var Californiaclient =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/assets/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.3.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		noModule: true
	};

	function DOMEval( code, doc, node ) {
		doc = doc || document;

		var i,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {
				if ( node[ i ] ) {
					script[ i ] = node[ i ];
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.3.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		div.style.position = "absolute";
		scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5
		) );
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),
		val = curCSS( elem, dimension, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox;

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = valueIsBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ dimension ] );

	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	if ( val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

		val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

		// offsetWidth/offsetHeight provide border-box values
		valueIsBorderBox = true;
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),
				isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra && boxModelAdjustment(
					elem,
					dimension,
					extra,
					isBorderBox,
					styles
				);

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && support.scrollboxSize() === styles.position ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {
        // CommonJS
        factory(exports);
    } else {
        // Browser globals
        factory(root.maquette = {});
    }
}(this, function (exports) {
    'use strict';
    // Comment that is displayed in the API documentation for the maquette module:
    /**
 * Welcome to the API documentation of the **maquette** library.
 *
 * [[http://maquettejs.org/|To the maquette homepage]]
 */
    Object.defineProperty(exports, '__esModule', { value: true });
    var NAMESPACE_W3 = 'http://www.w3.org/';
    var NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';
    var NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';
    // Utilities
    var emptyArray = [];
    var extend = function (base, overrides) {
        var result = {};
        Object.keys(base).forEach(function (key) {
            result[key] = base[key];
        });
        if (overrides) {
            Object.keys(overrides).forEach(function (key) {
                result[key] = overrides[key];
            });
        }
        return result;
    };
    // Hyperscript helper functions
    var same = function (vnode1, vnode2) {
        if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {
            return false;
        }
        if (vnode1.properties && vnode2.properties) {
            if (vnode1.properties.key !== vnode2.properties.key) {
                return false;
            }
            return vnode1.properties.bind === vnode2.properties.bind;
        }
        return !vnode1.properties && !vnode2.properties;
    };
    var toTextVNode = function (data) {
        return {
            vnodeSelector: '',
            properties: undefined,
            children: undefined,
            text: data.toString(),
            domNode: null
        };
    };
    var appendChildren = function (parentSelector, insertions, main) {
        for (var i = 0, length_1 = insertions.length; i < length_1; i++) {
            var item = insertions[i];
            if (Array.isArray(item)) {
                appendChildren(parentSelector, item, main);
            } else {
                if (item !== null && item !== undefined) {
                    if (!item.hasOwnProperty('vnodeSelector')) {
                        item = toTextVNode(item);
                    }
                    main.push(item);
                }
            }
        }
    };
    // Render helper functions
    var missingTransition = function () {
        throw new Error('Provide a transitions object to the projectionOptions to do animations');
    };
    var DEFAULT_PROJECTION_OPTIONS = {
        namespace: undefined,
        eventHandlerInterceptor: undefined,
        styleApplyer: function (domNode, styleName, value) {
            // Provides a hook to add vendor prefixes for browsers that still need it.
            domNode.style[styleName] = value;
        },
        transitions: {
            enter: missingTransition,
            exit: missingTransition
        }
    };
    var applyDefaultProjectionOptions = function (projectorOptions) {
        return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);
    };
    var checkStyleValue = function (styleValue) {
        if (typeof styleValue !== 'string') {
            throw new Error('Style values must be strings');
        }
    };
    var setProperties = function (domNode, properties, projectionOptions) {
        if (!properties) {
            return;
        }
        var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;
        var propNames = Object.keys(properties);
        var propCount = propNames.length;
        var _loop_1 = function (i) {
            var propName = propNames[i];
            /* tslint:disable:no-var-keyword: edge case */
            var propValue = properties[propName];
            /* tslint:enable:no-var-keyword */
            if (propName === 'className') {
                throw new Error('Property "className" is not supported, use "class".');
            } else if (propName === 'class') {
                propValue.split(/\s+/).forEach(function (token) {
                    return domNode.classList.add(token);
                });
            } else if (propName === 'classes') {
                // object with string keys and boolean values
                var classNames = Object.keys(propValue);
                var classNameCount = classNames.length;
                for (var j = 0; j < classNameCount; j++) {
                    var className = classNames[j];
                    if (propValue[className]) {
                        domNode.classList.add(className);
                    }
                }
            } else if (propName === 'styles') {
                // object with string keys and string (!) values
                var styleNames = Object.keys(propValue);
                var styleCount = styleNames.length;
                for (var j = 0; j < styleCount; j++) {
                    var styleName = styleNames[j];
                    var styleValue = propValue[styleName];
                    if (styleValue) {
                        checkStyleValue(styleValue);
                        projectionOptions.styleApplyer(domNode, styleName, styleValue);
                    }
                }
            } else if (propName !== 'key' && propValue !== null && propValue !== undefined) {
                var type = typeof propValue;
                if (type === 'function') {
                    if (propName.lastIndexOf('on', 0) === 0) {
                        if (eventHandlerInterceptor) {
                            propValue = eventHandlerInterceptor(propName, propValue, domNode, properties);    // intercept eventhandlers
                        }
                        if (propName === 'oninput') {
                            (function () {
                                // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput
                                var oldPropValue = propValue;
                                propValue = function (evt) {
                                    oldPropValue.apply(this, [evt]);
                                    evt.target['oninput-value'] = evt.target.value;    // may be HTMLTextAreaElement as well
                                };
                            }());
                        }
                        domNode[propName] = propValue;
                    }
                } else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {
                    if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {
                        domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);
                    } else {
                        domNode.setAttribute(propName, propValue);
                    }
                } else {
                    domNode[propName] = propValue;
                }
            }
        };
        for (var i = 0; i < propCount; i++) {
            _loop_1(i);
        }
    };
    var updateProperties = function (domNode, previousProperties, properties, projectionOptions) {
        if (!properties) {
            return;
        }
        var propertiesUpdated = false;
        var propNames = Object.keys(properties);
        var propCount = propNames.length;
        for (var i = 0; i < propCount; i++) {
            var propName = propNames[i];
            // assuming that properties will be nullified instead of missing is by design
            var propValue = properties[propName];
            var previousValue = previousProperties[propName];
            if (propName === 'class') {
                if (previousValue !== propValue) {
                    throw new Error('"class" property may not be updated. Use the "classes" property for conditional css classes.');
                }
            } else if (propName === 'classes') {
                var classList = domNode.classList;
                var classNames = Object.keys(propValue);
                var classNameCount = classNames.length;
                for (var j = 0; j < classNameCount; j++) {
                    var className = classNames[j];
                    var on = !!propValue[className];
                    var previousOn = !!previousValue[className];
                    if (on === previousOn) {
                        continue;
                    }
                    propertiesUpdated = true;
                    if (on) {
                        classList.add(className);
                    } else {
                        classList.remove(className);
                    }
                }
            } else if (propName === 'styles') {
                var styleNames = Object.keys(propValue);
                var styleCount = styleNames.length;
                for (var j = 0; j < styleCount; j++) {
                    var styleName = styleNames[j];
                    var newStyleValue = propValue[styleName];
                    var oldStyleValue = previousValue[styleName];
                    if (newStyleValue === oldStyleValue) {
                        continue;
                    }
                    propertiesUpdated = true;
                    if (newStyleValue) {
                        checkStyleValue(newStyleValue);
                        projectionOptions.styleApplyer(domNode, styleName, newStyleValue);
                    } else {
                        projectionOptions.styleApplyer(domNode, styleName, '');
                    }
                }
            } else {
                if (!propValue && typeof previousValue === 'string') {
                    propValue = '';
                }
                if (propName === 'value') {
                    var domValue = domNode[propName];
                    if (domValue !== propValue    // The 'value' in the DOM tree !== newValue
&& (domNode['oninput-value'] ? domValue === domNode['oninput-value']    // If the last reported value to 'oninput' does not match domValue, do nothing and wait for oninput
 : propValue !== previousValue    // Only update the value if the vdom changed
)) {
                        domNode[propName] = propValue;
                        // Reset the value, even if the virtual DOM did not change
                        domNode['oninput-value'] = undefined;
                    }
                    // else do not update the domNode, otherwise the cursor position would be changed
                    if (propValue !== previousValue) {
                        propertiesUpdated = true;
                    }
                } else if (propValue !== previousValue) {
                    var type = typeof propValue;
                    if (type === 'function') {
                        throw new Error('Functions may not be updated on subsequent renders (property: ' + propName + '). Hint: declare event handler functions outside the render() function.');
                    }
                    if (type === 'string' && propName !== 'innerHTML') {
                        if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {
                            domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);
                        } else if (propName === 'role' && propValue === '') {
                            domNode.removeAttribute(propName);
                        } else {
                            domNode.setAttribute(propName, propValue);
                        }
                    } else {
                        if (domNode[propName] !== propValue) {
                            domNode[propName] = propValue;
                        }
                    }
                    propertiesUpdated = true;
                }
            }
        }
        return propertiesUpdated;
    };
    var findIndexOfChild = function (children, sameAs, start) {
        if (sameAs.vnodeSelector !== '') {
            // Never scan for text-nodes
            for (var i = start; i < children.length; i++) {
                if (same(children[i], sameAs)) {
                    return i;
                }
            }
        }
        return -1;
    };
    var nodeAdded = function (vNode, transitions) {
        if (vNode.properties) {
            var enterAnimation = vNode.properties.enterAnimation;
            if (enterAnimation) {
                if (typeof enterAnimation === 'function') {
                    enterAnimation(vNode.domNode, vNode.properties);
                } else {
                    transitions.enter(vNode.domNode, vNode.properties, enterAnimation);
                }
            }
        }
    };
    var nodeToRemove = function (vNode, transitions) {
        var domNode = vNode.domNode;
        if (vNode.properties) {
            var exitAnimation = vNode.properties.exitAnimation;
            if (exitAnimation) {
                domNode.style.pointerEvents = 'none';
                var removeDomNode = function () {
                    if (domNode.parentNode) {
                        domNode.parentNode.removeChild(domNode);
                    }
                };
                if (typeof exitAnimation === 'function') {
                    exitAnimation(domNode, removeDomNode, vNode.properties);
                    return;
                } else {
                    transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);
                    return;
                }
            }
        }
        if (domNode.parentNode) {
            domNode.parentNode.removeChild(domNode);
        }
    };
    var checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {
        var childNode = childNodes[indexToCheck];
        if (childNode.vnodeSelector === '') {
            return;    // Text nodes need not be distinguishable
        }
        var properties = childNode.properties;
        var key = properties ? properties.key === undefined ? properties.bind : properties.key : undefined;
        if (!key) {
            for (var i = 0; i < childNodes.length; i++) {
                if (i !== indexToCheck) {
                    var node = childNodes[i];
                    if (same(node, childNode)) {
                        if (operation === 'added') {
                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'added, but there is now more than one. You must add unique key properties to make them distinguishable.');
                        } else {
                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'removed, but there were more than one. You must add unique key properties to make them distinguishable.');
                        }
                    }
                }
            }
        }
    };
    var createDom;
    var updateDom;
    var updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {
        if (oldChildren === newChildren) {
            return false;
        }
        oldChildren = oldChildren || emptyArray;
        newChildren = newChildren || emptyArray;
        var oldChildrenLength = oldChildren.length;
        var newChildrenLength = newChildren.length;
        var transitions = projectionOptions.transitions;
        var oldIndex = 0;
        var newIndex = 0;
        var i;
        var textUpdated = false;
        while (newIndex < newChildrenLength) {
            var oldChild = oldIndex < oldChildrenLength ? oldChildren[oldIndex] : undefined;
            var newChild = newChildren[newIndex];
            if (oldChild !== undefined && same(oldChild, newChild)) {
                textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;
                oldIndex++;
            } else {
                var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);
                if (findOldIndex >= 0) {
                    // Remove preceding missing children
                    for (i = oldIndex; i < findOldIndex; i++) {
                        nodeToRemove(oldChildren[i], transitions);
                        checkDistinguishable(oldChildren, i, vnode, 'removed');
                    }
                    textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;
                    oldIndex = findOldIndex + 1;
                } else {
                    // New child
                    createDom(newChild, domNode, oldIndex < oldChildrenLength ? oldChildren[oldIndex].domNode : undefined, projectionOptions);
                    nodeAdded(newChild, transitions);
                    checkDistinguishable(newChildren, newIndex, vnode, 'added');
                }
            }
            newIndex++;
        }
        if (oldChildrenLength > oldIndex) {
            // Remove child fragments
            for (i = oldIndex; i < oldChildrenLength; i++) {
                nodeToRemove(oldChildren[i], transitions);
                checkDistinguishable(oldChildren, i, vnode, 'removed');
            }
        }
        return textUpdated;
    };
    var addChildren = function (domNode, children, projectionOptions) {
        if (!children) {
            return;
        }
        for (var i = 0; i < children.length; i++) {
            createDom(children[i], domNode, undefined, projectionOptions);
        }
    };
    var initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {
        addChildren(domNode, vnode.children, projectionOptions);
        // children before properties, needed for value property of <select>.
        if (vnode.text) {
            domNode.textContent = vnode.text;
        }
        setProperties(domNode, vnode.properties, projectionOptions);
        if (vnode.properties && vnode.properties.afterCreate) {
            vnode.properties.afterCreate.apply(vnode.properties.bind || vnode.properties, [
                domNode,
                projectionOptions,
                vnode.vnodeSelector,
                vnode.properties,
                vnode.children
            ]);
        }
    };
    createDom = function (vnode, parentNode, insertBefore, projectionOptions) {
        var domNode, i, c, start = 0, type, found;
        var vnodeSelector = vnode.vnodeSelector;
        var doc = parentNode.ownerDocument;
        if (vnodeSelector === '') {
            domNode = vnode.domNode = doc.createTextNode(vnode.text);
            if (insertBefore !== undefined) {
                parentNode.insertBefore(domNode, insertBefore);
            } else {
                parentNode.appendChild(domNode);
            }
        } else {
            for (i = 0; i <= vnodeSelector.length; ++i) {
                c = vnodeSelector.charAt(i);
                if (i === vnodeSelector.length || c === '.' || c === '#') {
                    type = vnodeSelector.charAt(start - 1);
                    found = vnodeSelector.slice(start, i);
                    if (type === '.') {
                        domNode.classList.add(found);
                    } else if (type === '#') {
                        domNode.id = found;
                    } else {
                        if (found === 'svg') {
                            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });
                        }
                        if (projectionOptions.namespace !== undefined) {
                            domNode = vnode.domNode = doc.createElementNS(projectionOptions.namespace, found);
                        } else {
                            domNode = vnode.domNode = vnode.domNode || doc.createElement(found);
                            if (found === 'input' && vnode.properties && vnode.properties.type !== undefined) {
                                // IE8 and older don't support setting input type after the DOM Node has been added to the document
                                domNode.setAttribute('type', vnode.properties.type);
                            }
                        }
                        if (insertBefore !== undefined) {
                            parentNode.insertBefore(domNode, insertBefore);
                        } else if (domNode.parentNode !== parentNode) {
                            parentNode.appendChild(domNode);
                        }
                    }
                    start = i + 1;
                }
            }
            initPropertiesAndChildren(domNode, vnode, projectionOptions);
        }
    };
    updateDom = function (previous, vnode, projectionOptions) {
        var domNode = previous.domNode;
        var textUpdated = false;
        if (previous === vnode) {
            return false;    // By contract, VNode objects may not be modified anymore after passing them to maquette
        }
        var updated = false;
        if (vnode.vnodeSelector === '') {
            if (vnode.text !== previous.text) {
                var newVNode = domNode.ownerDocument.createTextNode(vnode.text);
                domNode.parentNode.replaceChild(newVNode, domNode);
                vnode.domNode = newVNode;
                textUpdated = true;
                return textUpdated;
            }
        } else {
            if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) {
                projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });
            }
            if (previous.text !== vnode.text) {
                updated = true;
                if (vnode.text === undefined) {
                    domNode.removeChild(domNode.firstChild);    // the only textnode presumably
                } else {
                    domNode.textContent = vnode.text;
                }
            }
            updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;
            updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;
            if (vnode.properties && vnode.properties.afterUpdate) {
                vnode.properties.afterUpdate.apply(vnode.properties.bind || vnode.properties, [
                    domNode,
                    projectionOptions,
                    vnode.vnodeSelector,
                    vnode.properties,
                    vnode.children
                ]);
            }
        }
        if (updated && vnode.properties && vnode.properties.updateAnimation) {
            vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);
        }
        vnode.domNode = previous.domNode;
        return textUpdated;
    };
    var createProjection = function (vnode, projectionOptions) {
        return {
            update: function (updatedVnode) {
                if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {
                    throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');
                }
                updateDom(vnode, updatedVnode, projectionOptions);
                vnode = updatedVnode;
            },
            domNode: vnode.domNode
        };
    };
    // The other two parameters are not added here, because the Typescript compiler creates surrogate code for destructuring 'children'.
    exports.h = function (selector) {
        var properties = arguments[1];
        if (typeof selector !== 'string') {
            throw new Error();
        }
        var childIndex = 1;
        if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {
            childIndex = 2;
        } else {
            // Optional properties argument was omitted
            properties = undefined;
        }
        var text;
        var children;
        var argsLength = arguments.length;
        // Recognize a common special case where there is only a single text node
        if (argsLength === childIndex + 1) {
            var onlyChild = arguments[childIndex];
            if (typeof onlyChild === 'string') {
                text = onlyChild;
            } else if (onlyChild !== undefined && onlyChild !== null && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {
                text = onlyChild[0];
            }
        }
        if (text === undefined) {
            children = [];
            for (; childIndex < argsLength; childIndex++) {
                var child = arguments[childIndex];
                if (child === null || child === undefined) {
                } else if (Array.isArray(child)) {
                    appendChildren(selector, child, children);
                } else if (child.hasOwnProperty('vnodeSelector')) {
                    children.push(child);
                } else {
                    children.push(toTextVNode(child));
                }
            }
        }
        return {
            vnodeSelector: selector,
            properties: properties,
            children: children,
            text: text === '' ? undefined : text,
            domNode: null
        };
    };
    /**
 * Contains simple low-level utility functions to manipulate the real DOM.
 */
    exports.dom = {
        /**
     * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in
     * its [[Projection.domNode|domNode]] property.
     * This is a low-level method. Users will typically use a [[Projector]] instead.
     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]
     * objects may only be rendered once.
     * @param projectionOptions - Options to be used to create and update the projection.
     * @returns The [[Projection]] which also contains the DOM Node that was created.
     */
        create: function (vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            createDom(vnode, document.createElement('div'), undefined, projectionOptions);
            return createProjection(vnode, projectionOptions);
        },
        /**
     * Appends a new child node to the DOM which is generated from a [[VNode]].
     * This is a low-level method. Users will typically use a [[Projector]] instead.
     * @param parentNode - The parent node for the new child node.
     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]
     * objects may only be rendered once.
     * @param projectionOptions - Options to be used to create and update the [[Projection]].
     * @returns The [[Projection]] that was created.
     */
        append: function (parentNode, vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            createDom(vnode, parentNode, undefined, projectionOptions);
            return createProjection(vnode, projectionOptions);
        },
        /**
     * Inserts a new DOM node which is generated from a [[VNode]].
     * This is a low-level method. Users wil typically use a [[Projector]] instead.
     * @param beforeNode - The node that the DOM Node is inserted before.
     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.
     * NOTE: [[VNode]] objects may only be rendered once.
     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].
     * @returns The [[Projection]] that was created.
     */
        insertBefore: function (beforeNode, vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);
            return createProjection(vnode, projectionOptions);
        },
        /**
     * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.
     * This means that the virtual DOM and the real DOM will have one overlapping element.
     * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.
     * This is a low-level method. Users wil typically use a [[Projector]] instead.
     * @param element - The existing element to adopt as the root of the new virtual DOM. Existing attributes and child nodes are preserved.
     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects
     * may only be rendered once.
     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].
     * @returns The [[Projection]] that was created.
     */
        merge: function (element, vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            vnode.domNode = element;
            initPropertiesAndChildren(element, vnode, projectionOptions);
            return createProjection(vnode, projectionOptions);
        },
        /**
     * Replaces an existing DOM node with a node generated from a [[VNode]].
     * This is a low-level method. Users will typically use a [[Projector]] instead.
     * @param element - The node for the [[VNode]] to replace.
     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]
     * objects may only be rendered once.
     * @param projectionOptions - Options to be used to create and update the [[Projection]].
     * @returns The [[Projection]] that was created.
     */
        replace: function (element, vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            createDom(vnode, element.parentNode, element, projectionOptions);
            element.parentNode.removeChild(element);
            return createProjection(vnode, projectionOptions);
        }
    };
    /**
 * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.
 * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.
 * For more information, see [[CalculationCache]].
 *
 * @param <Result> The type of the value that is cached.
 */
    exports.createCache = function () {
        var cachedInputs;
        var cachedOutcome;
        return {
            invalidate: function () {
                cachedOutcome = undefined;
                cachedInputs = undefined;
            },
            result: function (inputs, calculation) {
                if (cachedInputs) {
                    for (var i = 0; i < inputs.length; i++) {
                        if (cachedInputs[i] !== inputs[i]) {
                            cachedOutcome = undefined;
                        }
                    }
                }
                if (!cachedOutcome) {
                    cachedOutcome = calculation();
                    cachedInputs = inputs;
                }
                return cachedOutcome;
            }
        };
    };
    /**
 * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.
 * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.
 *
 * @param <Source>       The type of source items. A database-record for instance.
 * @param <Target>       The type of target items. A [[Component]] for instance.
 * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.
 * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical
 *                       to the `callback` argument in `Array.map(callback)`.
 * @param updateResult   `function(source, target, index)` that updates a result to an updated source.
 */
    exports.createMapping = function (getSourceKey, createResult, updateResult) {
        var keys = [];
        var results = [];
        return {
            results: results,
            map: function (newSources) {
                var newKeys = newSources.map(getSourceKey);
                var oldTargets = results.slice();
                var oldIndex = 0;
                for (var i = 0; i < newSources.length; i++) {
                    var source = newSources[i];
                    var sourceKey = newKeys[i];
                    if (sourceKey === keys[oldIndex]) {
                        results[i] = oldTargets[oldIndex];
                        updateResult(source, oldTargets[oldIndex], i);
                        oldIndex++;
                    } else {
                        var found = false;
                        for (var j = 1; j < keys.length + 1; j++) {
                            var searchIndex = (oldIndex + j) % keys.length;
                            if (keys[searchIndex] === sourceKey) {
                                results[i] = oldTargets[searchIndex];
                                updateResult(newSources[i], oldTargets[searchIndex], i);
                                oldIndex = searchIndex + 1;
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            results[i] = createResult(source, i);
                        }
                    }
                }
                results.length = newSources.length;
                keys = newKeys;
            }
        };
    };
    /**
 * Creates a [[Projector]] instance using the provided projectionOptions.
 *
 * For more information, see [[Projector]].
 *
 * @param projectorOptions   Options that influence how the DOM is rendered and updated.
 */
    exports.createProjector = function (projectorOptions) {
        var projector;
        var projectionOptions = applyDefaultProjectionOptions(projectorOptions);
        projectionOptions.eventHandlerInterceptor = function (propertyName, eventHandler, domNode, properties) {
            return function () {
                // intercept function calls (event handlers) to do a render afterwards.
                projector.scheduleRender();
                return eventHandler.apply(properties.bind || this, arguments);
            };
        };
        var renderCompleted = true;
        var scheduled;
        var stopped = false;
        var projections = [];
        var renderFunctions = [];
        // matches the projections array
        var doRender = function () {
            scheduled = undefined;
            if (!renderCompleted) {
                return;    // The last render threw an error, it should be logged in the browser console.
            }
            renderCompleted = false;
            for (var i = 0; i < projections.length; i++) {
                var updatedVnode = renderFunctions[i]();
                projections[i].update(updatedVnode);
            }
            renderCompleted = true;
        };
        projector = {
            renderNow: doRender,
            scheduleRender: function () {
                if (!scheduled && !stopped) {
                    scheduled = requestAnimationFrame(doRender);
                }
            },
            stop: function () {
                if (scheduled) {
                    cancelAnimationFrame(scheduled);
                    scheduled = undefined;
                }
                stopped = true;
            },
            resume: function () {
                stopped = false;
                renderCompleted = true;
                projector.scheduleRender();
            },
            append: function (parentNode, renderMaquetteFunction) {
                projections.push(exports.dom.append(parentNode, renderMaquetteFunction(), projectionOptions));
                renderFunctions.push(renderMaquetteFunction);
            },
            insertBefore: function (beforeNode, renderMaquetteFunction) {
                projections.push(exports.dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));
                renderFunctions.push(renderMaquetteFunction);
            },
            merge: function (domNode, renderMaquetteFunction) {
                projections.push(exports.dom.merge(domNode, renderMaquetteFunction(), projectionOptions));
                renderFunctions.push(renderMaquetteFunction);
            },
            replace: function (domNode, renderMaquetteFunction) {
                projections.push(exports.dom.replace(domNode, renderMaquetteFunction(), projectionOptions));
                renderFunctions.push(renderMaquetteFunction);
            },
            detach: function (renderMaquetteFunction) {
                for (var i = 0; i < renderFunctions.length; i++) {
                    if (renderFunctions[i] === renderMaquetteFunction) {
                        renderFunctions.splice(i, 1);
                        return projections.splice(i, 1)[0];
                    }
                }
                throw new Error('renderMaquetteFunction was not found');
            }
        };
        return projector;
    };
}));
//# sourceMappingURL=maquette.js.map


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function __export(m) {
    for (var p in m) {
        if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(15));
__export(__webpack_require__(17));
__export(__webpack_require__(18));
__export(__webpack_require__(19));
__export(__webpack_require__(20));
__export(__webpack_require__(21));
__export(__webpack_require__(22));
__export(__webpack_require__(23));
__export(__webpack_require__(24));
__export(__webpack_require__(25));
__export(__webpack_require__(26));
__export(__webpack_require__(27));
__export(__webpack_require__(28));
__export(__webpack_require__(29));
__export(__webpack_require__(30));
__export(__webpack_require__(31));
__export(__webpack_require__(32));
__export(__webpack_require__(33));
__export(__webpack_require__(34));
__export(__webpack_require__(35));
__export(__webpack_require__(36));

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var maquette = __webpack_require__(1);
var h = maquette.h;
var CaliforniaGenerated_1 = __webpack_require__(2);
var PagePreview_1 = __webpack_require__(37);
var PropertyBar_1 = __webpack_require__(39);
var CaliforniaRouter_1 = __webpack_require__(41);
var ClientState_1 = __webpack_require__(4);
var CaliforniaClientPartialData_1 = __webpack_require__(42);
exports.DEFAULT_EXCEPTION = "unexpected error";
exports.UI_Z_INDEX = 11;
var RESIZE_HANDLER_DELAY_MS = 200;
function getArrayForEnum(targetEnum) {
    return Object.keys(targetEnum).map(function (key) {
        return targetEnum[key];
    }).filter(function (value) {
        return typeof value === "string";
    });
}
exports.getArrayForEnum = getArrayForEnum;
;
function parseIntFromAttribute(element, attributeName) {
    if (element === undefined) {
        console.log("cannot read attribute: element is null");
    }
    var attr = element.attributes.getNamedItem(attributeName);
    if (attr === null) {
        console.log("could not find attribute " + attributeName + " on target");
        console.log(element);
        return 0;
    } else {
        return parseInt(attr.value);
    }
}
exports.parseIntFromAttribute = parseIntFromAttribute;
;
function parseStringFromAttribute(element, attributeName) {
    if (element === undefined) {
        console.log("cannot read attribute: element is null");
    }
    var attr = element.attributes.getNamedItem(attributeName);
    if (attr === null) {
        console.log("could not find attribute " + attributeName + " on target");
        console.log(element);
        return "";
    } else {
        return attr.value;
    }
}
exports.parseStringFromAttribute = parseStringFromAttribute;
;
var CaliforniaApp = function () {
    function CaliforniaApp() {
        var _this = this;
        this.californiaMainDiv = document.getElementById("california-main");
        this.styleSheet = document.getElementById("california-styles").sheet;
        this.pagePreviewHolder = undefined;
        this._propertyBars = [];
        this._propertyBarVMs = [];
        this._propertyBarBoxTreeDomReferences = [];
        this._propertyBarBoxTreeScrollHandled = [];
        this.isAjaxRequestRunning = false;
        this.resizeRtime = new Date();
        this.resizeTimeout = false;
        this.navigationHeigthPx = 32;
        this.controlAreaWidthPx = 500;
        this._propertyBarCount = 4;
        this.clientData = {
            CurrentRevision: 0,
            StatusText: "",
            CaliforniaEvent: CaliforniaGenerated_1.CaliforniaEvent.ReadInitialClientData,
            CaliforniaProject: new CaliforniaGenerated_1.CaliforniaProject(),
            AllCssProperties: [],
            StyleAtomCssPropertyMapping: {},
            UrlToReadAndEdit: "",
            UrlToReadOnly: "",
            PartialUpdate: new CaliforniaClientPartialData_1.CaliforniaClientPartialData()
        };
        this.resizeCheckHandler = function () {
            var curTime = Date.now();
            if (curTime - CaliforniaApp.CaliforniaAppInstance.resizeRtime.getMilliseconds() < RESIZE_HANDLER_DELAY_MS) {
                setTimeout(CaliforniaApp.CaliforniaAppInstance.resizeCheckHandler, RESIZE_HANDLER_DELAY_MS);
            } else {
                CaliforniaApp.CaliforniaAppInstance.resizeChangedHandler();
                CaliforniaApp.CaliforniaAppInstance.resizeTimeout = false;
            }
        };
        this.resizeChangedHandler = function () {
            CaliforniaApp.CaliforniaAppInstance.state.overrideResponsiveDeviceId = 0;
            CaliforniaApp.CaliforniaAppInstance.router.setupUiForDevice();
            CaliforniaApp.CaliforniaAppInstance.projector.scheduleRender();
        };
        this.renderCaliforniaApp = function () {
            var appStyles = {
                "width": "100%",
                "max-width": "100%",
                "height": "100%",
                "max-height": "100%",
                "display": "flex",
                "flex-flow": "row nowrap"
            };
            var renderedPropertyBars = [];
            var maxRenderedPropertyBarCount = _this.state.visiblePropertyBarMaxCount > _this._propertyBarCount ? _this._propertyBarCount : _this.state.visiblePropertyBarMaxCount;
            for (var i = 0; i < maxRenderedPropertyBarCount; i++) {
                renderedPropertyBars.push(_this._propertyBars[i].renderPropertyBar());
            }
            return h(
                "div",
                { styles: appStyles },
                _this.pagePreview.renderPreviewArea(),
                _this.state.isHideUserInterface || _this.state.editViewMode === ClientState_1.EditViewMode.PagePreviewOnly ? undefined : renderedPropertyBars,
                _this._propertyBars[0].renderPropertyBarPoppersRenderOnce()
            );
        };
        this.projector = maquette.createProjector();
        this.pagePreview = new PagePreview_1.PagePreview(this);
        this.pagePreviewVM = this.pagePreview.viewModel;
        for (var i = 0; i < this.propertyBarCount; i++) {
            var propertyBar = new PropertyBar_1.PropertyBar(this, i);
            this._propertyBars.push(propertyBar);
            this._propertyBarVMs.push(propertyBar.viewModel);
            this._propertyBarBoxTreeDomReferences.push(undefined);
            this._propertyBarBoxTreeScrollHandled.push(false);
        }
        this.controller = new CaliforniaGenerated_1.CaliforniaController(this);
        this.router = new CaliforniaRouter_1.CaliforniaRouter(this);
        this.state = new ClientState_1.ClientState(this);
        this.controller.InitialClientDataJson(new Date().toString()).done(function (data) {
            CaliforniaApp.CaliforniaAppInstance.router.updateData(data, true);
        }).fail(function () {
            console.log("could not get data");
        });
        document.addEventListener("DOMContentLoaded", function () {
            CaliforniaApp.CaliforniaAppInstance.projector.append(CaliforniaApp.CaliforniaAppInstance.californiaMainDiv, CaliforniaApp.CaliforniaAppInstance.renderCaliforniaApp);
        });
        window.addEventListener("resize", function () {
            CaliforniaApp.CaliforniaAppInstance.resizeRtime = new Date();
            if (CaliforniaApp.CaliforniaAppInstance.resizeTimeout === false) {
                CaliforniaApp.CaliforniaAppInstance.resizeTimeout = true;
                setTimeout(CaliforniaApp.CaliforniaAppInstance.resizeCheckHandler, RESIZE_HANDLER_DELAY_MS);
            }
        });
    }
    ;
    Object.defineProperty(CaliforniaApp.prototype, "propertyBarCount", {
        get: function get() {
            return this._propertyBarCount;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(CaliforniaApp.prototype, "propertyBars", {
        get: function get() {
            return this._propertyBars;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(CaliforniaApp.prototype, "propertyBarVMs", {
        get: function get() {
            return this._propertyBarVMs;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(CaliforniaApp.prototype, "propertyBarBoxTreeDomReferences", {
        get: function get() {
            return this._propertyBarBoxTreeDomReferences;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(CaliforniaApp.prototype, "propertyBarBoxTreeScrollHandled", {
        get: function get() {
            return this._propertyBarBoxTreeScrollHandled;
        },
        enumerable: true,
        configurable: true
    });
    ;
    return CaliforniaApp;
}();
exports.CaliforniaApp = CaliforniaApp;
;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var CaliforniaGenerated_1 = __webpack_require__(2);
var PropertyBarVM_1 = __webpack_require__(5);
var currentApp;
var currentClientState;
exports.STATIC_MARGIN_PX = 25;
var SelectionMode;
(function (SelectionMode) {
    SelectionMode[SelectionMode["Styles"] = 0] = "Styles";
    SelectionMode[SelectionMode["Content"] = 1] = "Content";
})(SelectionMode = exports.SelectionMode || (exports.SelectionMode = {}));
;
var ReadyState;
(function (ReadyState) {
    ReadyState[ReadyState["Ok"] = 0] = "Ok";
    ReadyState[ReadyState["Pending"] = 1] = "Pending";
})(ReadyState = exports.ReadyState || (exports.ReadyState = {}));
;
var EditViewMode;
(function (EditViewMode) {
    EditViewMode[EditViewMode["Default"] = 0] = "Default";
    EditViewMode[EditViewMode["SidebarOnly"] = 1] = "SidebarOnly";
    EditViewMode[EditViewMode["PagePreviewOnly"] = 2] = "PagePreviewOnly";
})(EditViewMode = exports.EditViewMode || (exports.EditViewMode = {}));
;
var ClientState = function () {
    function ClientState(californiaAppArg) {
        this.isDataLoaded = false;
        this.isHideUserInterface = false;
        this.editViewMode = EditViewMode.Default;
        this.currentSelectionMode = SelectionMode.Content;
        this.currentReadyState = ReadyState.Ok;
        this.isJaxOn = false;
        this.lowestWidthThresholdResponsiveDeviceId = 0;
        this.highestWidthThresholdResponsiveDeviceId = 0;
        this.specialStyleHolder = undefined;
        this.currentResponsiveDeviceId = 0;
        this.noneResponsiveDeviceId = 0;
        this.defaultSymmetricPagePreviewHolderMarginPx = exports.STATIC_MARGIN_PX;
        this.overrideResponsiveDeviceId = 0;
        this.isEnoughAvailableSpacePagePreview = true;
        this.targetPagePreviewHolderMarginPx = exports.STATIC_MARGIN_PX;
        this.visiblePropertyBarMaxCount = 2;
        this.popupTargetPropertyBarIndex = 0;
        this.currentTransactionMode = PropertyBarVM_1.TransactionMode.MoveLayoutMoleculeIntoLayoutMolecule;
        this.highlightedLayoutBaseId = 0;
        this.isSelectAllTextArea = false;
        this.lastCommand = CaliforniaGenerated_1.CaliforniaEvent.ReadInitialClientData;
        this.lastCaliforniaEventData = [];
        this.selectedLayoutBaseId = 0;
        this.preselectedLayoutBaseId = 0;
        this.isDrawHelperLines = false;
        this.hoveredBoxTreeLayoutBaseId = 0;
        this.hoveredPagePreviewLayoutBaseId = 0;
        this.hoveredInsertLayoutBaseId = 0;
        this.backupSortOrder = undefined;
        this.newBoxStyleMoleculeId = 0;
        currentClientState = this;
        currentApp = californiaAppArg;
    }
    ;
    return ClientState;
}();
exports.ClientState = ClientState;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var maquette = __webpack_require__(1);
var h = maquette.h;
var CaliforniaGenerated_1 = __webpack_require__(2);
var PropertyBarMode;
(function (PropertyBarMode) {
    PropertyBarMode[PropertyBarMode["None"] = 0] = "None";
    PropertyBarMode[PropertyBarMode["CaliforniaView"] = 1] = "CaliforniaView";
    PropertyBarMode[PropertyBarMode["LayoutMolecules"] = 2] = "LayoutMolecules";
    PropertyBarMode[PropertyBarMode["LayoutAtoms"] = 3] = "LayoutAtoms";
    PropertyBarMode[PropertyBarMode["AllStyleQuantums"] = 4] = "AllStyleQuantums";
    PropertyBarMode[PropertyBarMode["AllStyleAtoms"] = 5] = "AllStyleAtoms";
    PropertyBarMode[PropertyBarMode["AllStyleMolecules"] = 6] = "AllStyleMolecules";
    PropertyBarMode[PropertyBarMode["StyleMolecule"] = 7] = "StyleMolecule";
    PropertyBarMode[PropertyBarMode["AllLayoutMolecules"] = 8] = "AllLayoutMolecules";
    PropertyBarMode[PropertyBarMode["LayoutBase"] = 9] = "LayoutBase";
    PropertyBarMode[PropertyBarMode["AllCaliforniaViews"] = 10] = "AllCaliforniaViews";
})(PropertyBarMode = exports.PropertyBarMode || (exports.PropertyBarMode = {}));
;
var PopupSecondaryMode;
(function (PopupSecondaryMode) {
    PopupSecondaryMode[PopupSecondaryMode["None"] = 0] = "None";
    PopupSecondaryMode[PopupSecondaryMode["SelectBoxIntoBox"] = 1] = "SelectBoxIntoBox";
    PopupSecondaryMode[PopupSecondaryMode["SelectBoxIntoBoxAtomInPlace"] = 2] = "SelectBoxIntoBoxAtomInPlace";
})(PopupSecondaryMode = exports.PopupSecondaryMode || (exports.PopupSecondaryMode = {}));
;
var PopupMode;
(function (PopupMode) {
    PopupMode[PopupMode["None"] = 0] = "None";
    PopupMode[PopupMode["AddCssProperty"] = 1] = "AddCssProperty";
    PopupMode[PopupMode["AllCssProperties"] = 2] = "AllCssProperties";
    PopupMode[PopupMode["UpdateCssValue"] = 3] = "UpdateCssValue";
    PopupMode[PopupMode["MatchingQuantums"] = 4] = "MatchingQuantums";
    PopupMode[PopupMode["UpdateCssQuantum"] = 5] = "UpdateCssQuantum";
    PopupMode[PopupMode["AllCssPropertiesForQuantum"] = 6] = "AllCssPropertiesForQuantum";
    PopupMode[PopupMode["InsertLayoutRowIntoView"] = 7] = "InsertLayoutRowIntoView";
    PopupMode[PopupMode["InsertLayoutAtomIntoBox"] = 8] = "InsertLayoutAtomIntoBox";
    PopupMode[PopupMode["SelectBox"] = 9] = "SelectBox";
    PopupMode[PopupMode["MoveStyleAtom"] = 10] = "MoveStyleAtom";
    PopupMode[PopupMode["ShareCaliforniaProject"] = 11] = "ShareCaliforniaProject";
    PopupMode[PopupMode["SelectInteractionTarget"] = 12] = "SelectInteractionTarget";
    PopupMode[PopupMode["SelectInteractionTargetLayoutFilter"] = 13] = "SelectInteractionTargetLayoutFilter";
    PopupMode[PopupMode["CaliforniaViewSelection"] = 14] = "CaliforniaViewSelection";
})(PopupMode = exports.PopupMode || (exports.PopupMode = {}));
;
var TransactionMode;
(function (TransactionMode) {
    TransactionMode[TransactionMode["MoveLayoutMoleculeIntoLayoutMolecule"] = 0] = "MoveLayoutMoleculeIntoLayoutMolecule";
    TransactionMode[TransactionMode["MoveLayoutMoleculeBeforeLayoutMolecule"] = 1] = "MoveLayoutMoleculeBeforeLayoutMolecule";
    TransactionMode[TransactionMode["SyncLayoutStylesImitating"] = 2] = "SyncLayoutStylesImitating";
})(TransactionMode = exports.TransactionMode || (exports.TransactionMode = {}));
var currentApp;
var PropertyBarVM = function () {
    function PropertyBarVM(propertyBarArg, targetIndex, californiaAppArg) {
        var _this = this;
        this.propertyBarVMIndex = -1;
        this.currentPropertyBarMode = PropertyBarMode.None;
        this.currentPopupMode = PopupMode.None;
        this.currentSecondaryPopupMode = PopupSecondaryMode.None;
        this.tempQuantumName = "Quantum";
        this.tempCssPropertyName = "";
        this.tempCssValue = "";
        this.lastUsedTempCssValue = "";
        this.tempPseudoSelector = "";
        this.tempCaliforniaViewName = "";
        this.tempCssValueForInteraction = "";
        this.selectedStyleAtomId = 0;
        this.selectedStyleValueId = 0;
        this.selectedStyleQuantumId = 0;
        this.selectedStyleMoleculeId = 0;
        this._selectedCaliforniaViewId = 0;
        this.selectedResponsiveDeviceId = 0;
        this.selectedStateModifier = "";
        this.selectedStyleAtomType = CaliforniaGenerated_1.StyleAtomType.Generic;
        this.selectedLayoutBaseIdForFilter = 0;
        this.selectedLayoutStyleInteraction = 0;
        this.tempOriginalContent = "";
        this.tempContent = "";
        this.editedLayoutAtomId = 0;
        this._deepestLevelActiveView = 0;
        this.selectedStyleAtomIdForPopup = 0;
        this.isSyncedWithBoxTreeToTheLeft = false;
        this.isSyncedWithPagePreview = false;
        this.setSelectedResponsiveDeviceId = function (responsiveDeviceId, isForce) {
            if (isForce || _this.currentVM.selectedResponsiveDeviceId == 0) {
                _this.currentVM.selectedResponsiveDeviceId = responsiveDeviceId;
            }
        };
        this.setSelectedCaliforniaView = function (californiaView, isForce) {
            if (isForce || _this.currentVM.selectedCaliforniaViewId == 0) {
                _this.currentVM._selectedCaliforniaViewId = californiaView.CaliforniaViewId;
                _this.currentVM._deepestLevelActiveView = californiaView.DeepestLevel;
                _this.currentVM.boxTreeProjector.map([californiaView]);
            } else {
                _this.currentVM.boxTreeProjector.map([]);
                _this.currentVM._deepestLevelActiveView = 0;
                _this.currentVM._selectedCaliforniaViewId = 0;
            }
        };
        this.updateData = function (styleQuantums, styleAtoms, styleMolecules, layoutMolecules, allCaliforniaViews, instanceableAtomsView, instanceableRowsView) {
            _this.currentVM.styleQuantumProjector.map(styleQuantums);
            _this.currentVM.styleAtomProjector.map(styleAtoms);
            _this.currentVM.styleMoleculeProjector.map(styleMolecules);
            _this.currentVM.allLayoutMoleculesProjector.map(layoutMolecules);
            _this.currentVM.allCaliforniaViewsProjector.map(allCaliforniaViews);
            _this.currentVM.instanceableAtomProjector.map(instanceableAtomsView.PlacedLayoutRows);
            _this.currentVM.instanceableMoleculeProjector.map(instanceableRowsView.PlacedLayoutRows);
        };
        currentApp = californiaAppArg;
        this.propertyBarVMIndex = targetIndex;
        this.styleQuantumProjector = propertyBarArg.renderStyleQuantumArray(propertyBarArg);
        this.styleAtomProjector = propertyBarArg.renderStyleAtomArray(propertyBarArg);
        this.styleMoleculeProjector = propertyBarArg.renderStyleMoleculeArray(propertyBarArg);
        this.instanceableAtomProjector = propertyBarArg.renderLayoutRowArray(propertyBarArg);
        this.instanceableMoleculeProjector = propertyBarArg.renderLayoutRowArray(propertyBarArg);
        this.allLayoutMoleculesProjector = propertyBarArg.renderLayoutMoleculeArray(propertyBarArg);
        this.allCaliforniaViewsProjector = propertyBarArg.renderCaliforniaViewArray(propertyBarArg);
        this.boxTreeProjector = propertyBarArg.renderBoxTreeForCaliforniaView(propertyBarArg);
    }
    ;
    Object.defineProperty(PropertyBarVM.prototype, "currentVM", {
        get: function get() {
            return currentApp.propertyBarVMs[this.propertyBarVMIndex];
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PropertyBarVM.prototype, "selectedCaliforniaViewId", {
        get: function get() {
            return this._selectedCaliforniaViewId;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PropertyBarVM.prototype, "deepestLevelActiveView", {
        get: function get() {
            return this._deepestLevelActiveView;
        },
        enumerable: true,
        configurable: true
    });
    ;
    PropertyBarVM.prototype.clearSelectedCaliforniaView = function (isClearWhenNonEqual, clearWhenEqualsCaliforniaViewId) {
        if (isClearWhenNonEqual === true || this.currentVM.selectedCaliforniaViewId == clearWhenEqualsCaliforniaViewId) {
            this.currentVM._selectedCaliforniaViewId = 0;
            this.currentVM._deepestLevelActiveView = 0;
            this.currentVM.boxTreeProjector.map([]);
        }
    };
    ;
    return PropertyBarVM;
}();
exports.PropertyBarVM = PropertyBarVM;

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(global) {/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.14.3
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
var timeoutDuration = 0;
for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
    timeoutDuration = 1;
    break;
  }
}

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var css = getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null;

  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent;
  // Skip hidden elements which don't have an offsetParent
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }

  // .offsetParent will return the closest TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
}

function getWindowSizes() {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
  var width = sizes.width || element.clientWidth || result.right - result.left;
  var height = sizes.height || element.clientHeight || result.bottom - result.top;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
  if (fixedPosition && parent.nodeName === 'HTML') {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop, 10);
    var marginLeft = parseFloat(styles.marginLeft, 10);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  return isFixed(getParentNode(element));
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }
  return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // NOTE: 1 DOM access here

  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  boundaries.left += padding;
  boundaries.top += padding;
  boundaries.right -= padding;
  boundaries.bottom -= padding;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var styles = getComputedStyle(element);
  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  data.positionFixed = this.options.positionFixed;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroy the popper
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicity asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger onUpdate callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  // Avoid blurry text by using full pixel integers.
  // For pixel-perfect positioning, top/bottom prefers rounded
  // values, while left/right prefers floored values.
  var offsets = {
    left: Math.floor(popper.left),
    top: Math.round(popper.top),
    bottom: Math.round(popper.bottom),
    right: Math.floor(popper.right)
  };

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    top = -offsetParentRect.height + offsets.bottom;
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    left = -offsetParentRect.width + offsets.right;
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjuction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-right` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself
  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification
  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];

  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

  // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;

  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unitless, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the height.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * An scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries"  or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper this makes sure the popper has always a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier, can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near eachothers
   * without leaving any gap between the two. Expecially useful when the arrow is
   * enabled and you want to assure it to point to its reference element.
   * It cares only about the first axis, you can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjuction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations).
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position,
     * the popper will never be placed outside of the defined boundaries
     * (except if keepTogether is enabled)
     */
    boundariesElement: 'viewport'
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define you own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the informations used by Popper.js
 * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overriden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass as 3rd argument an object with the same
 * structure of this object, example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated, this callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Create a new Popper.js instance
   * @class Popper
   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper.
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedule an update, it will run on the next UI update available
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

/* harmony default export */ __webpack_exports__["default"] = (Popper);
//# sourceMappingURL=popper.js.map

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(12)))

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var ContentAtomType;
(function (ContentAtomType) {
    ContentAtomType[ContentAtomType["Text"] = 0] = "Text";
    ContentAtomType[ContentAtomType["Html"] = 1] = "Html";
    ContentAtomType[ContentAtomType["Picture"] = 2] = "Picture";
    ContentAtomType[ContentAtomType["Link"] = 3] = "Link";
    ContentAtomType[ContentAtomType["NavLink"] = 4] = "NavLink";
})(ContentAtomType = exports.ContentAtomType || (exports.ContentAtomType = {}));

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(0);
__webpack_require__(9);
__webpack_require__(10);
__webpack_require__(11);
__webpack_require__(6);
__webpack_require__(13);
module.exports = __webpack_require__(14);


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery Validation Plugin v1.17.0
 *
 * https://jqueryvalidation.org/
 *
 * Copyright (c) 2017 Jrn Zaefferer
 * Released under the MIT license
 */
(function( factory ) {
	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof module === "object" && module.exports) {
		module.exports = factory( require( "jquery" ) );
	} else {
		factory( jQuery );
	}
}(function( $ ) {

$.extend( $.fn, {

	// https://jqueryvalidation.org/validate/
	validate: function( options ) {

		// If nothing is selected, return nothing; can't chain anyway
		if ( !this.length ) {
			if ( options && options.debug && window.console ) {
				console.warn( "Nothing selected, can't validate, returning nothing." );
			}
			return;
		}

		// Check if a validator for this form was already created
		var validator = $.data( this[ 0 ], "validator" );
		if ( validator ) {
			return validator;
		}

		// Add novalidate tag if HTML5.
		this.attr( "novalidate", "novalidate" );

		validator = new $.validator( options, this[ 0 ] );
		$.data( this[ 0 ], "validator", validator );

		if ( validator.settings.onsubmit ) {

			this.on( "click.validate", ":submit", function( event ) {

				// Track the used submit button to properly handle scripted
				// submits later.
				validator.submitButton = event.currentTarget;

				// Allow suppressing validation by adding a cancel class to the submit button
				if ( $( this ).hasClass( "cancel" ) ) {
					validator.cancelSubmit = true;
				}

				// Allow suppressing validation by adding the html5 formnovalidate attribute to the submit button
				if ( $( this ).attr( "formnovalidate" ) !== undefined ) {
					validator.cancelSubmit = true;
				}
			} );

			// Validate the form on submit
			this.on( "submit.validate", function( event ) {
				if ( validator.settings.debug ) {

					// Prevent form submit to be able to see console output
					event.preventDefault();
				}
				function handle() {
					var hidden, result;

					// Insert a hidden input as a replacement for the missing submit button
					// The hidden input is inserted in two cases:
					//   - A user defined a `submitHandler`
					//   - There was a pending request due to `remote` method and `stopRequest()`
					//     was called to submit the form in case it's valid
					if ( validator.submitButton && ( validator.settings.submitHandler || validator.formSubmitted ) ) {
						hidden = $( "<input type='hidden'/>" )
							.attr( "name", validator.submitButton.name )
							.val( $( validator.submitButton ).val() )
							.appendTo( validator.currentForm );
					}

					if ( validator.settings.submitHandler ) {
						result = validator.settings.submitHandler.call( validator, validator.currentForm, event );
						if ( hidden ) {

							// And clean up afterwards; thanks to no-block-scope, hidden can be referenced
							hidden.remove();
						}
						if ( result !== undefined ) {
							return result;
						}
						return false;
					}
					return true;
				}

				// Prevent submit for invalid forms or custom submit handlers
				if ( validator.cancelSubmit ) {
					validator.cancelSubmit = false;
					return handle();
				}
				if ( validator.form() ) {
					if ( validator.pendingRequest ) {
						validator.formSubmitted = true;
						return false;
					}
					return handle();
				} else {
					validator.focusInvalid();
					return false;
				}
			} );
		}

		return validator;
	},

	// https://jqueryvalidation.org/valid/
	valid: function() {
		var valid, validator, errorList;

		if ( $( this[ 0 ] ).is( "form" ) ) {
			valid = this.validate().form();
		} else {
			errorList = [];
			valid = true;
			validator = $( this[ 0 ].form ).validate();
			this.each( function() {
				valid = validator.element( this ) && valid;
				if ( !valid ) {
					errorList = errorList.concat( validator.errorList );
				}
			} );
			validator.errorList = errorList;
		}
		return valid;
	},

	// https://jqueryvalidation.org/rules/
	rules: function( command, argument ) {
		var element = this[ 0 ],
			settings, staticRules, existingRules, data, param, filtered;

		// If nothing is selected, return empty object; can't chain anyway
		if ( element == null ) {
			return;
		}

		if ( !element.form && element.hasAttribute( "contenteditable" ) ) {
			element.form = this.closest( "form" )[ 0 ];
			element.name = this.attr( "name" );
		}

		if ( element.form == null ) {
			return;
		}

		if ( command ) {
			settings = $.data( element.form, "validator" ).settings;
			staticRules = settings.rules;
			existingRules = $.validator.staticRules( element );
			switch ( command ) {
			case "add":
				$.extend( existingRules, $.validator.normalizeRule( argument ) );

				// Remove messages from rules, but allow them to be set separately
				delete existingRules.messages;
				staticRules[ element.name ] = existingRules;
				if ( argument.messages ) {
					settings.messages[ element.name ] = $.extend( settings.messages[ element.name ], argument.messages );
				}
				break;
			case "remove":
				if ( !argument ) {
					delete staticRules[ element.name ];
					return existingRules;
				}
				filtered = {};
				$.each( argument.split( /\s/ ), function( index, method ) {
					filtered[ method ] = existingRules[ method ];
					delete existingRules[ method ];
				} );
				return filtered;
			}
		}

		data = $.validator.normalizeRules(
		$.extend(
			{},
			$.validator.classRules( element ),
			$.validator.attributeRules( element ),
			$.validator.dataRules( element ),
			$.validator.staticRules( element )
		), element );

		// Make sure required is at front
		if ( data.required ) {
			param = data.required;
			delete data.required;
			data = $.extend( { required: param }, data );
		}

		// Make sure remote is at back
		if ( data.remote ) {
			param = data.remote;
			delete data.remote;
			data = $.extend( data, { remote: param } );
		}

		return data;
	}
} );

// Custom selectors
$.extend( $.expr.pseudos || $.expr[ ":" ], {		// '|| $.expr[ ":" ]' here enables backwards compatibility to jQuery 1.7. Can be removed when dropping jQ 1.7.x support

	// https://jqueryvalidation.org/blank-selector/
	blank: function( a ) {
		return !$.trim( "" + $( a ).val() );
	},

	// https://jqueryvalidation.org/filled-selector/
	filled: function( a ) {
		var val = $( a ).val();
		return val !== null && !!$.trim( "" + val );
	},

	// https://jqueryvalidation.org/unchecked-selector/
	unchecked: function( a ) {
		return !$( a ).prop( "checked" );
	}
} );

// Constructor for validator
$.validator = function( options, form ) {
	this.settings = $.extend( true, {}, $.validator.defaults, options );
	this.currentForm = form;
	this.init();
};

// https://jqueryvalidation.org/jQuery.validator.format/
$.validator.format = function( source, params ) {
	if ( arguments.length === 1 ) {
		return function() {
			var args = $.makeArray( arguments );
			args.unshift( source );
			return $.validator.format.apply( this, args );
		};
	}
	if ( params === undefined ) {
		return source;
	}
	if ( arguments.length > 2 && params.constructor !== Array  ) {
		params = $.makeArray( arguments ).slice( 1 );
	}
	if ( params.constructor !== Array ) {
		params = [ params ];
	}
	$.each( params, function( i, n ) {
		source = source.replace( new RegExp( "\\{" + i + "\\}", "g" ), function() {
			return n;
		} );
	} );
	return source;
};

$.extend( $.validator, {

	defaults: {
		messages: {},
		groups: {},
		rules: {},
		errorClass: "error",
		pendingClass: "pending",
		validClass: "valid",
		errorElement: "label",
		focusCleanup: false,
		focusInvalid: true,
		errorContainer: $( [] ),
		errorLabelContainer: $( [] ),
		onsubmit: true,
		ignore: ":hidden",
		ignoreTitle: false,
		onfocusin: function( element ) {
			this.lastActive = element;

			// Hide error label and remove error class on focus if enabled
			if ( this.settings.focusCleanup ) {
				if ( this.settings.unhighlight ) {
					this.settings.unhighlight.call( this, element, this.settings.errorClass, this.settings.validClass );
				}
				this.hideThese( this.errorsFor( element ) );
			}
		},
		onfocusout: function( element ) {
			if ( !this.checkable( element ) && ( element.name in this.submitted || !this.optional( element ) ) ) {
				this.element( element );
			}
		},
		onkeyup: function( element, event ) {

			// Avoid revalidate the field when pressing one of the following keys
			// Shift       => 16
			// Ctrl        => 17
			// Alt         => 18
			// Caps lock   => 20
			// End         => 35
			// Home        => 36
			// Left arrow  => 37
			// Up arrow    => 38
			// Right arrow => 39
			// Down arrow  => 40
			// Insert      => 45
			// Num lock    => 144
			// AltGr key   => 225
			var excludedKeys = [
				16, 17, 18, 20, 35, 36, 37,
				38, 39, 40, 45, 144, 225
			];

			if ( event.which === 9 && this.elementValue( element ) === "" || $.inArray( event.keyCode, excludedKeys ) !== -1 ) {
				return;
			} else if ( element.name in this.submitted || element.name in this.invalid ) {
				this.element( element );
			}
		},
		onclick: function( element ) {

			// Click on selects, radiobuttons and checkboxes
			if ( element.name in this.submitted ) {
				this.element( element );

			// Or option elements, check parent select in that case
			} else if ( element.parentNode.name in this.submitted ) {
				this.element( element.parentNode );
			}
		},
		highlight: function( element, errorClass, validClass ) {
			if ( element.type === "radio" ) {
				this.findByName( element.name ).addClass( errorClass ).removeClass( validClass );
			} else {
				$( element ).addClass( errorClass ).removeClass( validClass );
			}
		},
		unhighlight: function( element, errorClass, validClass ) {
			if ( element.type === "radio" ) {
				this.findByName( element.name ).removeClass( errorClass ).addClass( validClass );
			} else {
				$( element ).removeClass( errorClass ).addClass( validClass );
			}
		}
	},

	// https://jqueryvalidation.org/jQuery.validator.setDefaults/
	setDefaults: function( settings ) {
		$.extend( $.validator.defaults, settings );
	},

	messages: {
		required: "This field is required.",
		remote: "Please fix this field.",
		email: "Please enter a valid email address.",
		url: "Please enter a valid URL.",
		date: "Please enter a valid date.",
		dateISO: "Please enter a valid date (ISO).",
		number: "Please enter a valid number.",
		digits: "Please enter only digits.",
		equalTo: "Please enter the same value again.",
		maxlength: $.validator.format( "Please enter no more than {0} characters." ),
		minlength: $.validator.format( "Please enter at least {0} characters." ),
		rangelength: $.validator.format( "Please enter a value between {0} and {1} characters long." ),
		range: $.validator.format( "Please enter a value between {0} and {1}." ),
		max: $.validator.format( "Please enter a value less than or equal to {0}." ),
		min: $.validator.format( "Please enter a value greater than or equal to {0}." ),
		step: $.validator.format( "Please enter a multiple of {0}." )
	},

	autoCreateRanges: false,

	prototype: {

		init: function() {
			this.labelContainer = $( this.settings.errorLabelContainer );
			this.errorContext = this.labelContainer.length && this.labelContainer || $( this.currentForm );
			this.containers = $( this.settings.errorContainer ).add( this.settings.errorLabelContainer );
			this.submitted = {};
			this.valueCache = {};
			this.pendingRequest = 0;
			this.pending = {};
			this.invalid = {};
			this.reset();

			var groups = ( this.groups = {} ),
				rules;
			$.each( this.settings.groups, function( key, value ) {
				if ( typeof value === "string" ) {
					value = value.split( /\s/ );
				}
				$.each( value, function( index, name ) {
					groups[ name ] = key;
				} );
			} );
			rules = this.settings.rules;
			$.each( rules, function( key, value ) {
				rules[ key ] = $.validator.normalizeRule( value );
			} );

			function delegate( event ) {

				// Set form expando on contenteditable
				if ( !this.form && this.hasAttribute( "contenteditable" ) ) {
					this.form = $( this ).closest( "form" )[ 0 ];
					this.name = $( this ).attr( "name" );
				}

				var validator = $.data( this.form, "validator" ),
					eventType = "on" + event.type.replace( /^validate/, "" ),
					settings = validator.settings;
				if ( settings[ eventType ] && !$( this ).is( settings.ignore ) ) {
					settings[ eventType ].call( validator, this, event );
				}
			}

			$( this.currentForm )
				.on( "focusin.validate focusout.validate keyup.validate",
					":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], " +
					"[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], " +
					"[type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], " +
					"[type='radio'], [type='checkbox'], [contenteditable], [type='button']", delegate )

				// Support: Chrome, oldIE
				// "select" is provided as event.target when clicking a option
				.on( "click.validate", "select, option, [type='radio'], [type='checkbox']", delegate );

			if ( this.settings.invalidHandler ) {
				$( this.currentForm ).on( "invalid-form.validate", this.settings.invalidHandler );
			}
		},

		// https://jqueryvalidation.org/Validator.form/
		form: function() {
			this.checkForm();
			$.extend( this.submitted, this.errorMap );
			this.invalid = $.extend( {}, this.errorMap );
			if ( !this.valid() ) {
				$( this.currentForm ).triggerHandler( "invalid-form", [ this ] );
			}
			this.showErrors();
			return this.valid();
		},

		checkForm: function() {
			this.prepareForm();
			for ( var i = 0, elements = ( this.currentElements = this.elements() ); elements[ i ]; i++ ) {
				this.check( elements[ i ] );
			}
			return this.valid();
		},

		// https://jqueryvalidation.org/Validator.element/
		element: function( element ) {
			var cleanElement = this.clean( element ),
				checkElement = this.validationTargetFor( cleanElement ),
				v = this,
				result = true,
				rs, group;

			if ( checkElement === undefined ) {
				delete this.invalid[ cleanElement.name ];
			} else {
				this.prepareElement( checkElement );
				this.currentElements = $( checkElement );

				// If this element is grouped, then validate all group elements already
				// containing a value
				group = this.groups[ checkElement.name ];
				if ( group ) {
					$.each( this.groups, function( name, testgroup ) {
						if ( testgroup === group && name !== checkElement.name ) {
							cleanElement = v.validationTargetFor( v.clean( v.findByName( name ) ) );
							if ( cleanElement && cleanElement.name in v.invalid ) {
								v.currentElements.push( cleanElement );
								result = v.check( cleanElement ) && result;
							}
						}
					} );
				}

				rs = this.check( checkElement ) !== false;
				result = result && rs;
				if ( rs ) {
					this.invalid[ checkElement.name ] = false;
				} else {
					this.invalid[ checkElement.name ] = true;
				}

				if ( !this.numberOfInvalids() ) {

					// Hide error containers on last error
					this.toHide = this.toHide.add( this.containers );
				}
				this.showErrors();

				// Add aria-invalid status for screen readers
				$( element ).attr( "aria-invalid", !rs );
			}

			return result;
		},

		// https://jqueryvalidation.org/Validator.showErrors/
		showErrors: function( errors ) {
			if ( errors ) {
				var validator = this;

				// Add items to error list and map
				$.extend( this.errorMap, errors );
				this.errorList = $.map( this.errorMap, function( message, name ) {
					return {
						message: message,
						element: validator.findByName( name )[ 0 ]
					};
				} );

				// Remove items from success list
				this.successList = $.grep( this.successList, function( element ) {
					return !( element.name in errors );
				} );
			}
			if ( this.settings.showErrors ) {
				this.settings.showErrors.call( this, this.errorMap, this.errorList );
			} else {
				this.defaultShowErrors();
			}
		},

		// https://jqueryvalidation.org/Validator.resetForm/
		resetForm: function() {
			if ( $.fn.resetForm ) {
				$( this.currentForm ).resetForm();
			}
			this.invalid = {};
			this.submitted = {};
			this.prepareForm();
			this.hideErrors();
			var elements = this.elements()
				.removeData( "previousValue" )
				.removeAttr( "aria-invalid" );

			this.resetElements( elements );
		},

		resetElements: function( elements ) {
			var i;

			if ( this.settings.unhighlight ) {
				for ( i = 0; elements[ i ]; i++ ) {
					this.settings.unhighlight.call( this, elements[ i ],
						this.settings.errorClass, "" );
					this.findByName( elements[ i ].name ).removeClass( this.settings.validClass );
				}
			} else {
				elements
					.removeClass( this.settings.errorClass )
					.removeClass( this.settings.validClass );
			}
		},

		numberOfInvalids: function() {
			return this.objectLength( this.invalid );
		},

		objectLength: function( obj ) {
			/* jshint unused: false */
			var count = 0,
				i;
			for ( i in obj ) {

				// This check allows counting elements with empty error
				// message as invalid elements
				if ( obj[ i ] !== undefined && obj[ i ] !== null && obj[ i ] !== false ) {
					count++;
				}
			}
			return count;
		},

		hideErrors: function() {
			this.hideThese( this.toHide );
		},

		hideThese: function( errors ) {
			errors.not( this.containers ).text( "" );
			this.addWrapper( errors ).hide();
		},

		valid: function() {
			return this.size() === 0;
		},

		size: function() {
			return this.errorList.length;
		},

		focusInvalid: function() {
			if ( this.settings.focusInvalid ) {
				try {
					$( this.findLastActive() || this.errorList.length && this.errorList[ 0 ].element || [] )
					.filter( ":visible" )
					.focus()

					// Manually trigger focusin event; without it, focusin handler isn't called, findLastActive won't have anything to find
					.trigger( "focusin" );
				} catch ( e ) {

					// Ignore IE throwing errors when focusing hidden elements
				}
			}
		},

		findLastActive: function() {
			var lastActive = this.lastActive;
			return lastActive && $.grep( this.errorList, function( n ) {
				return n.element.name === lastActive.name;
			} ).length === 1 && lastActive;
		},

		elements: function() {
			var validator = this,
				rulesCache = {};

			// Select all valid inputs inside the form (no submit or reset buttons)
			return $( this.currentForm )
			.find( "input, select, textarea, [contenteditable]" )
			.not( ":submit, :reset, :image, :disabled" )
			.not( this.settings.ignore )
			.filter( function() {
				var name = this.name || $( this ).attr( "name" ); // For contenteditable
				if ( !name && validator.settings.debug && window.console ) {
					console.error( "%o has no name assigned", this );
				}

				// Set form expando on contenteditable
				if ( this.hasAttribute( "contenteditable" ) ) {
					this.form = $( this ).closest( "form" )[ 0 ];
					this.name = name;
				}

				// Select only the first element for each name, and only those with rules specified
				if ( name in rulesCache || !validator.objectLength( $( this ).rules() ) ) {
					return false;
				}

				rulesCache[ name ] = true;
				return true;
			} );
		},

		clean: function( selector ) {
			return $( selector )[ 0 ];
		},

		errors: function() {
			var errorClass = this.settings.errorClass.split( " " ).join( "." );
			return $( this.settings.errorElement + "." + errorClass, this.errorContext );
		},

		resetInternals: function() {
			this.successList = [];
			this.errorList = [];
			this.errorMap = {};
			this.toShow = $( [] );
			this.toHide = $( [] );
		},

		reset: function() {
			this.resetInternals();
			this.currentElements = $( [] );
		},

		prepareForm: function() {
			this.reset();
			this.toHide = this.errors().add( this.containers );
		},

		prepareElement: function( element ) {
			this.reset();
			this.toHide = this.errorsFor( element );
		},

		elementValue: function( element ) {
			var $element = $( element ),
				type = element.type,
				val, idx;

			if ( type === "radio" || type === "checkbox" ) {
				return this.findByName( element.name ).filter( ":checked" ).val();
			} else if ( type === "number" && typeof element.validity !== "undefined" ) {
				return element.validity.badInput ? "NaN" : $element.val();
			}

			if ( element.hasAttribute( "contenteditable" ) ) {
				val = $element.text();
			} else {
				val = $element.val();
			}

			if ( type === "file" ) {

				// Modern browser (chrome & safari)
				if ( val.substr( 0, 12 ) === "C:\\fakepath\\" ) {
					return val.substr( 12 );
				}

				// Legacy browsers
				// Unix-based path
				idx = val.lastIndexOf( "/" );
				if ( idx >= 0 ) {
					return val.substr( idx + 1 );
				}

				// Windows-based path
				idx = val.lastIndexOf( "\\" );
				if ( idx >= 0 ) {
					return val.substr( idx + 1 );
				}

				// Just the file name
				return val;
			}

			if ( typeof val === "string" ) {
				return val.replace( /\r/g, "" );
			}
			return val;
		},

		check: function( element ) {
			element = this.validationTargetFor( this.clean( element ) );

			var rules = $( element ).rules(),
				rulesCount = $.map( rules, function( n, i ) {
					return i;
				} ).length,
				dependencyMismatch = false,
				val = this.elementValue( element ),
				result, method, rule, normalizer;

			// Prioritize the local normalizer defined for this element over the global one
			// if the former exists, otherwise user the global one in case it exists.
			if ( typeof rules.normalizer === "function" ) {
				normalizer = rules.normalizer;
			} else if (	typeof this.settings.normalizer === "function" ) {
				normalizer = this.settings.normalizer;
			}

			// If normalizer is defined, then call it to retreive the changed value instead
			// of using the real one.
			// Note that `this` in the normalizer is `element`.
			if ( normalizer ) {
				val = normalizer.call( element, val );

				if ( typeof val !== "string" ) {
					throw new TypeError( "The normalizer should return a string value." );
				}

				// Delete the normalizer from rules to avoid treating it as a pre-defined method.
				delete rules.normalizer;
			}

			for ( method in rules ) {
				rule = { method: method, parameters: rules[ method ] };
				try {
					result = $.validator.methods[ method ].call( this, val, element, rule.parameters );

					// If a method indicates that the field is optional and therefore valid,
					// don't mark it as valid when there are no other rules
					if ( result === "dependency-mismatch" && rulesCount === 1 ) {
						dependencyMismatch = true;
						continue;
					}
					dependencyMismatch = false;

					if ( result === "pending" ) {
						this.toHide = this.toHide.not( this.errorsFor( element ) );
						return;
					}

					if ( !result ) {
						this.formatAndAdd( element, rule );
						return false;
					}
				} catch ( e ) {
					if ( this.settings.debug && window.console ) {
						console.log( "Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.", e );
					}
					if ( e instanceof TypeError ) {
						e.message += ".  Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.";
					}

					throw e;
				}
			}
			if ( dependencyMismatch ) {
				return;
			}
			if ( this.objectLength( rules ) ) {
				this.successList.push( element );
			}
			return true;
		},

		// Return the custom message for the given element and validation method
		// specified in the element's HTML5 data attribute
		// return the generic message if present and no method specific message is present
		customDataMessage: function( element, method ) {
			return $( element ).data( "msg" + method.charAt( 0 ).toUpperCase() +
				method.substring( 1 ).toLowerCase() ) || $( element ).data( "msg" );
		},

		// Return the custom message for the given element name and validation method
		customMessage: function( name, method ) {
			var m = this.settings.messages[ name ];
			return m && ( m.constructor === String ? m : m[ method ] );
		},

		// Return the first defined argument, allowing empty strings
		findDefined: function() {
			for ( var i = 0; i < arguments.length; i++ ) {
				if ( arguments[ i ] !== undefined ) {
					return arguments[ i ];
				}
			}
			return undefined;
		},

		// The second parameter 'rule' used to be a string, and extended to an object literal
		// of the following form:
		// rule = {
		//     method: "method name",
		//     parameters: "the given method parameters"
		// }
		//
		// The old behavior still supported, kept to maintain backward compatibility with
		// old code, and will be removed in the next major release.
		defaultMessage: function( element, rule ) {
			if ( typeof rule === "string" ) {
				rule = { method: rule };
			}

			var message = this.findDefined(
					this.customMessage( element.name, rule.method ),
					this.customDataMessage( element, rule.method ),

					// 'title' is never undefined, so handle empty string as undefined
					!this.settings.ignoreTitle && element.title || undefined,
					$.validator.messages[ rule.method ],
					"<strong>Warning: No message defined for " + element.name + "</strong>"
				),
				theregex = /\$?\{(\d+)\}/g;
			if ( typeof message === "function" ) {
				message = message.call( this, rule.parameters, element );
			} else if ( theregex.test( message ) ) {
				message = $.validator.format( message.replace( theregex, "{$1}" ), rule.parameters );
			}

			return message;
		},

		formatAndAdd: function( element, rule ) {
			var message = this.defaultMessage( element, rule );

			this.errorList.push( {
				message: message,
				element: element,
				method: rule.method
			} );

			this.errorMap[ element.name ] = message;
			this.submitted[ element.name ] = message;
		},

		addWrapper: function( toToggle ) {
			if ( this.settings.wrapper ) {
				toToggle = toToggle.add( toToggle.parent( this.settings.wrapper ) );
			}
			return toToggle;
		},

		defaultShowErrors: function() {
			var i, elements, error;
			for ( i = 0; this.errorList[ i ]; i++ ) {
				error = this.errorList[ i ];
				if ( this.settings.highlight ) {
					this.settings.highlight.call( this, error.element, this.settings.errorClass, this.settings.validClass );
				}
				this.showLabel( error.element, error.message );
			}
			if ( this.errorList.length ) {
				this.toShow = this.toShow.add( this.containers );
			}
			if ( this.settings.success ) {
				for ( i = 0; this.successList[ i ]; i++ ) {
					this.showLabel( this.successList[ i ] );
				}
			}
			if ( this.settings.unhighlight ) {
				for ( i = 0, elements = this.validElements(); elements[ i ]; i++ ) {
					this.settings.unhighlight.call( this, elements[ i ], this.settings.errorClass, this.settings.validClass );
				}
			}
			this.toHide = this.toHide.not( this.toShow );
			this.hideErrors();
			this.addWrapper( this.toShow ).show();
		},

		validElements: function() {
			return this.currentElements.not( this.invalidElements() );
		},

		invalidElements: function() {
			return $( this.errorList ).map( function() {
				return this.element;
			} );
		},

		showLabel: function( element, message ) {
			var place, group, errorID, v,
				error = this.errorsFor( element ),
				elementID = this.idOrName( element ),
				describedBy = $( element ).attr( "aria-describedby" );

			if ( error.length ) {

				// Refresh error/success class
				error.removeClass( this.settings.validClass ).addClass( this.settings.errorClass );

				// Replace message on existing label
				error.html( message );
			} else {

				// Create error element
				error = $( "<" + this.settings.errorElement + ">" )
					.attr( "id", elementID + "-error" )
					.addClass( this.settings.errorClass )
					.html( message || "" );

				// Maintain reference to the element to be placed into the DOM
				place = error;
				if ( this.settings.wrapper ) {

					// Make sure the element is visible, even in IE
					// actually showing the wrapped element is handled elsewhere
					place = error.hide().show().wrap( "<" + this.settings.wrapper + "/>" ).parent();
				}
				if ( this.labelContainer.length ) {
					this.labelContainer.append( place );
				} else if ( this.settings.errorPlacement ) {
					this.settings.errorPlacement.call( this, place, $( element ) );
				} else {
					place.insertAfter( element );
				}

				// Link error back to the element
				if ( error.is( "label" ) ) {

					// If the error is a label, then associate using 'for'
					error.attr( "for", elementID );

					// If the element is not a child of an associated label, then it's necessary
					// to explicitly apply aria-describedby
				} else if ( error.parents( "label[for='" + this.escapeCssMeta( elementID ) + "']" ).length === 0 ) {
					errorID = error.attr( "id" );

					// Respect existing non-error aria-describedby
					if ( !describedBy ) {
						describedBy = errorID;
					} else if ( !describedBy.match( new RegExp( "\\b" + this.escapeCssMeta( errorID ) + "\\b" ) ) ) {

						// Add to end of list if not already present
						describedBy += " " + errorID;
					}
					$( element ).attr( "aria-describedby", describedBy );

					// If this element is grouped, then assign to all elements in the same group
					group = this.groups[ element.name ];
					if ( group ) {
						v = this;
						$.each( v.groups, function( name, testgroup ) {
							if ( testgroup === group ) {
								$( "[name='" + v.escapeCssMeta( name ) + "']", v.currentForm )
									.attr( "aria-describedby", error.attr( "id" ) );
							}
						} );
					}
				}
			}
			if ( !message && this.settings.success ) {
				error.text( "" );
				if ( typeof this.settings.success === "string" ) {
					error.addClass( this.settings.success );
				} else {
					this.settings.success( error, element );
				}
			}
			this.toShow = this.toShow.add( error );
		},

		errorsFor: function( element ) {
			var name = this.escapeCssMeta( this.idOrName( element ) ),
				describer = $( element ).attr( "aria-describedby" ),
				selector = "label[for='" + name + "'], label[for='" + name + "'] *";

			// 'aria-describedby' should directly reference the error element
			if ( describer ) {
				selector = selector + ", #" + this.escapeCssMeta( describer )
					.replace( /\s+/g, ", #" );
			}

			return this
				.errors()
				.filter( selector );
		},

		// See https://api.jquery.com/category/selectors/, for CSS
		// meta-characters that should be escaped in order to be used with JQuery
		// as a literal part of a name/id or any selector.
		escapeCssMeta: function( string ) {
			return string.replace( /([\\!"#$%&'()*+,./:;<=>?@\[\]^`{|}~])/g, "\\$1" );
		},

		idOrName: function( element ) {
			return this.groups[ element.name ] || ( this.checkable( element ) ? element.name : element.id || element.name );
		},

		validationTargetFor: function( element ) {

			// If radio/checkbox, validate first element in group instead
			if ( this.checkable( element ) ) {
				element = this.findByName( element.name );
			}

			// Always apply ignore filter
			return $( element ).not( this.settings.ignore )[ 0 ];
		},

		checkable: function( element ) {
			return ( /radio|checkbox/i ).test( element.type );
		},

		findByName: function( name ) {
			return $( this.currentForm ).find( "[name='" + this.escapeCssMeta( name ) + "']" );
		},

		getLength: function( value, element ) {
			switch ( element.nodeName.toLowerCase() ) {
			case "select":
				return $( "option:selected", element ).length;
			case "input":
				if ( this.checkable( element ) ) {
					return this.findByName( element.name ).filter( ":checked" ).length;
				}
			}
			return value.length;
		},

		depend: function( param, element ) {
			return this.dependTypes[ typeof param ] ? this.dependTypes[ typeof param ]( param, element ) : true;
		},

		dependTypes: {
			"boolean": function( param ) {
				return param;
			},
			"string": function( param, element ) {
				return !!$( param, element.form ).length;
			},
			"function": function( param, element ) {
				return param( element );
			}
		},

		optional: function( element ) {
			var val = this.elementValue( element );
			return !$.validator.methods.required.call( this, val, element ) && "dependency-mismatch";
		},

		startRequest: function( element ) {
			if ( !this.pending[ element.name ] ) {
				this.pendingRequest++;
				$( element ).addClass( this.settings.pendingClass );
				this.pending[ element.name ] = true;
			}
		},

		stopRequest: function( element, valid ) {
			this.pendingRequest--;

			// Sometimes synchronization fails, make sure pendingRequest is never < 0
			if ( this.pendingRequest < 0 ) {
				this.pendingRequest = 0;
			}
			delete this.pending[ element.name ];
			$( element ).removeClass( this.settings.pendingClass );
			if ( valid && this.pendingRequest === 0 && this.formSubmitted && this.form() ) {
				$( this.currentForm ).submit();

				// Remove the hidden input that was used as a replacement for the
				// missing submit button. The hidden input is added by `handle()`
				// to ensure that the value of the used submit button is passed on
				// for scripted submits triggered by this method
				if ( this.submitButton ) {
					$( "input:hidden[name='" + this.submitButton.name + "']", this.currentForm ).remove();
				}

				this.formSubmitted = false;
			} else if ( !valid && this.pendingRequest === 0 && this.formSubmitted ) {
				$( this.currentForm ).triggerHandler( "invalid-form", [ this ] );
				this.formSubmitted = false;
			}
		},

		previousValue: function( element, method ) {
			method = typeof method === "string" && method || "remote";

			return $.data( element, "previousValue" ) || $.data( element, "previousValue", {
				old: null,
				valid: true,
				message: this.defaultMessage( element, { method: method } )
			} );
		},

		// Cleans up all forms and elements, removes validator-specific events
		destroy: function() {
			this.resetForm();

			$( this.currentForm )
				.off( ".validate" )
				.removeData( "validator" )
				.find( ".validate-equalTo-blur" )
					.off( ".validate-equalTo" )
					.removeClass( "validate-equalTo-blur" );
		}

	},

	classRuleSettings: {
		required: { required: true },
		email: { email: true },
		url: { url: true },
		date: { date: true },
		dateISO: { dateISO: true },
		number: { number: true },
		digits: { digits: true },
		creditcard: { creditcard: true }
	},

	addClassRules: function( className, rules ) {
		if ( className.constructor === String ) {
			this.classRuleSettings[ className ] = rules;
		} else {
			$.extend( this.classRuleSettings, className );
		}
	},

	classRules: function( element ) {
		var rules = {},
			classes = $( element ).attr( "class" );

		if ( classes ) {
			$.each( classes.split( " " ), function() {
				if ( this in $.validator.classRuleSettings ) {
					$.extend( rules, $.validator.classRuleSettings[ this ] );
				}
			} );
		}
		return rules;
	},

	normalizeAttributeRule: function( rules, type, method, value ) {

		// Convert the value to a number for number inputs, and for text for backwards compability
		// allows type="date" and others to be compared as strings
		if ( /min|max|step/.test( method ) && ( type === null || /number|range|text/.test( type ) ) ) {
			value = Number( value );

			// Support Opera Mini, which returns NaN for undefined minlength
			if ( isNaN( value ) ) {
				value = undefined;
			}
		}

		if ( value || value === 0 ) {
			rules[ method ] = value;
		} else if ( type === method && type !== "range" ) {

			// Exception: the jquery validate 'range' method
			// does not test for the html5 'range' type
			rules[ method ] = true;
		}
	},

	attributeRules: function( element ) {
		var rules = {},
			$element = $( element ),
			type = element.getAttribute( "type" ),
			method, value;

		for ( method in $.validator.methods ) {

			// Support for <input required> in both html5 and older browsers
			if ( method === "required" ) {
				value = element.getAttribute( method );

				// Some browsers return an empty string for the required attribute
				// and non-HTML5 browsers might have required="" markup
				if ( value === "" ) {
					value = true;
				}

				// Force non-HTML5 browsers to return bool
				value = !!value;
			} else {
				value = $element.attr( method );
			}

			this.normalizeAttributeRule( rules, type, method, value );
		}

		// 'maxlength' may be returned as -1, 2147483647 ( IE ) and 524288 ( safari ) for text inputs
		if ( rules.maxlength && /-1|2147483647|524288/.test( rules.maxlength ) ) {
			delete rules.maxlength;
		}

		return rules;
	},

	dataRules: function( element ) {
		var rules = {},
			$element = $( element ),
			type = element.getAttribute( "type" ),
			method, value;

		for ( method in $.validator.methods ) {
			value = $element.data( "rule" + method.charAt( 0 ).toUpperCase() + method.substring( 1 ).toLowerCase() );
			this.normalizeAttributeRule( rules, type, method, value );
		}
		return rules;
	},

	staticRules: function( element ) {
		var rules = {},
			validator = $.data( element.form, "validator" );

		if ( validator.settings.rules ) {
			rules = $.validator.normalizeRule( validator.settings.rules[ element.name ] ) || {};
		}
		return rules;
	},

	normalizeRules: function( rules, element ) {

		// Handle dependency check
		$.each( rules, function( prop, val ) {

			// Ignore rule when param is explicitly false, eg. required:false
			if ( val === false ) {
				delete rules[ prop ];
				return;
			}
			if ( val.param || val.depends ) {
				var keepRule = true;
				switch ( typeof val.depends ) {
				case "string":
					keepRule = !!$( val.depends, element.form ).length;
					break;
				case "function":
					keepRule = val.depends.call( element, element );
					break;
				}
				if ( keepRule ) {
					rules[ prop ] = val.param !== undefined ? val.param : true;
				} else {
					$.data( element.form, "validator" ).resetElements( $( element ) );
					delete rules[ prop ];
				}
			}
		} );

		// Evaluate parameters
		$.each( rules, function( rule, parameter ) {
			rules[ rule ] = $.isFunction( parameter ) && rule !== "normalizer" ? parameter( element ) : parameter;
		} );

		// Clean number parameters
		$.each( [ "minlength", "maxlength" ], function() {
			if ( rules[ this ] ) {
				rules[ this ] = Number( rules[ this ] );
			}
		} );
		$.each( [ "rangelength", "range" ], function() {
			var parts;
			if ( rules[ this ] ) {
				if ( $.isArray( rules[ this ] ) ) {
					rules[ this ] = [ Number( rules[ this ][ 0 ] ), Number( rules[ this ][ 1 ] ) ];
				} else if ( typeof rules[ this ] === "string" ) {
					parts = rules[ this ].replace( /[\[\]]/g, "" ).split( /[\s,]+/ );
					rules[ this ] = [ Number( parts[ 0 ] ), Number( parts[ 1 ] ) ];
				}
			}
		} );

		if ( $.validator.autoCreateRanges ) {

			// Auto-create ranges
			if ( rules.min != null && rules.max != null ) {
				rules.range = [ rules.min, rules.max ];
				delete rules.min;
				delete rules.max;
			}
			if ( rules.minlength != null && rules.maxlength != null ) {
				rules.rangelength = [ rules.minlength, rules.maxlength ];
				delete rules.minlength;
				delete rules.maxlength;
			}
		}

		return rules;
	},

	// Converts a simple string to a {string: true} rule, e.g., "required" to {required:true}
	normalizeRule: function( data ) {
		if ( typeof data === "string" ) {
			var transformed = {};
			$.each( data.split( /\s/ ), function() {
				transformed[ this ] = true;
			} );
			data = transformed;
		}
		return data;
	},

	// https://jqueryvalidation.org/jQuery.validator.addMethod/
	addMethod: function( name, method, message ) {
		$.validator.methods[ name ] = method;
		$.validator.messages[ name ] = message !== undefined ? message : $.validator.messages[ name ];
		if ( method.length < 3 ) {
			$.validator.addClassRules( name, $.validator.normalizeRule( name ) );
		}
	},

	// https://jqueryvalidation.org/jQuery.validator.methods/
	methods: {

		// https://jqueryvalidation.org/required-method/
		required: function( value, element, param ) {

			// Check if dependency is met
			if ( !this.depend( param, element ) ) {
				return "dependency-mismatch";
			}
			if ( element.nodeName.toLowerCase() === "select" ) {

				// Could be an array for select-multiple or a string, both are fine this way
				var val = $( element ).val();
				return val && val.length > 0;
			}
			if ( this.checkable( element ) ) {
				return this.getLength( value, element ) > 0;
			}
			return value.length > 0;
		},

		// https://jqueryvalidation.org/email-method/
		email: function( value, element ) {

			// From https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address
			// Retrieved 2014-01-14
			// If you have a problem with this implementation, report a bug against the above spec
			// Or use custom methods to implement your own email validation
			return this.optional( element ) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test( value );
		},

		// https://jqueryvalidation.org/url-method/
		url: function( value, element ) {

			// Copyright (c) 2010-2013 Diego Perini, MIT licensed
			// https://gist.github.com/dperini/729294
			// see also https://mathiasbynens.be/demo/url-regex
			// modified to allow protocol-relative URLs
			return this.optional( element ) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test( value );
		},

		// https://jqueryvalidation.org/date-method/
		date: function( value, element ) {
			return this.optional( element ) || !/Invalid|NaN/.test( new Date( value ).toString() );
		},

		// https://jqueryvalidation.org/dateISO-method/
		dateISO: function( value, element ) {
			return this.optional( element ) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test( value );
		},

		// https://jqueryvalidation.org/number-method/
		number: function( value, element ) {
			return this.optional( element ) || /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test( value );
		},

		// https://jqueryvalidation.org/digits-method/
		digits: function( value, element ) {
			return this.optional( element ) || /^\d+$/.test( value );
		},

		// https://jqueryvalidation.org/minlength-method/
		minlength: function( value, element, param ) {
			var length = $.isArray( value ) ? value.length : this.getLength( value, element );
			return this.optional( element ) || length >= param;
		},

		// https://jqueryvalidation.org/maxlength-method/
		maxlength: function( value, element, param ) {
			var length = $.isArray( value ) ? value.length : this.getLength( value, element );
			return this.optional( element ) || length <= param;
		},

		// https://jqueryvalidation.org/rangelength-method/
		rangelength: function( value, element, param ) {
			var length = $.isArray( value ) ? value.length : this.getLength( value, element );
			return this.optional( element ) || ( length >= param[ 0 ] && length <= param[ 1 ] );
		},

		// https://jqueryvalidation.org/min-method/
		min: function( value, element, param ) {
			return this.optional( element ) || value >= param;
		},

		// https://jqueryvalidation.org/max-method/
		max: function( value, element, param ) {
			return this.optional( element ) || value <= param;
		},

		// https://jqueryvalidation.org/range-method/
		range: function( value, element, param ) {
			return this.optional( element ) || ( value >= param[ 0 ] && value <= param[ 1 ] );
		},

		// https://jqueryvalidation.org/step-method/
		step: function( value, element, param ) {
			var type = $( element ).attr( "type" ),
				errorMessage = "Step attribute on input type " + type + " is not supported.",
				supportedTypes = [ "text", "number", "range" ],
				re = new RegExp( "\\b" + type + "\\b" ),
				notSupported = type && !re.test( supportedTypes.join() ),
				decimalPlaces = function( num ) {
					var match = ( "" + num ).match( /(?:\.(\d+))?$/ );
					if ( !match ) {
						return 0;
					}

					// Number of digits right of decimal point.
					return match[ 1 ] ? match[ 1 ].length : 0;
				},
				toInt = function( num ) {
					return Math.round( num * Math.pow( 10, decimals ) );
				},
				valid = true,
				decimals;

			// Works only for text, number and range input types
			// TODO find a way to support input types date, datetime, datetime-local, month, time and week
			if ( notSupported ) {
				throw new Error( errorMessage );
			}

			decimals = decimalPlaces( param );

			// Value can't have too many decimals
			if ( decimalPlaces( value ) > decimals || toInt( value ) % toInt( param ) !== 0 ) {
				valid = false;
			}

			return this.optional( element ) || valid;
		},

		// https://jqueryvalidation.org/equalTo-method/
		equalTo: function( value, element, param ) {

			// Bind to the blur event of the target in order to revalidate whenever the target field is updated
			var target = $( param );
			if ( this.settings.onfocusout && target.not( ".validate-equalTo-blur" ).length ) {
				target.addClass( "validate-equalTo-blur" ).on( "blur.validate-equalTo", function() {
					$( element ).valid();
				} );
			}
			return value === target.val();
		},

		// https://jqueryvalidation.org/remote-method/
		remote: function( value, element, param, method ) {
			if ( this.optional( element ) ) {
				return "dependency-mismatch";
			}

			method = typeof method === "string" && method || "remote";

			var previous = this.previousValue( element, method ),
				validator, data, optionDataString;

			if ( !this.settings.messages[ element.name ] ) {
				this.settings.messages[ element.name ] = {};
			}
			previous.originalMessage = previous.originalMessage || this.settings.messages[ element.name ][ method ];
			this.settings.messages[ element.name ][ method ] = previous.message;

			param = typeof param === "string" && { url: param } || param;
			optionDataString = $.param( $.extend( { data: value }, param.data ) );
			if ( previous.old === optionDataString ) {
				return previous.valid;
			}

			previous.old = optionDataString;
			validator = this;
			this.startRequest( element );
			data = {};
			data[ element.name ] = value;
			$.ajax( $.extend( true, {
				mode: "abort",
				port: "validate" + element.name,
				dataType: "json",
				data: data,
				context: validator.currentForm,
				success: function( response ) {
					var valid = response === true || response === "true",
						errors, message, submitted;

					validator.settings.messages[ element.name ][ method ] = previous.originalMessage;
					if ( valid ) {
						submitted = validator.formSubmitted;
						validator.resetInternals();
						validator.toHide = validator.errorsFor( element );
						validator.formSubmitted = submitted;
						validator.successList.push( element );
						validator.invalid[ element.name ] = false;
						validator.showErrors();
					} else {
						errors = {};
						message = response || validator.defaultMessage( element, { method: method, parameters: value } );
						errors[ element.name ] = previous.message = message;
						validator.invalid[ element.name ] = true;
						validator.showErrors( errors );
					}
					previous.valid = valid;
					validator.stopRequest( element, valid );
				}
			}, param ) );
			return "pending";
		}
	}

} );

// Ajax mode: abort
// usage: $.ajax({ mode: "abort"[, port: "uniqueport"]});
// if mode:"abort" is used, the previous request on that port (port can be undefined) is aborted via XMLHttpRequest.abort()

var pendingRequests = {},
	ajax;

// Use a prefilter if available (1.5+)
if ( $.ajaxPrefilter ) {
	$.ajaxPrefilter( function( settings, _, xhr ) {
		var port = settings.port;
		if ( settings.mode === "abort" ) {
			if ( pendingRequests[ port ] ) {
				pendingRequests[ port ].abort();
			}
			pendingRequests[ port ] = xhr;
		}
	} );
} else {

	// Proxy ajax
	ajax = $.ajax;
	$.ajax = function( settings ) {
		var mode = ( "mode" in settings ? settings : $.ajaxSettings ).mode,
			port = ( "port" in settings ? settings : $.ajaxSettings ).port;
		if ( mode === "abort" ) {
			if ( pendingRequests[ port ] ) {
				pendingRequests[ port ].abort();
			}
			pendingRequests[ port ] = ajax.apply( this, arguments );
			return pendingRequests[ port ];
		}
		return ajax.apply( this, arguments );
	};
}
return $;
}));

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {/*!
** Unobtrusive validation support library for jQuery and jQuery Validate
** Copyright (C) Microsoft Corporation. All rights reserved.
*/

/*jslint white: true, browser: true, onevar: true, undef: true, nomen: true, eqeqeq: true, plusplus: true, bitwise: true, regexp: true, newcap: true, immed: true, strict: false */
/*global document: false, jQuery: false */

(function ($) {
    var $jQval = $.validator,
        adapters,
        data_validation = "unobtrusiveValidation";

    function setValidationValues(options, ruleName, value) {
        options.rules[ruleName] = value;
        if (options.message) {
            options.messages[ruleName] = options.message;
        }
    }

    function splitAndTrim(value) {
        return value.replace(/^\s+|\s+$/g, "").split(/\s*,\s*/g);
    }

    function escapeAttributeValue(value) {
        // As mentioned on http://api.jquery.com/category/selectors/
        return value.replace(/([!"#$%&'()*+,./:;<=>?@\[\\\]^`{|}~])/g, "\\$1");
    }

    function getModelPrefix(fieldName) {
        return fieldName.substr(0, fieldName.lastIndexOf(".") + 1);
    }

    function appendModelPrefix(value, prefix) {
        if (value.indexOf("*.") === 0) {
            value = value.replace("*.", prefix);
        }
        return value;
    }

    function onError(error, inputElement) {  // 'this' is the form element
        var container = $(this).find("[data-valmsg-for='" + escapeAttributeValue(inputElement[0].name) + "']"),
            replaceAttrValue = container.attr("data-valmsg-replace"),
            replace = replaceAttrValue ? $.parseJSON(replaceAttrValue) !== false : null;

        container.removeClass("field-validation-valid").addClass("field-validation-error");
        error.data("unobtrusiveContainer", container);

        if (replace) {
            container.empty();
            error.removeClass("input-validation-error").appendTo(container);
        }
        else {
            error.hide();
        }
    }

    function onErrors(event, validator) {  // 'this' is the form element
        var container = $(this).find("[data-valmsg-summary=true]"),
            list = container.find("ul");

        if (list && list.length && validator.errorList.length) {
            list.empty();
            container.addClass("validation-summary-errors").removeClass("validation-summary-valid");

            $.each(validator.errorList, function () {
                $("<li />").html(this.message).appendTo(list);
            });
        }
    }

    function onSuccess(error) {  // 'this' is the form element
        var container = error.data("unobtrusiveContainer");

        if (container) {
            var replaceAttrValue = container.attr("data-valmsg-replace"),
                replace = replaceAttrValue ? $.parseJSON(replaceAttrValue) : null;

            container.addClass("field-validation-valid").removeClass("field-validation-error");
            error.removeData("unobtrusiveContainer");

            if (replace) {
                container.empty();
            }
        }
    }

    function onReset(event) {  // 'this' is the form element
        var $form = $(this),
            key = '__jquery_unobtrusive_validation_form_reset';
        if ($form.data(key)) {
            return;
        }
        // Set a flag that indicates we're currently resetting the form.
        $form.data(key, true);
        try {
            $form.data("validator").resetForm();
        } finally {
            $form.removeData(key);
        }

        $form.find(".validation-summary-errors")
            .addClass("validation-summary-valid")
            .removeClass("validation-summary-errors");
        $form.find(".field-validation-error")
            .addClass("field-validation-valid")
            .removeClass("field-validation-error")
            .removeData("unobtrusiveContainer")
            .find(">*")  // If we were using valmsg-replace, get the underlying error
                .removeData("unobtrusiveContainer");
    }

    function validationInfo(form) {
        var $form = $(form),
            result = $form.data(data_validation),
            onResetProxy = $.proxy(onReset, form),
            defaultOptions = $jQval.unobtrusive.options || {},
            execInContext = function (name, args) {
                var func = defaultOptions[name];
                func && $.isFunction(func) && func.apply(form, args);
            }

        if (!result) {
            result = {
                options: {  // options structure passed to jQuery Validate's validate() method
                    errorClass: defaultOptions.errorClass || "input-validation-error",
                    errorElement: defaultOptions.errorElement || "span",
                    errorPlacement: function () {
                        onError.apply(form, arguments);
                        execInContext("errorPlacement", arguments);
                    },
                    invalidHandler: function () {
                        onErrors.apply(form, arguments);
                        execInContext("invalidHandler", arguments);
                    },
                    messages: {},
                    rules: {},
                    success: function () {
                        onSuccess.apply(form, arguments);
                        execInContext("success", arguments);
                    }
                },
                attachValidation: function () {
                    $form
                        .off("reset." + data_validation, onResetProxy)
                        .on("reset." + data_validation, onResetProxy)
                        .validate(this.options);
                },
                validate: function () {  // a validation function that is called by unobtrusive Ajax
                    $form.validate();
                    return $form.valid();
                }
            };
            $form.data(data_validation, result);
        }

        return result;
    }

    $jQval.unobtrusive = {
        adapters: [],

        parseElement: function (element, skipAttach) {
            /// <summary>
            /// Parses a single HTML element for unobtrusive validation attributes.
            /// </summary>
            /// <param name="element" domElement="true">The HTML element to be parsed.</param>
            /// <param name="skipAttach" type="Boolean">[Optional] true to skip attaching the
            /// validation to the form. If parsing just this single element, you should specify true.
            /// If parsing several elements, you should specify false, and manually attach the validation
            /// to the form when you are finished. The default is false.</param>
            var $element = $(element),
                form = $element.parents("form")[0],
                valInfo, rules, messages;

            if (!form) {  // Cannot do client-side validation without a form
                return;
            }

            valInfo = validationInfo(form);
            valInfo.options.rules[element.name] = rules = {};
            valInfo.options.messages[element.name] = messages = {};

            $.each(this.adapters, function () {
                var prefix = "data-val-" + this.name,
                    message = $element.attr(prefix),
                    paramValues = {};

                if (message !== undefined) {  // Compare against undefined, because an empty message is legal (and falsy)
                    prefix += "-";

                    $.each(this.params, function () {
                        paramValues[this] = $element.attr(prefix + this);
                    });

                    this.adapt({
                        element: element,
                        form: form,
                        message: message,
                        params: paramValues,
                        rules: rules,
                        messages: messages
                    });
                }
            });

            $.extend(rules, { "__dummy__": true });

            if (!skipAttach) {
                valInfo.attachValidation();
            }
        },

        parse: function (selector) {
            /// <summary>
            /// Parses all the HTML elements in the specified selector. It looks for input elements decorated
            /// with the [data-val=true] attribute value and enables validation according to the data-val-*
            /// attribute values.
            /// </summary>
            /// <param name="selector" type="String">Any valid jQuery selector.</param>

            // $forms includes all forms in selector's DOM hierarchy (parent, children and self) that have at least one
            // element with data-val=true
            var $selector = $(selector),
                $forms = $selector.parents()
                                  .addBack()
                                  .filter("form")
                                  .add($selector.find("form"))
                                  .has("[data-val=true]");

            $selector.find("[data-val=true]").each(function () {
                $jQval.unobtrusive.parseElement(this, true);
            });

            $forms.each(function () {
                var info = validationInfo(this);
                if (info) {
                    info.attachValidation();
                }
            });
        }
    };

    adapters = $jQval.unobtrusive.adapters;

    adapters.add = function (adapterName, params, fn) {
        /// <summary>Adds a new adapter to convert unobtrusive HTML into a jQuery Validate validation.</summary>
        /// <param name="adapterName" type="String">The name of the adapter to be added. This matches the name used
        /// in the data-val-nnnn HTML attribute (where nnnn is the adapter name).</param>
        /// <param name="params" type="Array" optional="true">[Optional] An array of parameter names (strings) that will
        /// be extracted from the data-val-nnnn-mmmm HTML attributes (where nnnn is the adapter name, and
        /// mmmm is the parameter name).</param>
        /// <param name="fn" type="Function">The function to call, which adapts the values from the HTML
        /// attributes into jQuery Validate rules and/or messages.</param>
        /// <returns type="jQuery.validator.unobtrusive.adapters" />
        if (!fn) {  // Called with no params, just a function
            fn = params;
            params = [];
        }
        this.push({ name: adapterName, params: params, adapt: fn });
        return this;
    };

    adapters.addBool = function (adapterName, ruleName) {
        /// <summary>Adds a new adapter to convert unobtrusive HTML into a jQuery Validate validation, where
        /// the jQuery Validate validation rule has no parameter values.</summary>
        /// <param name="adapterName" type="String">The name of the adapter to be added. This matches the name used
        /// in the data-val-nnnn HTML attribute (where nnnn is the adapter name).</param>
        /// <param name="ruleName" type="String" optional="true">[Optional] The name of the jQuery Validate rule. If not provided, the value
        /// of adapterName will be used instead.</param>
        /// <returns type="jQuery.validator.unobtrusive.adapters" />
        return this.add(adapterName, function (options) {
            setValidationValues(options, ruleName || adapterName, true);
        });
    };

    adapters.addMinMax = function (adapterName, minRuleName, maxRuleName, minMaxRuleName, minAttribute, maxAttribute) {
        /// <summary>Adds a new adapter to convert unobtrusive HTML into a jQuery Validate validation, where
        /// the jQuery Validate validation has three potential rules (one for min-only, one for max-only, and
        /// one for min-and-max). The HTML parameters are expected to be named -min and -max.</summary>
        /// <param name="adapterName" type="String">The name of the adapter to be added. This matches the name used
        /// in the data-val-nnnn HTML attribute (where nnnn is the adapter name).</param>
        /// <param name="minRuleName" type="String">The name of the jQuery Validate rule to be used when you only
        /// have a minimum value.</param>
        /// <param name="maxRuleName" type="String">The name of the jQuery Validate rule to be used when you only
        /// have a maximum value.</param>
        /// <param name="minMaxRuleName" type="String">The name of the jQuery Validate rule to be used when you
        /// have both a minimum and maximum value.</param>
        /// <param name="minAttribute" type="String" optional="true">[Optional] The name of the HTML attribute that
        /// contains the minimum value. The default is "min".</param>
        /// <param name="maxAttribute" type="String" optional="true">[Optional] The name of the HTML attribute that
        /// contains the maximum value. The default is "max".</param>
        /// <returns type="jQuery.validator.unobtrusive.adapters" />
        return this.add(adapterName, [minAttribute || "min", maxAttribute || "max"], function (options) {
            var min = options.params.min,
                max = options.params.max;

            if (min && max) {
                setValidationValues(options, minMaxRuleName, [min, max]);
            }
            else if (min) {
                setValidationValues(options, minRuleName, min);
            }
            else if (max) {
                setValidationValues(options, maxRuleName, max);
            }
        });
    };

    adapters.addSingleVal = function (adapterName, attribute, ruleName) {
        /// <summary>Adds a new adapter to convert unobtrusive HTML into a jQuery Validate validation, where
        /// the jQuery Validate validation rule has a single value.</summary>
        /// <param name="adapterName" type="String">The name of the adapter to be added. This matches the name used
        /// in the data-val-nnnn HTML attribute(where nnnn is the adapter name).</param>
        /// <param name="attribute" type="String">[Optional] The name of the HTML attribute that contains the value.
        /// The default is "val".</param>
        /// <param name="ruleName" type="String" optional="true">[Optional] The name of the jQuery Validate rule. If not provided, the value
        /// of adapterName will be used instead.</param>
        /// <returns type="jQuery.validator.unobtrusive.adapters" />
        return this.add(adapterName, [attribute || "val"], function (options) {
            setValidationValues(options, ruleName || adapterName, options.params[attribute]);
        });
    };

    $jQval.addMethod("__dummy__", function (value, element, params) {
        return true;
    });

    $jQval.addMethod("regex", function (value, element, params) {
        var match;
        if (this.optional(element)) {
            return true;
        }

        match = new RegExp(params).exec(value);
        return (match && (match.index === 0) && (match[0].length === value.length));
    });

    $jQval.addMethod("nonalphamin", function (value, element, nonalphamin) {
        var match;
        if (nonalphamin) {
            match = value.match(/\W/g);
            match = match && match.length >= nonalphamin;
        }
        return match;
    });

    if ($jQval.methods.extension) {
        adapters.addSingleVal("accept", "mimtype");
        adapters.addSingleVal("extension", "extension");
    } else {
        // for backward compatibility, when the 'extension' validation method does not exist, such as with versions
        // of JQuery Validation plugin prior to 1.10, we should use the 'accept' method for
        // validating the extension, and ignore mime-type validations as they are not supported.
        adapters.addSingleVal("extension", "extension", "accept");
    }

    adapters.addSingleVal("regex", "pattern");
    adapters.addBool("creditcard").addBool("date").addBool("digits").addBool("email").addBool("number").addBool("url");
    adapters.addMinMax("length", "minlength", "maxlength", "rangelength").addMinMax("range", "min", "max", "range");
    adapters.addMinMax("minlength", "minlength").addMinMax("maxlength", "minlength", "maxlength");
    adapters.add("equalto", ["other"], function (options) {
        var prefix = getModelPrefix(options.element.name),
            other = options.params.other,
            fullOtherName = appendModelPrefix(other, prefix),
            element = $(options.form).find(":input").filter("[name='" + escapeAttributeValue(fullOtherName) + "']")[0];

        setValidationValues(options, "equalTo", element);
    });
    adapters.add("required", function (options) {
        // jQuery Validate equates "required" with "mandatory" for checkbox elements
        if (options.element.tagName.toUpperCase() !== "INPUT" || options.element.type.toUpperCase() !== "CHECKBOX") {
            setValidationValues(options, "required", true);
        }
    });
    adapters.add("remote", ["url", "type", "additionalfields"], function (options) {
        var value = {
            url: options.params.url,
            type: options.params.type || "GET",
            data: {}
        },
            prefix = getModelPrefix(options.element.name);

        $.each(splitAndTrim(options.params.additionalfields || options.element.name), function (i, fieldName) {
            var paramName = appendModelPrefix(fieldName, prefix);
            value.data[paramName] = function () {
                var field = $(options.form).find(":input").filter("[name='" + escapeAttributeValue(paramName) + "']");
                // For checkboxes and radio buttons, only pick up values from checked fields.
                if (field.is(":checkbox")) {
                    return field.filter(":checked").val() || field.filter(":hidden").val() || '';
                }
                else if (field.is(":radio")) {
                    return field.filter(":checked").val() || '';
                }
                return field.val();
            };
        });

        setValidationValues(options, "remote", value);
    });
    adapters.add("password", ["min", "nonalphamin", "regex"], function (options) {
        if (options.params.min) {
            setValidationValues(options, "minlength", options.params.min);
        }
        if (options.params.nonalphamin) {
            setValidationValues(options, "nonalphamin", options.params.nonalphamin);
        }
        if (options.params.regex) {
            setValidationValues(options, "regex", options.params.regex);
        }
    });

    $(function () {
        $jQval.unobtrusive.parse(document);
    });
}(jQuery));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! tether 1.4.3 */

(function(root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports === 'object') {
    module.exports = factory(require, exports, module);
  } else {
    root.Tether = factory();
  }
}(this, function(require, exports, module) {

'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var TetherBase = undefined;
if (typeof TetherBase === 'undefined') {
  TetherBase = { modules: [] };
}

var zeroElement = null;

// Same as native getBoundingClientRect, except it takes into account parent <frame> offsets
// if the element lies within a nested document (<frame> or <iframe>-like).
function getActualBoundingClientRect(node) {
  var boundingRect = node.getBoundingClientRect();

  // The original object returned by getBoundingClientRect is immutable, so we clone it
  // We can't use extend because the properties are not considered part of the object by hasOwnProperty in IE9
  var rect = {};
  for (var k in boundingRect) {
    rect[k] = boundingRect[k];
  }

  if (node.ownerDocument !== document) {
    var _frameElement = node.ownerDocument.defaultView.frameElement;
    if (_frameElement) {
      var frameRect = getActualBoundingClientRect(_frameElement);
      rect.top += frameRect.top;
      rect.bottom += frameRect.top;
      rect.left += frameRect.left;
      rect.right += frameRect.left;
    }
  }

  return rect;
}

function getScrollParents(el) {
  // In firefox if the el is inside an iframe with display: none; window.getComputedStyle() will return null;
  // https://bugzilla.mozilla.org/show_bug.cgi?id=548397
  var computedStyle = getComputedStyle(el) || {};
  var position = computedStyle.position;
  var parents = [];

  if (position === 'fixed') {
    return [el];
  }

  var parent = el;
  while ((parent = parent.parentNode) && parent && parent.nodeType === 1) {
    var style = undefined;
    try {
      style = getComputedStyle(parent);
    } catch (err) {}

    if (typeof style === 'undefined' || style === null) {
      parents.push(parent);
      return parents;
    }

    var _style = style;
    var overflow = _style.overflow;
    var overflowX = _style.overflowX;
    var overflowY = _style.overflowY;

    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      if (position !== 'absolute' || ['relative', 'absolute', 'fixed'].indexOf(style.position) >= 0) {
        parents.push(parent);
      }
    }
  }

  parents.push(el.ownerDocument.body);

  // If the node is within a frame, account for the parent window scroll
  if (el.ownerDocument !== document) {
    parents.push(el.ownerDocument.defaultView);
  }

  return parents;
}

var uniqueId = (function () {
  var id = 0;
  return function () {
    return ++id;
  };
})();

var zeroPosCache = {};
var getOrigin = function getOrigin() {
  // getBoundingClientRect is unfortunately too accurate.  It introduces a pixel or two of
  // jitter as the user scrolls that messes with our ability to detect if two positions
  // are equivilant or not.  We place an element at the top left of the page that will
  // get the same jitter, so we can cancel the two out.
  var node = zeroElement;
  if (!node || !document.body.contains(node)) {
    node = document.createElement('div');
    node.setAttribute('data-tether-id', uniqueId());
    extend(node.style, {
      top: 0,
      left: 0,
      position: 'absolute'
    });

    document.body.appendChild(node);

    zeroElement = node;
  }

  var id = node.getAttribute('data-tether-id');
  if (typeof zeroPosCache[id] === 'undefined') {
    zeroPosCache[id] = getActualBoundingClientRect(node);

    // Clear the cache when this position call is done
    defer(function () {
      delete zeroPosCache[id];
    });
  }

  return zeroPosCache[id];
};

function removeUtilElements() {
  if (zeroElement) {
    document.body.removeChild(zeroElement);
  }
  zeroElement = null;
};

function getBounds(el) {
  var doc = undefined;
  if (el === document) {
    doc = document;
    el = document.documentElement;
  } else {
    doc = el.ownerDocument;
  }

  var docEl = doc.documentElement;

  var box = getActualBoundingClientRect(el);

  var origin = getOrigin();

  box.top -= origin.top;
  box.left -= origin.left;

  if (typeof box.width === 'undefined') {
    box.width = document.body.scrollWidth - box.left - box.right;
  }
  if (typeof box.height === 'undefined') {
    box.height = document.body.scrollHeight - box.top - box.bottom;
  }

  box.top = box.top - docEl.clientTop;
  box.left = box.left - docEl.clientLeft;
  box.right = doc.body.clientWidth - box.width - box.left;
  box.bottom = doc.body.clientHeight - box.height - box.top;

  return box;
}

function getOffsetParent(el) {
  return el.offsetParent || document.documentElement;
}

var _scrollBarSize = null;
function getScrollBarSize() {
  if (_scrollBarSize) {
    return _scrollBarSize;
  }
  var inner = document.createElement('div');
  inner.style.width = '100%';
  inner.style.height = '200px';

  var outer = document.createElement('div');
  extend(outer.style, {
    position: 'absolute',
    top: 0,
    left: 0,
    pointerEvents: 'none',
    visibility: 'hidden',
    width: '200px',
    height: '150px',
    overflow: 'hidden'
  });

  outer.appendChild(inner);

  document.body.appendChild(outer);

  var widthContained = inner.offsetWidth;
  outer.style.overflow = 'scroll';
  var widthScroll = inner.offsetWidth;

  if (widthContained === widthScroll) {
    widthScroll = outer.clientWidth;
  }

  document.body.removeChild(outer);

  var width = widthContained - widthScroll;

  _scrollBarSize = { width: width, height: width };
  return _scrollBarSize;
}

function extend() {
  var out = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var args = [];

  Array.prototype.push.apply(args, arguments);

  args.slice(1).forEach(function (obj) {
    if (obj) {
      for (var key in obj) {
        if (({}).hasOwnProperty.call(obj, key)) {
          out[key] = obj[key];
        }
      }
    }
  });

  return out;
}

function removeClass(el, name) {
  if (typeof el.classList !== 'undefined') {
    name.split(' ').forEach(function (cls) {
      if (cls.trim()) {
        el.classList.remove(cls);
      }
    });
  } else {
    var regex = new RegExp('(^| )' + name.split(' ').join('|') + '( |$)', 'gi');
    var className = getClassName(el).replace(regex, ' ');
    setClassName(el, className);
  }
}

function addClass(el, name) {
  if (typeof el.classList !== 'undefined') {
    name.split(' ').forEach(function (cls) {
      if (cls.trim()) {
        el.classList.add(cls);
      }
    });
  } else {
    removeClass(el, name);
    var cls = getClassName(el) + (' ' + name);
    setClassName(el, cls);
  }
}

function hasClass(el, name) {
  if (typeof el.classList !== 'undefined') {
    return el.classList.contains(name);
  }
  var className = getClassName(el);
  return new RegExp('(^| )' + name + '( |$)', 'gi').test(className);
}

function getClassName(el) {
  // Can't use just SVGAnimatedString here since nodes within a Frame in IE have
  // completely separately SVGAnimatedString base classes
  if (el.className instanceof el.ownerDocument.defaultView.SVGAnimatedString) {
    return el.className.baseVal;
  }
  return el.className;
}

function setClassName(el, className) {
  el.setAttribute('class', className);
}

function updateClasses(el, add, all) {
  // Of the set of 'all' classes, we need the 'add' classes, and only the
  // 'add' classes to be set.
  all.forEach(function (cls) {
    if (add.indexOf(cls) === -1 && hasClass(el, cls)) {
      removeClass(el, cls);
    }
  });

  add.forEach(function (cls) {
    if (!hasClass(el, cls)) {
      addClass(el, cls);
    }
  });
}

var deferred = [];

var defer = function defer(fn) {
  deferred.push(fn);
};

var flush = function flush() {
  var fn = undefined;
  while (fn = deferred.pop()) {
    fn();
  }
};

var Evented = (function () {
  function Evented() {
    _classCallCheck(this, Evented);
  }

  _createClass(Evented, [{
    key: 'on',
    value: function on(event, handler, ctx) {
      var once = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

      if (typeof this.bindings === 'undefined') {
        this.bindings = {};
      }
      if (typeof this.bindings[event] === 'undefined') {
        this.bindings[event] = [];
      }
      this.bindings[event].push({ handler: handler, ctx: ctx, once: once });
    }
  }, {
    key: 'once',
    value: function once(event, handler, ctx) {
      this.on(event, handler, ctx, true);
    }
  }, {
    key: 'off',
    value: function off(event, handler) {
      if (typeof this.bindings === 'undefined' || typeof this.bindings[event] === 'undefined') {
        return;
      }

      if (typeof handler === 'undefined') {
        delete this.bindings[event];
      } else {
        var i = 0;
        while (i < this.bindings[event].length) {
          if (this.bindings[event][i].handler === handler) {
            this.bindings[event].splice(i, 1);
          } else {
            ++i;
          }
        }
      }
    }
  }, {
    key: 'trigger',
    value: function trigger(event) {
      if (typeof this.bindings !== 'undefined' && this.bindings[event]) {
        var i = 0;

        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        while (i < this.bindings[event].length) {
          var _bindings$event$i = this.bindings[event][i];
          var handler = _bindings$event$i.handler;
          var ctx = _bindings$event$i.ctx;
          var once = _bindings$event$i.once;

          var context = ctx;
          if (typeof context === 'undefined') {
            context = this;
          }

          handler.apply(context, args);

          if (once) {
            this.bindings[event].splice(i, 1);
          } else {
            ++i;
          }
        }
      }
    }
  }]);

  return Evented;
})();

TetherBase.Utils = {
  getActualBoundingClientRect: getActualBoundingClientRect,
  getScrollParents: getScrollParents,
  getBounds: getBounds,
  getOffsetParent: getOffsetParent,
  extend: extend,
  addClass: addClass,
  removeClass: removeClass,
  hasClass: hasClass,
  updateClasses: updateClasses,
  defer: defer,
  flush: flush,
  uniqueId: uniqueId,
  Evented: Evented,
  getScrollBarSize: getScrollBarSize,
  removeUtilElements: removeUtilElements
};
/* globals TetherBase, performance */

'use strict';

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x6, _x7, _x8) { var _again = true; _function: while (_again) { var object = _x6, property = _x7, receiver = _x8; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x6 = parent; _x7 = property; _x8 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

if (typeof TetherBase === 'undefined') {
  throw new Error('You must include the utils.js file before tether.js');
}

var _TetherBase$Utils = TetherBase.Utils;
var getScrollParents = _TetherBase$Utils.getScrollParents;
var getBounds = _TetherBase$Utils.getBounds;
var getOffsetParent = _TetherBase$Utils.getOffsetParent;
var extend = _TetherBase$Utils.extend;
var addClass = _TetherBase$Utils.addClass;
var removeClass = _TetherBase$Utils.removeClass;
var updateClasses = _TetherBase$Utils.updateClasses;
var defer = _TetherBase$Utils.defer;
var flush = _TetherBase$Utils.flush;
var getScrollBarSize = _TetherBase$Utils.getScrollBarSize;
var removeUtilElements = _TetherBase$Utils.removeUtilElements;

function within(a, b) {
  var diff = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];

  return a + diff >= b && b >= a - diff;
}

var transformKey = (function () {
  if (typeof document === 'undefined') {
    return '';
  }
  var el = document.createElement('div');

  var transforms = ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform'];
  for (var i = 0; i < transforms.length; ++i) {
    var key = transforms[i];
    if (el.style[key] !== undefined) {
      return key;
    }
  }
})();

var tethers = [];

var position = function position() {
  tethers.forEach(function (tether) {
    tether.position(false);
  });
  flush();
};

function now() {
  if (typeof performance === 'object' && typeof performance.now === 'function') {
    return performance.now();
  }
  return +new Date();
}

(function () {
  var lastCall = null;
  var lastDuration = null;
  var pendingTimeout = null;

  var tick = function tick() {
    if (typeof lastDuration !== 'undefined' && lastDuration > 16) {
      // We voluntarily throttle ourselves if we can't manage 60fps
      lastDuration = Math.min(lastDuration - 16, 250);

      // Just in case this is the last event, remember to position just once more
      pendingTimeout = setTimeout(tick, 250);
      return;
    }

    if (typeof lastCall !== 'undefined' && now() - lastCall < 10) {
      // Some browsers call events a little too frequently, refuse to run more than is reasonable
      return;
    }

    if (pendingTimeout != null) {
      clearTimeout(pendingTimeout);
      pendingTimeout = null;
    }

    lastCall = now();
    position();
    lastDuration = now() - lastCall;
  };

  if (typeof window !== 'undefined' && typeof window.addEventListener !== 'undefined') {
    ['resize', 'scroll', 'touchmove'].forEach(function (event) {
      window.addEventListener(event, tick);
    });
  }
})();

var MIRROR_LR = {
  center: 'center',
  left: 'right',
  right: 'left'
};

var MIRROR_TB = {
  middle: 'middle',
  top: 'bottom',
  bottom: 'top'
};

var OFFSET_MAP = {
  top: 0,
  left: 0,
  middle: '50%',
  center: '50%',
  bottom: '100%',
  right: '100%'
};

var autoToFixedAttachment = function autoToFixedAttachment(attachment, relativeToAttachment) {
  var left = attachment.left;
  var top = attachment.top;

  if (left === 'auto') {
    left = MIRROR_LR[relativeToAttachment.left];
  }

  if (top === 'auto') {
    top = MIRROR_TB[relativeToAttachment.top];
  }

  return { left: left, top: top };
};

var attachmentToOffset = function attachmentToOffset(attachment) {
  var left = attachment.left;
  var top = attachment.top;

  if (typeof OFFSET_MAP[attachment.left] !== 'undefined') {
    left = OFFSET_MAP[attachment.left];
  }

  if (typeof OFFSET_MAP[attachment.top] !== 'undefined') {
    top = OFFSET_MAP[attachment.top];
  }

  return { left: left, top: top };
};

function addOffset() {
  var out = { top: 0, left: 0 };

  for (var _len = arguments.length, offsets = Array(_len), _key = 0; _key < _len; _key++) {
    offsets[_key] = arguments[_key];
  }

  offsets.forEach(function (_ref) {
    var top = _ref.top;
    var left = _ref.left;

    if (typeof top === 'string') {
      top = parseFloat(top, 10);
    }
    if (typeof left === 'string') {
      left = parseFloat(left, 10);
    }

    out.top += top;
    out.left += left;
  });

  return out;
}

function offsetToPx(offset, size) {
  if (typeof offset.left === 'string' && offset.left.indexOf('%') !== -1) {
    offset.left = parseFloat(offset.left, 10) / 100 * size.width;
  }
  if (typeof offset.top === 'string' && offset.top.indexOf('%') !== -1) {
    offset.top = parseFloat(offset.top, 10) / 100 * size.height;
  }

  return offset;
}

var parseOffset = function parseOffset(value) {
  var _value$split = value.split(' ');

  var _value$split2 = _slicedToArray(_value$split, 2);

  var top = _value$split2[0];
  var left = _value$split2[1];

  return { top: top, left: left };
};
var parseAttachment = parseOffset;

var TetherClass = (function (_Evented) {
  _inherits(TetherClass, _Evented);

  function TetherClass(options) {
    var _this = this;

    _classCallCheck(this, TetherClass);

    _get(Object.getPrototypeOf(TetherClass.prototype), 'constructor', this).call(this);
    this.position = this.position.bind(this);

    tethers.push(this);

    this.history = [];

    this.setOptions(options, false);

    TetherBase.modules.forEach(function (module) {
      if (typeof module.initialize !== 'undefined') {
        module.initialize.call(_this);
      }
    });

    this.position();
  }

  _createClass(TetherClass, [{
    key: 'getClass',
    value: function getClass() {
      var key = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
      var classes = this.options.classes;

      if (typeof classes !== 'undefined' && classes[key]) {
        return this.options.classes[key];
      } else if (this.options.classPrefix) {
        return this.options.classPrefix + '-' + key;
      } else {
        return key;
      }
    }
  }, {
    key: 'setOptions',
    value: function setOptions(options) {
      var _this2 = this;

      var pos = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

      var defaults = {
        offset: '0 0',
        targetOffset: '0 0',
        targetAttachment: 'auto auto',
        classPrefix: 'tether'
      };

      this.options = extend(defaults, options);

      var _options = this.options;
      var element = _options.element;
      var target = _options.target;
      var targetModifier = _options.targetModifier;

      this.element = element;
      this.target = target;
      this.targetModifier = targetModifier;

      if (this.target === 'viewport') {
        this.target = document.body;
        this.targetModifier = 'visible';
      } else if (this.target === 'scroll-handle') {
        this.target = document.body;
        this.targetModifier = 'scroll-handle';
      }

      ['element', 'target'].forEach(function (key) {
        if (typeof _this2[key] === 'undefined') {
          throw new Error('Tether Error: Both element and target must be defined');
        }

        if (typeof _this2[key].jquery !== 'undefined') {
          _this2[key] = _this2[key][0];
        } else if (typeof _this2[key] === 'string') {
          _this2[key] = document.querySelector(_this2[key]);
        }
      });

      addClass(this.element, this.getClass('element'));
      if (!(this.options.addTargetClasses === false)) {
        addClass(this.target, this.getClass('target'));
      }

      if (!this.options.attachment) {
        throw new Error('Tether Error: You must provide an attachment');
      }

      this.targetAttachment = parseAttachment(this.options.targetAttachment);
      this.attachment = parseAttachment(this.options.attachment);
      this.offset = parseOffset(this.options.offset);
      this.targetOffset = parseOffset(this.options.targetOffset);

      if (typeof this.scrollParents !== 'undefined') {
        this.disable();
      }

      if (this.targetModifier === 'scroll-handle') {
        this.scrollParents = [this.target];
      } else {
        this.scrollParents = getScrollParents(this.target);
      }

      if (!(this.options.enabled === false)) {
        this.enable(pos);
      }
    }
  }, {
    key: 'getTargetBounds',
    value: function getTargetBounds() {
      if (typeof this.targetModifier !== 'undefined') {
        if (this.targetModifier === 'visible') {
          if (this.target === document.body) {
            return { top: pageYOffset, left: pageXOffset, height: innerHeight, width: innerWidth };
          } else {
            var bounds = getBounds(this.target);

            var out = {
              height: bounds.height,
              width: bounds.width,
              top: bounds.top,
              left: bounds.left
            };

            out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));
            out.height = Math.min(out.height, bounds.height - (bounds.top + bounds.height - (pageYOffset + innerHeight)));
            out.height = Math.min(innerHeight, out.height);
            out.height -= 2;

            out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));
            out.width = Math.min(out.width, bounds.width - (bounds.left + bounds.width - (pageXOffset + innerWidth)));
            out.width = Math.min(innerWidth, out.width);
            out.width -= 2;

            if (out.top < pageYOffset) {
              out.top = pageYOffset;
            }
            if (out.left < pageXOffset) {
              out.left = pageXOffset;
            }

            return out;
          }
        } else if (this.targetModifier === 'scroll-handle') {
          var bounds = undefined;
          var target = this.target;
          if (target === document.body) {
            target = document.documentElement;

            bounds = {
              left: pageXOffset,
              top: pageYOffset,
              height: innerHeight,
              width: innerWidth
            };
          } else {
            bounds = getBounds(target);
          }

          var style = getComputedStyle(target);

          var hasBottomScroll = target.scrollWidth > target.clientWidth || [style.overflow, style.overflowX].indexOf('scroll') >= 0 || this.target !== document.body;

          var scrollBottom = 0;
          if (hasBottomScroll) {
            scrollBottom = 15;
          }

          var height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;

          var out = {
            width: 15,
            height: height * 0.975 * (height / target.scrollHeight),
            left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15
          };

          var fitAdj = 0;
          if (height < 408 && this.target === document.body) {
            fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;
          }

          if (this.target !== document.body) {
            out.height = Math.max(out.height, 24);
          }

          var scrollPercentage = this.target.scrollTop / (target.scrollHeight - height);
          out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);

          if (this.target === document.body) {
            out.height = Math.max(out.height, 24);
          }

          return out;
        }
      } else {
        return getBounds(this.target);
      }
    }
  }, {
    key: 'clearCache',
    value: function clearCache() {
      this._cache = {};
    }
  }, {
    key: 'cache',
    value: function cache(k, getter) {
      // More than one module will often need the same DOM info, so
      // we keep a cache which is cleared on each position call
      if (typeof this._cache === 'undefined') {
        this._cache = {};
      }

      if (typeof this._cache[k] === 'undefined') {
        this._cache[k] = getter.call(this);
      }

      return this._cache[k];
    }
  }, {
    key: 'enable',
    value: function enable() {
      var _this3 = this;

      var pos = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

      if (!(this.options.addTargetClasses === false)) {
        addClass(this.target, this.getClass('enabled'));
      }
      addClass(this.element, this.getClass('enabled'));
      this.enabled = true;

      this.scrollParents.forEach(function (parent) {
        if (parent !== _this3.target.ownerDocument) {
          parent.addEventListener('scroll', _this3.position);
        }
      });

      if (pos) {
        this.position();
      }
    }
  }, {
    key: 'disable',
    value: function disable() {
      var _this4 = this;

      removeClass(this.target, this.getClass('enabled'));
      removeClass(this.element, this.getClass('enabled'));
      this.enabled = false;

      if (typeof this.scrollParents !== 'undefined') {
        this.scrollParents.forEach(function (parent) {
          parent.removeEventListener('scroll', _this4.position);
        });
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var _this5 = this;

      this.disable();

      tethers.forEach(function (tether, i) {
        if (tether === _this5) {
          tethers.splice(i, 1);
        }
      });

      // Remove any elements we were using for convenience from the DOM
      if (tethers.length === 0) {
        removeUtilElements();
      }
    }
  }, {
    key: 'updateAttachClasses',
    value: function updateAttachClasses(elementAttach, targetAttach) {
      var _this6 = this;

      elementAttach = elementAttach || this.attachment;
      targetAttach = targetAttach || this.targetAttachment;
      var sides = ['left', 'top', 'bottom', 'right', 'middle', 'center'];

      if (typeof this._addAttachClasses !== 'undefined' && this._addAttachClasses.length) {
        // updateAttachClasses can be called more than once in a position call, so
        // we need to clean up after ourselves such that when the last defer gets
        // ran it doesn't add any extra classes from previous calls.
        this._addAttachClasses.splice(0, this._addAttachClasses.length);
      }

      if (typeof this._addAttachClasses === 'undefined') {
        this._addAttachClasses = [];
      }
      var add = this._addAttachClasses;

      if (elementAttach.top) {
        add.push(this.getClass('element-attached') + '-' + elementAttach.top);
      }
      if (elementAttach.left) {
        add.push(this.getClass('element-attached') + '-' + elementAttach.left);
      }
      if (targetAttach.top) {
        add.push(this.getClass('target-attached') + '-' + targetAttach.top);
      }
      if (targetAttach.left) {
        add.push(this.getClass('target-attached') + '-' + targetAttach.left);
      }

      var all = [];
      sides.forEach(function (side) {
        all.push(_this6.getClass('element-attached') + '-' + side);
        all.push(_this6.getClass('target-attached') + '-' + side);
      });

      defer(function () {
        if (!(typeof _this6._addAttachClasses !== 'undefined')) {
          return;
        }

        updateClasses(_this6.element, _this6._addAttachClasses, all);
        if (!(_this6.options.addTargetClasses === false)) {
          updateClasses(_this6.target, _this6._addAttachClasses, all);
        }

        delete _this6._addAttachClasses;
      });
    }
  }, {
    key: 'position',
    value: function position() {
      var _this7 = this;

      var flushChanges = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

      // flushChanges commits the changes immediately, leave true unless you are positioning multiple
      // tethers (in which case call Tether.Utils.flush yourself when you're done)

      if (!this.enabled) {
        return;
      }

      this.clearCache();

      // Turn 'auto' attachments into the appropriate corner or edge
      var targetAttachment = autoToFixedAttachment(this.targetAttachment, this.attachment);

      this.updateAttachClasses(this.attachment, targetAttachment);

      var elementPos = this.cache('element-bounds', function () {
        return getBounds(_this7.element);
      });

      var width = elementPos.width;
      var height = elementPos.height;

      if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {
        var _lastSize = this.lastSize;

        // We cache the height and width to make it possible to position elements that are
        // getting hidden.
        width = _lastSize.width;
        height = _lastSize.height;
      } else {
        this.lastSize = { width: width, height: height };
      }

      var targetPos = this.cache('target-bounds', function () {
        return _this7.getTargetBounds();
      });
      var targetSize = targetPos;

      // Get an actual px offset from the attachment
      var offset = offsetToPx(attachmentToOffset(this.attachment), { width: width, height: height });
      var targetOffset = offsetToPx(attachmentToOffset(targetAttachment), targetSize);

      var manualOffset = offsetToPx(this.offset, { width: width, height: height });
      var manualTargetOffset = offsetToPx(this.targetOffset, targetSize);

      // Add the manually provided offset
      offset = addOffset(offset, manualOffset);
      targetOffset = addOffset(targetOffset, manualTargetOffset);

      // It's now our goal to make (element position + offset) == (target position + target offset)
      var left = targetPos.left + targetOffset.left - offset.left;
      var top = targetPos.top + targetOffset.top - offset.top;

      for (var i = 0; i < TetherBase.modules.length; ++i) {
        var _module2 = TetherBase.modules[i];
        var ret = _module2.position.call(this, {
          left: left,
          top: top,
          targetAttachment: targetAttachment,
          targetPos: targetPos,
          elementPos: elementPos,
          offset: offset,
          targetOffset: targetOffset,
          manualOffset: manualOffset,
          manualTargetOffset: manualTargetOffset,
          scrollbarSize: scrollbarSize,
          attachment: this.attachment
        });

        if (ret === false) {
          return false;
        } else if (typeof ret === 'undefined' || typeof ret !== 'object') {
          continue;
        } else {
          top = ret.top;
          left = ret.left;
        }
      }

      // We describe the position three different ways to give the optimizer
      // a chance to decide the best possible way to position the element
      // with the fewest repaints.
      var next = {
        // It's position relative to the page (absolute positioning when
        // the element is a child of the body)
        page: {
          top: top,
          left: left
        },

        // It's position relative to the viewport (fixed positioning)
        viewport: {
          top: top - pageYOffset,
          bottom: pageYOffset - top - height + innerHeight,
          left: left - pageXOffset,
          right: pageXOffset - left - width + innerWidth
        }
      };

      var doc = this.target.ownerDocument;
      var win = doc.defaultView;

      var scrollbarSize = undefined;
      if (win.innerHeight > doc.documentElement.clientHeight) {
        scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);
        next.viewport.bottom -= scrollbarSize.height;
      }

      if (win.innerWidth > doc.documentElement.clientWidth) {
        scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);
        next.viewport.right -= scrollbarSize.width;
      }

      if (['', 'static'].indexOf(doc.body.style.position) === -1 || ['', 'static'].indexOf(doc.body.parentElement.style.position) === -1) {
        // Absolute positioning in the body will be relative to the page, not the 'initial containing block'
        next.page.bottom = doc.body.scrollHeight - top - height;
        next.page.right = doc.body.scrollWidth - left - width;
      }

      if (typeof this.options.optimizations !== 'undefined' && this.options.optimizations.moveElement !== false && !(typeof this.targetModifier !== 'undefined')) {
        (function () {
          var offsetParent = _this7.cache('target-offsetparent', function () {
            return getOffsetParent(_this7.target);
          });
          var offsetPosition = _this7.cache('target-offsetparent-bounds', function () {
            return getBounds(offsetParent);
          });
          var offsetParentStyle = getComputedStyle(offsetParent);
          var offsetParentSize = offsetPosition;

          var offsetBorder = {};
          ['Top', 'Left', 'Bottom', 'Right'].forEach(function (side) {
            offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle['border' + side + 'Width']);
          });

          offsetPosition.right = doc.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;
          offsetPosition.bottom = doc.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;

          if (next.page.top >= offsetPosition.top + offsetBorder.top && next.page.bottom >= offsetPosition.bottom) {
            if (next.page.left >= offsetPosition.left + offsetBorder.left && next.page.right >= offsetPosition.right) {
              // We're within the visible part of the target's scroll parent
              var scrollTop = offsetParent.scrollTop;
              var scrollLeft = offsetParent.scrollLeft;

              // It's position relative to the target's offset parent (absolute positioning when
              // the element is moved to be a child of the target's offset parent).
              next.offset = {
                top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,
                left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left
              };
            }
          }
        })();
      }

      // We could also travel up the DOM and try each containing context, rather than only
      // looking at the body, but we're gonna get diminishing returns.

      this.move(next);

      this.history.unshift(next);

      if (this.history.length > 3) {
        this.history.pop();
      }

      if (flushChanges) {
        flush();
      }

      return true;
    }

    // THE ISSUE
  }, {
    key: 'move',
    value: function move(pos) {
      var _this8 = this;

      if (!(typeof this.element.parentNode !== 'undefined')) {
        return;
      }

      var same = {};

      for (var type in pos) {
        same[type] = {};

        for (var key in pos[type]) {
          var found = false;

          for (var i = 0; i < this.history.length; ++i) {
            var point = this.history[i];
            if (typeof point[type] !== 'undefined' && !within(point[type][key], pos[type][key])) {
              found = true;
              break;
            }
          }

          if (!found) {
            same[type][key] = true;
          }
        }
      }

      var css = { top: '', left: '', right: '', bottom: '' };

      var transcribe = function transcribe(_same, _pos) {
        var hasOptimizations = typeof _this8.options.optimizations !== 'undefined';
        var gpu = hasOptimizations ? _this8.options.optimizations.gpu : null;
        if (gpu !== false) {
          var yPos = undefined,
              xPos = undefined;
          if (_same.top) {
            css.top = 0;
            yPos = _pos.top;
          } else {
            css.bottom = 0;
            yPos = -_pos.bottom;
          }

          if (_same.left) {
            css.left = 0;
            xPos = _pos.left;
          } else {
            css.right = 0;
            xPos = -_pos.right;
          }

          if (window.matchMedia) {
            // HubSpot/tether#207
            var retina = window.matchMedia('only screen and (min-resolution: 1.3dppx)').matches || window.matchMedia('only screen and (-webkit-min-device-pixel-ratio: 1.3)').matches;
            if (!retina) {
              xPos = Math.round(xPos);
              yPos = Math.round(yPos);
            }
          }

          css[transformKey] = 'translateX(' + xPos + 'px) translateY(' + yPos + 'px)';

          if (transformKey !== 'msTransform') {
            // The Z transform will keep this in the GPU (faster, and prevents artifacts),
            // but IE9 doesn't support 3d transforms and will choke.
            css[transformKey] += " translateZ(0)";
          }
        } else {
          if (_same.top) {
            css.top = _pos.top + 'px';
          } else {
            css.bottom = _pos.bottom + 'px';
          }

          if (_same.left) {
            css.left = _pos.left + 'px';
          } else {
            css.right = _pos.right + 'px';
          }
        }
      };

      var moved = false;
      if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {
        css.position = 'absolute';
        transcribe(same.page, pos.page);
      } else if ((same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {
        css.position = 'fixed';
        transcribe(same.viewport, pos.viewport);
      } else if (typeof same.offset !== 'undefined' && same.offset.top && same.offset.left) {
        (function () {
          css.position = 'absolute';
          var offsetParent = _this8.cache('target-offsetparent', function () {
            return getOffsetParent(_this8.target);
          });

          if (getOffsetParent(_this8.element) !== offsetParent) {
            defer(function () {
              _this8.element.parentNode.removeChild(_this8.element);
              offsetParent.appendChild(_this8.element);
            });
          }

          transcribe(same.offset, pos.offset);
          moved = true;
        })();
      } else {
        css.position = 'absolute';
        transcribe({ top: true, left: true }, pos.page);
      }

      if (!moved) {
        if (this.options.bodyElement) {
          if (this.element.parentNode !== this.options.bodyElement) {
            this.options.bodyElement.appendChild(this.element);
          }
        } else {
          var offsetParentIsBody = true;
          var currentNode = this.element.parentNode;
          while (currentNode && currentNode.nodeType === 1 && currentNode.tagName !== 'BODY') {
            if (getComputedStyle(currentNode).position !== 'static') {
              offsetParentIsBody = false;
              break;
            }

            currentNode = currentNode.parentNode;
          }

          if (!offsetParentIsBody) {
            this.element.parentNode.removeChild(this.element);
            this.element.ownerDocument.body.appendChild(this.element);
          }
        }
      }

      // Any css change will trigger a repaint, so let's avoid one if nothing changed
      var writeCSS = {};
      var write = false;
      for (var key in css) {
        var val = css[key];
        var elVal = this.element.style[key];

        if (elVal !== val) {
          write = true;
          writeCSS[key] = val;
        }
      }

      if (write) {
        defer(function () {
          extend(_this8.element.style, writeCSS);
          _this8.trigger('repositioned');
        });
      }
    }
  }]);

  return TetherClass;
})(Evented);

TetherClass.modules = [];

TetherBase.position = position;

var Tether = extend(TetherClass, TetherBase);
/* globals TetherBase */

'use strict';

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

var _TetherBase$Utils = TetherBase.Utils;
var getBounds = _TetherBase$Utils.getBounds;
var extend = _TetherBase$Utils.extend;
var updateClasses = _TetherBase$Utils.updateClasses;
var defer = _TetherBase$Utils.defer;

var BOUNDS_FORMAT = ['left', 'top', 'right', 'bottom'];

function getBoundingRect(tether, to) {
  if (to === 'scrollParent') {
    to = tether.scrollParents[0];
  } else if (to === 'window') {
    to = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset];
  }

  if (to === document) {
    to = to.documentElement;
  }

  if (typeof to.nodeType !== 'undefined') {
    (function () {
      var node = to;
      var size = getBounds(to);
      var pos = size;
      var style = getComputedStyle(to);

      to = [pos.left, pos.top, size.width + pos.left, size.height + pos.top];

      // Account any parent Frames scroll offset
      if (node.ownerDocument !== document) {
        var win = node.ownerDocument.defaultView;
        to[0] += win.pageXOffset;
        to[1] += win.pageYOffset;
        to[2] += win.pageXOffset;
        to[3] += win.pageYOffset;
      }

      BOUNDS_FORMAT.forEach(function (side, i) {
        side = side[0].toUpperCase() + side.substr(1);
        if (side === 'Top' || side === 'Left') {
          to[i] += parseFloat(style['border' + side + 'Width']);
        } else {
          to[i] -= parseFloat(style['border' + side + 'Width']);
        }
      });
    })();
  }

  return to;
}

TetherBase.modules.push({
  position: function position(_ref) {
    var _this = this;

    var top = _ref.top;
    var left = _ref.left;
    var targetAttachment = _ref.targetAttachment;

    if (!this.options.constraints) {
      return true;
    }

    var _cache = this.cache('element-bounds', function () {
      return getBounds(_this.element);
    });

    var height = _cache.height;
    var width = _cache.width;

    if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {
      var _lastSize = this.lastSize;

      // Handle the item getting hidden as a result of our positioning without glitching
      // the classes in and out
      width = _lastSize.width;
      height = _lastSize.height;
    }

    var targetSize = this.cache('target-bounds', function () {
      return _this.getTargetBounds();
    });

    var targetHeight = targetSize.height;
    var targetWidth = targetSize.width;

    var allClasses = [this.getClass('pinned'), this.getClass('out-of-bounds')];

    this.options.constraints.forEach(function (constraint) {
      var outOfBoundsClass = constraint.outOfBoundsClass;
      var pinnedClass = constraint.pinnedClass;

      if (outOfBoundsClass) {
        allClasses.push(outOfBoundsClass);
      }
      if (pinnedClass) {
        allClasses.push(pinnedClass);
      }
    });

    allClasses.forEach(function (cls) {
      ['left', 'top', 'right', 'bottom'].forEach(function (side) {
        allClasses.push(cls + '-' + side);
      });
    });

    var addClasses = [];

    var tAttachment = extend({}, targetAttachment);
    var eAttachment = extend({}, this.attachment);

    this.options.constraints.forEach(function (constraint) {
      var to = constraint.to;
      var attachment = constraint.attachment;
      var pin = constraint.pin;

      if (typeof attachment === 'undefined') {
        attachment = '';
      }

      var changeAttachX = undefined,
          changeAttachY = undefined;
      if (attachment.indexOf(' ') >= 0) {
        var _attachment$split = attachment.split(' ');

        var _attachment$split2 = _slicedToArray(_attachment$split, 2);

        changeAttachY = _attachment$split2[0];
        changeAttachX = _attachment$split2[1];
      } else {
        changeAttachX = changeAttachY = attachment;
      }

      var bounds = getBoundingRect(_this, to);

      if (changeAttachY === 'target' || changeAttachY === 'both') {
        if (top < bounds[1] && tAttachment.top === 'top') {
          top += targetHeight;
          tAttachment.top = 'bottom';
        }

        if (top + height > bounds[3] && tAttachment.top === 'bottom') {
          top -= targetHeight;
          tAttachment.top = 'top';
        }
      }

      if (changeAttachY === 'together') {
        if (tAttachment.top === 'top') {
          if (eAttachment.top === 'bottom' && top < bounds[1]) {
            top += targetHeight;
            tAttachment.top = 'bottom';

            top += height;
            eAttachment.top = 'top';
          } else if (eAttachment.top === 'top' && top + height > bounds[3] && top - (height - targetHeight) >= bounds[1]) {
            top -= height - targetHeight;
            tAttachment.top = 'bottom';

            eAttachment.top = 'bottom';
          }
        }

        if (tAttachment.top === 'bottom') {
          if (eAttachment.top === 'top' && top + height > bounds[3]) {
            top -= targetHeight;
            tAttachment.top = 'top';

            top -= height;
            eAttachment.top = 'bottom';
          } else if (eAttachment.top === 'bottom' && top < bounds[1] && top + (height * 2 - targetHeight) <= bounds[3]) {
            top += height - targetHeight;
            tAttachment.top = 'top';

            eAttachment.top = 'top';
          }
        }

        if (tAttachment.top === 'middle') {
          if (top + height > bounds[3] && eAttachment.top === 'top') {
            top -= height;
            eAttachment.top = 'bottom';
          } else if (top < bounds[1] && eAttachment.top === 'bottom') {
            top += height;
            eAttachment.top = 'top';
          }
        }
      }

      if (changeAttachX === 'target' || changeAttachX === 'both') {
        if (left < bounds[0] && tAttachment.left === 'left') {
          left += targetWidth;
          tAttachment.left = 'right';
        }

        if (left + width > bounds[2] && tAttachment.left === 'right') {
          left -= targetWidth;
          tAttachment.left = 'left';
        }
      }

      if (changeAttachX === 'together') {
        if (left < bounds[0] && tAttachment.left === 'left') {
          if (eAttachment.left === 'right') {
            left += targetWidth;
            tAttachment.left = 'right';

            left += width;
            eAttachment.left = 'left';
          } else if (eAttachment.left === 'left') {
            left += targetWidth;
            tAttachment.left = 'right';

            left -= width;
            eAttachment.left = 'right';
          }
        } else if (left + width > bounds[2] && tAttachment.left === 'right') {
          if (eAttachment.left === 'left') {
            left -= targetWidth;
            tAttachment.left = 'left';

            left -= width;
            eAttachment.left = 'right';
          } else if (eAttachment.left === 'right') {
            left -= targetWidth;
            tAttachment.left = 'left';

            left += width;
            eAttachment.left = 'left';
          }
        } else if (tAttachment.left === 'center') {
          if (left + width > bounds[2] && eAttachment.left === 'left') {
            left -= width;
            eAttachment.left = 'right';
          } else if (left < bounds[0] && eAttachment.left === 'right') {
            left += width;
            eAttachment.left = 'left';
          }
        }
      }

      if (changeAttachY === 'element' || changeAttachY === 'both') {
        if (top < bounds[1] && eAttachment.top === 'bottom') {
          top += height;
          eAttachment.top = 'top';
        }

        if (top + height > bounds[3] && eAttachment.top === 'top') {
          top -= height;
          eAttachment.top = 'bottom';
        }
      }

      if (changeAttachX === 'element' || changeAttachX === 'both') {
        if (left < bounds[0]) {
          if (eAttachment.left === 'right') {
            left += width;
            eAttachment.left = 'left';
          } else if (eAttachment.left === 'center') {
            left += width / 2;
            eAttachment.left = 'left';
          }
        }

        if (left + width > bounds[2]) {
          if (eAttachment.left === 'left') {
            left -= width;
            eAttachment.left = 'right';
          } else if (eAttachment.left === 'center') {
            left -= width / 2;
            eAttachment.left = 'right';
          }
        }
      }

      if (typeof pin === 'string') {
        pin = pin.split(',').map(function (p) {
          return p.trim();
        });
      } else if (pin === true) {
        pin = ['top', 'left', 'right', 'bottom'];
      }

      pin = pin || [];

      var pinned = [];
      var oob = [];

      if (top < bounds[1]) {
        if (pin.indexOf('top') >= 0) {
          top = bounds[1];
          pinned.push('top');
        } else {
          oob.push('top');
        }
      }

      if (top + height > bounds[3]) {
        if (pin.indexOf('bottom') >= 0) {
          top = bounds[3] - height;
          pinned.push('bottom');
        } else {
          oob.push('bottom');
        }
      }

      if (left < bounds[0]) {
        if (pin.indexOf('left') >= 0) {
          left = bounds[0];
          pinned.push('left');
        } else {
          oob.push('left');
        }
      }

      if (left + width > bounds[2]) {
        if (pin.indexOf('right') >= 0) {
          left = bounds[2] - width;
          pinned.push('right');
        } else {
          oob.push('right');
        }
      }

      if (pinned.length) {
        (function () {
          var pinnedClass = undefined;
          if (typeof _this.options.pinnedClass !== 'undefined') {
            pinnedClass = _this.options.pinnedClass;
          } else {
            pinnedClass = _this.getClass('pinned');
          }

          addClasses.push(pinnedClass);
          pinned.forEach(function (side) {
            addClasses.push(pinnedClass + '-' + side);
          });
        })();
      }

      if (oob.length) {
        (function () {
          var oobClass = undefined;
          if (typeof _this.options.outOfBoundsClass !== 'undefined') {
            oobClass = _this.options.outOfBoundsClass;
          } else {
            oobClass = _this.getClass('out-of-bounds');
          }

          addClasses.push(oobClass);
          oob.forEach(function (side) {
            addClasses.push(oobClass + '-' + side);
          });
        })();
      }

      if (pinned.indexOf('left') >= 0 || pinned.indexOf('right') >= 0) {
        eAttachment.left = tAttachment.left = false;
      }
      if (pinned.indexOf('top') >= 0 || pinned.indexOf('bottom') >= 0) {
        eAttachment.top = tAttachment.top = false;
      }

      if (tAttachment.top !== targetAttachment.top || tAttachment.left !== targetAttachment.left || eAttachment.top !== _this.attachment.top || eAttachment.left !== _this.attachment.left) {
        _this.updateAttachClasses(eAttachment, tAttachment);
        _this.trigger('update', {
          attachment: eAttachment,
          targetAttachment: tAttachment
        });
      }
    });

    defer(function () {
      if (!(_this.options.addTargetClasses === false)) {
        updateClasses(_this.target, addClasses, allClasses);
      }
      updateClasses(_this.element, addClasses, allClasses);
    });

    return { top: top, left: left };
  }
});
/* globals TetherBase */

'use strict';

var _TetherBase$Utils = TetherBase.Utils;
var getBounds = _TetherBase$Utils.getBounds;
var updateClasses = _TetherBase$Utils.updateClasses;
var defer = _TetherBase$Utils.defer;

TetherBase.modules.push({
  position: function position(_ref) {
    var _this = this;

    var top = _ref.top;
    var left = _ref.left;

    var _cache = this.cache('element-bounds', function () {
      return getBounds(_this.element);
    });

    var height = _cache.height;
    var width = _cache.width;

    var targetPos = this.getTargetBounds();

    var bottom = top + height;
    var right = left + width;

    var abutted = [];
    if (top <= targetPos.bottom && bottom >= targetPos.top) {
      ['left', 'right'].forEach(function (side) {
        var targetPosSide = targetPos[side];
        if (targetPosSide === left || targetPosSide === right) {
          abutted.push(side);
        }
      });
    }

    if (left <= targetPos.right && right >= targetPos.left) {
      ['top', 'bottom'].forEach(function (side) {
        var targetPosSide = targetPos[side];
        if (targetPosSide === top || targetPosSide === bottom) {
          abutted.push(side);
        }
      });
    }

    var allClasses = [];
    var addClasses = [];

    var sides = ['left', 'top', 'right', 'bottom'];
    allClasses.push(this.getClass('abutted'));
    sides.forEach(function (side) {
      allClasses.push(_this.getClass('abutted') + '-' + side);
    });

    if (abutted.length) {
      addClasses.push(this.getClass('abutted'));
    }

    abutted.forEach(function (side) {
      addClasses.push(_this.getClass('abutted') + '-' + side);
    });

    defer(function () {
      if (!(_this.options.addTargetClasses === false)) {
        updateClasses(_this.target, addClasses, allClasses);
      }
      updateClasses(_this.element, addClasses, allClasses);
    });

    return true;
  }
});
/* globals TetherBase */

'use strict';

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

TetherBase.modules.push({
  position: function position(_ref) {
    var top = _ref.top;
    var left = _ref.left;

    if (!this.options.shift) {
      return;
    }

    var shift = this.options.shift;
    if (typeof this.options.shift === 'function') {
      shift = this.options.shift.call(this, { top: top, left: left });
    }

    var shiftTop = undefined,
        shiftLeft = undefined;
    if (typeof shift === 'string') {
      shift = shift.split(' ');
      shift[1] = shift[1] || shift[0];

      var _shift = shift;

      var _shift2 = _slicedToArray(_shift, 2);

      shiftTop = _shift2[0];
      shiftLeft = _shift2[1];

      shiftTop = parseFloat(shiftTop, 10);
      shiftLeft = parseFloat(shiftLeft, 10);
    } else {
      shiftTop = shift.top;
      shiftLeft = shift.left;
    }

    top += shiftTop;
    left += shiftLeft;

    return { top: top, left: left };
  }
});
return Tether;

}));


/***/ }),
/* 12 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var CaliforniaApp_1 = __webpack_require__(3);
CaliforniaApp_1.CaliforniaApp.CaliforniaAppInstance = new CaliforniaApp_1.CaliforniaApp();
if (!Array.prototype.find) {
    Object.defineProperty(Array.prototype, 'find', {
        value: function value(predicate) {
            if (this == null) {
                throw new TypeError('"this" is null or not defined');
            }
            var o = Object(this);
            var len = o.length >>> 0;
            if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
            }
            var thisArg = arguments[1];
            var k = 0;
            while (k < len) {
                var kValue = o[k];
                if (predicate.call(thisArg, kValue, k, o)) {
                    return kValue;
                }
                k++;
            }
            return undefined;
        }
    });
}
if (!Array.prototype.findIndex) {
    Object.defineProperty(Array.prototype, 'findIndex', {
        value: function value(predicate) {
            if (this == null) {
                throw new TypeError('"this" is null or not defined');
            }
            var o = Object(this);
            var len = o.length >>> 0;
            if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
            }
            var thisArg = arguments[1];
            var k = 0;
            while (k < len) {
                var kValue = o[k];
                if (predicate.call(thisArg, kValue, k, o)) {
                    return k;
                }
                k++;
            }
            return -1;
        }
    });
}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var helpers = __webpack_require__(16);
var currentApp;
var CaliforniaController = function () {
    function CaliforniaController(californiaAppArg) {
        var _this = this;
        this.beforeSendAjax = function (jqXHR, settings) {
            if (currentApp.isAjaxRequestRunning === true) {
                console.log("ignored request (ajax call still in progress)");
                return false;
            }
            currentApp.isAjaxRequestRunning = true;
            jqXHR.done(function (xhr) {
                currentApp.isAjaxRequestRunning = false;
            }).fail(function (xhr) {
                currentApp.isAjaxRequestRunning = false;
                currentApp.projector.scheduleRender();
            });
        };
        this.LogoutAction = function () {
            return helpers.Action("/california/Logout", "post", null, _this.beforeSendAjax);
        };
        this.IndexAction = function (id, token) {
            return helpers.Action("/california/Index" + encodeURIComponent(id) + "?token=" + encodeURIComponent(token), "get", null, _this.beforeSendAjax);
        };
        this.DeleteLayoutStyleInteractionJson = function (layoutStyleInteractionId) {
            return helpers.Json("/california/DeleteLayoutStyleInteraction?layoutStyleInteractionId=" + layoutStyleInteractionId, "post", null, _this.beforeSendAjax);
        };
        this.DeleteStyleValueInteractionJson = function (layoutStyleInteractionId, styleValueId) {
            return helpers.Json("/california/DeleteStyleValueInteraction?layoutStyleInteractionId=" + layoutStyleInteractionId + "&styleValueId=" + styleValueId, "post", null, _this.beforeSendAjax);
        };
        this.CreateLayoutStyleInteractionForLayoutAtomJson = function (layoutAtomId) {
            return helpers.Json("/california/CreateLayoutStyleInteractionForLayoutAtom?layoutAtomId=" + layoutAtomId, "post", null, _this.beforeSendAjax);
        };
        this.StaticCssAction = function () {
            return helpers.Action("/california/StaticCss", "get", null, _this.beforeSendAjax);
        };
        this.StaticJsAction = function () {
            return helpers.Action("/california/StaticJs", "get", null, _this.beforeSendAjax);
        };
        this.pubAction = function (view, id) {
            return helpers.Action("/california/pub" + encodeURIComponent(id) + "?view=" + encodeURIComponent(view), "get", null, _this.beforeSendAjax);
        };
        this.PublishAction = function (californiaProjectId) {
            return helpers.Action("/california/Publish?californiaProjectId=" + californiaProjectId, "post", null, _this.beforeSendAjax);
        };
        this.InitialClientDataJson = function (jsTimeString) {
            return helpers.Json("/california/InitialClientData?jsTimeString=" + encodeURIComponent(jsTimeString), "post", null, _this.beforeSendAjax);
        };
        this.SetSpecialLayoutBoxTypeJson = function (layoutBoxId, specialLayoutBoxType) {
            return helpers.Json("/california/SetSpecialLayoutBoxType?layoutBoxId=" + layoutBoxId + "&specialLayoutBoxType=" + specialLayoutBoxType, "post", null, _this.beforeSendAjax);
        };
        this.DeleteStyleQuantumJson = function (styleQuantumId) {
            return helpers.Json("/california/DeleteStyleQuantum?styleQuantumId=" + styleQuantumId, "post", null, _this.beforeSendAjax);
        };
        this.DeleteLayoutJson = function (layoutBaseId, isOnlyBelow) {
            return helpers.Json("/california/DeleteLayout?layoutBaseId=" + layoutBaseId + "&isOnlyBelow=" + isOnlyBelow, "post", null, _this.beforeSendAjax);
        };
        this.SetStyleMoleculeAsReferenceStyleJson = function (styleMoleculeId) {
            return helpers.Json("/california/SetStyleMoleculeAsReferenceStyle?styleMoleculeId=" + styleMoleculeId, "post", null, _this.beforeSendAjax);
        };
        this.SetStyleMoleculeReferenceJson = function (styleMoleculeId, referenceStyleMoleculeId) {
            return helpers.Json("/california/SetStyleMoleculeReference?styleMoleculeId=" + styleMoleculeId + "&referenceStyleMoleculeId=" + referenceStyleMoleculeId, "post", null, _this.beforeSendAjax);
        };
        this.SyncStyleMoleculeToReferenceStyleJson = function (styleMoleculeId) {
            return helpers.Json("/california/SyncStyleMoleculeToReferenceStyle?styleMoleculeId=" + styleMoleculeId, "post", null, _this.beforeSendAjax);
        };
        this.SyncStyleMoleculeFromReferenceStyleJson = function (styleMoleculeId) {
            return helpers.Json("/california/SyncStyleMoleculeFromReferenceStyle?styleMoleculeId=" + styleMoleculeId, "post", null, _this.beforeSendAjax);
        };
        this.SyncLayoutStylesImitatingReferenceLayoutJson = function (targetLayoutMoleculeId, referenceLayoutMoleculeId) {
            return helpers.Json("/california/SyncLayoutStylesImitatingReferenceLayout?targetLayoutMoleculeId=" + targetLayoutMoleculeId + "&referenceLayoutMoleculeId=" + referenceLayoutMoleculeId, "post", null, _this.beforeSendAjax);
        };
        this.SetLayoutBoxCountForRowOrBoxJson = function (layoutRowId, boxStyleMoleculeId, targetBoxCount, isFitWidth) {
            return helpers.Json("/california/SetLayoutBoxCountForRowOrBox?layoutRowId=" + layoutRowId + "&boxStyleMoleculeId=" + boxStyleMoleculeId + "&targetBoxCount=" + targetBoxCount + "&isFitWidth=" + isFitWidth, "post", null, _this.beforeSendAjax);
        };
        this.CreateStyleValueForAtomJson = function (styleAtomId, cssProperty) {
            return helpers.Json("/california/CreateStyleValueForAtom?styleAtomId=" + styleAtomId + "&cssProperty=" + encodeURIComponent(cssProperty), "post", null, _this.beforeSendAjax);
        };
        this.CreateCaliforniaViewJson = function (californiaProjectId, californiaViewName) {
            return helpers.Json("/california/CreateCaliforniaView?californiaProjectId=" + californiaProjectId + "&californiaViewName=" + encodeURIComponent(californiaViewName), "post", null, _this.beforeSendAjax);
        };
        this.CreateCaliforniaViewFromReferenceViewJson = function (californiaProjectId, californiaViewName, referenceCaliforniaViewId) {
            return helpers.Json("/california/CreateCaliforniaViewFromReferenceView?californiaProjectId=" + californiaProjectId + "&californiaViewName=" + encodeURIComponent(californiaViewName) + "&referenceCaliforniaViewId=" + referenceCaliforniaViewId, "post", null, _this.beforeSendAjax);
        };
        this.DeleteCaliforniaViewJson = function (californiaViewId) {
            return helpers.Json("/california/DeleteCaliforniaView?californiaViewId=" + californiaViewId, "post", null, _this.beforeSendAjax);
        };
        this.CreateStyleValueInteractionJson = function (layoutStyleInteractionId, styleValueId, cssValue) {
            return helpers.Json("/california/CreateStyleValueInteraction?layoutStyleInteractionId=" + layoutStyleInteractionId + "&styleValueId=" + styleValueId + "&cssValue=" + encodeURIComponent(cssValue), "post", null, _this.beforeSendAjax);
        };
        this.CreateStyleAtomForMoleculeJson = function (styleMoleculeId, styleAtomType, responsiveDeviceId, stateModifier) {
            return helpers.Json("/california/CreateStyleAtomForMolecule?styleMoleculeId=" + styleMoleculeId + "&styleAtomType=" + styleAtomType + "&responsiveDeviceId=" + responsiveDeviceId + "&stateModifier=" + encodeURIComponent(stateModifier), "post", null, _this.beforeSendAjax);
        };
        this.DeleteStyleAtomJson = function (styleAtomId) {
            return helpers.Json("/california/DeleteStyleAtom?styleAtomId=" + styleAtomId, "post", null, _this.beforeSendAjax);
        };
        this.ApplyStyleQuantumToAtomJson = function (styleAtomId, styleQuantumId) {
            return helpers.Json("/california/ApplyStyleQuantumToAtom?styleAtomId=" + styleAtomId + "&styleQuantumId=" + styleQuantumId, "post", null, _this.beforeSendAjax);
        };
        this.CreateStyleQuantumJson = function (californiaProjectId, quantumName, cssProperty, cssValue) {
            return helpers.Json("/california/CreateStyleQuantum?californiaProjectId=" + californiaProjectId + "&quantumName=" + encodeURIComponent(quantumName) + "&cssProperty=" + encodeURIComponent(cssProperty) + "&cssValue=" + encodeURIComponent(cssValue), "post", null, _this.beforeSendAjax);
        };
        this.UpdateTextContentAtomJson = function (contentAtomId, updatedTextContent) {
            return helpers.Json("/california/UpdateTextContentAtom?contentAtomId=" + contentAtomId + "&updatedTextContent=" + encodeURIComponent(updatedTextContent), "post", null, _this.beforeSendAjax);
        };
        this.UpdateStyleQuantumJson = function (styleQuantumId, cssValue) {
            return helpers.Json("/california/UpdateStyleQuantum?styleQuantumId=" + styleQuantumId + "&cssValue=" + encodeURIComponent(cssValue), "post", null, _this.beforeSendAjax);
        };
        this.UpdateStyleValueJson = function (styleValueId, cssValue) {
            return helpers.Json("/california/UpdateStyleValue?styleValueId=" + styleValueId + "&cssValue=" + encodeURIComponent(cssValue), "post", null, _this.beforeSendAjax);
        };
        this.DeleteStyleValueJson = function (styleValueId) {
            return helpers.Json("/california/DeleteStyleValue?styleValueId=" + styleValueId, "post", null, _this.beforeSendAjax);
        };
        this.DuplicateStyleQuantumJson = function (styleQuantumId) {
            return helpers.Json("/california/DuplicateStyleQuantum?styleQuantumId=" + styleQuantumId, "post", null, _this.beforeSendAjax);
        };
        this.CreateLayoutAtomForBoxJson = function (targetLayoutBoxId, referenceLayoutAtomId) {
            return helpers.Json("/california/CreateLayoutAtomForBox?targetLayoutBoxId=" + targetLayoutBoxId + "&referenceLayoutAtomId=" + referenceLayoutAtomId, "post", null, _this.beforeSendAjax);
        };
        this.CreateLayoutBoxForBoxOrRowJson = function (targetLayoutBoxOrRowId, referenceLayoutBoxId) {
            return helpers.Json("/california/CreateLayoutBoxForBoxOrRow?targetLayoutBoxOrRowId=" + targetLayoutBoxOrRowId + "&referenceLayoutBoxId=" + referenceLayoutBoxId, "post", null, _this.beforeSendAjax);
        };
        this.CreateLayoutBoxForAtomInPlaceJson = function (targetLayoutAtomId, referenceLayoutBoxId) {
            return helpers.Json("/california/CreateLayoutBoxForAtomInPlace?targetLayoutAtomId=" + targetLayoutAtomId + "&referenceLayoutBoxId=" + referenceLayoutBoxId, "post", null, _this.beforeSendAjax);
        };
        this.CreateLayoutRowForViewJson = function (targetCaliforniaViewId, referenceLayoutRowId) {
            return helpers.Json("/california/CreateLayoutRowForView?targetCaliforniaViewId=" + targetCaliforniaViewId + "&referenceLayoutRowId=" + referenceLayoutRowId, "post", null, _this.beforeSendAjax);
        };
        this.SetLayoutRowOrBoxAsInstanceableJson = function (californiaProjectId, layoutRowOrBoxId) {
            return helpers.Json("/california/SetLayoutRowOrBoxAsInstanceable?californiaProjectId=" + californiaProjectId + "&layoutRowOrBoxId=" + layoutRowOrBoxId, "post", null, _this.beforeSendAjax);
        };
        this.MoveStyleAtomToResponsiveDeviceJson = function (styleAtomId, targetResponsiveDeviceId) {
            return helpers.Json("/california/MoveStyleAtomToResponsiveDevice?styleAtomId=" + styleAtomId + "&targetResponsiveDeviceId=" + targetResponsiveDeviceId, "post", null, _this.beforeSendAjax);
        };
        this.MoveLayoutMoleculeIntoLayoutMoleculeJson = function (movedLayoutMoleculeId, targetContainerLayoutMoleculeId) {
            return helpers.Json("/california/MoveLayoutMoleculeIntoLayoutMolecule?movedLayoutMoleculeId=" + movedLayoutMoleculeId + "&targetContainerLayoutMoleculeId=" + targetContainerLayoutMoleculeId, "post", null, _this.beforeSendAjax);
        };
        this.MoveLayoutMoleculeNextToLayoutMoleculeJson = function (movedLayoutMoleculeId, targetNeighborLayoutMoleculeId, isMoveBefore) {
            return helpers.Json("/california/MoveLayoutMoleculeNextToLayoutMolecule?movedLayoutMoleculeId=" + movedLayoutMoleculeId + "&targetNeighborLayoutMoleculeId=" + targetNeighborLayoutMoleculeId + "&isMoveBefore=" + isMoveBefore, "post", null, _this.beforeSendAjax);
        };
        currentApp = californiaAppArg;
    }
    return CaliforniaController;
}();
exports.CaliforniaController = CaliforniaController;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(jQuery) {

Object.defineProperty(exports, "__esModule", { value: true });
function Json(url, method, data, beforeSendCallback) {
    var request;
    if (data !== null) {
        request = jQuery.ajax(url, { method: method, data: JSON.stringify(data), contentType: "application/json; charset=utf-8", beforeSend: beforeSendCallback });
    } else {
        request = jQuery.ajax(url, { method: method, beforeSend: beforeSendCallback });
    }
    request.fail(function (data) {
        if (data.responseJSON !== undefined && data.responseJSON.StatusText !== undefined) {
            console.log(data.responseJSON.StatusText);
        }
    });
    return request;
}
exports.Json = Json;
;
function Action(url, method, data, beforeSendCallback) {
    var request;
    if (data !== null) {
        request = jQuery.ajax(url, { method: method, data: JSON.stringify(data), contentType: "application/json; charset=utf-8", beforeSend: beforeSendCallback });
    } else {
        request = jQuery.ajax(url, { method: method, beforeSend: beforeSendCallback });
    }
    request.fail(function (data) {
        if (data.statusText !== undefined) {
            console.log(data.statusText);
        }
    });
    return request;
}
exports.Action = Action;
;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var CaliforniaEvent;
(function (CaliforniaEvent) {
    CaliforniaEvent[CaliforniaEvent["ReadInitialClientData"] = 0] = "ReadInitialClientData";
    CaliforniaEvent[CaliforniaEvent["CreateStore"] = 1] = "CreateStore";
    CaliforniaEvent[CaliforniaEvent["ReadStore"] = 2] = "ReadStore";
    CaliforniaEvent[CaliforniaEvent["CreateStyleQuantum"] = 3] = "CreateStyleQuantum";
    CaliforniaEvent[CaliforniaEvent["DuplicateStyleQuantum"] = 4] = "DuplicateStyleQuantum";
    CaliforniaEvent[CaliforniaEvent["DeleteStyleQuantum"] = 5] = "DeleteStyleQuantum";
    CaliforniaEvent[CaliforniaEvent["DeleteStyleValue"] = 6] = "DeleteStyleValue";
    CaliforniaEvent[CaliforniaEvent["CreateStyleValueForAtom"] = 7] = "CreateStyleValueForAtom";
    CaliforniaEvent[CaliforniaEvent["UpdateStyleValue"] = 8] = "UpdateStyleValue";
    CaliforniaEvent[CaliforniaEvent["UpdateStyleQuantum"] = 9] = "UpdateStyleQuantum";
    CaliforniaEvent[CaliforniaEvent["ApplyStyleQuantumToAtom"] = 10] = "ApplyStyleQuantumToAtom";
    CaliforniaEvent[CaliforniaEvent["CreateStyleAtomForMolecule"] = 11] = "CreateStyleAtomForMolecule";
    CaliforniaEvent[CaliforniaEvent["DeleteStyleAtom"] = 12] = "DeleteStyleAtom";
    CaliforniaEvent[CaliforniaEvent["UpdateContentAtom"] = 13] = "UpdateContentAtom";
    CaliforniaEvent[CaliforniaEvent["CreateLayoutAtomForBox"] = 14] = "CreateLayoutAtomForBox";
    CaliforniaEvent[CaliforniaEvent["CreateLayoutRowForView"] = 15] = "CreateLayoutRowForView";
    CaliforniaEvent[CaliforniaEvent["DeleteLayout"] = 16] = "DeleteLayout";
    CaliforniaEvent[CaliforniaEvent["SetBoxCount"] = 17] = "SetBoxCount";
    CaliforniaEvent[CaliforniaEvent["CreateLayoutBoxForBoxOrRow"] = 18] = "CreateLayoutBoxForBoxOrRow";
    CaliforniaEvent[CaliforniaEvent["MoveStyleAtomToResponsiveDevice"] = 19] = "MoveStyleAtomToResponsiveDevice";
    CaliforniaEvent[CaliforniaEvent["SetStyleMoleculeReference"] = 20] = "SetStyleMoleculeReference";
    CaliforniaEvent[CaliforniaEvent["SetStyleMoleculeAsReference"] = 21] = "SetStyleMoleculeAsReference";
    CaliforniaEvent[CaliforniaEvent["SetLayoutMoleculeAsInstanceable"] = 22] = "SetLayoutMoleculeAsInstanceable";
    CaliforniaEvent[CaliforniaEvent["SyncStyleMoleculeToReference"] = 23] = "SyncStyleMoleculeToReference";
    CaliforniaEvent[CaliforniaEvent["SyncStyleMoleculeFromReference"] = 24] = "SyncStyleMoleculeFromReference";
    CaliforniaEvent[CaliforniaEvent["MoveLayoutMoleculeIntoLayoutMolecule"] = 25] = "MoveLayoutMoleculeIntoLayoutMolecule";
    CaliforniaEvent[CaliforniaEvent["MoveLayoutMoleculeNextToLayoutMolecule"] = 26] = "MoveLayoutMoleculeNextToLayoutMolecule";
    CaliforniaEvent[CaliforniaEvent["Publish"] = 27] = "Publish";
    CaliforniaEvent[CaliforniaEvent["View"] = 28] = "View";
    CaliforniaEvent[CaliforniaEvent["CreateCaliforniaView"] = 29] = "CreateCaliforniaView";
    CaliforniaEvent[CaliforniaEvent["DeleteCaliforniaView"] = 30] = "DeleteCaliforniaView";
    CaliforniaEvent[CaliforniaEvent["CreateLayoutStyleInteraction"] = 31] = "CreateLayoutStyleInteraction";
    CaliforniaEvent[CaliforniaEvent["CreateStyleValueInteraction"] = 32] = "CreateStyleValueInteraction";
    CaliforniaEvent[CaliforniaEvent["DeleteLayoutStyleInteraction"] = 33] = "DeleteLayoutStyleInteraction";
    CaliforniaEvent[CaliforniaEvent["CreateLayoutBoxForAtomInPlace"] = 34] = "CreateLayoutBoxForAtomInPlace";
    CaliforniaEvent[CaliforniaEvent["SyncLayoutStylesImitatingReference"] = 35] = "SyncLayoutStylesImitatingReference";
    CaliforniaEvent[CaliforniaEvent["CreateCaliforniaViewFromReferenceView"] = 36] = "CreateCaliforniaViewFromReferenceView";
    CaliforniaEvent[CaliforniaEvent["DeleteStyleValueInteraction"] = 37] = "DeleteStyleValueInteraction";
    CaliforniaEvent[CaliforniaEvent["SetSpecialLayoutBoxType"] = 38] = "SetSpecialLayoutBoxType";
    CaliforniaEvent[CaliforniaEvent["ViewJs"] = 39] = "ViewJs";
    CaliforniaEvent[CaliforniaEvent["ViewCss"] = 40] = "ViewCss";
})(CaliforniaEvent = exports.CaliforniaEvent || (exports.CaliforniaEvent = {}));

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var CaliforniaProject = function () {
    function CaliforniaProject() {}
    return CaliforniaProject;
}();
exports.CaliforniaProject = CaliforniaProject;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var CaliforniaUserDefaults = function () {
    function CaliforniaUserDefaults() {}
    return CaliforniaUserDefaults;
}();
exports.CaliforniaUserDefaults = CaliforniaUserDefaults;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var CaliforniaClientViewModel = function () {
    function CaliforniaClientViewModel() {}
    return CaliforniaClientViewModel;
}();
exports.CaliforniaClientViewModel = CaliforniaClientViewModel;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var StyleMolecule = function () {
    function StyleMolecule() {}
    return StyleMolecule;
}();
exports.StyleMolecule = StyleMolecule;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var StyleQuantum = function () {
    function StyleQuantum() {}
    return StyleQuantum;
}();
exports.StyleQuantum = StyleQuantum;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var StyleAtom = function () {
    function StyleAtom() {}
    return StyleAtom;
}();
exports.StyleAtom = StyleAtom;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var StyleAtomType;
(function (StyleAtomType) {
    StyleAtomType[StyleAtomType["Generic"] = 0] = "Generic";
    StyleAtomType[StyleAtomType["Font"] = 1] = "Font";
    StyleAtomType[StyleAtomType["Typography"] = 2] = "Typography";
    StyleAtomType[StyleAtomType["Divider"] = 3] = "Divider";
    StyleAtomType[StyleAtomType["Background"] = 4] = "Background";
    StyleAtomType[StyleAtomType["Spacing"] = 5] = "Spacing";
    StyleAtomType[StyleAtomType["Picture"] = 6] = "Picture";
    StyleAtomType[StyleAtomType["Grid"] = 7] = "Grid";
    StyleAtomType[StyleAtomType["Row"] = 8] = "Row";
    StyleAtomType[StyleAtomType["Navbar"] = 9] = "Navbar";
    StyleAtomType[StyleAtomType["List"] = 10] = "List";
    StyleAtomType[StyleAtomType["Box"] = 11] = "Box";
})(StyleAtomType = exports.StyleAtomType || (exports.StyleAtomType = {}));

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var StyleValue = function () {
    function StyleValue() {}
    return StyleValue;
}();
exports.StyleValue = StyleValue;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var ResponsiveDevice = function () {
    function ResponsiveDevice() {}
    return ResponsiveDevice;
}();
exports.ResponsiveDevice = ResponsiveDevice;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var CaliforniaView = function () {
    function CaliforniaView() {}
    return CaliforniaView;
}();
exports.CaliforniaView = CaliforniaView;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var LayoutRow = function () {
    function LayoutRow() {}
    return LayoutRow;
}();
exports.LayoutRow = LayoutRow;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var LayoutBox = function () {
    function LayoutBox() {}
    return LayoutBox;
}();
exports.LayoutBox = LayoutBox;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var LayoutAtom = function () {
    function LayoutAtom() {}
    return LayoutAtom;
}();
exports.LayoutAtom = LayoutAtom;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var StyleMoleculeAtomMapping = function () {
    function StyleMoleculeAtomMapping() {}
    return StyleMoleculeAtomMapping;
}();
exports.StyleMoleculeAtomMapping = StyleMoleculeAtomMapping;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var ContentAtom = function () {
    function ContentAtom() {}
    return ContentAtom;
}();
exports.ContentAtom = ContentAtom;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var LayoutBase = function () {
    function LayoutBase() {}
    return LayoutBase;
}();
exports.LayoutBase = LayoutBase;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var LayoutType;
(function (LayoutType) {
    LayoutType[LayoutType["Row"] = 0] = "Row";
    LayoutType[LayoutType["Box"] = 1] = "Box";
    LayoutType[LayoutType["Atom"] = 2] = "Atom";
})(LayoutType = exports.LayoutType || (exports.LayoutType = {}));

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var SpecialLayoutBoxType;
(function (SpecialLayoutBoxType) {
    SpecialLayoutBoxType[SpecialLayoutBoxType["Default"] = 0] = "Default";
    SpecialLayoutBoxType[SpecialLayoutBoxType["CaliforniaViewHolder"] = 1] = "CaliforniaViewHolder";
    SpecialLayoutBoxType[SpecialLayoutBoxType["Navigation"] = 2] = "Navigation";
    SpecialLayoutBoxType[SpecialLayoutBoxType["UnsortedList"] = 3] = "UnsortedList";
    SpecialLayoutBoxType[SpecialLayoutBoxType["SortedList"] = 4] = "SortedList";
    SpecialLayoutBoxType[SpecialLayoutBoxType["ListItem"] = 5] = "ListItem";
    SpecialLayoutBoxType[SpecialLayoutBoxType["RichText"] = 6] = "RichText";
})(SpecialLayoutBoxType = exports.SpecialLayoutBoxType || (exports.SpecialLayoutBoxType = {}));

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var LayoutStyleInteraction = function () {
    function LayoutStyleInteraction() {}
    return LayoutStyleInteraction;
}();
exports.LayoutStyleInteraction = LayoutStyleInteraction;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", { value: true });
var maquette = __webpack_require__(1);
var h = maquette.h;
var CaliforniaApp_1 = __webpack_require__(3);
var PagePreviewVM_1 = __webpack_require__(38);
var CaliforniaGenerated_1 = __webpack_require__(2);
var ClientState_1 = __webpack_require__(4);
var ContentAtomType_1 = __webpack_require__(7);
var currentApp;
var currentPagePreview;
exports.HIGHLIGHT_BACKGROUND_COLOR_STRING = "rgb(233,233,233)";
exports.MANUALLY_HIGHLIGHT_BACKGROUND_COLOR_STRING = "rgb(222,222,222)";
var PagePreview = function () {
    function PagePreview(californiaAppArg) {
        this.dynamicClientGridBreakpoints = [];
        this.virtualStyleIndex = [];
        this.virtualPseudoStyleIndex = [];
        this._visibleLayoutAtomDomNodeReferences = [];
        this._activeViewLayoutAtomDomNodeReferences = {};
        this._visibleLayoutAtomKeys = [];
        this._mostUpperVisibleLayoutAtomId = 0;
        this.renderPreviewArea = function () {
            var previewAreaStyles = {
                "flex": currentApp.state.editViewMode === ClientState_1.EditViewMode.SidebarOnly ? "0 0 1px" : "1 1 777px",
                "display": "flex",
                "flex-flow": "column nowrap",
                "width": "533px",
                "max-width": "100%",
                "height": "100%",
                "overflow": "visible"
            };
            var isRRButtonEnabled = currentApp.state.lastCaliforniaEventData.length > 0;
            return h(
                "div",
                { key: "0", styles: previewAreaStyles },
                currentApp.state.isHideUserInterface ? undefined : currentPagePreview.renderNavigation(),
                currentApp.state.editViewMode === ClientState_1.EditViewMode.SidebarOnly ? undefined : currentPagePreview.renderPagePreviewHolder(),
                currentApp.state.isHideUserInterface ? h(
                    "div",
                    { key: "2", styles: { "position": "absolute", "left": "0", "top": "0", "z-index": CaliforniaApp_1.UI_Z_INDEX.toString(), "display": "flex", "flex-flow": "column nowrap" } },
                    h(
                        "button",
                        { key: "a", onclick: currentPagePreview.previewClickHandler },
                        "\u2026"
                    ),
                    h(
                        "button",
                        { key: "b", onclick: currentApp.propertyBars[0].insertLayoutRowIntoViewClickHandler },
                        "+(R)"
                    ),
                    isRRButtonEnabled ? h(
                        "button",
                        { key: "c", onclick: currentPagePreview.repeatClickHandler, styles: { "flex": "0 0 auto", "width": "auto" } },
                        "RR"
                    ) : h(
                        "button",
                        { disabled: true, key: "c0", onclick: currentPagePreview.repeatClickHandler, styles: { "flex": "0 0 auto", "width": "auto" } },
                        "RR"
                    )
                ) : undefined
            );
        };
        this.renderNavigation = function () {
            var navigationStyles = {
                "flex": "0 0 " + currentApp.navigationHeigthPx + "px",
                "position": "relative",
                "display": "flex",
                "flex-flow": "row nowrap",
                "z-index": "3"
            };
            var loadingIndicatorStyles = {
                "position": "absolute",
                "right": "0px",
                "background-color": "red",
                "color": "white",
                "border": "solid black 1px"
            };
            var navigationButtonStyles = {
                "flex": "0 0 auto"
            };
            var isRRButtonEnabled = currentApp.state.lastCaliforniaEventData.length > 0;
            return h(
                "div",
                { key: "0", styles: navigationStyles },
                currentApp.isAjaxRequestRunning ? h(
                    "p",
                    { key: "z", styles: loadingIndicatorStyles },
                    "Loading..."
                ) : undefined,
                h(
                    "button",
                    { key: "a", onclick: currentPagePreview.previewClickHandler, styles: { "flex": "0 0 auto", "width": "auto" } },
                    "Preview"
                ),
                h(
                    "button",
                    { key: "b", eid: ClientState_1.EditViewMode.PagePreviewOnly.toString(), onclick: currentPagePreview.changeEditModeClickHandler, styles: { "flex": "0 0 auto", "background-color": currentApp.state.editViewMode === ClientState_1.EditViewMode.PagePreviewOnly ? "red" : undefined } },
                    "P"
                ),
                h(
                    "button",
                    { key: "c", eid: ClientState_1.EditViewMode.SidebarOnly.toString(), onclick: currentPagePreview.changeEditModeClickHandler, styles: { "flex": "0 0 auto", "background-color": currentApp.state.editViewMode === ClientState_1.EditViewMode.SidebarOnly ? "red" : undefined } },
                    "S"
                ),
                h(
                    "button",
                    { key: "d", onclick: currentPagePreview.toggleSideBarCount, cid: "1", styles: { "flex": "0 0 auto" } },
                    "x1"
                ),
                h(
                    "button",
                    { key: "e", onclick: currentPagePreview.toggleSideBarCount, cid: "2", styles: { "flex": "0 0 auto" } },
                    "x2"
                ),
                h(
                    "button",
                    { key: "f", onclick: currentPagePreview.toggleSideBarCount, cid: "4", styles: { "flex": "0 0 auto" } },
                    "x4"
                ),
                currentPagePreview.renderResponsiveDeviceSelectors(),
                h(
                    "button",
                    { key: "h", onclick: currentPagePreview.changeSelectionModeClickHandler, styles: { "flex": "0 0 auto", "background-color": currentApp.state.currentSelectionMode === ClientState_1.SelectionMode.Content ? "red" : undefined, "color": currentApp.state.currentSelectionMode === ClientState_1.SelectionMode.Styles ? "red" : undefined } },
                    ClientState_1.SelectionMode[currentApp.state.currentSelectionMode]
                ),
                h(
                    "button",
                    { key: "i", onclick: currentPagePreview.publishClickHandler, styles: { "flex": "0 0 auto", "width": "auto" } },
                    "Save"
                ),
                h(
                    "button",
                    { key: "j", onclick: currentPagePreview.publishAndOpenClickHandler, styles: { "flex": "0 0 auto", "width": "auto" } },
                    "Save&Open"
                ),
                h(
                    "button",
                    { key: "k", onclick: currentPagePreview.refreshClickHandler, styles: { "flex": "0 0 auto", "width": "auto" } },
                    "JAX"
                ),
                isRRButtonEnabled ? h(
                    "button",
                    { key: "l", onclick: currentPagePreview.repeatClickHandler, styles: { "flex": "0 0 auto", "width": "auto" } },
                    "RR"
                ) : h(
                    "button",
                    { disabled: true, key: "l0", onclick: currentPagePreview.repeatClickHandler, styles: { "flex": "0 0 auto", "width": "auto" } },
                    "RR"
                )
            );
        };
        this.toggleSideBarCount = function (evt) {
            var sidebarCount = CaliforniaApp_1.parseIntFromAttribute(evt.target, "cid");
            if (sidebarCount > 0 && sidebarCount <= 4) {
                currentApp.state.visiblePropertyBarMaxCount = sidebarCount;
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
        };
        this.publishClickHandler = function (evt) {
            currentPagePreview.publish(false);
        };
        this.publishAndOpenClickHandler = function (evt) {
            currentPagePreview.publish(true);
        };
        this.publish = function (isOpen) {
            var currentCaliforniaView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (v) {
                return v.CaliforniaViewId == currentPagePreview.viewModel.activeCaliforniaViewId;
            });
            if (isOpen) {
                currentApp.controller.PublishAction(currentApp.clientData.CaliforniaProject.CaliforniaProjectId).done(function (response) {
                    window.location.assign(window.location.origin + ("/california/pub/" + currentCaliforniaView.Name));
                }).fail(function (req) {
                    console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                });
            } else {
                currentApp.controller.PublishAction(currentApp.clientData.CaliforniaProject.CaliforniaProjectId);
            }
        };
        this.refreshClickHandler = function (evt) {
            if (!currentApp.state.isJaxOn) {
                var head = document.getElementsByTagName("head")[0],
                    script;
                script = document.createElement("script");
                script.type = "text/x-mathjax-config";
                script.text = "MathJax.Hub.Config({\n" + "  root: \"../third_party/mathjax\",\n" + "  extensions: [\"tex2jax.js\"],\n" + "  jax: [\"input/TeX\", \"output/HTML-CSS\"],\n" + "  tex2jax: { inlineMath: [['$','$'], ['\\\\(','\\\\)']], skipTags: [\"script\",\"noscript\",\"style\",\"textarea\",\"pre\",\"code\",\"input\"], processEscapes: true},\n" + "  TeX: { extensions: [\"AMSmath.js\", \"AMSsymbols.js\"], equationNumbers: { autoNumber: \"AMS\" } }, showProcessingMessages: true, messageStyle:\"normal\",\n" + "  \"HTML-CSS\": { availableFonts: [\"TeX\"], preferredFont: \"TeX\", imageFont: null }\n" + "});";
                head.appendChild(script);
                script = document.createElement("script");
                script.type = "text/javascript";
                script.src = "../third_party/mathjax/MathJax.js";
                script.onload = function () {
                    currentApp.state.isJaxOn = true;
                };
                head.appendChild(script);
            } else {
                MathJax.Hub.Queue(["resetEquationNumbers", MathJax.InputJax.TeX]);
                currentPagePreview.resetEquationNumbersWhenModifying(true);
            }
        };
        this.repeatClickHandler = function (evt) {
            if (currentApp.state.lastCommand === CaliforniaGenerated_1.CaliforniaEvent.CreateLayoutBoxForBoxOrRow) {
                currentApp.controller.CreateLayoutBoxForBoxOrRowJson(currentApp.state.lastCaliforniaEventData[0], currentApp.state.lastCaliforniaEventData[1]).done(function (data) {
                    return currentApp.router.updateData(data);
                });
            } else if (currentApp.state.lastCommand === CaliforniaGenerated_1.CaliforniaEvent.CreateLayoutRowForView) {
                currentApp.controller.CreateLayoutRowForViewJson(currentApp.state.lastCaliforniaEventData[0], currentApp.state.lastCaliforniaEventData[1]).done(function (data) {
                    return currentApp.router.updateData(data);
                });
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                return;
            }
        };
        this.resetEquationNumbersWhenModifying = function (isReprocess) {
            if (currentApp.state.isJaxOn) {
                if (isReprocess) {
                    MathJax.Hub.Queue(["PreProcess", MathJax.Hub]);
                    MathJax.Hub.Queue(["Reprocess", MathJax.Hub]);
                }
            }
        };
        this.previewClickHandler = function (evt) {
            currentApp.state.isHideUserInterface = !currentApp.state.isHideUserInterface;
            currentApp.projector.renderNow();
            currentApp.resizeChangedHandler();
        };
        this.changeEditModeClickHandler = function (evt) {
            var selectedEditViewMode = CaliforniaApp_1.parseIntFromAttribute(evt.target, "eid");
            if (currentApp.state.editViewMode === selectedEditViewMode) {
                if (currentApp.state.editViewMode === ClientState_1.EditViewMode.Default) {
                    return;
                } else {
                    currentApp.state.editViewMode = ClientState_1.EditViewMode.Default;
                    currentApp.projector.renderNow();
                }
            } else {
                currentApp.state.editViewMode = selectedEditViewMode;
            }
            currentApp.resizeChangedHandler();
        };
        this.changeSelectionModeClickHandler = function (evt) {
            currentApp.state.currentSelectionMode = currentApp.state.currentSelectionMode === ClientState_1.SelectionMode.Content ? ClientState_1.SelectionMode.Styles : ClientState_1.SelectionMode.Content;
            currentPagePreview.resetContentAtomEditMode();
        };
        this.renderResponsiveDeviceSelectors = function () {
            var responsiveGroupStyles = {
                "flex": "0 0 auto",
                "display": "flex",
                "flex-flow": "row nowrap"
            };
            return h(
                "div",
                { key: "1", styles: responsiveGroupStyles },
                currentApp.clientData.CaliforniaProject.ResponsiveDevices !== undefined ? currentApp.clientData.CaliforniaProject.ResponsiveDevices.map(function (r) {
                    if (r.WidthThreshold < 0) {
                        return undefined;
                    }
                    var responsiveButtonStyles = {
                        "flex": "0 0 auto",
                        "background-color": r.ResponsiveDeviceId == currentApp.state.overrideResponsiveDeviceId ? "red" : undefined,
                        "color": r.ResponsiveDeviceId == currentApp.state.currentResponsiveDeviceId && currentApp.state.overrideResponsiveDeviceId == 0 ? "red" : undefined
                    };
                    var responsiveDeviceIdString = r.ResponsiveDeviceId.toString();
                    return h(
                        "button",
                        { key: responsiveDeviceIdString, rid: responsiveDeviceIdString, onclick: currentPagePreview.selectResponsiveDeviceClickHandler, styles: responsiveButtonStyles },
                        r.NameShort
                    );
                }) : undefined
            );
        };
        this.selectResponsiveDeviceClickHandler = function (evt) {
            var selectedId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "rid");
            if (currentApp.state.overrideResponsiveDeviceId == selectedId) {
                currentApp.state.overrideResponsiveDeviceId = 0;
            } else {
                currentApp.state.overrideResponsiveDeviceId = selectedId;
            }
            currentPagePreview.updatePagePreviewDimensions();
        };
        this.renderPagePreviewHolder = function () {
            var pagePreviewHolderStyles = {
                "flex": currentApp.state.isHideUserInterface ? "1 1 auto" : "1 1 100%",
                "margin": currentApp.state.isHideUserInterface || currentApp.state.editViewMode === ClientState_1.EditViewMode.PagePreviewOnly ? "0" : "0 " + currentApp.state.targetPagePreviewHolderMarginPx + "px",
                "position": "relative",
                "height": "100%",
                "max-height": "100%",
                "overflow": "auto"
            };
            var scrolledPagePreview = {
                "display": "flex",
                "flex-flow": "column nowrap",
                "height": "100%"
            };
            return h(
                "div",
                { key: "1", styles: pagePreviewHolderStyles, onscroll: currentPagePreview.pagePreviewHolderScrollHandler, afterCreate: currentPagePreview.pagePreviewHolderAfterCreateHandler, afterUpdate: currentPagePreview.pagePreviewHolderAfterUpdateHandler },
                h(
                    "div",
                    { key: "p0", styles: scrolledPagePreview },
                    currentPagePreview.renderPagePreview()
                ),
                currentPagePreview.viewModel.fixedLayoutRowsProjector.results.map(function (r) {
                    return r.renderMaquette();
                })
            );
        };
        this.pagePreviewHolderAfterCreateHandler = function (element, projectionOptions, vnodeSelector, properties, children) {
            currentApp.pagePreviewHolder = element;
            currentApp.resizeChangedHandler();
        };
        this.pagePreviewHolderAfterUpdateHandler = function (element, projectionOptions, vnodeSelector, properties, children) {
            currentApp.pagePreviewHolder = element;
            currentPagePreview.updateVisibleLayoutAtoms();
        };
        this.pagePreviewHolderScrollHandler = function (evt) {
            if (currentApp.state.visiblePropertyBarMaxCount > 0) {
                currentPagePreview.updateVisibleLayoutAtoms();
            }
        };
        this.syncScrollPositionFromBoxTree = function () {
            if (currentApp.propertyBarVMs[0].isSyncedWithPagePreview) {
                if (currentApp.pagePreviewHolder !== undefined) {
                    var staticOffsetPx = currentApp.navigationHeigthPx;
                    var targetLayoutAtomId_1 = currentApp.propertyBars[0].mostUpperVisibleLayoutAtomId;
                    var domNodeOfTargetLayout = currentPagePreview._visibleLayoutAtomDomNodeReferences.find(function (r) {
                        return CaliforniaApp_1.parseIntFromAttribute(r, "aid") == targetLayoutAtomId_1;
                    });
                    if (domNodeOfTargetLayout === undefined) {
                        domNodeOfTargetLayout = currentPagePreview._activeViewLayoutAtomDomNodeReferences[targetLayoutAtomId_1];
                        currentApp.pagePreviewHolder.scrollTop = currentApp.pagePreviewHolder.scrollTop + (domNodeOfTargetLayout.getBoundingClientRect().top - staticOffsetPx);
                    }
                }
            }
        };
        this.updateVisibleLayoutAtoms = function () {
            var pagePreviewHolder = currentApp.pagePreviewHolder;
            currentPagePreview._visibleLayoutAtomDomNodeReferences = [];
            currentPagePreview._visibleLayoutAtomKeys = [];
            var processedElementCount = 0;
            var mostUpperVisibleIndex = -1;
            var mostUpperVisibleLayoutAtomId = 0;
            var mostUpperVisibleDeltaTopLeft = pagePreviewHolder.clientHeight + 1;
            var staticOffsetPx = currentApp.navigationHeigthPx;
            var currentScrollTop = pagePreviewHolder.scrollTop;
            var minXPreview = 0;
            var maxXPreview = pagePreviewHolder.clientHeight;
            for (var elementKey in currentPagePreview._activeViewLayoutAtomDomNodeReferences) {
                var domNode = currentPagePreview._activeViewLayoutAtomDomNodeReferences[elementKey];
                var isDomNodeVisible = false;
                var boundingRectElement = domNode.getBoundingClientRect();
                var minXElementDeltaTopLeft = boundingRectElement.top - staticOffsetPx;
                var maxXElementDeltaBottomLeft = pagePreviewHolder.clientHeight - (boundingRectElement.top - staticOffsetPx + currentScrollTop + boundingRectElement.height) + currentScrollTop;
                if (boundingRectElement.height > 0) {
                    if (minXElementDeltaTopLeft >= 0.0 && minXElementDeltaTopLeft <= pagePreviewHolder.clientHeight) {
                        isDomNodeVisible = true;
                    } else if (maxXElementDeltaBottomLeft >= 0.0 && maxXElementDeltaBottomLeft <= pagePreviewHolder.clientHeight) {
                        isDomNodeVisible = true;
                    } else if (minXElementDeltaTopLeft <= 0.0 && maxXElementDeltaBottomLeft <= 0.0) {
                        isDomNodeVisible = true;
                    }
                }
                if (isDomNodeVisible) {
                    currentPagePreview._visibleLayoutAtomDomNodeReferences.push(domNode);
                    currentPagePreview._visibleLayoutAtomKeys.push(elementKey);
                    if (minXElementDeltaTopLeft < mostUpperVisibleDeltaTopLeft) {
                        mostUpperVisibleDeltaTopLeft = minXElementDeltaTopLeft;
                        mostUpperVisibleIndex = currentPagePreview._visibleLayoutAtomKeys.length;
                        mostUpperVisibleLayoutAtomId = CaliforniaApp_1.parseIntFromAttribute(domNode, "aid");
                    }
                }
                if (mostUpperVisibleLayoutAtomId != currentPagePreview._mostUpperVisibleLayoutAtomId) {
                    currentPagePreview._mostUpperVisibleLayoutAtomId = mostUpperVisibleLayoutAtomId;
                    if (mostUpperVisibleLayoutAtomId != 0 && currentApp.propertyBarVMs[0].isSyncedWithPagePreview) {
                        currentApp.propertyBars[0].syncScrollPositionFromPagePreview();
                    }
                }
                processedElementCount++;
            }
        };
        this.renderPagePreview = function () {
            var pagePreviewStyles = {
                "width": currentApp.state.isDataLoaded && !currentApp.state.isEnoughAvailableSpacePagePreview ? currentApp.state.targetPagePreviewWidthPx + "px" : undefined,
                "display": "flex"
            };
            var isRenderView = currentApp.clientData.CaliforniaProject.CaliforniaViews !== undefined;
            var californiaViewBodyStyleString = undefined;
            if (currentApp.clientData.CaliforniaProject.CaliforniaViews !== undefined) {
                californiaViewBodyStyleString = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (v) {
                    return v.CaliforniaViewId == currentPagePreview.viewModel.activeCaliforniaViewId;
                }).SpecialStyleBodyStyleString;
            }
            return isRenderView ? h(
                "div",
                { key: "vp" + currentPagePreview.viewModel.activeCaliforniaViewId, "class": californiaViewBodyStyleString, styles: pagePreviewStyles },
                currentPagePreview.viewModel.californiaViewProjector.results.map(function (r) {
                    return r.renderMaquette();
                })
            ) : h("div", { key: "vp0", styles: pagePreviewStyles });
        };
        this.renderCaliforniaViewArray = function () {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.CaliforniaViewId;
            }, function createSectionTarget(source) {
                var sourceCaliforniaViewIdString = source.CaliforniaViewId.toString();
                var layoutRows = currentPagePreview.renderLayoutRowArray(false);
                layoutRows.map(source.PlacedLayoutRows);
                return {
                    renderMaquette: function renderMaquette() {
                        var californiaViewStyles = {
                            "flex": "1 1 1px"
                        };
                        return h(
                            "div",
                            { "class": source.SpecialStyleViewStyleString, key: sourceCaliforniaViewIdString, id: "california-v" + source.CaliforniaViewId + "_" + source.Name, vid: sourceCaliforniaViewIdString, styles: californiaViewStyles },
                            layoutRows.results.map(function (r) {
                                return r.renderMaquette();
                            })
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        layoutRows.map(source.PlacedLayoutRows);
                        sourceCaliforniaViewIdString = source.CaliforniaViewId.toString();
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.renderLayoutRowArray = function (isRenderFixedLayout) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.LayoutBaseId;
            }, function createSectionTarget(source) {
                var sourceLayoutRowIdString = source.LayoutBaseId.toString();
                var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                    return m.StyleForLayoutId == source.LayoutBaseId;
                });
                var layoutBoxMapping = currentPagePreview.renderLayoutBoxArray(isRenderFixedLayout, styleMolecule.IsPositionFixed);
                var unsortedBoxes = source.AllBoxesBelowRow.filter(function (b) {
                    return b.PlacedBoxInBoxId === undefined;
                });
                var sortedBoxes = unsortedBoxes.sort(function (boxA, boxB) {
                    if (boxA.LayoutSortOrderKey < boxB.LayoutSortOrderKey) {
                        return -1;
                    } else if (boxA.LayoutSortOrderKey == boxB.LayoutSortOrderKey) {
                        return 0;
                    } else {
                        return 1;
                    }
                });
                layoutBoxMapping.map(sortedBoxes);
                var pagePreviewOverrideStyles;
                var marginTopOverrideValue;
                var topOverrideValue;
                var marginLeftOverrideValue;
                if (styleMolecule.IsPositionFixed) {
                    marginTopOverrideValue = styleMolecule.TopCssValuePx + "px";
                    topOverrideValue = styleMolecule.TopCssValuePx !== undefined ? currentApp.navigationHeigthPx + "px" : undefined;
                    marginLeftOverrideValue = styleMolecule.LeftCssValuePx + "px";
                } else {
                    marginTopOverrideValue = undefined;
                    topOverrideValue = undefined;
                    marginLeftOverrideValue = undefined;
                }
                var styleMoleculeId = styleMolecule.StyleMoleculeId;
                var styleMoleculeIdString = styleMoleculeId.toString();
                var layoutRowStyleClass = "s" + styleMoleculeIdString;
                var holderKeyString = "" + (isRenderFixedLayout ? "f" : "g") + sourceLayoutRowIdString;
                return {
                    renderMaquette: function renderMaquette() {
                        var renderedLayoutBoxes = layoutBoxMapping.results.length > 0 ? layoutBoxMapping.results.map(function (r) {
                            return r.renderMaquette();
                        }) : [];
                        var isHoveredInBoxTree = currentApp.state.hoveredBoxTreeLayoutBaseId == source.LayoutBaseId;
                        if (!isRenderFixedLayout && styleMolecule.IsPositionFixed) {
                            return undefined;
                        }
                        if (styleMolecule.IsPositionFixed) {
                            pagePreviewOverrideStyles = {
                                "position": "absolute"
                            };
                        } else {
                            if (isRenderFixedLayout) {
                                if (renderedLayoutBoxes.filter(function (v) {
                                    return v !== undefined;
                                }).length == 0) {
                                    return undefined;
                                }
                            }
                            pagePreviewOverrideStyles = {
                                "position": undefined
                            };
                        }
                        pagePreviewOverrideStyles["background-color"] = isHoveredInBoxTree ? exports.HIGHLIGHT_BACKGROUND_COLOR_STRING : undefined;
                        if (source.LayoutBaseId == currentApp.state.highlightedLayoutBaseId) {
                            pagePreviewOverrideStyles["outline"] = "solid 1px black";
                            pagePreviewOverrideStyles["outline-offset"] = "-1px";
                            pagePreviewOverrideStyles["background-color"] = exports.MANUALLY_HIGHLIGHT_BACKGROUND_COLOR_STRING;
                        } else {
                            pagePreviewOverrideStyles["outline"] = undefined;
                            pagePreviewOverrideStyles["outline-offset"] = undefined;
                        }
                        if (styleMolecule.IsPositionFixed) {}
                        return h(
                            "div",
                            { key: holderKeyString, "class": layoutRowStyleClass, styles: pagePreviewOverrideStyles },
                            renderedLayoutBoxes
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        sourceLayoutRowIdString = source.LayoutBaseId.toString();
                        styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                            return m.StyleForLayoutId == source.LayoutBaseId;
                        });
                        layoutBoxMapping = currentPagePreview.renderLayoutBoxArray(isRenderFixedLayout, styleMolecule.IsPositionFixed);
                        unsortedBoxes = source.AllBoxesBelowRow.filter(function (b) {
                            return b.PlacedBoxInBoxId === undefined;
                        });
                        sortedBoxes = unsortedBoxes.sort(function (boxA, boxB) {
                            if (boxA.LayoutSortOrderKey < boxB.LayoutSortOrderKey) {
                                return -1;
                            } else if (boxA.LayoutSortOrderKey == boxB.LayoutSortOrderKey) {
                                return 0;
                            } else {
                                return 1;
                            }
                        });
                        layoutBoxMapping.map(sortedBoxes);
                        if (styleMolecule.IsPositionFixed) {
                            marginTopOverrideValue = styleMolecule.TopCssValuePx + "px";
                            topOverrideValue = styleMolecule.TopCssValuePx !== undefined ? currentApp.navigationHeigthPx + "px" : undefined;
                            marginLeftOverrideValue = styleMolecule.LeftCssValuePx + "px";
                        } else {
                            marginTopOverrideValue = undefined;
                            topOverrideValue = undefined;
                            marginLeftOverrideValue = undefined;
                        }
                        styleMoleculeId = styleMolecule.StyleMoleculeId;
                        styleMoleculeIdString = styleMoleculeId.toString();
                        layoutRowStyleClass = "s" + styleMoleculeId;
                        holderKeyString = "" + (isRenderFixedLayout ? "f" : "g") + sourceLayoutRowIdString;
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.renderLayoutBoxArray = function (isRenderFixedLayout, isLayoutBoxInsideFixed) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.LayoutBaseId;
            }, function createSectionTarget(source) {
                var sourceLayoutBoxIdString = source.LayoutBaseId.toString();
                var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                    return m.StyleForLayoutId == source.LayoutBaseId;
                });
                var renderedLayoutAtoms = currentPagePreview.renderLayoutAtomArray(isRenderFixedLayout, styleMolecule.IsPositionFixed || isLayoutBoxInsideFixed);
                var renderedLayoutBoxes = currentPagePreview.renderLayoutBoxArray(isRenderFixedLayout, styleMolecule.IsPositionFixed || isLayoutBoxInsideFixed);
                var pagePreviewOverrideStyles;
                var marginTopOverrideValue;
                var topOverrideValue;
                var marginLeftOverrideValue;
                if (styleMolecule.IsPositionFixed) {
                    marginTopOverrideValue = styleMolecule.TopCssValuePx + "px";
                    topOverrideValue = styleMolecule.TopCssValuePx !== undefined ? currentApp.navigationHeigthPx + "px" : undefined;
                    marginLeftOverrideValue = styleMolecule.LeftCssValuePx + "px";
                } else {
                    marginTopOverrideValue = undefined;
                    topOverrideValue = undefined;
                    marginLeftOverrideValue = undefined;
                }
                var styleMoleculeId = styleMolecule.StyleMoleculeId;
                var styleMoleculeIdString = styleMoleculeId.toString();
                var layoutBoxStyleClass = "s" + styleMoleculeId;
                var richTextTag = "p";
                if (source.SpecialLayoutBoxType === CaliforniaGenerated_1.SpecialLayoutBoxType.RichText && source.PlacedInBoxAtoms.length > 0) {
                    var layoutIdOfFirstAtom_1 = source.PlacedInBoxAtoms[0].LayoutBaseId;
                    var styleOfFirstAtom = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                        return m.StyleForLayoutId == layoutIdOfFirstAtom_1;
                    });
                    if (styleOfFirstAtom.HtmlTag !== undefined) {
                        richTextTag = styleOfFirstAtom.HtmlTag;
                    } else {
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                    }
                }
                return {
                    renderMaquette: function renderMaquette() {
                        var renderedBoxContent = currentPagePreview.mapAndRenderLayoutBoxContent(source, source.PlacedInBoxAtoms, renderedLayoutAtoms, source.PlacedInBoxBoxes, renderedLayoutBoxes);
                        var isHoveredInBoxTree = currentApp.state.hoveredBoxTreeLayoutBaseId == source.LayoutBaseId;
                        if (!isRenderFixedLayout && styleMolecule.IsPositionFixed) {
                            return undefined;
                        }
                        if (styleMolecule.IsPositionFixed) {
                            pagePreviewOverrideStyles = {
                                "position": "absolute"
                            };
                        } else {
                            if (isRenderFixedLayout && !isLayoutBoxInsideFixed) {
                                if (renderedBoxContent.filter(function (v) {
                                    return v !== undefined;
                                }).length == 0) {
                                    return undefined;
                                }
                            }
                            pagePreviewOverrideStyles = {
                                "position": undefined
                            };
                        }
                        pagePreviewOverrideStyles["background-color"] = isHoveredInBoxTree ? exports.HIGHLIGHT_BACKGROUND_COLOR_STRING : undefined;
                        if (source.LayoutBaseId == currentApp.state.highlightedLayoutBaseId) {
                            pagePreviewOverrideStyles["outline"] = "solid 1px black";
                            pagePreviewOverrideStyles["outline-offset"] = "-1px";
                            pagePreviewOverrideStyles["background-color"] = exports.MANUALLY_HIGHLIGHT_BACKGROUND_COLOR_STRING;
                        } else {
                            pagePreviewOverrideStyles["outline"] = undefined;
                            pagePreviewOverrideStyles["outline-offset"] = undefined;
                        }
                        if (styleMolecule.IsPositionFixed) {}
                        return source.SpecialLayoutBoxType === CaliforniaGenerated_1.SpecialLayoutBoxType.Default ? h(
                            "div",
                            { key: sourceLayoutBoxIdString, "class": layoutBoxStyleClass, styles: pagePreviewOverrideStyles },
                            renderedBoxContent
                        ) : source.SpecialLayoutBoxType === CaliforniaGenerated_1.SpecialLayoutBoxType.UnsortedList ? h(
                            "ul",
                            { key: sourceLayoutBoxIdString, "class": layoutBoxStyleClass, styles: pagePreviewOverrideStyles },
                            renderedBoxContent
                        ) : source.SpecialLayoutBoxType === CaliforniaGenerated_1.SpecialLayoutBoxType.SortedList ? h(
                            "ol",
                            { key: sourceLayoutBoxIdString, "class": layoutBoxStyleClass, styles: pagePreviewOverrideStyles },
                            renderedBoxContent
                        ) : source.SpecialLayoutBoxType === CaliforniaGenerated_1.SpecialLayoutBoxType.ListItem ? h(
                            "li",
                            { key: sourceLayoutBoxIdString, "class": layoutBoxStyleClass, styles: pagePreviewOverrideStyles },
                            renderedBoxContent.length > 0 ? renderedBoxContent : h(
                                "p",
                                null,
                                "add atoms..."
                            )
                        ) : source.SpecialLayoutBoxType === CaliforniaGenerated_1.SpecialLayoutBoxType.RichText ? h(richTextTag, {
                            key: sourceLayoutBoxIdString,
                            styles: pagePreviewOverrideStyles,
                            class: layoutBoxStyleClass
                        }, [renderedBoxContent.length > 0 ? renderedBoxContent : h("p", ["add atoms..."])]) : h(
                            "p",
                            null,
                            "TODO Box Type not implemented!"
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        sourceLayoutBoxIdString = source.LayoutBaseId.toString();
                        styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                            return m.StyleForLayoutId == source.LayoutBaseId;
                        });
                        renderedLayoutAtoms = currentPagePreview.renderLayoutAtomArray(isRenderFixedLayout, styleMolecule.IsPositionFixed || isLayoutBoxInsideFixed);
                        renderedLayoutBoxes = currentPagePreview.renderLayoutBoxArray(isRenderFixedLayout, styleMolecule.IsPositionFixed || isLayoutBoxInsideFixed);
                        if (styleMolecule.IsPositionFixed) {
                            marginTopOverrideValue = styleMolecule.TopCssValuePx + "px";
                            topOverrideValue = styleMolecule.TopCssValuePx !== undefined ? currentApp.navigationHeigthPx + "px" : undefined;
                            marginLeftOverrideValue = styleMolecule.LeftCssValuePx + "px";
                        } else {
                            marginTopOverrideValue = undefined;
                            topOverrideValue = undefined;
                            marginLeftOverrideValue = undefined;
                        }
                        styleMoleculeId = styleMolecule.StyleMoleculeId;
                        styleMoleculeIdString = styleMoleculeId.toString();
                        layoutBoxStyleClass = "s" + styleMoleculeId;
                        richTextTag = "p";
                        if (source.SpecialLayoutBoxType === CaliforniaGenerated_1.SpecialLayoutBoxType.RichText && source.PlacedInBoxAtoms.length > 0) {
                            var layoutIdOfFirstAtom_2 = source.PlacedInBoxAtoms[0].LayoutBaseId;
                            var styleOfFirstAtom = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                                return m.StyleForLayoutId == layoutIdOfFirstAtom_2;
                            });
                            if (styleOfFirstAtom.HtmlTag !== undefined) {
                                richTextTag = styleOfFirstAtom.HtmlTag;
                            } else {
                                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                            }
                        }
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.renderLayoutAtomArray = function (isRenderFixedLayout, isLayoutAtomInsideFixed) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.LayoutBaseId;
            }, function createSectionTarget(source) {
                var sourceLayoutAtomIdString = source.LayoutBaseId.toString();
                var sourceContentAtomIdString = source.HostedContentAtom.ContentAtomId.toString();
                var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                    return m.StyleForLayoutId == source.LayoutBaseId;
                });
                var pagePreviewOverrideStyles;
                var marginTopOverrideValue;
                var topOverrideValue;
                var marginLeftOverrideValue;
                var backgroundOverrideValue;
                if (styleMolecule.IsPositionFixed) {
                    marginTopOverrideValue = styleMolecule.TopCssValuePx + "px";
                    topOverrideValue = styleMolecule.TopCssValuePx !== undefined ? currentApp.navigationHeigthPx + "px" : undefined;
                    marginLeftOverrideValue = styleMolecule.LeftCssValuePx + "px";
                } else {
                    marginTopOverrideValue = undefined;
                    topOverrideValue = undefined;
                    marginLeftOverrideValue = undefined;
                }
                var styleMoleculeId = styleMolecule.StyleMoleculeId;
                var styleMoleculeIdString = styleMoleculeId.toString();
                var layoutAtomStyleClass = "s" + styleMoleculeIdString;
                var hostedContentAtom = currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (c) {
                    return c.ContentAtomId == source.HostedContentAtom.ContentAtomId;
                });
                if (styleMolecule.HtmlTag === undefined) {
                    console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                    return undefined;
                }
                var layoutAtomHtmlTag = styleMolecule.HtmlTag !== undefined ? styleMolecule.HtmlTag : "p";
                if (source.PlacedAtomInBox.SpecialLayoutBoxType === CaliforniaGenerated_1.SpecialLayoutBoxType.RichText) {
                    layoutAtomHtmlTag = "span";
                }
                return {
                    renderMaquette: function renderMaquette() {
                        var isHoveredInBoxTree = currentApp.state.hoveredBoxTreeLayoutBaseId == source.LayoutBaseId;
                        if (isRenderFixedLayout && !isLayoutAtomInsideFixed) {
                            return undefined;
                        }
                        if (styleMolecule.IsPositionFixed) {
                            pagePreviewOverrideStyles = {
                                "margin-top": marginTopOverrideValue,
                                "margin-left": marginLeftOverrideValue,
                                "top": topOverrideValue,
                                "left": undefined,
                                "max-width": undefined,
                                "z-index": undefined,
                                "background-color": undefined
                            };
                        } else {
                            pagePreviewOverrideStyles = {
                                "margin-top": undefined,
                                "margin-left": undefined,
                                "top": undefined,
                                "left": undefined,
                                "max-width": undefined,
                                "z-index": undefined,
                                "background-color": undefined
                            };
                        }
                        pagePreviewOverrideStyles["background-color"] = isHoveredInBoxTree ? exports.HIGHLIGHT_BACKGROUND_COLOR_STRING : undefined;
                        if (source.LayoutBaseId == currentApp.state.highlightedLayoutBaseId) {
                            pagePreviewOverrideStyles["outline"] = "solid 1px black";
                            pagePreviewOverrideStyles["outline-offset"] = "-1px";
                            pagePreviewOverrideStyles["background-color"] = exports.MANUALLY_HIGHLIGHT_BACKGROUND_COLOR_STRING;
                        } else {
                            pagePreviewOverrideStyles["outline"] = undefined;
                            pagePreviewOverrideStyles["outline-offset"] = undefined;
                        }
                        if (styleMolecule.IsPositionFixed) {
                            pagePreviewOverrideStyles["max-width"] = styleMolecule.IsPositionFixed && currentApp.state.isDataLoaded && currentApp.state.isEnoughAvailableSpacePagePreview && currentApp.state.editViewMode !== ClientState_1.EditViewMode.PagePreviewOnly ? currentApp.state.targetPagePreviewWidthPx + "px" : undefined;
                            pagePreviewOverrideStyles["left"] = styleMolecule.IsPositionFixed && styleMolecule.LeftCssValuePx !== undefined ? parseInt(styleMolecule.LeftCssValuePx) + currentApp.state.targetPagePreviewHolderMarginPx + "px" : undefined;
                        }
                        var isEditedLayoutAtomId = source.LayoutBaseId == currentPagePreview.viewModel.editedLayoutAtomId;
                        pagePreviewOverrideStyles["z-index"] = isEditedLayoutAtomId ? "30" : undefined;
                        if (isEditedLayoutAtomId) {
                            return h("textarea", { key: "i" + sourceLayoutAtomIdString, "class": layoutAtomStyleClass, value: currentPagePreview.viewModel.tempContent, oninput: currentPagePreview.contentAtomInputHandler, onblur: currentPagePreview.contentAtomLostFocusHandler, onkeydown: currentPagePreview.contentAtomKeyDownHandler, afterCreate: currentPagePreview.contentAtomAfterCreateHandler, afterUpdate: currentPagePreview.contentAtomAfterUpdateHandler, exitAnimation: currentPagePreview.contentAtomExitAnimationHandler, cid: sourceContentAtomIdString, styles: pagePreviewOverrideStyles });
                        }
                        if (hostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Text) {
                            return h(layoutAtomHtmlTag, {
                                key: sourceLayoutAtomIdString,
                                class: layoutAtomStyleClass,
                                onclick: currentPagePreview.layoutAtomClickHandler,
                                ondblclick: currentPagePreview.layoutAtomDblClickHandler,
                                aid: sourceLayoutAtomIdString,
                                cid: sourceContentAtomIdString,
                                styles: pagePreviewOverrideStyles,
                                afterCreate: currentPagePreview.layoutAtomAfterCreateHandler,
                                afterUpdate: currentPagePreview.layoutAtomAfterUpdateHandler,
                                exitAnimation: currentPagePreview.layoutAtomExitAnimationHandler,
                                onmouseenter: currentPagePreview.layoutAtomMouseEnterHandler,
                                onmouseleave: currentPagePreview.layoutAtomMouseLeaveHandler
                            }, [hostedContentAtom.TextContent]);
                        } else if (hostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Link) {
                            return h(layoutAtomHtmlTag, {
                                key: sourceLayoutAtomIdString,
                                class: layoutAtomStyleClass,
                                onclick: currentPagePreview.layoutAtomClickHandler,
                                ondblclick: currentPagePreview.layoutAtomDblClickHandler,
                                aid: sourceLayoutAtomIdString,
                                cid: sourceContentAtomIdString,
                                href: "",
                                styles: pagePreviewOverrideStyles,
                                onmouseenter: currentPagePreview.layoutAtomMouseEnterHandler,
                                onmouseleave: currentPagePreview.layoutAtomMouseLeaveHandler
                            }, [hostedContentAtom.Url]);
                        } else {
                            console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                            return undefined;
                        }
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        sourceLayoutAtomIdString = source.LayoutBaseId.toString();
                        sourceContentAtomIdString = source.HostedContentAtom.ContentAtomId.toString();
                        styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                            return m.StyleForLayoutId == source.LayoutBaseId;
                        });
                        if (styleMolecule.IsPositionFixed) {
                            marginTopOverrideValue = styleMolecule.TopCssValuePx + "px";
                            topOverrideValue = styleMolecule.TopCssValuePx !== undefined ? currentApp.navigationHeigthPx + "px" : undefined;
                            marginLeftOverrideValue = styleMolecule.LeftCssValuePx + "px";
                        } else {
                            marginTopOverrideValue = undefined;
                            topOverrideValue = undefined;
                            marginLeftOverrideValue = undefined;
                        }
                        styleMoleculeId = styleMolecule.StyleMoleculeId;
                        styleMoleculeIdString = styleMoleculeId.toString();
                        layoutAtomStyleClass = "s" + styleMoleculeId;
                        hostedContentAtom = currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (c) {
                            return c.ContentAtomId == source.HostedContentAtom.ContentAtomId;
                        });
                        if (styleMolecule.HtmlTag === undefined) {
                            console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                        }
                        layoutAtomHtmlTag = styleMolecule.HtmlTag !== undefined ? styleMolecule.HtmlTag : "p";
                        if (source.PlacedAtomInBox.SpecialLayoutBoxType === CaliforniaGenerated_1.SpecialLayoutBoxType.RichText) {
                            layoutAtomHtmlTag = "span";
                        }
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.resetContentAtomEditMode = function () {
            currentPagePreview.resetEquationNumbersWhenModifying(false);
            currentPagePreview.viewModel.editedLayoutAtomId = 0;
            currentPagePreview.viewModel.tempContent = "";
            currentPagePreview.viewModel.tempOriginalContent = "";
            currentPagePreview.viewModel.stylesOfEditedContent = {};
        };
        this.contentAtomLostFocusHandler = function (evt) {
            currentPagePreview.updateContentAtom(CaliforniaApp_1.parseIntFromAttribute(evt.target, "cid"));
        };
        this.updateContentAtom = function (contentAtomId) {
            if (currentPagePreview.viewModel.editedLayoutAtomId != 0) {
                if (currentPagePreview.viewModel.tempContent !== currentPagePreview.viewModel.tempOriginalContent) {
                    var contentAtom = currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (a) {
                        return a.InstancedOnLayoutId == currentPagePreview.viewModel.editedLayoutAtomId;
                    });
                    if (contentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Text) {
                        contentAtom.TextContent = currentPagePreview.viewModel.tempContent;
                    } else if (contentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Link) {
                        contentAtom.Url = currentPagePreview.viewModel.tempContent;
                    } else {
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                        return;
                    }
                    if (currentPagePreview.viewModel.tempContent === "") {
                        currentApp.controller.DeleteLayoutJson(currentPagePreview.viewModel.editedLayoutAtomId, false).done(function (data) {
                            return currentApp.router.updateData(data);
                        });
                    } else {
                        currentApp.state.currentReadyState = ClientState_1.ReadyState.Pending;
                        currentApp.controller.UpdateTextContentAtomJson(contentAtomId, currentPagePreview.viewModel.tempContent).done(function (data) {
                            currentApp.router.updateData(data);
                            currentPagePreview.resetEquationNumbersWhenModifying(false);
                        }).always(function (data) {
                            return currentApp.state.currentReadyState = ClientState_1.ReadyState.Ok;
                        });
                    }
                }
            }
            currentPagePreview.resetContentAtomEditMode();
        };
        this.contentAtomKeyDownHandler = function (evt) {
            if (evt.keyCode == 13) {
                evt.preventDefault();
                if (evt.shiftKey === true) {
                    currentPagePreview.contentAtomCreateNewLine(CaliforniaApp_1.parseIntFromAttribute(evt.target, "cid"));
                }
                evt.target.blur();
            } else if (evt.keyCode == 27) {
                evt.preventDefault();
                currentPagePreview.resetContentAtomEditMode();
                evt.target.blur();
            } else if (evt.keyCode == undefined) {
                evt.preventDefault();
            }
        };
        this.contentAtomCreateNewLine = function (contentAtomId) {
            if (currentPagePreview.viewModel.editedLayoutAtomId != 0) {
                var editedLayoutAtom = currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                    return l.LayoutBaseId == currentPagePreview.viewModel.editedLayoutAtomId;
                });
                var editedLayoutAtomIdChainedCall_1 = currentPagePreview.viewModel.editedLayoutAtomId;
                var placedAtomInBoxIdChainedCall_1 = editedLayoutAtom.PlacedAtomInBoxId;
                if (currentPagePreview.viewModel.tempContent !== currentPagePreview.viewModel.tempOriginalContent) {
                    currentApp.state.currentReadyState = ClientState_1.ReadyState.Pending;
                    currentApp.controller.UpdateTextContentAtomJson(contentAtomId, currentPagePreview.viewModel.tempContent).done(function (data) {
                        currentPagePreview.chainedAddMoveLayoutAtomCallWithFullUpdate(placedAtomInBoxIdChainedCall_1, editedLayoutAtomIdChainedCall_1);
                    }).always(function (data) {
                        return currentApp.state.currentReadyState = ClientState_1.ReadyState.Ok;
                    });
                    currentPagePreview.resetContentAtomEditMode();
                } else {
                    currentPagePreview.chainedAddMoveLayoutAtomCallWithFullUpdate(placedAtomInBoxIdChainedCall_1, editedLayoutAtomIdChainedCall_1);
                }
            }
        };
        this.chainedAddMoveLayoutAtomCallWithFullUpdate = function (placedAtomInBoxIdChainedCall, editedLayoutAtomIdChainedCall) {
            currentApp.controller.CreateLayoutAtomForBoxJson(placedAtomInBoxIdChainedCall, editedLayoutAtomIdChainedCall).done(function (dataSub) {
                var subBoxAtoms = dataSub.CaliforniaProject.LayoutMolecules.filter(function (m) {
                    return m.LayoutType === CaliforniaGenerated_1.LayoutType.Atom && m.PlacedAtomInBoxId == placedAtomInBoxIdChainedCall;
                });
                var createdLayoutMoleculeId = subBoxAtoms[subBoxAtoms.length - 1].LayoutBaseId;
                currentApp.controller.MoveLayoutMoleculeNextToLayoutMoleculeJson(createdLayoutMoleculeId, editedLayoutAtomIdChainedCall, true).done(function (dataSubSub) {
                    currentApp.controller.MoveLayoutMoleculeNextToLayoutMoleculeJson(editedLayoutAtomIdChainedCall, createdLayoutMoleculeId, true).done(function (dataSubSubSub) {
                        currentApp.router.updateData(dataSubSubSub);
                        var hostedContentAtom = currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (c) {
                            return c.InstancedOnLayoutId == createdLayoutMoleculeId;
                        });
                        currentPagePreview.viewModel.tempContent = "";
                        currentPagePreview.viewModel.tempOriginalContent = "";
                        if (hostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Text) {
                            currentPagePreview.viewModel.tempOriginalContent = hostedContentAtom.TextContent;
                        } else if (hostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Link) {
                            currentPagePreview.viewModel.tempOriginalContent = hostedContentAtom.Url;
                        } else {
                            console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                            return;
                        }
                        currentPagePreview.viewModel.editedLayoutAtomId = createdLayoutMoleculeId;
                    });
                });
            });
        };
        this.contentAtomAfterCreateHandler = function (element, projectionOptions, vnodeSelector, properties, children) {
            var targetElement = element;
            $(targetElement).css(currentPagePreview.viewModel.stylesOfEditedContent);
            if (currentApp.state.isSelectAllTextArea === true) {
                targetElement.setSelectionRange(0, currentPagePreview.viewModel.tempContent.length);
            }
            targetElement.focus();
        };
        this.contentAtomAfterUpdateHandler = function (element, projectionOptions, vnodeSelector, properties, children) {};
        this.contentAtomExitAnimationHandler = function (element, removeElement, properties) {
            removeElement();
        };
        this.layoutAtomAfterCreateHandler = function (element, projectionOptions, vnodeSelector, properties, children) {
            if (currentApp.state.isJaxOn) {
                var targetElement = element;
                currentPagePreview._activeViewLayoutAtomDomNodeReferences[properties.key] = targetElement;
                if (targetElement.innerText.indexOf("$") != -1) {
                    MathJax.Hub.Queue(["Typeset", MathJax.Hub, targetElement]);
                }
            }
        };
        this.layoutAtomExitAnimationHandler = function (element, removeElement, properties) {
            delete currentPagePreview._activeViewLayoutAtomDomNodeReferences[properties.key];
            removeElement();
        };
        this.layoutAtomMouseEnterHandler = function (evt) {
            var targetElement = evt.target;
            currentApp.state.hoveredPagePreviewLayoutBaseId = CaliforniaApp_1.parseIntFromAttribute(targetElement, "aid");
        };
        this.layoutAtomMouseLeaveHandler = function (evt) {
            currentApp.state.hoveredPagePreviewLayoutBaseId = 0;
        };
        this.layoutAtomAfterUpdateHandler = function (element, projectionOptions, vnodeSelector, properties, children) {
            if (currentApp.state.isJaxOn) {
                var targetElement = element;
                var math = MathJax.Hub.getAllJax(targetElement)[0];
                if (math !== undefined) {} else if (targetElement.innerText.indexOf("$") != -1) {
                    MathJax.Hub.Queue(["Typeset", MathJax.Hub, targetElement]);
                    currentPagePreview.resetEquationNumbersWhenModifying(false);
                }
            }
        };
        this.contentAtomInputHandler = function (evt) {
            currentPagePreview.viewModel.tempContent = evt.target.value;
        };
        this.layoutAtomDblClickHandler = function (evt) {
            evt.preventDefault();
            if (currentApp.state.currentReadyState !== ClientState_1.ReadyState.Ok) {
                console.log("pending...");
                return;
            }
            if (currentApp.state.currentSelectionMode === ClientState_1.SelectionMode.Content) {
                var targetElement = evt.currentTarget;
                currentPagePreview.viewModel.stylesOfEditedContent = currentPagePreview.getStyleObject(targetElement);
                var contentId = CaliforniaApp_1.parseIntFromAttribute(targetElement, "cid");
                var layoutId = CaliforniaApp_1.parseIntFromAttribute(targetElement, "aid");
                var targetWidth = targetElement.clientWidth;
                var targetHeight = targetElement.clientHeight;
                var maxIterations = 10;
                var currentIteration = 0;
                while (currentIteration++ < maxIterations) {
                    if (targetWidth == 0 || targetHeight == 0) {
                        if (targetElement.parentElement !== null) {
                            targetWidth = targetElement.parentElement.clientWidth;
                            targetHeight = targetElement.parentElement.clientHeight;
                            targetElement = targetElement.parentElement;
                        }
                    }
                }
                currentPagePreview.layoutAtomToTextAreaSetup(contentId, layoutId, true, targetWidth, targetHeight);
            } else {}
        };
        this.layoutAtomClickHandler = function (evt) {
            evt.preventDefault();
            if (currentApp.state.currentReadyState !== ClientState_1.ReadyState.Ok) {
                console.log("pending...");
                return;
            }
            if (currentApp.state.currentSelectionMode === ClientState_1.SelectionMode.Content) {
                var targetElement = evt.currentTarget;
                currentPagePreview.viewModel.stylesOfEditedContent = currentPagePreview.getStyleObject(targetElement);
                var contentId = CaliforniaApp_1.parseIntFromAttribute(targetElement, "cid");
                var layoutId = CaliforniaApp_1.parseIntFromAttribute(targetElement, "aid");
                var targetWidth = targetElement.clientWidth;
                var targetHeight = targetElement.clientHeight;
                var maxIterations = 10;
                var currentIteration = 0;
                while (currentIteration++ < maxIterations) {
                    if (targetWidth == 0 || targetHeight == 0) {
                        if (targetElement.parentElement !== null) {
                            targetWidth = targetElement.parentElement.clientWidth;
                            targetHeight = targetElement.parentElement.clientHeight;
                            targetElement = targetElement.parentElement;
                        }
                    }
                }
                currentPagePreview.layoutAtomToTextAreaSetup(contentId, layoutId, true, targetWidth, targetHeight);
            } else {}
        };
        this.layoutAtomToTextAreaSetup = function (contentAtomId, layoutAtomId, isPreSelectAll, targetWidthPx, targetHeightPx) {
            currentApp.state.isSelectAllTextArea = isPreSelectAll;
            currentPagePreview.viewModel.stylesOfEditedContent["outline"] = "solid 1px rgb(200,200,200)";
            currentPagePreview.viewModel.stylesOfEditedContent["outline-offset"] = "-1px";
            if (currentPagePreview.viewModel.stylesOfEditedContent["width"] === undefined || currentPagePreview.viewModel.stylesOfEditedContent["height"] === undefined) {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            } else {
                var targetWidthString = (targetWidthPx == 0 ? 300 : targetWidthPx).toString() + "px";
                var targetHeightString = (targetHeightPx == 0 ? 300 : targetHeightPx).toString() + "px";
                currentPagePreview.viewModel.stylesOfEditedContent["width"] = targetWidthString;
                currentPagePreview.viewModel.stylesOfEditedContent["min-width"] = targetWidthString;
                currentPagePreview.viewModel.stylesOfEditedContent["height"] = targetHeightString;
                currentPagePreview.viewModel.stylesOfEditedContent["min-height"] = targetHeightString;
            }
            var hostedContentAtom = currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (c) {
                return c.ContentAtomId == contentAtomId;
            });
            currentPagePreview.viewModel.tempContent = "";
            if (hostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Text) {
                currentPagePreview.viewModel.tempContent = hostedContentAtom.TextContent;
            } else if (hostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Link) {
                currentPagePreview.viewModel.tempContent = hostedContentAtom.Url;
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                return;
            }
            currentPagePreview.viewModel.tempOriginalContent = currentPagePreview.viewModel.tempContent;
            currentPagePreview.viewModel.editedLayoutAtomId = layoutAtomId;
        };
        this.getStyleObject = function (targetElement) {
            var dom = $(targetElement).get(0);
            var style;
            var returns = {};
            var camelize = function camelize(a, b) {
                return b.toUpperCase();
            };
            style = window.getComputedStyle(dom, undefined);
            for (var i = 0, l = style.length; i < l; i++) {
                var prop = style[i];
                var camel = prop.replace(/\-([a-z])/g, camelize);
                var val = style.getPropertyValue(prop);
                returns[camel] = val;
            }
            ;
            return returns;
        };
        this.mapAndRenderLayoutBoxContent = function (refLayoutBox, unsortedAtoms, atomMapping, unsortedBoxes, boxMapping) {
            if (unsortedAtoms.length == 0 && unsortedBoxes.length == 0) {
                return [];
            }
            var sortedAtoms = unsortedAtoms.sort(function (atomA, atomB) {
                if (atomA.LayoutSortOrderKey < atomB.LayoutSortOrderKey) {
                    return -1;
                } else if (atomA.LayoutSortOrderKey == atomB.LayoutSortOrderKey) {
                    return 0;
                } else {
                    return 1;
                }
            });
            var sortedBoxes = unsortedBoxes.sort(function (boxA, boxB) {
                if (boxA.LayoutSortOrderKey < boxB.LayoutSortOrderKey) {
                    return -1;
                } else if (boxA.LayoutSortOrderKey == boxB.LayoutSortOrderKey) {
                    return 0;
                } else {
                    return 1;
                }
            });
            atomMapping.map(sortedAtoms);
            boxMapping.map(sortedBoxes);
            var renderedAtomsAndBoxes = [];
            var atomIndex = 0;
            var boxIndex = 0;
            var atomsLength = sortedAtoms.length;
            var boxesLength = sortedBoxes.length;
            var totalItems = atomsLength + boxesLength;
            for (var i = 0; i < totalItems; i++) {
                var currentAtom = undefined;
                var currentBox = undefined;
                if (atomIndex < atomsLength) {
                    currentAtom = sortedAtoms[atomIndex];
                }
                if (boxIndex < boxesLength) {
                    currentBox = sortedBoxes[boxIndex];
                }
                if (currentAtom !== undefined && currentBox !== undefined) {
                    if (currentAtom.LayoutSortOrderKey < currentBox.LayoutSortOrderKey) {
                        renderedAtomsAndBoxes.push(atomMapping.results[atomIndex++].renderMaquette());
                    } else {
                        renderedAtomsAndBoxes.push(boxMapping.results[boxIndex++].renderMaquette());
                    }
                } else if (currentAtom !== undefined) {
                    var remainingAtoms = atomsLength - atomIndex;
                    for (var j = 0; j < remainingAtoms; j++) {
                        renderedAtomsAndBoxes.push(atomMapping.results[atomIndex++].renderMaquette());
                    }
                    break;
                } else {
                    var remainingBoxes = boxesLength - boxIndex;
                    for (var j = 0; j < remainingBoxes; j++) {
                        renderedAtomsAndBoxes.push(boxMapping.results[boxIndex++].renderMaquette());
                    }
                    break;
                }
            }
            return renderedAtomsAndBoxes;
        };
        this.getCssRuleOf = function (styleMolecule, responsiveDevice, stateModifier) {
            var selector = ".s" + styleMolecule.StyleMoleculeId;
            if (stateModifier === undefined || stateModifier === "") {
                var styleRule = selector + "{";
                var _loop_1 = function _loop_1(styleAtomMapping) {
                    var styleAtomId = currentApp.clientData.CaliforniaProject.StyleAtoms.find(function (a) {
                        return a.MappedToMoleculeId == styleAtomMapping.StyleMoleculeAtomMappingId;
                    }).StyleAtomId;
                    var appliedValues = currentApp.clientData.CaliforniaProject.StyleValues.filter(function (v) {
                        return v.StyleAtomId == styleAtomId;
                    });
                    for (var _i = 0, appliedValues_1 = appliedValues; _i < appliedValues_1.length; _i++) {
                        var cssProp = appliedValues_1[_i];
                        if (cssProp.CssValue !== "") {
                            styleRule += cssProp.CssProperty + ": " + cssProp.CssValue + ";";
                        }
                    }
                };
                for (var _i = 0, _a = styleMolecule.MappedStyleAtoms.filter(function (styleAtomMap) {
                    return styleAtomMap.ResponsiveDeviceId == responsiveDevice.ResponsiveDeviceId && (styleAtomMap.StateModifier === undefined || styleAtomMap.StateModifier === "");
                }); _i < _a.length; _i++) {
                    var styleAtomMapping = _a[_i];
                    _loop_1(styleAtomMapping);
                }
                styleRule += "}";
                return currentPagePreview.wrapCssMediaQuery(styleRule, responsiveDevice);
            } else {
                var pseudoStyleRule = "" + selector + stateModifier + "{";
                var _loop_2 = function _loop_2(pseudoStyleAtomMapping) {
                    var styleAtomId = currentApp.clientData.CaliforniaProject.StyleAtoms.find(function (a) {
                        return a.MappedToMoleculeId == pseudoStyleAtomMapping.StyleMoleculeAtomMappingId;
                    }).StyleAtomId;
                    var appliedValues = currentApp.clientData.CaliforniaProject.StyleValues.filter(function (v) {
                        return v.StyleAtomId == styleAtomId;
                    });
                    for (var _i = 0, appliedValues_2 = appliedValues; _i < appliedValues_2.length; _i++) {
                        var cssProp = appliedValues_2[_i];
                        if (cssProp.CssValue !== "") {
                            pseudoStyleRule += cssProp.CssProperty + ": " + cssProp.CssValue + ";";
                        }
                    }
                };
                for (var _b = 0, _c = styleMolecule.MappedStyleAtoms.filter(function (styleAtomMap) {
                    return styleAtomMap.ResponsiveDeviceId == responsiveDevice.ResponsiveDeviceId && styleAtomMap.StateModifier === stateModifier;
                }); _b < _c.length; _b++) {
                    var pseudoStyleAtomMapping = _c[_b];
                    _loop_2(pseudoStyleAtomMapping);
                }
                pseudoStyleRule += "}";
                return currentPagePreview.wrapCssMediaQuery(pseudoStyleRule, responsiveDevice);
            }
        };
        this.wrapCssMediaQuery = function (styleRule, responsiveDevice) {
            if (responsiveDevice.WidthThreshold !== undefined && responsiveDevice.WidthThreshold > 0) {
                return "@media(min-width:" + currentPagePreview.dynamicClientGridBreakpoints[currentApp.clientData.CaliforniaProject.ResponsiveDevices.indexOf(responsiveDevice)] + "px){" + styleRule + "}";
            } else {
                return styleRule;
            }
        };
        this.appendStyleRulesFor = function (styleMolecule, styleSheet) {
            var ruleIndex;
            var styleRule;
            for (var i = 0; i < currentApp.clientData.CaliforniaProject.ResponsiveDevices.length; i++) {
                var responsiveDevice = currentApp.clientData.CaliforniaProject.ResponsiveDevices[i];
                ruleIndex = styleSheet.cssRules.length;
                styleRule = currentPagePreview.getCssRuleOf(styleMolecule, responsiveDevice, undefined);
                styleSheet.insertRule(styleRule, ruleIndex);
                currentPagePreview.virtualStyleIndex[i][styleMolecule.StyleMoleculeId] = ruleIndex;
                var stateModifiers = [];
                var _loop_3 = function _loop_3(i_1) {
                    var styleAtomMap = styleMolecule.MappedStyleAtoms[i_1];
                    if (styleAtomMap.ResponsiveDeviceId == responsiveDevice.ResponsiveDeviceId && styleAtomMap.StateModifier !== undefined) if (stateModifiers.findIndex(function (s) {
                        return s === styleAtomMap.StateModifier;
                    }) == -1) {
                        stateModifiers.push(styleAtomMap.StateModifier);
                    }
                };
                for (var i_1 = 0; i_1 < styleMolecule.MappedStyleAtoms.length; i_1++) {
                    _loop_3(i_1);
                }
                for (var _i = 0, stateModifiers_1 = stateModifiers; _i < stateModifiers_1.length; _i++) {
                    var stateModifier = stateModifiers_1[_i];
                    ruleIndex = styleSheet.cssRules.length;
                    styleRule = currentPagePreview.getCssRuleOf(styleMolecule, responsiveDevice, stateModifier);
                    styleSheet.insertRule(styleRule, ruleIndex);
                    currentPagePreview.virtualPseudoStyleIndex[i]["" + styleMolecule.StyleMoleculeId + stateModifier] = ruleIndex;
                }
            }
        };
        this.reloadCssStyles = function () {
            for (var i = currentApp.styleSheet.cssRules.length; i > 0; i--) {
                currentApp.styleSheet.deleteRule(i - 1);
            }
            for (var i = 0; i < currentApp.clientData.CaliforniaProject.StyleMolecules.length; i++) {
                var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules[i];
                currentPagePreview.appendStyleRulesFor(styleMolecule, currentApp.styleSheet);
            }
        };
        this.updatePagePreviewDimensions = function () {
            var staticMargin = currentApp.state.defaultSymmetricPagePreviewHolderMarginPx;
            var targetWidthPx = 0;
            if (currentApp.state.overrideResponsiveDeviceId == 0) {
                currentApp.state.targetPagePreviewHolderMarginPx = staticMargin;
                targetWidthPx = currentApp.state.availableSpacePagePreviewPx - 2 * staticMargin;
                currentApp.state.targetPagePreviewWidthPx = targetWidthPx;
                currentApp.state.isEnoughAvailableSpacePagePreview = true;
            } else {
                var overrideWithResponsiveDevice = currentApp.clientData.CaliforniaProject.ResponsiveDevices.find(function (r) {
                    return r.ResponsiveDeviceId == currentApp.state.overrideResponsiveDeviceId;
                });
                if (currentApp.state.overrideResponsiveDeviceId == currentApp.state.highestWidthThresholdResponsiveDeviceId) {
                    targetWidthPx = overrideWithResponsiveDevice.WidthThreshold + 1;
                } else {
                    var targetResponsiveSettingAbove = currentApp.clientData.CaliforniaProject.ResponsiveDevices[currentApp.clientData.CaliforniaProject.ResponsiveDevices.indexOf(overrideWithResponsiveDevice) + 1];
                    targetWidthPx = targetResponsiveSettingAbove.WidthThreshold - 1;
                }
                if (currentApp.state.availableSpacePagePreviewPx - 2 * staticMargin >= targetWidthPx) {
                    var remainingSpacePx = currentApp.state.availableSpacePagePreviewPx - 2 * staticMargin - targetWidthPx;
                    currentApp.state.targetPagePreviewHolderMarginPx = staticMargin + remainingSpacePx / 2;
                    currentApp.state.targetPagePreviewWidthPx = currentApp.state.availableSpacePagePreviewPx - remainingSpacePx;
                    currentApp.state.isEnoughAvailableSpacePagePreview = true;
                } else {
                    currentApp.state.isEnoughAvailableSpacePagePreview = false;
                    currentApp.state.targetPagePreviewHolderMarginPx = staticMargin;
                    currentApp.state.targetPagePreviewWidthPx = targetWidthPx;
                }
            }
            if (currentApp.state.isDataLoaded === true) {
                var currentResponsiveDeviceIndex = currentApp.clientData.CaliforniaProject.ResponsiveDevices.findIndex(function (r) {
                    return targetWidthPx < r.WidthThreshold;
                });
                if (currentResponsiveDeviceIndex == 0) {
                    console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                } else if (currentResponsiveDeviceIndex == -1) {
                    currentApp.state.currentResponsiveDeviceId = currentApp.state.highestWidthThresholdResponsiveDeviceId;
                } else {
                    currentApp.state.currentResponsiveDeviceId = currentApp.clientData.CaliforniaProject.ResponsiveDevices[currentResponsiveDeviceIndex - 1].ResponsiveDeviceId;
                }
            }
            currentPagePreview.dynamicClientGridBreakpoints = [];
            var californiaAppWidth = $(window).width();
            if (californiaAppWidth === undefined) {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                return;
            }
            var californiaUIWidth = californiaAppWidth - currentApp.state.availableSpacePagePreviewPx;
            for (var i = 0; i < currentApp.clientData.CaliforniaProject.ResponsiveDevices.length; i++) {
                var responsiveDevice = currentApp.clientData.CaliforniaProject.ResponsiveDevices[i];
                if (responsiveDevice.WidthThreshold < 0) {
                    currentPagePreview.dynamicClientGridBreakpoints.push(0);
                } else if (responsiveDevice.WidthThreshold == 0) {
                    currentPagePreview.dynamicClientGridBreakpoints.push(0);
                } else {
                    var currentDeviceIndex = currentApp.clientData.CaliforniaProject.ResponsiveDevices.findIndex(function (r) {
                        return r.ResponsiveDeviceId == currentApp.state.currentResponsiveDeviceId;
                    });
                    var safetyMarginPx = 50;
                    if (i <= currentDeviceIndex) {
                        var adjustedBreakPoint = californiaAppWidth - safetyMarginPx - (currentDeviceIndex + 1 - i);
                        currentPagePreview.dynamicClientGridBreakpoints.push(adjustedBreakPoint);
                    } else {
                        var adjustedBreakPoint = californiaAppWidth + safetyMarginPx + (i - currentDeviceIndex);
                        currentPagePreview.dynamicClientGridBreakpoints.push(adjustedBreakPoint);
                    }
                }
            }
            currentPagePreview.reloadCssStyles();
        };
        currentPagePreview = this;
        currentApp = californiaAppArg;
        this.viewModel = new PagePreviewVM_1.PagePreviewVM(this);
    }
    ;
    Object.defineProperty(PagePreview.prototype, "visibleLayoutAtomDomNodeReferences", {
        get: function get() {
            return this._visibleLayoutAtomDomNodeReferences;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PagePreview.prototype, "visibleLayoutAtomKeys", {
        get: function get() {
            return this._visibleLayoutAtomKeys;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PagePreview.prototype, "activeViewLayoutAtomDomNodeReferences", {
        get: function get() {
            return this._activeViewLayoutAtomDomNodeReferences;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PagePreview.prototype, "mostUpperVisibleLayoutAtomId", {
        get: function get() {
            return this._mostUpperVisibleLayoutAtomId;
        },
        enumerable: true,
        configurable: true
    });
    ;
    return PagePreview;
}();
exports.PagePreview = PagePreview;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var maquette = __webpack_require__(1);
var h = maquette.h;
var currentVM;
var PagePreviewVM = function () {
    function PagePreviewVM(pagePreviewArg) {
        this.tempOriginalContent = "";
        this.tempContent = "";
        this.editedLayoutAtomId = 0;
        this.stylesOfEditedContent = {};
        this.activeCaliforniaViewId = 0;
        this.activeCaliforniaViewBodyStyleString = "";
        this.activeCaliforniaViewStyleString = "";
        currentVM = this;
        this.californiaViewProjector = pagePreviewArg.renderCaliforniaViewArray();
        this.fixedLayoutRowsProjector = pagePreviewArg.renderLayoutRowArray(true);
    }
    ;
    return PagePreviewVM;
}();
exports.PagePreviewVM = PagePreviewVM;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(jQuery, $) {

Object.defineProperty(exports, "__esModule", { value: true });
var velocity = __webpack_require__(40);
var maquette = __webpack_require__(1);
var h = maquette.h;
var CaliforniaApp_1 = __webpack_require__(3);
var PropertyBarVM_1 = __webpack_require__(5);
var CaliforniaGenerated_1 = __webpack_require__(2);
var ClientState_1 = __webpack_require__(4);
var popperjs = __webpack_require__(6);
var ContentAtomType_1 = __webpack_require__(7);
var currentApp;
exports.VERY_HIGH_VALUE = 2300000000;
var CaliforniaViewSpecialStyle;
(function (CaliforniaViewSpecialStyle) {
    CaliforniaViewSpecialStyle[CaliforniaViewSpecialStyle["View"] = 0] = "View";
    CaliforniaViewSpecialStyle[CaliforniaViewSpecialStyle["Body"] = 1] = "Body";
    CaliforniaViewSpecialStyle[CaliforniaViewSpecialStyle["Html"] = 2] = "Html";
})(CaliforniaViewSpecialStyle || (CaliforniaViewSpecialStyle = {}));
var PropertyBar = function () {
    function PropertyBar(californiaAppArg, targetIndex) {
        var _this = this;
        this.propertyBarIndex = -1;
        this._visibleLayoutAtomDomNodeReferences = [];
        this._activeViewLayoutAtomDomNodeReferences = {};
        this._visibleLayoutAtomKeys = [];
        this._mostUpperVisibleLayoutAtomId = 0;
        this.renderPropertyBar = function () {
            var divPropertyBarsStyles = {
                "flex": currentApp.state.editViewMode === ClientState_1.EditViewMode.SidebarOnly ? "1 1 200px" : "1 1 200px",
                "display": "flex",
                "flex-flow": "row nowrap",
                "height": "100%",
                "min-width": "100px",
                "width": "200px",
                "z-index": "2"
            };
            var propertyBarStyles = {
                "flex": currentApp.state.editViewMode === ClientState_1.EditViewMode.SidebarOnly ? "1 1 1px" : "1 1 1px",
                "border-right": _this.propertyBarIndex < currentApp.propertyBarCount - 1 && _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.CaliforniaView ? "solid 3px black" : undefined,
                "width": "100%",
                "height": "100%",
                "display": "flex",
                "flex-flow": "column nowrap"
            };
            return h(
                "div",
                { key: "p" + _this.propertyBarIndex.toString(), styles: divPropertyBarsStyles },
                h(
                    "div",
                    { key: "v0", styles: propertyBarStyles },
                    _this.currentPropertyBar.renderPropertyBarNavigation(),
                    _this.currentPropertyBar.renderPropertyBarControls(),
                    _this.propertyBarIndex != 0 ? _this.currentPropertyBar.renderPropertyBarPoppersRenderOnce() : undefined
                )
            );
        };
        this.renderPropertyBarPoppersRenderOnce = function () {
            return h(
                "div",
                { key: "k0" },
                _this.currentPropertyBar.renderAddCssPropertyPopup(),
                _this.currentPropertyBar.renderAllCssPropertiesPopup(),
                _this.currentPropertyBar.renderUpdateCssValuePopup(),
                _this.currentPropertyBar.renderMatchingQuantumsPopup(),
                _this.currentPropertyBar.renderUpdateCssQuantumPopup(),
                _this.currentPropertyBar.renderAllCssPropertiesForQuantumPopup(),
                _this.currentPropertyBar.insertLayoutRowIntoViewPopup(),
                _this.currentPropertyBar.insertLayoutAtomIntoBoxPopup(),
                _this.currentPropertyBar.insertLayoutBoxIntoBoxPopup(),
                _this.currentPropertyBar.moveStyleAtomToResponsiveDevicePopup(),
                _this.currentPropertyBar.renderSelectInteractionTargetPopup(),
                _this.currentPropertyBar.renderSelectInteractionTargetLayoutFilterPopup(),
                _this.currentPropertyBar.renderShareCaliforniaProjectPopup(),
                _this.currentPropertyBar.renderCaliforniaViewSelectionPopup()
            );
        };
        this.renderPropertyBarNavigation = function () {
            var propertyBarNavigationStyles = {
                "margin-top": currentApp.navigationHeigthPx + "px",
                "display": "flex",
                "flex-flow": "row nowrap",
                "height": "auto",
                "width": "100%",
                "flex": "0 0 auto"
            };
            var hiddenModeButtons = [PropertyBarVM_1.PropertyBarMode.None, PropertyBarVM_1.PropertyBarMode.AllStyleAtoms, PropertyBarVM_1.PropertyBarMode.LayoutAtoms, PropertyBarVM_1.PropertyBarMode.LayoutBase, PropertyBarVM_1.PropertyBarMode.LayoutMolecules, PropertyBarVM_1.PropertyBarMode.StyleMolecule];
            var propertyBarModeIconStrings = {};
            propertyBarModeIconStrings[PropertyBarVM_1.PropertyBarMode.AllCaliforniaViews] = "V";
            propertyBarModeIconStrings[PropertyBarVM_1.PropertyBarMode.AllLayoutMolecules] = "L";
            propertyBarModeIconStrings[PropertyBarVM_1.PropertyBarMode.AllStyleMolecules] = "S";
            propertyBarModeIconStrings[PropertyBarVM_1.PropertyBarMode.AllStyleQuantums] = "Q";
            propertyBarModeIconStrings[PropertyBarVM_1.PropertyBarMode.CaliforniaView] = ":)";
            var propertyBarModeButtons = CaliforniaApp_1.getArrayForEnum(PropertyBarVM_1.PropertyBarMode).map(function (type, index) {
                var modeButtonStyles = {
                    "color": index === _this.currentPropertyBar.viewModel.currentPropertyBarMode ? "red" : undefined,
                    "width": "1px",
                    "margin-right": "5px",
                    "margin-left": "5px",
                    "flex": "1 1 1px"
                };
                if (hiddenModeButtons.findIndex(function (el) {
                    return el == index;
                }) != -1) {
                    return undefined;
                }
                return h(
                    "button",
                    { key: index, role: "button", pid: index.toString(), onclick: _this.currentPropertyBar.setPropertyBarMode, styles: modeButtonStyles },
                    propertyBarModeIconStrings[index] !== undefined ? propertyBarModeIconStrings[index] : type
                );
            });
            return h(
                "div",
                { key: "n0", styles: propertyBarNavigationStyles },
                propertyBarModeButtons,
                _this.propertyBarIndex == 0 ? h(
                    "button",
                    { key: "a", onclick: _this.currentPropertyBar.logoutPopupClickHandler, styles: { "flex": "0 0 auto", "width": "auto" } },
                    "\u2709\u2026"
                ) : undefined
            );
        };
        this.setPropertyBarMode = function (evt) {
            _this.currentPropertyBar.viewModel.currentPropertyBarMode = CaliforniaApp_1.parseIntFromAttribute(evt.target, "pid");
        };
        this.renderPropertyBarControls = function () {
            var divPropertyBarControlsStyles = {
                "flex": "1 1 auto",
                "height": "100%",
                "width": "100%"
            };
            var propertyBarControlsStyles = {
                "width": "100%",
                "height": "100%",
                "overflow": "auto"
            };
            return h(
                "div",
                { key: _this.currentPropertyBar.viewModel.currentPropertyBarMode, styles: divPropertyBarControlsStyles },
                _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.AllStyleAtoms ? h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.AllStyleAtoms, styles: propertyBarControlsStyles },
                    _this.currentPropertyBar.viewModel.styleAtomProjector.results.map(function (r) {
                        return r.renderMaquette();
                    })
                ) : _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.AllStyleQuantums ? h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.AllStyleQuantums, styles: propertyBarControlsStyles },
                    _this.currentPropertyBar.renderStyleQuantumControls(),
                    _this.currentPropertyBar.viewModel.styleQuantumProjector.results.map(function (r) {
                        return r.renderMaquette();
                    })
                ) : _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.AllStyleMolecules ? h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.AllStyleMolecules, styles: propertyBarControlsStyles },
                    _this.currentPropertyBar.viewModel.styleMoleculeProjector.results.map(function (r) {
                        return r.renderMaquette();
                    })
                ) : _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.StyleMolecule ? h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.AllStyleMolecules, styles: propertyBarControlsStyles },
                    _this.currentPropertyBar.renderStyleMoleculeControls(_this)
                ) : _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.LayoutAtoms ? h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.LayoutAtoms, styles: propertyBarControlsStyles },
                    _this.currentPropertyBar.viewModel.instanceableAtomProjector.results.map(function (r) {
                        return r.renderMaquette();
                    })
                ) : _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.LayoutMolecules ? h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.LayoutMolecules, styles: propertyBarControlsStyles },
                    _this.currentPropertyBar.viewModel.instanceableMoleculeProjector.results.map(function (r) {
                        return r.renderMaquette();
                    })
                ) : _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.AllLayoutMolecules ? h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.AllLayoutMolecules, styles: propertyBarControlsStyles },
                    _this.currentPropertyBar.viewModel.allLayoutMoleculesProjector.results.map(function (r) {
                        return r.renderMaquette();
                    })
                ) : _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.LayoutBase ? h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.LayoutBase, styles: propertyBarControlsStyles },
                    _this.currentPropertyBar.renderLayoutBaseControls()
                ) : _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.AllCaliforniaViews ? h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.AllCaliforniaViews, styles: propertyBarControlsStyles },
                    _this.currentPropertyBar.renderCaliforniaViewControlsWhenAll(),
                    _this.currentPropertyBar.viewModel.allCaliforniaViewsProjector.results.map(function (r) {
                        return r.renderMaquette();
                    })
                ) : _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.CaliforniaView ? h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.CaliforniaView, styles: propertyBarControlsStyles },
                    _this.currentPropertyBar.renderCaliforniaViewControls()
                ) : undefined
            );
        };
        this.renderStyleMoleculeControls = function (propertyBar) {
            if (propertyBar.viewModel.selectedStyleMoleculeId != 0) {
                var sourceStyleMoleculeIdString = propertyBar.viewModel.selectedStyleMoleculeId.toString();
                var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                    return m.StyleMoleculeId == propertyBar.viewModel.selectedStyleMoleculeId;
                });
                if (styleMolecule === undefined) {
                    return undefined;
                }
                var isClonedStyle = false;
                var cloneRefStyleMoleculeIdString = undefined;
                if (styleMolecule.ClonedFromStyleId !== undefined) {
                    isClonedStyle = true;
                    cloneRefStyleMoleculeIdString = styleMolecule.ClonedFromStyleId.toString();
                }
                var styledLayoutBaseIdString = styleMolecule.StyleForLayoutId.toString();
                var propertyBarControlsStyles = {
                    "height": "100%",
                    "width": "100%",
                    "display": "flex",
                    "flex-flow": "column nowrap"
                };
                return h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.StyleMolecule, styles: propertyBarControlsStyles },
                    h(
                        "div",
                        { key: "0", styles: { "flex": "0 0 auto" } },
                        "Selected StyleMolecule #",
                        propertyBar.viewModel.selectedStyleMoleculeId,
                        isClonedStyle ? h(
                            "div",
                            { key: "0" },
                            h(
                                "button",
                                { key: "a", role: "button", mid: cloneRefStyleMoleculeIdString, onclick: propertyBar.selectStyleMoleculeClickHandler },
                                "ref style (#",
                                cloneRefStyleMoleculeIdString,
                                ")"
                            ),
                            h(
                                "button",
                                { disabled: true, key: "b", role: "button", mid: sourceStyleMoleculeIdString, onclick: propertyBar.createReferenceStyleMoleculeClickHandler },
                                "make ref"
                            ),
                            h(
                                "button",
                                { disabled: true, key: "c", role: "button", mid: sourceStyleMoleculeIdString, onclick: propertyBar.syncToReferenceStyleClickHandler },
                                "sync to ref"
                            ),
                            h(
                                "button",
                                { disabled: true, key: "d", role: "button", mid: sourceStyleMoleculeIdString, onclick: propertyBar.syncFromReferenceStyleClickHandler },
                                "sync from ref"
                            )
                        ) : propertyBar.renderStyleMoleculeReferenceSelector(),
                        propertyBar.renderResponsiveDeviceSelectors(),
                        propertyBar.renderStateModifierSelectors(),
                        propertyBar.renderStyleAtomControls()
                    ),
                    h(
                        "div",
                        { key: "1", styles: { "flex": "1 1 1px", "overflow": "scroll" } },
                        propertyBar.viewModel.styleAtomProjector.results.map(function (r) {
                            return r.renderMaquette();
                        }),
                        propertyBar.renderStyleMoleculeChildren(propertyBar)
                    ),
                    h(
                        "div",
                        { key: "2", styles: { "flex": "0 0 auto" } },
                        h(
                            "button",
                            { key: "a", role: "button", lid: styledLayoutBaseIdString, onclick: propertyBar.selectLayoutBaseClickHandler },
                            "layout #",
                            styledLayoutBaseIdString
                        )
                    )
                );
            } else {
                return undefined;
            }
        };
        this.syncToReferenceStyleClickHandler = function (evt) {
            currentApp.controller.SyncStyleMoleculeToReferenceStyleJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "mid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.syncFromReferenceStyleClickHandler = function (evt) {
            currentApp.controller.SyncStyleMoleculeFromReferenceStyleJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "mid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.createReferenceStyleMoleculeClickHandler = function (evt) {
            currentApp.controller.SetStyleMoleculeAsReferenceStyleJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "mid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.renderStyleMoleculeReferenceSelector = function () {
            return h(
                "div",
                { key: "-1" },
                h(
                    "select",
                    { disabled: true, onchange: _this.currentPropertyBar.styleMoleculeReferenceChangedHandler },
                    currentApp.clientData.CaliforniaProject.StyleMolecules.map(function (mol) {
                        if (mol.ClonedFromStyleId !== undefined) {
                            return undefined;
                        }
                        var styleMoleculeIdString = mol.StyleMoleculeId.toString();
                        if (mol.StyleMoleculeId == _this.currentPropertyBar.viewModel.selectedStyleMoleculeId) {
                            return h(
                                "option",
                                { selected: true, key: styleMoleculeIdString, value: styleMoleculeIdString },
                                mol.Name,
                                " #",
                                mol.StyleMoleculeId
                            );
                        } else {
                            return h(
                                "option",
                                { key: styleMoleculeIdString, value: styleMoleculeIdString },
                                mol.Name,
                                " #",
                                mol.StyleMoleculeId
                            );
                        }
                    })
                )
            );
        };
        this.styleMoleculeReferenceChangedHandler = function (evt) {
            var targetSelect = evt.target;
            var parsedStyleMoleculeId = undefined;
            if (targetSelect.selectedIndex < targetSelect.childElementCount) {
                var selectOptionElement = targetSelect.options[targetSelect.selectedIndex];
                parsedStyleMoleculeId = parseInt(selectOptionElement.value);
            }
            if (parsedStyleMoleculeId !== undefined) {
                currentApp.controller.SetStyleMoleculeReferenceJson(_this.currentPropertyBar.viewModel.selectedStyleMoleculeId, parsedStyleMoleculeId).done(function (data) {
                    return currentApp.router.updateData(data);
                });
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
        };
        this.renderStyleMoleculeChildren = function (propertyBar) {
            var childMolecules = [];
            if (propertyBar.viewModel.selectedStyleMoleculeId != 0) {
                childMolecules = currentApp.clientData.CaliforniaProject.StyleMolecules.filter(function (s) {
                    return s.ClonedFromStyleId == _this.currentPropertyBar.viewModel.selectedStyleMoleculeId;
                });
            }
            return h(
                "div",
                { key: "-4" },
                " affects styles:",
                childMolecules.map(function (s) {
                    var styleMoleculeIdString = s.StyleMoleculeId.toString();
                    return h(
                        "div",
                        { key: styleMoleculeIdString },
                        h(
                            "button",
                            { key: "a", role: "button", mid: styleMoleculeIdString, onclick: propertyBar.selectStyleMoleculeClickHandler },
                            "#",
                            styleMoleculeIdString
                        )
                    );
                })
            );
        };
        this.renderBoxTreeForCaliforniaView = function (propertyBar) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.CaliforniaViewId;
            }, function createSectionTarget(source) {
                var sourceCaliforniaViewIdString = source.CaliforniaViewId.toString();
                var layoutRows = propertyBar.renderLayoutRowArray(propertyBar);
                layoutRows.map(source.PlacedLayoutRows);
                return {
                    renderMaquette: function renderMaquette() {
                        var treeViewStyles = {
                            "display": "flex",
                            "flex-direction": "row",
                            "flex-wrap": "wrap",
                            "margin-right": "-15px",
                            "font-family": "sans-serif",
                            "border-bottom": "solid, 1px, black",
                            "width": "auto",
                            "height": "auto",
                            "padding-bottom": "123px"
                        };
                        return propertyBar.viewModel.selectedCaliforniaViewId == source.CaliforniaViewId ? h(
                            "div",
                            { key: sourceCaliforniaViewIdString, styles: treeViewStyles },
                            layoutRows.results.map(function (r) {
                                return r.renderMaquette();
                            })
                        ) : undefined;
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        layoutRows.map(source.PlacedLayoutRows);
                        sourceCaliforniaViewIdString = source.CaliforniaViewId.toString();
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.renderLayoutRowArray = function (propertyBar) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.LayoutBaseId;
            }, function createSectionTarget(source) {
                var sourceLayoutRowIdString = source.LayoutBaseId.toString();
                var renderedLayoutBoxes = propertyBar.renderLayoutBoxArray(propertyBar);
                var unsortedBoxes = source.AllBoxesBelowRow.filter(function (b) {
                    return b.PlacedBoxInBoxId === undefined;
                });
                var sortedBoxes = unsortedBoxes.sort(function (boxA, boxB) {
                    if (boxA.LayoutSortOrderKey < boxB.LayoutSortOrderKey) {
                        return -1;
                    } else if (boxA.LayoutSortOrderKey == boxB.LayoutSortOrderKey) {
                        return 0;
                    } else {
                        return 1;
                    }
                });
                renderedLayoutBoxes.map(sortedBoxes);
                var styleMoleculeId = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                    return m.StyleForLayoutId == source.LayoutBaseId;
                }).StyleMoleculeId;
                var styleMoleculeIdString = styleMoleculeId.toString();
                var layoutRowStyleClass = "s" + styleMoleculeIdString;
                return {
                    renderMaquette: function renderMaquette() {
                        var treeRowStyles = {
                            "flex-basis": "100%",
                            "width": "100%",
                            "max-width": "100%",
                            "padding-left": "15px",
                            "padding-right": "15px",
                            "background-color": "rgb(222, 222, 222)"
                        };
                        var captionStyles = {
                            "flex-basis": "auto",
                            "width": "auto",
                            "color": "rgb(78, 78, 78)",
                            "padding-left": "15px",
                            "padding-right": "15px",
                            "margin": "0",
                            "background-color": "rgb(222, 222, 222)",
                            "text-decoration": "underline"
                        };
                        var divButtonStyles = {
                            "display": "flex",
                            "flex-direction": "row",
                            "flex-wrap": "nowrap",
                            "margin-right": "-15px",
                            "width": "auto",
                            "flex": "0 0 auto"
                        };
                        var buttonStyles = {
                            "font-size": "10px",
                            "color": "rgb(78, 78, 78)",
                            "background-color": "rgb(222, 222, 222)",
                            "width": "auto",
                            "flex": "0 0 auto",
                            "outline": undefined,
                            "outline-offset": undefined
                        };
                        var isPreselectedAny = currentApp.state.preselectedLayoutBaseId != 0;
                        var isPreselectedCurrent = isPreselectedAny && currentApp.state.preselectedLayoutBaseId == source.LayoutBaseId;
                        var buttonStylesTarget = {
                            "font-size": "10px",
                            "color": !isPreselectedAny || isPreselectedCurrent ? "rgb(222, 222, 222)" : "rgb(78, 78, 78)",
                            "background-color": "rgb(222, 222, 222)",
                            "width": "auto",
                            "flex": "0 0 auto",
                            "outline": !isPreselectedAny || isPreselectedCurrent ? undefined : "solid 4px rgb(200,0,0)",
                            "outline-offset": !isPreselectedAny || isPreselectedCurrent ? undefined : "-4px"
                        };
                        var buttonStylesPreselectRow = {
                            "font-size": "10px",
                            "color": isPreselectedCurrent ? "rgb(222,222,222)" : isPreselectedAny ? "rgb(222, 222, 222)" : "rgb(78, 78, 78)",
                            "background-color": isPreselectedCurrent ? "rgb(200,0,0)" : "rgb(222, 222, 222)",
                            "width": "auto",
                            "flex": "0 0 auto",
                            "outline": isPreselectedCurrent || isPreselectedAny ? undefined : "solid 1px rgb(200,0,0)",
                            "outline-offset": isPreselectedCurrent || isPreselectedAny ? undefined : "-1px"
                        };
                        var divSubBoxStyles = {
                            "flex-basis": "100%",
                            "width": "100%",
                            "max-width": "100%",
                            "padding-left": "15px",
                            "padding-right": "15px"
                        };
                        return h(
                            "div",
                            { key: sourceLayoutRowIdString, styles: treeRowStyles, lid: sourceLayoutRowIdString, onmouseenter: propertyBar.layoutBaseMouseEnterHandler, onmouseleave: propertyBar.layoutBaseMouseLeaveHandler },
                            h(
                                "div",
                                { key: "-2", styles: divButtonStyles },
                                h(
                                    "p",
                                    { key: "-1", styles: captionStyles },
                                    "ROW"
                                ),
                                h(
                                    "button",
                                    { key: "a", styles: buttonStyles, lid: sourceLayoutRowIdString, onclick: propertyBar.insertLayoutBoxIntoBoxClickHandler },
                                    "+(B)"
                                ),
                                h(
                                    "button",
                                    { key: "b", styles: buttonStyles, lid: sourceLayoutRowIdString, onclick: propertyBar.selectLayoutBaseClickHandler },
                                    "\u2026"
                                ),
                                h(
                                    "button",
                                    { key: "c", styles: buttonStyles, lid: sourceLayoutRowIdString, onclick: propertyBar.highlightLayoutBaseClickHandler },
                                    "?"
                                ),
                                h(
                                    "button",
                                    { key: "d", styles: buttonStyles, mid: styleMoleculeIdString, onclick: propertyBar.selectStyleMoleculeClickHandler },
                                    "S\u2026"
                                ),
                                h(
                                    "button",
                                    { key: "e", styles: buttonStyles, lid: sourceLayoutRowIdString, onclick: propertyBar.saveLayoutMoleculeClickHandler },
                                    "!!!"
                                ),
                                isPreselectedCurrent || !isPreselectedAny ? h(
                                    "button",
                                    { key: "f", styles: buttonStylesPreselectRow, lid: sourceLayoutRowIdString, onclick: propertyBar.moveLayoutRowBeforeRowClickHandler },
                                    "MV(R)"
                                ) : h(
                                    "button",
                                    { disabled: true, key: "f0", styles: buttonStylesPreselectRow, lid: sourceLayoutRowIdString, onclick: propertyBar.moveLayoutRowBeforeRowClickHandler },
                                    "MV(R)"
                                ),
                                isPreselectedCurrent || !isPreselectedAny ? h(
                                    "button",
                                    { key: "g", styles: buttonStylesPreselectRow, lid: sourceLayoutRowIdString, onclick: propertyBar.syncLayoutBaseStylesClickHandler },
                                    "ST(R)"
                                ) : h(
                                    "button",
                                    { disabled: true, key: "g0", styles: buttonStylesPreselectRow, lid: sourceLayoutRowIdString, onclick: propertyBar.syncLayoutBaseStylesClickHandler },
                                    "ST(R)"
                                ),
                                isPreselectedAny && !isPreselectedCurrent ? h(
                                    "button",
                                    { key: "h", styles: buttonStylesTarget, lid: sourceLayoutRowIdString, onclick: propertyBar.finalizeLayoutRequest },
                                    "$(B:R)"
                                ) : h(
                                    "button",
                                    { disabled: true, key: "h0", styles: buttonStylesTarget, lid: sourceLayoutRowIdString, onclick: propertyBar.finalizeLayoutRequest },
                                    "$(B:R)"
                                ),
                                !isPreselectedAny ? h(
                                    "button",
                                    { key: "i", styles: buttonStyles, lid: sourceLayoutRowIdString, onclick: propertyBar.deleteLayoutBaseClickHandler },
                                    "X"
                                ) : h(
                                    "button",
                                    { disabled: true, key: "i0", styles: buttonStyles, lid: sourceLayoutRowIdString, onclick: propertyBar.deleteLayoutBaseClickHandler },
                                    "X"
                                ),
                                !isPreselectedAny && sortedBoxes.length > 0 ? h(
                                    "button",
                                    { key: "j", styles: buttonStyles, lid: sourceLayoutRowIdString, onclick: propertyBar.deleteBelowLayoutBaseClickHandler },
                                    "CLR"
                                ) : h(
                                    "button",
                                    { disabled: true, key: "j0", styles: buttonStyles, lid: sourceLayoutRowIdString, onclick: propertyBar.deleteBelowLayoutBaseClickHandler },
                                    "CLR"
                                )
                            ),
                            h(
                                "div",
                                { key: "0", styles: divSubBoxStyles },
                                renderedLayoutBoxes.results.map(function (r) {
                                    return r.renderMaquette();
                                })
                            )
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        sourceLayoutRowIdString = source.LayoutBaseId.toString();
                        unsortedBoxes = source.AllBoxesBelowRow.filter(function (b) {
                            return b.PlacedBoxInBoxId === undefined;
                        });
                        sortedBoxes = unsortedBoxes.sort(function (boxA, boxB) {
                            if (boxA.LayoutSortOrderKey < boxB.LayoutSortOrderKey) {
                                return -1;
                            } else if (boxA.LayoutSortOrderKey == boxB.LayoutSortOrderKey) {
                                return 0;
                            } else {
                                return 1;
                            }
                        });
                        renderedLayoutBoxes.map(sortedBoxes);
                        styleMoleculeId = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                            return m.StyleForLayoutId == source.LayoutBaseId;
                        }).StyleMoleculeId;
                        styleMoleculeIdString = styleMoleculeId.toString();
                        layoutRowStyleClass = "s" + styleMoleculeId;
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.renderLayoutBoxArray = function (propertyBar) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.LayoutBaseId;
            }, function createSectionTarget(source) {
                var sourceLayoutBoxIdString = source.LayoutBaseId.toString();
                var renderedLayoutAtoms = propertyBar.renderLayoutAtomArray(propertyBar);
                var renderedLayoutBoxes = propertyBar.renderLayoutBoxArray(propertyBar);
                var styleMoleculeId = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                    return m.StyleForLayoutId == source.LayoutBaseId;
                }).StyleMoleculeId;
                var styleMoleculeIdString = styleMoleculeId.toString();
                var layoutBoxStyleClass = "s" + styleMoleculeId;
                var deepnessPadding = "";
                var calculatedBackgroundColor = "";
                var calculatedColor = "";
                var calculatedBorderColor = "";
                var hasSubAtoms = false;
                var isOddLevel = false;
                deepnessPadding = (source.Level + 1) * 15 + "px";
                calculatedBackgroundColor = propertyBar.calculateBackgroundColorForLevel(source.Level);
                calculatedColor = propertyBar.calculateColorForLevel(source.Level);
                calculatedBorderColor = "solid 1px " + propertyBar.calculateBackgroundColorForLevel(source.Level + 1);
                hasSubAtoms = source.PlacedInBoxAtoms.length > 0;
                isOddLevel = source.Level % 2 != 0;
                return {
                    renderMaquette: function renderMaquette() {
                        var renderedBoxContent = currentApp.pagePreview.mapAndRenderLayoutBoxContent(source, source.PlacedInBoxAtoms, renderedLayoutAtoms, source.PlacedInBoxBoxes, renderedLayoutBoxes);
                        var treeBoxStyles = {
                            "display": "flex",
                            "flex-direction": "row",
                            "flex-wrap": "wrap",
                            "margin-right": "-15px",
                            "background-color": "rgb(222, 222, 222)",
                            "border-bottom": hasSubAtoms ? calculatedBorderColor : undefined,
                            "border-left": "solid 1px black",
                            "zoom": "1.05"
                        };
                        var boxCaptionStyles = {
                            "padding-left": "15px",
                            "padding-right": "15px",
                            "width": "auto",
                            "flex": "0 0 auto",
                            "margin": "0",
                            "text-decoration": "underline",
                            "color": calculatedColor,
                            "background-color": calculatedBackgroundColor,
                            "font-stretch": isOddLevel ? "extra-condensed" : undefined
                        };
                        var divButtonStyles = {
                            "display": "flex",
                            "flex-direction": "row",
                            "flex-wrap": "nowrap",
                            "margin-left": "-15px",
                            "margin-right": "-15px"
                        };
                        var buttonStyles = {
                            "font-size": "10px",
                            "color": calculatedColor,
                            "background-color": calculatedBackgroundColor,
                            "width": "auto",
                            "flex": "0 0 auto",
                            "outline": undefined,
                            "outline-offset": undefined
                        };
                        var buttonDisabledStyles = {
                            "font-size": "10px",
                            "background-color": "rgb(242,242,242)",
                            "color": calculatedColor,
                            "width": "auto",
                            "flex": "0 0 auto",
                            "outline": undefined,
                            "outline-offset": undefined
                        };
                        var isPreselectedAny = currentApp.state.preselectedLayoutBaseId != 0;
                        var isPreselectedCurrent = isPreselectedAny && currentApp.state.preselectedLayoutBaseId == source.LayoutBaseId;
                        var buttonStylesTarget = {
                            "font-size": "10px",
                            "color": !isPreselectedAny || isPreselectedCurrent ? calculatedBackgroundColor : calculatedColor,
                            "background-color": calculatedBackgroundColor,
                            "width": "auto",
                            "flex": "0 0 auto",
                            "outline": !isPreselectedAny || isPreselectedCurrent ? undefined : "solid 4px rgb(200,0,0)",
                            "outline-offset": !isPreselectedAny || isPreselectedCurrent ? undefined : "-4px"
                        };
                        var buttonStylesPreselectAny = {
                            "font-size": "10px",
                            "color": isPreselectedCurrent ? calculatedBackgroundColor : isPreselectedAny ? calculatedBackgroundColor : calculatedColor,
                            "background-color": isPreselectedCurrent ? "rgb(200,0,0)" : calculatedBackgroundColor,
                            "width": "auto",
                            "flex": "0 0 auto",
                            "outline": isPreselectedCurrent || isPreselectedAny ? undefined : "solid 1px rgb(200,0,0)",
                            "outline-offset": isPreselectedCurrent || isPreselectedAny ? undefined : "-1px"
                        };
                        var divSubTreeStyles = {
                            "flex-basis": "100%",
                            "width": "100%",
                            "max-width": "100%",
                            "padding-left": "15px",
                            "padding-right": "15px",
                            "background-color": calculatedBackgroundColor
                        };
                        return h(
                            "div",
                            { key: sourceLayoutBoxIdString, styles: treeBoxStyles },
                            h(
                                "div",
                                { key: "0", styles: divSubTreeStyles, lid: sourceLayoutBoxIdString, onmouseenter: propertyBar.layoutBaseMouseEnterHandler, onmouseleave: propertyBar.layoutBaseMouseLeaveHandler },
                                h(
                                    "div",
                                    { key: "-2", styles: divButtonStyles },
                                    h(
                                        "p",
                                        { key: "-1", styles: boxCaptionStyles },
                                        "BOX",
                                        !isOddLevel ? " |" : undefined
                                    ),
                                    h(
                                        "button",
                                        { key: "a", styles: buttonStyles, lid: sourceLayoutBoxIdString, onclick: propertyBar.insertLayoutAtomIntoBoxClickHandler },
                                        "+(A)"
                                    ),
                                    h(
                                        "button",
                                        { key: "b", styles: buttonStyles, lid: sourceLayoutBoxIdString, onclick: propertyBar.insertLayoutBoxIntoBoxClickHandler },
                                        "+(B)"
                                    ),
                                    h(
                                        "button",
                                        { key: "c", styles: buttonStyles, lid: sourceLayoutBoxIdString, onclick: propertyBar.selectLayoutBaseClickHandler },
                                        "\u2026"
                                    ),
                                    h(
                                        "button",
                                        { key: "d", styles: buttonStyles, lid: sourceLayoutBoxIdString, onclick: propertyBar.highlightLayoutBaseClickHandler },
                                        "?"
                                    ),
                                    h(
                                        "button",
                                        { key: "e", styles: buttonStyles, mid: styleMoleculeIdString, onclick: propertyBar.selectStyleMoleculeClickHandler },
                                        "S\u2026"
                                    ),
                                    h(
                                        "button",
                                        { key: "f", styles: buttonStyles, lid: sourceLayoutBoxIdString, onclick: propertyBar.saveLayoutMoleculeClickHandler },
                                        "!!!"
                                    ),
                                    isPreselectedCurrent || !isPreselectedAny ? h(
                                        "button",
                                        { key: "g", styles: buttonStylesPreselectAny, lid: sourceLayoutBoxIdString, onclick: propertyBar.moveLayoutBoxIntoRowClickHandler },
                                        "IN(R)"
                                    ) : h(
                                        "button",
                                        { disabled: true, key: "g0", styles: buttonStylesPreselectAny, lid: sourceLayoutBoxIdString, onclick: propertyBar.moveLayoutBoxIntoRowClickHandler },
                                        "IN(R)"
                                    ),
                                    isPreselectedCurrent || !isPreselectedAny ? h(
                                        "button",
                                        { key: "h", styles: buttonStylesPreselectAny, lid: sourceLayoutBoxIdString, onclick: propertyBar.moveLayoutBoxIntoBoxClickHandler },
                                        "IN(B)"
                                    ) : h(
                                        "button",
                                        { disabled: true, key: "h0", styles: buttonStylesPreselectAny, lid: sourceLayoutBoxIdString, onclick: propertyBar.moveLayoutBoxIntoBoxClickHandler },
                                        "IN(B)"
                                    ),
                                    isPreselectedCurrent || !isPreselectedAny ? h(
                                        "button",
                                        { key: "i", styles: buttonStylesPreselectAny, lid: sourceLayoutBoxIdString, onclick: propertyBar.moveLayoutBoxBeforeBoxClickHandler },
                                        "MV(A:B)"
                                    ) : h(
                                        "button",
                                        { disabled: true, key: "i0", styles: buttonStylesPreselectAny, lid: sourceLayoutBoxIdString, onclick: propertyBar.moveLayoutBoxBeforeBoxClickHandler },
                                        "MV(A:B)"
                                    ),
                                    isPreselectedCurrent || !isPreselectedAny ? h(
                                        "button",
                                        { key: "j", styles: buttonStylesPreselectAny, lid: sourceLayoutBoxIdString, onclick: propertyBar.syncLayoutBaseStylesClickHandler },
                                        "ST(B)"
                                    ) : h(
                                        "button",
                                        { disabled: true, key: "j0", styles: buttonStylesPreselectAny, lid: sourceLayoutBoxIdString, onclick: propertyBar.syncLayoutBaseStylesClickHandler },
                                        "ST(B)"
                                    ),
                                    isPreselectedAny && !isPreselectedCurrent ? h(
                                        "button",
                                        { key: "k", styles: buttonStylesTarget, lid: sourceLayoutBoxIdString, onclick: propertyBar.finalizeLayoutRequest },
                                        "$(A:B)"
                                    ) : h(
                                        "button",
                                        { disabled: true, key: "k0", styles: buttonStylesTarget, lid: sourceLayoutBoxIdString, onclick: propertyBar.finalizeLayoutRequest },
                                        "$(A:B)"
                                    ),
                                    !isPreselectedAny ? h(
                                        "button",
                                        { key: "l", styles: buttonStyles, lid: sourceLayoutBoxIdString, onclick: propertyBar.deleteLayoutBaseClickHandler },
                                        "X"
                                    ) : h(
                                        "button",
                                        { disabled: true, key: "l0", styles: buttonStyles, lid: sourceLayoutBoxIdString, onclick: propertyBar.deleteLayoutBaseClickHandler },
                                        "X"
                                    ),
                                    !isPreselectedAny && renderedBoxContent.length > 0 ? h(
                                        "button",
                                        { key: "m", styles: buttonStyles, lid: sourceLayoutBoxIdString, onclick: propertyBar.deleteBelowLayoutBaseClickHandler },
                                        "CLR"
                                    ) : h(
                                        "button",
                                        { disabled: true, key: "m0", styles: buttonStyles, lid: sourceLayoutBoxIdString, onclick: propertyBar.deleteBelowLayoutBaseClickHandler },
                                        "CLR"
                                    )
                                ),
                                renderedBoxContent
                            )
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        sourceLayoutBoxIdString = source.LayoutBaseId.toString();
                        styleMoleculeId = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                            return m.StyleForLayoutId == source.LayoutBaseId;
                        }).StyleMoleculeId;
                        styleMoleculeIdString = styleMoleculeId.toString();
                        layoutBoxStyleClass = "s" + styleMoleculeId;
                        deepnessPadding = (source.Level + 1) * 15 + "px";
                        calculatedBackgroundColor = propertyBar.calculateBackgroundColorForLevel(source.Level);
                        calculatedColor = propertyBar.calculateColorForLevel(source.Level);
                        calculatedBorderColor = "solid 1px " + propertyBar.calculateBackgroundColorForLevel(source.Level + 1);
                        hasSubAtoms = source.PlacedInBoxAtoms.length > 0;
                        isOddLevel = source.Level % 2 != 0;
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.calculateColorForLevel = function (level) {
            level = level < 0 ? 0 : level;
            var colorValue = level > 2 ? 222 : 78 + level * 12;
            return "rgb(" + colorValue + "," + colorValue + "," + colorValue + ")";
        };
        this.calculateBackgroundColorForLevel = function (level) {
            level = level < 0 ? 0 : level;
            var colorValue = 200 - level * 22;
            colorValue = colorValue < 0 ? 0 : colorValue;
            return "rgb(" + colorValue + "," + colorValue + "," + colorValue + ")";
        };
        this.renderLayoutAtomArray = function (propertyBar) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.LayoutBaseId;
            }, function createSectionTarget(source) {
                var sourceLayoutAtomIdString = source.LayoutBaseId.toString();
                var sourceContentAtomIdString = source.HostedContentAtom.ContentAtomId.toString();
                var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                    return m.StyleForLayoutId == source.LayoutBaseId;
                });
                var styleMoleculeId = styleMolecule.StyleMoleculeId;
                var styleMoleculeIdString = styleMoleculeId.toString();
                var layoutAtomStyleClass = "s" + styleMoleculeIdString;
                var calculatedPaddingPx = (propertyBar.viewModel.deepestLevelActiveView + 1 - source.Level) * 15;
                var calculatedMargin = "";
                var calculatedColor = "";
                var calculatedBackgroundColor = "";
                calculatedMargin = source.Level * 15 + 15 + "px";
                calculatedColor = propertyBar.calculateColorForLevel(source.Level);
                calculatedBackgroundColor = propertyBar.calculateBackgroundColorForLevel(source.Level);
                var hostedContentAtom = currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (c) {
                    return c.ContentAtomId == source.HostedContentAtom.ContentAtomId;
                });
                return {
                    renderMaquette: function renderMaquette() {
                        var isRenderedAtomVisible = currentApp.pagePreview.visibleLayoutAtomKeys.findIndex(function (k) {
                            return k === sourceLayoutAtomIdString;
                        }) != -1;
                        var isRenderedAtomHovered = currentApp.state.hoveredPagePreviewLayoutBaseId == source.LayoutBaseId;
                        var divAtomStyles = {
                            "display": "flex",
                            "flex-direction": "row",
                            "flex-wrap": "nowrap",
                            "margin-right": "-15px",
                            "border-left": "solid 1px black"
                        };
                        var atomCaptionStyles = {
                            "text-decoration": "underline",
                            "flex": "0 0 auto",
                            "width": "auto",
                            "margin-left": "15px",
                            "padding-left": (calculatedPaddingPx + (isRenderedAtomVisible ? -1 : 0)).toString() + "px",
                            "padding-right": "15px",
                            "margin": "0",
                            "color": calculatedColor,
                            "background-color": calculatedBackgroundColor,
                            "font-size": undefined,
                            "min-width": undefined,
                            "border-left": isRenderedAtomHovered ? "solid 3px rgb(200,0,0)" : isRenderedAtomVisible ? "dashed 1px rgb(200,0,0)" : undefined
                        };
                        var inputStyles = {
                            "text-decoration": undefined,
                            "flex": "0 0 auto",
                            "width": "auto",
                            "margin-left": "15px",
                            "padding-left": undefined,
                            "padding-right": "15px",
                            "margin": "0",
                            "color": undefined,
                            "background-color": undefined,
                            "font-size": "0.8rem",
                            "min-width": "200px"
                        };
                        var buttonStyles = {
                            "font-size": "10px",
                            "color": calculatedColor,
                            "background-color": calculatedBackgroundColor,
                            "width": "auto",
                            "flex": "0 0 auto",
                            "outline": undefined,
                            "outline-offset": undefined
                        };
                        var isPreselectedAny = currentApp.state.preselectedLayoutBaseId != 0;
                        var isPreselectedCurrent = isPreselectedAny && currentApp.state.preselectedLayoutBaseId == source.LayoutBaseId;
                        var buttonStylesTarget = {
                            "font-size": "10px",
                            "color": !isPreselectedAny || isPreselectedCurrent ? calculatedBackgroundColor : calculatedColor,
                            "background-color": calculatedBackgroundColor,
                            "width": "auto",
                            "flex": "0 0 auto",
                            "outline": !isPreselectedAny || isPreselectedCurrent ? undefined : "solid 4px rgb(200,0,0)",
                            "outline-offset": !isPreselectedAny || isPreselectedCurrent ? undefined : "-4px"
                        };
                        var buttonStylesPreselectAny = {
                            "font-size": "10px",
                            "color": isPreselectedCurrent ? calculatedBackgroundColor : isPreselectedAny ? calculatedBackgroundColor : calculatedColor,
                            "background-color": isPreselectedCurrent ? "rgb(200,0,0)" : calculatedBackgroundColor,
                            "width": "auto",
                            "flex": "0 0 auto",
                            "outline": isPreselectedCurrent || isPreselectedAny ? undefined : "solid 1px rgb(200,0,0)",
                            "outline-offset": isPreselectedCurrent || isPreselectedAny ? undefined : "-1px"
                        };
                        var description = "";
                        if (hostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Text && hostedContentAtom.TextContent !== undefined) {
                            description = hostedContentAtom.TextContent.length > 20 ? hostedContentAtom.TextContent.substring(0, 20) + "..." : hostedContentAtom.TextContent;
                        } else if (hostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Link && hostedContentAtom.Url !== undefined) {
                            description = hostedContentAtom.Url.length > 20 ? hostedContentAtom.Url.substring(0, 20) + "..." : hostedContentAtom.Url;
                        } else {
                            console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                            return undefined;
                        }
                        var renderedInputForContent = undefined;
                        var isEditedLayoutAtomId = source.LayoutBaseId == propertyBar.viewModel.editedLayoutAtomId;
                        if (isEditedLayoutAtomId) {
                            renderedInputForContent = h("input", { key: "inp" + sourceLayoutAtomIdString, "class": layoutAtomStyleClass, value: propertyBar.viewModel.tempContent, oninput: propertyBar.contentAtomInputHandler, onblur: propertyBar.contentAtomLostFocusHandler, onkeydown: propertyBar.contentAtomKeyDownHandler, styles: inputStyles, afterCreate: propertyBar.contentAtomAfterCreateHandler, cid: sourceContentAtomIdString });
                        }
                        return h(
                            "div",
                            { key: sourceLayoutAtomIdString, lid: sourceLayoutAtomIdString, styles: divAtomStyles, afterCreate: propertyBar.layoutAtomAfterCreateHandler, onmouseenter: propertyBar.layoutBaseMouseEnterHandler, onmouseleave: propertyBar.layoutBaseMouseLeaveHandler },
                            !isEditedLayoutAtomId ? h(
                                "p",
                                { key: "0", styles: atomCaptionStyles, aid: sourceLayoutAtomIdString, cid: sourceContentAtomIdString, onclick: propertyBar.layoutAtomClickHandler },
                                h(
                                    "small",
                                    { key: "0", aid: sourceLayoutAtomIdString, cid: sourceContentAtomIdString },
                                    description,
                                    "ATOM"
                                )
                            ) : renderedInputForContent,
                            h(
                                "button",
                                { key: "a", styles: buttonStyles, lid: sourceLayoutAtomIdString, onclick: propertyBar.selectLayoutBaseClickHandler },
                                "\u2026"
                            ),
                            h(
                                "button",
                                { key: "b", styles: buttonStyles, lid: sourceLayoutAtomIdString, onclick: propertyBar.highlightLayoutBaseClickHandler },
                                "?"
                            ),
                            h(
                                "button",
                                { key: "c", styles: buttonStyles, mid: styleMoleculeIdString, onclick: propertyBar.selectStyleMoleculeClickHandler },
                                "S\u2026"
                            ),
                            isPreselectedCurrent || !isPreselectedAny ? h(
                                "button",
                                { key: "d", styles: buttonStylesPreselectAny, lid: sourceLayoutAtomIdString, onclick: propertyBar.moveLayoutAtomIntoBoxClickHandler },
                                "IN"
                            ) : h(
                                "button",
                                { disabled: true, key: "d0", styles: buttonStylesPreselectAny, lid: sourceLayoutAtomIdString, onclick: propertyBar.moveLayoutAtomIntoBoxClickHandler },
                                "IN"
                            ),
                            isPreselectedCurrent || !isPreselectedAny ? h(
                                "button",
                                { key: "e", styles: buttonStylesPreselectAny, lid: sourceLayoutAtomIdString, onclick: propertyBar.moveLayoutAtomBeforeAtomClickHandler },
                                "MV"
                            ) : h(
                                "button",
                                { disabled: true, key: "e0", styles: buttonStylesPreselectAny, lid: sourceLayoutAtomIdString, onclick: propertyBar.moveLayoutAtomBeforeAtomClickHandler },
                                "MV"
                            ),
                            isPreselectedCurrent || !isPreselectedAny ? h(
                                "button",
                                { key: "f", styles: buttonStylesPreselectAny, lid: sourceLayoutAtomIdString, onclick: propertyBar.syncLayoutBaseStylesClickHandler },
                                "ST(A)"
                            ) : h(
                                "button",
                                { disabled: true, key: "f0", styles: buttonStylesPreselectAny, lid: sourceLayoutAtomIdString, onclick: propertyBar.syncLayoutBaseStylesClickHandler },
                                "ST(A)"
                            ),
                            isPreselectedCurrent || !isPreselectedAny ? h(
                                "button",
                                { key: "g", styles: buttonStylesPreselectAny, lid: sourceLayoutAtomIdString, onclick: propertyBar.createBoxForAtomInPlaceClickHandler },
                                "+(B).IN"
                            ) : h(
                                "button",
                                { disabled: true, key: "g0", styles: buttonStylesPreselectAny, lid: sourceLayoutAtomIdString, onclick: propertyBar.createBoxForAtomInPlaceClickHandler },
                                "+(B).IN"
                            ),
                            isPreselectedAny && !isPreselectedCurrent ? h(
                                "button",
                                { key: "h", styles: buttonStylesTarget, lid: sourceLayoutAtomIdString, onclick: propertyBar.finalizeLayoutRequest },
                                "$(A:B)"
                            ) : h(
                                "button",
                                { disabled: true, key: "h0", styles: buttonStylesTarget, lid: sourceLayoutAtomIdString, onclick: propertyBar.finalizeLayoutRequest },
                                "$(A:B)"
                            ),
                            !isPreselectedAny ? h(
                                "button",
                                { key: "i", styles: buttonStyles, lid: sourceLayoutAtomIdString, onclick: propertyBar.deleteLayoutBaseClickHandler },
                                "X"
                            ) : h(
                                "button",
                                { disabled: true, key: "i0", styles: buttonStyles, lid: sourceLayoutAtomIdString, onclick: propertyBar.deleteLayoutBaseClickHandler },
                                "X"
                            )
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        sourceLayoutAtomIdString = source.LayoutBaseId.toString();
                        sourceContentAtomIdString = source.HostedContentAtom.ContentAtomId.toString();
                        styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                            return m.StyleForLayoutId == source.LayoutBaseId;
                        });
                        styleMoleculeId = styleMolecule.StyleMoleculeId;
                        styleMoleculeIdString = styleMoleculeId.toString();
                        layoutAtomStyleClass = "s" + styleMoleculeId;
                        calculatedPaddingPx = (propertyBar.viewModel.deepestLevelActiveView - source.Level) * 15 + 15;
                        calculatedColor = propertyBar.calculateColorForLevel(source.Level);
                        calculatedMargin = source.Level * 15 + 15 + "px";
                        calculatedBackgroundColor = propertyBar.calculateBackgroundColorForLevel(source.Level);
                        hostedContentAtom = currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (c) {
                            return c.ContentAtomId == source.HostedContentAtom.ContentAtomId;
                        });
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.contentAtomAfterCreateHandler = function (element, projectionOptions, vnodeSelector, properties, children) {
            var targetElement = element;
            targetElement.focus();
        };
        this.layoutBaseMouseEnterHandler = function (evt) {
            var targetElement = evt.target;
            currentApp.state.hoveredBoxTreeLayoutBaseId = CaliforniaApp_1.parseIntFromAttribute(targetElement, "lid");
        };
        this.layoutBaseMouseLeaveHandler = function (evt) {
            currentApp.state.hoveredBoxTreeLayoutBaseId = 0;
        };
        this.layoutAtomAfterCreateHandler = function (element, projectionOptions, vnodeSelector, properties, children) {
            if (_this.currentPropertyBar.propertyBarIndex == 0) {
                var targetElement = element;
                _this.currentPropertyBar._activeViewLayoutAtomDomNodeReferences[properties.key] = targetElement;
            }
        };
        this.resetContentAtomEditMode = function () {
            currentApp.pagePreview.resetEquationNumbersWhenModifying(false);
            _this.currentPropertyBar.viewModel.editedLayoutAtomId = 0;
            _this.currentPropertyBar.viewModel.tempContent = "";
            _this.currentPropertyBar.viewModel.tempOriginalContent = "";
        };
        this.contentAtomLostFocusHandler = function (evt) {
            _this.currentPropertyBar.updateContentAtom(CaliforniaApp_1.parseIntFromAttribute(evt.target, "cid"));
        };
        this.updateContentAtom = function (contentAtomId) {
            if (_this.currentPropertyBar.viewModel.editedLayoutAtomId != 0) {
                if (_this.currentPropertyBar.viewModel.tempContent !== _this.currentPropertyBar.viewModel.tempOriginalContent) {
                    if (_this.currentPropertyBar.viewModel.tempContent !== "") {
                        var contentAtom = currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (a) {
                            return a.InstancedOnLayoutId == _this.currentPropertyBar.viewModel.editedLayoutAtomId;
                        });
                        if (contentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Text) {
                            contentAtom.TextContent = _this.currentPropertyBar.viewModel.tempContent;
                        } else if (contentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Link) {
                            contentAtom.Url = _this.currentPropertyBar.viewModel.tempContent;
                        } else {
                            console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                            return;
                        }
                        currentApp.state.currentReadyState = ClientState_1.ReadyState.Pending;
                        currentApp.controller.UpdateTextContentAtomJson(contentAtomId, _this.currentPropertyBar.viewModel.tempContent).done(function (data) {
                            currentApp.router.updateData(data);
                        }).always(function (data) {
                            return currentApp.state.currentReadyState = ClientState_1.ReadyState.Ok;
                        });
                    } else {
                        currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (c) {
                            return c.InstancedOnLayoutId == _this.currentPropertyBar.viewModel.editedLayoutAtomId;
                        }).TextContent = _this.currentPropertyBar.viewModel.tempOriginalContent;
                    }
                }
            }
            _this.currentPropertyBar.resetContentAtomEditMode();
        };
        this.contentAtomKeyDownHandler = function (evt) {
            if (evt.keyCode == 13) {
                evt.preventDefault();
                evt.target.blur();
            } else if (evt.keyCode == 27) {
                evt.preventDefault();
                currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (c) {
                    return c.InstancedOnLayoutId == _this.currentPropertyBar.viewModel.editedLayoutAtomId;
                }).TextContent = _this.currentPropertyBar.viewModel.tempOriginalContent;
                _this.currentPropertyBar.resetContentAtomEditMode();
                evt.target.blur();
            } else if (evt.keyCode == undefined) {
                evt.preventDefault();
            }
        };
        this.contentAtomInputHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempContent = evt.target.value;
            currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (c) {
                return c.InstancedOnLayoutId == _this.currentPropertyBar.viewModel.editedLayoutAtomId;
            }).TextContent = _this.currentPropertyBar.viewModel.tempContent;
        };
        this.layoutAtomClickHandler = function (evt) {
            evt.preventDefault();
            if (currentApp.state.currentReadyState !== ClientState_1.ReadyState.Ok) {
                console.log("pending...");
                return;
            }
            if (currentApp.state.currentSelectionMode === ClientState_1.SelectionMode.Content) {
                var contentAtomId_1 = CaliforniaApp_1.parseIntFromAttribute(evt.target, "cid");
                var layoutAtomId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "aid");
                var hostedContentAtom = currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (c) {
                    return c.ContentAtomId == contentAtomId_1;
                });
                _this.currentPropertyBar.viewModel.tempContent = "";
                if (hostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Text) {
                    _this.currentPropertyBar.viewModel.tempContent = hostedContentAtom.TextContent;
                } else if (hostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Link) {
                    _this.currentPropertyBar.viewModel.tempContent = hostedContentAtom.Url;
                } else {
                    console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                    return;
                }
                _this.currentPropertyBar.viewModel.tempOriginalContent = _this.currentPropertyBar.viewModel.tempContent;
                _this.currentPropertyBar.viewModel.editedLayoutAtomId = layoutAtomId;
            } else {}
        };
        this.renderStateModifierSelectors = function () {
            var stateModifierGroupStyles = {
                "display": "flex",
                "flex-flow": "row nowrap"
            };
            var stateModifiers = [];
            var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                return m.StyleMoleculeId == _this.currentPropertyBar.viewModel.selectedStyleMoleculeId;
            });
            var _loop_1 = function _loop_1(i) {
                var modifier = styleMolecule.MappedStyleAtoms[i].StateModifier;
                if (modifier === undefined) {
                    modifier = "";
                }
                if (stateModifiers.findIndex(function (s) {
                    return s === modifier;
                }) == -1) {
                    stateModifiers.push(modifier);
                }
            };
            for (var i = 0; i < styleMolecule.MappedStyleAtoms.length; i++) {
                _loop_1(i);
            }
            var renderedModifiers = [];
            for (var i = 0; i < stateModifiers.length; i++) {
                var modifier = stateModifiers[i];
                var modifierButtonStyles = {
                    "flex": "0 0 auto",
                    "background-color": modifier == _this.currentPropertyBar.viewModel.selectedStateModifier ? "red" : undefined
                };
                renderedModifiers.push(h(
                    "button",
                    { key: modifier, role: "button", mid: modifier, onclick: _this.currentPropertyBar.stateModifierClickHandler, styles: modifierButtonStyles },
                    modifier
                ));
            }
            return h(
                "div",
                { key: "-2", styles: stateModifierGroupStyles },
                renderedModifiers
            );
        };
        this.stateModifierClickHandler = function (evt) {
            var selectedStateModifier = CaliforniaApp_1.parseStringFromAttribute(evt.target, "mid");
            if (selectedStateModifier === _this.currentPropertyBar.viewModel.selectedStateModifier) {
                _this.currentPropertyBar.viewModel.selectedStateModifier = "";
            } else {
                _this.currentPropertyBar.viewModel.selectedStateModifier = selectedStateModifier;
            }
        };
        this.renderResponsiveDeviceSelectors = function () {
            var responsiveGroupStyles = {
                "display": "flex",
                "flex-flow": "row wrap"
            };
            return h(
                "div",
                { key: "-3", styles: responsiveGroupStyles },
                currentApp.clientData.CaliforniaProject.ResponsiveDevices !== undefined ? currentApp.clientData.CaliforniaProject.ResponsiveDevices.map(function (r) {
                    var responsiveButtonStyles = {
                        "flex": "0 0 auto",
                        "background-color": r.ResponsiveDeviceId == _this.currentPropertyBar.viewModel.selectedResponsiveDeviceId ? "red" : undefined
                    };
                    var responsiveDeviceIdString = r.ResponsiveDeviceId.toString();
                    return h(
                        "button",
                        { key: responsiveDeviceIdString, role: "button", rid: responsiveDeviceIdString, onclick: _this.currentPropertyBar.selectResponsiveDeviceClickHandler, styles: responsiveButtonStyles },
                        r.NameShort
                    );
                }) : undefined
            );
        };
        this.selectResponsiveDeviceClickHandler = function (evt) {
            var selectedResponsiveId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "rid");
            if (_this.currentPropertyBar.viewModel.selectedResponsiveDeviceId == selectedResponsiveId) {
                _this.currentPropertyBar.viewModel.selectedResponsiveDeviceId = currentApp.state.noneResponsiveDeviceId;
            } else {
                _this.currentPropertyBar.viewModel.selectedResponsiveDeviceId = selectedResponsiveId;
            }
        };
        this.renderStyleAtomControls = function () {
            return h(
                "div",
                { key: "-1" },
                h(
                    "select",
                    { key: "0", onchange: _this.currentPropertyBar.styleAtomTypeChangedHandler },
                    CaliforniaApp_1.getArrayForEnum(CaliforniaGenerated_1.StyleAtomType).map(function (type, index) {
                        var isSelected = index === _this.currentPropertyBar.viewModel.selectedStyleAtomType;
                        return isSelected ? h(
                            "option",
                            { selected: true, key: index, value: index.toString() },
                            type
                        ) : h(
                            "option",
                            { key: index, value: index.toString() },
                            type
                        );
                    })
                ),
                h("input", { key: "-1", placeholder: "optional :hover,:before,...", value: _this.currentPropertyBar.viewModel.tempPseudoSelector, oninput: _this.currentPropertyBar.pseudoSelectorInputHandler }),
                h(
                    "button",
                    { key: "a", role: "button", onclick: _this.currentPropertyBar.createStyleAtomForMoleculeClickHandler },
                    "+"
                )
            );
        };
        this.pseudoSelectorInputHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempPseudoSelector = evt.target.value;
        };
        this.styleAtomTypeChangedHandler = function (evt) {
            var targetSelect = evt.target;
            var parsedStyleAtomType = undefined;
            if (targetSelect.selectedIndex < targetSelect.childElementCount) {
                var selectOptionElement = targetSelect.options[targetSelect.selectedIndex];
                parsedStyleAtomType = parseInt(selectOptionElement.value);
            }
            if (parsedStyleAtomType !== undefined) {
                _this.currentPropertyBar.viewModel.selectedStyleAtomType = parsedStyleAtomType;
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
        };
        this.createStyleAtomForMoleculeClickHandler = function (evt) {
            if (_this.currentPropertyBar.viewModel.tempPseudoSelector !== "") {
                _this.currentPropertyBar.viewModel.selectedStateModifier = _this.currentPropertyBar.viewModel.tempPseudoSelector;
            }
            currentApp.controller.CreateStyleAtomForMoleculeJson(_this.currentPropertyBar.viewModel.selectedStyleMoleculeId, _this.currentPropertyBar.viewModel.selectedStyleAtomType, _this.currentPropertyBar.viewModel.selectedResponsiveDeviceId, _this.currentPropertyBar.viewModel.selectedStateModifier).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.viewModel.tempPseudoSelector = "";
        };
        this.renderStyleQuantumControls = function () {
            return h(
                "div",
                { key: "0" },
                h("input", { key: "-3", value: _this.currentPropertyBar.viewModel.tempQuantumName, oninput: _this.currentPropertyBar.quantumNameInputHandler }),
                h("input", { key: "-2", value: _this.currentPropertyBar.viewModel.tempCssPropertyName, oninput: _this.currentPropertyBar.cssPropertyNameInputHandler }),
                h("input", { key: "-1", value: _this.currentPropertyBar.viewModel.tempCssValue, oninput: _this.currentPropertyBar.cssValueInputHandler }),
                h(
                    "button",
                    { key: "a", role: "button", onclick: _this.currentPropertyBar.createStyleQuantumClickHandler },
                    "\u2714"
                ),
                h(
                    "button",
                    { key: "b", role: "button", onclick: _this.currentPropertyBar.showAllCssPropertiesForQuantumClickHandler },
                    "?"
                )
            );
        };
        this.showAllCssPropertiesForQuantumClickHandler = function (evt) {
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.AllCssPropertiesForQuantum);
        };
        this.createStyleQuantumClickHandler = function (evt) {
            currentApp.controller.CreateStyleQuantumJson(currentApp.clientData.CaliforniaProject.CaliforniaProjectId, _this.currentPropertyBar.viewModel.tempQuantumName, _this.currentPropertyBar.viewModel.tempCssPropertyName, _this.currentPropertyBar.viewModel.tempCssValue).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.resetAddQuantumState();
        };
        this.resetAddQuantumState = function () {
            _this.currentPropertyBar.viewModel.tempQuantumName = "Quantum";
            _this.currentPropertyBar.viewModel.tempCssPropertyName = "";
            _this.currentPropertyBar.viewModel.tempCssValue = "";
        };
        this.quantumNameInputHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempQuantumName = evt.target.value;
        };
        this.renderStyleValueArray = function (propertyBar) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.StyleValueId;
            }, function createSectionTarget(source) {
                var sourceIdString = source.StyleValueId.toString();
                var styleValueButtonStyle = {
                    "flex": "0 0 auto",
                    "width": "auto",
                    "height": "1rem"
                };
                var styleValueTextStyle = {
                    "outline": source.CssValue === "" ? "solid white 1px" : undefined,
                    "outline-offset": source.CssValue === "" ? "-1px" : undefined,
                    "flex": "0 0 auto",
                    "width": "auto",
                    "margin": "0"
                };
                return {
                    renderMaquette: function renderMaquette() {
                        return h(
                            "div",
                            { key: sourceIdString, exitAnimation: propertyBar.styleElementExitAnimation, styles: { "display": "flex", "flex-flow": "row nowrap" } },
                            h(
                                "p",
                                { styles: styleValueTextStyle },
                                source.CssProperty,
                                ": ",
                                source.CssValue
                            ),
                            h(
                                "button",
                                { key: "a", role: "button", vid: sourceIdString, onclick: propertyBar.deleteStyleValueClickHandler, styles: styleValueButtonStyle },
                                "X"
                            ),
                            h(
                                "button",
                                { key: "b", role: "button", aid: source.StyleAtomId.toString(), vid: sourceIdString, onclick: propertyBar.updateCssValueClickHandler, styles: styleValueButtonStyle },
                                "Edit"
                            )
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        sourceIdString = source.StyleValueId.toString();
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.renderStyleQuantumArrayForStyleAtom = function () {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.StyleQuantumId;
            }, function createSectionTarget(source) {
                var sourceIdString = source.StyleQuantumId.toString();
                return {
                    renderMaquette: function renderMaquette() {
                        return h(
                            "div",
                            { key: sourceIdString },
                            h(
                                "p",
                                { styles: { "margin": "0" } },
                                source.Name,
                                ": ",
                                source.CssProperty,
                                " (",
                                source.CssValue,
                                ")"
                            )
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        sourceIdString = source.StyleQuantumId.toString();
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.renderStyleAtomArray = function (propertyBar) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.StyleAtomId;
            }, function createSectionTarget(source) {
                var styleAtomIdString = source.StyleAtomId.toString();
                var appliedValuesMap = propertyBar.renderStyleValueArray(propertyBar);
                var appliedQuantumsMap = propertyBar.renderStyleQuantumArrayForStyleAtom();
                if (source.AppliedValues !== undefined) {
                    appliedValuesMap.map(source.AppliedValues);
                } else {
                    appliedValuesMap.map([]);
                }
                if (source.MappedQuantums !== undefined) {
                    appliedQuantumsMap.map(source.MappedQuantums.map(function (qm) {
                        return qm.StyleQuantum;
                    }));
                } else {
                    appliedQuantumsMap.map([]);
                }
                return {
                    renderMaquette: function renderMaquette() {
                        var isDisplayStyleAtom = true;
                        if (propertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.StyleMolecule) {
                            var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                                return m.StyleMoleculeId == propertyBar.viewModel.selectedStyleMoleculeId;
                            });
                            var targetMappingIndex = styleMolecule.MappedStyleAtoms.findIndex(function (m) {
                                return m.ResponsiveDeviceId == propertyBar.viewModel.selectedResponsiveDeviceId && m.StyleMoleculeAtomMappingId == source.MappedToMoleculeId && (m.StateModifier === undefined && propertyBar.viewModel.selectedStateModifier === "" || m.StateModifier === propertyBar.viewModel.selectedStateModifier);
                            });
                            isDisplayStyleAtom = targetMappingIndex != -1;
                        }
                        var divStyleAtomStyles = {
                            "display": !isDisplayStyleAtom ? "none" : undefined,
                            "width": "100%",
                            "height": "auto"
                        };
                        return h(
                            "div",
                            { key: styleAtomIdString, exitAnimation: propertyBar.styleElementExitAnimation, styles: divStyleAtomStyles },
                            h(
                                "p",
                                { key: "0", styles: { "margin": "0" } },
                                "(#",
                                styleAtomIdString,
                                ")",
                                source.Name,
                                ":"
                            ),
                            appliedValuesMap.results.map(function (r) {
                                return r.renderMaquette();
                            }),
                            h(
                                "button",
                                { key: "a", role: "button", aid: styleAtomIdString, onclick: propertyBar.createCssPropertyForAtomClickHandler },
                                "+"
                            ),
                            h(
                                "button",
                                { key: "b", role: "button", aid: styleAtomIdString, onclick: propertyBar.moveStyleAtomPopupClickHandler },
                                "=>"
                            ),
                            source.IsDeletable ? h(
                                "button",
                                { key: "b0", role: "button", aid: styleAtomIdString, onclick: propertyBar.deleteStyleAtomClickHandler },
                                "X"
                            ) : h(
                                "button",
                                { disabled: true, key: "b1", role: "button", aid: styleAtomIdString },
                                "X"
                            ),
                            source.MappedQuantums.length > 0 ? h(
                                "p",
                                { key: "-1" },
                                "quantums:"
                            ) : undefined,
                            " ",
                            appliedQuantumsMap.results.map(function (r) {
                                return r.renderMaquette();
                            })
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        appliedValuesMap.map(updatedSource.AppliedValues);
                        appliedQuantumsMap.map(updatedSource.MappedQuantums.map(function (qm) {
                            return qm.StyleQuantum;
                        }));
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.moveStyleAtomPopupClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.selectedStyleAtomIdForPopup = CaliforniaApp_1.parseIntFromAttribute(evt.target, "aid");
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.MoveStyleAtom);
        };
        this.createCssPropertyForAtomClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.selectedStyleAtomId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "aid");
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.AddCssProperty);
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.AllCssProperties);
        };
        this.deleteStyleAtomClickHandler = function (evt) {
            currentApp.controller.DeleteStyleAtomJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "aid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.updateCssValueClickHandler = function (evt) {
            var styleValueId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "vid");
            var styleAtomId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "aid");
            _this.currentPropertyBar.viewModel.selectedStyleValueId = styleValueId;
            _this.currentPropertyBar.viewModel.selectedStyleAtomId = styleAtomId;
            var targetStyleValue = currentApp.clientData.CaliforniaProject.StyleValues.find(function (val) {
                return val.StyleValueId == styleValueId;
            });
            _this.currentPropertyBar.viewModel.tempCssValue = targetStyleValue.CssValue;
            _this.currentPropertyBar.viewModel.tempCssPropertyName = targetStyleValue.CssProperty;
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.UpdateCssValue);
        };
        this.deleteStyleValueClickHandler = function (evt) {
            currentApp.controller.DeleteStyleValueJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "vid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.renderAddCssPropertyPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.AddCssProperty || _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.AllCssProperties;
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.AddCssProperty], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px" } },
                h(
                    "div",
                    { styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.saveCssPropertyForAtomClickHandler },
                        "\u2714"
                    ),
                    h(
                        "button",
                        { key: "b", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelAddCssPropertyForAtomClickHandler },
                        "x"
                    )
                ),
                h(
                    "div",
                    null,
                    h("input", { key: "-1", value: _this.currentPropertyBar.viewModel.tempCssPropertyName, oninput: _this.currentPropertyBar.cssPropertyNameInputHandler }),
                    h(
                        "button",
                        { key: "a", role: "button", onclick: _this.currentPropertyBar.showAllCssPropertiesClickHandler },
                        "?"
                    )
                )
            );
        };
        this.renderAllCssPropertiesForQuantumPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.AllCssPropertiesForQuantum;
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.AllCssPropertiesForQuantum], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px", "height": "300px", "overflow": "scroll" } },
                h(
                    "div",
                    { styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelUpdateCssPropertyForQuantumClickHandler },
                        "x"
                    )
                ),
                currentApp.clientData.AllCssProperties.map(function (prop) {
                    return h(
                        "div",
                        { key: prop },
                        prop,
                        h(
                            "button",
                            { key: "a", role: "button", cid: prop, onclick: _this.currentPropertyBar.setSelectedCssPropertyForQuantumClickHandler },
                            "\u2714"
                        )
                    );
                })
            );
        };
        this.setSelectedCssPropertyForQuantumClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCssPropertyName = CaliforniaApp_1.parseStringFromAttribute(evt.target, "cid");
            _this.currentPropertyBar.closePopup();
        };
        this.cancelUpdateCssPropertyForQuantumClickHandler = function (evt) {
            _this.currentPropertyBar.closePopup();
        };
        this.insertLayoutRowIntoViewPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.InsertLayoutRowIntoView;
            var instanceableLayoutRows = [];
            if (isPopupVisible) {
                var instanceableRowsView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (view) {
                    return view.IsInternal && view.Name === "[Internal] Instanceable Layout Rows";
                });
                instanceableLayoutRows.push.apply(instanceableLayoutRows, instanceableRowsView.PlacedLayoutRows);
                var userInstanceableRowsView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (view) {
                    return view.IsInternal && view.Name === "[Internal] User Layout Molecules";
                });
                for (var i = 1; i < userInstanceableRowsView.PlacedLayoutRows.length; i++) {
                    instanceableLayoutRows.push(userInstanceableRowsView.PlacedLayoutRows[i]);
                }
            }
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.InsertLayoutRowIntoView], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px", "height": "300px", "overflow": "scroll" } },
                h(
                    "div",
                    { styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelInsertLayoutRowIntoViewClickHandler },
                        "x"
                    )
                ),
                instanceableLayoutRows.map(function (prop) {
                    return h(
                        "div",
                        { key: prop.LayoutBaseId },
                        h(
                            "button",
                            { styles: { "width": "auto", "margin": "0" }, key: "a", lid: prop.LayoutBaseId.toString(), onclick: _this.currentPropertyBar.insertSelectedLayoutRowIntoViewClickHandler, onmouseenter: _this.currentPropertyBar.insertRowShowPreviewHandler, onmouseleave: _this.currentPropertyBar.insertRowHidePreviewHandler },
                            "\u2714"
                        ),
                        h(
                            "p",
                            { key: "0", styles: { "-webkit-user-select": "none", "width": "auto", "margin": "0", "float": "left" }, lid: prop.LayoutBaseId.toString(), ontouchstart: _this.currentPropertyBar.insertRowShowPreviewHandler, ontouchend: _this.currentPropertyBar.insertRowHidePreviewHandler },
                            prop.LayoutBaseId
                        )
                    );
                })
            );
        };
        this.insertSelectedLayoutRowIntoViewClickHandler = function (evt) {
            var layoutId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            currentApp.controller.CreateLayoutRowForViewJson(_this.currentPropertyBar.viewModel.selectedCaliforniaViewId, layoutId).done(function (data) {
                return currentApp.router.updateData(data);
            });
            currentApp.state.lastCommand = CaliforniaGenerated_1.CaliforniaEvent.CreateLayoutRowForView;
            currentApp.state.lastCaliforniaEventData = [_this.currentPropertyBar.viewModel.selectedCaliforniaViewId, layoutId];
            _this.currentPropertyBar.closePopup();
        };
        this.cancelInsertLayoutRowIntoViewClickHandler = function (evt) {
            _this.currentPropertyBar.closePopup();
        };
        this.insertLayoutAtomIntoBoxPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.InsertLayoutAtomIntoBox;
            var instanceableLayoutAtoms = [];
            if (isPopupVisible) {
                var instanceableAtomsView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (view) {
                    return view.IsInternal && view.Name === "[Internal] Instanceable Layout Atoms";
                });
                var atomContainerBox = instanceableAtomsView.PlacedLayoutRows[0].AllBoxesBelowRow.find(function (b) {
                    return b.PlacedInBoxAtoms.length > 0;
                });
                instanceableLayoutAtoms.push.apply(instanceableLayoutAtoms, atomContainerBox.PlacedInBoxAtoms);
            }
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.InsertLayoutAtomIntoBox], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px", "height": "300px", "overflow": "scroll" } },
                h(
                    "div",
                    { styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelInsertLayoutAtomIntoBoxClickHandler },
                        "x"
                    )
                ),
                instanceableLayoutAtoms.map(function (prop) {
                    var textPreview = "";
                    if (prop.HostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Text) {
                        textPreview = prop.HostedContentAtom.TextContent;
                    } else if (prop.HostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Link) {
                        textPreview = prop.HostedContentAtom.Url;
                    } else {
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                        return;
                    }
                    return h(
                        "div",
                        { key: prop.LayoutBaseId },
                        h(
                            "button",
                            { styles: { "width": "auto", "margin": "0" }, key: "a", lid: prop.LayoutBaseId.toString(), onclick: _this.currentPropertyBar.insertSelectedLayoutAtomIntoBoxClickHandler, onmouseenter: _this.currentPropertyBar.insertAtomShowPreviewHandler, onmouseleave: _this.currentPropertyBar.insertAtomHidePreviewHandler },
                            "\u2714"
                        ),
                        h(
                            "p",
                            { key: "0", styles: { "-webkit-user-select": "none", "width": "auto", "margin": "0", "float": "left" }, lid: prop.LayoutBaseId.toString(), ontouchstart: _this.currentPropertyBar.insertAtomShowPreviewHandler, ontouchend: _this.currentPropertyBar.insertAtomHidePreviewHandler },
                            prop.LayoutBaseId,
                            " ",
                            textPreview
                        )
                    );
                })
            );
        };
        this.insertSelectedLayoutAtomIntoBoxClickHandler = function (evt) {
            var targetBoxId = currentApp.state.selectedLayoutBaseId;
            currentApp.controller.CreateLayoutAtomForBoxJson(targetBoxId, CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid")).done(function (data) {
                currentApp.router.updateData(data);
                currentApp.projector.renderNow();
                var updatedSubAtoms = currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                    return l.LayoutBaseId == targetBoxId;
                }).PlacedInBoxAtoms;
                _this.currentPropertyBar.viewModel.editedLayoutAtomId = updatedSubAtoms[updatedSubAtoms.length - 1].LayoutBaseId;
            });
            _this.currentPropertyBar.closePopup();
        };
        this.cancelInsertLayoutAtomIntoBoxClickHandler = function (evt) {
            _this.currentPropertyBar.closePopup();
        };
        this.displayPopup = function (targetPosition, popupMode) {
            var popupElement = null;
            popupElement = document.getElementById(_this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[popupMode]);
            if (popupElement !== null) {
                _this.viewModel.currentPopupMode = popupMode;
                var displayPopup = new popperjs.default(targetPosition, popupElement, {
                    placement: 'bottom-end',
                    modifiers: {
                        preventOverflow: {
                            boundariesElement: document.body
                        }
                    }
                });
                currentApp.projector.renderNow();
                return;
            }
            console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
        };
        this.closePopup = function () {
            _this.viewModel.currentPopupMode = PropertyBarVM_1.PopupMode.None;
            _this.viewModel.currentSecondaryPopupMode = PropertyBarVM_1.PopupSecondaryMode.None;
        };
        this.insertLayoutBoxIntoBoxPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.SelectBox;
            var instanceableLayoutBoxes = [];
            if (isPopupVisible) {
                var instanceableRowsView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (view) {
                    return view.IsInternal && view.Name === "[Internal] Instanceable Layout Rows";
                });
                var allBoxes = instanceableRowsView.PlacedLayoutRows[0].AllBoxesBelowRow;
                var firstSubBox_1 = allBoxes.find(function (b) {
                    return b.PlacedBoxInBoxId === undefined;
                });
                var targetBox = allBoxes.find(function (b) {
                    return b.PlacedBoxInBoxId == firstSubBox_1.LayoutBaseId;
                });
                instanceableLayoutBoxes.push(targetBox);
                var userInstanceableView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (view) {
                    return view.IsInternal && view.Name === "[Internal] User Layout Molecules";
                });
                var userBoxes = userInstanceableView.PlacedLayoutRows[0].AllBoxesBelowRow.filter(function (b) {
                    return b.PlacedBoxInBoxId === undefined;
                });
                instanceableLayoutBoxes.push.apply(instanceableLayoutBoxes, userBoxes);
            }
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.SelectBox], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px", "height": "300px", "overflow": "scroll" } },
                h(
                    "div",
                    { styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelInsertLayoutBoxIntoBoxClickHandler },
                        "x"
                    )
                ),
                instanceableLayoutBoxes.map(function (prop) {
                    return h(
                        "div",
                        { key: prop.LayoutBaseId },
                        h(
                            "button",
                            { styles: { "width": "auto", "margin": "0" }, key: "a", role: "button", lid: prop.LayoutBaseId.toString(), onclick: _this.currentPropertyBar.insertSelectedLayoutBoxIntoBoxOrRowClickHandler, onmouseenter: _this.currentPropertyBar.insertBoxShowPreviewHandler, onmouseleave: _this.currentPropertyBar.insertBoxHidePreviewHandler },
                            "\u2714"
                        ),
                        h(
                            "p",
                            { key: "0", styles: { "-webkit-user-select": "none", "width": "auto", "margin": "0", "float": "left" }, lid: prop.LayoutBaseId.toString(), ontouchstart: _this.currentPropertyBar.insertBoxShowPreviewHandler, ontouchend: _this.currentPropertyBar.insertBoxHidePreviewHandler },
                            prop.LayoutBaseId
                        )
                    );
                })
            );
        };
        this.insertRowShowPreviewHandler = function (evt) {
            var targetElement = evt.target;
            var hoveredLayoutId = CaliforniaApp_1.parseIntFromAttribute(targetElement, "lid");
            currentApp.state.hoveredInsertLayoutBaseId = hoveredLayoutId;
            var tempRow = currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                return l.LayoutBaseId == hoveredLayoutId;
            });
            currentApp.state.backupSortOrder = tempRow.LayoutSortOrderKey;
            tempRow.LayoutSortOrderKey = exports.VERY_HIGH_VALUE;
            var californiaView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (v) {
                return v.CaliforniaViewId == _this.currentPropertyBar.viewModel.selectedCaliforniaViewId;
            });
            californiaView.PlacedLayoutRows.push(tempRow);
            currentApp.router.setActiveCaliforniaView(californiaView);
        };
        this.insertRowHidePreviewHandler = function (evt) {
            var californiaView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (v) {
                return v.CaliforniaViewId == _this.currentPropertyBar.viewModel.selectedCaliforniaViewId;
            });
            var tempRowIndex = californiaView.PlacedLayoutRows.findIndex(function (r) {
                return r.LayoutBaseId == currentApp.state.hoveredInsertLayoutBaseId;
            });
            if (tempRowIndex != -1) {
                var tempRow = californiaView.PlacedLayoutRows.splice(tempRowIndex, 1)[0];
                if (currentApp.state.backupSortOrder !== undefined) {
                    tempRow.LayoutSortOrderKey = currentApp.state.backupSortOrder;
                } else {
                    console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                }
                currentApp.state.backupSortOrder = undefined;
                currentApp.state.hoveredInsertLayoutBaseId = 0;
                currentApp.router.setActiveCaliforniaView(californiaView);
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
        };
        this.insertBoxShowPreviewHandler = function (evt) {
            var targetElement = evt.target;
            var hoveredLayoutId = CaliforniaApp_1.parseIntFromAttribute(targetElement, "lid");
            currentApp.state.hoveredInsertLayoutBaseId = hoveredLayoutId;
            var tempBox = currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                return l.LayoutBaseId == hoveredLayoutId;
            });
            currentApp.state.backupSortOrder = tempBox.LayoutSortOrderKey;
            tempBox.LayoutSortOrderKey = exports.VERY_HIGH_VALUE;
            var selectedBoxOrRow = currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                return l.LayoutBaseId == currentApp.state.selectedLayoutBaseId;
            });
            if (selectedBoxOrRow.LayoutType === CaliforniaGenerated_1.LayoutType.Box) {
                selectedBoxOrRow.PlacedInBoxBoxes.push(tempBox);
            } else if (selectedBoxOrRow.LayoutType === CaliforniaGenerated_1.LayoutType.Row) {
                selectedBoxOrRow.AllBoxesBelowRow.push(tempBox);
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
        };
        this.insertBoxHidePreviewHandler = function (evt) {
            var selectedBoxOrRow = currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                return l.LayoutBaseId == currentApp.state.selectedLayoutBaseId;
            });
            if (selectedBoxOrRow.LayoutType === CaliforniaGenerated_1.LayoutType.Box) {
                var layoutBox = selectedBoxOrRow;
                var tempBoxIndex = layoutBox.PlacedInBoxBoxes.findIndex(function (b) {
                    return b.LayoutBaseId == currentApp.state.hoveredInsertLayoutBaseId;
                });
                if (tempBoxIndex != -1) {
                    var tempBox = layoutBox.PlacedInBoxBoxes.splice(tempBoxIndex, 1)[0];
                    if (currentApp.state.backupSortOrder !== undefined) {
                        tempBox.LayoutSortOrderKey = currentApp.state.backupSortOrder;
                    } else {
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                    }
                    currentApp.state.backupSortOrder = undefined;
                    currentApp.state.hoveredInsertLayoutBaseId = 0;
                } else {
                    console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                }
            } else if (selectedBoxOrRow.LayoutType === CaliforniaGenerated_1.LayoutType.Row) {
                var layoutRow = selectedBoxOrRow;
                var tempBoxIndex = layoutRow.AllBoxesBelowRow.findIndex(function (b) {
                    return b.LayoutBaseId == currentApp.state.hoveredInsertLayoutBaseId;
                });
                if (tempBoxIndex != -1) {
                    var tempBox = layoutRow.AllBoxesBelowRow.splice(tempBoxIndex, 1)[0];
                    if (currentApp.state.backupSortOrder !== undefined) {
                        tempBox.LayoutSortOrderKey = currentApp.state.backupSortOrder;
                    } else {
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                    }
                    currentApp.state.backupSortOrder = undefined;
                    currentApp.state.hoveredInsertLayoutBaseId = 0;
                } else {
                    console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                }
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
        };
        this.insertAtomShowPreviewHandler = function (evt) {
            var targetElement = evt.target;
            var hoveredLayoutId = CaliforniaApp_1.parseIntFromAttribute(targetElement, "lid");
            currentApp.state.hoveredInsertLayoutBaseId = hoveredLayoutId;
            var tempAtom = currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                return l.LayoutBaseId == hoveredLayoutId;
            });
            currentApp.state.backupSortOrder = tempAtom.LayoutSortOrderKey;
            tempAtom.LayoutSortOrderKey = exports.VERY_HIGH_VALUE;
            var layoutBox = currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                return l.LayoutBaseId == currentApp.state.selectedLayoutBaseId;
            });
            layoutBox.PlacedInBoxAtoms.push(tempAtom);
        };
        this.insertAtomHidePreviewHandler = function (evt) {
            var layoutBox = currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                return l.LayoutBaseId == currentApp.state.selectedLayoutBaseId;
            });
            var tempAtomIndex = layoutBox.PlacedInBoxAtoms.findIndex(function (a) {
                return a.LayoutBaseId == currentApp.state.hoveredInsertLayoutBaseId;
            });
            if (tempAtomIndex != -1) {
                var tempAtom = layoutBox.PlacedInBoxAtoms.splice(tempAtomIndex, 1)[0];
                if (currentApp.state.backupSortOrder !== undefined) {
                    tempAtom.LayoutSortOrderKey = currentApp.state.backupSortOrder;
                } else {
                    console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                }
                currentApp.state.backupSortOrder = undefined;
                currentApp.state.hoveredInsertLayoutBaseId = 0;
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
        };
        this.insertSelectedLayoutBoxIntoBoxOrRowClickHandler = function (evt) {
            if (_this.viewModel.currentSecondaryPopupMode === PropertyBarVM_1.PopupSecondaryMode.SelectBoxIntoBox) {
                var layoutId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
                var targetLayoutId = currentApp.state.selectedLayoutBaseId;
                currentApp.controller.CreateLayoutBoxForBoxOrRowJson(targetLayoutId, layoutId).done(function (data) {
                    currentApp.router.updateData(data);
                });
                currentApp.state.lastCommand = CaliforniaGenerated_1.CaliforniaEvent.CreateLayoutBoxForBoxOrRow;
                currentApp.state.lastCaliforniaEventData = [currentApp.state.selectedLayoutBaseId, layoutId];
            } else if (_this.viewModel.currentSecondaryPopupMode === PropertyBarVM_1.PopupSecondaryMode.SelectBoxIntoBoxAtomInPlace) {
                currentApp.controller.CreateLayoutBoxForAtomInPlaceJson(currentApp.state.selectedLayoutBaseId, CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid")).done(function (data) {
                    currentApp.router.updateData(data);
                });
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
            _this.currentPropertyBar.closePopup();
        };
        this.cancelInsertLayoutBoxIntoBoxClickHandler = function (evt) {
            _this.currentPropertyBar.closePopup();
        };
        this.moveLayoutMoleculeIntoLayoutMolecule = function () {
            currentApp.controller.MoveLayoutMoleculeIntoLayoutMoleculeJson(currentApp.state.preselectedLayoutBaseId, currentApp.state.selectedLayoutBaseId).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.closePopup();
        };
        this.moveLayoutMoleculeBeforeLayoutMolecule = function () {
            currentApp.controller.MoveLayoutMoleculeNextToLayoutMoleculeJson(currentApp.state.preselectedLayoutBaseId, currentApp.state.selectedLayoutBaseId, true).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.closePopup();
        };
        this.syncLayoutMoleculeStylesImitatingReferenceLayout = function () {
            currentApp.controller.SyncLayoutStylesImitatingReferenceLayoutJson(currentApp.state.selectedLayoutBaseId, currentApp.state.preselectedLayoutBaseId).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.closePopup();
        };
        this.moveStyleAtomToResponsiveDevicePopup = function () {
            var thisPopupMode = PropertyBarVM_1.PopupMode.MoveStyleAtom;
            var isPopupVisible = _this.viewModel.currentPopupMode === thisPopupMode;
            var isDataLoaded = currentApp.clientData.CaliforniaProject !== undefined && currentApp.clientData.CaliforniaProject.ResponsiveDevices !== undefined;
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[thisPopupMode], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px" } },
                h(
                    "div",
                    { styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelMoveStyleAtomClickHandler },
                        "x"
                    )
                ),
                isDataLoaded ? currentApp.clientData.CaliforniaProject.ResponsiveDevices.map(function (responsiveDevice) {
                    var responsiveDeviceIdString = responsiveDevice.ResponsiveDeviceId.toString();
                    var isSelectedResponsiveDeviceInPropertyBar = _this.currentPropertyBar.viewModel.selectedResponsiveDeviceId == responsiveDevice.ResponsiveDeviceId;
                    return h(
                        "div",
                        { key: responsiveDeviceIdString },
                        !isSelectedResponsiveDeviceInPropertyBar ? h(
                            "button",
                            { key: "a", rid: responsiveDeviceIdString, onclick: _this.currentPropertyBar.moveStyleAtomToResponsiveDeviceClickHandler },
                            responsiveDevice.NameShort
                        ) : h(
                            "button",
                            { disabled: true, key: "a0", rid: responsiveDeviceIdString, onclick: _this.currentPropertyBar.moveStyleAtomToResponsiveDeviceClickHandler },
                            responsiveDevice.NameShort
                        )
                    );
                }) : undefined
            );
        };
        this.moveStyleAtomToResponsiveDeviceClickHandler = function (evt) {
            var targetResponsiveDeviceId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "rid");
            currentApp.controller.MoveStyleAtomToResponsiveDeviceJson(_this.currentPropertyBar.viewModel.selectedStyleAtomIdForPopup, targetResponsiveDeviceId).done(function (data) {
                currentApp.router.updateData(data);
                _this.currentPropertyBar.viewModel.selectedResponsiveDeviceId = targetResponsiveDeviceId;
            });
            _this.currentPropertyBar.viewModel.selectedStyleAtomIdForPopup = 0;
            _this.currentPropertyBar.closePopup();
        };
        this.cancelMoveStyleAtomClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.selectedStyleAtomIdForPopup = 0;
            _this.currentPropertyBar.closePopup();
        };
        this.renderAllCssPropertiesPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.AllCssProperties;
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.AllCssProperties], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px", "height": "300px", "overflow": "scroll" } },
                h(
                    "div",
                    { styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelUpdateCssPropertylickHandler },
                        "x"
                    )
                ),
                currentApp.clientData.AllCssProperties.map(function (prop) {
                    var isPropertyUnmapped = true;
                    var isPropertyVisible = false;
                    if (_this.currentPropertyBar.viewModel.selectedStyleAtomId != 0 && currentApp.clientData.CaliforniaProject !== undefined && currentApp.clientData.CaliforniaProject.StyleAtoms !== undefined) {
                        var targetAtom = currentApp.clientData.CaliforniaProject.StyleAtoms.find(function (s) {
                            return s.StyleAtomId == _this.currentPropertyBar.viewModel.selectedStyleAtomId;
                        });
                        if (targetAtom !== undefined && targetAtom.AppliedValues !== undefined) {
                            isPropertyVisible = currentApp.clientData.StyleAtomCssPropertyMapping[CaliforniaGenerated_1.StyleAtomType[targetAtom.StyleAtomType]].findIndex(function (p) {
                                return p === prop;
                            }) != -1;
                            isPropertyUnmapped = targetAtom.AppliedValues.findIndex(function (v) {
                                return v.CssProperty === prop;
                            }) == -1;
                        }
                    }
                    return isPropertyVisible ? h(
                        "div",
                        { key: prop },
                        prop,
                        isPropertyUnmapped ? h(
                            "button",
                            { key: "a0", role: "button", cid: prop, onclick: _this.currentPropertyBar.setSelectedCssPropertyClickHandler },
                            "\u2714"
                        ) : h(
                            "button",
                            { disabled: true, key: "a1", role: "button", cid: prop, onclick: _this.currentPropertyBar.setSelectedCssPropertyClickHandler },
                            "\u2714"
                        )
                    ) : undefined;
                })
            );
        };
        this.cancelUpdateCssPropertylickHandler = function (evt) {
            _this.viewModel.currentPopupMode = PropertyBarVM_1.PopupMode.AddCssProperty;
        };
        this.showAllCssPropertiesClickHandler = function (evt) {
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.AllCssProperties);
        };
        this.setSelectedCssPropertyClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCssPropertyName = CaliforniaApp_1.parseStringFromAttribute(evt.target, "cid");
            _this.currentPropertyBar.saveCssPropertyForAtom();
        };
        this.saveCssPropertyForAtomClickHandler = function (evt) {
            _this.currentPropertyBar.saveCssPropertyForAtom();
        };
        this.saveCssPropertyForAtom = function () {
            currentApp.controller.CreateStyleValueForAtomJson(_this.currentPropertyBar.viewModel.selectedStyleAtomId, _this.currentPropertyBar.viewModel.tempCssPropertyName).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.resetTempCssPropertyState();
        };
        this.cancelAddCssPropertyForAtomClickHandler = function (evt) {
            _this.currentPropertyBar.resetTempCssPropertyState();
        };
        this.resetTempCssPropertyState = function () {
            _this.currentPropertyBar.viewModel.tempCssPropertyName = "";
            _this.currentPropertyBar.viewModel.tempCssValue = "";
            _this.currentPropertyBar.viewModel.selectedStyleAtomId = 0;
            _this.currentPropertyBar.viewModel.selectedStyleValueId = 0;
            _this.currentPropertyBar.viewModel.selectedStyleQuantumId = 0;
            _this.currentPropertyBar.closePopup();
        };
        this.cssPropertyNameInputHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCssPropertyName = evt.target.value;
        };
        this.renderUpdateCssValuePopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.UpdateCssValue || _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.MatchingQuantums;
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.UpdateCssValue], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px" } },
                h(
                    "div",
                    { styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.saveUpdatedCssValueClickHandler },
                        "\u2714"
                    ),
                    h(
                        "button",
                        { key: "b", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelUpdateCssValueClickHandler },
                        "x"
                    )
                ),
                h(
                    "div",
                    null,
                    h("input", { key: "-1", value: _this.currentPropertyBar.viewModel.tempCssValue, oninput: _this.currentPropertyBar.cssValueInputHandler }),
                    h(
                        "button",
                        { key: "a", role: "button", onclick: _this.currentPropertyBar.showMatchingQuantumsClickHandler },
                        "?"
                    ),
                    h(
                        "button",
                        { key: "b", role: "button", onclick: _this.currentPropertyBar.setTempCssToZeroClickHandler },
                        "0"
                    ),
                    h(
                        "button",
                        { key: "c", role: "button", onclick: _this.currentPropertyBar.setTempCssToNoneClickHandler },
                        "none"
                    ),
                    h(
                        "button",
                        { key: "d", role: "button", onclick: _this.currentPropertyBar.setTempCssToNullClickHandler },
                        "null"
                    ),
                    h(
                        "button",
                        { key: "e", role: "button", onclick: _this.currentPropertyBar.setTempCssToAutoClickHandler },
                        "auto"
                    ),
                    _this.currentPropertyBar.viewModel.lastUsedTempCssValue !== "" ? h(
                        "button",
                        { key: "e", role: "button", onclick: _this.currentPropertyBar.setTempCssAppendLastUsedClickHandler },
                        "+",
                        _this.currentPropertyBar.viewModel.lastUsedTempCssValue.length > 10 ? _this.currentPropertyBar.viewModel.lastUsedTempCssValue.substring(0, 10) + "..." : _this.currentPropertyBar.viewModel.lastUsedTempCssValue
                    ) : undefined
                )
            );
        };
        this.setTempCssToZeroClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCssValue = "0";
        };
        this.setTempCssToNullClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCssValue = "null";
        };
        this.setTempCssToNoneClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCssValue = "none";
        };
        this.setTempCssToAutoClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCssValue = "auto";
        };
        this.setTempCssAppendLastUsedClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCssValue = _this.currentPropertyBar.viewModel.tempCssValue + _this.currentPropertyBar.viewModel.lastUsedTempCssValue;
        };
        this.renderUpdateCssQuantumPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.UpdateCssQuantum;
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.UpdateCssQuantum], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px" } },
                h(
                    "div",
                    { styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.saveUpdatedCssQuantumClickHandler },
                        "\u2714"
                    ),
                    h(
                        "button",
                        { key: "b", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelUpdateCssQuantumClickHandler },
                        "x"
                    )
                ),
                h(
                    "div",
                    null,
                    h("input", { key: "-1", value: _this.currentPropertyBar.viewModel.tempCssValue, oninput: _this.currentPropertyBar.cssValueInputHandler })
                )
            );
        };
        this.showMatchingQuantumsClickHandler = function (evt) {
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.MatchingQuantums);
        };
        this.saveUpdatedCssQuantumClickHandler = function (evt) {
            currentApp.controller.UpdateStyleQuantumJson(_this.currentPropertyBar.viewModel.selectedStyleQuantumId, _this.currentPropertyBar.viewModel.tempCssValue).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.viewModel.lastUsedTempCssValue = _this.currentPropertyBar.viewModel.tempCssValue;
            _this.currentPropertyBar.resetTempCssPropertyState();
        };
        this.cancelUpdateCssQuantumClickHandler = function (evt) {
            _this.currentPropertyBar.resetTempCssPropertyState();
        };
        this.saveUpdatedCssValueClickHandler = function (evt) {
            currentApp.controller.UpdateStyleValueJson(_this.currentPropertyBar.viewModel.selectedStyleValueId, _this.currentPropertyBar.viewModel.tempCssValue).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.viewModel.lastUsedTempCssValue = _this.currentPropertyBar.viewModel.tempCssValue;
            _this.currentPropertyBar.resetTempCssPropertyState();
        };
        this.cancelUpdateCssValueClickHandler = function (evt) {
            _this.currentPropertyBar.resetTempCssPropertyState();
        };
        this.cssValueInputHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCssValue = evt.target.value;
        };
        this.cssValueForInteractionInputHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCssValueForInteraction = evt.target.value;
        };
        this.renderSelectInteractionTargetPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.SelectInteractionTarget;
            var renderedOptions = [];
            if (isPopupVisible === true) {
                currentApp.clientData.CaliforniaProject.LayoutMolecules.map(function (m) {
                    var layoutBaseIdString = m.LayoutBaseId.toString();
                    renderedOptions.push(h(
                        "div",
                        { key: layoutBaseIdString, styles: { "flex": "0 0 100%", "width": "100%", "min-width": "100%" } },
                        "layout #",
                        layoutBaseIdString,
                        " ",
                        h(
                            "button",
                            { key: "a", role: "button", bid: layoutBaseIdString, onclick: _this.currentPropertyBar.selectLayoutBaseForInteractionTargetClickHandler },
                            "\u2714"
                        )
                    ));
                });
            }
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.SelectInteractionTarget], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px" } },
                h(
                    "div",
                    { key: "0", styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelSelectInteractionTargetClickHandler },
                        "x"
                    )
                ),
                h(
                    "div",
                    { key: "1", styles: { "display": "flex", "flex-flow": "row wrap" } },
                    renderedOptions
                )
            );
        };
        this.selectLayoutBaseForInteractionTargetClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.selectedLayoutBaseIdForFilter = CaliforniaApp_1.parseIntFromAttribute(evt.target, "bid");
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.SelectInteractionTargetLayoutFilter);
        };
        this.cancelSelectInteractionTargetClickHandler = function (evt) {
            _this.currentPropertyBar.closePopup();
            _this.currentPropertyBar.viewModel.selectedLayoutBaseIdForFilter = 0;
            _this.currentPropertyBar.viewModel.selectedLayoutStyleInteraction = 0;
        };
        this.renderSelectInteractionTargetLayoutFilterPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.SelectInteractionTargetLayoutFilter;
            var renderedOptions = [];
            if (isPopupVisible === true) {
                currentApp.clientData.CaliforniaProject.StyleValues.map(function (v) {
                    var styleAtom = currentApp.clientData.CaliforniaProject.StyleAtoms.find(function (a) {
                        return a.AppliedValues.findIndex(function (map) {
                            return map.StyleValueId == v.StyleValueId;
                        }) != -1;
                    });
                    var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                        return m.MappedStyleAtoms.findIndex(function (map) {
                            return map.StyleMoleculeAtomMappingId == styleAtom.MappedToMoleculeId;
                        }) != -1;
                    });
                    if (styleMolecule.StyleForLayoutId == _this.currentPropertyBar.viewModel.selectedLayoutBaseIdForFilter) {
                        var styleValueIdString = v.StyleValueId.toString();
                        renderedOptions.push(h(
                            "div",
                            { key: styleValueIdString, styles: { "flex": "0 0 100%", "width": "100%", "min-width": "100%" } },
                            "value #",
                            styleValueIdString,
                            ": ",
                            v.CssProperty,
                            ":",
                            v.CssValue,
                            " ",
                            h(
                                "button",
                                { key: "a", role: "button", vid: styleValueIdString, onclick: _this.currentPropertyBar.selectStyleValueForInteractionTargetClickHandler },
                                "\u2714"
                            )
                        ));
                    }
                });
            }
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.SelectInteractionTargetLayoutFilter], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px" } },
                h(
                    "div",
                    { key: "0", styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelSelectStyleValueForInteractionTargetClickHandler },
                        "x"
                    )
                ),
                h(
                    "div",
                    { key: "1", styles: { "display": "flex", "flex-flow": "row wrap" } },
                    renderedOptions
                )
            );
        };
        this.selectStyleValueForInteractionTargetClickHandler = function (evt) {
            _this.currentPropertyBar.closePopup();
            currentApp.controller.CreateStyleValueInteractionJson(_this.currentPropertyBar.viewModel.selectedLayoutStyleInteraction, CaliforniaApp_1.parseIntFromAttribute(evt.target, "vid"), _this.currentPropertyBar.viewModel.tempCssValueForInteraction).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.cancelSelectStyleValueForInteractionTargetClickHandler = function (evt) {
            _this.currentPropertyBar.closePopup();
            _this.currentPropertyBar.viewModel.selectedLayoutBaseIdForFilter = 0;
            _this.currentPropertyBar.viewModel.selectedLayoutStyleInteraction = 0;
        };
        this.renderMatchingQuantumsPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.MatchingQuantums;
            var renderedOptions = [];
            if (isPopupVisible === true) {
                currentApp.clientData.CaliforniaProject.StyleQuantums.map(function (quantum) {
                    var isMatchingProperty = quantum.CssProperty === _this.currentPropertyBar.viewModel.tempCssPropertyName;
                    if (isMatchingProperty === true) {
                        renderedOptions.push(h(
                            "div",
                            { key: quantum.StyleQuantumId },
                            quantum.Name,
                            " = ",
                            quantum.CssValue,
                            " ",
                            h(
                                "button",
                                { key: "a", role: "button", qid: quantum.StyleQuantumId.toString(), onclick: _this.currentPropertyBar.setQuantumOnAtomClickHandler },
                                "\u2714"
                            )
                        ));
                    }
                });
                if (renderedOptions.length == 0) {
                    renderedOptions.push(h(
                        "div",
                        { key: "0" },
                        "No quantums available."
                    ));
                }
            }
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.MatchingQuantums], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px", "height": "300px", "overflow": "scroll" } },
                h(
                    "div",
                    { styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelSelectMatchingCssQuantumClickHandler },
                        "x"
                    )
                ),
                renderedOptions
            );
        };
        this.cancelSelectMatchingCssQuantumClickHandler = function (evt) {
            _this.viewModel.currentPopupMode = PropertyBarVM_1.PopupMode.UpdateCssValue;
        };
        this.setQuantumOnAtomClickHandler = function (evt) {
            var quantumId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "qid");
            currentApp.controller.ApplyStyleQuantumToAtomJson(_this.currentPropertyBar.viewModel.selectedStyleAtomId, quantumId).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.resetTempCssPropertyState();
            _this.currentPropertyBar.viewModel.lastUsedTempCssValue = currentApp.clientData.CaliforniaProject.StyleQuantums.find(function (q) {
                return q.StyleQuantumId == quantumId;
            }).CssValue;
        };
        this.renderStyleMoleculeArray = function (propertyBar) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.StyleMoleculeId;
            }, function createSectionTarget(source) {
                var sourceStyleMoleculeIdString = source.StyleMoleculeId.toString();
                return {
                    renderMaquette: function renderMaquette() {
                        return h(
                            "div",
                            { key: sourceStyleMoleculeIdString, exitAnimation: propertyBar.styleElementExitAnimation },
                            h(
                                "p",
                                null,
                                "(#",
                                sourceStyleMoleculeIdString,
                                ")",
                                source.Name
                            ),
                            h(
                                "button",
                                { key: "a", role: "button", mid: sourceStyleMoleculeIdString, onclick: propertyBar.selectStyleMoleculeClickHandler },
                                "Edit"
                            )
                        );
                    },
                    update: function update(updatedSource) {
                        sourceStyleMoleculeIdString = updatedSource.StyleMoleculeId.toString();
                        source = updatedSource;
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.selectStyleMoleculeClickHandler = function (evt) {
            _this.nextExceptLastPropertyBar.viewModel.selectedStyleMoleculeId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "mid");
            _this.nextExceptLastPropertyBar.viewModel.selectedStateModifier = "";
            _this.nextExceptLastPropertyBar.viewModel.currentPropertyBarMode = PropertyBarVM_1.PropertyBarMode.StyleMolecule;
        };
        this.highlightLayoutBaseClickHandler = function (evt) {
            var targetLayoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            if (currentApp.state.highlightedLayoutBaseId != targetLayoutBaseId) {
                currentApp.state.highlightedLayoutBaseId = targetLayoutBaseId;
            } else {
                currentApp.state.highlightedLayoutBaseId = 0;
            }
        };
        this.renderStyleQuantumArray = function (propertyBar) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.StyleQuantumId;
            }, function createSectionTarget(source) {
                var sourceIdString = source.StyleQuantumId.toString();
                return {
                    renderMaquette: function renderMaquette() {
                        return h(
                            "div",
                            { key: sourceIdString, exitAnimation: propertyBar.styleElementExitAnimation },
                            h(
                                "p",
                                { key: "0", styles: { "margin": "0" } },
                                "(#",
                                sourceIdString,
                                ")",
                                source.Name,
                                ": ",
                                source.CssProperty,
                                " => ",
                                source.CssValue
                            ),
                            h(
                                "button",
                                { key: "a", role: "button", qid: sourceIdString, onclick: propertyBar.duplicateStyleQuantumClickHandler },
                                "DD"
                            ),
                            source.IsDeletable ? h(
                                "button",
                                { key: "b0", role: "button", qid: sourceIdString, onclick: propertyBar.deleteStyleQuantumClickHandler },
                                "X"
                            ) : h(
                                "button",
                                { disabled: true, key: "b1", role: "button" },
                                "X"
                            ),
                            h(
                                "button",
                                { key: "c", role: "button", qid: sourceIdString, onclick: propertyBar.updateCssQuantumClickHandler },
                                "Edit"
                            )
                        );
                    },
                    update: function update(updatedSource) {
                        sourceIdString = updatedSource.StyleQuantumId.toString();
                        source = updatedSource;
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.updateCssQuantumClickHandler = function (evt) {
            var styleQuantumId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "qid");
            _this.currentPropertyBar.viewModel.selectedStyleQuantumId = styleQuantumId;
            var targetStyleQuantum = currentApp.clientData.CaliforniaProject.StyleQuantums.find(function (val) {
                return val.StyleQuantumId == styleQuantumId;
            });
            _this.currentPropertyBar.viewModel.tempCssValue = targetStyleQuantum.CssValue;
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.UpdateCssQuantum);
        };
        this.deleteStyleQuantumClickHandler = function (evt) {
            currentApp.controller.DeleteStyleQuantumJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "qid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.duplicateStyleQuantumClickHandler = function (evt) {
            currentApp.controller.DuplicateStyleQuantumJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "qid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.styleElementExitAnimation = function (domNode, removeElement, properties) {
            domNode.style.overflow = "hidden";
            velocity.animate(domNode, { opacity: 0.5, height: 0 }, { duration: 100, easing: "ease-out", complete: removeElement });
        };
        this.renderLayoutMoleculeArray = function (propertyBar) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.LayoutBaseId;
            }, function createSectionTarget(source) {
                var sourceLayoutBaseIdString = source.LayoutBaseId.toString();
                var sourceStyleMoleculeIdString = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                    return m.StyleForLayoutId == source.LayoutBaseId;
                }).StyleMoleculeId.toString();
                var layoutControlButtonStyles = {
                    "margin-right": "5px"
                };
                return {
                    renderMaquette: function renderMaquette() {
                        var description = "";
                        if (source.LayoutType === CaliforniaGenerated_1.LayoutType.Atom) {
                            var sourceLayoutAtom = source;
                            var textContentString = "";
                            if (sourceLayoutAtom.HostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Text) {
                                textContentString = sourceLayoutAtom.HostedContentAtom.TextContent;
                            } else if (sourceLayoutAtom.HostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Link) {
                                textContentString = sourceLayoutAtom.HostedContentAtom.Url;
                            } else {
                                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                            }
                            description = textContentString.length > 20 ? textContentString.substring(0, 20) + "..." : textContentString;
                            description += " in box #" + source.PlacedAtomInBoxId;
                        }
                        return h(
                            "div",
                            { key: sourceLayoutBaseIdString },
                            " ",
                            CaliforniaGenerated_1.LayoutType[source.LayoutType].toString(),
                            " #",
                            sourceLayoutBaseIdString,
                            " ",
                            description,
                            h(
                                "button",
                                { key: "a", role: "button", lid: sourceLayoutBaseIdString, onclick: propertyBar.selectLayoutBaseClickHandler, styles: layoutControlButtonStyles },
                                "?"
                            ),
                            h(
                                "button",
                                { key: "b", role: "button", mid: sourceStyleMoleculeIdString, onclick: propertyBar.selectStyleMoleculeClickHandler, styles: layoutControlButtonStyles },
                                "S"
                            ),
                            h(
                                "button",
                                { key: "c", role: "button", lid: sourceLayoutBaseIdString, onclick: propertyBar.deleteLayoutBaseClickHandler, styles: layoutControlButtonStyles },
                                "X"
                            )
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        sourceLayoutBaseIdString = source.LayoutBaseId.toString();
                        var sourceStyleMoleculeIdString = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                            return m.StyleForLayoutId == source.LayoutBaseId;
                        }).StyleMoleculeId.toString();
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.renderCaliforniaViewArray = function (propertyBar) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.CaliforniaViewId;
            }, function createSectionTarget(source) {
                var sourceCaliforniaViewIdString = source.CaliforniaViewId.toString();
                return {
                    renderMaquette: function renderMaquette() {
                        var isDeleteButtonEnabled = source.PlacedLayoutRows.length == 0;
                        return h(
                            "div",
                            { key: sourceCaliforniaViewIdString },
                            source.Name,
                            " View #",
                            sourceCaliforniaViewIdString,
                            h(
                                "button",
                                { key: "a", role: "button", vid: sourceCaliforniaViewIdString, onclick: propertyBar.selectCaliforniaViewClickHandler },
                                ":)"
                            ),
                            !source.IsInternal && source.CaliforniaViewId != currentApp.pagePreview.viewModel.activeCaliforniaViewId ? h(
                                "button",
                                { key: "b", role: "button", vid: sourceCaliforniaViewIdString, onclick: propertyBar.activateCaliforniaViewClickHandler },
                                "\u2714"
                            ) : undefined,
                            ": ",
                            source.IsInternal ? "internal" : undefined,
                            " ",
                            source.Name,
                            " hosted by ",
                            source.HostedByLayoutMappings.length,
                            " layouts",
                            h(
                                "button",
                                { key: "c", role: "button", mid: source.SpecialStyleViewStyleMoleculeIdString, onclick: propertyBar.selectStyleMoleculeClickHandler },
                                "style #",
                                source.SpecialStyleViewStyleMoleculeIdString
                            ),
                            h(
                                "button",
                                { key: "d", role: "button", mid: source.SpecialStyleBodyStyleMoleculeIdString, onclick: propertyBar.selectStyleMoleculeClickHandler },
                                "body style #",
                                source.SpecialStyleBodyStyleMoleculeIdString
                            ),
                            h(
                                "button",
                                { key: "e", role: "button", mid: source.SpecialStyleHtmlStyleMoleculeIdString, onclick: propertyBar.selectStyleMoleculeClickHandler },
                                "HTML style #",
                                source.SpecialStyleHtmlStyleMoleculeIdString
                            ),
                            isDeleteButtonEnabled ? h(
                                "button",
                                { key: "f", role: "button", vid: sourceCaliforniaViewIdString, onclick: propertyBar.deleteCaliforniaViewClickHandler },
                                "X"
                            ) : h(
                                "button",
                                { disabled: true, key: "c0", role: "button", onclick: propertyBar.deleteCaliforniaViewClickHandler },
                                "X"
                            )
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        sourceCaliforniaViewIdString = source.CaliforniaViewId.toString();
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.logoutPopupClickHandler = function (evt) {
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.ShareCaliforniaProject);
        };
        this.renderShareCaliforniaProjectPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.ShareCaliforniaProject;
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.ShareCaliforniaProject], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px" } },
                h(
                    "div",
                    { key: "0", styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "b", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelShareCaliforniaProjectClickHandler },
                        "x"
                    )
                ),
                h(
                    "div",
                    { key: "1", styles: { "display": "flex", "flex-flow": "row wrap" } },
                    h(
                        "p",
                        { key: "a", styles: { "flex": "0 0 100%", "width": "100%", "min-width": "100%" } },
                        currentApp.clientData.UrlToReadOnly
                    ),
                    "Bookmark! Clear browser history!",
                    h(
                        "button",
                        { key: "c", type: "button", onclick: _this.currentPropertyBar.logoutClickHandler, styles: { "flex": "0 0 10%", "width": "10%", "min-width": "10%" } },
                        "\uD83D\uDD12"
                    ),
                    h(
                        "button",
                        { key: "d", type: "button", onclick: _this.currentPropertyBar.tokyoClickHandler, styles: { "flex": "0 0 10%", "width": "10%", "min-width": "10%" } },
                        "TOKYO"
                    )
                )
            );
        };
        this.tokyoClickHandler = function (evt) {
            window.location.assign(window.location.origin + "/tokyo/");
        };
        this.cancelShareCaliforniaProjectClickHandler = function (evt) {
            _this.currentPropertyBar.closePopup();
        };
        this.logoutClickHandler = function (evt) {
            currentApp.controller.LogoutAction().done(function (response) {
                window.location.assign(window.location.origin + "/california/");
            });
        };
        this.activateCaliforniaViewClickHandler = function (evt) {
            var californiaViewId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "vid");
            var userPages = currentApp.clientData.CaliforniaProject.CaliforniaViews.filter(function (view) {
                return !view.IsInternal;
            });
            var activeView = undefined;
            var activePageIndex = userPages.findIndex(function (v) {
                return v.CaliforniaViewId == californiaViewId;
            });
            if (activePageIndex > -1) {
                activeView = userPages[activePageIndex];
                currentApp.router.setActiveCaliforniaView(activeView);
                currentApp.pagePreview.resetEquationNumbersWhenModifying(true);
                _this.currentPropertyBar.viewModel.setSelectedCaliforniaView(activeView, true);
                _this.viewModel.currentPropertyBarMode = PropertyBarVM_1.PropertyBarMode.CaliforniaView;
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
        };
        this.selectLayoutBaseClickHandler = function (evt) {
            var layoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            currentApp.state.selectedLayoutBaseId = layoutBaseId;
            _this.currentPropertyBar.viewModel.currentPropertyBarMode = PropertyBarVM_1.PropertyBarMode.LayoutBase;
        };
        this.selectCaliforniaViewClickHandler = function (evt) {
            var californiaViewId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "vid");
            var userPages = currentApp.clientData.CaliforniaProject.CaliforniaViews.filter(function (view) {
                return !view.IsInternal;
            });
            var activeView = undefined;
            var activePageIndex = userPages.findIndex(function (v) {
                return v.CaliforniaViewId == californiaViewId;
            });
            if (activePageIndex > -1) {
                activeView = userPages[activePageIndex];
                if (_this.currentPropertyBar.propertyBarIndex == 0) {
                    currentApp.router.setActiveCaliforniaView(activeView);
                    currentApp.pagePreview.resetEquationNumbersWhenModifying(true);
                } else {
                    _this.currentPropertyBar.viewModel.isSyncedWithBoxTreeToTheLeft = false;
                }
                _this.currentPropertyBar.viewModel.setSelectedCaliforniaView(activeView, true);
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
            _this.currentPropertyBar.viewModel.currentPropertyBarMode = PropertyBarVM_1.PropertyBarMode.CaliforniaView;
        };
        this.deleteLayoutBaseClickHandler = function (evt) {
            if (currentApp.state.preselectedLayoutBaseId != 0) {
                return;
            }
            currentApp.state.selectedLayoutBaseId = 0;
            currentApp.controller.DeleteLayoutJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid"), false).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.deleteBelowLayoutBaseClickHandler = function (evt) {
            if (currentApp.state.preselectedLayoutBaseId != 0) {
                return;
            }
            currentApp.state.selectedLayoutBaseId = 0;
            currentApp.controller.DeleteLayoutJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid"), true).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.renderLayoutBaseControls = function () {
            if (currentApp.state.selectedLayoutBaseId == 0) {
                return undefined;
            }
            var selectedLayoutBase = currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                return l.LayoutBaseId == currentApp.state.selectedLayoutBaseId;
            });
            var layoutBaseIdString = selectedLayoutBase.LayoutBaseId.toString();
            var sourceStyleMoleculeIdString = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                return m.StyleForLayoutId == selectedLayoutBase.LayoutBaseId;
            }).StyleMoleculeId.toString();
            if (selectedLayoutBase.LayoutType === CaliforniaGenerated_1.LayoutType.Atom) {
                var selectedLayoutAtom = selectedLayoutBase;
                var isPictureContent = selectedLayoutAtom.HostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Picture;
                var pictureContentIdString = isPictureContent ? selectedLayoutAtom.HostedContentAtom.PictureContent.PictureContentId.toString() : undefined;
                return h(
                    "div",
                    { key: CaliforniaGenerated_1.LayoutType.Atom },
                    " Atom:",
                    h(
                        "button",
                        { key: "a", role: "button", mid: sourceStyleMoleculeIdString, onclick: _this.currentPropertyBar.selectStyleMoleculeClickHandler },
                        "style #",
                        sourceStyleMoleculeIdString
                    ),
                    h(
                        "button",
                        { key: "b", role: "button", lid: layoutBaseIdString, onclick: _this.currentPropertyBar.deleteLayoutBaseClickHandler },
                        "X"
                    ),
                    h(
                        "button",
                        { key: "c", role: "button", aid: layoutBaseIdString, onclick: _this.currentPropertyBar.createLayoutStyleInteraction },
                        "+ Interaction"
                    ),
                    selectedLayoutAtom.LayoutStyleInteractions.map(function (interaction) {
                        var interactionIdString = interaction.LayoutStyleInteractionId.toString();
                        return h(
                            "div",
                            { key: "i" + interactionIdString },
                            h(
                                "p",
                                { key: "0" },
                                "Interaction #",
                                interaction.LayoutStyleInteractionId
                            ),
                            h("input", { key: "1", value: _this.currentPropertyBar.viewModel.tempCssValueForInteraction, oninput: _this.currentPropertyBar.cssValueForInteractionInputHandler }),
                            _this.currentPropertyBar.viewModel.tempCssValueForInteraction !== "" ? h(
                                "button",
                                { key: "a", role: "button", lid: interactionIdString, onclick: _this.currentPropertyBar.selectInteractionTargetClickHandler },
                                "?"
                            ) : h(
                                "button",
                                { disabled: true, key: "a0", role: "button", lid: interactionIdString, onclick: _this.currentPropertyBar.selectInteractionTargetClickHandler },
                                "?"
                            ),
                            h(
                                "button",
                                { key: "b", role: "button", lid: interactionIdString, onclick: _this.currentPropertyBar.deleteLayoutStyleInteractionClickHandler },
                                "X"
                            ),
                            interaction.StyleValueInteractions.map(function (map) {
                                var mappingIdString = map.StyleValueInteractionMappingId.toString();
                                return h(
                                    "div",
                                    { key: mappingIdString },
                                    h(
                                        "p",
                                        { key: "0" },
                                        "#",
                                        mappingIdString,
                                        ": ",
                                        map.CssValue
                                    ),
                                    h(
                                        "button",
                                        { key: "a", role: "button", vid: map.StyleValueId.toString(), lid: interactionIdString, onclick: _this.currentPropertyBar.deleteStyleValueInteractionClickHandler },
                                        "X"
                                    )
                                );
                            })
                        );
                    }),
                    h(
                        "form",
                        { key: "0", action: "UploadFiles", method: "post", enctype: "multipart/form-data" },
                        h(
                            "p",
                            { key: "0" },
                            "picture id #",
                            pictureContentIdString
                        ),
                        h("input", { multiple: true, key: "1", type: "file", name: "formFiles", onchange: _this.currentPropertyBar.uploadFileChangeHandler }),
                        h(
                            "button",
                            { key: "a", role: "button", pid: pictureContentIdString, onclick: _this.currentPropertyBar.uploadFileClickHandler },
                            "..."
                        )
                    )
                );
            } else if (selectedLayoutBase.LayoutType === CaliforniaGenerated_1.LayoutType.Box) {
                var selectedLayoutBox_1 = selectedLayoutBase;
                var specialLayoutBoxTypeSelectors_1 = [];
                CaliforniaApp_1.getArrayForEnum(CaliforniaGenerated_1.SpecialLayoutBoxType).map(function (type, index) {
                    var isLayoutBoxType = index == selectedLayoutBox_1.SpecialLayoutBoxType;
                    var layoutBoxTypeString = index.toString();
                    specialLayoutBoxTypeSelectors_1.push(isLayoutBoxType ? h(
                        "option",
                        { selected: true, key: layoutBoxTypeString, value: layoutBoxTypeString },
                        type
                    ) : h(
                        "option",
                        { key: layoutBoxTypeString, value: layoutBoxTypeString },
                        type
                    ));
                });
                return h(
                    "div",
                    { key: CaliforniaGenerated_1.LayoutType.Box },
                    " Box:",
                    h(
                        "button",
                        { key: "a", role: "button", mid: sourceStyleMoleculeIdString, onclick: _this.currentPropertyBar.selectStyleMoleculeClickHandler },
                        "style #",
                        sourceStyleMoleculeIdString
                    ),
                    h(
                        "button",
                        { disabled: true, key: "b", role: "button", onclick: _this.currentPropertyBar.createViewForBoxClickHandler },
                        "Create View"
                    ),
                    h(
                        "button",
                        { key: "c", role: "button", lid: layoutBaseIdString, onclick: _this.currentPropertyBar.deleteLayoutBaseClickHandler },
                        "X"
                    ),
                    h(
                        "select",
                        { key: "0", bid: layoutBaseIdString, onchange: _this.currentPropertyBar.specialLayoutBoxTypeChangedHandler },
                        specialLayoutBoxTypeSelectors_1
                    )
                );
            } else if (selectedLayoutBase.LayoutType === CaliforniaGenerated_1.LayoutType.Row) {
                var selectedLayoutRow = selectedLayoutBase;
                var currentBoxCount = selectedLayoutRow.AllBoxesBelowRow.filter(function (b) {
                    return b.PlacedBoxInBoxId === undefined;
                }).length;
                var boxCountSelectors = [];
                for (var i = 0; i <= 12; i++) {
                    var isSelected = i == currentBoxCount;
                    var boxCountString = i.toString();
                    if (i == 0) {
                        boxCountSelectors.push(isSelected ? h(
                            "option",
                            { disabled: true, selected: true, key: boxCountString, value: boxCountString },
                            boxCountString
                        ) : h(
                            "option",
                            { disabled: true, key: boxCountString, value: boxCountString },
                            boxCountString
                        ));
                    } else {
                        boxCountSelectors.push(isSelected ? h(
                            "option",
                            { selected: true, key: boxCountString, value: boxCountString },
                            boxCountString
                        ) : h(
                            "option",
                            { key: boxCountString, value: boxCountString },
                            boxCountString
                        ));
                    }
                }
                return h(
                    "div",
                    { key: CaliforniaGenerated_1.LayoutType.Row },
                    " Row:",
                    h(
                        "button",
                        { key: "a", role: "button", mid: sourceStyleMoleculeIdString, onclick: _this.currentPropertyBar.selectStyleMoleculeClickHandler },
                        "style #",
                        sourceStyleMoleculeIdString
                    ),
                    h(
                        "button",
                        { key: "b", role: "button", lid: layoutBaseIdString, onclick: _this.currentPropertyBar.deleteLayoutBaseClickHandler },
                        "X"
                    ),
                    h(
                        "select",
                        { key: "c", rid: layoutBaseIdString, onchange: _this.currentPropertyBar.boxCountInRowChangedHandler },
                        boxCountSelectors
                    )
                );
            }
            console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            return undefined;
        };
        this.uploadFileChangeHandler = function (evt) {
            var fileSelector = evt.target;
            if (fileSelector.files !== null) {
                var fileArray = [];
                for (var index in fileSelector.files) {
                    var file = fileSelector.files[index];
                    fileArray.push(file);
                    console.log(file);
                    var fileReader = new FileReader();
                    fileReader.addEventListener("loadend", _this.currentPropertyBar.fileProcessingLoadEndHandler);
                }
                if (fileSelector.files.length == 0) {
                    console.log("empty");
                }
            } else {
                console.log("undefined");
            }
        };
        this.fileProcessingLoadEndHandler = function (evt) {
            console.log(evt.total);
            console.log(evt.target.result);
        };
        this.uploadFileClickHandler = function (evt) {
            evt.preventDefault();
            var targetForm = evt.target.form;
            console.log("upload dialog TODO");
            jQuery.ajax(targetForm.action, {
                method: targetForm.method,
                contentType: "multipart/form-data",
                data: $(targetForm).serialize()
            });
        };
        this.selectInteractionTargetClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.selectedLayoutStyleInteraction = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.SelectInteractionTarget);
        };
        this.deleteStyleValueInteractionClickHandler = function (evt) {
            currentApp.controller.DeleteStyleValueInteractionJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid"), CaliforniaApp_1.parseIntFromAttribute(evt.target, "vid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.deleteLayoutStyleInteractionClickHandler = function (evt) {
            currentApp.controller.DeleteLayoutStyleInteractionJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.createLayoutStyleInteraction = function (evt) {
            currentApp.controller.CreateLayoutStyleInteractionForLayoutAtomJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "aid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.specialLayoutBoxTypeChangedHandler = function (evt) {
            var targetSelect = evt.target;
            var selectedSpecialLayoutBoxType = undefined;
            if (targetSelect.selectedIndex < targetSelect.childElementCount) {
                var selectOptionElement = targetSelect.options[targetSelect.selectedIndex];
                selectedSpecialLayoutBoxType = parseInt(selectOptionElement.value);
            }
            if (selectedSpecialLayoutBoxType !== undefined) {
                currentApp.controller.SetSpecialLayoutBoxTypeJson(CaliforniaApp_1.parseIntFromAttribute(targetSelect, "bid"), selectedSpecialLayoutBoxType).done(function (data) {
                    return currentApp.router.updateData(data);
                });
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
        };
        this.boxCountInRowChangedHandler = function (evt) {
            var targetSelect = evt.target;
            var parsedBoxCount = undefined;
            if (targetSelect.selectedIndex < targetSelect.childElementCount) {
                var selectOptionElement = targetSelect.options[targetSelect.selectedIndex];
                parsedBoxCount = parseInt(selectOptionElement.value);
            }
            if (parsedBoxCount !== undefined) {
                currentApp.controller.SetLayoutBoxCountForRowOrBoxJson(CaliforniaApp_1.parseIntFromAttribute(targetSelect, "rid"), currentApp.state.newBoxStyleMoleculeId, parsedBoxCount, false).done(function (data) {
                    return currentApp.router.updateData(data);
                });
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
        };
        this.finalizeLayoutRequest = function (evt) {
            currentApp.state.selectedLayoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            if (currentApp.state.currentTransactionMode === PropertyBarVM_1.TransactionMode.MoveLayoutMoleculeIntoLayoutMolecule) {
                _this.currentPropertyBar.moveLayoutMoleculeIntoLayoutMolecule();
                currentApp.state.preselectedLayoutBaseId = 0;
            } else if (currentApp.state.currentTransactionMode === PropertyBarVM_1.TransactionMode.MoveLayoutMoleculeBeforeLayoutMolecule) {
                _this.currentPropertyBar.moveLayoutMoleculeBeforeLayoutMolecule();
                currentApp.state.preselectedLayoutBaseId = 0;
            } else if (currentApp.state.currentTransactionMode === PropertyBarVM_1.TransactionMode.SyncLayoutStylesImitating) {
                _this.currentPropertyBar.syncLayoutMoleculeStylesImitatingReferenceLayout();
            } else {
                currentApp.state.preselectedLayoutBaseId = 0;
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                return;
            }
        };
        this.moveLayoutBoxIntoRowClickHandler = function (evt) {
            var layoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            if (currentApp.state.preselectedLayoutBaseId != layoutBaseId) {
                currentApp.state.preselectedLayoutBaseId = layoutBaseId;
                currentApp.state.currentTransactionMode = PropertyBarVM_1.TransactionMode.MoveLayoutMoleculeIntoLayoutMolecule;
            } else {
                currentApp.state.preselectedLayoutBaseId = 0;
            }
        };
        this.moveLayoutBoxIntoBoxClickHandler = function (evt) {
            var layoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            if (currentApp.state.preselectedLayoutBaseId != layoutBaseId) {
                currentApp.state.preselectedLayoutBaseId = layoutBaseId;
                currentApp.state.currentTransactionMode = PropertyBarVM_1.TransactionMode.MoveLayoutMoleculeIntoLayoutMolecule;
            } else {
                currentApp.state.preselectedLayoutBaseId = 0;
            }
        };
        this.moveLayoutBoxBeforeBoxClickHandler = function (evt) {
            var layoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            if (currentApp.state.preselectedLayoutBaseId != layoutBaseId) {
                currentApp.state.preselectedLayoutBaseId = layoutBaseId;
                currentApp.state.currentTransactionMode = PropertyBarVM_1.TransactionMode.MoveLayoutMoleculeBeforeLayoutMolecule;
            } else {
                currentApp.state.preselectedLayoutBaseId = 0;
            }
        };
        this.moveLayoutRowBeforeRowClickHandler = function (evt) {
            var layoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            if (currentApp.state.preselectedLayoutBaseId != layoutBaseId) {
                currentApp.state.preselectedLayoutBaseId = layoutBaseId;
                currentApp.state.currentTransactionMode = PropertyBarVM_1.TransactionMode.MoveLayoutMoleculeBeforeLayoutMolecule;
            } else {
                currentApp.state.preselectedLayoutBaseId = 0;
            }
        };
        this.syncLayoutBaseStylesClickHandler = function (evt) {
            var layoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            if (currentApp.state.preselectedLayoutBaseId != layoutBaseId) {
                currentApp.state.preselectedLayoutBaseId = layoutBaseId;
                currentApp.state.currentTransactionMode = PropertyBarVM_1.TransactionMode.SyncLayoutStylesImitating;
            } else {
                currentApp.state.preselectedLayoutBaseId = 0;
            }
        };
        this.moveLayoutAtomIntoBoxClickHandler = function (evt) {
            var layoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            if (currentApp.state.preselectedLayoutBaseId != layoutBaseId) {
                currentApp.state.preselectedLayoutBaseId = layoutBaseId;
                currentApp.state.currentTransactionMode = PropertyBarVM_1.TransactionMode.MoveLayoutMoleculeIntoLayoutMolecule;
            } else {
                currentApp.state.preselectedLayoutBaseId = 0;
            }
        };
        this.createBoxForAtomInPlaceClickHandler = function (evt) {
            currentApp.state.selectedLayoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            _this.viewModel.currentSecondaryPopupMode = PropertyBarVM_1.PopupSecondaryMode.SelectBoxIntoBoxAtomInPlace;
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.SelectBox);
        };
        this.moveLayoutAtomBeforeAtomClickHandler = function (evt) {
            var layoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            if (currentApp.state.preselectedLayoutBaseId != layoutBaseId) {
                currentApp.state.preselectedLayoutBaseId = layoutBaseId;
                currentApp.state.currentTransactionMode = PropertyBarVM_1.TransactionMode.MoveLayoutMoleculeBeforeLayoutMolecule;
            } else {
                currentApp.state.preselectedLayoutBaseId = 0;
            }
        };
        this.moveLayoutAtomBeforeBoxClickHandler = function (evt) {
            var layoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            if (currentApp.state.preselectedLayoutBaseId != layoutBaseId) {
                currentApp.state.preselectedLayoutBaseId = layoutBaseId;
                currentApp.state.currentTransactionMode = PropertyBarVM_1.TransactionMode.MoveLayoutMoleculeBeforeLayoutMolecule;
            } else {
                currentApp.state.preselectedLayoutBaseId = 0;
            }
        };
        this.saveLayoutMoleculeClickHandler = function (evt) {
            currentApp.controller.SetLayoutRowOrBoxAsInstanceableJson(currentApp.clientData.CaliforniaProject.CaliforniaProjectId, CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.createViewForBoxClickHandler = function (evt) {
            console.log("TODO");
        };
        this.insertLayoutAtomIntoBoxClickHandler = function (evt) {
            currentApp.state.selectedLayoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.InsertLayoutAtomIntoBox);
        };
        this.insertLayoutBoxIntoBoxClickHandler = function (evt) {
            currentApp.state.selectedLayoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            _this.viewModel.currentSecondaryPopupMode = PropertyBarVM_1.PopupSecondaryMode.SelectBoxIntoBox;
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.SelectBox);
        };
        this.renderCaliforniaViewControlsWhenAll = function () {
            var isAddButtonEnabled = _this.currentPropertyBar.viewModel.tempCaliforniaViewName !== "";
            return h(
                "div",
                { key: "-1" },
                h("input", { key: "0", value: _this.currentPropertyBar.viewModel.tempCaliforniaViewName, oninput: _this.currentPropertyBar.californiaViewNameInputHandler }),
                isAddButtonEnabled ? h(
                    "button",
                    { key: "a", role: "button", onclick: _this.currentPropertyBar.createCaliforniaViewClickHandler },
                    "\u2714"
                ) : h(
                    "button",
                    { disabled: true, key: "a0", role: "button", onclick: _this.currentPropertyBar.createCaliforniaViewClickHandler },
                    "\u2714"
                ),
                isAddButtonEnabled ? h(
                    "button",
                    { key: "b", role: "button", onclick: _this.currentPropertyBar.createCaliforniaViewFromReferenceClickHandler },
                    "x2"
                ) : h(
                    "button",
                    { disabled: true, key: "b0", role: "button", onclick: _this.currentPropertyBar.createCaliforniaViewFromReferenceClickHandler },
                    "x2"
                )
            );
        };
        this.createCaliforniaViewFromReferenceClickHandler = function (evt) {
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.CaliforniaViewSelection);
        };
        this.createCaliforniaViewClickHandler = function (evt) {
            currentApp.controller.CreateCaliforniaViewJson(currentApp.clientData.CaliforniaProject.CaliforniaProjectId, _this.currentPropertyBar.viewModel.tempCaliforniaViewName).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.viewModel.tempCaliforniaViewName = "";
        };
        this.californiaViewNameInputHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCaliforniaViewName = evt.target.value;
        };
        this.renderCaliforniaViewSelectionPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.CaliforniaViewSelection;
            var renderedOptions = [];
            if (isPopupVisible === true) {
                currentApp.clientData.CaliforniaProject.CaliforniaViews.filter(function (m) {
                    return !m.IsInternal;
                }).map(function (m) {
                    var californiaViewIdString = m.CaliforniaViewId.toString();
                    renderedOptions.push(h(
                        "div",
                        { key: californiaViewIdString, styles: { "flex": "0 0 100%", "width": "100%", "min-width": "100%" } },
                        "view #",
                        californiaViewIdString,
                        ": ",
                        m.Name,
                        " ",
                        h(
                            "button",
                            { key: "a", role: "button", vid: californiaViewIdString, onclick: _this.currentPropertyBar.selectCaliforniaViewInPopupClickHandler },
                            "\u2714"
                        )
                    ));
                });
            }
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.CaliforniaViewSelection], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px" } },
                h(
                    "div",
                    { key: "0", styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "b", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelSelectCaliforniaViewPopupClickHandler },
                        "x"
                    )
                ),
                h(
                    "div",
                    { key: "1", styles: { "display": "flex", "flex-flow": "row wrap" } },
                    renderedOptions
                )
            );
        };
        this.selectCaliforniaViewInPopupClickHandler = function (evt) {
            currentApp.controller.CreateCaliforniaViewFromReferenceViewJson(currentApp.clientData.CaliforniaProject.CaliforniaProjectId, _this.currentPropertyBar.viewModel.tempCaliforniaViewName, CaliforniaApp_1.parseIntFromAttribute(evt.target, "vid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.viewModel.tempCaliforniaViewName = "";
            _this.currentPropertyBar.closePopup();
        };
        this.cancelSelectCaliforniaViewPopupClickHandler = function (evt) {
            _this.currentPropertyBar.closePopup();
        };
        this.renderCaliforniaViewControls = function () {
            if (_this.currentPropertyBar.viewModel.selectedCaliforniaViewId == 0) {
                return undefined;
            }
            var selectedCaliforniaView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (v) {
                return v.CaliforniaViewId == _this.currentPropertyBar.viewModel.selectedCaliforniaViewId;
            });
            var californiaViewIdString = selectedCaliforniaView.CaliforniaViewId.toString();
            var viewControlsButtonHolderStyles = {
                "flex": "0 0 auto",
                "height": "auto"
            };
            var viewControlsBoxTreeHolderStyles = {
                "flex": "1 1 1px",
                "width": "100%",
                "height": "auto",
                "overflow": "scroll"
            };
            var isSyncWithPreviewActive = _this.currentPropertyBar.propertyBarIndex == 0;
            var isSyncWithLeftActive = _this.currentPropertyBar.propertyBarIndex != 0;
            var isDrawHelperLinesActive = _this.currentPropertyBar.propertyBarIndex == 0;
            var syncWithLeftBoxTreeButtonStyles = {
                "outline": !isSyncWithLeftActive ? undefined : _this.currentPropertyBar.viewModel.isSyncedWithBoxTreeToTheLeft ? "solid 1px rgb(200,0,0)" : "solid 1px rgb(0,242,0)",
                "outline-offset": !isSyncWithLeftActive ? undefined : "-1px"
            };
            var syncWithPreviewButtonStyles = {
                "outline": !isSyncWithPreviewActive ? undefined : _this.currentPropertyBar.viewModel.isSyncedWithPagePreview ? "solid 1px rgb(200,0,0)" : "solid 1px rgb(0,242,0)",
                "outline-offset": !isSyncWithPreviewActive ? undefined : "-1px"
            };
            var drawHelperLinesButtonStyles = {
                "outline": !isDrawHelperLinesActive ? undefined : currentApp.state.isDrawHelperLines ? "solid 1px rgb(200,0,0)" : undefined,
                "outline-offset": !isDrawHelperLinesActive ? undefined : "-1px"
            };
            return h(
                "div",
                { styles: { "width": "100%", "height": "100%", "display": "flex", "flex-flow": "column nowrap" } },
                " View #",
                californiaViewIdString,
                h(
                    "div",
                    { key: "0", styles: viewControlsButtonHolderStyles },
                    h(
                        "button",
                        { key: "a", onclick: _this.currentPropertyBar.insertLayoutRowIntoViewClickHandler },
                        "+(R)"
                    ),
                    h(
                        "button",
                        { key: "b", mid: selectedCaliforniaView.SpecialStyleViewStyleMoleculeIdString, onclick: _this.currentPropertyBar.selectStyleMoleculeClickHandler },
                        "style #",
                        selectedCaliforniaView.SpecialStyleViewStyleMoleculeIdString
                    ),
                    h(
                        "button",
                        { key: "c", mid: selectedCaliforniaView.SpecialStyleBodyStyleMoleculeIdString, onclick: _this.currentPropertyBar.selectStyleMoleculeClickHandler },
                        "body style #",
                        selectedCaliforniaView.SpecialStyleBodyStyleMoleculeIdString
                    ),
                    h(
                        "button",
                        { key: "d", mid: selectedCaliforniaView.SpecialStyleHtmlStyleMoleculeIdString, onclick: _this.currentPropertyBar.selectStyleMoleculeClickHandler },
                        "HTML style #",
                        selectedCaliforniaView.SpecialStyleHtmlStyleMoleculeIdString
                    ),
                    h(
                        "button",
                        { key: "e", onclick: _this.currentPropertyBar.resetPreselectedLayoutClickHandler },
                        "o"
                    ),
                    isDrawHelperLinesActive ? h(
                        "button",
                        { key: "f", onclick: _this.currentPropertyBar.drawHelperLinesClickHandler, styles: drawHelperLinesButtonStyles },
                        "\\-\\"
                    ) : h(
                        "button",
                        { disabled: true, key: "f0", onclick: _this.currentPropertyBar.drawHelperLinesClickHandler, styles: drawHelperLinesButtonStyles },
                        "\\-\\"
                    ),
                    isSyncWithPreviewActive ? h(
                        "button",
                        { key: "g", onclick: _this.currentPropertyBar.syncWithPagePreviewClickHandler, styles: syncWithPreviewButtonStyles },
                        "-=-"
                    ) : h(
                        "button",
                        { disabled: true, key: "g0", onclick: _this.currentPropertyBar.syncWithPagePreviewClickHandler, styles: syncWithPreviewButtonStyles },
                        "-=-"
                    ),
                    isSyncWithLeftActive ? h(
                        "button",
                        { key: "h", onclick: _this.currentPropertyBar.syncWithLeftPropertyBarClickHandler, styles: syncWithLeftBoxTreeButtonStyles },
                        "=="
                    ) : h(
                        "button",
                        { disabled: true, key: "h0", onclick: _this.currentPropertyBar.syncWithLeftPropertyBarClickHandler, styles: syncWithLeftBoxTreeButtonStyles },
                        "=="
                    )
                ),
                h(
                    "div",
                    { key: "1", styles: viewControlsBoxTreeHolderStyles, onscroll: _this.currentPropertyBar.boxTreeScrollHandler, afterCreate: _this.currentPropertyBar.boxTreeAfterCreateHandler },
                    _this.currentPropertyBar.viewModel.boxTreeProjector.results.map(function (r) {
                        return r.renderMaquette();
                    })
                )
            );
        };
        this.boxTreeScrollHandler = function (evt) {
            var currentPropertyBarIndex = _this.currentPropertyBar.propertyBarIndex;
            var currentScrollDom = currentApp.propertyBarBoxTreeDomReferences[currentPropertyBarIndex];
            if (currentApp.state.visiblePropertyBarMaxCount > 1 && currentApp.propertyBarBoxTreeScrollHandled[currentPropertyBarIndex] === false) {
                currentApp.propertyBarBoxTreeScrollHandled[currentPropertyBarIndex] = true;
                var currentViewModel = _this.currentPropertyBar.viewModel;
                if (currentScrollDom === undefined) {
                    console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                    return;
                }
                var progressingPropertyBarIndex = currentPropertyBarIndex;
                var isKeepGoingLeft = currentPropertyBarIndex > 0;
                var currentIteration = 0;
                var maxIteration = currentPropertyBarIndex - 1;
                while (isKeepGoingLeft === true && progressingPropertyBarIndex > 0) {
                    if (currentApp.propertyBarVMs[progressingPropertyBarIndex].isSyncedWithBoxTreeToTheLeft) {
                        var targetScrollDom = currentApp.propertyBarBoxTreeDomReferences[progressingPropertyBarIndex - 1];
                        if (targetScrollDom !== undefined && targetScrollDom.scrollTop != currentScrollDom.scrollTop) {
                            currentApp.propertyBarBoxTreeScrollHandled[progressingPropertyBarIndex - 1] = true;
                            targetScrollDom.scrollTop = currentScrollDom.scrollTop;
                        }
                    } else {
                        isKeepGoingLeft = false;
                        break;
                    }
                    if (currentIteration > maxIteration) {
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                        break;
                    }
                    progressingPropertyBarIndex--;
                    currentIteration++;
                }
                progressingPropertyBarIndex = currentPropertyBarIndex + 1;
                var isKeepGoingRight = true;
                currentIteration = 0;
                maxIteration = currentApp.state.visiblePropertyBarMaxCount - 1 - currentPropertyBarIndex;
                while (isKeepGoingRight === true && progressingPropertyBarIndex < currentApp.state.visiblePropertyBarMaxCount) {
                    if (currentApp.propertyBarVMs[progressingPropertyBarIndex].isSyncedWithBoxTreeToTheLeft) {
                        var targetScrollDom = currentApp.propertyBarBoxTreeDomReferences[progressingPropertyBarIndex];
                        if (targetScrollDom !== undefined && targetScrollDom.scrollTop != currentScrollDom.scrollTop) {
                            currentApp.propertyBarBoxTreeScrollHandled[progressingPropertyBarIndex] = true;
                            targetScrollDom.scrollTop = currentScrollDom.scrollTop;
                        }
                    } else {
                        isKeepGoingRight = false;
                        break;
                    }
                    if (currentIteration > maxIteration) {
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                        break;
                    }
                    progressingPropertyBarIndex++;
                    currentIteration++;
                }
            } else {
                for (var i = 0; i < currentApp.state.visiblePropertyBarMaxCount; i++) {
                    currentApp.propertyBarBoxTreeScrollHandled[i] = false;
                }
            }
            if (currentPropertyBarIndex == 0 && _this.currentPropertyBar.viewModel.isSyncedWithPagePreview) {
                _this.currentPropertyBar._visibleLayoutAtomDomNodeReferences = [];
                _this.currentPropertyBar._visibleLayoutAtomKeys = [];
                _this.currentPropertyBar._mostUpperVisibleLayoutAtomId = 0;
                var processedElementCount = 0;
                var mostUpperVisibleIndex = -1;
                var mostUpperVisibleLayoutAtomId = 0;
                var mostUpperVisibleDeltaTopLeft = currentScrollDom.clientHeight + 1;
                var staticOffsetPx = currentScrollDom.getBoundingClientRect().top;
                var currentScrollTop = currentScrollDom.scrollTop;
                var minXPreview = 0;
                var maxXPreview = currentScrollDom.clientHeight;
                for (var elementKey in _this.currentPropertyBar._activeViewLayoutAtomDomNodeReferences) {
                    var domNode = _this.currentPropertyBar._activeViewLayoutAtomDomNodeReferences[elementKey];
                    var isDomNodeVisible = false;
                    var boundingRectElement = domNode.getBoundingClientRect();
                    var minXElementDeltaTopLeft = boundingRectElement.top - staticOffsetPx;
                    var maxXElementDeltaBottomLeft = currentScrollDom.clientHeight - (boundingRectElement.top - staticOffsetPx + currentScrollTop + boundingRectElement.height) + currentScrollTop;
                    if (boundingRectElement.height > 0) {
                        if (minXElementDeltaTopLeft >= 0.0 && minXElementDeltaTopLeft <= currentScrollDom.clientHeight) {
                            isDomNodeVisible = true;
                        } else if (maxXElementDeltaBottomLeft >= 0.0 && maxXElementDeltaBottomLeft <= currentScrollDom.clientHeight) {
                            isDomNodeVisible = true;
                        } else if (minXElementDeltaTopLeft <= 0.0 && maxXElementDeltaBottomLeft <= 0.0) {
                            isDomNodeVisible = true;
                        }
                    }
                    if (isDomNodeVisible) {
                        _this.currentPropertyBar._visibleLayoutAtomDomNodeReferences.push(domNode);
                        _this.currentPropertyBar._visibleLayoutAtomKeys.push(elementKey);
                        if (minXElementDeltaTopLeft < mostUpperVisibleDeltaTopLeft) {
                            mostUpperVisibleDeltaTopLeft = minXElementDeltaTopLeft;
                            mostUpperVisibleIndex = _this.currentPropertyBar._visibleLayoutAtomKeys.length;
                            mostUpperVisibleLayoutAtomId = CaliforniaApp_1.parseIntFromAttribute(domNode, "lid");
                        }
                    }
                    processedElementCount++;
                }
                if (mostUpperVisibleLayoutAtomId != _this.currentPropertyBar._mostUpperVisibleLayoutAtomId) {
                    _this.currentPropertyBar._mostUpperVisibleLayoutAtomId = mostUpperVisibleLayoutAtomId;
                    if (mostUpperVisibleLayoutAtomId != 0 && _this.currentPropertyBar.viewModel.isSyncedWithPagePreview) {
                        currentApp.pagePreview.syncScrollPositionFromBoxTree();
                    }
                }
            }
        };
        this.syncScrollPositionFromPagePreview = function () {
            if (_this.currentPropertyBar.viewModel.isSyncedWithPagePreview) {
                var currentPropertyBarIndex = _this.currentPropertyBar.propertyBarIndex;
                var currentScrollDom = currentApp.propertyBarBoxTreeDomReferences[currentPropertyBarIndex];
                if (currentScrollDom !== undefined) {
                    var staticOffsetPx = currentScrollDom.getBoundingClientRect().top;
                    var targetLayoutAtomId_1 = currentApp.pagePreview.mostUpperVisibleLayoutAtomId;
                    console.log("tree from preview for target layout #" + targetLayoutAtomId_1);
                    var domNodeOfTargetLayout = _this.currentPropertyBar._visibleLayoutAtomDomNodeReferences.find(function (r) {
                        return CaliforniaApp_1.parseIntFromAttribute(r, "lid") == targetLayoutAtomId_1;
                    });
                    if (domNodeOfTargetLayout === undefined) {
                        domNodeOfTargetLayout = _this.currentPropertyBar._activeViewLayoutAtomDomNodeReferences[targetLayoutAtomId_1];
                    }
                    if (domNodeOfTargetLayout !== undefined) {
                        currentScrollDom.scrollTop = currentScrollDom.scrollTop + (domNodeOfTargetLayout.getBoundingClientRect().top - staticOffsetPx);
                    } else {
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                    }
                } else {}
            }
        };
        this.boxTreeAfterCreateHandler = function (element, projectionOptions, vnodeSelector, properties, children) {
            currentApp.propertyBarBoxTreeDomReferences[_this.currentPropertyBar.propertyBarIndex] = element;
        };
        this.deleteCaliforniaViewClickHandler = function (evt) {
            var deleteCaliforniaViewId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "vid");
            currentApp.router.clearCaliforniaPropertyBars(false, deleteCaliforniaViewId);
            currentApp.controller.DeleteCaliforniaViewJson(deleteCaliforniaViewId).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.insertLayoutRowIntoViewClickHandler = function (evt) {
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.InsertLayoutRowIntoView);
        };
        this.resetPreselectedLayoutClickHandler = function (evt) {
            currentApp.state.preselectedLayoutBaseId = 0;
        };
        this.drawHelperLinesClickHandler = function (evt) {
            currentApp.state.isDrawHelperLines = !currentApp.state.isDrawHelperLines;
        };
        this.syncWithPagePreviewClickHandler = function (evt) {
            var currentPropertyBarIndex = _this.currentPropertyBar.propertyBarIndex;
            var currentViewModel = _this.currentPropertyBar.viewModel;
            if (currentPropertyBarIndex == 0) {
                currentViewModel.isSyncedWithPagePreview = !currentViewModel.isSyncedWithPagePreview;
                if (currentViewModel.isSyncedWithPagePreview) {
                    var currentBoxTreeDomReference = currentApp.propertyBarBoxTreeDomReferences[currentPropertyBarIndex];
                    if (currentBoxTreeDomReference !== undefined) {
                        if (currentBoxTreeDomReference.scrollTop <= 1.0) {
                            _this.currentPropertyBar.syncScrollPositionFromPagePreview();
                        } else {
                            currentApp.pagePreview.syncScrollPositionFromBoxTree();
                        }
                    }
                }
            }
        };
        this.syncWithLeftPropertyBarClickHandler = function (evt) {
            var currentPropertyBarIndex = _this.currentPropertyBar.propertyBarIndex;
            var currentViewModel = _this.currentPropertyBar.viewModel;
            if (currentPropertyBarIndex != 0 && currentApp.propertyBarVMs[currentPropertyBarIndex - 1].currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.CaliforniaView && currentApp.propertyBarVMs[currentPropertyBarIndex - 1].selectedCaliforniaViewId == currentViewModel.selectedCaliforniaViewId) {
                currentViewModel.isSyncedWithBoxTreeToTheLeft = !currentViewModel.isSyncedWithBoxTreeToTheLeft;
                if (currentViewModel.isSyncedWithBoxTreeToTheLeft === true) {
                    var currentBoxTreeDomReference = currentApp.propertyBarBoxTreeDomReferences[currentPropertyBarIndex];
                    var otherBoxTreeDomReference = currentApp.propertyBarBoxTreeDomReferences[currentPropertyBarIndex - 1];
                    if (currentBoxTreeDomReference !== undefined && otherBoxTreeDomReference !== undefined) {
                        otherBoxTreeDomReference.scrollTop = currentBoxTreeDomReference.scrollTop;
                    } else {
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                        currentViewModel.isSyncedWithBoxTreeToTheLeft = false;
                    }
                }
            } else {
                currentViewModel.isSyncedWithBoxTreeToTheLeft = false;
            }
        };
        currentApp = californiaAppArg;
        this.propertyBarIndex = targetIndex;
        this.viewModel = new PropertyBarVM_1.PropertyBarVM(this, targetIndex, californiaAppArg);
        this.viewModel.isSyncedWithBoxTreeToTheLeft = false;
        this.viewModel.isSyncedWithPagePreview = false;
    }
    ;
    Object.defineProperty(PropertyBar.prototype, "currentPropertyBar", {
        get: function get() {
            return currentApp.propertyBars[this.propertyBarIndex];
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PropertyBar.prototype, "nextExceptLastPropertyBar", {
        get: function get() {
            var nextPropertyBarIndex = this.propertyBarIndex + 1;
            if (nextPropertyBarIndex < currentApp.state.visiblePropertyBarMaxCount) {
                return currentApp.propertyBars[nextPropertyBarIndex];
            } else {
                return this.currentPropertyBar;
            }
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PropertyBar.prototype, "visibleLayoutAtomDomNodeReferences", {
        get: function get() {
            return this._visibleLayoutAtomDomNodeReferences;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PropertyBar.prototype, "visibleLayoutAtomKeys", {
        get: function get() {
            return this._visibleLayoutAtomKeys;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PropertyBar.prototype, "mostUpperVisibleLayoutAtomId", {
        get: function get() {
            return this._mostUpperVisibleLayoutAtomId;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PropertyBar.prototype, "activeViewLayoutAtomDomNodeReferences", {
        get: function get() {
            return this._activeViewLayoutAtomDomNodeReferences;
        },
        enumerable: true,
        configurable: true
    });
    ;
    return PropertyBar;
}();
exports.PropertyBar = PropertyBar;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(0)))

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery, jQuery) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! VelocityJS.org (1.5.0). (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License */

/*************************
 Velocity jQuery Shim
 *************************/

/*! VelocityJS.org jQuery Shim (1.0.1). (C) 2014 The jQuery Foundation. MIT @license: en.wikipedia.org/wiki/MIT_License. */

/* This file contains the jQuery functions that Velocity relies on, thereby removing Velocity's dependency on a full copy of jQuery, and allowing it to work in any environment. */
/* These shimmed functions are only used if jQuery isn't present. If both this shim and jQuery are loaded, Velocity defaults to jQuery proper. */
/* Browser support: Using this shim instead of jQuery proper removes support for IE8. */

(function(window) {
	"use strict";
	/***************
	 Setup
	 ***************/

	/* If jQuery is already loaded, there's no point in loading this shim. */
	if (__webpack_provided_window_dot_jQuery) {
		return;
	}

	/* jQuery base. */
	var $ = function(selector, context) {
		return new $.fn.init(selector, context);
	};

	/********************
	 Private Methods
	 ********************/

	/* jQuery */
	$.isWindow = function(obj) {
		/* jshint eqeqeq: false */
		return obj && obj === obj.window;
	};

	/* jQuery */
	$.type = function(obj) {
		if (!obj) {
			return obj + "";
		}

		return typeof obj === "object" || typeof obj === "function" ?
				class2type[toString.call(obj)] || "object" :
				typeof obj;
	};

	/* jQuery */
	$.isArray = Array.isArray || function(obj) {
		return $.type(obj) === "array";
	};

	/* jQuery */
	function isArraylike(obj) {
		var length = obj.length,
				type = $.type(obj);

		if (type === "function" || $.isWindow(obj)) {
			return false;
		}

		if (obj.nodeType === 1 && length) {
			return true;
		}

		return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
	}

	/***************
	 $ Methods
	 ***************/

	/* jQuery: Support removed for IE<9. */
	$.isPlainObject = function(obj) {
		var key;

		if (!obj || $.type(obj) !== "object" || obj.nodeType || $.isWindow(obj)) {
			return false;
		}

		try {
			if (obj.constructor &&
					!hasOwn.call(obj, "constructor") &&
					!hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
				return false;
			}
		} catch (e) {
			return false;
		}

		for (key in obj) {
		}

		return key === undefined || hasOwn.call(obj, key);
	};

	/* jQuery */
	$.each = function(obj, callback, args) {
		var value,
				i = 0,
				length = obj.length,
				isArray = isArraylike(obj);

		if (args) {
			if (isArray) {
				for (; i < length; i++) {
					value = callback.apply(obj[i], args);

					if (value === false) {
						break;
					}
				}
			} else {
				for (i in obj) {
					if (!obj.hasOwnProperty(i)) {
						continue;
					}
					value = callback.apply(obj[i], args);

					if (value === false) {
						break;
					}
				}
			}

		} else {
			if (isArray) {
				for (; i < length; i++) {
					value = callback.call(obj[i], i, obj[i]);

					if (value === false) {
						break;
					}
				}
			} else {
				for (i in obj) {
					if (!obj.hasOwnProperty(i)) {
						continue;
					}
					value = callback.call(obj[i], i, obj[i]);

					if (value === false) {
						break;
					}
				}
			}
		}

		return obj;
	};

	/* Custom */
	$.data = function(node, key, value) {
		/* $.getData() */
		if (value === undefined) {
			var getId = node[$.expando],
					store = getId && cache[getId];

			if (key === undefined) {
				return store;
			} else if (store) {
				if (key in store) {
					return store[key];
				}
			}
			/* $.setData() */
		} else if (key !== undefined) {
			var setId = node[$.expando] || (node[$.expando] = ++$.uuid);

			cache[setId] = cache[setId] || {};
			cache[setId][key] = value;

			return value;
		}
	};

	/* Custom */
	$.removeData = function(node, keys) {
		var id = node[$.expando],
				store = id && cache[id];

		if (store) {
			// Cleanup the entire store if no keys are provided.
			if (!keys) {
				delete cache[id];
			} else {
				$.each(keys, function(_, key) {
					delete store[key];
				});
			}
		}
	};

	/* jQuery */
	$.extend = function() {
		var src, copyIsArray, copy, name, options, clone,
				target = arguments[0] || {},
				i = 1,
				length = arguments.length,
				deep = false;

		if (typeof target === "boolean") {
			deep = target;

			target = arguments[i] || {};
			i++;
		}

		if (typeof target !== "object" && $.type(target) !== "function") {
			target = {};
		}

		if (i === length) {
			target = this;
			i--;
		}

		for (; i < length; i++) {
			if ((options = arguments[i])) {
				for (name in options) {
					if (!options.hasOwnProperty(name)) {
						continue;
					}
					src = target[name];
					copy = options[name];

					if (target === copy) {
						continue;
					}

					if (deep && copy && ($.isPlainObject(copy) || (copyIsArray = $.isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && $.isArray(src) ? src : [];

						} else {
							clone = src && $.isPlainObject(src) ? src : {};
						}

						target[name] = $.extend(deep, clone, copy);

					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}

		return target;
	};

	/* jQuery 1.4.3 */
	$.queue = function(elem, type, data) {
		function $makeArray(arr, results) {
			var ret = results || [];

			if (arr) {
				if (isArraylike(Object(arr))) {
					/* $.merge */
					(function(first, second) {
						var len = +second.length,
								j = 0,
								i = first.length;

						while (j < len) {
							first[i++] = second[j++];
						}

						if (len !== len) {
							while (second[j] !== undefined) {
								first[i++] = second[j++];
							}
						}

						first.length = i;

						return first;
					})(ret, typeof arr === "string" ? [arr] : arr);
				} else {
					[].push.call(ret, arr);
				}
			}

			return ret;
		}

		if (!elem) {
			return;
		}

		type = (type || "fx") + "queue";

		var q = $.data(elem, type);

		if (!data) {
			return q || [];
		}

		if (!q || $.isArray(data)) {
			q = $.data(elem, type, $makeArray(data));
		} else {
			q.push(data);
		}

		return q;
	};

	/* jQuery 1.4.3 */
	$.dequeue = function(elems, type) {
		/* Custom: Embed element iteration. */
		$.each(elems.nodeType ? [elems] : elems, function(i, elem) {
			type = type || "fx";

			var queue = $.queue(elem, type),
					fn = queue.shift();

			if (fn === "inprogress") {
				fn = queue.shift();
			}

			if (fn) {
				if (type === "fx") {
					queue.unshift("inprogress");
				}

				fn.call(elem, function() {
					$.dequeue(elem, type);
				});
			}
		});
	};

	/******************
	 $.fn Methods
	 ******************/

	/* jQuery */
	$.fn = $.prototype = {
		init: function(selector) {
			/* Just return the element wrapped inside an array; don't proceed with the actual jQuery node wrapping process. */
			if (selector.nodeType) {
				this[0] = selector;

				return this;
			} else {
				throw new Error("Not a DOM node.");
			}
		},
		offset: function() {
			/* jQuery altered code: Dropped disconnected DOM node checking. */
			var box = this[0].getBoundingClientRect ? this[0].getBoundingClientRect() : {top: 0, left: 0};

			return {
				top: box.top + (window.pageYOffset || document.scrollTop || 0) - (document.clientTop || 0),
				left: box.left + (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || 0)
			};
		},
		position: function() {
			/* jQuery */
			function offsetParentFn(elem) {
				var offsetParent = elem.offsetParent;

				while (offsetParent && (offsetParent.nodeName.toLowerCase() !== "html" && offsetParent.style && offsetParent.style.position.toLowerCase() === "static")) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || document;
			}

			/* Zepto */
			var elem = this[0],
					offsetParent = offsetParentFn(elem),
					offset = this.offset(),
					parentOffset = /^(?:body|html)$/i.test(offsetParent.nodeName) ? {top: 0, left: 0} : $(offsetParent).offset();

			offset.top -= parseFloat(elem.style.marginTop) || 0;
			offset.left -= parseFloat(elem.style.marginLeft) || 0;

			if (offsetParent.style) {
				parentOffset.top += parseFloat(offsetParent.style.borderTopWidth) || 0;
				parentOffset.left += parseFloat(offsetParent.style.borderLeftWidth) || 0;
			}

			return {
				top: offset.top - parentOffset.top,
				left: offset.left - parentOffset.left
			};
		}
	};

	/**********************
	 Private Variables
	 **********************/

	/* For $.data() */
	var cache = {};
	$.expando = "velocity" + (new Date().getTime());
	$.uuid = 0;

	/* For $.queue() */
	var class2type = {},
			hasOwn = class2type.hasOwnProperty,
			toString = class2type.toString;

	var types = "Boolean Number String Function Array Date RegExp Object Error".split(" ");
	for (var i = 0; i < types.length; i++) {
		class2type["[object " + types[i] + "]"] = types[i].toLowerCase();
	}

	/* Makes $(node) possible, without having to call init. */
	$.fn.init.prototype = $.fn;

	/* Globalize Velocity onto the window, and assign its Utilities property. */
	window.Velocity = {Utilities: $};
})(window);

/******************
 Velocity.js
 ******************/

(function(factory) {
	"use strict";
	/* CommonJS module. */
	if (typeof module === "object" && typeof module.exports === "object") {
		module.exports = factory();
		/* AMD module. */
	} else if (true) {
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		/* Browser globals. */
	} else {
		factory();
	}
}(function() {
	"use strict";
	return function(global, window, document, undefined) {

		/***************
		 Summary
		 ***************/

		/*
		 - CSS: CSS stack that works independently from the rest of Velocity.
		 - animate(): Core animation method that iterates over the targeted elements and queues the incoming call onto each element individually.
		 - Pre-Queueing: Prepare the element for animation by instantiating its data cache and processing the call's options.
		 - Queueing: The logic that runs once the call has reached its point of execution in the element's $.queue() stack.
		 Most logic is placed here to avoid risking it becoming stale (if the element's properties have changed).
		 - Pushing: Consolidation of the tween data followed by its push onto the global in-progress calls container.
		 - tick(): The single requestAnimationFrame loop responsible for tweening all in-progress calls.
		 - completeCall(): Handles the cleanup process for each Velocity call.
		 */

		/*********************
		 Helper Functions
		 *********************/

		/* IE detection. Gist: https://gist.github.com/julianshapiro/9098609 */
		var IE = (function() {
			if (document.documentMode) {
				return document.documentMode;
			} else {
				for (var i = 7; i > 4; i--) {
					var div = document.createElement("div");

					div.innerHTML = "<!--[if IE " + i + "]><span></span><![endif]-->";

					if (div.getElementsByTagName("span").length) {
						div = null;

						return i;
					}
				}
			}

			return undefined;
		})();

		/* rAF shim. Gist: https://gist.github.com/julianshapiro/9497513 */
		var rAFShim = (function() {
			var timeLast = 0;

			return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
				var timeCurrent = (new Date()).getTime(),
						timeDelta;

				/* Dynamically set delay on a per-tick basis to match 60fps. */
				/* Technique by Erik Moller. MIT license: https://gist.github.com/paulirish/1579671 */
				timeDelta = Math.max(0, 16 - (timeCurrent - timeLast));
				timeLast = timeCurrent + timeDelta;

				return setTimeout(function() {
					callback(timeCurrent + timeDelta);
				}, timeDelta);
			};
		})();

		var performance = (function() {
			var perf = window.performance || {};

			if (typeof perf.now !== "function") {
				var nowOffset = perf.timing && perf.timing.navigationStart ? perf.timing.navigationStart : (new Date()).getTime();

				perf.now = function() {
					return (new Date()).getTime() - nowOffset;
				};
			}
			return perf;
		})();

		/* Array compacting. Copyright Lo-Dash. MIT License: https://github.com/lodash/lodash/blob/master/LICENSE.txt */
		function compactSparseArray(array) {
			var index = -1,
					length = array ? array.length : 0,
					result = [];

			while (++index < length) {
				var value = array[index];

				if (value) {
					result.push(value);
				}
			}

			return result;
		}

		/**
		 * Shim for "fixing" IE's lack of support (IE < 9) for applying slice
		 * on host objects like NamedNodeMap, NodeList, and HTMLCollection
		 * (technically, since host objects have been implementation-dependent,
		 * at least before ES2015, IE hasn't needed to work this way).
		 * Also works on strings, fixes IE < 9 to allow an explicit undefined
		 * for the 2nd argument (as in Firefox), and prevents errors when
		 * called on other DOM objects.
		 */
		var _slice = (function() {
			var slice = Array.prototype.slice;

			try {
				// Can't be used with DOM elements in IE < 9
				slice.call(document.documentElement);
				return slice;
			} catch (e) { // Fails in IE < 9

				// This will work for genuine arrays, array-like objects, 
				// NamedNodeMap (attributes, entities, notations),
				// NodeList (e.g., getElementsByTagName), HTMLCollection (e.g., childNodes),
				// and will not fail on other DOM objects (as do DOM elements in IE < 9)
				return function(begin, end) {
					var len = this.length;

					if (typeof begin !== "number") {
						begin = 0;
					}
					// IE < 9 gets unhappy with an undefined end argument
					if (typeof end !== "number") {
						end = len;
					}
					// For native Array objects, we use the native slice function
					if (this.slice) {
						return slice.call(this, begin, end);
					}
					// For array like object we handle it ourselves.
					var i,
							cloned = [],
							// Handle negative value for "begin"
							start = (begin >= 0) ? begin : Math.max(0, len + begin),
							// Handle negative value for "end"
							upTo = end < 0 ? len + end : Math.min(end, len),
							// Actual expected size of the slice
							size = upTo - start;

					if (size > 0) {
						cloned = new Array(size);
						if (this.charAt) {
							for (i = 0; i < size; i++) {
								cloned[i] = this.charAt(start + i);
							}
						} else {
							for (i = 0; i < size; i++) {
								cloned[i] = this[start + i];
							}
						}
					}
					return cloned;
				};
			}
		})();

		/* .indexOf doesn't exist in IE<9 */
		var _inArray = (function() {
			if (Array.prototype.includes) {
				return function(arr, val) {
					return arr.includes(val);
				};
			}
			if (Array.prototype.indexOf) {
				return function(arr, val) {
					return arr.indexOf(val) >= 0;
				};
			}
			return function(arr, val) {
				for (var i = 0; i < arr.length; i++) {
					if (arr[i] === val) {
						return true;
					}
				}
				return false;
			};
		});

		function sanitizeElements(elements) {
			/* Unwrap jQuery/Zepto objects. */
			if (Type.isWrapped(elements)) {
				elements = _slice.call(elements);
				/* Wrap a single element in an array so that $.each() can iterate with the element instead of its node's children. */
			} else if (Type.isNode(elements)) {
				elements = [elements];
			}

			return elements;
		}

		var Type = {
			isNumber: function(variable) {
				return (typeof variable === "number");
			},
			isString: function(variable) {
				return (typeof variable === "string");
			},
			isArray: Array.isArray || function(variable) {
				return Object.prototype.toString.call(variable) === "[object Array]";
			},
			isFunction: function(variable) {
				return Object.prototype.toString.call(variable) === "[object Function]";
			},
			isNode: function(variable) {
				return variable && variable.nodeType;
			},
			/* Determine if variable is an array-like wrapped jQuery, Zepto or similar element, or even a NodeList etc. */
			/* NOTE: HTMLFormElements also have a length. */
			isWrapped: function(variable) {
				return variable
						&& variable !== window
						&& Type.isNumber(variable.length)
						&& !Type.isString(variable)
						&& !Type.isFunction(variable)
						&& !Type.isNode(variable)
						&& (variable.length === 0 || Type.isNode(variable[0]));
			},
			isSVG: function(variable) {
				return window.SVGElement && (variable instanceof window.SVGElement);
			},
			isEmptyObject: function(variable) {
				for (var name in variable) {
					if (variable.hasOwnProperty(name)) {
						return false;
					}
				}

				return true;
			}
		};

		/*****************
		 Dependencies
		 *****************/

		var $,
				isJQuery = false;

		if (global.fn && global.fn.jquery) {
			$ = global;
			isJQuery = true;
		} else {
			$ = window.Velocity.Utilities;
		}

		if (IE <= 8 && !isJQuery) {
			throw new Error("Velocity: IE8 and below require jQuery to be loaded before Velocity.");
		} else if (IE <= 7) {
			/* Revert to jQuery's $.animate(), and lose Velocity's extra features. */
			jQuery.fn.velocity = jQuery.fn.animate;

			/* Now that $.fn.velocity is aliased, abort this Velocity declaration. */
			return;
		}

		/*****************
		 Constants
		 *****************/

		var DURATION_DEFAULT = 400,
				EASING_DEFAULT = "swing";

		/*************
		 State
		 *************/

		var Velocity = {
			/* Container for page-wide Velocity state data. */
			State: {
				/* Detect mobile devices to determine if mobileHA should be turned on. */
				isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(window.navigator.userAgent),
				/* The mobileHA option's behavior changes on older Android devices (Gingerbread, versions 2.3.3-2.3.7). */
				isAndroid: /Android/i.test(window.navigator.userAgent),
				isGingerbread: /Android 2\.3\.[3-7]/i.test(window.navigator.userAgent),
				isChrome: window.chrome,
				isFirefox: /Firefox/i.test(window.navigator.userAgent),
				/* Create a cached element for re-use when checking for CSS property prefixes. */
				prefixElement: document.createElement("div"),
				/* Cache every prefix match to avoid repeating lookups. */
				prefixMatches: {},
				/* Cache the anchor used for animating window scrolling. */
				scrollAnchor: null,
				/* Cache the browser-specific property names associated with the scroll anchor. */
				scrollPropertyLeft: null,
				scrollPropertyTop: null,
				/* Keep track of whether our RAF tick is running. */
				isTicking: false,
				/* Container for every in-progress call to Velocity. */
				calls: [],
				delayedElements: {
					count: 0
				}
			},
			/* Velocity's custom CSS stack. Made global for unit testing. */
			CSS: {/* Defined below. */},
			/* A shim of the jQuery utility functions used by Velocity -- provided by Velocity's optional jQuery shim. */
			Utilities: $,
			/* Container for the user's custom animation redirects that are referenced by name in place of the properties map argument. */
			Redirects: {/* Manually registered by the user. */},
			Easings: {/* Defined below. */},
			/* Attempt to use ES6 Promises by default. Users can override this with a third-party promises library. */
			Promise: window.Promise,
			/* Velocity option defaults, which can be overriden by the user. */
			defaults: {
				queue: "",
				duration: DURATION_DEFAULT,
				easing: EASING_DEFAULT,
				begin: undefined,
				complete: undefined,
				progress: undefined,
				display: undefined,
				visibility: undefined,
				loop: false,
				delay: false,
				mobileHA: true,
				/* Advanced: Set to false to prevent property values from being cached between consecutive Velocity-initiated chain calls. */
				_cacheValues: true,
				/* Advanced: Set to false if the promise should always resolve on empty element lists. */
				promiseRejectEmpty: true
			},
			/* A design goal of Velocity is to cache data wherever possible in order to avoid DOM requerying. Accordingly, each element has a data cache. */
			init: function(element) {
				$.data(element, "velocity", {
					/* Store whether this is an SVG element, since its properties are retrieved and updated differently than standard HTML elements. */
					isSVG: Type.isSVG(element),
					/* Keep track of whether the element is currently being animated by Velocity.
					 This is used to ensure that property values are not transferred between non-consecutive (stale) calls. */
					isAnimating: false,
					/* A reference to the element's live computedStyle object. Learn more here: https://developer.mozilla.org/en/docs/Web/API/window.getComputedStyle */
					computedStyle: null,
					/* Tween data is cached for each animation on the element so that data can be passed across calls --
					 in particular, end values are used as subsequent start values in consecutive Velocity calls. */
					tweensContainer: null,
					/* The full root property values of each CSS hook being animated on this element are cached so that:
					 1) Concurrently-animating hooks sharing the same root can have their root values' merged into one while tweening.
					 2) Post-hook-injection root values can be transferred over to consecutively chained Velocity calls as starting root values. */
					rootPropertyValueCache: {},
					/* A cache for transform updates, which must be manually flushed via CSS.flushTransformCache(). */
					transformCache: {}
				});
			},
			/* A parallel to jQuery's $.css(), used for getting/setting Velocity's hooked CSS properties. */
			hook: null, /* Defined below. */
			/* Velocity-wide animation time remapping for testing purposes. */
			mock: false,
			version: {major: 1, minor: 5, patch: 1},
			/* Set to 1 or 2 (most verbose) to output debug info to console. */
			debug: false,
			/* Use rAF high resolution timestamp when available */
			timestamp: true,
			/* Pause all animations */
			pauseAll: function(queueName) {
				var currentTime = (new Date()).getTime();

				$.each(Velocity.State.calls, function(i, activeCall) {

					if (activeCall) {

						/* If we have a queueName and this call is not on that queue, skip */
						if (queueName !== undefined && ((activeCall[2].queue !== queueName) || (activeCall[2].queue === false))) {
							return true;
						}

						/* Set call to paused */
						activeCall[5] = {
							resume: false
						};
					}
				});

				/* Pause timers on any currently delayed calls */
				$.each(Velocity.State.delayedElements, function(k, element) {
					if (!element) {
						return;
					}
					pauseDelayOnElement(element, currentTime);
				});
			},
			/* Resume all animations */
			resumeAll: function(queueName) {
				var currentTime = (new Date()).getTime();

				$.each(Velocity.State.calls, function(i, activeCall) {

					if (activeCall) {

						/* If we have a queueName and this call is not on that queue, skip */
						if (queueName !== undefined && ((activeCall[2].queue !== queueName) || (activeCall[2].queue === false))) {
							return true;
						}

						/* Set call to resumed if it was paused */
						if (activeCall[5]) {
							activeCall[5].resume = true;
						}
					}
				});
				/* Resume timers on any currently delayed calls */
				$.each(Velocity.State.delayedElements, function(k, element) {
					if (!element) {
						return;
					}
					resumeDelayOnElement(element, currentTime);
				});
			}
		};

		/* Retrieve the appropriate scroll anchor and property name for the browser: https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY */
		if (window.pageYOffset !== undefined) {
			Velocity.State.scrollAnchor = window;
			Velocity.State.scrollPropertyLeft = "pageXOffset";
			Velocity.State.scrollPropertyTop = "pageYOffset";
		} else {
			Velocity.State.scrollAnchor = document.documentElement || document.body.parentNode || document.body;
			Velocity.State.scrollPropertyLeft = "scrollLeft";
			Velocity.State.scrollPropertyTop = "scrollTop";
		}

		/* Shorthand alias for jQuery's $.data() utility. */
		function Data(element) {
			/* Hardcode a reference to the plugin name. */
			var response = $.data(element, "velocity");

			/* jQuery <=1.4.2 returns null instead of undefined when no match is found. We normalize this behavior. */
			return response === null ? undefined : response;
		}

		/**************
		 Delay Timer
		 **************/

		function pauseDelayOnElement(element, currentTime) {
			/* Check for any delay timers, and pause the set timeouts (while preserving time data)
			 to be resumed when the "resume" command is issued */
			var data = Data(element);
			if (data && data.delayTimer && !data.delayPaused) {
				data.delayRemaining = data.delay - currentTime + data.delayBegin;
				data.delayPaused = true;
				clearTimeout(data.delayTimer.setTimeout);
			}
		}

		function resumeDelayOnElement(element, currentTime) {
			/* Check for any paused timers and resume */
			var data = Data(element);
			if (data && data.delayTimer && data.delayPaused) {
				/* If the element was mid-delay, re initiate the timeout with the remaining delay */
				data.delayPaused = false;
				data.delayTimer.setTimeout = setTimeout(data.delayTimer.next, data.delayRemaining);
			}
		}



		/**************
		 Easing
		 **************/

		/* Step easing generator. */
		function generateStep(steps) {
			return function(p) {
				return Math.round(p * steps) * (1 / steps);
			};
		}

		/* Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */
		function generateBezier(mX1, mY1, mX2, mY2) {
			var NEWTON_ITERATIONS = 4,
					NEWTON_MIN_SLOPE = 0.001,
					SUBDIVISION_PRECISION = 0.0000001,
					SUBDIVISION_MAX_ITERATIONS = 10,
					kSplineTableSize = 11,
					kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),
					float32ArraySupported = "Float32Array" in window;

			/* Must contain four arguments. */
			if (arguments.length !== 4) {
				return false;
			}

			/* Arguments must be numbers. */
			for (var i = 0; i < 4; ++i) {
				if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
					return false;
				}
			}

			/* X values must be in the [0, 1] range. */
			mX1 = Math.min(mX1, 1);
			mX2 = Math.min(mX2, 1);
			mX1 = Math.max(mX1, 0);
			mX2 = Math.max(mX2, 0);

			var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

			function A(aA1, aA2) {
				return 1.0 - 3.0 * aA2 + 3.0 * aA1;
			}
			function B(aA1, aA2) {
				return 3.0 * aA2 - 6.0 * aA1;
			}
			function C(aA1) {
				return 3.0 * aA1;
			}

			function calcBezier(aT, aA1, aA2) {
				return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
			}

			function getSlope(aT, aA1, aA2) {
				return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
			}

			function newtonRaphsonIterate(aX, aGuessT) {
				for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
					var currentSlope = getSlope(aGuessT, mX1, mX2);

					if (currentSlope === 0.0) {
						return aGuessT;
					}

					var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
					aGuessT -= currentX / currentSlope;
				}

				return aGuessT;
			}

			function calcSampleValues() {
				for (var i = 0; i < kSplineTableSize; ++i) {
					mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
				}
			}

			function binarySubdivide(aX, aA, aB) {
				var currentX, currentT, i = 0;

				do {
					currentT = aA + (aB - aA) / 2.0;
					currentX = calcBezier(currentT, mX1, mX2) - aX;
					if (currentX > 0.0) {
						aB = currentT;
					} else {
						aA = currentT;
					}
				} while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

				return currentT;
			}

			function getTForX(aX) {
				var intervalStart = 0.0,
						currentSample = 1,
						lastSample = kSplineTableSize - 1;

				for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
					intervalStart += kSampleStepSize;
				}

				--currentSample;

				var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),
						guessForT = intervalStart + dist * kSampleStepSize,
						initialSlope = getSlope(guessForT, mX1, mX2);

				if (initialSlope >= NEWTON_MIN_SLOPE) {
					return newtonRaphsonIterate(aX, guessForT);
				} else if (initialSlope === 0.0) {
					return guessForT;
				} else {
					return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
				}
			}

			var _precomputed = false;

			function precompute() {
				_precomputed = true;
				if (mX1 !== mY1 || mX2 !== mY2) {
					calcSampleValues();
				}
			}

			var f = function(aX) {
				if (!_precomputed) {
					precompute();
				}
				if (mX1 === mY1 && mX2 === mY2) {
					return aX;
				}
				if (aX === 0) {
					return 0;
				}
				if (aX === 1) {
					return 1;
				}

				return calcBezier(getTForX(aX), mY1, mY2);
			};

			f.getControlPoints = function() {
				return [{x: mX1, y: mY1}, {x: mX2, y: mY2}];
			};

			var str = "generateBezier(" + [mX1, mY1, mX2, mY2] + ")";
			f.toString = function() {
				return str;
			};

			return f;
		}

		/* Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */
		/* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
		 then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */
		var generateSpringRK4 = (function() {
			function springAccelerationForState(state) {
				return (-state.tension * state.x) - (state.friction * state.v);
			}

			function springEvaluateStateWithDerivative(initialState, dt, derivative) {
				var state = {
					x: initialState.x + derivative.dx * dt,
					v: initialState.v + derivative.dv * dt,
					tension: initialState.tension,
					friction: initialState.friction
				};

				return {dx: state.v, dv: springAccelerationForState(state)};
			}

			function springIntegrateState(state, dt) {
				var a = {
					dx: state.v,
					dv: springAccelerationForState(state)
				},
						b = springEvaluateStateWithDerivative(state, dt * 0.5, a),
						c = springEvaluateStateWithDerivative(state, dt * 0.5, b),
						d = springEvaluateStateWithDerivative(state, dt, c),
						dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),
						dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);

				state.x = state.x + dxdt * dt;
				state.v = state.v + dvdt * dt;

				return state;
			}

			return function springRK4Factory(tension, friction, duration) {

				var initState = {
					x: -1,
					v: 0,
					tension: null,
					friction: null
				},
						path = [0],
						time_lapsed = 0,
						tolerance = 1 / 10000,
						DT = 16 / 1000,
						have_duration, dt, last_state;

				tension = parseFloat(tension) || 500;
				friction = parseFloat(friction) || 20;
				duration = duration || null;

				initState.tension = tension;
				initState.friction = friction;

				have_duration = duration !== null;

				/* Calculate the actual time it takes for this animation to complete with the provided conditions. */
				if (have_duration) {
					/* Run the simulation without a duration. */
					time_lapsed = springRK4Factory(tension, friction);
					/* Compute the adjusted time delta. */
					dt = time_lapsed / duration * DT;
				} else {
					dt = DT;
				}

				while (true) {
					/* Next/step function .*/
					last_state = springIntegrateState(last_state || initState, dt);
					/* Store the position. */
					path.push(1 + last_state.x);
					time_lapsed += 16;
					/* If the change threshold is reached, break. */
					if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {
						break;
					}
				}

				/* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
				 computed path and returns a snapshot of the position according to a given percentComplete. */
				return !have_duration ? time_lapsed : function(percentComplete) {
					return path[ (percentComplete * (path.length - 1)) | 0 ];
				};
			};
		}());

		/* jQuery easings. */
		Velocity.Easings = {
			linear: function(p) {
				return p;
			},
			swing: function(p) {
				return 0.5 - Math.cos(p * Math.PI) / 2;
			},
			/* Bonus "spring" easing, which is a less exaggerated version of easeInOutElastic. */
			spring: function(p) {
				return 1 - (Math.cos(p * 4.5 * Math.PI) * Math.exp(-p * 6));
			}
		};

		/* CSS3 and Robert Penner easings. */
		$.each(
				[
					["ease", [0.25, 0.1, 0.25, 1.0]],
					["ease-in", [0.42, 0.0, 1.00, 1.0]],
					["ease-out", [0.00, 0.0, 0.58, 1.0]],
					["ease-in-out", [0.42, 0.0, 0.58, 1.0]],
					["easeInSine", [0.47, 0, 0.745, 0.715]],
					["easeOutSine", [0.39, 0.575, 0.565, 1]],
					["easeInOutSine", [0.445, 0.05, 0.55, 0.95]],
					["easeInQuad", [0.55, 0.085, 0.68, 0.53]],
					["easeOutQuad", [0.25, 0.46, 0.45, 0.94]],
					["easeInOutQuad", [0.455, 0.03, 0.515, 0.955]],
					["easeInCubic", [0.55, 0.055, 0.675, 0.19]],
					["easeOutCubic", [0.215, 0.61, 0.355, 1]],
					["easeInOutCubic", [0.645, 0.045, 0.355, 1]],
					["easeInQuart", [0.895, 0.03, 0.685, 0.22]],
					["easeOutQuart", [0.165, 0.84, 0.44, 1]],
					["easeInOutQuart", [0.77, 0, 0.175, 1]],
					["easeInQuint", [0.755, 0.05, 0.855, 0.06]],
					["easeOutQuint", [0.23, 1, 0.32, 1]],
					["easeInOutQuint", [0.86, 0, 0.07, 1]],
					["easeInExpo", [0.95, 0.05, 0.795, 0.035]],
					["easeOutExpo", [0.19, 1, 0.22, 1]],
					["easeInOutExpo", [1, 0, 0, 1]],
					["easeInCirc", [0.6, 0.04, 0.98, 0.335]],
					["easeOutCirc", [0.075, 0.82, 0.165, 1]],
					["easeInOutCirc", [0.785, 0.135, 0.15, 0.86]]
				], function(i, easingArray) {
			Velocity.Easings[easingArray[0]] = generateBezier.apply(null, easingArray[1]);
		});

		/* Determine the appropriate easing type given an easing input. */
		function getEasing(value, duration) {
			var easing = value;

			/* The easing option can either be a string that references a pre-registered easing,
			 or it can be a two-/four-item array of integers to be converted into a bezier/spring function. */
			if (Type.isString(value)) {
				/* Ensure that the easing has been assigned to jQuery's Velocity.Easings object. */
				if (!Velocity.Easings[value]) {
					easing = false;
				}
			} else if (Type.isArray(value) && value.length === 1) {
				easing = generateStep.apply(null, value);
			} else if (Type.isArray(value) && value.length === 2) {
				/* springRK4 must be passed the animation's duration. */
				/* Note: If the springRK4 array contains non-numbers, generateSpringRK4() returns an easing
				 function generated with default tension and friction values. */
				easing = generateSpringRK4.apply(null, value.concat([duration]));
			} else if (Type.isArray(value) && value.length === 4) {
				/* Note: If the bezier array contains non-numbers, generateBezier() returns false. */
				easing = generateBezier.apply(null, value);
			} else {
				easing = false;
			}

			/* Revert to the Velocity-wide default easing type, or fall back to "swing" (which is also jQuery's default)
			 if the Velocity-wide default has been incorrectly modified. */
			if (easing === false) {
				if (Velocity.Easings[Velocity.defaults.easing]) {
					easing = Velocity.defaults.easing;
				} else {
					easing = EASING_DEFAULT;
				}
			}

			return easing;
		}

		/*****************
		 CSS Stack
		 *****************/

		/* The CSS object is a highly condensed and performant CSS stack that fully replaces jQuery's.
		 It handles the validation, getting, and setting of both standard CSS properties and CSS property hooks. */
		/* Note: A "CSS" shorthand is aliased so that our code is easier to read. */
		var CSS = Velocity.CSS = {
			/*************
			 RegEx
			 *************/

			RegEx: {
				isHex: /^#([A-f\d]{3}){1,2}$/i,
				/* Unwrap a property value's surrounding text, e.g. "rgba(4, 3, 2, 1)" ==> "4, 3, 2, 1" and "rect(4px 3px 2px 1px)" ==> "4px 3px 2px 1px". */
				valueUnwrap: /^[A-z]+\((.*)\)$/i,
				wrappedValueAlreadyExtracted: /[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/,
				/* Split a multi-value property into an array of subvalues, e.g. "rgba(4, 3, 2, 1) 4px 3px 2px 1px" ==> [ "rgba(4, 3, 2, 1)", "4px", "3px", "2px", "1px" ]. */
				valueSplit: /([A-z]+\(.+\))|(([A-z0-9#-.]+?)(?=\s|$))/ig
			},
			/************
			 Lists
			 ************/

			Lists: {
				colors: ["fill", "stroke", "stopColor", "color", "backgroundColor", "borderColor", "borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor", "outlineColor"],
				transformsBase: ["translateX", "translateY", "scale", "scaleX", "scaleY", "skewX", "skewY", "rotateZ"],
				transforms3D: ["transformPerspective", "translateZ", "scaleZ", "rotateX", "rotateY"],
				units: [
					"%", // relative
					"em", "ex", "ch", "rem", // font relative
					"vw", "vh", "vmin", "vmax", // viewport relative
					"cm", "mm", "Q", "in", "pc", "pt", "px", // absolute lengths
					"deg", "grad", "rad", "turn", // angles
					"s", "ms" // time
				],
				colorNames: {
					"aliceblue": "240,248,255",
					"antiquewhite": "250,235,215",
					"aquamarine": "127,255,212",
					"aqua": "0,255,255",
					"azure": "240,255,255",
					"beige": "245,245,220",
					"bisque": "255,228,196",
					"black": "0,0,0",
					"blanchedalmond": "255,235,205",
					"blueviolet": "138,43,226",
					"blue": "0,0,255",
					"brown": "165,42,42",
					"burlywood": "222,184,135",
					"cadetblue": "95,158,160",
					"chartreuse": "127,255,0",
					"chocolate": "210,105,30",
					"coral": "255,127,80",
					"cornflowerblue": "100,149,237",
					"cornsilk": "255,248,220",
					"crimson": "220,20,60",
					"cyan": "0,255,255",
					"darkblue": "0,0,139",
					"darkcyan": "0,139,139",
					"darkgoldenrod": "184,134,11",
					"darkgray": "169,169,169",
					"darkgrey": "169,169,169",
					"darkgreen": "0,100,0",
					"darkkhaki": "189,183,107",
					"darkmagenta": "139,0,139",
					"darkolivegreen": "85,107,47",
					"darkorange": "255,140,0",
					"darkorchid": "153,50,204",
					"darkred": "139,0,0",
					"darksalmon": "233,150,122",
					"darkseagreen": "143,188,143",
					"darkslateblue": "72,61,139",
					"darkslategray": "47,79,79",
					"darkturquoise": "0,206,209",
					"darkviolet": "148,0,211",
					"deeppink": "255,20,147",
					"deepskyblue": "0,191,255",
					"dimgray": "105,105,105",
					"dimgrey": "105,105,105",
					"dodgerblue": "30,144,255",
					"firebrick": "178,34,34",
					"floralwhite": "255,250,240",
					"forestgreen": "34,139,34",
					"fuchsia": "255,0,255",
					"gainsboro": "220,220,220",
					"ghostwhite": "248,248,255",
					"gold": "255,215,0",
					"goldenrod": "218,165,32",
					"gray": "128,128,128",
					"grey": "128,128,128",
					"greenyellow": "173,255,47",
					"green": "0,128,0",
					"honeydew": "240,255,240",
					"hotpink": "255,105,180",
					"indianred": "205,92,92",
					"indigo": "75,0,130",
					"ivory": "255,255,240",
					"khaki": "240,230,140",
					"lavenderblush": "255,240,245",
					"lavender": "230,230,250",
					"lawngreen": "124,252,0",
					"lemonchiffon": "255,250,205",
					"lightblue": "173,216,230",
					"lightcoral": "240,128,128",
					"lightcyan": "224,255,255",
					"lightgoldenrodyellow": "250,250,210",
					"lightgray": "211,211,211",
					"lightgrey": "211,211,211",
					"lightgreen": "144,238,144",
					"lightpink": "255,182,193",
					"lightsalmon": "255,160,122",
					"lightseagreen": "32,178,170",
					"lightskyblue": "135,206,250",
					"lightslategray": "119,136,153",
					"lightsteelblue": "176,196,222",
					"lightyellow": "255,255,224",
					"limegreen": "50,205,50",
					"lime": "0,255,0",
					"linen": "250,240,230",
					"magenta": "255,0,255",
					"maroon": "128,0,0",
					"mediumaquamarine": "102,205,170",
					"mediumblue": "0,0,205",
					"mediumorchid": "186,85,211",
					"mediumpurple": "147,112,219",
					"mediumseagreen": "60,179,113",
					"mediumslateblue": "123,104,238",
					"mediumspringgreen": "0,250,154",
					"mediumturquoise": "72,209,204",
					"mediumvioletred": "199,21,133",
					"midnightblue": "25,25,112",
					"mintcream": "245,255,250",
					"mistyrose": "255,228,225",
					"moccasin": "255,228,181",
					"navajowhite": "255,222,173",
					"navy": "0,0,128",
					"oldlace": "253,245,230",
					"olivedrab": "107,142,35",
					"olive": "128,128,0",
					"orangered": "255,69,0",
					"orange": "255,165,0",
					"orchid": "218,112,214",
					"palegoldenrod": "238,232,170",
					"palegreen": "152,251,152",
					"paleturquoise": "175,238,238",
					"palevioletred": "219,112,147",
					"papayawhip": "255,239,213",
					"peachpuff": "255,218,185",
					"peru": "205,133,63",
					"pink": "255,192,203",
					"plum": "221,160,221",
					"powderblue": "176,224,230",
					"purple": "128,0,128",
					"red": "255,0,0",
					"rosybrown": "188,143,143",
					"royalblue": "65,105,225",
					"saddlebrown": "139,69,19",
					"salmon": "250,128,114",
					"sandybrown": "244,164,96",
					"seagreen": "46,139,87",
					"seashell": "255,245,238",
					"sienna": "160,82,45",
					"silver": "192,192,192",
					"skyblue": "135,206,235",
					"slateblue": "106,90,205",
					"slategray": "112,128,144",
					"snow": "255,250,250",
					"springgreen": "0,255,127",
					"steelblue": "70,130,180",
					"tan": "210,180,140",
					"teal": "0,128,128",
					"thistle": "216,191,216",
					"tomato": "255,99,71",
					"turquoise": "64,224,208",
					"violet": "238,130,238",
					"wheat": "245,222,179",
					"whitesmoke": "245,245,245",
					"white": "255,255,255",
					"yellowgreen": "154,205,50",
					"yellow": "255,255,0"
				}
			},
			/************
			 Hooks
			 ************/

			/* Hooks allow a subproperty (e.g. "boxShadowBlur") of a compound-value CSS property
			 (e.g. "boxShadow: X Y Blur Spread Color") to be animated as if it were a discrete property. */
			/* Note: Beyond enabling fine-grained property animation, hooking is necessary since Velocity only
			 tweens properties with single numeric values; unlike CSS transitions, Velocity does not interpolate compound-values. */
			Hooks: {
				/********************
				 Registration
				 ********************/

				/* Templates are a concise way of indicating which subproperties must be individually registered for each compound-value CSS property. */
				/* Each template consists of the compound-value's base name, its constituent subproperty names, and those subproperties' default values. */
				templates: {
					"textShadow": ["Color X Y Blur", "black 0px 0px 0px"],
					"boxShadow": ["Color X Y Blur Spread", "black 0px 0px 0px 0px"],
					"clip": ["Top Right Bottom Left", "0px 0px 0px 0px"],
					"backgroundPosition": ["X Y", "0% 0%"],
					"transformOrigin": ["X Y Z", "50% 50% 0px"],
					"perspectiveOrigin": ["X Y", "50% 50%"]
				},
				/* A "registered" hook is one that has been converted from its template form into a live,
				 tweenable property. It contains data to associate it with its root property. */
				registered: {
					/* Note: A registered hook looks like this ==> textShadowBlur: [ "textShadow", 3 ],
					 which consists of the subproperty's name, the associated root property's name,
					 and the subproperty's position in the root's value. */
				},
				/* Convert the templates into individual hooks then append them to the registered object above. */
				register: function() {
					/* Color hooks registration: Colors are defaulted to white -- as opposed to black -- since colors that are
					 currently set to "transparent" default to their respective template below when color-animated,
					 and white is typically a closer match to transparent than black is. An exception is made for text ("color"),
					 which is almost always set closer to black than white. */
					for (var i = 0; i < CSS.Lists.colors.length; i++) {
						var rgbComponents = (CSS.Lists.colors[i] === "color") ? "0 0 0 1" : "255 255 255 1";
						CSS.Hooks.templates[CSS.Lists.colors[i]] = ["Red Green Blue Alpha", rgbComponents];
					}

					var rootProperty,
							hookTemplate,
							hookNames;

					/* In IE, color values inside compound-value properties are positioned at the end the value instead of at the beginning.
					 Thus, we re-arrange the templates accordingly. */
					if (IE) {
						for (rootProperty in CSS.Hooks.templates) {
							if (!CSS.Hooks.templates.hasOwnProperty(rootProperty)) {
								continue;
							}
							hookTemplate = CSS.Hooks.templates[rootProperty];
							hookNames = hookTemplate[0].split(" ");

							var defaultValues = hookTemplate[1].match(CSS.RegEx.valueSplit);

							if (hookNames[0] === "Color") {
								/* Reposition both the hook's name and its default value to the end of their respective strings. */
								hookNames.push(hookNames.shift());
								defaultValues.push(defaultValues.shift());

								/* Replace the existing template for the hook's root property. */
								CSS.Hooks.templates[rootProperty] = [hookNames.join(" "), defaultValues.join(" ")];
							}
						}
					}

					/* Hook registration. */
					for (rootProperty in CSS.Hooks.templates) {
						if (!CSS.Hooks.templates.hasOwnProperty(rootProperty)) {
							continue;
						}
						hookTemplate = CSS.Hooks.templates[rootProperty];
						hookNames = hookTemplate[0].split(" ");

						for (var j in hookNames) {
							if (!hookNames.hasOwnProperty(j)) {
								continue;
							}
							var fullHookName = rootProperty + hookNames[j],
									hookPosition = j;

							/* For each hook, register its full name (e.g. textShadowBlur) with its root property (e.g. textShadow)
							 and the hook's position in its template's default value string. */
							CSS.Hooks.registered[fullHookName] = [rootProperty, hookPosition];
						}
					}
				},
				/*****************************
				 Injection and Extraction
				 *****************************/

				/* Look up the root property associated with the hook (e.g. return "textShadow" for "textShadowBlur"). */
				/* Since a hook cannot be set directly (the browser won't recognize it), style updating for hooks is routed through the hook's root property. */
				getRoot: function(property) {
					var hookData = CSS.Hooks.registered[property];

					if (hookData) {
						return hookData[0];
					} else {
						/* If there was no hook match, return the property name untouched. */
						return property;
					}
				},
				getUnit: function(str, start) {
					var unit = (str.substr(start || 0, 5).match(/^[a-z%]+/) || [])[0] || "";

					if (unit && _inArray(CSS.Lists.units, unit)) {
						return unit;
					}
					return "";
				},
				fixColors: function(str) {
					return str.replace(/(rgba?\(\s*)?(\b[a-z]+\b)/g, function($0, $1, $2) {
						if (CSS.Lists.colorNames.hasOwnProperty($2)) {
							return ($1 ? $1 : "rgba(") + CSS.Lists.colorNames[$2] + ($1 ? "" : ",1)");
						}
						return $1 + $2;
					});
				},
				/* Convert any rootPropertyValue, null or otherwise, into a space-delimited list of hook values so that
				 the targeted hook can be injected or extracted at its standard position. */
				cleanRootPropertyValue: function(rootProperty, rootPropertyValue) {
					/* If the rootPropertyValue is wrapped with "rgb()", "clip()", etc., remove the wrapping to normalize the value before manipulation. */
					if (CSS.RegEx.valueUnwrap.test(rootPropertyValue)) {
						rootPropertyValue = rootPropertyValue.match(CSS.RegEx.valueUnwrap)[1];
					}

					/* If rootPropertyValue is a CSS null-value (from which there's inherently no hook value to extract),
					 default to the root's default value as defined in CSS.Hooks.templates. */
					/* Note: CSS null-values include "none", "auto", and "transparent". They must be converted into their
					 zero-values (e.g. textShadow: "none" ==> textShadow: "0px 0px 0px black") for hook manipulation to proceed. */
					if (CSS.Values.isCSSNullValue(rootPropertyValue)) {
						rootPropertyValue = CSS.Hooks.templates[rootProperty][1];
					}

					return rootPropertyValue;
				},
				/* Extracted the hook's value from its root property's value. This is used to get the starting value of an animating hook. */
				extractValue: function(fullHookName, rootPropertyValue) {
					var hookData = CSS.Hooks.registered[fullHookName];

					if (hookData) {
						var hookRoot = hookData[0],
								hookPosition = hookData[1];

						rootPropertyValue = CSS.Hooks.cleanRootPropertyValue(hookRoot, rootPropertyValue);

						/* Split rootPropertyValue into its constituent hook values then grab the desired hook at its standard position. */
						return rootPropertyValue.toString().match(CSS.RegEx.valueSplit)[hookPosition];
					} else {
						/* If the provided fullHookName isn't a registered hook, return the rootPropertyValue that was passed in. */
						return rootPropertyValue;
					}
				},
				/* Inject the hook's value into its root property's value. This is used to piece back together the root property
				 once Velocity has updated one of its individually hooked values through tweening. */
				injectValue: function(fullHookName, hookValue, rootPropertyValue) {
					var hookData = CSS.Hooks.registered[fullHookName];

					if (hookData) {
						var hookRoot = hookData[0],
								hookPosition = hookData[1],
								rootPropertyValueParts,
								rootPropertyValueUpdated;

						rootPropertyValue = CSS.Hooks.cleanRootPropertyValue(hookRoot, rootPropertyValue);

						/* Split rootPropertyValue into its individual hook values, replace the targeted value with hookValue,
						 then reconstruct the rootPropertyValue string. */
						rootPropertyValueParts = rootPropertyValue.toString().match(CSS.RegEx.valueSplit);
						rootPropertyValueParts[hookPosition] = hookValue;
						rootPropertyValueUpdated = rootPropertyValueParts.join(" ");

						return rootPropertyValueUpdated;
					} else {
						/* If the provided fullHookName isn't a registered hook, return the rootPropertyValue that was passed in. */
						return rootPropertyValue;
					}
				}
			},
			/*******************
			 Normalizations
			 *******************/

			/* Normalizations standardize CSS property manipulation by pollyfilling browser-specific implementations (e.g. opacity)
			 and reformatting special properties (e.g. clip, rgba) to look like standard ones. */
			Normalizations: {
				/* Normalizations are passed a normalization target (either the property's name, its extracted value, or its injected value),
				 the targeted element (which may need to be queried), and the targeted property value. */
				registered: {
					clip: function(type, element, propertyValue) {
						switch (type) {
							case "name":
								return "clip";
								/* Clip needs to be unwrapped and stripped of its commas during extraction. */
							case "extract":
								var extracted;

								/* If Velocity also extracted this value, skip extraction. */
								if (CSS.RegEx.wrappedValueAlreadyExtracted.test(propertyValue)) {
									extracted = propertyValue;
								} else {
									/* Remove the "rect()" wrapper. */
									extracted = propertyValue.toString().match(CSS.RegEx.valueUnwrap);

									/* Strip off commas. */
									extracted = extracted ? extracted[1].replace(/,(\s+)?/g, " ") : propertyValue;
								}

								return extracted;
								/* Clip needs to be re-wrapped during injection. */
							case "inject":
								return "rect(" + propertyValue + ")";
						}
					},
					blur: function(type, element, propertyValue) {
						switch (type) {
							case "name":
								return Velocity.State.isFirefox ? "filter" : "-webkit-filter";
							case "extract":
								var extracted = parseFloat(propertyValue);

								/* If extracted is NaN, meaning the value isn't already extracted. */
								if (!(extracted || extracted === 0)) {
									var blurComponent = propertyValue.toString().match(/blur\(([0-9]+[A-z]+)\)/i);

									/* If the filter string had a blur component, return just the blur value and unit type. */
									if (blurComponent) {
										extracted = blurComponent[1];
										/* If the component doesn't exist, default blur to 0. */
									} else {
										extracted = 0;
									}
								}

								return extracted;
								/* Blur needs to be re-wrapped during injection. */
							case "inject":
								/* For the blur effect to be fully de-applied, it needs to be set to "none" instead of 0. */
								if (!parseFloat(propertyValue)) {
									return "none";
								} else {
									return "blur(" + propertyValue + ")";
								}
						}
					},
					/* <=IE8 do not support the standard opacity property. They use filter:alpha(opacity=INT) instead. */
					opacity: function(type, element, propertyValue) {
						if (IE <= 8) {
							switch (type) {
								case "name":
									return "filter";
								case "extract":
									/* <=IE8 return a "filter" value of "alpha(opacity=\d{1,3})".
									 Extract the value and convert it to a decimal value to match the standard CSS opacity property's formatting. */
									var extracted = propertyValue.toString().match(/alpha\(opacity=(.*)\)/i);

									if (extracted) {
										/* Convert to decimal value. */
										propertyValue = extracted[1] / 100;
									} else {
										/* When extracting opacity, default to 1 since a null value means opacity hasn't been set. */
										propertyValue = 1;
									}

									return propertyValue;
								case "inject":
									/* Opacified elements are required to have their zoom property set to a non-zero value. */
									element.style.zoom = 1;

									/* Setting the filter property on elements with certain font property combinations can result in a
									 highly unappealing ultra-bolding effect. There's no way to remedy this throughout a tween, but dropping the
									 value altogether (when opacity hits 1) at leasts ensures that the glitch is gone post-tweening. */
									if (parseFloat(propertyValue) >= 1) {
										return "";
									} else {
										/* As per the filter property's spec, convert the decimal value to a whole number and wrap the value. */
										return "alpha(opacity=" + parseInt(parseFloat(propertyValue) * 100, 10) + ")";
									}
							}
							/* With all other browsers, normalization is not required; return the same values that were passed in. */
						} else {
							switch (type) {
								case "name":
									return "opacity";
								case "extract":
									return propertyValue;
								case "inject":
									return propertyValue;
							}
						}
					}
				},
				/*****************************
				 Batched Registrations
				 *****************************/

				/* Note: Batched normalizations extend the CSS.Normalizations.registered object. */
				register: function() {

					/*****************
					 Transforms
					 *****************/

					/* Transforms are the subproperties contained by the CSS "transform" property. Transforms must undergo normalization
					 so that they can be referenced in a properties map by their individual names. */
					/* Note: When transforms are "set", they are actually assigned to a per-element transformCache. When all transform
					 setting is complete complete, CSS.flushTransformCache() must be manually called to flush the values to the DOM.
					 Transform setting is batched in this way to improve performance: the transform style only needs to be updated
					 once when multiple transform subproperties are being animated simultaneously. */
					/* Note: IE9 and Android Gingerbread have support for 2D -- but not 3D -- transforms. Since animating unsupported
					 transform properties results in the browser ignoring the *entire* transform string, we prevent these 3D values
					 from being normalized for these browsers so that tweening skips these properties altogether
					 (since it will ignore them as being unsupported by the browser.) */
					if ((!IE || IE > 9) && !Velocity.State.isGingerbread) {
						/* Note: Since the standalone CSS "perspective" property and the CSS transform "perspective" subproperty
						 share the same name, the latter is given a unique token within Velocity: "transformPerspective". */
						CSS.Lists.transformsBase = CSS.Lists.transformsBase.concat(CSS.Lists.transforms3D);
					}

					for (var i = 0; i < CSS.Lists.transformsBase.length; i++) {
						/* Wrap the dynamically generated normalization function in a new scope so that transformName's value is
						 paired with its respective function. (Otherwise, all functions would take the final for loop's transformName.) */
						(function() {
							var transformName = CSS.Lists.transformsBase[i];

							CSS.Normalizations.registered[transformName] = function(type, element, propertyValue) {
								switch (type) {
									/* The normalized property name is the parent "transform" property -- the property that is actually set in CSS. */
									case "name":
										return "transform";
										/* Transform values are cached onto a per-element transformCache object. */
									case "extract":
										/* If this transform has yet to be assigned a value, return its null value. */
										if (Data(element) === undefined || Data(element).transformCache[transformName] === undefined) {
											/* Scale CSS.Lists.transformsBase default to 1 whereas all other transform properties default to 0. */
											return /^scale/i.test(transformName) ? 1 : 0;
											/* When transform values are set, they are wrapped in parentheses as per the CSS spec.
											 Thus, when extracting their values (for tween calculations), we strip off the parentheses. */
										}
										return Data(element).transformCache[transformName].replace(/[()]/g, "");
									case "inject":
										var invalid = false;

										/* If an individual transform property contains an unsupported unit type, the browser ignores the *entire* transform property.
										 Thus, protect users from themselves by skipping setting for transform values supplied with invalid unit types. */
										/* Switch on the base transform type; ignore the axis by removing the last letter from the transform's name. */
										switch (transformName.substr(0, transformName.length - 1)) {
											/* Whitelist unit types for each transform. */
											case "translate":
												invalid = !/(%|px|em|rem|vw|vh|\d)$/i.test(propertyValue);
												break;
												/* Since an axis-free "scale" property is supported as well, a little hack is used here to detect it by chopping off its last letter. */
											case "scal":
											case "scale":
												/* Chrome on Android has a bug in which scaled elements blur if their initial scale
												 value is below 1 (which can happen with forcefeeding). Thus, we detect a yet-unset scale property
												 and ensure that its first value is always 1. More info: http://stackoverflow.com/questions/10417890/css3-animations-with-transform-causes-blurred-elements-on-webkit/10417962#10417962 */
												if (Velocity.State.isAndroid && Data(element).transformCache[transformName] === undefined && propertyValue < 1) {
													propertyValue = 1;
												}

												invalid = !/(\d)$/i.test(propertyValue);
												break;
											case "skew":
												invalid = !/(deg|\d)$/i.test(propertyValue);
												break;
											case "rotate":
												invalid = !/(deg|\d)$/i.test(propertyValue);
												break;
										}

										if (!invalid) {
											/* As per the CSS spec, wrap the value in parentheses. */
											Data(element).transformCache[transformName] = "(" + propertyValue + ")";
										}

										/* Although the value is set on the transformCache object, return the newly-updated value for the calling code to process as normal. */
										return Data(element).transformCache[transformName];
								}
							};
						})();
					}

					/*************
					 Colors
					 *************/

					/* Since Velocity only animates a single numeric value per property, color animation is achieved by hooking the individual RGBA components of CSS color properties.
					 Accordingly, color values must be normalized (e.g. "#ff0000", "red", and "rgb(255, 0, 0)" ==> "255 0 0 1") so that their components can be injected/extracted by CSS.Hooks logic. */
					for (var j = 0; j < CSS.Lists.colors.length; j++) {
						/* Wrap the dynamically generated normalization function in a new scope so that colorName's value is paired with its respective function.
						 (Otherwise, all functions would take the final for loop's colorName.) */
						(function() {
							var colorName = CSS.Lists.colors[j];

							/* Note: In IE<=8, which support rgb but not rgba, color properties are reverted to rgb by stripping off the alpha component. */
							CSS.Normalizations.registered[colorName] = function(type, element, propertyValue) {
								switch (type) {
									case "name":
										return colorName;
										/* Convert all color values into the rgb format. (Old IE can return hex values and color names instead of rgb/rgba.) */
									case "extract":
										var extracted;

										/* If the color is already in its hookable form (e.g. "255 255 255 1") due to having been previously extracted, skip extraction. */
										if (CSS.RegEx.wrappedValueAlreadyExtracted.test(propertyValue)) {
											extracted = propertyValue;
										} else {
											var converted,
													colorNames = {
														black: "rgb(0, 0, 0)",
														blue: "rgb(0, 0, 255)",
														gray: "rgb(128, 128, 128)",
														green: "rgb(0, 128, 0)",
														red: "rgb(255, 0, 0)",
														white: "rgb(255, 255, 255)"
													};

											/* Convert color names to rgb. */
											if (/^[A-z]+$/i.test(propertyValue)) {
												if (colorNames[propertyValue] !== undefined) {
													converted = colorNames[propertyValue];
												} else {
													/* If an unmatched color name is provided, default to black. */
													converted = colorNames.black;
												}
												/* Convert hex values to rgb. */
											} else if (CSS.RegEx.isHex.test(propertyValue)) {
												converted = "rgb(" + CSS.Values.hexToRgb(propertyValue).join(" ") + ")";
												/* If the provided color doesn't match any of the accepted color formats, default to black. */
											} else if (!(/^rgba?\(/i.test(propertyValue))) {
												converted = colorNames.black;
											}

											/* Remove the surrounding "rgb/rgba()" string then replace commas with spaces and strip
											 repeated spaces (in case the value included spaces to begin with). */
											extracted = (converted || propertyValue).toString().match(CSS.RegEx.valueUnwrap)[1].replace(/,(\s+)?/g, " ");
										}

										/* So long as this isn't <=IE8, add a fourth (alpha) component if it's missing and default it to 1 (visible). */
										if ((!IE || IE > 8) && extracted.split(" ").length === 3) {
											extracted += " 1";
										}

										return extracted;
									case "inject":
										/* If we have a pattern then it might already have the right values */
										if (/^rgb/.test(propertyValue)) {
											return propertyValue;
										}

										/* If this is IE<=8 and an alpha component exists, strip it off. */
										if (IE <= 8) {
											if (propertyValue.split(" ").length === 4) {
												propertyValue = propertyValue.split(/\s+/).slice(0, 3).join(" ");
											}
											/* Otherwise, add a fourth (alpha) component if it's missing and default it to 1 (visible). */
										} else if (propertyValue.split(" ").length === 3) {
											propertyValue += " 1";
										}

										/* Re-insert the browser-appropriate wrapper("rgb/rgba()"), insert commas, and strip off decimal units
										 on all values but the fourth (R, G, and B only accept whole numbers). */
										return (IE <= 8 ? "rgb" : "rgba") + "(" + propertyValue.replace(/\s+/g, ",").replace(/\.(\d)+(?=,)/g, "") + ")";
								}
							};
						})();
					}

					/**************
					 Dimensions
					 **************/
					function augmentDimension(name, element, wantInner) {
						var isBorderBox = CSS.getPropertyValue(element, "boxSizing").toString().toLowerCase() === "border-box";

						if (isBorderBox === (wantInner || false)) {
							/* in box-sizing mode, the CSS width / height accessors already give the outerWidth / outerHeight. */
							var i,
									value,
									augment = 0,
									sides = name === "width" ? ["Left", "Right"] : ["Top", "Bottom"],
									fields = ["padding" + sides[0], "padding" + sides[1], "border" + sides[0] + "Width", "border" + sides[1] + "Width"];

							for (i = 0; i < fields.length; i++) {
								value = parseFloat(CSS.getPropertyValue(element, fields[i]));
								if (!isNaN(value)) {
									augment += value;
								}
							}
							return wantInner ? -augment : augment;
						}
						return 0;
					}
					function getDimension(name, wantInner) {
						return function(type, element, propertyValue) {
							switch (type) {
								case "name":
									return name;
								case "extract":
									return parseFloat(propertyValue) + augmentDimension(name, element, wantInner);
								case "inject":
									return (parseFloat(propertyValue) - augmentDimension(name, element, wantInner)) + "px";
							}
						};
					}
					CSS.Normalizations.registered.innerWidth = getDimension("width", true);
					CSS.Normalizations.registered.innerHeight = getDimension("height", true);
					CSS.Normalizations.registered.outerWidth = getDimension("width");
					CSS.Normalizations.registered.outerHeight = getDimension("height");
				}
			},
			/************************
			 CSS Property Names
			 ************************/

			Names: {
				/* Camelcase a property name into its JavaScript notation (e.g. "background-color" ==> "backgroundColor").
				 Camelcasing is used to normalize property names between and across calls. */
				camelCase: function(property) {
					return property.replace(/-(\w)/g, function(match, subMatch) {
						return subMatch.toUpperCase();
					});
				},
				/* For SVG elements, some properties (namely, dimensional ones) are GET/SET via the element's HTML attributes (instead of via CSS styles). */
				SVGAttribute: function(property) {
					var SVGAttributes = "width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2";

					/* Certain browsers require an SVG transform to be applied as an attribute. (Otherwise, application via CSS is preferable due to 3D support.) */
					if (IE || (Velocity.State.isAndroid && !Velocity.State.isChrome)) {
						SVGAttributes += "|transform";
					}

					return new RegExp("^(" + SVGAttributes + ")$", "i").test(property);
				},
				/* Determine whether a property should be set with a vendor prefix. */
				/* If a prefixed version of the property exists, return it. Otherwise, return the original property name.
				 If the property is not at all supported by the browser, return a false flag. */
				prefixCheck: function(property) {
					/* If this property has already been checked, return the cached value. */
					if (Velocity.State.prefixMatches[property]) {
						return [Velocity.State.prefixMatches[property], true];
					} else {
						var vendors = ["", "Webkit", "Moz", "ms", "O"];

						for (var i = 0, vendorsLength = vendors.length; i < vendorsLength; i++) {
							var propertyPrefixed;

							if (i === 0) {
								propertyPrefixed = property;
							} else {
								/* Capitalize the first letter of the property to conform to JavaScript vendor prefix notation (e.g. webkitFilter). */
								propertyPrefixed = vendors[i] + property.replace(/^\w/, function(match) {
									return match.toUpperCase();
								});
							}

							/* Check if the browser supports this property as prefixed. */
							if (Type.isString(Velocity.State.prefixElement.style[propertyPrefixed])) {
								/* Cache the match. */
								Velocity.State.prefixMatches[property] = propertyPrefixed;

								return [propertyPrefixed, true];
							}
						}

						/* If the browser doesn't support this property in any form, include a false flag so that the caller can decide how to proceed. */
						return [property, false];
					}
				}
			},
			/************************
			 CSS Property Values
			 ************************/

			Values: {
				/* Hex to RGB conversion. Copyright Tim Down: http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb */
				hexToRgb: function(hex) {
					var shortformRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
							longformRegex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
							rgbParts;

					hex = hex.replace(shortformRegex, function(m, r, g, b) {
						return r + r + g + g + b + b;
					});

					rgbParts = longformRegex.exec(hex);

					return rgbParts ? [parseInt(rgbParts[1], 16), parseInt(rgbParts[2], 16), parseInt(rgbParts[3], 16)] : [0, 0, 0];
				},
				isCSSNullValue: function(value) {
					/* The browser defaults CSS values that have not been set to either 0 or one of several possible null-value strings.
					 Thus, we check for both falsiness and these special strings. */
					/* Null-value checking is performed to default the special strings to 0 (for the sake of tweening) or their hook
					 templates as defined as CSS.Hooks (for the sake of hook injection/extraction). */
					/* Note: Chrome returns "rgba(0, 0, 0, 0)" for an undefined color whereas IE returns "transparent". */
					return (!value || /^(none|auto|transparent|(rgba\(0, ?0, ?0, ?0\)))$/i.test(value));
				},
				/* Retrieve a property's default unit type. Used for assigning a unit type when one is not supplied by the user. */
				getUnitType: function(property) {
					if (/^(rotate|skew)/i.test(property)) {
						return "deg";
					} else if (/(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(property)) {
						/* The above properties are unitless. */
						return "";
					} else {
						/* Default to px for all other properties. */
						return "px";
					}
				},
				/* HTML elements default to an associated display type when they're not set to display:none. */
				/* Note: This function is used for correctly setting the non-"none" display value in certain Velocity redirects, such as fadeIn/Out. */
				getDisplayType: function(element) {
					var tagName = element && element.tagName.toString().toLowerCase();

					if (/^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(tagName)) {
						return "inline";
					} else if (/^(li)$/i.test(tagName)) {
						return "list-item";
					} else if (/^(tr)$/i.test(tagName)) {
						return "table-row";
					} else if (/^(table)$/i.test(tagName)) {
						return "table";
					} else if (/^(tbody)$/i.test(tagName)) {
						return "table-row-group";
						/* Default to "block" when no match is found. */
					} else {
						return "block";
					}
				},
				/* The class add/remove functions are used to temporarily apply a "velocity-animating" class to elements while they're animating. */
				addClass: function(element, className) {
					if (element) {
						if (element.classList) {
							element.classList.add(className);
						} else if (Type.isString(element.className)) {
							// Element.className is around 15% faster then set/getAttribute
							element.className += (element.className.length ? " " : "") + className;
						} else {
							// Work around for IE strict mode animating SVG - and anything else that doesn't behave correctly - the same way jQuery does it
							var currentClass = element.getAttribute(IE <= 7 ? "className" : "class") || "";

							element.setAttribute("class", currentClass + (currentClass ? " " : "") + className);
						}
					}
				},
				removeClass: function(element, className) {
					if (element) {
						if (element.classList) {
							element.classList.remove(className);
						} else if (Type.isString(element.className)) {
							// Element.className is around 15% faster then set/getAttribute
							// TODO: Need some jsperf tests on performance - can we get rid of the regex and maybe use split / array manipulation?
							element.className = element.className.toString().replace(new RegExp("(^|\\s)" + className.split(" ").join("|") + "(\\s|$)", "gi"), " ");
						} else {
							// Work around for IE strict mode animating SVG - and anything else that doesn't behave correctly - the same way jQuery does it
							var currentClass = element.getAttribute(IE <= 7 ? "className" : "class") || "";

							element.setAttribute("class", currentClass.replace(new RegExp("(^|\s)" + className.split(" ").join("|") + "(\s|$)", "gi"), " "));
						}
					}
				}
			},
			/****************************
			 Style Getting & Setting
			 ****************************/

			/* The singular getPropertyValue, which routes the logic for all normalizations, hooks, and standard CSS properties. */
			getPropertyValue: function(element, property, rootPropertyValue, forceStyleLookup) {
				/* Get an element's computed property value. */
				/* Note: Retrieving the value of a CSS property cannot simply be performed by checking an element's
				 style attribute (which only reflects user-defined values). Instead, the browser must be queried for a property's
				 *computed* value. You can read more about getComputedStyle here: https://developer.mozilla.org/en/docs/Web/API/window.getComputedStyle */
				function computePropertyValue(element, property) {
					/* When box-sizing isn't set to border-box, height and width style values are incorrectly computed when an
					 element's scrollbars are visible (which expands the element's dimensions). Thus, we defer to the more accurate
					 offsetHeight/Width property, which includes the total dimensions for interior, border, padding, and scrollbar.
					 We subtract border and padding to get the sum of interior + scrollbar. */
					var computedValue = 0;

					/* IE<=8 doesn't support window.getComputedStyle, thus we defer to jQuery, which has an extensive array
					 of hacks to accurately retrieve IE8 property values. Re-implementing that logic here is not worth bloating the
					 codebase for a dying browser. The performance repercussions of using jQuery here are minimal since
					 Velocity is optimized to rarely (and sometimes never) query the DOM. Further, the $.css() codepath isn't that slow. */
					if (IE <= 8) {
						computedValue = $.css(element, property); /* GET */
						/* All other browsers support getComputedStyle. The returned live object reference is cached onto its
						 associated element so that it does not need to be refetched upon every GET. */
					} else {
						/* Browsers do not return height and width values for elements that are set to display:"none". Thus, we temporarily
						 toggle display to the element type's default value. */
						var toggleDisplay = false;

						if (/^(width|height)$/.test(property) && CSS.getPropertyValue(element, "display") === 0) {
							toggleDisplay = true;
							CSS.setPropertyValue(element, "display", CSS.Values.getDisplayType(element));
						}

						var revertDisplay = function() {
							if (toggleDisplay) {
								CSS.setPropertyValue(element, "display", "none");
							}
						};

						if (!forceStyleLookup) {
							if (property === "height" && CSS.getPropertyValue(element, "boxSizing").toString().toLowerCase() !== "border-box") {
								var contentBoxHeight = element.offsetHeight - (parseFloat(CSS.getPropertyValue(element, "borderTopWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "borderBottomWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingTop")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingBottom")) || 0);
								revertDisplay();

								return contentBoxHeight;
							} else if (property === "width" && CSS.getPropertyValue(element, "boxSizing").toString().toLowerCase() !== "border-box") {
								var contentBoxWidth = element.offsetWidth - (parseFloat(CSS.getPropertyValue(element, "borderLeftWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "borderRightWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingLeft")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingRight")) || 0);
								revertDisplay();

								return contentBoxWidth;
							}
						}

						var computedStyle;

						/* For elements that Velocity hasn't been called on directly (e.g. when Velocity queries the DOM on behalf
						 of a parent of an element its animating), perform a direct getComputedStyle lookup since the object isn't cached. */
						if (Data(element) === undefined) {
							computedStyle = window.getComputedStyle(element, null); /* GET */
							/* If the computedStyle object has yet to be cached, do so now. */
						} else if (!Data(element).computedStyle) {
							computedStyle = Data(element).computedStyle = window.getComputedStyle(element, null); /* GET */
							/* If computedStyle is cached, use it. */
						} else {
							computedStyle = Data(element).computedStyle;
						}

						/* IE and Firefox do not return a value for the generic borderColor -- they only return individual values for each border side's color.
						 Also, in all browsers, when border colors aren't all the same, a compound value is returned that Velocity isn't setup to parse.
						 So, as a polyfill for querying individual border side colors, we just return the top border's color and animate all borders from that value. */
						if (property === "borderColor") {
							property = "borderTopColor";
						}

						/* IE9 has a bug in which the "filter" property must be accessed from computedStyle using the getPropertyValue method
						 instead of a direct property lookup. The getPropertyValue method is slower than a direct lookup, which is why we avoid it by default. */
						if (IE === 9 && property === "filter") {
							computedValue = computedStyle.getPropertyValue(property); /* GET */
						} else {
							computedValue = computedStyle[property];
						}

						/* Fall back to the property's style value (if defined) when computedValue returns nothing,
						 which can happen when the element hasn't been painted. */
						if (computedValue === "" || computedValue === null) {
							computedValue = element.style[property];
						}

						revertDisplay();
					}

					/* For top, right, bottom, and left (TRBL) values that are set to "auto" on elements of "fixed" or "absolute" position,
					 defer to jQuery for converting "auto" to a numeric value. (For elements with a "static" or "relative" position, "auto" has the same
					 effect as being set to 0, so no conversion is necessary.) */
					/* An example of why numeric conversion is necessary: When an element with "position:absolute" has an untouched "left"
					 property, which reverts to "auto", left's value is 0 relative to its parent element, but is often non-zero relative
					 to its *containing* (not parent) element, which is the nearest "position:relative" ancestor or the viewport (and always the viewport in the case of "position:fixed"). */
					if (computedValue === "auto" && /^(top|right|bottom|left)$/i.test(property)) {
						var position = computePropertyValue(element, "position"); /* GET */

						/* For absolute positioning, jQuery's $.position() only returns values for top and left;
						 right and bottom will have their "auto" value reverted to 0. */
						/* Note: A jQuery object must be created here since jQuery doesn't have a low-level alias for $.position().
						 Not a big deal since we're currently in a GET batch anyway. */
						if (position === "fixed" || (position === "absolute" && /top|left/i.test(property))) {
							/* Note: jQuery strips the pixel unit from its returned values; we re-add it here to conform with computePropertyValue's behavior. */
							computedValue = $(element).position()[property] + "px"; /* GET */
						}
					}

					return computedValue;
				}

				var propertyValue;

				/* If this is a hooked property (e.g. "clipLeft" instead of the root property of "clip"),
				 extract the hook's value from a normalized rootPropertyValue using CSS.Hooks.extractValue(). */
				if (CSS.Hooks.registered[property]) {
					var hook = property,
							hookRoot = CSS.Hooks.getRoot(hook);

					/* If a cached rootPropertyValue wasn't passed in (which Velocity always attempts to do in order to avoid requerying the DOM),
					 query the DOM for the root property's value. */
					if (rootPropertyValue === undefined) {
						/* Since the browser is now being directly queried, use the official post-prefixing property name for this lookup. */
						rootPropertyValue = CSS.getPropertyValue(element, CSS.Names.prefixCheck(hookRoot)[0]); /* GET */
					}

					/* If this root has a normalization registered, peform the associated normalization extraction. */
					if (CSS.Normalizations.registered[hookRoot]) {
						rootPropertyValue = CSS.Normalizations.registered[hookRoot]("extract", element, rootPropertyValue);
					}

					/* Extract the hook's value. */
					propertyValue = CSS.Hooks.extractValue(hook, rootPropertyValue);

					/* If this is a normalized property (e.g. "opacity" becomes "filter" in <=IE8) or "translateX" becomes "transform"),
					 normalize the property's name and value, and handle the special case of transforms. */
					/* Note: Normalizing a property is mutually exclusive from hooking a property since hook-extracted values are strictly
					 numerical and therefore do not require normalization extraction. */
				} else if (CSS.Normalizations.registered[property]) {
					var normalizedPropertyName,
							normalizedPropertyValue;

					normalizedPropertyName = CSS.Normalizations.registered[property]("name", element);

					/* Transform values are calculated via normalization extraction (see below), which checks against the element's transformCache.
					 At no point do transform GETs ever actually query the DOM; initial stylesheet values are never processed.
					 This is because parsing 3D transform matrices is not always accurate and would bloat our codebase;
					 thus, normalization extraction defaults initial transform values to their zero-values (e.g. 1 for scaleX and 0 for translateX). */
					if (normalizedPropertyName !== "transform") {
						normalizedPropertyValue = computePropertyValue(element, CSS.Names.prefixCheck(normalizedPropertyName)[0]); /* GET */

						/* If the value is a CSS null-value and this property has a hook template, use that zero-value template so that hooks can be extracted from it. */
						if (CSS.Values.isCSSNullValue(normalizedPropertyValue) && CSS.Hooks.templates[property]) {
							normalizedPropertyValue = CSS.Hooks.templates[property][1];
						}
					}

					propertyValue = CSS.Normalizations.registered[property]("extract", element, normalizedPropertyValue);
				}

				/* If a (numeric) value wasn't produced via hook extraction or normalization, query the DOM. */
				if (!/^[\d-]/.test(propertyValue)) {
					/* For SVG elements, dimensional properties (which SVGAttribute() detects) are tweened via
					 their HTML attribute values instead of their CSS style values. */
					var data = Data(element);

					if (data && data.isSVG && CSS.Names.SVGAttribute(property)) {
						/* Since the height/width attribute values must be set manually, they don't reflect computed values.
						 Thus, we use use getBBox() to ensure we always get values for elements with undefined height/width attributes. */
						if (/^(height|width)$/i.test(property)) {
							/* Firefox throws an error if .getBBox() is called on an SVG that isn't attached to the DOM. */
							try {
								propertyValue = element.getBBox()[property];
							} catch (error) {
								propertyValue = 0;
							}
							/* Otherwise, access the attribute value directly. */
						} else {
							propertyValue = element.getAttribute(property);
						}
					} else {
						propertyValue = computePropertyValue(element, CSS.Names.prefixCheck(property)[0]); /* GET */
					}
				}

				/* Since property lookups are for animation purposes (which entails computing the numeric delta between start and end values),
				 convert CSS null-values to an integer of value 0. */
				if (CSS.Values.isCSSNullValue(propertyValue)) {
					propertyValue = 0;
				}

				if (Velocity.debug >= 2) {
					console.log("Get " + property + ": " + propertyValue);
				}

				return propertyValue;
			},
			/* The singular setPropertyValue, which routes the logic for all normalizations, hooks, and standard CSS properties. */
			setPropertyValue: function(element, property, propertyValue, rootPropertyValue, scrollData) {
				var propertyName = property;

				/* In order to be subjected to call options and element queueing, scroll animation is routed through Velocity as if it were a standard CSS property. */
				if (property === "scroll") {
					/* If a container option is present, scroll the container instead of the browser window. */
					if (scrollData.container) {
						scrollData.container["scroll" + scrollData.direction] = propertyValue;
						/* Otherwise, Velocity defaults to scrolling the browser window. */
					} else {
						if (scrollData.direction === "Left") {
							window.scrollTo(propertyValue, scrollData.alternateValue);
						} else {
							window.scrollTo(scrollData.alternateValue, propertyValue);
						}
					}
				} else {
					/* Transforms (translateX, rotateZ, etc.) are applied to a per-element transformCache object, which is manually flushed via flushTransformCache().
					 Thus, for now, we merely cache transforms being SET. */
					if (CSS.Normalizations.registered[property] && CSS.Normalizations.registered[property]("name", element) === "transform") {
						/* Perform a normalization injection. */
						/* Note: The normalization logic handles the transformCache updating. */
						CSS.Normalizations.registered[property]("inject", element, propertyValue);

						propertyName = "transform";
						propertyValue = Data(element).transformCache[property];
					} else {
						/* Inject hooks. */
						if (CSS.Hooks.registered[property]) {
							var hookName = property,
									hookRoot = CSS.Hooks.getRoot(property);

							/* If a cached rootPropertyValue was not provided, query the DOM for the hookRoot's current value. */
							rootPropertyValue = rootPropertyValue || CSS.getPropertyValue(element, hookRoot); /* GET */

							propertyValue = CSS.Hooks.injectValue(hookName, propertyValue, rootPropertyValue);
							property = hookRoot;
						}

						/* Normalize names and values. */
						if (CSS.Normalizations.registered[property]) {
							propertyValue = CSS.Normalizations.registered[property]("inject", element, propertyValue);
							property = CSS.Normalizations.registered[property]("name", element);
						}

						/* Assign the appropriate vendor prefix before performing an official style update. */
						propertyName = CSS.Names.prefixCheck(property)[0];

						/* A try/catch is used for IE<=8, which throws an error when "invalid" CSS values are set, e.g. a negative width.
						 Try/catch is avoided for other browsers since it incurs a performance overhead. */
						if (IE <= 8) {
							try {
								element.style[propertyName] = propertyValue;
							} catch (error) {
								if (Velocity.debug) {
									console.log("Browser does not support [" + propertyValue + "] for [" + propertyName + "]");
								}
							}
							/* SVG elements have their dimensional properties (width, height, x, y, cx, etc.) applied directly as attributes instead of as styles. */
							/* Note: IE8 does not support SVG elements, so it's okay that we skip it for SVG animation. */
						} else {
							var data = Data(element);

							if (data && data.isSVG && CSS.Names.SVGAttribute(property)) {
								/* Note: For SVG attributes, vendor-prefixed property names are never used. */
								/* Note: Not all CSS properties can be animated via attributes, but the browser won't throw an error for unsupported properties. */
								element.setAttribute(property, propertyValue);
							} else {
								element.style[propertyName] = propertyValue;
							}
						}

						if (Velocity.debug >= 2) {
							console.log("Set " + property + " (" + propertyName + "): " + propertyValue);
						}
					}
				}

				/* Return the normalized property name and value in case the caller wants to know how these values were modified before being applied to the DOM. */
				return [propertyName, propertyValue];
			},
			/* To increase performance by batching transform updates into a single SET, transforms are not directly applied to an element until flushTransformCache() is called. */
			/* Note: Velocity applies transform properties in the same order that they are chronogically introduced to the element's CSS styles. */
			flushTransformCache: function(element) {
				var transformString = "",
						data = Data(element);

				/* Certain browsers require that SVG transforms be applied as an attribute. However, the SVG transform attribute takes a modified version of CSS's transform string
				 (units are dropped and, except for skewX/Y, subproperties are merged into their master property -- e.g. scaleX and scaleY are merged into scale(X Y). */
				if ((IE || (Velocity.State.isAndroid && !Velocity.State.isChrome)) && data && data.isSVG) {
					/* Since transform values are stored in their parentheses-wrapped form, we use a helper function to strip out their numeric values.
					 Further, SVG transform properties only take unitless (representing pixels) values, so it's okay that parseFloat() strips the unit suffixed to the float value. */
					var getTransformFloat = function(transformProperty) {
						return parseFloat(CSS.getPropertyValue(element, transformProperty));
					};

					/* Create an object to organize all the transforms that we'll apply to the SVG element. To keep the logic simple,
					 we process *all* transform properties -- even those that may not be explicitly applied (since they default to their zero-values anyway). */
					var SVGTransforms = {
						translate: [getTransformFloat("translateX"), getTransformFloat("translateY")],
						skewX: [getTransformFloat("skewX")], skewY: [getTransformFloat("skewY")],
						/* If the scale property is set (non-1), use that value for the scaleX and scaleY values
						 (this behavior mimics the result of animating all these properties at once on HTML elements). */
						scale: getTransformFloat("scale") !== 1 ? [getTransformFloat("scale"), getTransformFloat("scale")] : [getTransformFloat("scaleX"), getTransformFloat("scaleY")],
						/* Note: SVG's rotate transform takes three values: rotation degrees followed by the X and Y values
						 defining the rotation's origin point. We ignore the origin values (default them to 0). */
						rotate: [getTransformFloat("rotateZ"), 0, 0]
					};

					/* Iterate through the transform properties in the user-defined property map order.
					 (This mimics the behavior of non-SVG transform animation.) */
					$.each(Data(element).transformCache, function(transformName) {
						/* Except for with skewX/Y, revert the axis-specific transform subproperties to their axis-free master
						 properties so that they match up with SVG's accepted transform properties. */
						if (/^translate/i.test(transformName)) {
							transformName = "translate";
						} else if (/^scale/i.test(transformName)) {
							transformName = "scale";
						} else if (/^rotate/i.test(transformName)) {
							transformName = "rotate";
						}

						/* Check that we haven't yet deleted the property from the SVGTransforms container. */
						if (SVGTransforms[transformName]) {
							/* Append the transform property in the SVG-supported transform format. As per the spec, surround the space-delimited values in parentheses. */
							transformString += transformName + "(" + SVGTransforms[transformName].join(" ") + ")" + " ";

							/* After processing an SVG transform property, delete it from the SVGTransforms container so we don't
							 re-insert the same master property if we encounter another one of its axis-specific properties. */
							delete SVGTransforms[transformName];
						}
					});
				} else {
					var transformValue,
							perspective;

					/* Transform properties are stored as members of the transformCache object. Concatenate all the members into a string. */
					$.each(Data(element).transformCache, function(transformName) {
						transformValue = Data(element).transformCache[transformName];

						/* Transform's perspective subproperty must be set first in order to take effect. Store it temporarily. */
						if (transformName === "transformPerspective") {
							perspective = transformValue;
							return true;
						}

						/* IE9 only supports one rotation type, rotateZ, which it refers to as "rotate". */
						if (IE === 9 && transformName === "rotateZ") {
							transformName = "rotate";
						}

						transformString += transformName + transformValue + " ";
					});

					/* If present, set the perspective subproperty first. */
					if (perspective) {
						transformString = "perspective" + perspective + " " + transformString;
					}
				}

				CSS.setPropertyValue(element, "transform", transformString);
			}
		};

		/* Register hooks and normalizations. */
		CSS.Hooks.register();
		CSS.Normalizations.register();

		/* Allow hook setting in the same fashion as jQuery's $.css(). */
		Velocity.hook = function(elements, arg2, arg3) {
			var value;

			elements = sanitizeElements(elements);

			$.each(elements, function(i, element) {
				/* Initialize Velocity's per-element data cache if this element hasn't previously been animated. */
				if (Data(element) === undefined) {
					Velocity.init(element);
				}

				/* Get property value. If an element set was passed in, only return the value for the first element. */
				if (arg3 === undefined) {
					if (value === undefined) {
						value = CSS.getPropertyValue(element, arg2);
					}
					/* Set property value. */
				} else {
					/* sPV returns an array of the normalized propertyName/propertyValue pair used to update the DOM. */
					var adjustedSet = CSS.setPropertyValue(element, arg2, arg3);

					/* Transform properties don't automatically set. They have to be flushed to the DOM. */
					if (adjustedSet[0] === "transform") {
						Velocity.CSS.flushTransformCache(element);
					}

					value = adjustedSet;
				}
			});

			return value;
		};

		/*****************
		 Animation
		 *****************/

		var animate = function() {
			var opts;

			/******************
			 Call Chain
			 ******************/

			/* Logic for determining what to return to the call stack when exiting out of Velocity. */
			function getChain() {
				/* If we are using the utility function, attempt to return this call's promise. If no promise library was detected,
				 default to null instead of returning the targeted elements so that utility function's return value is standardized. */
				if (isUtility) {
					return promiseData.promise || null;
					/* Otherwise, if we're using $.fn, return the jQuery-/Zepto-wrapped element set. */
				} else {
					return elementsWrapped;
				}
			}

			/*************************
			 Arguments Assignment
			 *************************/

			/* To allow for expressive CoffeeScript code, Velocity supports an alternative syntax in which "elements" (or "e"), "properties" (or "p"), and "options" (or "o")
			 objects are defined on a container object that's passed in as Velocity's sole argument. */
			/* Note: Some browsers automatically populate arguments with a "properties" object. We detect it by checking for its default "names" property. */
			var syntacticSugar = (arguments[0] && (arguments[0].p || (($.isPlainObject(arguments[0].properties) && !arguments[0].properties.names) || Type.isString(arguments[0].properties)))),
					/* Whether Velocity was called via the utility function (as opposed to on a jQuery/Zepto object). */
					isUtility,
					/* When Velocity is called via the utility function ($.Velocity()/Velocity()), elements are explicitly
					 passed in as the first parameter. Thus, argument positioning varies. We normalize them here. */
					elementsWrapped,
					argumentIndex;

			var elements,
					propertiesMap,
					options;

			/* Detect jQuery/Zepto elements being animated via the $.fn method. */
			if (Type.isWrapped(this)) {
				isUtility = false;

				argumentIndex = 0;
				elements = this;
				elementsWrapped = this;
				/* Otherwise, raw elements are being animated via the utility function. */
			} else {
				isUtility = true;

				argumentIndex = 1;
				elements = syntacticSugar ? (arguments[0].elements || arguments[0].e) : arguments[0];
			}

			/***************
			 Promises
			 ***************/

			var promiseData = {
				promise: null,
				resolver: null,
				rejecter: null
			};

			/* If this call was made via the utility function (which is the default method of invocation when jQuery/Zepto are not being used), and if
			 promise support was detected, create a promise object for this call and store references to its resolver and rejecter methods. The resolve
			 method is used when a call completes naturally or is prematurely stopped by the user. In both cases, completeCall() handles the associated
			 call cleanup and promise resolving logic. The reject method is used when an invalid set of arguments is passed into a Velocity call. */
			/* Note: Velocity employs a call-based queueing architecture, which means that stopping an animating element actually stops the full call that
			 triggered it -- not that one element exclusively. Similarly, there is one promise per call, and all elements targeted by a Velocity call are
			 grouped together for the purposes of resolving and rejecting a promise. */
			if (isUtility && Velocity.Promise) {
				promiseData.promise = new Velocity.Promise(function(resolve, reject) {
					promiseData.resolver = resolve;
					promiseData.rejecter = reject;
				});
			}

			if (syntacticSugar) {
				propertiesMap = arguments[0].properties || arguments[0].p;
				options = arguments[0].options || arguments[0].o;
			} else {
				propertiesMap = arguments[argumentIndex];
				options = arguments[argumentIndex + 1];
			}

			elements = sanitizeElements(elements);

			if (!elements) {
				if (promiseData.promise) {
					if (!propertiesMap || !options || options.promiseRejectEmpty !== false) {
						promiseData.rejecter();
					} else {
						promiseData.resolver();
					}
				}
				return;
			}

			/* The length of the element set (in the form of a nodeList or an array of elements) is defaulted to 1 in case a
			 single raw DOM element is passed in (which doesn't contain a length property). */
			var elementsLength = elements.length,
					elementsIndex = 0;

			/***************************
			 Argument Overloading
			 ***************************/

			/* Support is included for jQuery's argument overloading: $.animate(propertyMap [, duration] [, easing] [, complete]).
			 Overloading is detected by checking for the absence of an object being passed into options. */
			/* Note: The stop/finish/pause/resume actions do not accept animation options, and are therefore excluded from this check. */
			if (!/^(stop|finish|finishAll|pause|resume)$/i.test(propertiesMap) && !$.isPlainObject(options)) {
				/* The utility function shifts all arguments one position to the right, so we adjust for that offset. */
				var startingArgumentPosition = argumentIndex + 1;

				options = {};

				/* Iterate through all options arguments */
				for (var i = startingArgumentPosition; i < arguments.length; i++) {
					/* Treat a number as a duration. Parse it out. */
					/* Note: The following RegEx will return true if passed an array with a number as its first item.
					 Thus, arrays are skipped from this check. */
					if (!Type.isArray(arguments[i]) && (/^(fast|normal|slow)$/i.test(arguments[i]) || /^\d/.test(arguments[i]))) {
						options.duration = arguments[i];
						/* Treat strings and arrays as easings. */
					} else if (Type.isString(arguments[i]) || Type.isArray(arguments[i])) {
						options.easing = arguments[i];
						/* Treat a function as a complete callback. */
					} else if (Type.isFunction(arguments[i])) {
						options.complete = arguments[i];
					}
				}
			}

			/*********************
			 Action Detection
			 *********************/

			/* Velocity's behavior is categorized into "actions": Elements can either be specially scrolled into view,
			 or they can be started, stopped, paused, resumed, or reversed . If a literal or referenced properties map is passed in as Velocity's
			 first argument, the associated action is "start". Alternatively, "scroll", "reverse", "pause", "resume" or "stop" can be passed in 
			 instead of a properties map. */
			var action;

			switch (propertiesMap) {
				case "scroll":
					action = "scroll";
					break;

				case "reverse":
					action = "reverse";
					break;

				case "pause":

					/*******************
					 Action: Pause
					 *******************/

					var currentTime = (new Date()).getTime();

					/* Handle delay timers */
					$.each(elements, function(i, element) {
						pauseDelayOnElement(element, currentTime);
					});

					/* Pause and Resume are call-wide (not on a per element basis). Thus, calling pause or resume on a 
					 single element will cause any calls that containt tweens for that element to be paused/resumed
					 as well. */

					/* Iterate through all calls and pause any that contain any of our elements */
					$.each(Velocity.State.calls, function(i, activeCall) {

						var found = false;
						/* Inactive calls are set to false by the logic inside completeCall(). Skip them. */
						if (activeCall) {
							/* Iterate through the active call's targeted elements. */
							$.each(activeCall[1], function(k, activeElement) {
								var queueName = (options === undefined) ? "" : options;

								if (queueName !== true && (activeCall[2].queue !== queueName) && !(options === undefined && activeCall[2].queue === false)) {
									return true;
								}

								/* Iterate through the calls targeted by the stop command. */
								$.each(elements, function(l, element) {
									/* Check that this call was applied to the target element. */
									if (element === activeElement) {

										/* Set call to paused */
										activeCall[5] = {
											resume: false
										};

										/* Once we match an element, we can bounce out to the next call entirely */
										found = true;
										return false;
									}
								});

								/* Proceed to check next call if we have already matched */
								if (found) {
									return false;
								}
							});
						}

					});

					/* Since pause creates no new tweens, exit out of Velocity. */
					return getChain();

				case "resume":

					/*******************
					 Action: Resume
					 *******************/

					/* Handle delay timers */
					$.each(elements, function(i, element) {
						resumeDelayOnElement(element, currentTime);
					});

					/* Pause and Resume are call-wide (not on a per elemnt basis). Thus, calling pause or resume on a 
					 single element will cause any calls that containt tweens for that element to be paused/resumed
					 as well. */

					/* Iterate through all calls and pause any that contain any of our elements */
					$.each(Velocity.State.calls, function(i, activeCall) {
						var found = false;
						/* Inactive calls are set to false by the logic inside completeCall(). Skip them. */
						if (activeCall) {
							/* Iterate through the active call's targeted elements. */
							$.each(activeCall[1], function(k, activeElement) {
								var queueName = (options === undefined) ? "" : options;

								if (queueName !== true && (activeCall[2].queue !== queueName) && !(options === undefined && activeCall[2].queue === false)) {
									return true;
								}

								/* Skip any calls that have never been paused */
								if (!activeCall[5]) {
									return true;
								}

								/* Iterate through the calls targeted by the stop command. */
								$.each(elements, function(l, element) {
									/* Check that this call was applied to the target element. */
									if (element === activeElement) {

										/* Flag a pause object to be resumed, which will occur during the next tick. In
										 addition, the pause object will at that time be deleted */
										activeCall[5].resume = true;

										/* Once we match an element, we can bounce out to the next call entirely */
										found = true;
										return false;
									}
								});

								/* Proceed to check next call if we have already matched */
								if (found) {
									return false;
								}
							});
						}

					});

					/* Since resume creates no new tweens, exit out of Velocity. */
					return getChain();

				case "finish":
				case "finishAll":
				case "stop":
					/*******************
					 Action: Stop
					 *******************/

					/* Clear the currently-active delay on each targeted element. */
					$.each(elements, function(i, element) {
						if (Data(element) && Data(element).delayTimer) {
							/* Stop the timer from triggering its cached next() function. */
							clearTimeout(Data(element).delayTimer.setTimeout);

							/* Manually call the next() function so that the subsequent queue items can progress. */
							if (Data(element).delayTimer.next) {
								Data(element).delayTimer.next();
							}

							delete Data(element).delayTimer;
						}

						/* If we want to finish everything in the queue, we have to iterate through it
						 and call each function. This will make them active calls below, which will
						 cause them to be applied via the duration setting. */
						if (propertiesMap === "finishAll" && (options === true || Type.isString(options))) {
							/* Iterate through the items in the element's queue. */
							$.each($.queue(element, Type.isString(options) ? options : ""), function(_, item) {
								/* The queue array can contain an "inprogress" string, which we skip. */
								if (Type.isFunction(item)) {
									item();
								}
							});

							/* Clearing the $.queue() array is achieved by resetting it to []. */
							$.queue(element, Type.isString(options) ? options : "", []);
						}
					});

					var callsToStop = [];

					/* When the stop action is triggered, the elements' currently active call is immediately stopped. The active call might have
					 been applied to multiple elements, in which case all of the call's elements will be stopped. When an element
					 is stopped, the next item in its animation queue is immediately triggered. */
					/* An additional argument may be passed in to clear an element's remaining queued calls. Either true (which defaults to the "fx" queue)
					 or a custom queue string can be passed in. */
					/* Note: The stop command runs prior to Velocity's Queueing phase since its behavior is intended to take effect *immediately*,
					 regardless of the element's current queue state. */

					/* Iterate through every active call. */
					$.each(Velocity.State.calls, function(i, activeCall) {
						/* Inactive calls are set to false by the logic inside completeCall(). Skip them. */
						if (activeCall) {
							/* Iterate through the active call's targeted elements. */
							$.each(activeCall[1], function(k, activeElement) {
								/* If true was passed in as a secondary argument, clear absolutely all calls on this element. Otherwise, only
								 clear calls associated with the relevant queue. */
								/* Call stopping logic works as follows:
								 - options === true --> stop current default queue calls (and queue:false calls), including remaining queued ones.
								 - options === undefined --> stop current queue:"" call and all queue:false calls.
								 - options === false --> stop only queue:false calls.
								 - options === "custom" --> stop current queue:"custom" call, including remaining queued ones (there is no functionality to only clear the currently-running queue:"custom" call). */
								var queueName = (options === undefined) ? "" : options;

								if (queueName !== true && (activeCall[2].queue !== queueName) && !(options === undefined && activeCall[2].queue === false)) {
									return true;
								}

								/* Iterate through the calls targeted by the stop command. */
								$.each(elements, function(l, element) {
									/* Check that this call was applied to the target element. */
									if (element === activeElement) {
										/* Optionally clear the remaining queued calls. If we're doing "finishAll" this won't find anything,
										 due to the queue-clearing above. */
										if (options === true || Type.isString(options)) {
											/* Iterate through the items in the element's queue. */
											$.each($.queue(element, Type.isString(options) ? options : ""), function(_, item) {
												/* The queue array can contain an "inprogress" string, which we skip. */
												if (Type.isFunction(item)) {
													/* Pass the item's callback a flag indicating that we want to abort from the queue call.
													 (Specifically, the queue will resolve the call's associated promise then abort.)  */
													item(null, true);
												}
											});

											/* Clearing the $.queue() array is achieved by resetting it to []. */
											$.queue(element, Type.isString(options) ? options : "", []);
										}

										if (propertiesMap === "stop") {
											/* Since "reverse" uses cached start values (the previous call's endValues), these values must be
											 changed to reflect the final value that the elements were actually tweened to. */
											/* Note: If only queue:false animations are currently running on an element, it won't have a tweensContainer
											 object. Also, queue:false animations can't be reversed. */
											var data = Data(element);
											if (data && data.tweensContainer && queueName !== false) {
												$.each(data.tweensContainer, function(m, activeTween) {
													activeTween.endValue = activeTween.currentValue;
												});
											}

											callsToStop.push(i);
										} else if (propertiesMap === "finish" || propertiesMap === "finishAll") {
											/* To get active tweens to finish immediately, we forcefully shorten their durations to 1ms so that
											 they finish upon the next rAf tick then proceed with normal call completion logic. */
											activeCall[2].duration = 1;
										}
									}
								});
							});
						}
					});

					/* Prematurely call completeCall() on each matched active call. Pass an additional flag for "stop" to indicate
					 that the complete callback and display:none setting should be skipped since we're completing prematurely. */
					if (propertiesMap === "stop") {
						$.each(callsToStop, function(i, j) {
							completeCall(j, true);
						});

						if (promiseData.promise) {
							/* Immediately resolve the promise associated with this stop call since stop runs synchronously. */
							promiseData.resolver(elements);
						}
					}

					/* Since we're stopping, and not proceeding with queueing, exit out of Velocity. */
					return getChain();

				default:
					/* Treat a non-empty plain object as a literal properties map. */
					if ($.isPlainObject(propertiesMap) && !Type.isEmptyObject(propertiesMap)) {
						action = "start";

						/****************
						 Redirects
						 ****************/

						/* Check if a string matches a registered redirect (see Redirects above). */
					} else if (Type.isString(propertiesMap) && Velocity.Redirects[propertiesMap]) {
						opts = $.extend({}, options);

						var durationOriginal = opts.duration,
								delayOriginal = opts.delay || 0;

						/* If the backwards option was passed in, reverse the element set so that elements animate from the last to the first. */
						if (opts.backwards === true) {
							elements = $.extend(true, [], elements).reverse();
						}

						/* Individually trigger the redirect for each element in the set to prevent users from having to handle iteration logic in their redirect. */
						$.each(elements, function(elementIndex, element) {
							/* If the stagger option was passed in, successively delay each element by the stagger value (in ms). Retain the original delay value. */
							if (parseFloat(opts.stagger)) {
								opts.delay = delayOriginal + (parseFloat(opts.stagger) * elementIndex);
							} else if (Type.isFunction(opts.stagger)) {
								opts.delay = delayOriginal + opts.stagger.call(element, elementIndex, elementsLength);
							}

							/* If the drag option was passed in, successively increase/decrease (depending on the presense of opts.backwards)
							 the duration of each element's animation, using floors to prevent producing very short durations. */
							if (opts.drag) {
								/* Default the duration of UI pack effects (callouts and transitions) to 1000ms instead of the usual default duration of 400ms. */
								opts.duration = parseFloat(durationOriginal) || (/^(callout|transition)/.test(propertiesMap) ? 1000 : DURATION_DEFAULT);

								/* For each element, take the greater duration of: A) animation completion percentage relative to the original duration,
								 B) 75% of the original duration, or C) a 200ms fallback (in case duration is already set to a low value).
								 The end result is a baseline of 75% of the redirect's duration that increases/decreases as the end of the element set is approached. */
								opts.duration = Math.max(opts.duration * (opts.backwards ? 1 - elementIndex / elementsLength : (elementIndex + 1) / elementsLength), opts.duration * 0.75, 200);
							}

							/* Pass in the call's opts object so that the redirect can optionally extend it. It defaults to an empty object instead of null to
							 reduce the opts checking logic required inside the redirect. */
							Velocity.Redirects[propertiesMap].call(element, element, opts || {}, elementIndex, elementsLength, elements, promiseData.promise ? promiseData : undefined);
						});

						/* Since the animation logic resides within the redirect's own code, abort the remainder of this call.
						 (The performance overhead up to this point is virtually non-existant.) */
						/* Note: The jQuery call chain is kept intact by returning the complete element set. */
						return getChain();
					} else {
						var abortError = "Velocity: First argument (" + propertiesMap + ") was not a property map, a known action, or a registered redirect. Aborting.";

						if (promiseData.promise) {
							promiseData.rejecter(new Error(abortError));
						} else if (window.console) {
							console.log(abortError);
						}

						return getChain();
					}
			}

			/**************************
			 Call-Wide Variables
			 **************************/

			/* A container for CSS unit conversion ratios (e.g. %, rem, and em ==> px) that is used to cache ratios across all elements
			 being animated in a single Velocity call. Calculating unit ratios necessitates DOM querying and updating, and is therefore
			 avoided (via caching) wherever possible. This container is call-wide instead of page-wide to avoid the risk of using stale
			 conversion metrics across Velocity animations that are not immediately consecutively chained. */
			var callUnitConversionData = {
				lastParent: null,
				lastPosition: null,
				lastFontSize: null,
				lastPercentToPxWidth: null,
				lastPercentToPxHeight: null,
				lastEmToPx: null,
				remToPx: null,
				vwToPx: null,
				vhToPx: null
			};

			/* A container for all the ensuing tween data and metadata associated with this call. This container gets pushed to the page-wide
			 Velocity.State.calls array that is processed during animation ticking. */
			var call = [];

			/************************
			 Element Processing
			 ************************/

			/* Element processing consists of three parts -- data processing that cannot go stale and data processing that *can* go stale (i.e. third-party style modifications):
			 1) Pre-Queueing: Element-wide variables, including the element's data storage, are instantiated. Call options are prepared. If triggered, the Stop action is executed.
			 2) Queueing: The logic that runs once this call has reached its point of execution in the element's $.queue() stack. Most logic is placed here to avoid risking it becoming stale.
			 3) Pushing: Consolidation of the tween data followed by its push onto the global in-progress calls container.
			 `elementArrayIndex` allows passing index of the element in the original array to value functions.
			 If `elementsIndex` were used instead the index would be determined by the elements' per-element queue.
			 */
			function processElement(element, elementArrayIndex) {

				/*************************
				 Part I: Pre-Queueing
				 *************************/

				/***************************
				 Element-Wide Variables
				 ***************************/

				var /* The runtime opts object is the extension of the current call's options and Velocity's page-wide option defaults. */
						opts = $.extend({}, Velocity.defaults, options),
						/* A container for the processed data associated with each property in the propertyMap.
						 (Each property in the map produces its own "tween".) */
						tweensContainer = {},
						elementUnitConversionData;

				/******************
				 Element Init
				 ******************/

				if (Data(element) === undefined) {
					Velocity.init(element);
				}

				/******************
				 Option: Delay
				 ******************/

				/* Since queue:false doesn't respect the item's existing queue, we avoid injecting its delay here (it's set later on). */
				/* Note: Velocity rolls its own delay function since jQuery doesn't have a utility alias for $.fn.delay()
				 (and thus requires jQuery element creation, which we avoid since its overhead includes DOM querying). */
				if (parseFloat(opts.delay) && opts.queue !== false) {
					$.queue(element, opts.queue, function(next, clearQueue) {
						if (clearQueue === true) {
							/* Do not continue with animation queueing. */
							return true;
						}

						/* This is a flag used to indicate to the upcoming completeCall() function that this queue entry was initiated by Velocity. See completeCall() for further details. */
						Velocity.velocityQueueEntryFlag = true;

						/* The ensuing queue item (which is assigned to the "next" argument that $.queue() automatically passes in) will be triggered after a setTimeout delay.
						 The setTimeout is stored so that it can be subjected to clearTimeout() if this animation is prematurely stopped via Velocity's "stop" command, and
						 delayBegin/delayTime is used to ensure we can "pause" and "resume" a tween that is still mid-delay. */

						/* Temporarily store delayed elements to facilite access for global pause/resume */
						var callIndex = Velocity.State.delayedElements.count++;
						Velocity.State.delayedElements[callIndex] = element;

						var delayComplete = (function(index) {
							return function() {
								/* Clear the temporary element */
								Velocity.State.delayedElements[index] = false;

								/* Finally, issue the call */
								next();
							};
						})(callIndex);


						Data(element).delayBegin = (new Date()).getTime();
						Data(element).delay = parseFloat(opts.delay);
						Data(element).delayTimer = {
							setTimeout: setTimeout(next, parseFloat(opts.delay)),
							next: delayComplete
						};
					});
				}

				/*********************
				 Option: Duration
				 *********************/

				/* Support for jQuery's named durations. */
				switch (opts.duration.toString().toLowerCase()) {
					case "fast":
						opts.duration = 200;
						break;

					case "normal":
						opts.duration = DURATION_DEFAULT;
						break;

					case "slow":
						opts.duration = 600;
						break;

					default:
						/* Remove the potential "ms" suffix and default to 1 if the user is attempting to set a duration of 0 (in order to produce an immediate style change). */
						opts.duration = parseFloat(opts.duration) || 1;
				}

				/************************
				 Global Option: Mock
				 ************************/

				if (Velocity.mock !== false) {
					/* In mock mode, all animations are forced to 1ms so that they occur immediately upon the next rAF tick.
					 Alternatively, a multiplier can be passed in to time remap all delays and durations. */
					if (Velocity.mock === true) {
						opts.duration = opts.delay = 1;
					} else {
						opts.duration *= parseFloat(Velocity.mock) || 1;
						opts.delay *= parseFloat(Velocity.mock) || 1;
					}
				}

				/*******************
				 Option: Easing
				 *******************/

				opts.easing = getEasing(opts.easing, opts.duration);

				/**********************
				 Option: Callbacks
				 **********************/

				/* Callbacks must functions. Otherwise, default to null. */
				if (opts.begin && !Type.isFunction(opts.begin)) {
					opts.begin = null;
				}

				if (opts.progress && !Type.isFunction(opts.progress)) {
					opts.progress = null;
				}

				if (opts.complete && !Type.isFunction(opts.complete)) {
					opts.complete = null;
				}

				/*********************************
				 Option: Display & Visibility
				 *********************************/

				/* Refer to Velocity's documentation (VelocityJS.org/#displayAndVisibility) for a description of the display and visibility options' behavior. */
				/* Note: We strictly check for undefined instead of falsiness because display accepts an empty string value. */
				if (opts.display !== undefined && opts.display !== null) {
					opts.display = opts.display.toString().toLowerCase();

					/* Users can pass in a special "auto" value to instruct Velocity to set the element to its default display value. */
					if (opts.display === "auto") {
						opts.display = Velocity.CSS.Values.getDisplayType(element);
					}
				}

				if (opts.visibility !== undefined && opts.visibility !== null) {
					opts.visibility = opts.visibility.toString().toLowerCase();
				}

				/**********************
				 Option: mobileHA
				 **********************/

				/* When set to true, and if this is a mobile device, mobileHA automatically enables hardware acceleration (via a null transform hack)
				 on animating elements. HA is removed from the element at the completion of its animation. */
				/* Note: Android Gingerbread doesn't support HA. If a null transform hack (mobileHA) is in fact set, it will prevent other tranform subproperties from taking effect. */
				/* Note: You can read more about the use of mobileHA in Velocity's documentation: VelocityJS.org/#mobileHA. */
				opts.mobileHA = (opts.mobileHA && Velocity.State.isMobile && !Velocity.State.isGingerbread);

				/***********************
				 Part II: Queueing
				 ***********************/

				/* When a set of elements is targeted by a Velocity call, the set is broken up and each element has the current Velocity call individually queued onto it.
				 In this way, each element's existing queue is respected; some elements may already be animating and accordingly should not have this current Velocity call triggered immediately. */
				/* In each queue, tween data is processed for each animating property then pushed onto the call-wide calls array. When the last element in the set has had its tweens processed,
				 the call array is pushed to Velocity.State.calls for live processing by the requestAnimationFrame tick. */
				function buildQueue(next) {
					var data, lastTweensContainer;

					/*******************
					 Option: Begin
					 *******************/

					/* The begin callback is fired once per call -- not once per elemenet -- and is passed the full raw DOM element set as both its context and its first argument. */
					if (opts.begin && elementsIndex === 0) {
						/* We throw callbacks in a setTimeout so that thrown errors don't halt the execution of Velocity itself. */
						try {
							opts.begin.call(elements, elements);
						} catch (error) {
							setTimeout(function() {
								throw error;
							}, 1);
						}
					}

					/*****************************************
					 Tween Data Construction (for Scroll)
					 *****************************************/

					/* Note: In order to be subjected to chaining and animation options, scroll's tweening is routed through Velocity as if it were a standard CSS property animation. */
					if (action === "scroll") {
						/* The scroll action uniquely takes an optional "offset" option -- specified in pixels -- that offsets the targeted scroll position. */
						var scrollDirection = (/^x$/i.test(opts.axis) ? "Left" : "Top"),
								scrollOffset = parseFloat(opts.offset) || 0,
								scrollPositionCurrent,
								scrollPositionCurrentAlternate,
								scrollPositionEnd;

						/* Scroll also uniquely takes an optional "container" option, which indicates the parent element that should be scrolled --
						 as opposed to the browser window itself. This is useful for scrolling toward an element that's inside an overflowing parent element. */
						if (opts.container) {
							/* Ensure that either a jQuery object or a raw DOM element was passed in. */
							if (Type.isWrapped(opts.container) || Type.isNode(opts.container)) {
								/* Extract the raw DOM element from the jQuery wrapper. */
								opts.container = opts.container[0] || opts.container;
								/* Note: Unlike other properties in Velocity, the browser's scroll position is never cached since it so frequently changes
								 (due to the user's natural interaction with the page). */
								scrollPositionCurrent = opts.container["scroll" + scrollDirection]; /* GET */

								/* $.position() values are relative to the container's currently viewable area (without taking into account the container's true dimensions
								 -- say, for example, if the container was not overflowing). Thus, the scroll end value is the sum of the child element's position *and*
								 the scroll container's current scroll position. */
								scrollPositionEnd = (scrollPositionCurrent + $(element).position()[scrollDirection.toLowerCase()]) + scrollOffset; /* GET */
								/* If a value other than a jQuery object or a raw DOM element was passed in, default to null so that this option is ignored. */
							} else {
								opts.container = null;
							}
						} else {
							/* If the window itself is being scrolled -- not a containing element -- perform a live scroll position lookup using
							 the appropriate cached property names (which differ based on browser type). */
							scrollPositionCurrent = Velocity.State.scrollAnchor[Velocity.State["scrollProperty" + scrollDirection]]; /* GET */
							/* When scrolling the browser window, cache the alternate axis's current value since window.scrollTo() doesn't let us change only one value at a time. */
							scrollPositionCurrentAlternate = Velocity.State.scrollAnchor[Velocity.State["scrollProperty" + (scrollDirection === "Left" ? "Top" : "Left")]]; /* GET */

							/* Unlike $.position(), $.offset() values are relative to the browser window's true dimensions -- not merely its currently viewable area --
							 and therefore end values do not need to be compounded onto current values. */
							scrollPositionEnd = $(element).offset()[scrollDirection.toLowerCase()] + scrollOffset; /* GET */
						}

						/* Since there's only one format that scroll's associated tweensContainer can take, we create it manually. */
						tweensContainer = {
							scroll: {
								rootPropertyValue: false,
								startValue: scrollPositionCurrent,
								currentValue: scrollPositionCurrent,
								endValue: scrollPositionEnd,
								unitType: "",
								easing: opts.easing,
								scrollData: {
									container: opts.container,
									direction: scrollDirection,
									alternateValue: scrollPositionCurrentAlternate
								}
							},
							element: element
						};

						if (Velocity.debug) {
							console.log("tweensContainer (scroll): ", tweensContainer.scroll, element);
						}

						/******************************************
						 Tween Data Construction (for Reverse)
						 ******************************************/

						/* Reverse acts like a "start" action in that a property map is animated toward. The only difference is
						 that the property map used for reverse is the inverse of the map used in the previous call. Thus, we manipulate
						 the previous call to construct our new map: use the previous map's end values as our new map's start values. Copy over all other data. */
						/* Note: Reverse can be directly called via the "reverse" parameter, or it can be indirectly triggered via the loop option. (Loops are composed of multiple reverses.) */
						/* Note: Reverse calls do not need to be consecutively chained onto a currently-animating element in order to operate on cached values;
						 there is no harm to reverse being called on a potentially stale data cache since reverse's behavior is simply defined
						 as reverting to the element's values as they were prior to the previous *Velocity* call. */
					} else if (action === "reverse") {
						data = Data(element);

						/* Abort if there is no prior animation data to reverse to. */
						if (!data) {
							return;
						}

						if (!data.tweensContainer) {
							/* Dequeue the element so that this queue entry releases itself immediately, allowing subsequent queue entries to run. */
							$.dequeue(element, opts.queue);

							return;
						} else {
							/*********************
							 Options Parsing
							 *********************/

							/* If the element was hidden via the display option in the previous call,
							 revert display to "auto" prior to reversal so that the element is visible again. */
							if (data.opts.display === "none") {
								data.opts.display = "auto";
							}

							if (data.opts.visibility === "hidden") {
								data.opts.visibility = "visible";
							}

							/* If the loop option was set in the previous call, disable it so that "reverse" calls aren't recursively generated.
							 Further, remove the previous call's callback options; typically, users do not want these to be refired. */
							data.opts.loop = false;
							data.opts.begin = null;
							data.opts.complete = null;

							/* Since we're extending an opts object that has already been extended with the defaults options object,
							 we remove non-explicitly-defined properties that are auto-assigned values. */
							if (!options.easing) {
								delete opts.easing;
							}

							if (!options.duration) {
								delete opts.duration;
							}

							/* The opts object used for reversal is an extension of the options object optionally passed into this
							 reverse call plus the options used in the previous Velocity call. */
							opts = $.extend({}, data.opts, opts);

							/*************************************
							 Tweens Container Reconstruction
							 *************************************/

							/* Create a deepy copy (indicated via the true flag) of the previous call's tweensContainer. */
							lastTweensContainer = $.extend(true, {}, data ? data.tweensContainer : null);

							/* Manipulate the previous tweensContainer by replacing its end values and currentValues with its start values. */
							for (var lastTween in lastTweensContainer) {
								/* In addition to tween data, tweensContainers contain an element property that we ignore here. */
								if (lastTweensContainer.hasOwnProperty(lastTween) && lastTween !== "element") {
									var lastStartValue = lastTweensContainer[lastTween].startValue;

									lastTweensContainer[lastTween].startValue = lastTweensContainer[lastTween].currentValue = lastTweensContainer[lastTween].endValue;
									lastTweensContainer[lastTween].endValue = lastStartValue;

									/* Easing is the only option that embeds into the individual tween data (since it can be defined on a per-property basis).
									 Accordingly, every property's easing value must be updated when an options object is passed in with a reverse call.
									 The side effect of this extensibility is that all per-property easing values are forcefully reset to the new value. */
									if (!Type.isEmptyObject(options)) {
										lastTweensContainer[lastTween].easing = opts.easing;
									}

									if (Velocity.debug) {
										console.log("reverse tweensContainer (" + lastTween + "): " + JSON.stringify(lastTweensContainer[lastTween]), element);
									}
								}
							}

							tweensContainer = lastTweensContainer;
						}

						/*****************************************
						 Tween Data Construction (for Start)
						 *****************************************/

					} else if (action === "start") {

						/*************************
						 Value Transferring
						 *************************/

						/* If this queue entry follows a previous Velocity-initiated queue entry *and* if this entry was created
						 while the element was in the process of being animated by Velocity, then this current call is safe to use
						 the end values from the prior call as its start values. Velocity attempts to perform this value transfer
						 process whenever possible in order to avoid requerying the DOM. */
						/* If values aren't transferred from a prior call and start values were not forcefed by the user (more on this below),
						 then the DOM is queried for the element's current values as a last resort. */
						/* Note: Conversely, animation reversal (and looping) *always* perform inter-call value transfers; they never requery the DOM. */

						data = Data(element);

						/* The per-element isAnimating flag is used to indicate whether it's safe (i.e. the data isn't stale)
						 to transfer over end values to use as start values. If it's set to true and there is a previous
						 Velocity call to pull values from, do so. */
						if (data && data.tweensContainer && data.isAnimating === true) {
							lastTweensContainer = data.tweensContainer;
						}

						/***************************
						 Tween Data Calculation
						 ***************************/

						/* This function parses property data and defaults endValue, easing, and startValue as appropriate. */
						/* Property map values can either take the form of 1) a single value representing the end value,
						 or 2) an array in the form of [ endValue, [, easing] [, startValue] ].
						 The optional third parameter is a forcefed startValue to be used instead of querying the DOM for
						 the element's current value. Read Velocity's docmentation to learn more about forcefeeding: VelocityJS.org/#forcefeeding */
						var parsePropertyValue = function(valueData, skipResolvingEasing) {
							var endValue, easing, startValue;

							/* If we have a function as the main argument then resolve it first, in case it returns an array that needs to be split */
							if (Type.isFunction(valueData)) {
								valueData = valueData.call(element, elementArrayIndex, elementsLength);
							}

							/* Handle the array format, which can be structured as one of three potential overloads:
							 A) [ endValue, easing, startValue ], B) [ endValue, easing ], or C) [ endValue, startValue ] */
							if (Type.isArray(valueData)) {
								/* endValue is always the first item in the array. Don't bother validating endValue's value now
								 since the ensuing property cycling logic does that. */
								endValue = valueData[0];

								/* Two-item array format: If the second item is a number, function, or hex string, treat it as a
								 start value since easings can only be non-hex strings or arrays. */
								if ((!Type.isArray(valueData[1]) && /^[\d-]/.test(valueData[1])) || Type.isFunction(valueData[1]) || CSS.RegEx.isHex.test(valueData[1])) {
									startValue = valueData[1];
									/* Two or three-item array: If the second item is a non-hex string easing name or an array, treat it as an easing. */
								} else if ((Type.isString(valueData[1]) && !CSS.RegEx.isHex.test(valueData[1]) && Velocity.Easings[valueData[1]]) || Type.isArray(valueData[1])) {
									easing = skipResolvingEasing ? valueData[1] : getEasing(valueData[1], opts.duration);

									/* Don't bother validating startValue's value now since the ensuing property cycling logic inherently does that. */
									startValue = valueData[2];
								} else {
									startValue = valueData[1] || valueData[2];
								}
								/* Handle the single-value format. */
							} else {
								endValue = valueData;
							}

							/* Default to the call's easing if a per-property easing type was not defined. */
							if (!skipResolvingEasing) {
								easing = easing || opts.easing;
							}

							/* If functions were passed in as values, pass the function the current element as its context,
							 plus the element's index and the element set's size as arguments. Then, assign the returned value. */
							if (Type.isFunction(endValue)) {
								endValue = endValue.call(element, elementArrayIndex, elementsLength);
							}

							if (Type.isFunction(startValue)) {
								startValue = startValue.call(element, elementArrayIndex, elementsLength);
							}

							/* Allow startValue to be left as undefined to indicate to the ensuing code that its value was not forcefed. */
							return [endValue || 0, easing, startValue];
						};

						var fixPropertyValue = function(property, valueData) {
							/* In case this property is a hook, there are circumstances where we will intend to work on the hook's root property and not the hooked subproperty. */
							var rootProperty = CSS.Hooks.getRoot(property),
									rootPropertyValue = false,
									/* Parse out endValue, easing, and startValue from the property's data. */
									endValue = valueData[0],
									easing = valueData[1],
									startValue = valueData[2],
									pattern;

							/**************************
							 Start Value Sourcing
							 **************************/

							/* Other than for the dummy tween property, properties that are not supported by the browser (and do not have an associated normalization) will
							 inherently produce no style changes when set, so they are skipped in order to decrease animation tick overhead.
							 Property support is determined via prefixCheck(), which returns a false flag when no supported is detected. */
							/* Note: Since SVG elements have some of their properties directly applied as HTML attributes,
							 there is no way to check for their explicit browser support, and so we skip skip this check for them. */
							if ((!data || !data.isSVG) && rootProperty !== "tween" && CSS.Names.prefixCheck(rootProperty)[1] === false && CSS.Normalizations.registered[rootProperty] === undefined) {
								if (Velocity.debug) {
									console.log("Skipping [" + rootProperty + "] due to a lack of browser support.");
								}
								return;
							}

							/* If the display option is being set to a non-"none" (e.g. "block") and opacity (filter on IE<=8) is being
							 animated to an endValue of non-zero, the user's intention is to fade in from invisible, thus we forcefeed opacity
							 a startValue of 0 if its startValue hasn't already been sourced by value transferring or prior forcefeeding. */
							if (((opts.display !== undefined && opts.display !== null && opts.display !== "none") || (opts.visibility !== undefined && opts.visibility !== "hidden")) && /opacity|filter/.test(property) && !startValue && endValue !== 0) {
								startValue = 0;
							}

							/* If values have been transferred from the previous Velocity call, extract the endValue and rootPropertyValue
							 for all of the current call's properties that were *also* animated in the previous call. */
							/* Note: Value transferring can optionally be disabled by the user via the _cacheValues option. */
							if (opts._cacheValues && lastTweensContainer && lastTweensContainer[property]) {
								if (startValue === undefined) {
									startValue = lastTweensContainer[property].endValue + lastTweensContainer[property].unitType;
								}

								/* The previous call's rootPropertyValue is extracted from the element's data cache since that's the
								 instance of rootPropertyValue that gets freshly updated by the tweening process, whereas the rootPropertyValue
								 attached to the incoming lastTweensContainer is equal to the root property's value prior to any tweening. */
								rootPropertyValue = data.rootPropertyValueCache[rootProperty];
								/* If values were not transferred from a previous Velocity call, query the DOM as needed. */
							} else {
								/* Handle hooked properties. */
								if (CSS.Hooks.registered[property]) {
									if (startValue === undefined) {
										rootPropertyValue = CSS.getPropertyValue(element, rootProperty); /* GET */
										/* Note: The following getPropertyValue() call does not actually trigger a DOM query;
										 getPropertyValue() will extract the hook from rootPropertyValue. */
										startValue = CSS.getPropertyValue(element, property, rootPropertyValue);
										/* If startValue is already defined via forcefeeding, do not query the DOM for the root property's value;
										 just grab rootProperty's zero-value template from CSS.Hooks. This overwrites the element's actual
										 root property value (if one is set), but this is acceptable since the primary reason users forcefeed is
										 to avoid DOM queries, and thus we likewise avoid querying the DOM for the root property's value. */
									} else {
										/* Grab this hook's zero-value template, e.g. "0px 0px 0px black". */
										rootPropertyValue = CSS.Hooks.templates[rootProperty][1];
									}
									/* Handle non-hooked properties that haven't already been defined via forcefeeding. */
								} else if (startValue === undefined) {
									startValue = CSS.getPropertyValue(element, property); /* GET */
								}
							}

							/**************************
							 Value Data Extraction
							 **************************/

							var separatedValue,
									endValueUnitType,
									startValueUnitType,
									operator = false;

							/* Separates a property value into its numeric value and its unit type. */
							var separateValue = function(property, value) {
								var unitType,
										numericValue;

								numericValue = (value || "0")
										.toString()
										.toLowerCase()
										/* Match the unit type at the end of the value. */
										.replace(/[%A-z]+$/, function(match) {
											/* Grab the unit type. */
											unitType = match;

											/* Strip the unit type off of value. */
											return "";
										});

								/* If no unit type was supplied, assign one that is appropriate for this property (e.g. "deg" for rotateZ or "px" for width). */
								if (!unitType) {
									unitType = CSS.Values.getUnitType(property);
								}

								return [numericValue, unitType];
							};

							if (startValue !== endValue && Type.isString(startValue) && Type.isString(endValue)) {
								pattern = "";
								var iStart = 0, // index in startValue
										iEnd = 0, // index in endValue
										aStart = [], // array of startValue numbers
										aEnd = [], // array of endValue numbers
										inCalc = 0, // Keep track of being inside a "calc()" so we don't duplicate it
										inRGB = 0, // Keep track of being inside an RGB as we can't use fractional values
										inRGBA = 0; // Keep track of being inside an RGBA as we must pass fractional for the alpha channel

								startValue = CSS.Hooks.fixColors(startValue);
								endValue = CSS.Hooks.fixColors(endValue);
								while (iStart < startValue.length && iEnd < endValue.length) {
									var cStart = startValue[iStart],
											cEnd = endValue[iEnd];

									if (/[\d\.-]/.test(cStart) && /[\d\.-]/.test(cEnd)) {
										var tStart = cStart, // temporary character buffer
												tEnd = cEnd, // temporary character buffer
												dotStart = ".", // Make sure we can only ever match a single dot in a decimal
												dotEnd = "."; // Make sure we can only ever match a single dot in a decimal

										while (++iStart < startValue.length) {
											cStart = startValue[iStart];
											if (cStart === dotStart) {
												dotStart = ".."; // Can never match two characters
											} else if (!/\d/.test(cStart)) {
												break;
											}
											tStart += cStart;
										}
										while (++iEnd < endValue.length) {
											cEnd = endValue[iEnd];
											if (cEnd === dotEnd) {
												dotEnd = ".."; // Can never match two characters
											} else if (!/\d/.test(cEnd)) {
												break;
											}
											tEnd += cEnd;
										}
										var uStart = CSS.Hooks.getUnit(startValue, iStart), // temporary unit type
												uEnd = CSS.Hooks.getUnit(endValue, iEnd); // temporary unit type

										iStart += uStart.length;
										iEnd += uEnd.length;
										if (uStart === uEnd) {
											// Same units
											if (tStart === tEnd) {
												// Same numbers, so just copy over
												pattern += tStart + uStart;
											} else {
												// Different numbers, so store them
												pattern += "{" + aStart.length + (inRGB ? "!" : "") + "}" + uStart;
												aStart.push(parseFloat(tStart));
												aEnd.push(parseFloat(tEnd));
											}
										} else {
											// Different units, so put into a "calc(from + to)" and animate each side to/from zero
											var nStart = parseFloat(tStart),
													nEnd = parseFloat(tEnd);

											pattern += (inCalc < 5 ? "calc" : "") + "("
													+ (nStart ? "{" + aStart.length + (inRGB ? "!" : "") + "}" : "0") + uStart
													+ " + "
													+ (nEnd ? "{" + (aStart.length + (nStart ? 1 : 0)) + (inRGB ? "!" : "") + "}" : "0") + uEnd
													+ ")";
											if (nStart) {
												aStart.push(nStart);
												aEnd.push(0);
											}
											if (nEnd) {
												aStart.push(0);
												aEnd.push(nEnd);
											}
										}
									} else if (cStart === cEnd) {
										pattern += cStart;
										iStart++;
										iEnd++;
										// Keep track of being inside a calc()
										if (inCalc === 0 && cStart === "c"
												|| inCalc === 1 && cStart === "a"
												|| inCalc === 2 && cStart === "l"
												|| inCalc === 3 && cStart === "c"
												|| inCalc >= 4 && cStart === "("
												) {
											inCalc++;
										} else if ((inCalc && inCalc < 5)
												|| inCalc >= 4 && cStart === ")" && --inCalc < 5) {
											inCalc = 0;
										}
										// Keep track of being inside an rgb() / rgba()
										if (inRGB === 0 && cStart === "r"
												|| inRGB === 1 && cStart === "g"
												|| inRGB === 2 && cStart === "b"
												|| inRGB === 3 && cStart === "a"
												|| inRGB >= 3 && cStart === "("
												) {
											if (inRGB === 3 && cStart === "a") {
												inRGBA = 1;
											}
											inRGB++;
										} else if (inRGBA && cStart === ",") {
											if (++inRGBA > 3) {
												inRGB = inRGBA = 0;
											}
										} else if ((inRGBA && inRGB < (inRGBA ? 5 : 4))
												|| inRGB >= (inRGBA ? 4 : 3) && cStart === ")" && --inRGB < (inRGBA ? 5 : 4)) {
											inRGB = inRGBA = 0;
										}
									} else {
										inCalc = 0;
										// TODO: changing units, fixing colours
										break;
									}
								}
								if (iStart !== startValue.length || iEnd !== endValue.length) {
									if (Velocity.debug) {
										console.error("Trying to pattern match mis-matched strings [\"" + endValue + "\", \"" + startValue + "\"]");
									}
									pattern = undefined;
								}
								if (pattern) {
									if (aStart.length) {
										if (Velocity.debug) {
											console.log("Pattern found \"" + pattern + "\" -> ", aStart, aEnd, "[" + startValue + "," + endValue + "]");
										}
										startValue = aStart;
										endValue = aEnd;
										endValueUnitType = startValueUnitType = "";
									} else {
										pattern = undefined;
									}
								}
							}

							if (!pattern) {
								/* Separate startValue. */
								separatedValue = separateValue(property, startValue);
								startValue = separatedValue[0];
								startValueUnitType = separatedValue[1];

								/* Separate endValue, and extract a value operator (e.g. "+=", "-=") if one exists. */
								separatedValue = separateValue(property, endValue);
								endValue = separatedValue[0].replace(/^([+-\/*])=/, function(match, subMatch) {
									operator = subMatch;

									/* Strip the operator off of the value. */
									return "";
								});
								endValueUnitType = separatedValue[1];

								/* Parse float values from endValue and startValue. Default to 0 if NaN is returned. */
								startValue = parseFloat(startValue) || 0;
								endValue = parseFloat(endValue) || 0;

								/***************************************
								 Property-Specific Value Conversion
								 ***************************************/

								/* Custom support for properties that don't actually accept the % unit type, but where pollyfilling is trivial and relatively foolproof. */
								if (endValueUnitType === "%") {
									/* A %-value fontSize/lineHeight is relative to the parent's fontSize (as opposed to the parent's dimensions),
									 which is identical to the em unit's behavior, so we piggyback off of that. */
									if (/^(fontSize|lineHeight)$/.test(property)) {
										/* Convert % into an em decimal value. */
										endValue = endValue / 100;
										endValueUnitType = "em";
										/* For scaleX and scaleY, convert the value into its decimal format and strip off the unit type. */
									} else if (/^scale/.test(property)) {
										endValue = endValue / 100;
										endValueUnitType = "";
										/* For RGB components, take the defined percentage of 255 and strip off the unit type. */
									} else if (/(Red|Green|Blue)$/i.test(property)) {
										endValue = (endValue / 100) * 255;
										endValueUnitType = "";
									}
								}
							}

							/***************************
							 Unit Ratio Calculation
							 ***************************/

							/* When queried, the browser returns (most) CSS property values in pixels. Therefore, if an endValue with a unit type of
							 %, em, or rem is animated toward, startValue must be converted from pixels into the same unit type as endValue in order
							 for value manipulation logic (increment/decrement) to proceed. Further, if the startValue was forcefed or transferred
							 from a previous call, startValue may also not be in pixels. Unit conversion logic therefore consists of two steps:
							 1) Calculating the ratio of %/em/rem/vh/vw relative to pixels
							 2) Converting startValue into the same unit of measurement as endValue based on these ratios. */
							/* Unit conversion ratios are calculated by inserting a sibling node next to the target node, copying over its position property,
							 setting values with the target unit type then comparing the returned pixel value. */
							/* Note: Even if only one of these unit types is being animated, all unit ratios are calculated at once since the overhead
							 of batching the SETs and GETs together upfront outweights the potential overhead
							 of layout thrashing caused by re-querying for uncalculated ratios for subsequently-processed properties. */
							/* Todo: Shift this logic into the calls' first tick instance so that it's synced with RAF. */
							var calculateUnitRatios = function() {

								/************************
								 Same Ratio Checks
								 ************************/

								/* The properties below are used to determine whether the element differs sufficiently from this call's
								 previously iterated element to also differ in its unit conversion ratios. If the properties match up with those
								 of the prior element, the prior element's conversion ratios are used. Like most optimizations in Velocity,
								 this is done to minimize DOM querying. */
								var sameRatioIndicators = {
									myParent: element.parentNode || document.body, /* GET */
									position: CSS.getPropertyValue(element, "position"), /* GET */
									fontSize: CSS.getPropertyValue(element, "fontSize") /* GET */
								},
										/* Determine if the same % ratio can be used. % is based on the element's position value and its parent's width and height dimensions. */
										samePercentRatio = ((sameRatioIndicators.position === callUnitConversionData.lastPosition) && (sameRatioIndicators.myParent === callUnitConversionData.lastParent)),
										/* Determine if the same em ratio can be used. em is relative to the element's fontSize. */
										sameEmRatio = (sameRatioIndicators.fontSize === callUnitConversionData.lastFontSize);

								/* Store these ratio indicators call-wide for the next element to compare against. */
								callUnitConversionData.lastParent = sameRatioIndicators.myParent;
								callUnitConversionData.lastPosition = sameRatioIndicators.position;
								callUnitConversionData.lastFontSize = sameRatioIndicators.fontSize;

								/***************************
								 Element-Specific Units
								 ***************************/

								/* Note: IE8 rounds to the nearest pixel when returning CSS values, thus we perform conversions using a measurement
								 of 100 (instead of 1) to give our ratios a precision of at least 2 decimal values. */
								var measurement = 100,
										unitRatios = {};

								if (!sameEmRatio || !samePercentRatio) {
									var dummy = data && data.isSVG ? document.createElementNS("http://www.w3.org/2000/svg", "rect") : document.createElement("div");

									Velocity.init(dummy);
									sameRatioIndicators.myParent.appendChild(dummy);

									/* To accurately and consistently calculate conversion ratios, the element's cascaded overflow and box-sizing are stripped.
									 Similarly, since width/height can be artificially constrained by their min-/max- equivalents, these are controlled for as well. */
									/* Note: Overflow must be also be controlled for per-axis since the overflow property overwrites its per-axis values. */
									$.each(["overflow", "overflowX", "overflowY"], function(i, property) {
										Velocity.CSS.setPropertyValue(dummy, property, "hidden");
									});
									Velocity.CSS.setPropertyValue(dummy, "position", sameRatioIndicators.position);
									Velocity.CSS.setPropertyValue(dummy, "fontSize", sameRatioIndicators.fontSize);
									Velocity.CSS.setPropertyValue(dummy, "boxSizing", "content-box");

									/* width and height act as our proxy properties for measuring the horizontal and vertical % ratios. */
									$.each(["minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height"], function(i, property) {
										Velocity.CSS.setPropertyValue(dummy, property, measurement + "%");
									});
									/* paddingLeft arbitrarily acts as our proxy property for the em ratio. */
									Velocity.CSS.setPropertyValue(dummy, "paddingLeft", measurement + "em");

									/* Divide the returned value by the measurement to get the ratio between 1% and 1px. Default to 1 since working with 0 can produce Infinite. */
									unitRatios.percentToPxWidth = callUnitConversionData.lastPercentToPxWidth = (parseFloat(CSS.getPropertyValue(dummy, "width", null, true)) || 1) / measurement; /* GET */
									unitRatios.percentToPxHeight = callUnitConversionData.lastPercentToPxHeight = (parseFloat(CSS.getPropertyValue(dummy, "height", null, true)) || 1) / measurement; /* GET */
									unitRatios.emToPx = callUnitConversionData.lastEmToPx = (parseFloat(CSS.getPropertyValue(dummy, "paddingLeft")) || 1) / measurement; /* GET */

									sameRatioIndicators.myParent.removeChild(dummy);
								} else {
									unitRatios.emToPx = callUnitConversionData.lastEmToPx;
									unitRatios.percentToPxWidth = callUnitConversionData.lastPercentToPxWidth;
									unitRatios.percentToPxHeight = callUnitConversionData.lastPercentToPxHeight;
								}

								/***************************
								 Element-Agnostic Units
								 ***************************/

								/* Whereas % and em ratios are determined on a per-element basis, the rem unit only needs to be checked
								 once per call since it's exclusively dependant upon document.body's fontSize. If this is the first time
								 that calculateUnitRatios() is being run during this call, remToPx will still be set to its default value of null,
								 so we calculate it now. */
								if (callUnitConversionData.remToPx === null) {
									/* Default to browsers' default fontSize of 16px in the case of 0. */
									callUnitConversionData.remToPx = parseFloat(CSS.getPropertyValue(document.body, "fontSize")) || 16; /* GET */
								}

								/* Similarly, viewport units are %-relative to the window's inner dimensions. */
								if (callUnitConversionData.vwToPx === null) {
									callUnitConversionData.vwToPx = parseFloat(window.innerWidth) / 100; /* GET */
									callUnitConversionData.vhToPx = parseFloat(window.innerHeight) / 100; /* GET */
								}

								unitRatios.remToPx = callUnitConversionData.remToPx;
								unitRatios.vwToPx = callUnitConversionData.vwToPx;
								unitRatios.vhToPx = callUnitConversionData.vhToPx;

								if (Velocity.debug >= 1) {
									console.log("Unit ratios: " + JSON.stringify(unitRatios), element);
								}
								return unitRatios;
							};

							/********************
							 Unit Conversion
							 ********************/

							/* The * and / operators, which are not passed in with an associated unit, inherently use startValue's unit. Skip value and unit conversion. */
							if (/[\/*]/.test(operator)) {
								endValueUnitType = startValueUnitType;
								/* If startValue and endValue differ in unit type, convert startValue into the same unit type as endValue so that if endValueUnitType
								 is a relative unit (%, em, rem), the values set during tweening will continue to be accurately relative even if the metrics they depend
								 on are dynamically changing during the course of the animation. Conversely, if we always normalized into px and used px for setting values, the px ratio
								 would become stale if the original unit being animated toward was relative and the underlying metrics change during the animation. */
								/* Since 0 is 0 in any unit type, no conversion is necessary when startValue is 0 -- we just start at 0 with endValueUnitType. */
							} else if ((startValueUnitType !== endValueUnitType) && startValue !== 0) {
								/* Unit conversion is also skipped when endValue is 0, but *startValueUnitType* must be used for tween values to remain accurate. */
								/* Note: Skipping unit conversion here means that if endValueUnitType was originally a relative unit, the animation won't relatively
								 match the underlying metrics if they change, but this is acceptable since we're animating toward invisibility instead of toward visibility,
								 which remains past the point of the animation's completion. */
								if (endValue === 0) {
									endValueUnitType = startValueUnitType;
								} else {
									/* By this point, we cannot avoid unit conversion (it's undesirable since it causes layout thrashing).
									 If we haven't already, we trigger calculateUnitRatios(), which runs once per element per call. */
									elementUnitConversionData = elementUnitConversionData || calculateUnitRatios();

									/* The following RegEx matches CSS properties that have their % values measured relative to the x-axis. */
									/* Note: W3C spec mandates that all of margin and padding's properties (even top and bottom) are %-relative to the *width* of the parent element. */
									var axis = (/margin|padding|left|right|width|text|word|letter/i.test(property) || /X$/.test(property) || property === "x") ? "x" : "y";

									/* In order to avoid generating n^2 bespoke conversion functions, unit conversion is a two-step process:
									 1) Convert startValue into pixels. 2) Convert this new pixel value into endValue's unit type. */
									switch (startValueUnitType) {
										case "%":
											/* Note: translateX and translateY are the only properties that are %-relative to an element's own dimensions -- not its parent's dimensions.
											 Velocity does not include a special conversion process to account for this behavior. Therefore, animating translateX/Y from a % value
											 to a non-% value will produce an incorrect start value. Fortunately, this sort of cross-unit conversion is rarely done by users in practice. */
											startValue *= (axis === "x" ? elementUnitConversionData.percentToPxWidth : elementUnitConversionData.percentToPxHeight);
											break;

										case "px":
											/* px acts as our midpoint in the unit conversion process; do nothing. */
											break;

										default:
											startValue *= elementUnitConversionData[startValueUnitType + "ToPx"];
									}

									/* Invert the px ratios to convert into to the target unit. */
									switch (endValueUnitType) {
										case "%":
											startValue *= 1 / (axis === "x" ? elementUnitConversionData.percentToPxWidth : elementUnitConversionData.percentToPxHeight);
											break;

										case "px":
											/* startValue is already in px, do nothing; we're done. */
											break;

										default:
											startValue *= 1 / elementUnitConversionData[endValueUnitType + "ToPx"];
									}
								}
							}

							/*********************
							 Relative Values
							 *********************/

							/* Operator logic must be performed last since it requires unit-normalized start and end values. */
							/* Note: Relative *percent values* do not behave how most people think; while one would expect "+=50%"
							 to increase the property 1.5x its current value, it in fact increases the percent units in absolute terms:
							 50 points is added on top of the current % value. */
							switch (operator) {
								case "+":
									endValue = startValue + endValue;
									break;

								case "-":
									endValue = startValue - endValue;
									break;

								case "*":
									endValue = startValue * endValue;
									break;

								case "/":
									endValue = startValue / endValue;
									break;
							}

							/**************************
							 tweensContainer Push
							 **************************/

							/* Construct the per-property tween object, and push it to the element's tweensContainer. */
							tweensContainer[property] = {
								rootPropertyValue: rootPropertyValue,
								startValue: startValue,
								currentValue: startValue,
								endValue: endValue,
								unitType: endValueUnitType,
								easing: easing
							};
							if (pattern) {
								tweensContainer[property].pattern = pattern;
							}

							if (Velocity.debug) {
								console.log("tweensContainer (" + property + "): " + JSON.stringify(tweensContainer[property]), element);
							}
						};

						/* Create a tween out of each property, and append its associated data to tweensContainer. */
						for (var property in propertiesMap) {

							if (!propertiesMap.hasOwnProperty(property)) {
								continue;
							}
							/* The original property name's format must be used for the parsePropertyValue() lookup,
							 but we then use its camelCase styling to normalize it for manipulation. */
							var propertyName = CSS.Names.camelCase(property),
									valueData = parsePropertyValue(propertiesMap[property]);

							/* Find shorthand color properties that have been passed a hex string. */
							/* Would be quicker to use CSS.Lists.colors.includes() if possible */
							if (_inArray(CSS.Lists.colors, propertyName)) {
								/* Parse the value data for each shorthand. */
								var endValue = valueData[0],
										easing = valueData[1],
										startValue = valueData[2];

								if (CSS.RegEx.isHex.test(endValue)) {
									/* Convert the hex strings into their RGB component arrays. */
									var colorComponents = ["Red", "Green", "Blue"],
											endValueRGB = CSS.Values.hexToRgb(endValue),
											startValueRGB = startValue ? CSS.Values.hexToRgb(startValue) : undefined;

									/* Inject the RGB component tweens into propertiesMap. */
									for (var i = 0; i < colorComponents.length; i++) {
										var dataArray = [endValueRGB[i]];

										if (easing) {
											dataArray.push(easing);
										}

										if (startValueRGB !== undefined) {
											dataArray.push(startValueRGB[i]);
										}

										fixPropertyValue(propertyName + colorComponents[i], dataArray);
									}
									/* If we have replaced a shortcut color value then don't update the standard property name */
									continue;
								}
							}
							fixPropertyValue(propertyName, valueData);
						}

						/* Along with its property data, store a reference to the element itself onto tweensContainer. */
						tweensContainer.element = element;
					}

					/*****************
					 Call Push
					 *****************/

					/* Note: tweensContainer can be empty if all of the properties in this call's property map were skipped due to not
					 being supported by the browser. The element property is used for checking that the tweensContainer has been appended to. */
					if (tweensContainer.element) {
						/* Apply the "velocity-animating" indicator class. */
						CSS.Values.addClass(element, "velocity-animating");

						/* The call array houses the tweensContainers for each element being animated in the current call. */
						call.push(tweensContainer);

						data = Data(element);

						if (data) {
							/* Store the tweensContainer and options if we're working on the default effects queue, so that they can be used by the reverse command. */
							if (opts.queue === "") {

								data.tweensContainer = tweensContainer;
								data.opts = opts;
							}

							/* Switch on the element's animating flag. */
							data.isAnimating = true;
						}

						/* Once the final element in this call's element set has been processed, push the call array onto
						 Velocity.State.calls for the animation tick to immediately begin processing. */
						if (elementsIndex === elementsLength - 1) {
							/* Add the current call plus its associated metadata (the element set and the call's options) onto the global call container.
							 Anything on this call container is subjected to tick() processing. */
							Velocity.State.calls.push([call, elements, opts, null, promiseData.resolver, null, 0]);

							/* If the animation tick isn't running, start it. (Velocity shuts it off when there are no active calls to process.) */
							if (Velocity.State.isTicking === false) {
								Velocity.State.isTicking = true;

								/* Start the tick loop. */
								tick();
							}
						} else {
							elementsIndex++;
						}
					}
				}

				/* When the queue option is set to false, the call skips the element's queue and fires immediately. */
				if (opts.queue === false) {
					/* Since this buildQueue call doesn't respect the element's existing queue (which is where a delay option would have been appended),
					 we manually inject the delay property here with an explicit setTimeout. */
					if (opts.delay) {

						/* Temporarily store delayed elements to facilitate access for global pause/resume */
						var callIndex = Velocity.State.delayedElements.count++;
						Velocity.State.delayedElements[callIndex] = element;

						var delayComplete = (function(index) {
							return function() {
								/* Clear the temporary element */
								Velocity.State.delayedElements[index] = false;

								/* Finally, issue the call */
								buildQueue();
							};
						})(callIndex);

						Data(element).delayBegin = (new Date()).getTime();
						Data(element).delay = parseFloat(opts.delay);
						Data(element).delayTimer = {
							setTimeout: setTimeout(buildQueue, parseFloat(opts.delay)),
							next: delayComplete
						};
					} else {
						buildQueue();
					}
					/* Otherwise, the call undergoes element queueing as normal. */
					/* Note: To interoperate with jQuery, Velocity uses jQuery's own $.queue() stack for queuing logic. */
				} else {
					$.queue(element, opts.queue, function(next, clearQueue) {
						/* If the clearQueue flag was passed in by the stop command, resolve this call's promise. (Promises can only be resolved once,
						 so it's fine if this is repeatedly triggered for each element in the associated call.) */
						if (clearQueue === true) {
							if (promiseData.promise) {
								promiseData.resolver(elements);
							}

							/* Do not continue with animation queueing. */
							return true;
						}

						/* This flag indicates to the upcoming completeCall() function that this queue entry was initiated by Velocity.
						 See completeCall() for further details. */
						Velocity.velocityQueueEntryFlag = true;

						buildQueue(next);
					});
				}

				/*********************
				 Auto-Dequeuing
				 *********************/

				/* As per jQuery's $.queue() behavior, to fire the first non-custom-queue entry on an element, the element
				 must be dequeued if its queue stack consists *solely* of the current call. (This can be determined by checking
				 for the "inprogress" item that jQuery prepends to active queue stack arrays.) Regardless, whenever the element's
				 queue is further appended with additional items -- including $.delay()'s or even $.animate() calls, the queue's
				 first entry is automatically fired. This behavior contrasts that of custom queues, which never auto-fire. */
				/* Note: When an element set is being subjected to a non-parallel Velocity call, the animation will not begin until
				 each one of the elements in the set has reached the end of its individually pre-existing queue chain. */
				/* Note: Unfortunately, most people don't fully grasp jQuery's powerful, yet quirky, $.queue() function.
				 Lean more here: http://stackoverflow.com/questions/1058158/can-somebody-explain-jquery-queue-to-me */
				if ((opts.queue === "" || opts.queue === "fx") && $.queue(element)[0] !== "inprogress") {
					$.dequeue(element);
				}
			}

			/**************************
			 Element Set Iteration
			 **************************/

			/* If the "nodeType" property exists on the elements variable, we're animating a single element.
			 Place it in an array so that $.each() can iterate over it. */
			$.each(elements, function(i, element) {
				/* Ensure each element in a set has a nodeType (is a real element) to avoid throwing errors. */
				if (Type.isNode(element)) {
					processElement(element, i);
				}
			});

			/******************
			 Option: Loop
			 ******************/

			/* The loop option accepts an integer indicating how many times the element should loop between the values in the
			 current call's properties map and the element's property values prior to this call. */
			/* Note: The loop option's logic is performed here -- after element processing -- because the current call needs
			 to undergo its queue insertion prior to the loop option generating its series of constituent "reverse" calls,
			 which chain after the current call. Two reverse calls (two "alternations") constitute one loop. */
			opts = $.extend({}, Velocity.defaults, options);
			opts.loop = parseInt(opts.loop, 10);
			var reverseCallsCount = (opts.loop * 2) - 1;

			if (opts.loop) {
				/* Double the loop count to convert it into its appropriate number of "reverse" calls.
				 Subtract 1 from the resulting value since the current call is included in the total alternation count. */
				for (var x = 0; x < reverseCallsCount; x++) {
					/* Since the logic for the reverse action occurs inside Queueing and therefore this call's options object
					 isn't parsed until then as well, the current call's delay option must be explicitly passed into the reverse
					 call so that the delay logic that occurs inside *Pre-Queueing* can process it. */
					var reverseOptions = {
						delay: opts.delay,
						progress: opts.progress
					};

					/* If a complete callback was passed into this call, transfer it to the loop redirect's final "reverse" call
					 so that it's triggered when the entire redirect is complete (and not when the very first animation is complete). */
					if (x === reverseCallsCount - 1) {
						reverseOptions.display = opts.display;
						reverseOptions.visibility = opts.visibility;
						reverseOptions.complete = opts.complete;
					}

					animate(elements, "reverse", reverseOptions);
				}
			}

			/***************
			 Chaining
			 ***************/

			/* Return the elements back to the call chain, with wrapped elements taking precedence in case Velocity was called via the $.fn. extension. */
			return getChain();
		};

		/* Turn Velocity into the animation function, extended with the pre-existing Velocity object. */
		Velocity = $.extend(animate, Velocity);
		/* For legacy support, also expose the literal animate method. */
		Velocity.animate = animate;

		/**************
		 Timing
		 **************/

		/* Ticker function. */
		var ticker = window.requestAnimationFrame || rAFShim;

		/* Inactive browser tabs pause rAF, which results in all active animations immediately sprinting to their completion states when the tab refocuses.
		 To get around this, we dynamically switch rAF to setTimeout (which the browser *doesn't* pause) when the tab loses focus. We skip this for mobile
		 devices to avoid wasting battery power on inactive tabs. */
		/* Note: Tab focus detection doesn't work on older versions of IE, but that's okay since they don't support rAF to begin with. */
		if (!Velocity.State.isMobile && document.hidden !== undefined) {
			var updateTicker = function() {
				/* Reassign the rAF function (which the global tick() function uses) based on the tab's focus state. */
				if (document.hidden) {
					ticker = function(callback) {
						/* The tick function needs a truthy first argument in order to pass its internal timestamp check. */
						return setTimeout(function() {
							callback(true);
						}, 16);
					};

					/* The rAF loop has been paused by the browser, so we manually restart the tick. */
					tick();
				} else {
					ticker = window.requestAnimationFrame || rAFShim;
				}
			};

			/* Page could be sitting in the background at this time (i.e. opened as new tab) so making sure we use correct ticker from the start */
			updateTicker();

			/* And then run check again every time visibility changes */
			document.addEventListener("visibilitychange", updateTicker);
		}

		/************
		 Tick
		 ************/

		/* Note: All calls to Velocity are pushed to the Velocity.State.calls array, which is fully iterated through upon each tick. */
		function tick(timestamp) {
			/* An empty timestamp argument indicates that this is the first tick occurence since ticking was turned on.
			 We leverage this metadata to fully ignore the first tick pass since RAF's initial pass is fired whenever
			 the browser's next tick sync time occurs, which results in the first elements subjected to Velocity
			 calls being animated out of sync with any elements animated immediately thereafter. In short, we ignore
			 the first RAF tick pass so that elements being immediately consecutively animated -- instead of simultaneously animated
			 by the same Velocity call -- are properly batched into the same initial RAF tick and consequently remain in sync thereafter. */
			if (timestamp) {
				/* We normally use RAF's high resolution timestamp but as it can be significantly offset when the browser is
				 under high stress we give the option for choppiness over allowing the browser to drop huge chunks of frames.
				 We use performance.now() and shim it if it doesn't exist for when the tab is hidden. */
				var timeCurrent = Velocity.timestamp && timestamp !== true ? timestamp : performance.now();

				/********************
				 Call Iteration
				 ********************/

				var callsLength = Velocity.State.calls.length;

				/* To speed up iterating over this array, it is compacted (falsey items -- calls that have completed -- are removed)
				 when its length has ballooned to a point that can impact tick performance. This only becomes necessary when animation
				 has been continuous with many elements over a long period of time; whenever all active calls are completed, completeCall() clears Velocity.State.calls. */
				if (callsLength > 10000) {
					Velocity.State.calls = compactSparseArray(Velocity.State.calls);
					callsLength = Velocity.State.calls.length;
				}

				/* Iterate through each active call. */
				for (var i = 0; i < callsLength; i++) {
					/* When a Velocity call is completed, its Velocity.State.calls entry is set to false. Continue on to the next call. */
					if (!Velocity.State.calls[i]) {
						continue;
					}

					/************************
					 Call-Wide Variables
					 ************************/

					var callContainer = Velocity.State.calls[i],
							call = callContainer[0],
							opts = callContainer[2],
							timeStart = callContainer[3],
							firstTick = !timeStart,
							tweenDummyValue = null,
							pauseObject = callContainer[5],
							millisecondsEllapsed = callContainer[6];



					/* If timeStart is undefined, then this is the first time that this call has been processed by tick().
					 We assign timeStart now so that its value is as close to the real animation start time as possible.
					 (Conversely, had timeStart been defined when this call was added to Velocity.State.calls, the delay
					 between that time and now would cause the first few frames of the tween to be skipped since
					 percentComplete is calculated relative to timeStart.) */
					/* Further, subtract 16ms (the approximate resolution of RAF) from the current time value so that the
					 first tick iteration isn't wasted by animating at 0% tween completion, which would produce the
					 same style value as the element's current value. */
					if (!timeStart) {
						timeStart = Velocity.State.calls[i][3] = timeCurrent - 16;
					}

					/* If a pause object is present, skip processing unless it has been set to resume */
					if (pauseObject) {
						if (pauseObject.resume === true) {
							/* Update the time start to accomodate the paused completion amount */
							timeStart = callContainer[3] = Math.round(timeCurrent - millisecondsEllapsed - 16);

							/* Remove pause object after processing */
							callContainer[5] = null;
						} else {
							continue;
						}
					}

					millisecondsEllapsed = callContainer[6] = timeCurrent - timeStart;

					/* The tween's completion percentage is relative to the tween's start time, not the tween's start value
					 (which would result in unpredictable tween durations since JavaScript's timers are not particularly accurate).
					 Accordingly, we ensure that percentComplete does not exceed 1. */
					var percentComplete = Math.min((millisecondsEllapsed) / opts.duration, 1);

					/**********************
					 Element Iteration
					 **********************/

					/* For every call, iterate through each of the elements in its set. */
					for (var j = 0, callLength = call.length; j < callLength; j++) {
						var tweensContainer = call[j],
								element = tweensContainer.element;

						/* Check to see if this element has been deleted midway through the animation by checking for the
						 continued existence of its data cache. If it's gone, or the element is currently paused, skip animating this element. */
						if (!Data(element)) {
							continue;
						}

						var transformPropertyExists = false;

						/**********************************
						 Display & Visibility Toggling
						 **********************************/

						/* If the display option is set to non-"none", set it upfront so that the element can become visible before tweening begins.
						 (Otherwise, display's "none" value is set in completeCall() once the animation has completed.) */
						if (opts.display !== undefined && opts.display !== null && opts.display !== "none") {
							if (opts.display === "flex") {
								var flexValues = ["-webkit-box", "-moz-box", "-ms-flexbox", "-webkit-flex"];

								$.each(flexValues, function(i, flexValue) {
									CSS.setPropertyValue(element, "display", flexValue);
								});
							}

							CSS.setPropertyValue(element, "display", opts.display);
						}

						/* Same goes with the visibility option, but its "none" equivalent is "hidden". */
						if (opts.visibility !== undefined && opts.visibility !== "hidden") {
							CSS.setPropertyValue(element, "visibility", opts.visibility);
						}

						/************************
						 Property Iteration
						 ************************/

						/* For every element, iterate through each property. */
						for (var property in tweensContainer) {
							/* Note: In addition to property tween data, tweensContainer contains a reference to its associated element. */
							if (tweensContainer.hasOwnProperty(property) && property !== "element") {
								var tween = tweensContainer[property],
										currentValue,
										/* Easing can either be a pre-genereated function or a string that references a pre-registered easing
										 on the Velocity.Easings object. In either case, return the appropriate easing *function*. */
										easing = Type.isString(tween.easing) ? Velocity.Easings[tween.easing] : tween.easing;

								/******************************
								 Current Value Calculation
								 ******************************/

								if (Type.isString(tween.pattern)) {
									var patternReplace = percentComplete === 1 ?
											function($0, index, round) {
												var result = tween.endValue[index];

												return round ? Math.round(result) : result;
											} :
											function($0, index, round) {
												var startValue = tween.startValue[index],
														tweenDelta = tween.endValue[index] - startValue,
														result = startValue + (tweenDelta * easing(percentComplete, opts, tweenDelta));

												return round ? Math.round(result) : result;
											};

									currentValue = tween.pattern.replace(/{(\d+)(!)?}/g, patternReplace);
								} else if (percentComplete === 1) {
									/* If this is the last tick pass (if we've reached 100% completion for this tween),
									 ensure that currentValue is explicitly set to its target endValue so that it's not subjected to any rounding. */
									currentValue = tween.endValue;
								} else {
									/* Otherwise, calculate currentValue based on the current delta from startValue. */
									var tweenDelta = tween.endValue - tween.startValue;

									currentValue = tween.startValue + (tweenDelta * easing(percentComplete, opts, tweenDelta));
									/* If no value change is occurring, don't proceed with DOM updating. */
								}
								if (!firstTick && (currentValue === tween.currentValue)) {
									continue;
								}

								tween.currentValue = currentValue;

								/* If we're tweening a fake 'tween' property in order to log transition values, update the one-per-call variable so that
								 it can be passed into the progress callback. */
								if (property === "tween") {
									tweenDummyValue = currentValue;
								} else {
									/******************
									 Hooks: Part I
									 ******************/
									var hookRoot;

									/* For hooked properties, the newly-updated rootPropertyValueCache is cached onto the element so that it can be used
									 for subsequent hooks in this call that are associated with the same root property. If we didn't cache the updated
									 rootPropertyValue, each subsequent update to the root property in this tick pass would reset the previous hook's
									 updates to rootPropertyValue prior to injection. A nice performance byproduct of rootPropertyValue caching is that
									 subsequently chained animations using the same hookRoot but a different hook can use this cached rootPropertyValue. */
									if (CSS.Hooks.registered[property]) {
										hookRoot = CSS.Hooks.getRoot(property);

										var rootPropertyValueCache = Data(element).rootPropertyValueCache[hookRoot];

										if (rootPropertyValueCache) {
											tween.rootPropertyValue = rootPropertyValueCache;
										}
									}

									/*****************
									 DOM Update
									 *****************/

									/* setPropertyValue() returns an array of the property name and property value post any normalization that may have been performed. */
									/* Note: To solve an IE<=8 positioning bug, the unit type is dropped when setting a property value of 0. */
									var adjustedSetData = CSS.setPropertyValue(element, /* SET */
											property,
											tween.currentValue + (IE < 9 && parseFloat(currentValue) === 0 ? "" : tween.unitType),
											tween.rootPropertyValue,
											tween.scrollData);

									/*******************
									 Hooks: Part II
									 *******************/

									/* Now that we have the hook's updated rootPropertyValue (the post-processed value provided by adjustedSetData), cache it onto the element. */
									if (CSS.Hooks.registered[property]) {
										/* Since adjustedSetData contains normalized data ready for DOM updating, the rootPropertyValue needs to be re-extracted from its normalized form. ?? */
										if (CSS.Normalizations.registered[hookRoot]) {
											Data(element).rootPropertyValueCache[hookRoot] = CSS.Normalizations.registered[hookRoot]("extract", null, adjustedSetData[1]);
										} else {
											Data(element).rootPropertyValueCache[hookRoot] = adjustedSetData[1];
										}
									}

									/***************
									 Transforms
									 ***************/

									/* Flag whether a transform property is being animated so that flushTransformCache() can be triggered once this tick pass is complete. */
									if (adjustedSetData[0] === "transform") {
										transformPropertyExists = true;
									}

								}
							}
						}

						/****************
						 mobileHA
						 ****************/

						/* If mobileHA is enabled, set the translate3d transform to null to force hardware acceleration.
						 It's safe to override this property since Velocity doesn't actually support its animation (hooks are used in its place). */
						if (opts.mobileHA) {
							/* Don't set the null transform hack if we've already done so. */
							if (Data(element).transformCache.translate3d === undefined) {
								/* All entries on the transformCache object are later concatenated into a single transform string via flushTransformCache(). */
								Data(element).transformCache.translate3d = "(0px, 0px, 0px)";

								transformPropertyExists = true;
							}
						}

						if (transformPropertyExists) {
							CSS.flushTransformCache(element);
						}
					}

					/* The non-"none" display value is only applied to an element once -- when its associated call is first ticked through.
					 Accordingly, it's set to false so that it isn't re-processed by this call in the next tick. */
					if (opts.display !== undefined && opts.display !== "none") {
						Velocity.State.calls[i][2].display = false;
					}
					if (opts.visibility !== undefined && opts.visibility !== "hidden") {
						Velocity.State.calls[i][2].visibility = false;
					}

					/* Pass the elements and the timing data (percentComplete, msRemaining, timeStart, tweenDummyValue) into the progress callback. */
					if (opts.progress) {
						opts.progress.call(callContainer[1],
								callContainer[1],
								percentComplete,
								Math.max(0, (timeStart + opts.duration) - timeCurrent),
								timeStart,
								tweenDummyValue);
					}

					/* If this call has finished tweening, pass its index to completeCall() to handle call cleanup. */
					if (percentComplete === 1) {
						completeCall(i);
					}
				}
			}

			/* Note: completeCall() sets the isTicking flag to false when the last call on Velocity.State.calls has completed. */
			if (Velocity.State.isTicking) {
				ticker(tick);
			}
		}

		/**********************
		 Call Completion
		 **********************/

		/* Note: Unlike tick(), which processes all active calls at once, call completion is handled on a per-call basis. */
		function completeCall(callIndex, isStopped) {
			/* Ensure the call exists. */
			if (!Velocity.State.calls[callIndex]) {
				return false;
			}

			/* Pull the metadata from the call. */
			var call = Velocity.State.calls[callIndex][0],
					elements = Velocity.State.calls[callIndex][1],
					opts = Velocity.State.calls[callIndex][2],
					resolver = Velocity.State.calls[callIndex][4];

			var remainingCallsExist = false;

			/*************************
			 Element Finalization
			 *************************/

			for (var i = 0, callLength = call.length; i < callLength; i++) {
				var element = call[i].element;

				/* If the user set display to "none" (intending to hide the element), set it now that the animation has completed. */
				/* Note: display:none isn't set when calls are manually stopped (via Velocity("stop"). */
				/* Note: Display gets ignored with "reverse" calls and infinite loops, since this behavior would be undesirable. */
				if (!isStopped && !opts.loop) {
					if (opts.display === "none") {
						CSS.setPropertyValue(element, "display", opts.display);
					}

					if (opts.visibility === "hidden") {
						CSS.setPropertyValue(element, "visibility", opts.visibility);
					}
				}

				/* If the element's queue is empty (if only the "inprogress" item is left at position 0) or if its queue is about to run
				 a non-Velocity-initiated entry, turn off the isAnimating flag. A non-Velocity-initiatied queue entry's logic might alter
				 an element's CSS values and thereby cause Velocity's cached value data to go stale. To detect if a queue entry was initiated by Velocity,
				 we check for the existence of our special Velocity.queueEntryFlag declaration, which minifiers won't rename since the flag
				 is assigned to jQuery's global $ object and thus exists out of Velocity's own scope. */
				var data = Data(element);

				if (opts.loop !== true && ($.queue(element)[1] === undefined || !/\.velocityQueueEntryFlag/i.test($.queue(element)[1]))) {
					/* The element may have been deleted. Ensure that its data cache still exists before acting on it. */
					if (data) {
						data.isAnimating = false;
						/* Clear the element's rootPropertyValueCache, which will become stale. */
						data.rootPropertyValueCache = {};

						var transformHAPropertyExists = false;
						/* If any 3D transform subproperty is at its default value (regardless of unit type), remove it. */
						$.each(CSS.Lists.transforms3D, function(i, transformName) {
							var defaultValue = /^scale/.test(transformName) ? 1 : 0,
									currentValue = data.transformCache[transformName];

							if (data.transformCache[transformName] !== undefined && new RegExp("^\\(" + defaultValue + "[^.]").test(currentValue)) {
								transformHAPropertyExists = true;

								delete data.transformCache[transformName];
							}
						});

						/* Mobile devices have hardware acceleration removed at the end of the animation in order to avoid hogging the GPU's memory. */
						if (opts.mobileHA) {
							transformHAPropertyExists = true;
							delete data.transformCache.translate3d;
						}

						/* Flush the subproperty removals to the DOM. */
						if (transformHAPropertyExists) {
							CSS.flushTransformCache(element);
						}

						/* Remove the "velocity-animating" indicator class. */
						CSS.Values.removeClass(element, "velocity-animating");
					}
				}

				/*********************
				 Option: Complete
				 *********************/

				/* Complete is fired once per call (not once per element) and is passed the full raw DOM element set as both its context and its first argument. */
				/* Note: Callbacks aren't fired when calls are manually stopped (via Velocity("stop"). */
				if (!isStopped && opts.complete && !opts.loop && (i === callLength - 1)) {
					/* We throw callbacks in a setTimeout so that thrown errors don't halt the execution of Velocity itself. */
					try {
						opts.complete.call(elements, elements);
					} catch (error) {
						setTimeout(function() {
							throw error;
						}, 1);
					}
				}

				/**********************
				 Promise Resolving
				 **********************/

				/* Note: Infinite loops don't return promises. */
				if (resolver && opts.loop !== true) {
					resolver(elements);
				}

				/****************************
				 Option: Loop (Infinite)
				 ****************************/

				if (data && opts.loop === true && !isStopped) {
					/* If a rotateX/Y/Z property is being animated by 360 deg with loop:true, swap tween start/end values to enable
					 continuous iterative rotation looping. (Otherise, the element would just rotate back and forth.) */
					$.each(data.tweensContainer, function(propertyName, tweenContainer) {
						if (/^rotate/.test(propertyName) && ((parseFloat(tweenContainer.startValue) - parseFloat(tweenContainer.endValue)) % 360 === 0)) {
							var oldStartValue = tweenContainer.startValue;

							tweenContainer.startValue = tweenContainer.endValue;
							tweenContainer.endValue = oldStartValue;
						}

						if (/^backgroundPosition/.test(propertyName) && parseFloat(tweenContainer.endValue) === 100 && tweenContainer.unitType === "%") {
							tweenContainer.endValue = 0;
							tweenContainer.startValue = 100;
						}
					});

					Velocity(element, "reverse", {loop: true, delay: opts.delay});
				}

				/***************
				 Dequeueing
				 ***************/

				/* Fire the next call in the queue so long as this call's queue wasn't set to false (to trigger a parallel animation),
				 which would have already caused the next call to fire. Note: Even if the end of the animation queue has been reached,
				 $.dequeue() must still be called in order to completely clear jQuery's animation queue. */
				if (opts.queue !== false) {
					$.dequeue(element, opts.queue);
				}
			}

			/************************
			 Calls Array Cleanup
			 ************************/

			/* Since this call is complete, set it to false so that the rAF tick skips it. This array is later compacted via compactSparseArray().
			 (For performance reasons, the call is set to false instead of being deleted from the array: http://www.html5rocks.com/en/tutorials/speed/v8/) */
			Velocity.State.calls[callIndex] = false;

			/* Iterate through the calls array to determine if this was the final in-progress animation.
			 If so, set a flag to end ticking and clear the calls array. */
			for (var j = 0, callsLength = Velocity.State.calls.length; j < callsLength; j++) {
				if (Velocity.State.calls[j] !== false) {
					remainingCallsExist = true;

					break;
				}
			}

			if (remainingCallsExist === false) {
				/* tick() will detect this flag upon its next iteration and subsequently turn itself off. */
				Velocity.State.isTicking = false;

				/* Clear the calls array so that its length is reset. */
				delete Velocity.State.calls;
				Velocity.State.calls = [];
			}
		}

		/******************
		 Frameworks
		 ******************/

		/* Both jQuery and Zepto allow their $.fn object to be extended to allow wrapped elements to be subjected to plugin calls.
		 If either framework is loaded, register a "velocity" extension pointing to Velocity's core animate() method.  Velocity
		 also registers itself onto a global container (window.jQuery || window.Zepto || window) so that certain features are
		 accessible beyond just a per-element scope. This master object contains an .animate() method, which is later assigned to $.fn
		 (if jQuery or Zepto are present). Accordingly, Velocity can both act on wrapped DOM elements and stand alone for targeting raw DOM elements. */
		global.Velocity = Velocity;

		if (global !== window) {
			/* Assign the element function to Velocity's core animate() method. */
			global.fn.velocity = animate;
			/* Assign the object function's defaults to Velocity's global defaults object. */
			global.fn.velocity.defaults = Velocity.defaults;
		}

		/***********************
		 Packaged Redirects
		 ***********************/

		/* slideUp, slideDown */
		$.each(["Down", "Up"], function(i, direction) {
			Velocity.Redirects["slide" + direction] = function(element, options, elementsIndex, elementsSize, elements, promiseData) {
				var opts = $.extend({}, options),
						begin = opts.begin,
						complete = opts.complete,
						inlineValues = {},
						computedValues = {height: "", marginTop: "", marginBottom: "", paddingTop: "", paddingBottom: ""};

				if (opts.display === undefined) {
					/* Show the element before slideDown begins and hide the element after slideUp completes. */
					/* Note: Inline elements cannot have dimensions animated, so they're reverted to inline-block. */
					opts.display = (direction === "Down" ? (Velocity.CSS.Values.getDisplayType(element) === "inline" ? "inline-block" : "block") : "none");
				}

				opts.begin = function() {
					/* If the user passed in a begin callback, fire it now. */
					if (elementsIndex === 0 && begin) {
						begin.call(elements, elements);
					}

					/* Cache the elements' original vertical dimensional property values so that we can animate back to them. */
					for (var property in computedValues) {
						if (!computedValues.hasOwnProperty(property)) {
							continue;
						}
						inlineValues[property] = element.style[property];

						/* For slideDown, use forcefeeding to animate all vertical properties from 0. For slideUp,
						 use forcefeeding to start from computed values and animate down to 0. */
						var propertyValue = CSS.getPropertyValue(element, property);
						computedValues[property] = (direction === "Down") ? [propertyValue, 0] : [0, propertyValue];
					}

					/* Force vertical overflow content to clip so that sliding works as expected. */
					inlineValues.overflow = element.style.overflow;
					element.style.overflow = "hidden";
				};

				opts.complete = function() {
					/* Reset element to its pre-slide inline values once its slide animation is complete. */
					for (var property in inlineValues) {
						if (inlineValues.hasOwnProperty(property)) {
							element.style[property] = inlineValues[property];
						}
					}

					/* If the user passed in a complete callback, fire it now. */
					if (elementsIndex === elementsSize - 1) {
						if (complete) {
							complete.call(elements, elements);
						}
						if (promiseData) {
							promiseData.resolver(elements);
						}
					}
				};

				Velocity(element, computedValues, opts);
			};
		});

		/* fadeIn, fadeOut */
		$.each(["In", "Out"], function(i, direction) {
			Velocity.Redirects["fade" + direction] = function(element, options, elementsIndex, elementsSize, elements, promiseData) {
				var opts = $.extend({}, options),
						complete = opts.complete,
						propertiesMap = {opacity: (direction === "In") ? 1 : 0};

				/* Since redirects are triggered individually for each element in the animated set, avoid repeatedly triggering
				 callbacks by firing them only when the final element has been reached. */
				if (elementsIndex !== 0) {
					opts.begin = null;
				}
				if (elementsIndex !== elementsSize - 1) {
					opts.complete = null;
				} else {
					opts.complete = function() {
						if (complete) {
							complete.call(elements, elements);
						}
						if (promiseData) {
							promiseData.resolver(elements);
						}
					};
				}

				/* If a display was passed in, use it. Otherwise, default to "none" for fadeOut or the element-specific default for fadeIn. */
				/* Note: We allow users to pass in "null" to skip display setting altogether. */
				if (opts.display === undefined) {
					opts.display = (direction === "In" ? "auto" : "none");
				}

				Velocity(this, propertiesMap, opts);
			};
		});

		return Velocity;
	}((__webpack_provided_window_dot_jQuery || window.Zepto || window), window, (window ? window.document : undefined));
}));

/******************
 Known Issues
 ******************/

/* The CSS spec mandates that the translateX/Y/Z transforms are %-relative to the element itself -- not its parent.
 Velocity, however, doesn't make this distinction. Thus, converting to or from the % unit with these subproperties
 will produce an inaccurate conversion value. The same issue exists with the cx/cy attributes of SVG circles and ellipses. */

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(0)))

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", { value: true });
var maquette = __webpack_require__(1);
var h = maquette.h;
var CaliforniaApp_1 = __webpack_require__(3);
var CaliforniaGenerated_1 = __webpack_require__(2);
var ClientState_1 = __webpack_require__(4);
var PropertyBarVM_1 = __webpack_require__(5);
var currentApp;
var currentRouter;
var CaliforniaRouter = function () {
    function CaliforniaRouter(californiaAppArg) {
        this.deepestLevelCurrentRow = 0;
        this.updateData = function (response, isInitial, preventRenderChainedCalls) {
            var _a;
            if (isInitial === void 0) {
                isInitial = false;
            }
            if (preventRenderChainedCalls === void 0) {
                preventRenderChainedCalls = false;
            }
            var isValidResponse = currentRouter.validateResponse(response);
            if (!isValidResponse) {
                return;
            }
            var isFullDataUpdate = false;
            var isUpdateSuccess = false;
            switch (response.CaliforniaEvent) {
                case CaliforniaGenerated_1.CaliforniaEvent.UpdateContentAtom:
                    if (response.PartialUpdate.ContentAtom !== undefined) {
                        var currentContentAtomIndex = currentApp.clientData.CaliforniaProject.ContentAtoms.findIndex(function (c) {
                            return c.ContentAtomId == response.PartialUpdate.ContentAtom.ContentAtomId;
                        });
                        (_a = currentApp.clientData.CaliforniaProject.ContentAtoms).splice.apply(_a, [currentContentAtomIndex, 1].concat([response.PartialUpdate.ContentAtom]));
                        currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                            return l.LayoutBaseId == response.PartialUpdate.ContentAtom.InstancedOnLayoutId;
                        }).HostedContentAtom = response.PartialUpdate.ContentAtom;
                        isUpdateSuccess = true;
                    }
                    break;
                default:
                    isFullDataUpdate = true;
                    break;
            }
            if (isFullDataUpdate === true) {
                if (response.CaliforniaProject !== undefined) {
                    currentApp.clientData.CaliforniaProject = response.CaliforniaProject;
                    currentApp.clientData.UrlToReadOnly = response.UrlToReadOnly;
                    currentApp.clientData.UrlToReadAndEdit = response.UrlToReadAndEdit;
                    if (response.CaliforniaProject.ResponsiveDevices.length !== undefined && response.CaliforniaProject.ResponsiveDevices.length > 0) {
                        currentApp.clientData.CaliforniaProject.ResponsiveDevices = currentApp.clientData.CaliforniaProject.ResponsiveDevices.sort(function (r1, r2) {
                            return r1.WidthThreshold !== undefined && r2.WidthThreshold !== undefined ? r1.WidthThreshold < r2.WidthThreshold ? -1 : r1.WidthThreshold == r2.WidthThreshold ? 0 : 1 : 0;
                        });
                        currentApp.state.lowestWidthThresholdResponsiveDeviceId = currentApp.clientData.CaliforniaProject.ResponsiveDevices[1].ResponsiveDeviceId;
                        currentApp.state.highestWidthThresholdResponsiveDeviceId = currentApp.clientData.CaliforniaProject.ResponsiveDevices[currentApp.clientData.CaliforniaProject.ResponsiveDevices.length - 1].ResponsiveDeviceId;
                        currentApp.state.noneResponsiveDeviceId = currentApp.clientData.CaliforniaProject.ResponsiveDevices[0].ResponsiveDeviceId;
                        if (isInitial) {
                            for (var i = 0; i < currentApp.propertyBars.length; i++) {
                                var propertyBar = currentApp.propertyBars[i];
                                propertyBar.viewModel.setSelectedResponsiveDeviceId(currentApp.state.noneResponsiveDeviceId, true);
                            }
                        }
                        if (currentApp.pagePreview.virtualStyleIndex.length == 0) {
                            currentApp.pagePreview.virtualStyleIndex = [];
                            currentApp.pagePreview.virtualPseudoStyleIndex = [];
                            for (var _i = 0, _b = currentApp.clientData.CaliforniaProject.ResponsiveDevices; _i < _b.length; _i++) {
                                var responsiveDevice = _b[_i];
                                currentApp.pagePreview.virtualStyleIndex.push([]);
                                currentApp.pagePreview.virtualPseudoStyleIndex.push({});
                            }
                        }
                    }
                    if (isInitial === true) {
                        currentApp.clientData.AllCssProperties = response.AllCssProperties;
                        currentApp.clientData.StyleAtomCssPropertyMapping = response.StyleAtomCssPropertyMapping;
                    }
                    if (currentApp.clientData.CaliforniaProject.StyleQuantums !== undefined && currentApp.clientData.CaliforniaProject.StyleAtoms !== undefined && currentApp.clientData.CaliforniaProject.StyleMolecules !== undefined && currentApp.clientData.CaliforniaProject.LayoutMolecules !== undefined && currentApp.clientData.CaliforniaProject.CaliforniaViews !== undefined && currentApp.clientData.CaliforniaProject.CaliforniaViews.length > 0) {
                        currentRouter.restoreLayoutMoleculeAndStyleReferences();
                        currentApp.state.specialStyleHolder = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (v) {
                            return v.IsInternal === true && v.Name === "[Internal] Special Styles";
                        });
                        if (currentApp.state.specialStyleHolder === undefined) {
                            console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                            return;
                        }
                        currentApp.clientData.CaliforniaProject.CaliforniaViews.filter(function (v) {
                            return !v.IsInternal;
                        }).map(function (v) {
                            if (currentApp.state.specialStyleHolder !== undefined) {
                                var californiaViewStyleHolderRow = currentApp.state.specialStyleHolder.PlacedLayoutRows.find(function (layoutRow) {
                                    var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                                        return m.StyleForLayoutId == layoutRow.LayoutBaseId;
                                    });
                                    if (styleMolecule.Name === "[Internal] " + v.Name + " View Style") {
                                        v.SpecialStyleViewStyleMoleculeId = styleMolecule.StyleMoleculeId;
                                        return true;
                                    }
                                    return false;
                                });
                                var californiaViewBodyStyleHolderRow = currentApp.state.specialStyleHolder.PlacedLayoutRows.find(function (layoutRow) {
                                    var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                                        return m.StyleForLayoutId == layoutRow.LayoutBaseId;
                                    });
                                    if (styleMolecule.Name === "[Internal] " + v.Name + " Body Style") {
                                        v.SpecialStyleBodyStyleMoleculeId = styleMolecule.StyleMoleculeId;
                                        return true;
                                    }
                                    return false;
                                });
                                var californiaViewHtmlStyleHolderRow = currentApp.state.specialStyleHolder.PlacedLayoutRows.find(function (layoutRow) {
                                    var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                                        return m.StyleForLayoutId == layoutRow.LayoutBaseId;
                                    });
                                    if (styleMolecule.Name === "[Internal] " + v.Name + " Html Style") {
                                        v.SpecialStyleHtmlStyleMoleculeId = styleMolecule.StyleMoleculeId;
                                        return true;
                                    }
                                    return false;
                                });
                                v.SpecialStyleViewStyleMoleculeIdString = v.SpecialStyleViewStyleMoleculeId.toString();
                                v.SpecialStyleViewStyleString = "s" + v.SpecialStyleViewStyleMoleculeIdString;
                                v.SpecialStyleBodyStyleMoleculeIdString = v.SpecialStyleBodyStyleMoleculeId.toString();
                                v.SpecialStyleBodyStyleString = "s" + v.SpecialStyleBodyStyleMoleculeIdString;
                                v.SpecialStyleHtmlStyleMoleculeIdString = v.SpecialStyleHtmlStyleMoleculeId.toString();
                                v.SpecialStyleHtmlStyleString = "s" + v.SpecialStyleHtmlStyleMoleculeIdString;
                            } else {
                                v.SpecialStyleViewStyleString = "";
                                v.SpecialStyleBodyStyleString = "";
                                v.SpecialStyleHtmlStyleString = "";
                            }
                        });
                        var instanceableAtomsView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (view) {
                            return view.IsInternal && view.Name === "[Internal] Instanceable Layout Atoms";
                        });
                        var instanceableRowsView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (view) {
                            return view.IsInternal && view.Name === "[Internal] Instanceable Layout Rows";
                        });
                        currentRouter.setActiveCaliforniaViewId(currentApp.pagePreviewVM.activeCaliforniaViewId != 0 ? currentApp.pagePreviewVM.activeCaliforniaViewId : 0, true, isInitial);
                        for (var i = 0; i < currentApp.propertyBars.length; i++) {
                            currentApp.propertyBars[i].viewModel.updateData(currentApp.clientData.CaliforniaProject.StyleQuantums, currentApp.clientData.CaliforniaProject.StyleAtoms, currentApp.clientData.CaliforniaProject.StyleMolecules, currentApp.clientData.CaliforniaProject.LayoutMolecules, currentApp.clientData.CaliforniaProject.CaliforniaViews, instanceableAtomsView, instanceableRowsView);
                        }
                        var firstRow_1 = instanceableRowsView.PlacedLayoutRows[0];
                        currentApp.state.newBoxStyleMoleculeId = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (s) {
                            return s.StyleForLayoutId == firstRow_1.AllBoxesBelowRow[0].LayoutBaseId;
                        }).StyleMoleculeId;
                    } else {
                        currentApp.state.specialStyleHolder = undefined;
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                    }
                    if (isInitial === true) {
                        var i = 0;
                        if (i < currentApp.propertyBarCount) {
                            currentApp.propertyBarVMs[i++].currentPropertyBarMode = PropertyBarVM_1.PropertyBarMode.CaliforniaView;
                            if (i < currentApp.propertyBarCount) {
                                currentApp.propertyBarVMs[i++].currentPropertyBarMode = PropertyBarVM_1.PropertyBarMode.AllCaliforniaViews;
                                if (i < currentApp.propertyBarCount) {
                                    currentApp.propertyBarVMs[i++].currentPropertyBarMode = PropertyBarVM_1.PropertyBarMode.StyleMolecule;
                                    if (i < currentApp.propertyBarCount) {
                                        currentApp.propertyBarVMs[i++].currentPropertyBarMode = PropertyBarVM_1.PropertyBarMode.AllStyleQuantums;
                                    }
                                }
                            }
                        }
                    }
                    currentRouter.setupUiForDevice();
                    isUpdateSuccess = true;
                }
            }
            if (isUpdateSuccess === false) {
                console.log("missing client data");
                location.reload();
            }
            currentApp.state.isDataLoaded = true;
            if (!preventRenderChainedCalls) {
                currentApp.projector.scheduleRender();
            }
        };
        this.restoreLayoutMoleculeAndStyleReferences = function () {
            var project = currentApp.clientData.CaliforniaProject;
            var allRows = [];
            var allBoxes = [];
            var allAtoms = [];
            project.LayoutMolecules.map(function (mol) {
                switch (mol.LayoutType) {
                    case CaliforniaGenerated_1.LayoutType.Row:
                        allRows.push(mol);
                        break;
                    case CaliforniaGenerated_1.LayoutType.Box:
                        allBoxes.push(mol);
                        break;
                    case CaliforniaGenerated_1.LayoutType.Atom:
                        allAtoms.push(mol);
                        break;
                    default:
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                        break;
                }
            });
            var allContentAtoms = project.ContentAtoms;
            var allInteractions = project.LayoutStyleInteractions;
            project.CaliforniaViews.map(function (view) {
                view.PlacedLayoutRows = allRows.filter(function (row) {
                    return row.PlacedOnViewId == view.CaliforniaViewId;
                }).sort(function (rowA, rowB) {
                    if (rowA.LayoutSortOrderKey < rowB.LayoutSortOrderKey) {
                        return -1;
                    } else if (rowA.LayoutSortOrderKey == rowB.LayoutSortOrderKey) {
                        return 0;
                    } else {
                        return 1;
                    }
                });
            });
            var deepestLevelCurrentView = 0;
            project.CaliforniaViews.map(function (view) {
                deepestLevelCurrentView = 0;
                var _loop_1 = function _loop_1(iRow) {
                    currentRouter.deepestLevelCurrentRow = 0;
                    var row = view.PlacedLayoutRows[iRow];
                    row.AllBoxesBelowRow = allBoxes.filter(function (box) {
                        return box.BoxOwnerRowId == row.LayoutBaseId && box.PlacedBoxInBoxId == undefined;
                    });
                    row.AllBoxesBelowRow.map(function (box) {
                        currentRouter.restoreLayoutBoxReferencesRecursive(0, box, row, allBoxes, allAtoms, allContentAtoms, allInteractions);
                        box.BoxOwnerRow = row;
                    });
                    row.DeepestLevel = currentRouter.deepestLevelCurrentRow;
                    if (currentRouter.deepestLevelCurrentRow > deepestLevelCurrentView) {
                        deepestLevelCurrentView = currentRouter.deepestLevelCurrentRow;
                    }
                };
                for (var iRow = 0; iRow < view.PlacedLayoutRows.length; iRow++) {
                    _loop_1(iRow);
                }
                view.DeepestLevel = deepestLevelCurrentView;
            });
        };
        this.restoreLayoutBoxReferencesRecursive = function (boxLevel, box, boxOwnerRow, allBoxes, allAtoms, allContentAtoms, allInteractions) {
            var _a;
            box.Level = boxLevel;
            box.PlacedInBoxBoxes = allBoxes.filter(function (subBox) {
                return subBox.PlacedBoxInBoxId !== undefined && subBox.PlacedBoxInBoxId == box.LayoutBaseId;
            });
            box.PlacedInBoxBoxes.map(function (subBox) {
                currentRouter.restoreLayoutBoxReferencesRecursive(boxLevel + 1, subBox, boxOwnerRow, allBoxes, allAtoms, allContentAtoms, allInteractions);
                subBox.BoxOwnerRow = boxOwnerRow;
                subBox.PlacedBoxInBox = box;
            });
            (_a = boxOwnerRow.AllBoxesBelowRow).push.apply(_a, box.PlacedInBoxBoxes);
            box.PlacedInBoxAtoms = allAtoms.filter(function (subAtom) {
                return subAtom.PlacedAtomInBoxId !== undefined && subAtom.PlacedAtomInBoxId == box.LayoutBaseId;
            });
            box.PlacedInBoxAtoms.map(function (subAtom) {
                subAtom.HostedContentAtom = allContentAtoms.find(function (contentAtom) {
                    return contentAtom.InstancedOnLayoutId == subAtom.LayoutBaseId;
                });
                subAtom.PlacedAtomInBox = box;
                subAtom.LayoutStyleInteractions = allInteractions.filter(function (map) {
                    return map.LayoutAtomId == subAtom.LayoutBaseId;
                });
                subAtom.Level = boxLevel + 1;
            });
            if (box.PlacedInBoxAtoms.length > 0) {
                if (boxLevel + 1 > currentRouter.deepestLevelCurrentRow) {
                    currentRouter.deepestLevelCurrentRow = boxLevel + 1;
                }
            } else if (boxLevel > currentRouter.deepestLevelCurrentRow) {
                currentRouter.deepestLevelCurrentRow = boxLevel;
            }
        };
        this.setupUiForDevice = function () {
            var californiaAppHeight = $(window).height();
            if (californiaAppHeight === undefined) {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                return;
            }
            document.body.style.height = californiaAppHeight + "px";
            if (currentApp.state.isHideUserInterface === true || currentApp.state.editViewMode === ClientState_1.EditViewMode.PagePreviewOnly) {
                currentApp.state.availableSpacePagePreviewPx = currentApp.pagePreviewHolder !== undefined ? window.innerWidth + 2 * currentApp.state.targetPagePreviewHolderMarginPx : 0;
            } else {
                currentApp.state.availableSpacePagePreviewPx = currentApp.pagePreviewHolder !== undefined ? currentApp.pagePreviewHolder.clientWidth + 2 * currentApp.state.targetPagePreviewHolderMarginPx : 0;
            }
            if (currentApp.clientData.CaliforniaProject !== undefined && currentApp.clientData.CaliforniaProject.ResponsiveDevices !== undefined && currentApp.clientData.CaliforniaProject.ResponsiveDevices.length > 0) {
                if (currentApp.pagePreviewVM.editedLayoutAtomId == 0) {
                    currentApp.pagePreview.updatePagePreviewDimensions();
                }
            }
        };
        this.validateResponse = function (response) {
            if (response == null) {
                console.log("invalid client data");
                return false;
            } else if (response.StatusText !== null && response.StatusText !== "") {
                console.log(response.StatusText);
                return false;
            }
            if (currentApp.clientData !== undefined && response.CurrentRevision < currentApp.clientData.CurrentRevision) {
                console.log("Ignoring client data: revision is lower");
                return false;
            }
            return true;
        };
        currentRouter = this;
        currentApp = californiaAppArg;
    }
    ;
    CaliforniaRouter.prototype.clearCaliforniaPropertyBars = function (isClearWhenNonEqual, clearWhenEqualsCaliforniaViewId) {
        for (var i = 0; i < currentApp.propertyBars.length; i++) {
            currentApp.propertyBars[i].viewModel.clearSelectedCaliforniaView(isClearWhenNonEqual, clearWhenEqualsCaliforniaViewId);
        }
    };
    ;
    CaliforniaRouter.prototype.setActiveCaliforniaViewId = function (californiaViewId, isDefaultToHome, isSetAllPropertyBars) {
        var userPages = currentApp.clientData.CaliforniaProject.CaliforniaViews.filter(function (view) {
            return !view.IsInternal;
        });
        var activeView = undefined;
        var activePageIndex = -1;
        if (californiaViewId != 0) {
            activePageIndex = userPages.findIndex(function (v) {
                return v.CaliforniaViewId == californiaViewId;
            });
        }
        if (activePageIndex == -1 && isDefaultToHome === true) {
            activePageIndex = userPages.findIndex(function (v) {
                return v.Name === "Home";
            });
        }
        if (activePageIndex > -1) {
            activeView = userPages[activePageIndex];
            currentRouter.setActiveCaliforniaView(activeView);
            if (isSetAllPropertyBars === true) {
                for (var i = 0; i < currentApp.propertyBars.length; i++) {
                    currentApp.propertyBars[i].viewModel.setSelectedCaliforniaView(activeView, true);
                }
            } else {
                currentApp.propertyBars[0].viewModel.setSelectedCaliforniaView(activeView, true);
                var _loop_2 = function _loop_2(i) {
                    var propertyBarViewId = currentApp.propertyBars[i].viewModel.selectedCaliforniaViewId;
                    if (propertyBarViewId != 0) {
                        var propertyBarView = userPages.find(function (v) {
                            return v.CaliforniaViewId === propertyBarViewId;
                        });
                        currentApp.propertyBars[i].viewModel.setSelectedCaliforniaView(propertyBarView, true);
                    }
                };
                for (var i = 1; i < currentApp.propertyBars.length; i++) {
                    _loop_2(i);
                }
            }
        } else {
            console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
        }
    };
    ;
    CaliforniaRouter.prototype.setActiveCaliforniaView = function (californiaView) {
        currentApp.pagePreview.viewModel.activeCaliforniaViewId = californiaView.CaliforniaViewId;
        currentApp.pagePreviewVM.californiaViewProjector.map([californiaView]);
        currentApp.pagePreviewVM.fixedLayoutRowsProjector.map(californiaView.PlacedLayoutRows);
    };
    ;
    return CaliforniaRouter;
}();
exports.CaliforniaRouter = CaliforniaRouter;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var CaliforniaClientPartialData = function () {
    function CaliforniaClientPartialData() {}
    return CaliforniaClientPartialData;
}();
exports.CaliforniaClientPartialData = CaliforniaClientPartialData;

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYmVkMjY3ZDNiMTc3YTMxODRhZjQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFxdWV0dGUvZGlzdC9tYXF1ZXR0ZS5qcyIsIndlYnBhY2s6Ly8vLi9Nb2RlbHMvQ2FsaWZvcm5pYUdlbmVyYXRlZC50cyIsIndlYnBhY2s6Ly8vLi9Nb2RlbHMvQ2FsaWZvcm5pYUFwcC50c3giLCJ3ZWJwYWNrOi8vLy4vTW9kZWxzL0NsaWVudFN0YXRlLnRzeCIsIndlYnBhY2s6Ly8vLi9WaWV3TW9kZWxzL1Byb3BlcnR5QmFyVk0udHN4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wb3BwZXIuanMvZGlzdC9lc20vcG9wcGVyLmpzIiwid2VicGFjazovLy8uL1R5cGV3cml0ZXIvQ29udGVudEF0b21UeXBlLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnktdmFsaWRhdGlvbi9kaXN0L2pxdWVyeS52YWxpZGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXZhbGlkYXRpb24tdW5vYnRydXNpdmUvanF1ZXJ5LnZhbGlkYXRlLnVub2J0cnVzaXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90ZXRoZXIvZGlzdC9qcy90ZXRoZXIuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9zYXNzL21haW4uc2NzcyIsIndlYnBhY2s6Ly8vLi9zaXRlLnRzeCIsIndlYnBhY2s6Ly8vLi9UeXBld3JpdGVyL0NhbGlmb3JuaWFDb250cm9sbGVyLnRzIiwid2VicGFjazovLy8uL1R5cGV3cml0ZXIvdHNnZW5IZWxwZXJzLnRzIiwid2VicGFjazovLy8uL1R5cGV3cml0ZXIvQ2FsaWZvcm5pYUV2ZW50LnRzIiwid2VicGFjazovLy8uL1R5cGV3cml0ZXIvQ2FsaWZvcm5pYVByb2plY3QudHMiLCJ3ZWJwYWNrOi8vLy4vVHlwZXdyaXRlci9DYWxpZm9ybmlhVXNlckRlZmF1bHRzLnRzIiwid2VicGFjazovLy8uL1R5cGV3cml0ZXIvQ2FsaWZvcm5pYUNsaWVudFZpZXdNb2RlbC50cyIsIndlYnBhY2s6Ly8vLi9UeXBld3JpdGVyL1N0eWxlTW9sZWN1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vVHlwZXdyaXRlci9TdHlsZVF1YW50dW0udHMiLCJ3ZWJwYWNrOi8vLy4vVHlwZXdyaXRlci9TdHlsZUF0b20udHMiLCJ3ZWJwYWNrOi8vLy4vVHlwZXdyaXRlci9TdHlsZUF0b21UeXBlLnRzIiwid2VicGFjazovLy8uL1R5cGV3cml0ZXIvU3R5bGVWYWx1ZS50cyIsIndlYnBhY2s6Ly8vLi9UeXBld3JpdGVyL1Jlc3BvbnNpdmVEZXZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vVHlwZXdyaXRlci9DYWxpZm9ybmlhVmlldy50cyIsIndlYnBhY2s6Ly8vLi9UeXBld3JpdGVyL0xheW91dFJvdy50cyIsIndlYnBhY2s6Ly8vLi9UeXBld3JpdGVyL0xheW91dEJveC50cyIsIndlYnBhY2s6Ly8vLi9UeXBld3JpdGVyL0xheW91dEF0b20udHMiLCJ3ZWJwYWNrOi8vLy4vVHlwZXdyaXRlci9TdHlsZU1vbGVjdWxlQXRvbU1hcHBpbmcudHMiLCJ3ZWJwYWNrOi8vLy4vVHlwZXdyaXRlci9Db250ZW50QXRvbS50cyIsIndlYnBhY2s6Ly8vLi9UeXBld3JpdGVyL0xheW91dEJhc2UudHMiLCJ3ZWJwYWNrOi8vLy4vVHlwZXdyaXRlci9MYXlvdXRUeXBlLnRzIiwid2VicGFjazovLy8uL1R5cGV3cml0ZXIvU3BlY2lhbExheW91dEJveFR5cGUudHMiLCJ3ZWJwYWNrOi8vLy4vVHlwZXdyaXRlci9MYXlvdXRTdHlsZUludGVyYWN0aW9uLnRzIiwid2VicGFjazovLy8uL01vZGVscy9QYWdlUHJldmlldy50c3giLCJ3ZWJwYWNrOi8vLy4vVmlld01vZGVscy9QYWdlUHJldmlld1ZNLnRzeCIsIndlYnBhY2s6Ly8vLi9Nb2RlbHMvUHJvcGVydHlCYXIudHN4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92ZWxvY2l0eS1hbmltYXRlL3ZlbG9jaXR5LmpzIiwid2VicGFjazovLy8uL01vZGVscy9DYWxpZm9ybmlhUm91dGVyLnRzeCIsIndlYnBhY2s6Ly8vLi9UeXBld3JpdGVyL0NhbGlmb3JuaWFDbGllbnRQYXJ0aWFsRGF0YS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsU0FBUztBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsWUFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsZ0JBQWdCLElBQUk7O0FBRXBCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVEsNkJBQTZCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlOztBQUVmLFNBQVM7O0FBRVQ7QUFDQSxRQUFRLGlDQUFpQztBQUN6QyxRQUFRLG9CQUFvQjtBQUM1QixRQUFRLHNDQUFzQztBQUM5QyxRQUFRO0FBQ1IsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWEsRUFBRTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxVQUFVO0FBQzNFLHNDQUFzQywyQkFBMkI7QUFDakU7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLHVFQUF1RTtBQUNuRjtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0Esb0ZBQW9GOztBQUVwRjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlEQUFpRDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxVQUFVLHdDQUF3QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBLENBQUM7Ozs7QUFJRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxRQUFRLEdBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQiwwQkFBMEIsd0JBQXdCOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0Msc0NBQXNDO0FBQzlFLG9DQUFvQyx1Q0FBdUM7QUFDM0Usb0NBQW9DLHNDQUFzQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixhQUFhO0FBQ3BDLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGdCQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdCQUFnQjtBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxjQUFjOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQXVEO0FBQzlFOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLCtCQUErQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLHFDQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLFNBQVMsOEJBQThCO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFdBQVc7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxjQUFjLFdBQVc7QUFDeEUsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQSxzQkFBc0IsY0FBYyxzQkFBc0IsZ0JBQWdCO0FBQzFFLGdCQUFnQixXQUFXLFlBQVk7QUFDdkMsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBK0Q7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUEsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdCQUFnQjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osaURBQWlELDBCQUEwQjtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFD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QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUSxtQkFBbUI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQUs7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFDQUFxQzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYixLQUFLO0FBQ0w7O0FBRUEsV0FBVztBQUNYLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQixnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSxzQkFBc0I7QUFDdEIsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsc0RBQXNEO0FBQ3BFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0EsY0FBYyxtQ0FBbUM7QUFDakQsZUFBZSw2REFBNkQ7QUFDNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7QUFDRixDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFBQTtBQUNGOzs7OztBQUtBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQSxDQUFDOzs7Ozs7O0FDM25VRDtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Es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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwrREFBK0QsMkJBQTJCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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NENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7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Q0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0EsSUFBSTtBQUNKLCtEQUErRCxHQUFHO0FBQ2xFOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQyxVOzs7Ozs7O0FDL1pEOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLGlDQUFpQywyQ0FBMkMs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RUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Es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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBLCtCQUErQjtBQUMvQiwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsWUFBWTtBQUNaO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsWUFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdGQUFnRjs7QUFFaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFNBQVMscUJBQXFCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUNBQXVDO0FBQ3RELGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLG9FQUFvRTtBQUM5RTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsZUFBZSxHQUFHLGVBQWU7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLEVBQUUsRUFBRSxJQUFJO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUU7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLE9BQU87QUFDUCw0RkFBNEY7QUFDNUY7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RSw4REFBOEQ7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSDs7QUFFaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ04sd0ZBQXdGO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdGQUF3Rjs7QUFFeEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBDQUEwQyxzQkFBc0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBLE1BQU07O0FBRU47QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ04sd0JBQXdCOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTs7QUFFM0U7QUFDQTtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLCtHQUErRztBQUMvRztBQUNBLHNKQUFzSjs7QUFFdEo7QUFDQTtBQUNBLDZGQUE2RjtBQUM3Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0c7O0FBRXhHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw4REFBOEQ7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLHlCQUF5QiwyQ0FBMkM7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiwyQ0FBMkM7QUFDdEU7QUFDQSx5QkFBeUIsZ0VBQWdFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLHVLQUF1SztBQUN2SywwS0FBMEs7QUFDMUssNklBQTZJOztBQUU3STtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHOztBQUVBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0UsOEVBQThFO0FBQzlFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFFQUFxRTtBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdEQUFnRCxVQUFVO0FBQzFELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsZ0JBQWdCO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtB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S0s7QUFFRCwyQkFBVyxZQUFYLENBQXdCLENBQXhCLEVBQTJCLFNBQTNCLENBQXFDLHlCQUFyQyxDQUErRCxVQUEvRCxFQUEyRSxJQUEzRTsrQ0FDUyxDLEVBQUM7QUFDTix3QkFBSSxvQkFBNEIsV0FBVyxZQUFYLENBQXdCLENBQXhCLEVBQTJCLFNBQTNCLENBQXFDLHdCQUFyRTtBQUNBLHdCQUFJLHFCQUFxQixDQUF6QixFQUE0QjtBQUN4Qiw0QkFBSSxrQkFBa0MsVUFBVSxJQUFWLENBQWUsYUFBQztBQUFJLHFDQUFFLGdCQUFGO0FBQXdDLHlCQUE1RCxDQUF0QztBQUNBLG1DQUFXLFlBQVgsQ0FBd0IsQ0FBeEIsRUFBMkIsU0FBM0IsQ0FBcUMseUJBQXJDLENBQStELGVBQS9ELEVBQWdGLElBQWhGO0FBQ0g7QUFDSixpQjtBQU5ELHFCQUFLLElBQUksSUFBWSxDQUFyQixFQUF3QixJQUFJLFdBQVcsWUFBWCxDQUF3QixNQUFwRCxFQUE0RCxHQUE1RCxFQUErRDs0QkFBdEQsQztBQU1SO0FBQ0o7QUFDSixTQW5CRCxNQW9CSztBQUNELG9CQUFRLEdBQVIsQ0FBWSxpQ0FBWjtBQUNIO0FBQ0osS0FqQ007QUFpQ047QUFFTSx5REFBUCxVQUErQixjQUEvQixFQUE2RDtBQUN6RCxtQkFBVyxXQUFYLENBQXVCLFNBQXZCLENBQWlDLHNCQUFqQyxHQUEwRCxlQUFlLGdCQUF6RTtBQUNBLG1CQUFXLGFBQVgsQ0FBeUIsdUJBQXpCLENBQWlELEdBQWpELENBQXFELENBQUMsY0FBRCxDQUFyRDtBQUNBLG1CQUFXLGFBQVgsQ0FBeUIsd0JBQXpCLENBQWtELEdBQWxELENBQXNELGVBQWUsZ0JBQXJFO0FBQ0gsS0FKTTtBQUlOO0FBcUlMO0FBQUMsQ0FyWUQ7QUFBYSw0Qzs7Ozs7Ozs7Ozs7QUNiYjtBQUFBLDRDQUVDO0FBQUQ7QUFBQyxDQUZEO0FBQWEsa0UiLCJmaWxlIjoiY2FsaWZvcm5pYWNsaWVudC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9hc3NldHMvXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gOCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgYmVkMjY3ZDNiMTc3YTMxODRhZjQiLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuMy4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxOC0wMS0yMFQxNzoyNFpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xuXG4gICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcbiAgICAgIC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCI7XG4gIH07XG5cblxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cblxuXG5cdHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xuXHRcdHR5cGU6IHRydWUsXG5cdFx0c3JjOiB0cnVlLFxuXHRcdG5vTW9kdWxlOiB0cnVlXG5cdH07XG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgZG9jLCBub2RlICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBpLFxuXHRcdFx0c2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRpZiAoIG5vZGUgKSB7XG5cdFx0XHRmb3IgKCBpIGluIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgKSB7XG5cdFx0XHRcdGlmICggbm9kZVsgaSBdICkge1xuXHRcdFx0XHRcdHNjcmlwdFsgaSBdID0gbm9kZVsgaSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xuXHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHR0eXBlb2Ygb2JqO1xufVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy4zLjFcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgQXJyYXkuaXNBcnJheSggc3JjICkgPyBzcmMgOiBbXTtcblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgPyBzcmMgOiB7fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBwcm90bywgQ3RvcjtcblxuXHRcdC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuXHRcdC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuXHRcdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwcm90byA9IGdldFByb3RvKCBvYmogKTtcblxuXHRcdC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cblx0XHRpZiAoICFwcm90byApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG5cdFx0Q3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvNjEyNVxuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlICkge1xuXHRcdERPTUV2YWwoIGNvZGUgKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHR0cmltOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcdFwiXCIgOlxuXHRcdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBjb25jYXQuYXBwbHkoIFtdLCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcbmZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbn0gKTtcblxuZnVuY3Rpb24gaXNBcnJheUxpa2UoIG9iaiApIHtcblxuXHQvLyBTdXBwb3J0OiByZWFsIGlPUyA4LjIgb25seSAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IHRvVHlwZSggb2JqICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBvYmogKSB8fCBpc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHxcblx0XHR0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiICYmIGxlbmd0aCA+IDAgJiYgKCBsZW5ndGggLSAxICkgaW4gb2JqO1xufVxudmFyIFNpenpsZSA9XG4vKiFcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYyLjMuM1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDgtMDhcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKHt9KS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hfbmF0aXZlID0gYXJyLnB1c2gsXG5cdHB1c2ggPSBhcnIucHVzaCxcblx0c2xpY2UgPSBhcnIuc2xpY2UsXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFwwLVxcXFx4YTBdKStcIixcblxuXHQvLyBBdHRyaWJ1dGUgc2VsZWN0b3JzOiBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2F0dHJpYnV0ZS1zZWxlY3RvcnNcblx0YXR0cmlidXRlcyA9IFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdIG9yIHN0cmluZ3MgW2NhcHR1cmUgMyBvciBjYXB0dXJlIDRdXCJcblx0XHRcIiooPzonKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCJ8KFwiICsgaWRlbnRpZmllciArIFwiKSl8KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXFxcXF1cIixcblxuXHRwc2V1ZG9zID0gXCI6KFwiICsgaWRlbnRpZmllciArIFwiKSg/OlxcXFwoKFwiICtcblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblx0XHQvLyAzLiBhbnl0aGluZyBlbHNlIChjYXB0dXJlIDIpXG5cdFx0XCIuKlwiICtcblx0XHRcIilcXFxcKXwpXCIsXG5cblx0Ly8gTGVhZGluZyBhbmQgbm9uLWVzY2FwZWQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgY2FwdHVyaW5nIHNvbWUgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVycyBwcmVjZWRpbmcgdGhlIGxhdHRlclxuXHRyd2hpdGVzcGFjZSA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcIitcIiwgXCJnXCIgKSxcblx0cnRyaW0gPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIit8KCg/Ol58W15cXFxcXFxcXF0pKD86XFxcXFxcXFwuKSopXCIgKyB3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblxuXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0ZGlzYWJsZWRBbmNlc3RvciA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiAoXCJmb3JtXCIgaW4gZWxlbSB8fCBcImxhYmVsXCIgaW4gZWxlbSk7XG5cdFx0fSxcblx0XHR7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfVxuXHQpO1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXG5cdFx0cHJlZmVycmVkRG9jLmNoaWxkTm9kZXNcblx0KTtcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaF9uYXRpdmUuYXBwbHkoIHRhcmdldCwgc2xpY2UuY2FsbChlbHMpICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKHRhcmdldFtqKytdID0gZWxzW2krK10pICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblxuXHRcdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdH1cblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IWNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdFx0XHQvLyBxU0EgbG9va3Mgb3V0c2lkZSBFbGVtZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgd29ya2Fyb3VuZCB0ZWNobmlxdWVcblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0aWYgKCAobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApKSApIHtcblx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIChuaWQgPSBleHBhbmRvKSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzW2ldID0gXCIjXCIgKyBuaWQgKyBcIiBcIiArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRkaXNhYmxlZEFuY2VzdG9yKCBlbGVtICkgPT09IGRpc2FibGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cblx0XHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG5cdFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG5cdFx0Ly8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG5cdFx0fSBlbHNlIGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0Ly8gZG9jdW1lbnRFbGVtZW50IGlzIHZlcmlmaWVkIGZvciBjYXNlcyB3aGVyZSBpdCBkb2Vzbid0IHlldCBleGlzdFxuXHQvLyAoc3VjaCBhcyBsb2FkaW5nIGlmcmFtZXMgaW4gSUUgLSAjNDgzMylcblx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XG5cdHJldHVybiBkb2N1bWVudEVsZW1lbnQgPyBkb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgIT09IFwiSFRNTFwiIDogZmFsc2U7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsIHN1YldpbmRvdyxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcblx0aWYgKCBkb2MgPT09IGRvY3VtZW50IHx8IGRvYy5ub2RlVHlwZSAhPT0gOSB8fCAhZG9jLmRvY3VtZW50RWxlbWVudCApIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBVcGRhdGUgZ2xvYmFsIHZhcmlhYmxlc1xuXHRkb2N1bWVudCA9IGRvYztcblx0ZG9jRWxlbSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblx0ZG9jdW1lbnRJc0hUTUwgPSAhaXNYTUwoIGRvY3VtZW50ICk7XG5cblx0Ly8gU3VwcG9ydDogSUUgOS0xMSwgRWRnZVxuXHQvLyBBY2Nlc3NpbmcgaWZyYW1lIGRvY3VtZW50cyBhZnRlciB1bmxvYWQgdGhyb3dzIFwicGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvcnMgKGpRdWVyeSAjMTM5MzYpXG5cdGlmICggcHJlZmVycmVkRG9jICE9PSBkb2N1bWVudCAmJlxuXHRcdChzdWJXaW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldykgJiYgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTEsIEVkZ2Vcblx0XHRpZiAoIHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0c3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuXHRcdH0gZWxzZSBpZiAoIHN1YldpbmRvdy5hdHRhY2hFdmVudCApIHtcblx0XHRcdHN1YldpbmRvdy5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdFx0fVxuXHR9XG5cblx0LyogQXR0cmlidXRlc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gU3VwcG9ydDogSUU8OFxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXNcblx0Ly8gKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXG5cdHN1cHBvcnQuYXR0cmlidXRlcyA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFlbC5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XG5cdH0pO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCJcIikgKTtcblx0XHRyZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmlsdGVyIGFuZCBmaW5kXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblx0XHRcdFx0cmV0dXJuIGVsZW0gPyBbIGVsZW0gXSA6IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDYgLSA3IG9ubHlcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgbm9kZSwgaSwgZWxlbXMsXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0Ly8gVmVyaWZ5IHRoZSBpZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxuXHRcdFx0XHRcdGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbXNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0XHRub2RlID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM3OFxuXHRyYnVnZ3lRU0EgPSBbXTtcblxuXHRpZiAoIChzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApKSApIHtcblx0XHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0XHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvaGg0NjUzODguYXNweCNhdHRyaWJ1dGVfc2VjdGlvblxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbc2VsZWN0ZWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIn49XCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2libGluZy1jb21iaW5hdG9yIHNlbGVjdG9yYCBmYWlsc1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIipbKl4kfCF+XT89XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRkYgMy41IC0gOmVuYWJsZWQvOmRpc2FibGVkIGFuZCBoaWRkZW4gZWxlbWVudHMgKGhpZGRlbiBlbGVtZW50cyBhcmUgc3RpbGwgZW5hYmxlZClcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZW5hYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdFx0Ly8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3BlcmEgMTAtMTEgZG9lcyBub3QgdGhyb3cgb24gcG9zdC1jb21tYSBpbnZhbGlkIHBzZXVkb3Ncblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqLDp4XCIpO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xuXHRcdH0pO1xuXHR9XG5cblx0aWYgKCAoc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgPSBybmF0aXZlLnRlc3QoIChtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IpICkpICkge1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGVsLCBcIipcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGVsLCBcIltzIT0nJ106eFwiICk7XG5cdFx0XHRyYnVnZ3lNYXRjaGVzLnB1c2goIFwiIT1cIiwgcHNldWRvcyApO1xuXHRcdH0pO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbihcInxcIikgKTtcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkpO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0aWYgKCBiICkge1xuXHRcdFx0XHR3aGlsZSAoIChiID0gYi5wYXJlbnROb2RlKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PT0gKCBiLm93bmVyRG9jdW1lbnQgfHwgYiApID9cblx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGIgKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSB3ZSBrbm93IHRoZXkgYXJlIGRpc2Nvbm5lY3RlZFxuXHRcdFx0MTtcblxuXHRcdC8vIERpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdGlmICggY29tcGFyZSAmIDEgfHxcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHRpZiAoIGEgPT09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYSkgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHRcdGlmICggYiA9PT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBiKSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1haW50YWluIG9yaWdpbmFsIG9yZGVyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb21wYXJlICYgNCA/IC0xIDogMTtcblx0fSA6XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXHRcdFx0cmV0dXJuIGEgPT09IGRvY3VtZW50ID8gLTEgOlxuXHRcdFx0XHRiID09PSBkb2N1bWVudCA/IDEgOlxuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cdFx0Y3VyID0gYjtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxuXHRcdHdoaWxlICggYXBbaV0gPT09IGJwW2ldICkge1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpID9cblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxuXHRcdFx0c2libGluZ0NoZWNrKCBhcFtpXSwgYnBbaV0gKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuXHRcdFx0YXBbaV0gPT09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwW2ldID09PSBwcmVmZXJyZWREb2MgPyAxIDpcblx0XHRcdDA7XG5cdH07XG5cblx0cmV0dXJuIGRvY3VtZW50O1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxuXHRleHByID0gZXhwci5yZXBsYWNlKCByYXR0cmlidXRlUXVvdGVzLCBcIj0nJDEnXVwiICk7XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFjb21waWxlckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lc2NhcGUgPSBmdW5jdGlvbiggc2VsICkge1xuXHRyZXR1cm4gKHNlbCArIFwiXCIpLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQocGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkpICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gbm9kZVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHBhcmVudDtcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFswXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXG5cdFx0XCJkaXNhYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0pLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9KTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRza2lwID0gY29tYmluYXRvci5uZXh0LFxuXHRcdGtleSA9IHNraXAgfHwgZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fCAob3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIChvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBrZXkgXSkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIGtleSBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbMF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG5cdFx0XHRcdFx0XHQodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3Rvcihcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9KVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0fTtcblxuXHRyZXR1cm4gYnlTZXQgP1xuXHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdHN1cGVyTWF0Y2hlcjtcbn1cblxuY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFtpXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoIChzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpICkgJiAxO1xufSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiIDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHZhbDtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0pO1xufVxuXG5yZXR1cm4gU2l6emxlO1xuXG59KSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuLy8gRGVwcmVjYXRlZFxualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcblxuXG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxuXG5cbmZ1bmN0aW9uIG5vZGVOYW1lKCBlbGVtLCBuYW1lICkge1xuXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG59O1xudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEZpbHRlcmVkIGRpcmVjdGx5IGZvciBib3RoIHNpbXBsZSBhbmQgY29tcGxleCBzZWxlY3RvcnNcblx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0aWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG4gICAgICAgIGlmICggbm9kZU5hbWUoIGVsZW0sIFwiaWZyYW1lXCIgKSApIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5LCBpT1MgNyBvbmx5LCBBbmRyb2lkIEJyb3dzZXIgPD00LjMgb25seVxuICAgICAgICAvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcbiAgICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCBpdC5cbiAgICAgICAgaWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0ZW1wbGF0ZVwiICkgKSB7XG4gICAgICAgICAgICBlbGVtID0gZWxlbS5jb250ZW50IHx8IGVsZW07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdGh0bWx3aGl0ZSA9ICggL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gbG9ja2VkIHx8IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0b1R5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5mdW5jdGlvbiBJZGVudGl0eSggdiApIHtcblx0cmV0dXJuIHY7XG59XG5mdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcblx0dGhyb3cgZXg7XG59XG5cbmZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QsIG5vVmFsdWUgKSB7XG5cdHZhciBtZXRob2Q7XG5cblx0dHJ5IHtcblxuXHRcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3Jcblx0XHRpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUgKS5kb25lKCByZXNvbHZlICkuZmFpbCggcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciB0aGVuYWJsZXNcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb250cm9sIGByZXNvbHZlYCBhcmd1bWVudHMgYnkgbGV0dGluZyBBcnJheSNzbGljZSBjYXN0IGJvb2xlYW4gYG5vVmFsdWVgIHRvIGludGVnZXI6XG5cdFx0XHQvLyAqIGZhbHNlOiBbIHZhbHVlIF0uc2xpY2UoIDAgKSA9PiByZXNvbHZlKCB2YWx1ZSApXG5cdFx0XHQvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxuXHRcdFx0cmVzb2x2ZS5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0uc2xpY2UoIG5vVmFsdWUgKSApO1xuXHRcdH1cblxuXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcblx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuXHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuXHR9IGNhdGNoICggdmFsdWUgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdHJlamVjdC5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0gKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcblx0XHRcdFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMSwgXCJyZWplY3RlZFwiIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjYXRjaFwiOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBpc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMyBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9jayxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWRcblx0XHRcdG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBtYXN0ZXIucmVqZWN0LFxuXHRcdFx0XHQhcmVtYWluaW5nICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBtYXN0ZXIudGhlbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgbWFzdGVyLnJlamVjdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXN0ZXIucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdHdpbmRvdy5jb25zb2xlLndhcm4oIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjaywgc3RhY2sgKTtcblx0fVxufTtcblxuXG5cblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cblxuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggdG9UeXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggY2hhaW5hYmxlICkge1xuXHRcdHJldHVybiBlbGVtcztcblx0fVxuXG5cdC8vIEdldHNcblx0aWYgKCBidWxrICkge1xuXHRcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xuXHR9XG5cblx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcblxuXG4vLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcbnZhciBybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2c7XG5cbi8vIFVzZWQgYnkgY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuZnVuY3Rpb24gZmNhbWVsQ2FzZSggYWxsLCBsZXR0ZXIgKSB7XG5cdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcbn1cblxuLy8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuLy8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuZnVuY3Rpb24gY2FtZWxDYXNlKCBzdHJpbmcgKSB7XG5cdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xufVxudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggZGF0YSApIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cblx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGNhbWVsQ2FzZSgga2V5ICkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSxcblx0XHRcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGtleSApICkge1xuXG5cdFx0XHRcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxuXHRcdFx0XHRrZXkgPSBrZXkubWFwKCBjYW1lbENhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSA9IGNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRrZXkgPSBrZXkgaW4gY2FjaGUgP1xuXHRcdFx0XHRcdFsga2V5IF0gOlxuXHRcdFx0XHRcdCgga2V5Lm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10gKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IGtleS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGdldERhdGEoIGRhdGEgKSB7XG5cdGlmICggZGF0YSA9PT0gXCJ0cnVlXCIgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwiZmFsc2VcIiApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwibnVsbFwiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0aWYgKCBkYXRhID09PSArZGF0YSArIFwiXCIgKSB7XG5cdFx0cmV0dXJuICtkYXRhO1xuXHR9XG5cblx0aWYgKCByYnJhY2UudGVzdCggZGF0YSApICkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICk7XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBnZXREYXRhKCBkYXRhICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0gY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBBcnJheS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblxuXHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG5cdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICYmXG5cblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiO1xuXHR9O1xuXG52YXIgc3dhcCA9IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBjYWxsYmFjaywgYXJncyApIHtcblx0dmFyIHJldCwgbmFtZSxcblx0XHRvbGQgPSB7fTtcblxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdG9sZFsgbmFtZSBdID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcblx0fVxuXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsIHNjYWxlLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0fSA6XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0XHQvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXG5cdFx0aW5pdGlhbCA9IGluaXRpYWwgLyAyO1xuXG5cdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuXHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cblx0XHR3aGlsZSAoIG1heEl0ZXJhdGlvbnMtLSApIHtcblxuXHRcdFx0Ly8gRXZhbHVhdGUgYW5kIHVwZGF0ZSBvdXIgYmVzdCBndWVzcyAoZG91YmxpbmcgZ3Vlc3NlcyB0aGF0IHplcm8gb3V0KS5cblx0XHRcdC8vIEZpbmlzaCBpZiB0aGUgc2NhbGUgZXF1YWxzIG9yIGNyb3NzZXMgMSAobWFraW5nIHRoZSBvbGQqbmV3IHByb2R1Y3Qgbm9uLXBvc2l0aXZlKS5cblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblx0XHRcdGlmICggKCAxIC0gc2NhbGUgKSAqICggMSAtICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgfHwgMC41ICkgKSA8PSAwICkge1xuXHRcdFx0XHRtYXhJdGVyYXRpb25zID0gMDtcblx0XHRcdH1cblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cblx0XHR9XG5cblx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAqIDI7XG5cdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXHR9XG5cblx0aWYgKCB2YWx1ZVBhcnRzICkge1xuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG5cdFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXG5cdFx0YWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xuXHRcdFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcblx0XHRcdCt2YWx1ZVBhcnRzWyAyIF07XG5cdFx0aWYgKCB0d2VlbiApIHtcblx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuXHRcdFx0dHdlZW4uZW5kID0gYWRqdXN0ZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhZGp1c3RlZDtcbn1cblxuXG52YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKSB7XG5cdHZhciB0ZW1wLFxuXHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcblx0XHRub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUsXG5cdFx0ZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdO1xuXG5cdGlmICggZGlzcGxheSApIHtcblx0XHRyZXR1cm4gZGlzcGxheTtcblx0fVxuXG5cdHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUVsZW1lbnQoIG5vZGVOYW1lICkgKTtcblx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIHRlbXAsIFwiZGlzcGxheVwiICk7XG5cblx0dGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0ZW1wICk7XG5cblx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRkaXNwbGF5ID0gXCJibG9ja1wiO1xuXHR9XG5cdGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdID0gZGlzcGxheTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSxcblx0XHR2YWx1ZXMgPSBbXSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cblx0XHRcdC8vIFNpbmNlIHdlIGZvcmNlIHZpc2liaWxpdHkgdXBvbiBjYXNjYWRlLWhpZGRlbiBlbGVtZW50cywgYW4gaW1tZWRpYXRlIChhbmQgc2xvdylcblx0XHRcdC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxuXHRcdFx0Ly8gaW5saW5lIG9yIGFib3V0LXRvLWJlLXJlc3RvcmVkKVxuXHRcdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApIHx8IG51bGw7XG5cdFx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSApIHtcblx0XHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gXCJub25lXCI7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgd2hhdCB3ZSdyZSBvdmVyd3JpdGluZ1xuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiZGlzcGxheVwiLCBkaXNwbGF5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggdmFsdWVzWyBpbmRleCBdICE9IG51bGwgKSB7XG5cdFx0XHRlbGVtZW50c1sgaW5kZXggXS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzWyBpbmRleCBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuV2l0aGluVHJlZSggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbnZhciBydGFnTmFtZSA9ICggLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0rKS9pICk7XG5cbnZhciByc2NyaXB0VHlwZSA9ICggL14kfF5tb2R1bGUkfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xuXG5cblxuLy8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcbnZhciB3cmFwTWFwID0ge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbndyYXBNYXAub3B0Z3JvdXAgPSB3cmFwTWFwLm9wdGlvbjtcblxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcbndyYXBNYXAudGggPSB3cmFwTWFwLnRkO1xuXG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxuXHR2YXIgcmV0O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIGlmICggdHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gW107XG5cdH1cblxuXHRpZiAoIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggdG9UeXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cblx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdGkgPSAwO1xuXHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG5cdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4Nylcblx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcblx0XHRcdGlmICggaWdub3JlZCApIHtcblx0XHRcdFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjb250YWlucyA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGNvbnRhaW5zICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFNlZSAjMTMzOTMgZm9yIG1vcmUgaW5mb1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdHZhciBldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICk7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblx0XHRcdGhhbmRsZXJzID0gKCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBUcmlnZ2VyZWQgZXZlbnQgbXVzdCBlaXRoZXIgMSkgaGF2ZSBubyBuYW1lc3BhY2UsIG9yIDIpIGhhdmUgbmFtZXNwYWNlKHMpXG5cdFx0XHRcdC8vIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRmb2N1czoge1xuXG5cdFx0XHQvLyBGaXJlIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHtcblx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3VzaW5cIlxuXHRcdH0sXG5cdFx0Ymx1cjoge1xuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5ibHVyKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVsZWdhdGVUeXBlOiBcImZvY3Vzb3V0XCJcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cblx0XHRcdC8vIEZvciBjaGVja2JveCwgZmlyZSBuYXRpdmUgZXZlbnQgc28gY2hlY2tlZCBzdGF0ZSB3aWxsIGJlIHJpZ2h0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICYmIG5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBub2RlTmFtZSggZXZlbnQudGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cblx0d2hpY2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0aWYgKCBidXR0b24gJiAxICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiAyICkge1xuXHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiA0ICkge1xuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LndoaWNoO1xuXHR9XG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXG5cdC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzMyMjlcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKVtePl0qKVxcLz4vZ2ksXG5cblx0LyogZXNsaW50LWVuYWJsZSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzIG9ubHlcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG4vLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSApIHtcblxuXHRcdHJldHVybiBqUXVlcnkoIGVsZW0gKS5jaGlsZHJlbiggXCJ0Ym9keVwiIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdGlmICggKCBlbGVtLnR5cGUgfHwgXCJcIiApLnNsaWNlKCAwLCA1ICkgPT09IFwidHJ1ZS9cIiApIHtcblx0XHRlbGVtLnR5cGUgPSBlbGVtLnR5cGUuc2xpY2UoIDUgKTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0cGRhdGFDdXIuZXZlbnRzID0ge307XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0Ly8gV2UgY2FuJ3QgY2xvbmVOb2RlIGZyYWdtZW50cyB0aGF0IGNvbnRhaW4gY2hlY2tlZCwgaW4gV2ViS2l0XG5cdGlmICggdmFsdWVJc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XG5cdFx0XHR9XG5cdFx0XHRkb21NYW5pcCggc2VsZiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRpZiAoIGwgKSB7XG5cdFx0ZnJhZ21lbnQgPSBidWlsZEZyYWdtZW50KCBhcmdzLCBjb2xsZWN0aW9uWyAwIF0ub3duZXJEb2N1bWVudCwgZmFsc2UsIGNvbGxlY3Rpb24sIGlnbm9yZWQgKTtcblx0XHRmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRpZiAoIGZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcblx0XHR9XG5cblx0XHQvLyBSZXF1aXJlIGVpdGhlciBuZXcgY29udGVudCBvciBhbiBpbnRlcmVzdCBpbiBpZ25vcmVkIGVsZW1lbnRzIHRvIGludm9rZSB0aGUgY2FsbGJhY2tcblx0XHRpZiAoIGZpcnN0IHx8IGlnbm9yZWQgKSB7XG5cdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XG5cdFx0XHRoYXNTY3JpcHRzID0gc2NyaXB0cy5sZW5ndGg7XG5cblx0XHRcdC8vIFVzZSB0aGUgb3JpZ2luYWwgZnJhZ21lbnQgZm9yIHRoZSBsYXN0IGl0ZW1cblx0XHRcdC8vIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxuXHRcdFx0Ly8gYmVpbmcgZW1wdGllZCBpbmNvcnJlY3RseSBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgKCM4MDcwKS5cblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xuXG5cdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IGpRdWVyeS5jbG9uZSggbm9kZSwgdHJ1ZSwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0Ly8gS2VlcCByZWZlcmVuY2VzIHRvIGNsb25lZCBzY3JpcHRzIGZvciBsYXRlciByZXN0b3JhdGlvblxuXHRcdFx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHNjcmlwdHMsIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FsbGJhY2suY2FsbCggY29sbGVjdGlvblsgaSBdLCBub2RlLCBpICk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaGFzU2NyaXB0cyApIHtcblx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcblxuXHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXG5cdFx0XHRcdGpRdWVyeS5tYXAoIHNjcmlwdHMsIHJlc3RvcmVTY3JpcHQgKTtcblxuXHRcdFx0XHQvLyBFdmFsdWF0ZSBleGVjdXRhYmxlIHNjcmlwdHMgb24gZmlyc3QgZG9jdW1lbnQgaW5zZXJ0aW9uXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgaGFzU2NyaXB0czsgaSsrICkge1xuXHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XG5cdFx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBub2RlLnR5cGUgfHwgXCJcIiApICYmXG5cdFx0XHRcdFx0XHQhZGF0YVByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmXG5cdFx0XHRcdFx0XHRqUXVlcnkuY29udGFpbnMoIGRvYywgbm9kZSApICkge1xuXG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUuc3JjICYmICggbm9kZS50eXBlIHx8IFwiXCIgKS50b0xvd2VyQ2FzZSgpICAhPT0gXCJtb2R1bGVcIiApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIGRvYywgbm9kZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBub2RlLm93bmVyRG9jdW1lbnQsIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG52YXIgcmJveFN0eWxlID0gbmV3IFJlZ0V4cCggY3NzRXhwYW5kLmpvaW4oIFwifFwiICksIFwiaVwiICk7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuXHRcdC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2Vcblx0XHRpZiAoICFkaXYgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDtcIiArXG5cdFx0XHRcIm1hcmdpbi10b3A6MXB4O3BhZGRpbmc6MDtib3JkZXI6MFwiO1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6c2Nyb2xsO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcIndpZHRoOjYwJTt0b3A6MSVcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5tYXJnaW5MZWZ0ICkgPT09IDEyO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgU2FmYXJpIDw9OS4xIC0gMTAuMSwgaU9TIDw9Ny4wIC0gOS4zXG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLnJpZ2h0ID0gXCI2MCVcIjtcblx0XHRwaXhlbEJveFN0eWxlc1ZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUucmlnaHQgKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHRcdC8vIERldGVjdCBtaXNyZXBvcnRpbmcgb2YgY29udGVudCBkaW1lbnNpb25zIGZvciBib3gtc2l6aW5nOmJvcmRlci1ib3ggZWxlbWVudHNcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUud2lkdGggKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHQvLyBEZXRlY3Qgb3ZlcmZsb3c6c2Nyb2xsIHNjcmV3aW5lc3MgKGdoLTM2OTkpXG5cdFx0ZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXHRcdHNjcm9sbGJveFNpemVWYWwgPSBkaXYub2Zmc2V0V2lkdGggPT09IDM2IHx8IFwiYWJzb2x1dGVcIjtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHQvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG5cdFx0Ly8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxuXHRcdGRpdiA9IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiByb3VuZFBpeGVsTWVhc3VyZXMoIG1lYXN1cmUgKSB7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQoIHBhcnNlRmxvYXQoIG1lYXN1cmUgKSApO1xuXHR9XG5cblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBzY3JvbGxib3hTaXplVmFsLCBwaXhlbEJveFN0eWxlc1ZhbCxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsQm94U3R5bGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XG5cdFx0fSxcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9LFxuXHRcdHNjcm9sbGJveFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG5cdFx0Ly8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xuXHRcdC8vIGZpeGVzIGFuIGlzc3VlIHdpdGggZ2V0dGluZyB3cm9uZyB2YWx1ZXNcblx0XHQvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcblx0Ly8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCAjMTI1MzcpXG5cdC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKCMzMTQ0KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJib3hTdHlsZS50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdHJjdXN0b21Qcm9wID0gL14tLS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9LFxuXG5cdGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZTtcblxuLy8gUmV0dXJuIGEgY3NzIHByb3BlcnR5IG1hcHBlZCB0byBhIHBvdGVudGlhbGx5IHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gU2hvcnRjdXQgZm9yIG5hbWVzIHRoYXQgYXJlIG5vdCB2ZW5kb3IgcHJlZml4ZWRcblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gUmV0dXJuIGEgcHJvcGVydHkgbWFwcGVkIGFsb25nIHdoYXQgalF1ZXJ5LmNzc1Byb3BzIHN1Z2dlc3RzIG9yIHRvXG4vLyBhIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eS5cbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG5cdHZhciByZXQgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXTtcblx0aWYgKCAhcmV0ICkge1xuXHRcdHJldCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB8fCBuYW1lO1xuXHR9XG5cdHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0ZXh0cmEgPSAwLFxuXHRcdGRlbHRhID0gMDtcblxuXHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG5cdGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cblx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG5cdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0ZGVsdGEgLVxuXHRcdFx0ZXh0cmEgLVxuXHRcdFx0MC41XG5cdFx0KSApO1xuXHR9XG5cblx0cmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggY29tcHV0ZWQgc3R5bGVcblx0dmFyIHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgZGltZW5zaW9uLCBzdHlsZXMgKSxcblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94O1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0XHR2YWwgPSBcImF1dG9cIjtcblx0fVxuXG5cdC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdC8vIGZvciBnZXRDb21wdXRlZFN0eWxlIHNpbGVudGx5IGZhbGxzIGJhY2sgdG8gdGhlIHJlbGlhYmxlIGVsZW0uc3R5bGVcblx0dmFsdWVJc0JvcmRlckJveCA9IHZhbHVlSXNCb3JkZXJCb3ggJiZcblx0XHQoIHN1cHBvcnQuYm94U2l6aW5nUmVsaWFibGUoKSB8fCB2YWwgPT09IGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdICk7XG5cblx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG5cdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG5cdC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXG5cdGlmICggdmFsID09PSBcImF1dG9cIiB8fFxuXHRcdCFwYXJzZUZsb2F0KCB2YWwgKSAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImlubGluZVwiICkge1xuXG5cdFx0dmFsID0gZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdO1xuXG5cdFx0Ly8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHByb3ZpZGUgYm9yZGVyLWJveCB2YWx1ZXNcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZTtcblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBcIlwiIGFuZCBhdXRvXG5cdHZhbCA9IHBhcnNlRmxvYXQoIHZhbCApIHx8IDA7XG5cblx0Ly8gQWRqdXN0IGZvciB0aGUgZWxlbWVudCdzIGJveCBtb2RlbFxuXHRyZXR1cm4gKCB2YWwgK1xuXHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdGVsZW0sXG5cdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRleHRyYSB8fCAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICksXG5cdFx0XHR2YWx1ZUlzQm9yZGVyQm94LFxuXHRcdFx0c3R5bGVzLFxuXG5cdFx0XHQvLyBQcm92aWRlIHRoZSBjdXJyZW50IGNvbXB1dGVkIHNpemUgdG8gcmVxdWVzdCBzY3JvbGwgZ3V0dGVyIGNhbGN1bGF0aW9uIChnaC0zNTg5KVxuXHRcdFx0dmFsXG5cdFx0KVxuXHQpICsgXCJweFwiO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XG5cdC8vIGJlaGF2aW9yIG9mIGdldHRpbmcgYW5kIHNldHRpbmcgYSBzdHlsZSBwcm9wZXJ0eVxuXHRjc3NIb29rczoge1xuXHRcdG9wYWNpdHk6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdFx0Ly8gV2Ugc2hvdWxkIGFsd2F5cyBnZXQgYSBudW1iZXIgYmFjayBmcm9tIG9wYWNpdHlcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xuXHRcdFx0XHRcdHJldHVybiByZXQgPT09IFwiXCIgPyBcIjFcIiA6IHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBEb24ndCBhdXRvbWF0aWNhbGx5IGFkZCBcInB4XCIgdG8gdGhlc2UgcG9zc2libHktdW5pdGxlc3MgcHJvcGVydGllc1xuXHRjc3NOdW1iZXI6IHtcblx0XHRcImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50XCI6IHRydWUsXG5cdFx0XCJjb2x1bW5Db3VudFwiOiB0cnVlLFxuXHRcdFwiZmlsbE9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXG5cdFx0XCJmbGV4U2hyaW5rXCI6IHRydWUsXG5cdFx0XCJmb250V2VpZ2h0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge30sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbHVlICs9IHJldCAmJiByZXRbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGJhY2tncm91bmQtKiBwcm9wcyBhZmZlY3Qgb3JpZ2luYWwgY2xvbmUncyB2YWx1ZXNcblx0XHRcdGlmICggIXN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlICYmIHZhbHVlID09PSBcIlwiICYmIG5hbWUuaW5kZXhPZiggXCJiYWNrZ3JvdW5kXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fFxuXHRcdFx0XHQoIHZhbHVlID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0aWYgKCBpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRcdFx0c3R5bGUuc2V0UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgbm9uLWNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSBqdXN0IGdldCB0aGUgdmFsdWUgZnJvbSB0aGUgc3R5bGUgb2JqZWN0XG5cdFx0XHRyZXR1cm4gc3R5bGVbIG5hbWUgXTtcblx0XHR9XG5cdH0sXG5cblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcblx0XHR2YXIgdmFsLCBudW0sIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBjYW1lbENhc2UoIG5hbWUgKSxcblx0XHRcdGlzQ3VzdG9tUHJvcCA9IHJjdXN0b21Qcm9wLnRlc3QoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZS4gV2UgZG9uJ3Rcblx0XHQvLyB3YW50IHRvIG1vZGlmeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbDtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIGksIGRpbWVuc2lvbiApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBkaW1lbnNpb24gXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrXG5cdFx0XHRcdFx0Ly8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cblx0XHRcdFx0XHQvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHRcdFx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0XHRcdFx0KCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cblx0XHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXHRcdFx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgJiYgYm94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdGlzQm9yZGVyQm94LFxuXHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHQpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB1bnJlbGlhYmxlIGJvcmRlci1ib3ggZGltZW5zaW9ucyBieSBjb21wYXJpbmcgb2Zmc2V0KiB0byBjb21wdXRlZCBhbmRcblx0XHRcdC8vIGZha2luZyBhIGNvbnRlbnQtYm94IHRvIGdldCBib3JkZXIgYW5kIHBhZGRpbmcgKGdoLTM2OTkpXG5cdFx0XHRpZiAoIGlzQm9yZGVyQm94ICYmIHN1cHBvcnQuc2Nyb2xsYm94U2l6ZSgpID09PSBzdHlsZXMucG9zaXRpb24gKSB7XG5cdFx0XHRcdHN1YnRyYWN0IC09IE1hdGguY2VpbChcblx0XHRcdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoIHN0eWxlc1sgZGltZW5zaW9uIF0gKSAtXG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIFwiYm9yZGVyXCIsIGZhbHNlLCBzdHlsZXMgKSAtXG5cdFx0XHRcdFx0MC41XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBkaW1lbnNpb24gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoIHByZWZpeCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH0sXG5cdF9kZWZhdWx0OiBcInN3aW5nXCJcbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCBpblByb2dyZXNzLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbmZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0aWYgKCBkb2N1bWVudC5oaWRkZW4gPT09IGZhbHNlICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBzY2hlZHVsZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dCggc2NoZWR1bGUsIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHRcdH1cblxuXHRcdGpRdWVyeS5meC50aWNrKCk7XG5cdH1cbn1cblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IERhdGUubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcblx0XHRpc0JveCA9IFwid2lkdGhcIiBpbiBwcm9wcyB8fCBcImhlaWdodFwiIGluIHByb3BzLFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXG5cdFx0XHRcdC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxuXHRwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3BzICk7XG5cdGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuXHRpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXG5cdFx0Ly8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1kgYW5kIEVkZ2UganVzdCBtaXJyb3JzXG5cdFx0Ly8gdGhlIG92ZXJmbG93WCB2YWx1ZSB0aGVyZS5cblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxuXHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcblx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHR9XG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgKSB7XG5cdFx0XHRcdGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gR2V0IG5vbmVtcHR5IHZhbHVlKHMpIGJ5IHRlbXBvcmFyaWx5IGZvcmNpbmcgdmlzaWJpbGl0eVxuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwiaW5saW5lXCIgfHwgZGlzcGxheSA9PT0gXCJpbmxpbmUtYmxvY2tcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0XHRcdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuXHRcdFx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRwcm9wVHdlZW4gPSBmYWxzZTtcblx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXG5cdFx0Ly8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cblx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwgeyBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSB9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxuXHRcdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRcdC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuXHRcdFx0XHRpZiAoICFoaWRkZW4gKSB7XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXG5cdFx0cHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRcdHByb3BUd2Vlbi5zdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0gY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSdzIG1vcmUgdG8gZG8sIHlpZWxkXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyB3YXMgYW4gZW1wdHkgYW5pbWF0aW9uLCBzeW50aGVzaXplIGEgZmluYWwgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uXG5cdFx0XHRpZiAoICFsZW5ndGggKSB7XG5cdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzb2x2ZSB0aGUgYW5pbWF0aW9uIGFuZCByZXBvcnQgaXRzIGNvbmNsdXNpb25cblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRyZXN1bHQuc3RvcC5iaW5kKCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHQvLyBBdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRhbmltYXRpb25cblx0XHQucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdHJldHVybiBhbmltYXRpb247XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyczoge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XG5cdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fSxcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0aXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFpc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHQvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmZcblx0aWYgKCBqUXVlcnkuZngub2ZmICkge1xuXHRcdG9wdC5kdXJhdGlvbiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHRpZiAoIHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRpZiAoIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzICkge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuXHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IERhdGUubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aW5Qcm9ncmVzcyA9IHRydWU7XG5cdHNjaGVkdWxlKCk7XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpblByb2dyZXNzID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGUsXG5cdFx0XHRsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bG93ZXJjYXNlTmFtZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSBoYW5kbGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXQ7XG5cdH07XG59ICk7XG5cblxuXG5cbnZhciByZm9jdXNhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmNsaWNrYWJsZSA9IC9eKD86YXxhcmVhKSQvaTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBGaXggbmFtZSBhbmQgYXR0YWNoIGhvb2tzXG5cdFx0XHRuYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuICggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdO1xuXHR9LFxuXG5cdHByb3BIb29rczoge1xuXHRcdHRhYkluZGV4OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxNDExMTYyMzMzNDcvaHR0cDovL2ZsdWlkcHJvamVjdC5vcmcvYmxvZy8yMDA4LzAxLzA5L2dldHRpbmctc2V0dGluZy1hbmQtcmVtb3ZpbmctdGFiaW5kZXgtdmFsdWVzLXdpdGgtamF2YXNjcmlwdC9cblx0XHRcdFx0Ly8gVXNlIHByb3BlciBhdHRyaWJ1dGUgcmV0cmlldmFsKCMxMjA3Milcblx0XHRcdFx0dmFyIHRhYmluZGV4ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ0YWJpbmRleFwiICk7XG5cblx0XHRcdFx0aWYgKCB0YWJpbmRleCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQoIHRhYmluZGV4LCAxMCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHJmb2N1c2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApIHx8XG5cdFx0XHRcdFx0cmNsaWNrYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgJiZcblx0XHRcdFx0XHRlbGVtLmhyZWZcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHByb3BGaXg6IHtcblx0XHRcImZvclwiOiBcImh0bWxGb3JcIixcblx0XHRcImNsYXNzXCI6IFwiY2xhc3NOYW1lXCJcblx0fVxufSApO1xuXG4vLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcbi8vIEFjY2Vzc2luZyB0aGUgc2VsZWN0ZWRJbmRleCBwcm9wZXJ0eVxuLy8gZm9yY2VzIHRoZSBicm93c2VyIHRvIHJlc3BlY3Qgc2V0dGluZyBzZWxlY3RlZFxuLy8gb24gdGhlIG9wdGlvblxuLy8gVGhlIGdldHRlciBlbnN1cmVzIGEgZGVmYXVsdCBvcHRpb24gaXMgc2VsZWN0ZWRcbi8vIHdoZW4gaW4gYW4gb3B0Z3JvdXBcbi8vIGVzbGludCBydWxlIFwibm8tdW51c2VkLWV4cHJlc3Npb25zXCIgaXMgZGlzYWJsZWQgZm9yIHRoaXMgY29kZVxuLy8gc2luY2UgaXQgY29uc2lkZXJzIHN1Y2ggYWNjZXNzaW9ucyBub29wXG5pZiAoICFzdXBwb3J0Lm9wdFNlbGVjdGVkICkge1xuXHRqUXVlcnkucHJvcEhvb2tzLnNlbGVjdGVkID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LnNlbGVjdGVkSW5kZXg7XG5cblx0XHRcdFx0aWYgKCBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRwYXJlbnQucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG5qUXVlcnkuZWFjaCggW1xuXHRcInRhYkluZGV4XCIsXG5cdFwicmVhZE9ubHlcIixcblx0XCJtYXhMZW5ndGhcIixcblx0XCJjZWxsU3BhY2luZ1wiLFxuXHRcImNlbGxQYWRkaW5nXCIsXG5cdFwicm93U3BhblwiLFxuXHRcImNvbFNwYW5cIixcblx0XCJ1c2VNYXBcIixcblx0XCJmcmFtZUJvcmRlclwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiXG5dLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcbn0gKTtcblxuXG5cblxuXHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gSFRNTCBzcGVjXG5cdC8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2UtYXNjaWktd2hpdGVzcGFjZVxuXHRmdW5jdGlvbiBzdHJpcEFuZENvbGxhcHNlKCB2YWx1ZSApIHtcblx0XHR2YXIgdG9rZW5zID0gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0XHRyZXR1cm4gdG9rZW5zLmpvaW4oIFwiIFwiICk7XG5cdH1cblxuXG5mdW5jdGlvbiBnZXRDbGFzcyggZWxlbSApIHtcblx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlICYmIGVsZW0uZ2V0QXR0cmlidXRlKCBcImNsYXNzXCIgKSB8fCBcIlwiO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VzVG9BcnJheSggdmFsdWUgKSB7XG5cdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH1cblx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdH1cblx0cmV0dXJuIFtdO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGFkZENsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuYWRkQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApIDwgMCApIHtcblx0XHRcdFx0XHRcdFx0Y3VyICs9IGNsYXp6ICsgXCIgXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXG5cdFx0XHRcdC8vIFRoaXMgZXhwcmVzc2lvbiBpcyBoZXJlIGZvciBiZXR0ZXIgY29tcHJlc3NpYmlsaXR5IChzZWUgYWRkQ2xhc3MpXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSAqYWxsKiBpbnN0YW5jZXNcblx0XHRcdFx0XHRcdHdoaWxlICggY3VyLmluZGV4T2YoIFwiIFwiICsgY2xhenogKyBcIiBcIiApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gT25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cblx0XHRcdFx0XHRmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSxcblx0XHRcdGlzVmFsaWRWYWx1ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiBpc1ZhbGlkVmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkudG9nZ2xlQ2xhc3MoXG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggdGhpcywgaSwgZ2V0Q2xhc3MoIHRoaXMgKSwgc3RhdGVWYWwgKSxcblx0XHRcdFx0XHRzdGF0ZVZhbFxuXHRcdFx0XHQpO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSwgaSwgc2VsZiwgY2xhc3NOYW1lcztcblxuXHRcdFx0aWYgKCBpc1ZhbGlkVmFsdWUgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0XHRcdHdoaWxlICggKCBjbGFzc05hbWUgPSBjbGFzc05hbWVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgZWFjaCBjbGFzc05hbWUgZ2l2ZW4sIHNwYWNlIHNlcGFyYXRlZCBsaXN0XG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcblx0XHRcdFx0XHRcdHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gVG9nZ2xlIHdob2xlIGNsYXNzIG5hbWVcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGdldENsYXNzKCB0aGlzICk7XG5cdFx0XHRcdGlmICggY2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgY2xhc3NOYW1lIGlmIHNldFxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIsIGNsYXNzTmFtZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgYGZhbHNlYCxcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgdGhlIHdob2xlIGNsYXNzbmFtZSAoaWYgdGhlcmUgd2FzIG9uZSwgdGhlIGFib3ZlIHNhdmVkIGl0KS5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcblx0XHRcdFx0Ly8gZmFsbGluZyBiYWNrIHRvIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuXHRcdFx0XHRpZiAoIHRoaXMuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUgfHwgdmFsdWUgPT09IGZhbHNlID9cblx0XHRcdFx0XHRcdFwiXCIgOlxuXHRcdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiApIHx8IFwiXCJcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSwgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Y2xhc3NOYW1lID0gXCIgXCIgKyBzZWxlY3RvciArIFwiIFwiO1xuXHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggZ2V0Q2xhc3MoIGVsZW0gKSApICsgXCIgXCIgKS5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgcnJldHVybiA9IC9cXHIvZztcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgaG9va3MsIHJldCwgdmFsdWVJc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0aWYgKCB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHJldHVybiByZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNhc2VzIHdoZXJlIHZhbHVlIGlzIG51bGwvdW5kZWYgb3IgbnVtYmVyXG5cdFx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/IFwiXCIgOiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHR2YXIgdmFsO1xuXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHJlYXQgbnVsbC91bmRlZmluZWQgYXMgXCJcIjsgY29udmVydCBudW1iZXJzIHRvIHN0cmluZ1xuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dmFsID0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0dmFsICs9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xuXHRcdFx0XHRyZXR1cm4gdmFsICE9IG51bGwgP1xuXHRcdFx0XHRcdHZhbCA6XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEgb25seVxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcblx0XHRcdFx0XHQvLyBTdHJpcCBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS13aGl0ZXNwYWNlXG5cdFx0XHRcdFx0c3RyaXBBbmRDb2xsYXBzZSggalF1ZXJ5LnRleHQoIGVsZW0gKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbiwgaSxcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIsXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxuXHRcdFx0XHRcdG1heCA9IG9uZSA/IGluZGV4ICsgMSA6IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdGlmICggaW5kZXggPCAwICkge1xuXHRcdFx0XHRcdGkgPSBtYXg7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpID0gb25lID8gaW5kZXggOiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdC8vIElFOC05IGRvZXNuJ3QgdXBkYXRlIHNlbGVjdGVkIGFmdGVyIGZvcm0gcmVzZXQgKCMyNTUxKVxuXHRcdFx0XHRcdGlmICggKCBvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXggKSAmJlxuXG5cdFx0XHRcdFx0XHRcdC8vIERvbid0IHJldHVybiBvcHRpb25zIHRoYXQgYXJlIGRpc2FibGVkIG9yIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fFxuXHRcdFx0XHRcdFx0XHRcdCFub2RlTmFtZSggb3B0aW9uLnBhcmVudE5vZGUsIFwib3B0Z3JvdXBcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cblx0XHRcdFx0XHRcdHZhbHVlID0galF1ZXJ5KCBvcHRpb24gKS52YWwoKTtcblxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcblx0XHRcdFx0XHRcdGlmICggb25lICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE11bHRpLVNlbGVjdHMgcmV0dXJuIGFuIGFycmF5XG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBvcHRpb25TZXQsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGpRdWVyeS5tYWtlQXJyYXkoIHZhbHVlICksXG5cdFx0XHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICovXG5cblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggalF1ZXJ5LnZhbEhvb2tzLm9wdGlvbi5nZXQoIG9wdGlvbiApLCB2YWx1ZXMgKSA+IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRvcHRpb25TZXQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tY29uZC1hc3NpZ24gKi9cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XG5cdFx0XHRcdGlmICggIW9wdGlvblNldCApIHtcblx0XHRcdFx0XHRlbGVtLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBSYWRpb3MgYW5kIGNoZWNrYm94ZXMgZ2V0dGVyL3NldHRlclxualF1ZXJ5LmVhY2goIFsgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIgXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdID0ge1xuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLmNoZWNrZWQgPSBqUXVlcnkuaW5BcnJheSggalF1ZXJ5KCBlbGVtICkudmFsKCksIHZhbHVlICkgPiAtMSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0aWYgKCAhc3VwcG9ydC5jaGVja09uICkge1xuXHRcdGpRdWVyeS52YWxIb29rc1sgdGhpcyBdLmdldCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gbnVsbCA/IFwib25cIiA6IGVsZW0udmFsdWU7XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBSZXR1cm4galF1ZXJ5IGZvciBhdHRyaWJ1dGVzLW9ubHkgaW5jbHVzaW9uXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxudmFyIHJmb2N1c01vcnBoID0gL14oPzpmb2N1c2luZm9jdXN8Zm9jdXNvdXRibHVyKSQvLFxuXHRzdG9wUHJvcGFnYXRpb25DYWxsYmFjayA9IGZ1bmN0aW9uKCBlICkge1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH07XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCwgbGFzdEVsZW1lbnQsXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcblx0XHRcdHR5cGUgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwidHlwZVwiICkgPyBldmVudC50eXBlIDogZXZlbnQsXG5cdFx0XHRuYW1lc3BhY2VzID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcIm5hbWVzcGFjZVwiICkgPyBldmVudC5uYW1lc3BhY2Uuc3BsaXQoIFwiLlwiICkgOiBbXTtcblxuXHRcdGN1ciA9IGxhc3RFbGVtZW50ID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRidWJibGVUeXBlID0gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgfHwgdHlwZTtcblx0XHRcdGlmICggIXJmb2N1c01vcnBoLnRlc3QoIGJ1YmJsZVR5cGUgKyB0eXBlICkgKSB7XG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICggOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XG5cdFx0XHRcdHRtcCA9IGN1cjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT25seSBhZGQgd2luZG93IGlmIHdlIGdvdCB0byBkb2N1bWVudCAoZS5nLiwgbm90IHBsYWluIG9iaiBvciBkZXRhY2hlZCBET00pXG5cdFx0XHRpZiAoIHRtcCA9PT0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIHRtcC5kZWZhdWx0VmlldyB8fCB0bXAucGFyZW50V2luZG93IHx8IHdpbmRvdyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggY3VyID0gZXZlbnRQYXRoWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0bGFzdEVsZW1lbnQgPSBjdXI7XG5cdFx0XHRldmVudC50eXBlID0gaSA+IDEgP1xuXHRcdFx0XHRidWJibGVUeXBlIDpcblx0XHRcdFx0c3BlY2lhbC5iaW5kVHlwZSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gKCBkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJlxuXHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJoYW5kbGVcIiApO1xuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XG5cdFx0XHRcdGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5hdGl2ZSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSBvbnR5cGUgJiYgY3VyWyBvbnR5cGUgXTtcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBhY2NlcHREYXRhKCBjdXIgKSApIHtcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XG5cblx0XHQvLyBJZiBub2JvZHkgcHJldmVudGVkIHRoZSBkZWZhdWx0IGFjdGlvbiwgZG8gaXQgbm93XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcblxuXHRcdFx0aWYgKCAoICFzcGVjaWFsLl9kZWZhdWx0IHx8XG5cdFx0XHRcdHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSApICYmXG5cdFx0XHRcdGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGlzRnVuY3Rpb24oIGVsZW1bIHR5cGUgXSApICYmICFpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxuXHRcdFx0XHRcdHRtcCA9IGVsZW1bIG9udHlwZSBdO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCByZS10cmlnZ2VyaW5nIG9mIHRoZSBzYW1lIGV2ZW50LCBzaW5jZSB3ZSBhbHJlYWR5IGJ1YmJsZWQgaXQgYWJvdmVcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdHlwZTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbVsgdHlwZSBdKCk7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdC8vIFVzZWQgb25seSBmb3IgYGZvY3VzKGluIHwgb3V0KWAgZXZlbnRzXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cdH1cblxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xuXHRcdH0gKTtcblx0fSxcblx0dHJpZ2dlckhhbmRsZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBlbGVtID0gdGhpc1sgMCBdO1xuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xuXHRcdH1cblx0fVxufSApO1xuXG5cbi8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00NFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUgPD00OCAtIDQ5LCBTYWZhcmkgPD05LjAgLSA5LjFcbi8vIGZvY3VzKGluIHwgb3V0KSBldmVudHMgZmlyZSBhZnRlciBmb2N1cyAmIGJsdXIgZXZlbnRzLFxuLy8gd2hpY2ggaXMgc3BlYyB2aW9sYXRpb24gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1mb2N1c2V2ZW50LWV2ZW50LW9yZGVyXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBEYXRlLm5vdygpO1xuXG52YXIgcnF1ZXJ5ID0gKCAvXFw/LyApO1xuXG5cblxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xualF1ZXJ5LnBhcnNlWE1MID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdHZhciB4bWw7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHQvLyBJRSB0aHJvd3Mgb24gcGFyc2VGcm9tU3RyaW5nIHdpdGggaW52YWxpZCBpbnB1dC5cblx0dHJ5IHtcblx0XHR4bWwgPSAoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHR4bWwgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoICF4bWwgfHwgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInBhcnNlcmVycm9yXCIgKS5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcblx0fVxuXHRyZXR1cm4geG1sO1xufTtcblxuXG52YXJcblx0cmJyYWNrZXQgPSAvXFxbXFxdJC8sXG5cdHJDUkxGID0gL1xccj9cXG4vZyxcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxuXHRyc3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcblx0dmFyIG5hbWU7XG5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmogKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBhcnJheSBpdGVtLlxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xuXHRcdFx0aWYgKCB0cmFkaXRpb25hbCB8fCByYnJhY2tldC50ZXN0KCBwcmVmaXggKSApIHtcblxuXHRcdFx0XHQvLyBUcmVhdCBlYWNoIGFycmF5IGl0ZW0gYXMgYSBzY2FsYXIuXG5cdFx0XHRcdGFkZCggcHJlZml4LCB2ICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSXRlbSBpcyBub24tc2NhbGFyIChhcnJheSBvciBvYmplY3QpLCBlbmNvZGUgaXRzIG51bWVyaWMgaW5kZXguXG5cdFx0XHRcdGJ1aWxkUGFyYW1zKFxuXHRcdFx0XHRcdHByZWZpeCArIFwiW1wiICsgKCB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9IG51bGwgPyBpIDogXCJcIiApICsgXCJdXCIsXG5cdFx0XHRcdFx0dixcblx0XHRcdFx0XHR0cmFkaXRpb25hbCxcblx0XHRcdFx0XHRhZGRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0fSBlbHNlIGlmICggIXRyYWRpdGlvbmFsICYmIHRvVHlwZSggb2JqICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgb2JqZWN0IGl0ZW0uXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyBuYW1lICsgXCJdXCIsIG9ialsgbmFtZSBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBTZXJpYWxpemUgc2NhbGFyIGl0ZW0uXG5cdFx0YWRkKCBwcmVmaXgsIG9iaiApO1xuXHR9XG59XG5cbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXG4vLyBrZXkvdmFsdWVzIGludG8gYSBxdWVyeSBzdHJpbmdcbmpRdWVyeS5wYXJhbSA9IGZ1bmN0aW9uKCBhLCB0cmFkaXRpb25hbCApIHtcblx0dmFyIHByZWZpeCxcblx0XHRzID0gW10sXG5cdFx0YWRkID0gZnVuY3Rpb24oIGtleSwgdmFsdWVPckZ1bmN0aW9uICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHVzZSBpdHMgcmV0dXJuIHZhbHVlXG5cdFx0XHR2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKCB2YWx1ZU9yRnVuY3Rpb24gKSA/XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbigpIDpcblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uO1xuXG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICtcblx0XHRcdFx0ZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0fTtcblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSAmJiAoIHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZSsrICkgKyB1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblx0XHRcInRocm93c1wiOiB0cnVlXG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGh0bWxJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnRpbWVvdXQgPVxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IHhoci5vbnRpbWVvdXQgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiICkucHJvcCgge1xuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcblx0XHRcdFx0XHRzcmM6IHMudXJsXG5cdFx0XHRcdH0gKS5vbihcblx0XHRcdFx0XHRcImxvYWQgZXJyb3JcIixcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBpc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG5cdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbn0gKSgpO1xuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblxuXHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xuXG5cdGlmICggIWNvbnRleHQgKSB7XG5cblx0XHQvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcblx0XHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICk7XG5cblx0XHRcdC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuXHRcdFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcblx0XHRcdC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG5cdFx0XHRiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImJhc2VcIiApO1xuXHRcdFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcblx0XHRcdGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXHR9XG5cblx0cGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XG5cdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0aWYgKCBvZmYgPiAtMSApIHtcblx0XHRzZWxlY3RvciA9IHN0cmlwQW5kQ29sbGFwc2UoIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxuLy8gQXR0YWNoIGEgYnVuY2ggb2YgZnVuY3Rpb25zIGZvciBoYW5kbGluZyBjb21tb24gQUpBWCBldmVudHNcbmpRdWVyeS5lYWNoKCBbXG5cdFwiYWpheFN0YXJ0XCIsXG5cdFwiYWpheFN0b3BcIixcblx0XCJhamF4Q29tcGxldGVcIixcblx0XCJhamF4RXJyb3JcIixcblx0XCJhamF4U3VjY2Vzc1wiLFxuXHRcImFqYXhTZW5kXCJcbl0sIGZ1bmN0aW9uKCBpLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdC8vIG9mZnNldCgpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIGJvcmRlciBib3ggdG8gdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gUHJlc2VydmUgY2hhaW5pbmcgZm9yIHNldHRlclxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlY3QsIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB6ZXJvcyBmb3IgZGlzY29ubmVjdGVkIGFuZCBoaWRkZW4gKGRpc3BsYXk6IG5vbmUpIGVsZW1lbnRzIChnaC0yMzEwKVxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGFcblx0XHQvLyBkaXNjb25uZWN0ZWQgbm9kZSBpbiBJRSB0aHJvd3MgYW4gZXJyb3Jcblx0XHRpZiAoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0Ly8gR2V0IGRvY3VtZW50LXJlbGF0aXZlIHBvc2l0aW9uIGJ5IGFkZGluZyB2aWV3cG9ydCBzY3JvbGwgdG8gdmlld3BvcnQtcmVsYXRpdmUgZ0JDUlxuXHRcdHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHdpbiA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiByZWN0LnRvcCArIHdpbi5wYWdlWU9mZnNldCxcblx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHdpbi5wYWdlWE9mZnNldFxuXHRcdH07XG5cdH0sXG5cblx0Ly8gcG9zaXRpb24oKSByZWxhdGVzIGFuIGVsZW1lbnQncyBtYXJnaW4gYm94IHRvIGl0cyBvZmZzZXQgcGFyZW50J3MgcGFkZGluZyBib3hcblx0Ly8gVGhpcyBjb3JyZXNwb25kcyB0byB0aGUgYmVoYXZpb3Igb2YgQ1NTIGFic29sdXRlIHBvc2l0aW9uaW5nXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoICF0aGlzWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LCBkb2MsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblxuXHRcdC8vIHBvc2l0aW9uOmZpeGVkIGVsZW1lbnRzIGFyZSBvZmZzZXQgZnJvbSB0aGUgdmlld3BvcnQsIHdoaWNoIGl0c2VsZiBhbHdheXMgaGFzIHplcm8gb2Zmc2V0XG5cdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSA9PT0gXCJmaXhlZFwiICkge1xuXG5cdFx0XHQvLyBBc3N1bWUgcG9zaXRpb246Zml4ZWQgaW1wbGllcyBhdmFpbGFiaWxpdHkgb2YgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG5cdFx0XHRvZmZzZXQgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdG9mZnNldCA9IHRoaXMub2Zmc2V0KCk7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHRoZSAqcmVhbCogb2Zmc2V0IHBhcmVudCwgd2hpY2ggY2FuIGJlIHRoZSBkb2N1bWVudCBvciBpdHMgcm9vdCBlbGVtZW50XG5cdFx0XHQvLyB3aGVuIGEgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnQgaXMgaWRlbnRpZmllZFxuXHRcdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdFx0b2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmXG5cdFx0XHRcdCggb2Zmc2V0UGFyZW50ID09PSBkb2MuYm9keSB8fCBvZmZzZXRQYXJlbnQgPT09IGRvYy5kb2N1bWVudEVsZW1lbnQgKSAmJlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50ICE9PSBlbGVtICYmIG9mZnNldFBhcmVudC5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSBib3JkZXJzIGludG8gaXRzIG9mZnNldCwgc2luY2UgdGhleSBhcmUgb3V0c2lkZSBpdHMgY29udGVudCBvcmlnaW5cblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0galF1ZXJ5KCBvZmZzZXRQYXJlbnQgKS5vZmZzZXQoKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyVG9wV2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQubGVmdCArPSBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogb2Zmc2V0LnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlICksXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gZG9jdW1lbnRFbGVtZW50IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG5cdC8vIDEpIEZvciB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIGlmcmFtZSB3aXRob3V0IG9mZnNldFBhcmVudCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0Ly8gICAgZG9jdW1lbnRFbGVtZW50IG9mIHRoZSBwYXJlbnQgd2luZG93XG5cdC8vIDIpIEZvciB0aGUgaGlkZGVuIG9yIGRldGFjaGVkIGVsZW1lbnRcblx0Ly8gMykgRm9yIGJvZHkgb3IgaHRtbCBlbGVtZW50LCBpLmUuIGluIGNhc2Ugb2YgdGhlIGh0bWwgbm9kZSAtIGl0IHdpbGwgcmV0dXJuIGl0c2VsZlxuXHQvL1xuXHQvLyBidXQgdGhvc2UgZXhjZXB0aW9ucyB3ZXJlIG5ldmVyIHByZXNlbnRlZCBhcyBhIHJlYWwgbGlmZSB1c2UtY2FzZXNcblx0Ly8gYW5kIG1pZ2h0IGJlIGNvbnNpZGVyZWQgYXMgbW9yZSBwcmVmZXJhYmxlIHJlc3VsdHMuXG5cdC8vXG5cdC8vIFRoaXMgbG9naWMsIGhvd2V2ZXIsIGlzIG5vdCBndWFyYW50ZWVkIGFuZCBjYW4gY2hhbmdlIGF0IGFueSBwb2ludCBpbiB0aGUgZnV0dXJlXG5cdG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudDtcblxuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiYgalF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudEVsZW1lbnQ7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbi8vIENyZWF0ZSBzY3JvbGxMZWZ0IGFuZCBzY3JvbGxUb3AgbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgc2Nyb2xsTGVmdDogXCJwYWdlWE9mZnNldFwiLCBzY3JvbGxUb3A6IFwicGFnZVlPZmZzZXRcIiB9LCBmdW5jdGlvbiggbWV0aG9kLCBwcm9wICkge1xuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xuXG5cdGpRdWVyeS5mblsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdmFsICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcblxuXHRcdFx0Ly8gQ29hbGVzY2UgZG9jdW1lbnRzIGFuZCB3aW5kb3dzXG5cdFx0XHR2YXIgd2luO1xuXHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0d2luID0gZWxlbS5kZWZhdWx0Vmlldztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHdpbiA/IHdpblsgcHJvcCBdIDogZWxlbVsgbWV0aG9kIF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggd2luICkge1xuXHRcdFx0XHR3aW4uc2Nyb2xsVG8oXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbi5wYWdlWE9mZnNldCxcblx0XHRcdFx0XHR0b3AgPyB2YWwgOiB3aW4ucGFnZVlPZmZzZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbVsgbWV0aG9kIF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSwgbWV0aG9kLCB2YWwsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fTtcbn0gKTtcblxuLy8gU3VwcG9ydDogU2FmYXJpIDw9NyAtIDkuMSwgQ2hyb21lIDw9MzcgLSA0OVxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD01ODkzNDdcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHQ7XG4vLyByYXRoZXIgdGhhbiBtYWtlIHRoZSBjc3MgbW9kdWxlIGRlcGVuZCBvbiB0aGUgb2Zmc2V0IG1vZHVsZSwganVzdCBjaGVjayBmb3IgaXQgaGVyZVxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuXHRcdGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuXHRcdFx0XHRcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG5cdFx0XHRcdFx0XHRlbGVtWyBcImlubmVyXCIgKyBuYW1lIF0gOlxuXHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmVhY2goICggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxuXG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fVxufSApO1xuXG4vLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcbi8vIGFyZ3VtZW50cy5cbi8vIGpRdWVyeS5wcm94eSBpcyBkZXByZWNhdGVkIHRvIHByb21vdGUgc3RhbmRhcmRzIChzcGVjaWZpY2FsbHkgRnVuY3Rpb24jYmluZClcbi8vIEhvd2V2ZXIsIGl0IGlzIG5vdCBzbGF0ZWQgZm9yIHJlbW92YWwgYW55IHRpbWUgc29vblxualF1ZXJ5LnByb3h5ID0gZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0Y29udGV4dCA9IGZuO1xuXHRcdGZuID0gdG1wO1xuXHR9XG5cblx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0aWYgKCAhaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHR9O1xuXG5cdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRyZXR1cm4gcHJveHk7XG59O1xuXG5qUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24oIGhvbGQgKSB7XG5cdGlmICggaG9sZCApIHtcblx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdH1cbn07XG5qUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcbmpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xualF1ZXJ5LmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xualF1ZXJ5LmlzV2luZG93ID0gaXNXaW5kb3c7XG5qUXVlcnkuY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xualF1ZXJ5LnR5cGUgPSB0b1R5cGU7XG5cbmpRdWVyeS5ub3cgPSBEYXRlLm5vdztcblxualF1ZXJ5LmlzTnVtZXJpYyA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuXHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuXHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XG59O1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCAhbm9HbG9iYWwgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwb3J0cy5ub2RlTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQ29tbW9uSlNcbiAgICAgICAgZmFjdG9yeShleHBvcnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHNcbiAgICAgICAgZmFjdG9yeShyb290Lm1hcXVldHRlID0ge30pO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gQ29tbWVudCB0aGF0IGlzIGRpc3BsYXllZCBpbiB0aGUgQVBJIGRvY3VtZW50YXRpb24gZm9yIHRoZSBtYXF1ZXR0ZSBtb2R1bGU6XG4gICAgLyoqXG4gKiBXZWxjb21lIHRvIHRoZSBBUEkgZG9jdW1lbnRhdGlvbiBvZiB0aGUgKiptYXF1ZXR0ZSoqIGxpYnJhcnkuXG4gKlxuICogW1todHRwOi8vbWFxdWV0dGVqcy5vcmcvfFRvIHRoZSBtYXF1ZXR0ZSBob21lcGFnZV1dXG4gKi9cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIHZhciBOQU1FU1BBQ0VfVzMgPSAnaHR0cDovL3d3dy53My5vcmcvJztcbiAgICB2YXIgTkFNRVNQQUNFX1NWRyA9IE5BTUVTUEFDRV9XMyArICcyMDAwL3N2Zyc7XG4gICAgdmFyIE5BTUVTUEFDRV9YTElOSyA9IE5BTUVTUEFDRV9XMyArICcxOTk5L3hsaW5rJztcbiAgICAvLyBVdGlsaXRpZXNcbiAgICB2YXIgZW1wdHlBcnJheSA9IFtdO1xuICAgIHZhciBleHRlbmQgPSBmdW5jdGlvbiAoYmFzZSwgb3ZlcnJpZGVzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoYmFzZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGJhc2Vba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvdmVycmlkZXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG92ZXJyaWRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBvdmVycmlkZXNba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvLyBIeXBlcnNjcmlwdCBoZWxwZXIgZnVuY3Rpb25zXG4gICAgdmFyIHNhbWUgPSBmdW5jdGlvbiAodm5vZGUxLCB2bm9kZTIpIHtcbiAgICAgICAgaWYgKHZub2RlMS52bm9kZVNlbGVjdG9yICE9PSB2bm9kZTIudm5vZGVTZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bm9kZTEucHJvcGVydGllcyAmJiB2bm9kZTIucHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHZub2RlMS5wcm9wZXJ0aWVzLmtleSAhPT0gdm5vZGUyLnByb3BlcnRpZXMua2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZub2RlMS5wcm9wZXJ0aWVzLmJpbmQgPT09IHZub2RlMi5wcm9wZXJ0aWVzLmJpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICF2bm9kZTEucHJvcGVydGllcyAmJiAhdm5vZGUyLnByb3BlcnRpZXM7XG4gICAgfTtcbiAgICB2YXIgdG9UZXh0Vk5vZGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdm5vZGVTZWxlY3RvcjogJycsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjaGlsZHJlbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdGV4dDogZGF0YS50b1N0cmluZygpLFxuICAgICAgICAgICAgZG9tTm9kZTogbnVsbFxuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIGFwcGVuZENoaWxkcmVuID0gZnVuY3Rpb24gKHBhcmVudFNlbGVjdG9yLCBpbnNlcnRpb25zLCBtYWluKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGhfMSA9IGluc2VydGlvbnMubGVuZ3RoOyBpIDwgbGVuZ3RoXzE7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpbnNlcnRpb25zW2ldO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRDaGlsZHJlbihwYXJlbnRTZWxlY3RvciwgaXRlbSwgbWFpbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtICE9PSBudWxsICYmIGl0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0uaGFzT3duUHJvcGVydHkoJ3Zub2RlU2VsZWN0b3InKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IHRvVGV4dFZOb2RlKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1haW4ucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFJlbmRlciBoZWxwZXIgZnVuY3Rpb25zXG4gICAgdmFyIG1pc3NpbmdUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGUgYSB0cmFuc2l0aW9ucyBvYmplY3QgdG8gdGhlIHByb2plY3Rpb25PcHRpb25zIHRvIGRvIGFuaW1hdGlvbnMnKTtcbiAgICB9O1xuICAgIHZhciBERUZBVUxUX1BST0pFQ1RJT05fT1BUSU9OUyA9IHtcbiAgICAgICAgbmFtZXNwYWNlOiB1bmRlZmluZWQsXG4gICAgICAgIGV2ZW50SGFuZGxlckludGVyY2VwdG9yOiB1bmRlZmluZWQsXG4gICAgICAgIHN0eWxlQXBwbHllcjogZnVuY3Rpb24gKGRvbU5vZGUsIHN0eWxlTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFByb3ZpZGVzIGEgaG9vayB0byBhZGQgdmVuZG9yIHByZWZpeGVzIGZvciBicm93c2VycyB0aGF0IHN0aWxsIG5lZWQgaXQuXG4gICAgICAgICAgICBkb21Ob2RlLnN0eWxlW3N0eWxlTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNpdGlvbnM6IHtcbiAgICAgICAgICAgIGVudGVyOiBtaXNzaW5nVHJhbnNpdGlvbixcbiAgICAgICAgICAgIGV4aXQ6IG1pc3NpbmdUcmFuc2l0aW9uXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBhcHBseURlZmF1bHRQcm9qZWN0aW9uT3B0aW9ucyA9IGZ1bmN0aW9uIChwcm9qZWN0b3JPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBleHRlbmQoREVGQVVMVF9QUk9KRUNUSU9OX09QVElPTlMsIHByb2plY3Rvck9wdGlvbnMpO1xuICAgIH07XG4gICAgdmFyIGNoZWNrU3R5bGVWYWx1ZSA9IGZ1bmN0aW9uIChzdHlsZVZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3R5bGVWYWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3R5bGUgdmFsdWVzIG11c3QgYmUgc3RyaW5ncycpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgc2V0UHJvcGVydGllcyA9IGZ1bmN0aW9uIChkb21Ob2RlLCBwcm9wZXJ0aWVzLCBwcm9qZWN0aW9uT3B0aW9ucykge1xuICAgICAgICBpZiAoIXByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRIYW5kbGVySW50ZXJjZXB0b3IgPSBwcm9qZWN0aW9uT3B0aW9ucy5ldmVudEhhbmRsZXJJbnRlcmNlcHRvcjtcbiAgICAgICAgdmFyIHByb3BOYW1lcyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpO1xuICAgICAgICB2YXIgcHJvcENvdW50ID0gcHJvcE5hbWVzLmxlbmd0aDtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcE5hbWVzW2ldO1xuICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tdmFyLWtleXdvcmQ6IGVkZ2UgY2FzZSAqL1xuICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BlcnRpZXNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby12YXIta2V5d29yZCAqL1xuICAgICAgICAgICAgaWYgKHByb3BOYW1lID09PSAnY2xhc3NOYW1lJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgXCJjbGFzc05hbWVcIiBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgXCJjbGFzc1wiLicpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wTmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgIHByb3BWYWx1ZS5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb21Ob2RlLmNsYXNzTGlzdC5hZGQodG9rZW4pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wTmFtZSA9PT0gJ2NsYXNzZXMnKSB7XG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0IHdpdGggc3RyaW5nIGtleXMgYW5kIGJvb2xlYW4gdmFsdWVzXG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBPYmplY3Qua2V5cyhwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWVDb3VudCA9IGNsYXNzTmFtZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2xhc3NOYW1lQ291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gY2xhc3NOYW1lc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BWYWx1ZVtjbGFzc05hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcE5hbWUgPT09ICdzdHlsZXMnKSB7XG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0IHdpdGggc3RyaW5nIGtleXMgYW5kIHN0cmluZyAoISkgdmFsdWVzXG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlTmFtZXMgPSBPYmplY3Qua2V5cyhwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZUNvdW50ID0gc3R5bGVOYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdHlsZUNvdW50OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlTmFtZSA9IHN0eWxlTmFtZXNbal07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZVZhbHVlID0gcHJvcFZhbHVlW3N0eWxlTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja1N0eWxlVmFsdWUoc3R5bGVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9qZWN0aW9uT3B0aW9ucy5zdHlsZUFwcGx5ZXIoZG9tTm9kZSwgc3R5bGVOYW1lLCBzdHlsZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcE5hbWUgIT09ICdrZXknICYmIHByb3BWYWx1ZSAhPT0gbnVsbCAmJiBwcm9wVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcE5hbWUubGFzdEluZGV4T2YoJ29uJywgMCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudEhhbmRsZXJJbnRlcmNlcHRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSA9IGV2ZW50SGFuZGxlckludGVyY2VwdG9yKHByb3BOYW1lLCBwcm9wVmFsdWUsIGRvbU5vZGUsIHByb3BlcnRpZXMpOyAgICAvLyBpbnRlcmNlcHQgZXZlbnRoYW5kbGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BOYW1lID09PSAnb25pbnB1dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZWNvcmQgdGhlIGV2dC50YXJnZXQudmFsdWUsIGJlY2F1c2UgSUUgYW5kIEVkZ2Ugc29tZXRpbWVzIGRvIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGJldHdlZW4gY2hhbmdpbmcgdmFsdWUgYW5kIHJ1bm5pbmcgb25pbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkUHJvcFZhbHVlID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRQcm9wVmFsdWUuYXBwbHkodGhpcywgW2V2dF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZ0LnRhcmdldFsnb25pbnB1dC12YWx1ZSddID0gZXZ0LnRhcmdldC52YWx1ZTsgICAgLy8gbWF5IGJlIEhUTUxUZXh0QXJlYUVsZW1lbnQgYXMgd2VsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlW3Byb3BOYW1lXSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgcHJvcE5hbWUgIT09ICd2YWx1ZScgJiYgcHJvcE5hbWUgIT09ICdpbm5lckhUTUwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9qZWN0aW9uT3B0aW9ucy5uYW1lc3BhY2UgPT09IE5BTUVTUEFDRV9TVkcgJiYgcHJvcE5hbWUgPT09ICdocmVmJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5zZXRBdHRyaWJ1dGVOUyhOQU1FU1BBQ0VfWExJTkssIHByb3BOYW1lLCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5zZXRBdHRyaWJ1dGUocHJvcE5hbWUsIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb21Ob2RlW3Byb3BOYW1lXSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIF9sb29wXzEoaSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciB1cGRhdGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGRvbU5vZGUsIHByZXZpb3VzUHJvcGVydGllcywgcHJvcGVydGllcywgcHJvamVjdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BlcnRpZXNVcGRhdGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBwcm9wTmFtZXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKTtcbiAgICAgICAgdmFyIHByb3BDb3VudCA9IHByb3BOYW1lcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BOYW1lc1tpXTtcbiAgICAgICAgICAgIC8vIGFzc3VtaW5nIHRoYXQgcHJvcGVydGllcyB3aWxsIGJlIG51bGxpZmllZCBpbnN0ZWFkIG9mIG1pc3NpbmcgaXMgYnkgZGVzaWduXG4gICAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IHByZXZpb3VzUHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgICAgICAgICBpZiAocHJvcE5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSAhPT0gcHJvcFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCJjbGFzc1wiIHByb3BlcnR5IG1heSBub3QgYmUgdXBkYXRlZC4gVXNlIHRoZSBcImNsYXNzZXNcIiBwcm9wZXJ0eSBmb3IgY29uZGl0aW9uYWwgY3NzIGNsYXNzZXMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wTmFtZSA9PT0gJ2NsYXNzZXMnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTGlzdCA9IGRvbU5vZGUuY2xhc3NMaXN0O1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWVzID0gT2JqZWN0LmtleXMocHJvcFZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lQ291bnQgPSBjbGFzc05hbWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNsYXNzTmFtZUNvdW50OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbal07XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbiA9ICEhcHJvcFZhbHVlW2NsYXNzTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c09uID0gISFwcmV2aW91c1ZhbHVlW2NsYXNzTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbiA9PT0gcHJldmlvdXNPbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllc1VwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAob24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcE5hbWUgPT09ICdzdHlsZXMnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlTmFtZXMgPSBPYmplY3Qua2V5cyhwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZUNvdW50ID0gc3R5bGVOYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdHlsZUNvdW50OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlTmFtZSA9IHN0eWxlTmFtZXNbal07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdTdHlsZVZhbHVlID0gcHJvcFZhbHVlW3N0eWxlTmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbGRTdHlsZVZhbHVlID0gcHJldmlvdXNWYWx1ZVtzdHlsZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3U3R5bGVWYWx1ZSA9PT0gb2xkU3R5bGVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllc1VwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3U3R5bGVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tTdHlsZVZhbHVlKG5ld1N0eWxlVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvamVjdGlvbk9wdGlvbnMuc3R5bGVBcHBseWVyKGRvbU5vZGUsIHN0eWxlTmFtZSwgbmV3U3R5bGVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9qZWN0aW9uT3B0aW9ucy5zdHlsZUFwcGx5ZXIoZG9tTm9kZSwgc3R5bGVOYW1lLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghcHJvcFZhbHVlICYmIHR5cGVvZiBwcmV2aW91c1ZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3BOYW1lID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb21WYWx1ZSA9IGRvbU5vZGVbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tVmFsdWUgIT09IHByb3BWYWx1ZSAgICAvLyBUaGUgJ3ZhbHVlJyBpbiB0aGUgRE9NIHRyZWUgIT09IG5ld1ZhbHVlXG4mJiAoZG9tTm9kZVsnb25pbnB1dC12YWx1ZSddID8gZG9tVmFsdWUgPT09IGRvbU5vZGVbJ29uaW5wdXQtdmFsdWUnXSAgICAvLyBJZiB0aGUgbGFzdCByZXBvcnRlZCB2YWx1ZSB0byAnb25pbnB1dCcgZG9lcyBub3QgbWF0Y2ggZG9tVmFsdWUsIGRvIG5vdGhpbmcgYW5kIHdhaXQgZm9yIG9uaW5wdXRcbiA6IHByb3BWYWx1ZSAhPT0gcHJldmlvdXNWYWx1ZSAgICAvLyBPbmx5IHVwZGF0ZSB0aGUgdmFsdWUgaWYgdGhlIHZkb20gY2hhbmdlZFxuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZVtwcm9wTmFtZV0gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgdmFsdWUsIGV2ZW4gaWYgdGhlIHZpcnR1YWwgRE9NIGRpZCBub3QgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlWydvbmlucHV0LXZhbHVlJ10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBkbyBub3QgdXBkYXRlIHRoZSBkb21Ob2RlLCBvdGhlcndpc2UgdGhlIGN1cnNvciBwb3NpdGlvbiB3b3VsZCBiZSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wVmFsdWUgIT09IHByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXNVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlICE9PSBwcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb25zIG1heSBub3QgYmUgdXBkYXRlZCBvbiBzdWJzZXF1ZW50IHJlbmRlcnMgKHByb3BlcnR5OiAnICsgcHJvcE5hbWUgKyAnKS4gSGludDogZGVjbGFyZSBldmVudCBoYW5kbGVyIGZ1bmN0aW9ucyBvdXRzaWRlIHRoZSByZW5kZXIoKSBmdW5jdGlvbi4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgcHJvcE5hbWUgIT09ICdpbm5lckhUTUwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvamVjdGlvbk9wdGlvbnMubmFtZXNwYWNlID09PSBOQU1FU1BBQ0VfU1ZHICYmIHByb3BOYW1lID09PSAnaHJlZicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLnNldEF0dHJpYnV0ZU5TKE5BTUVTUEFDRV9YTElOSywgcHJvcE5hbWUsIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BOYW1lID09PSAncm9sZScgJiYgcHJvcFZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGUucmVtb3ZlQXR0cmlidXRlKHByb3BOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5zZXRBdHRyaWJ1dGUocHJvcE5hbWUsIHByb3BWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tTm9kZVtwcm9wTmFtZV0gIT09IHByb3BWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGVbcHJvcE5hbWVdID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXNVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXNVcGRhdGVkO1xuICAgIH07XG4gICAgdmFyIGZpbmRJbmRleE9mQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIHNhbWVBcywgc3RhcnQpIHtcbiAgICAgICAgaWYgKHNhbWVBcy52bm9kZVNlbGVjdG9yICE9PSAnJykge1xuICAgICAgICAgICAgLy8gTmV2ZXIgc2NhbiBmb3IgdGV4dC1ub2Rlc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc2FtZShjaGlsZHJlbltpXSwgc2FtZUFzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgdmFyIG5vZGVBZGRlZCA9IGZ1bmN0aW9uICh2Tm9kZSwgdHJhbnNpdGlvbnMpIHtcbiAgICAgICAgaWYgKHZOb2RlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHZhciBlbnRlckFuaW1hdGlvbiA9IHZOb2RlLnByb3BlcnRpZXMuZW50ZXJBbmltYXRpb247XG4gICAgICAgICAgICBpZiAoZW50ZXJBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVudGVyQW5pbWF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudGVyQW5pbWF0aW9uKHZOb2RlLmRvbU5vZGUsIHZOb2RlLnByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zLmVudGVyKHZOb2RlLmRvbU5vZGUsIHZOb2RlLnByb3BlcnRpZXMsIGVudGVyQW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBub2RlVG9SZW1vdmUgPSBmdW5jdGlvbiAodk5vZGUsIHRyYW5zaXRpb25zKSB7XG4gICAgICAgIHZhciBkb21Ob2RlID0gdk5vZGUuZG9tTm9kZTtcbiAgICAgICAgaWYgKHZOb2RlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHZhciBleGl0QW5pbWF0aW9uID0gdk5vZGUucHJvcGVydGllcy5leGl0QW5pbWF0aW9uO1xuICAgICAgICAgICAgaWYgKGV4aXRBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZURvbU5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb21Ob2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb21Ob2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleGl0QW5pbWF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXRBbmltYXRpb24oZG9tTm9kZSwgcmVtb3ZlRG9tTm9kZSwgdk5vZGUucHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9ucy5leGl0KHZOb2RlLmRvbU5vZGUsIHZOb2RlLnByb3BlcnRpZXMsIGV4aXRBbmltYXRpb24sIHJlbW92ZURvbU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkb21Ob2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGRvbU5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkb21Ob2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGNoZWNrRGlzdGluZ3Vpc2hhYmxlID0gZnVuY3Rpb24gKGNoaWxkTm9kZXMsIGluZGV4VG9DaGVjaywgcGFyZW50Vk5vZGUsIG9wZXJhdGlvbikge1xuICAgICAgICB2YXIgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tpbmRleFRvQ2hlY2tdO1xuICAgICAgICBpZiAoY2hpbGROb2RlLnZub2RlU2VsZWN0b3IgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm47ICAgIC8vIFRleHQgbm9kZXMgbmVlZCBub3QgYmUgZGlzdGluZ3Vpc2hhYmxlXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBjaGlsZE5vZGUucHJvcGVydGllcztcbiAgICAgICAgdmFyIGtleSA9IHByb3BlcnRpZXMgPyBwcm9wZXJ0aWVzLmtleSA9PT0gdW5kZWZpbmVkID8gcHJvcGVydGllcy5iaW5kIDogcHJvcGVydGllcy5rZXkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gaW5kZXhUb0NoZWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNhbWUobm9kZSwgY2hpbGROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJ2FkZGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwYXJlbnRWTm9kZS52bm9kZVNlbGVjdG9yICsgJyBoYWQgYSAnICsgY2hpbGROb2RlLnZub2RlU2VsZWN0b3IgKyAnIGNoaWxkICcgKyAnYWRkZWQsIGJ1dCB0aGVyZSBpcyBub3cgbW9yZSB0aGFuIG9uZS4gWW91IG11c3QgYWRkIHVuaXF1ZSBrZXkgcHJvcGVydGllcyB0byBtYWtlIHRoZW0gZGlzdGluZ3Vpc2hhYmxlLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocGFyZW50Vk5vZGUudm5vZGVTZWxlY3RvciArICcgaGFkIGEgJyArIGNoaWxkTm9kZS52bm9kZVNlbGVjdG9yICsgJyBjaGlsZCAnICsgJ3JlbW92ZWQsIGJ1dCB0aGVyZSB3ZXJlIG1vcmUgdGhhbiBvbmUuIFlvdSBtdXN0IGFkZCB1bmlxdWUga2V5IHByb3BlcnRpZXMgdG8gbWFrZSB0aGVtIGRpc3Rpbmd1aXNoYWJsZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGNyZWF0ZURvbTtcbiAgICB2YXIgdXBkYXRlRG9tO1xuICAgIHZhciB1cGRhdGVDaGlsZHJlbiA9IGZ1bmN0aW9uICh2bm9kZSwgZG9tTm9kZSwgb2xkQ2hpbGRyZW4sIG5ld0NoaWxkcmVuLCBwcm9qZWN0aW9uT3B0aW9ucykge1xuICAgICAgICBpZiAob2xkQ2hpbGRyZW4gPT09IG5ld0NoaWxkcmVuKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgb2xkQ2hpbGRyZW4gPSBvbGRDaGlsZHJlbiB8fCBlbXB0eUFycmF5O1xuICAgICAgICBuZXdDaGlsZHJlbiA9IG5ld0NoaWxkcmVuIHx8IGVtcHR5QXJyYXk7XG4gICAgICAgIHZhciBvbGRDaGlsZHJlbkxlbmd0aCA9IG9sZENoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgdmFyIG5ld0NoaWxkcmVuTGVuZ3RoID0gbmV3Q2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICB2YXIgdHJhbnNpdGlvbnMgPSBwcm9qZWN0aW9uT3B0aW9ucy50cmFuc2l0aW9ucztcbiAgICAgICAgdmFyIG9sZEluZGV4ID0gMDtcbiAgICAgICAgdmFyIG5ld0luZGV4ID0gMDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciB0ZXh0VXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAobmV3SW5kZXggPCBuZXdDaGlsZHJlbkxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG9sZENoaWxkID0gb2xkSW5kZXggPCBvbGRDaGlsZHJlbkxlbmd0aCA/IG9sZENoaWxkcmVuW29sZEluZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBuZXdDaGlsZCA9IG5ld0NoaWxkcmVuW25ld0luZGV4XTtcbiAgICAgICAgICAgIGlmIChvbGRDaGlsZCAhPT0gdW5kZWZpbmVkICYmIHNhbWUob2xkQ2hpbGQsIG5ld0NoaWxkKSkge1xuICAgICAgICAgICAgICAgIHRleHRVcGRhdGVkID0gdXBkYXRlRG9tKG9sZENoaWxkLCBuZXdDaGlsZCwgcHJvamVjdGlvbk9wdGlvbnMpIHx8IHRleHRVcGRhdGVkO1xuICAgICAgICAgICAgICAgIG9sZEluZGV4Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmaW5kT2xkSW5kZXggPSBmaW5kSW5kZXhPZkNoaWxkKG9sZENoaWxkcmVuLCBuZXdDaGlsZCwgb2xkSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAoZmluZE9sZEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHByZWNlZGluZyBtaXNzaW5nIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IG9sZEluZGV4OyBpIDwgZmluZE9sZEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVUb1JlbW92ZShvbGRDaGlsZHJlbltpXSwgdHJhbnNpdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tEaXN0aW5ndWlzaGFibGUob2xkQ2hpbGRyZW4sIGksIHZub2RlLCAncmVtb3ZlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRleHRVcGRhdGVkID0gdXBkYXRlRG9tKG9sZENoaWxkcmVuW2ZpbmRPbGRJbmRleF0sIG5ld0NoaWxkLCBwcm9qZWN0aW9uT3B0aW9ucykgfHwgdGV4dFVwZGF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIG9sZEluZGV4ID0gZmluZE9sZEluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBOZXcgY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRG9tKG5ld0NoaWxkLCBkb21Ob2RlLCBvbGRJbmRleCA8IG9sZENoaWxkcmVuTGVuZ3RoID8gb2xkQ2hpbGRyZW5bb2xkSW5kZXhdLmRvbU5vZGUgOiB1bmRlZmluZWQsIHByb2plY3Rpb25PcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZUFkZGVkKG5ld0NoaWxkLCB0cmFuc2l0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRGlzdGluZ3Vpc2hhYmxlKG5ld0NoaWxkcmVuLCBuZXdJbmRleCwgdm5vZGUsICdhZGRlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0luZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZENoaWxkcmVuTGVuZ3RoID4gb2xkSW5kZXgpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBjaGlsZCBmcmFnbWVudHNcbiAgICAgICAgICAgIGZvciAoaSA9IG9sZEluZGV4OyBpIDwgb2xkQ2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG5vZGVUb1JlbW92ZShvbGRDaGlsZHJlbltpXSwgdHJhbnNpdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNoZWNrRGlzdGluZ3Vpc2hhYmxlKG9sZENoaWxkcmVuLCBpLCB2bm9kZSwgJ3JlbW92ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dFVwZGF0ZWQ7XG4gICAgfTtcbiAgICB2YXIgYWRkQ2hpbGRyZW4gPSBmdW5jdGlvbiAoZG9tTm9kZSwgY2hpbGRyZW4sIHByb2plY3Rpb25PcHRpb25zKSB7XG4gICAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjcmVhdGVEb20oY2hpbGRyZW5baV0sIGRvbU5vZGUsIHVuZGVmaW5lZCwgcHJvamVjdGlvbk9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgaW5pdFByb3BlcnRpZXNBbmRDaGlsZHJlbiA9IGZ1bmN0aW9uIChkb21Ob2RlLCB2bm9kZSwgcHJvamVjdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgYWRkQ2hpbGRyZW4oZG9tTm9kZSwgdm5vZGUuY2hpbGRyZW4sIHByb2plY3Rpb25PcHRpb25zKTtcbiAgICAgICAgLy8gY2hpbGRyZW4gYmVmb3JlIHByb3BlcnRpZXMsIG5lZWRlZCBmb3IgdmFsdWUgcHJvcGVydHkgb2YgPHNlbGVjdD4uXG4gICAgICAgIGlmICh2bm9kZS50ZXh0KSB7XG4gICAgICAgICAgICBkb21Ob2RlLnRleHRDb250ZW50ID0gdm5vZGUudGV4dDtcbiAgICAgICAgfVxuICAgICAgICBzZXRQcm9wZXJ0aWVzKGRvbU5vZGUsIHZub2RlLnByb3BlcnRpZXMsIHByb2plY3Rpb25PcHRpb25zKTtcbiAgICAgICAgaWYgKHZub2RlLnByb3BlcnRpZXMgJiYgdm5vZGUucHJvcGVydGllcy5hZnRlckNyZWF0ZSkge1xuICAgICAgICAgICAgdm5vZGUucHJvcGVydGllcy5hZnRlckNyZWF0ZS5hcHBseSh2bm9kZS5wcm9wZXJ0aWVzLmJpbmQgfHwgdm5vZGUucHJvcGVydGllcywgW1xuICAgICAgICAgICAgICAgIGRvbU5vZGUsXG4gICAgICAgICAgICAgICAgcHJvamVjdGlvbk9wdGlvbnMsXG4gICAgICAgICAgICAgICAgdm5vZGUudm5vZGVTZWxlY3RvcixcbiAgICAgICAgICAgICAgICB2bm9kZS5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY3JlYXRlRG9tID0gZnVuY3Rpb24gKHZub2RlLCBwYXJlbnROb2RlLCBpbnNlcnRCZWZvcmUsIHByb2plY3Rpb25PcHRpb25zKSB7XG4gICAgICAgIHZhciBkb21Ob2RlLCBpLCBjLCBzdGFydCA9IDAsIHR5cGUsIGZvdW5kO1xuICAgICAgICB2YXIgdm5vZGVTZWxlY3RvciA9IHZub2RlLnZub2RlU2VsZWN0b3I7XG4gICAgICAgIHZhciBkb2MgPSBwYXJlbnROb2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGlmICh2bm9kZVNlbGVjdG9yID09PSAnJykge1xuICAgICAgICAgICAgZG9tTm9kZSA9IHZub2RlLmRvbU5vZGUgPSBkb2MuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICAgICAgICBpZiAoaW5zZXJ0QmVmb3JlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShkb21Ob2RlLCBpbnNlcnRCZWZvcmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKGRvbU5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8PSB2bm9kZVNlbGVjdG9yLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgYyA9IHZub2RlU2VsZWN0b3IuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSB2bm9kZVNlbGVjdG9yLmxlbmd0aCB8fCBjID09PSAnLicgfHwgYyA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSB2bm9kZVNlbGVjdG9yLmNoYXJBdChzdGFydCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHZub2RlU2VsZWN0b3Iuc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLmNsYXNzTGlzdC5hZGQoZm91bmQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICcjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5pZCA9IGZvdW5kO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kID09PSAnc3ZnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3Rpb25PcHRpb25zID0gZXh0ZW5kKHByb2plY3Rpb25PcHRpb25zLCB7IG5hbWVzcGFjZTogTkFNRVNQQUNFX1NWRyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9qZWN0aW9uT3B0aW9ucy5uYW1lc3BhY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGUgPSB2bm9kZS5kb21Ob2RlID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhwcm9qZWN0aW9uT3B0aW9ucy5uYW1lc3BhY2UsIGZvdW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZSA9IHZub2RlLmRvbU5vZGUgPSB2bm9kZS5kb21Ob2RlIHx8IGRvYy5jcmVhdGVFbGVtZW50KGZvdW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQgPT09ICdpbnB1dCcgJiYgdm5vZGUucHJvcGVydGllcyAmJiB2bm9kZS5wcm9wZXJ0aWVzLnR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJRTggYW5kIG9sZGVyIGRvbid0IHN1cHBvcnQgc2V0dGluZyBpbnB1dCB0eXBlIGFmdGVyIHRoZSBET00gTm9kZSBoYXMgYmVlbiBhZGRlZCB0byB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCB2bm9kZS5wcm9wZXJ0aWVzLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnNlcnRCZWZvcmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGRvbU5vZGUsIGluc2VydEJlZm9yZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRvbU5vZGUucGFyZW50Tm9kZSAhPT0gcGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoZG9tTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbml0UHJvcGVydGllc0FuZENoaWxkcmVuKGRvbU5vZGUsIHZub2RlLCBwcm9qZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHVwZGF0ZURvbSA9IGZ1bmN0aW9uIChwcmV2aW91cywgdm5vZGUsIHByb2plY3Rpb25PcHRpb25zKSB7XG4gICAgICAgIHZhciBkb21Ob2RlID0gcHJldmlvdXMuZG9tTm9kZTtcbiAgICAgICAgdmFyIHRleHRVcGRhdGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChwcmV2aW91cyA9PT0gdm5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgICAgLy8gQnkgY29udHJhY3QsIFZOb2RlIG9iamVjdHMgbWF5IG5vdCBiZSBtb2RpZmllZCBhbnltb3JlIGFmdGVyIHBhc3NpbmcgdGhlbSB0byBtYXF1ZXR0ZVxuICAgICAgICB9XG4gICAgICAgIHZhciB1cGRhdGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh2bm9kZS52bm9kZVNlbGVjdG9yID09PSAnJykge1xuICAgICAgICAgICAgaWYgKHZub2RlLnRleHQgIT09IHByZXZpb3VzLnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Vk5vZGUgPSBkb21Ob2RlLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICAgICAgICAgICAgZG9tTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdWTm9kZSwgZG9tTm9kZSk7XG4gICAgICAgICAgICAgICAgdm5vZGUuZG9tTm9kZSA9IG5ld1ZOb2RlO1xuICAgICAgICAgICAgICAgIHRleHRVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dFVwZGF0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodm5vZGUudm5vZGVTZWxlY3Rvci5sYXN0SW5kZXhPZignc3ZnJywgMCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0aW9uT3B0aW9ucyA9IGV4dGVuZChwcm9qZWN0aW9uT3B0aW9ucywgeyBuYW1lc3BhY2U6IE5BTUVTUEFDRV9TVkcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldmlvdXMudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh2bm9kZS50ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5yZW1vdmVDaGlsZChkb21Ob2RlLmZpcnN0Q2hpbGQpOyAgICAvLyB0aGUgb25seSB0ZXh0bm9kZSBwcmVzdW1hYmx5XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS50ZXh0Q29udGVudCA9IHZub2RlLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlZCA9IHVwZGF0ZUNoaWxkcmVuKHZub2RlLCBkb21Ob2RlLCBwcmV2aW91cy5jaGlsZHJlbiwgdm5vZGUuY2hpbGRyZW4sIHByb2plY3Rpb25PcHRpb25zKSB8fCB1cGRhdGVkO1xuICAgICAgICAgICAgdXBkYXRlZCA9IHVwZGF0ZVByb3BlcnRpZXMoZG9tTm9kZSwgcHJldmlvdXMucHJvcGVydGllcywgdm5vZGUucHJvcGVydGllcywgcHJvamVjdGlvbk9wdGlvbnMpIHx8IHVwZGF0ZWQ7XG4gICAgICAgICAgICBpZiAodm5vZGUucHJvcGVydGllcyAmJiB2bm9kZS5wcm9wZXJ0aWVzLmFmdGVyVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUucHJvcGVydGllcy5hZnRlclVwZGF0ZS5hcHBseSh2bm9kZS5wcm9wZXJ0aWVzLmJpbmQgfHwgdm5vZGUucHJvcGVydGllcywgW1xuICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLFxuICAgICAgICAgICAgICAgICAgICBwcm9qZWN0aW9uT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUudm5vZGVTZWxlY3RvcixcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUucHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUuY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlZCAmJiB2bm9kZS5wcm9wZXJ0aWVzICYmIHZub2RlLnByb3BlcnRpZXMudXBkYXRlQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB2bm9kZS5wcm9wZXJ0aWVzLnVwZGF0ZUFuaW1hdGlvbihkb21Ob2RlLCB2bm9kZS5wcm9wZXJ0aWVzLCBwcmV2aW91cy5wcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICB2bm9kZS5kb21Ob2RlID0gcHJldmlvdXMuZG9tTm9kZTtcbiAgICAgICAgcmV0dXJuIHRleHRVcGRhdGVkO1xuICAgIH07XG4gICAgdmFyIGNyZWF0ZVByb2plY3Rpb24gPSBmdW5jdGlvbiAodm5vZGUsIHByb2plY3Rpb25PcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICh1cGRhdGVkVm5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodm5vZGUudm5vZGVTZWxlY3RvciAhPT0gdXBkYXRlZFZub2RlLnZub2RlU2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VsZWN0b3IgZm9yIHRoZSByb290IFZOb2RlIG1heSBub3QgYmUgY2hhbmdlZC4gKGNvbnNpZGVyIHVzaW5nIGRvbS5tZXJnZSBhbmQgYWRkIG9uZSBleHRyYSBsZXZlbCB0byB0aGUgdmlydHVhbCBET00pJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZURvbSh2bm9kZSwgdXBkYXRlZFZub2RlLCBwcm9qZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdm5vZGUgPSB1cGRhdGVkVm5vZGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9tTm9kZTogdm5vZGUuZG9tTm9kZVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLy8gVGhlIG90aGVyIHR3byBwYXJhbWV0ZXJzIGFyZSBub3QgYWRkZWQgaGVyZSwgYmVjYXVzZSB0aGUgVHlwZXNjcmlwdCBjb21waWxlciBjcmVhdGVzIHN1cnJvZ2F0ZSBjb2RlIGZvciBkZXN0cnVjdHVyaW5nICdjaGlsZHJlbicuXG4gICAgZXhwb3J0cy5oID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoaWxkSW5kZXggPSAxO1xuICAgICAgICBpZiAocHJvcGVydGllcyAmJiAhcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSgndm5vZGVTZWxlY3RvcicpICYmICFBcnJheS5pc0FycmF5KHByb3BlcnRpZXMpICYmIHR5cGVvZiBwcm9wZXJ0aWVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY2hpbGRJbmRleCA9IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPcHRpb25hbCBwcm9wZXJ0aWVzIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXh0O1xuICAgICAgICB2YXIgY2hpbGRyZW47XG4gICAgICAgIHZhciBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgLy8gUmVjb2duaXplIGEgY29tbW9uIHNwZWNpYWwgY2FzZSB3aGVyZSB0aGVyZSBpcyBvbmx5IGEgc2luZ2xlIHRleHQgbm9kZVxuICAgICAgICBpZiAoYXJnc0xlbmd0aCA9PT0gY2hpbGRJbmRleCArIDEpIHtcbiAgICAgICAgICAgIHZhciBvbmx5Q2hpbGQgPSBhcmd1bWVudHNbY2hpbGRJbmRleF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9ubHlDaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gb25seUNoaWxkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvbmx5Q2hpbGQgIT09IHVuZGVmaW5lZCAmJiBvbmx5Q2hpbGQgIT09IG51bGwgJiYgb25seUNoaWxkLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2Ygb25seUNoaWxkWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRleHQgPSBvbmx5Q2hpbGRbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIGZvciAoOyBjaGlsZEluZGV4IDwgYXJnc0xlbmd0aDsgY2hpbGRJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gYXJndW1lbnRzW2NoaWxkSW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZCA9PT0gbnVsbCB8fCBjaGlsZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBhcHBlbmRDaGlsZHJlbihzZWxlY3RvciwgY2hpbGQsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkLmhhc093blByb3BlcnR5KCd2bm9kZVNlbGVjdG9yJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0b1RleHRWTm9kZShjaGlsZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdm5vZGVTZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICAgICAgdGV4dDogdGV4dCA9PT0gJycgPyB1bmRlZmluZWQgOiB0ZXh0LFxuICAgICAgICAgICAgZG9tTm9kZTogbnVsbFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gKiBDb250YWlucyBzaW1wbGUgbG93LWxldmVsIHV0aWxpdHkgZnVuY3Rpb25zIHRvIG1hbmlwdWxhdGUgdGhlIHJlYWwgRE9NLlxuICovXG4gICAgZXhwb3J0cy5kb20gPSB7XG4gICAgICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByZWFsIERPTSB0cmVlIGZyb20gYHZub2RlYC4gVGhlIFtbUHJvamVjdGlvbl1dIG9iamVjdCByZXR1cm5lZCB3aWxsIGNvbnRhaW4gdGhlIHJlc3VsdGluZyBET00gTm9kZSBpblxuICAgICAqIGl0cyBbW1Byb2plY3Rpb24uZG9tTm9kZXxkb21Ob2RlXV0gcHJvcGVydHkuXG4gICAgICogVGhpcyBpcyBhIGxvdy1sZXZlbCBtZXRob2QuIFVzZXJzIHdpbGwgdHlwaWNhbGx5IHVzZSBhIFtbUHJvamVjdG9yXV0gaW5zdGVhZC5cbiAgICAgKiBAcGFyYW0gdm5vZGUgLSBUaGUgcm9vdCBvZiB0aGUgdmlydHVhbCBET00gdHJlZSB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBbW2hdXSBmdW5jdGlvbi4gTk9URTogW1tWTm9kZV1dXG4gICAgICogb2JqZWN0cyBtYXkgb25seSBiZSByZW5kZXJlZCBvbmNlLlxuICAgICAqIEBwYXJhbSBwcm9qZWN0aW9uT3B0aW9ucyAtIE9wdGlvbnMgdG8gYmUgdXNlZCB0byBjcmVhdGUgYW5kIHVwZGF0ZSB0aGUgcHJvamVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgW1tQcm9qZWN0aW9uXV0gd2hpY2ggYWxzbyBjb250YWlucyB0aGUgRE9NIE5vZGUgdGhhdCB3YXMgY3JlYXRlZC5cbiAgICAgKi9cbiAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAodm5vZGUsIHByb2plY3Rpb25PcHRpb25zKSB7XG4gICAgICAgICAgICBwcm9qZWN0aW9uT3B0aW9ucyA9IGFwcGx5RGVmYXVsdFByb2plY3Rpb25PcHRpb25zKHByb2plY3Rpb25PcHRpb25zKTtcbiAgICAgICAgICAgIGNyZWF0ZURvbSh2bm9kZSwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIHVuZGVmaW5lZCwgcHJvamVjdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVByb2plY3Rpb24odm5vZGUsIHByb2plY3Rpb25PcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICogQXBwZW5kcyBhIG5ldyBjaGlsZCBub2RlIHRvIHRoZSBET00gd2hpY2ggaXMgZ2VuZXJhdGVkIGZyb20gYSBbW1ZOb2RlXV0uXG4gICAgICogVGhpcyBpcyBhIGxvdy1sZXZlbCBtZXRob2QuIFVzZXJzIHdpbGwgdHlwaWNhbGx5IHVzZSBhIFtbUHJvamVjdG9yXV0gaW5zdGVhZC5cbiAgICAgKiBAcGFyYW0gcGFyZW50Tm9kZSAtIFRoZSBwYXJlbnQgbm9kZSBmb3IgdGhlIG5ldyBjaGlsZCBub2RlLlxuICAgICAqIEBwYXJhbSB2bm9kZSAtIFRoZSByb290IG9mIHRoZSB2aXJ0dWFsIERPTSB0cmVlIHRoYXQgd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIFtbaF1dIGZ1bmN0aW9uLiBOT1RFOiBbW1ZOb2RlXV1cbiAgICAgKiBvYmplY3RzIG1heSBvbmx5IGJlIHJlbmRlcmVkIG9uY2UuXG4gICAgICogQHBhcmFtIHByb2plY3Rpb25PcHRpb25zIC0gT3B0aW9ucyB0byBiZSB1c2VkIHRvIGNyZWF0ZSBhbmQgdXBkYXRlIHRoZSBbW1Byb2plY3Rpb25dXS5cbiAgICAgKiBAcmV0dXJucyBUaGUgW1tQcm9qZWN0aW9uXV0gdGhhdCB3YXMgY3JlYXRlZC5cbiAgICAgKi9cbiAgICAgICAgYXBwZW5kOiBmdW5jdGlvbiAocGFyZW50Tm9kZSwgdm5vZGUsIHByb2plY3Rpb25PcHRpb25zKSB7XG4gICAgICAgICAgICBwcm9qZWN0aW9uT3B0aW9ucyA9IGFwcGx5RGVmYXVsdFByb2plY3Rpb25PcHRpb25zKHByb2plY3Rpb25PcHRpb25zKTtcbiAgICAgICAgICAgIGNyZWF0ZURvbSh2bm9kZSwgcGFyZW50Tm9kZSwgdW5kZWZpbmVkLCBwcm9qZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJvamVjdGlvbih2bm9kZSwgcHJvamVjdGlvbk9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgbmV3IERPTSBub2RlIHdoaWNoIGlzIGdlbmVyYXRlZCBmcm9tIGEgW1tWTm9kZV1dLlxuICAgICAqIFRoaXMgaXMgYSBsb3ctbGV2ZWwgbWV0aG9kLiBVc2VycyB3aWwgdHlwaWNhbGx5IHVzZSBhIFtbUHJvamVjdG9yXV0gaW5zdGVhZC5cbiAgICAgKiBAcGFyYW0gYmVmb3JlTm9kZSAtIFRoZSBub2RlIHRoYXQgdGhlIERPTSBOb2RlIGlzIGluc2VydGVkIGJlZm9yZS5cbiAgICAgKiBAcGFyYW0gdm5vZGUgLSBUaGUgcm9vdCBvZiB0aGUgdmlydHVhbCBET00gdHJlZSB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBbW2hdXSBmdW5jdGlvbi5cbiAgICAgKiBOT1RFOiBbW1ZOb2RlXV0gb2JqZWN0cyBtYXkgb25seSBiZSByZW5kZXJlZCBvbmNlLlxuICAgICAqIEBwYXJhbSBwcm9qZWN0aW9uT3B0aW9ucyAtIE9wdGlvbnMgdG8gYmUgdXNlZCB0byBjcmVhdGUgYW5kIHVwZGF0ZSB0aGUgcHJvamVjdGlvbiwgc2VlIFtbY3JlYXRlUHJvamVjdG9yXV0uXG4gICAgICogQHJldHVybnMgVGhlIFtbUHJvamVjdGlvbl1dIHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAgICovXG4gICAgICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24gKGJlZm9yZU5vZGUsIHZub2RlLCBwcm9qZWN0aW9uT3B0aW9ucykge1xuICAgICAgICAgICAgcHJvamVjdGlvbk9wdGlvbnMgPSBhcHBseURlZmF1bHRQcm9qZWN0aW9uT3B0aW9ucyhwcm9qZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICBjcmVhdGVEb20odm5vZGUsIGJlZm9yZU5vZGUucGFyZW50Tm9kZSwgYmVmb3JlTm9kZSwgcHJvamVjdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVByb2plY3Rpb24odm5vZGUsIHByb2plY3Rpb25PcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICogTWVyZ2VzIGEgbmV3IERPTSBub2RlIHdoaWNoIGlzIGdlbmVyYXRlZCBmcm9tIGEgW1tWTm9kZV1dIHdpdGggYW4gZXhpc3RpbmcgRE9NIE5vZGUuXG4gICAgICogVGhpcyBtZWFucyB0aGF0IHRoZSB2aXJ0dWFsIERPTSBhbmQgdGhlIHJlYWwgRE9NIHdpbGwgaGF2ZSBvbmUgb3ZlcmxhcHBpbmcgZWxlbWVudC5cbiAgICAgKiBUaGVyZWZvcmUgdGhlIHNlbGVjdG9yIGZvciB0aGUgcm9vdCBbW1ZOb2RlXV0gd2lsbCBiZSBpZ25vcmVkLCBidXQgaXRzIHByb3BlcnRpZXMgYW5kIGNoaWxkcmVuIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgRWxlbWVudCBwcm92aWRlZC5cbiAgICAgKiBUaGlzIGlzIGEgbG93LWxldmVsIG1ldGhvZC4gVXNlcnMgd2lsIHR5cGljYWxseSB1c2UgYSBbW1Byb2plY3Rvcl1dIGluc3RlYWQuXG4gICAgICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZXhpc3RpbmcgZWxlbWVudCB0byBhZG9wdCBhcyB0aGUgcm9vdCBvZiB0aGUgbmV3IHZpcnR1YWwgRE9NLiBFeGlzdGluZyBhdHRyaWJ1dGVzIGFuZCBjaGlsZCBub2RlcyBhcmUgcHJlc2VydmVkLlxuICAgICAqIEBwYXJhbSB2bm9kZSAtIFRoZSByb290IG9mIHRoZSB2aXJ0dWFsIERPTSB0cmVlIHRoYXQgd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIFtbaF1dIGZ1bmN0aW9uLiBOT1RFOiBbW1ZOb2RlXV0gb2JqZWN0c1xuICAgICAqIG1heSBvbmx5IGJlIHJlbmRlcmVkIG9uY2UuXG4gICAgICogQHBhcmFtIHByb2plY3Rpb25PcHRpb25zIC0gT3B0aW9ucyB0byBiZSB1c2VkIHRvIGNyZWF0ZSBhbmQgdXBkYXRlIHRoZSBwcm9qZWN0aW9uLCBzZWUgW1tjcmVhdGVQcm9qZWN0b3JdXS5cbiAgICAgKiBAcmV0dXJucyBUaGUgW1tQcm9qZWN0aW9uXV0gdGhhdCB3YXMgY3JlYXRlZC5cbiAgICAgKi9cbiAgICAgICAgbWVyZ2U6IGZ1bmN0aW9uIChlbGVtZW50LCB2bm9kZSwgcHJvamVjdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgICAgIHByb2plY3Rpb25PcHRpb25zID0gYXBwbHlEZWZhdWx0UHJvamVjdGlvbk9wdGlvbnMocHJvamVjdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgdm5vZGUuZG9tTm9kZSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICBpbml0UHJvcGVydGllc0FuZENoaWxkcmVuKGVsZW1lbnQsIHZub2RlLCBwcm9qZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJvamVjdGlvbih2bm9kZSwgcHJvamVjdGlvbk9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbiBleGlzdGluZyBET00gbm9kZSB3aXRoIGEgbm9kZSBnZW5lcmF0ZWQgZnJvbSBhIFtbVk5vZGVdXS5cbiAgICAgKiBUaGlzIGlzIGEgbG93LWxldmVsIG1ldGhvZC4gVXNlcnMgd2lsbCB0eXBpY2FsbHkgdXNlIGEgW1tQcm9qZWN0b3JdXSBpbnN0ZWFkLlxuICAgICAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIG5vZGUgZm9yIHRoZSBbW1ZOb2RlXV0gdG8gcmVwbGFjZS5cbiAgICAgKiBAcGFyYW0gdm5vZGUgLSBUaGUgcm9vdCBvZiB0aGUgdmlydHVhbCBET00gdHJlZSB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBbW2hdXSBmdW5jdGlvbi4gTk9URTogW1tWTm9kZV1dXG4gICAgICogb2JqZWN0cyBtYXkgb25seSBiZSByZW5kZXJlZCBvbmNlLlxuICAgICAqIEBwYXJhbSBwcm9qZWN0aW9uT3B0aW9ucyAtIE9wdGlvbnMgdG8gYmUgdXNlZCB0byBjcmVhdGUgYW5kIHVwZGF0ZSB0aGUgW1tQcm9qZWN0aW9uXV0uXG4gICAgICogQHJldHVybnMgVGhlIFtbUHJvamVjdGlvbl1dIHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAgICovXG4gICAgICAgIHJlcGxhY2U6IGZ1bmN0aW9uIChlbGVtZW50LCB2bm9kZSwgcHJvamVjdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgICAgIHByb2plY3Rpb25PcHRpb25zID0gYXBwbHlEZWZhdWx0UHJvamVjdGlvbk9wdGlvbnMocHJvamVjdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgY3JlYXRlRG9tKHZub2RlLCBlbGVtZW50LnBhcmVudE5vZGUsIGVsZW1lbnQsIHByb2plY3Rpb25PcHRpb25zKTtcbiAgICAgICAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVQcm9qZWN0aW9uKHZub2RlLCBwcm9qZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICogQ3JlYXRlcyBhIFtbQ2FsY3VsYXRpb25DYWNoZV1dIG9iamVjdCwgdXNlZnVsIGZvciBjYWNoaW5nIFtbVk5vZGVdXSB0cmVlcy5cbiAqIEluIHByYWN0aWNlLCBjYWNoaW5nIG9mIFtbVk5vZGVdXSB0cmVlcyBpcyBub3QgbmVlZGVkLCBiZWNhdXNlIGFjaGlldmluZyA2MCBmcmFtZXMgcGVyIHNlY29uZCBpcyBhbG1vc3QgbmV2ZXIgYSBwcm9ibGVtLlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSBbW0NhbGN1bGF0aW9uQ2FjaGVdXS5cbiAqXG4gKiBAcGFyYW0gPFJlc3VsdD4gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRoYXQgaXMgY2FjaGVkLlxuICovXG4gICAgZXhwb3J0cy5jcmVhdGVDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhY2hlZElucHV0cztcbiAgICAgICAgdmFyIGNhY2hlZE91dGNvbWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkT3V0Y29tZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjYWNoZWRJbnB1dHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzdWx0OiBmdW5jdGlvbiAoaW5wdXRzLCBjYWxjdWxhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRJbnB1dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWRJbnB1dHNbaV0gIT09IGlucHV0c1tpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlZE91dGNvbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZWRPdXRjb21lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZE91dGNvbWUgPSBjYWxjdWxhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWRJbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPdXRjb21lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIE1hcHBpbmd9IGluc3RhbmNlIHRoYXQga2VlcHMgYW4gYXJyYXkgb2YgcmVzdWx0IG9iamVjdHMgc3luY2hyb25pemVkIHdpdGggYW4gYXJyYXkgb2Ygc291cmNlIG9iamVjdHMuXG4gKiBTZWUge0BsaW5rIGh0dHA6Ly9tYXF1ZXR0ZWpzLm9yZy9kb2NzL2FycmF5cy5odG1sfFdvcmtpbmcgd2l0aCBhcnJheXN9LlxuICpcbiAqIEBwYXJhbSA8U291cmNlPiAgICAgICBUaGUgdHlwZSBvZiBzb3VyY2UgaXRlbXMuIEEgZGF0YWJhc2UtcmVjb3JkIGZvciBpbnN0YW5jZS5cbiAqIEBwYXJhbSA8VGFyZ2V0PiAgICAgICBUaGUgdHlwZSBvZiB0YXJnZXQgaXRlbXMuIEEgW1tDb21wb25lbnRdXSBmb3IgaW5zdGFuY2UuXG4gKiBAcGFyYW0gZ2V0U291cmNlS2V5ICAgYGZ1bmN0aW9uKHNvdXJjZSlgIHRoYXQgbXVzdCByZXR1cm4gYSBrZXkgdG8gaWRlbnRpZnkgZWFjaCBzb3VyY2Ugb2JqZWN0LiBUaGUgcmVzdWx0IG11c3QgZWl0aGVyIGJlIGEgc3RyaW5nIG9yIGEgbnVtYmVyLlxuICogQHBhcmFtIGNyZWF0ZVJlc3VsdCAgIGBmdW5jdGlvbihzb3VyY2UsIGluZGV4KWAgdGhhdCBtdXN0IGNyZWF0ZSBhIG5ldyByZXN1bHQgb2JqZWN0IGZyb20gYSBnaXZlbiBzb3VyY2UuIFRoaXMgZnVuY3Rpb24gaXMgaWRlbnRpY2FsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgdG8gdGhlIGBjYWxsYmFja2AgYXJndW1lbnQgaW4gYEFycmF5Lm1hcChjYWxsYmFjaylgLlxuICogQHBhcmFtIHVwZGF0ZVJlc3VsdCAgIGBmdW5jdGlvbihzb3VyY2UsIHRhcmdldCwgaW5kZXgpYCB0aGF0IHVwZGF0ZXMgYSByZXN1bHQgdG8gYW4gdXBkYXRlZCBzb3VyY2UuXG4gKi9cbiAgICBleHBvcnRzLmNyZWF0ZU1hcHBpbmcgPSBmdW5jdGlvbiAoZ2V0U291cmNlS2V5LCBjcmVhdGVSZXN1bHQsIHVwZGF0ZVJlc3VsdCkge1xuICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0czogcmVzdWx0cyxcbiAgICAgICAgICAgIG1hcDogZnVuY3Rpb24gKG5ld1NvdXJjZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3S2V5cyA9IG5ld1NvdXJjZXMubWFwKGdldFNvdXJjZUtleSk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFRhcmdldHMgPSByZXN1bHRzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1NvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IG5ld1NvdXJjZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VLZXkgPSBuZXdLZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlS2V5ID09PSBrZXlzW29sZEluZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IG9sZFRhcmdldHNbb2xkSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVzdWx0KHNvdXJjZSwgb2xkVGFyZ2V0c1tvbGRJbmRleF0sIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBrZXlzLmxlbmd0aCArIDE7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWFyY2hJbmRleCA9IChvbGRJbmRleCArIGopICUga2V5cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleXNbc2VhcmNoSW5kZXhdID09PSBzb3VyY2VLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IG9sZFRhcmdldHNbc2VhcmNoSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHQobmV3U291cmNlc1tpXSwgb2xkVGFyZ2V0c1tzZWFyY2hJbmRleF0sIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRJbmRleCA9IHNlYXJjaEluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IGNyZWF0ZVJlc3VsdChzb3VyY2UsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMubGVuZ3RoID0gbmV3U291cmNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAga2V5cyA9IG5ld0tleXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAqIENyZWF0ZXMgYSBbW1Byb2plY3Rvcl1dIGluc3RhbmNlIHVzaW5nIHRoZSBwcm92aWRlZCBwcm9qZWN0aW9uT3B0aW9ucy5cbiAqXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIFtbUHJvamVjdG9yXV0uXG4gKlxuICogQHBhcmFtIHByb2plY3Rvck9wdGlvbnMgICBPcHRpb25zIHRoYXQgaW5mbHVlbmNlIGhvdyB0aGUgRE9NIGlzIHJlbmRlcmVkIGFuZCB1cGRhdGVkLlxuICovXG4gICAgZXhwb3J0cy5jcmVhdGVQcm9qZWN0b3IgPSBmdW5jdGlvbiAocHJvamVjdG9yT3B0aW9ucykge1xuICAgICAgICB2YXIgcHJvamVjdG9yO1xuICAgICAgICB2YXIgcHJvamVjdGlvbk9wdGlvbnMgPSBhcHBseURlZmF1bHRQcm9qZWN0aW9uT3B0aW9ucyhwcm9qZWN0b3JPcHRpb25zKTtcbiAgICAgICAgcHJvamVjdGlvbk9wdGlvbnMuZXZlbnRIYW5kbGVySW50ZXJjZXB0b3IgPSBmdW5jdGlvbiAocHJvcGVydHlOYW1lLCBldmVudEhhbmRsZXIsIGRvbU5vZGUsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gaW50ZXJjZXB0IGZ1bmN0aW9uIGNhbGxzIChldmVudCBoYW5kbGVycykgdG8gZG8gYSByZW5kZXIgYWZ0ZXJ3YXJkcy5cbiAgICAgICAgICAgICAgICBwcm9qZWN0b3Iuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnRIYW5kbGVyLmFwcGx5KHByb3BlcnRpZXMuYmluZCB8fCB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlbmRlckNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIHZhciBzY2hlZHVsZWQ7XG4gICAgICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBwcm9qZWN0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgcmVuZGVyRnVuY3Rpb25zID0gW107XG4gICAgICAgIC8vIG1hdGNoZXMgdGhlIHByb2plY3Rpb25zIGFycmF5XG4gICAgICAgIHZhciBkb1JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICghcmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAgICAvLyBUaGUgbGFzdCByZW5kZXIgdGhyZXcgYW4gZXJyb3IsIGl0IHNob3VsZCBiZSBsb2dnZWQgaW4gdGhlIGJyb3dzZXIgY29uc29sZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbmRlckNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9qZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVkVm5vZGUgPSByZW5kZXJGdW5jdGlvbnNbaV0oKTtcbiAgICAgICAgICAgICAgICBwcm9qZWN0aW9uc1tpXS51cGRhdGUodXBkYXRlZFZub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbmRlckNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHByb2plY3RvciA9IHtcbiAgICAgICAgICAgIHJlbmRlck5vdzogZG9SZW5kZXIsXG4gICAgICAgICAgICBzY2hlZHVsZVJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghc2NoZWR1bGVkICYmICFzdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShkb1JlbmRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZWR1bGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHNjaGVkdWxlZCk7XG4gICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlbmRlckNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJvamVjdG9yLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXBwZW5kOiBmdW5jdGlvbiAocGFyZW50Tm9kZSwgcmVuZGVyTWFxdWV0dGVGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHByb2plY3Rpb25zLnB1c2goZXhwb3J0cy5kb20uYXBwZW5kKHBhcmVudE5vZGUsIHJlbmRlck1hcXVldHRlRnVuY3Rpb24oKSwgcHJvamVjdGlvbk9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICByZW5kZXJGdW5jdGlvbnMucHVzaChyZW5kZXJNYXF1ZXR0ZUZ1bmN0aW9uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIChiZWZvcmVOb2RlLCByZW5kZXJNYXF1ZXR0ZUZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdGlvbnMucHVzaChleHBvcnRzLmRvbS5pbnNlcnRCZWZvcmUoYmVmb3JlTm9kZSwgcmVuZGVyTWFxdWV0dGVGdW5jdGlvbigpLCBwcm9qZWN0aW9uT3B0aW9ucykpO1xuICAgICAgICAgICAgICAgIHJlbmRlckZ1bmN0aW9ucy5wdXNoKHJlbmRlck1hcXVldHRlRnVuY3Rpb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lcmdlOiBmdW5jdGlvbiAoZG9tTm9kZSwgcmVuZGVyTWFxdWV0dGVGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHByb2plY3Rpb25zLnB1c2goZXhwb3J0cy5kb20ubWVyZ2UoZG9tTm9kZSwgcmVuZGVyTWFxdWV0dGVGdW5jdGlvbigpLCBwcm9qZWN0aW9uT3B0aW9ucykpO1xuICAgICAgICAgICAgICAgIHJlbmRlckZ1bmN0aW9ucy5wdXNoKHJlbmRlck1hcXVldHRlRnVuY3Rpb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcGxhY2U6IGZ1bmN0aW9uIChkb21Ob2RlLCByZW5kZXJNYXF1ZXR0ZUZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdGlvbnMucHVzaChleHBvcnRzLmRvbS5yZXBsYWNlKGRvbU5vZGUsIHJlbmRlck1hcXVldHRlRnVuY3Rpb24oKSwgcHJvamVjdGlvbk9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICByZW5kZXJGdW5jdGlvbnMucHVzaChyZW5kZXJNYXF1ZXR0ZUZ1bmN0aW9uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXRhY2g6IGZ1bmN0aW9uIChyZW5kZXJNYXF1ZXR0ZUZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW5kZXJGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbmRlckZ1bmN0aW9uc1tpXSA9PT0gcmVuZGVyTWFxdWV0dGVGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyRnVuY3Rpb25zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9qZWN0aW9ucy5zcGxpY2UoaSwgMSlbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZW5kZXJNYXF1ZXR0ZUZ1bmN0aW9uIHdhcyBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHByb2plY3RvcjtcbiAgICB9O1xufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFxdWV0dGUuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tYXF1ZXR0ZS9kaXN0L21hcXVldHRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCAqIGZyb20gXCIuLy4uL1R5cGV3cml0ZXIvQ2FsaWZvcm5pYUNvbnRyb2xsZXJcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vLi4vVHlwZXdyaXRlci9DYWxpZm9ybmlhRXZlbnRcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vLi4vVHlwZXdyaXRlci9DYWxpZm9ybmlhUHJvamVjdFwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi8uLi9UeXBld3JpdGVyL0NhbGlmb3JuaWFVc2VyRGVmYXVsdHNcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vLi4vVHlwZXdyaXRlci9DYWxpZm9ybmlhQ2xpZW50Vmlld01vZGVsXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuLy4uL1R5cGV3cml0ZXIvU3R5bGVNb2xlY3VsZVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi8uLi9UeXBld3JpdGVyL1N0eWxlUXVhbnR1bVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi8uLi9UeXBld3JpdGVyL1N0eWxlQXRvbVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi8uLi9UeXBld3JpdGVyL1N0eWxlQXRvbVR5cGVcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vLi4vVHlwZXdyaXRlci9TdHlsZVZhbHVlXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuLy4uL1R5cGV3cml0ZXIvUmVzcG9uc2l2ZURldmljZVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi8uLi9UeXBld3JpdGVyL0NhbGlmb3JuaWFWaWV3XCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuLy4uL1R5cGV3cml0ZXIvTGF5b3V0Um93XCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuLy4uL1R5cGV3cml0ZXIvTGF5b3V0Qm94XCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuLy4uL1R5cGV3cml0ZXIvTGF5b3V0QXRvbVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi8uLi9UeXBld3JpdGVyL1N0eWxlTW9sZWN1bGVBdG9tTWFwcGluZ1wiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi8uLi9UeXBld3JpdGVyL0NvbnRlbnRBdG9tXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuLy4uL1R5cGV3cml0ZXIvTGF5b3V0QmFzZVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi8uLi9UeXBld3JpdGVyL0xheW91dFR5cGVcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vLi4vVHlwZXdyaXRlci9TcGVjaWFsTGF5b3V0Qm94VHlwZVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi8uLi9UeXBld3JpdGVyL0xheW91dFN0eWxlSW50ZXJhY3Rpb25cIjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9Nb2RlbHMvQ2FsaWZvcm5pYUdlbmVyYXRlZC50cyIsIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9qc3gudHNcIiAvPlxyXG5cInVzZSBzdHJpY3RcIjtcclxuaW1wb3J0IHsgVk5vZGUgfSBmcm9tIFwibWFxdWV0dGVcIjtcclxuaW1wb3J0ICogYXMgbWFxdWV0dGUgZnJvbSBcIm1hcXVldHRlXCI7XHJcbmNvbnN0IGggPSBtYXF1ZXR0ZS5oO1xyXG5pbXBvcnQgeyBDYWxpZm9ybmlhQ29udHJvbGxlciwgQ2FsaWZvcm5pYUNsaWVudFZpZXdNb2RlbCwgQ2FsaWZvcm5pYUV2ZW50LCBDYWxpZm9ybmlhUHJvamVjdCB9IGZyb20gXCIuL0NhbGlmb3JuaWFHZW5lcmF0ZWRcIjtcclxuaW1wb3J0IHsgUGFnZVByZXZpZXcgfSBmcm9tIFwiLi9QYWdlUHJldmlld1wiO1xyXG5pbXBvcnQgeyBQYWdlUHJldmlld1ZNIH0gZnJvbSBcIi4vLi4vVmlld01vZGVscy9QYWdlUHJldmlld1ZNXCI7XHJcbmltcG9ydCB7IFByb3BlcnR5QmFyIH0gZnJvbSBcIi4vUHJvcGVydHlCYXJcIjtcclxuaW1wb3J0IHsgUHJvcGVydHlCYXJWTSwgUG9wdXBNb2RlIH0gZnJvbSBcIi4uL1ZpZXdNb2RlbHMvUHJvcGVydHlCYXJWTVwiO1xyXG5pbXBvcnQgeyBDYWxpZm9ybmlhUm91dGVyIH0gZnJvbSBcIi4vQ2FsaWZvcm5pYVJvdXRlclwiO1xyXG5pbXBvcnQgeyBDbGllbnRTdGF0ZSwgRWRpdFZpZXdNb2RlIH0gZnJvbSBcIi4vQ2xpZW50U3RhdGVcIjtcclxuaW1wb3J0IHsgQ2FsaWZvcm5pYUNsaWVudFBhcnRpYWxEYXRhIH0gZnJvbSBcIi4uL1R5cGV3cml0ZXIvQ2FsaWZvcm5pYUNsaWVudFBhcnRpYWxEYXRhXCI7XHJcblxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9FWENFUFRJT046IHN0cmluZyA9IFwidW5leHBlY3RlZCBlcnJvclwiOyAvLyBUT0RPIGNvdWxkIHJlZGlyZWN0L292ZXJsYXkgYW4gZXJyb3IgcGFnZSB3aXRoIGluc3RydWN0aW9uczogcmVsb2FkIHBhZ2UsIHdhaXQsIGNsZWFyIGhpc3RvcnksIGNsZWFyIGxvY2FsIHN0b3JhZ2UsIGNsZWFyIGNvb2tpZXMsIGV0Yy5cclxuZXhwb3J0IGNvbnN0IFVJX1pfSU5ERVg6IG51bWJlciA9IDExO1xyXG5jb25zdCBSRVNJWkVfSEFORExFUl9ERUxBWV9NUzogbnVtYmVyID0gMjAwO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEFycmF5Rm9yRW51bSh0YXJnZXRFbnVtOiBhbnkpOiBzdHJpbmdbXSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGFyZ2V0RW51bSkubWFwKGtleSA9PiB0YXJnZXRFbnVtW2tleSBhcyBhbnldKS5maWx0ZXIodmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSBhcyBzdHJpbmdbXTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUludEZyb21BdHRyaWJ1dGUoZWxlbWVudDogRXZlbnRUYXJnZXQgfCBudWxsLCBhdHRyaWJ1dGVOYW1lOiBzdHJpbmcpOiBudW1iZXIgeyAvLyBjYW4gdGhyb3dcclxuICAgIGlmIChlbGVtZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcImNhbm5vdCByZWFkIGF0dHJpYnV0ZTogZWxlbWVudCBpcyBudWxsXCIpO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETyBkaXNhYmxlIGRlYnVnIHZhcmlhbnRcclxuICAgIGxldCBhdHRyOiBBdHRyIHwgbnVsbCA9IChlbGVtZW50IGFzIEhUTUxFbGVtZW50KS5hdHRyaWJ1dGVzLmdldE5hbWVkSXRlbShhdHRyaWJ1dGVOYW1lKTtcclxuICAgIGlmIChhdHRyID09PSBudWxsKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJjb3VsZCBub3QgZmluZCBhdHRyaWJ1dGUgXCIgKyBhdHRyaWJ1dGVOYW1lICsgXCIgb24gdGFyZ2V0XCIpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGVsZW1lbnQpO1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGF0dHIudmFsdWUpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU3RyaW5nRnJvbUF0dHJpYnV0ZShlbGVtZW50OiBFdmVudFRhcmdldCB8IG51bGwsIGF0dHJpYnV0ZU5hbWU6IHN0cmluZyk6IHN0cmluZyB7IC8vIGNhbiB0aHJvd1xyXG4gICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiY2Fubm90IHJlYWQgYXR0cmlidXRlOiBlbGVtZW50IGlzIG51bGxcIik7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPIGRpc2FibGUgZGVidWcgdmFyaWFudFxyXG4gICAgbGV0IGF0dHI6IEF0dHIgfCBudWxsID0gKGVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpLmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKGF0dHJpYnV0ZU5hbWUpO1xyXG4gICAgaWYgKGF0dHIgPT09IG51bGwpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcImNvdWxkIG5vdCBmaW5kIGF0dHJpYnV0ZSBcIiArIGF0dHJpYnV0ZU5hbWUgKyBcIiBvbiB0YXJnZXRcIik7XHJcbiAgICAgICAgY29uc29sZS5sb2coZWxlbWVudCk7XHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gYXR0ci52YWx1ZTtcclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBDYWxpZm9ybmlhQXBwIHtcclxuICAgIC8vIHN0YXRpYyBodG1sIHJlZmVyZW5jZXNcclxuICAgIHB1YmxpYyBjYWxpZm9ybmlhTWFpbkRpdjogSFRNTEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhbGlmb3JuaWEtbWFpblwiKSBhcyBIVE1MRWxlbWVudDtcclxuICAgIHB1YmxpYyBzdHlsZVNoZWV0OiBDU1NTdHlsZVNoZWV0ID0gKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FsaWZvcm5pYS1zdHlsZXNcIikgYXMgSFRNTFN0eWxlRWxlbWVudCkuc2hlZXQgYXMgQ1NTU3R5bGVTaGVldDtcclxuICAgIC8vIHJlbmRlcmVkIHZkb20gcmVmZXJlbmNlc1xyXG4gICAgcHVibGljIHBhZ2VQcmV2aWV3SG9sZGVyOiBIVE1MRWxlbWVudCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuICAgIC8vIG1vZHVsZSBpbnN0YW5jZXNcclxuICAgIHB1YmxpYyBzdGF0aWMgQ2FsaWZvcm5pYUFwcEluc3RhbmNlOiBDYWxpZm9ybmlhQXBwO1xyXG4gICAgcHVibGljIHByb2plY3RvcjogbWFxdWV0dGUuUHJvamVjdG9yO1xyXG4gICAgcHVibGljIGNvbnRyb2xsZXI6IENhbGlmb3JuaWFDb250cm9sbGVyO1xyXG4gICAgcHVibGljIHJvdXRlcjogQ2FsaWZvcm5pYVJvdXRlcjtcclxuICAgIHB1YmxpYyBzdGF0ZTogQ2xpZW50U3RhdGU7XHJcbiAgICBwdWJsaWMgcGFnZVByZXZpZXc6IFBhZ2VQcmV2aWV3O1xyXG4gICAgcHVibGljIHBhZ2VQcmV2aWV3Vk06IFBhZ2VQcmV2aWV3Vk07XHJcbiAgICBwcml2YXRlIF9wcm9wZXJ0eUJhcnM6IFByb3BlcnR5QmFyW10gPSBbXTtcclxuICAgIHByaXZhdGUgX3Byb3BlcnR5QmFyVk1zOiBQcm9wZXJ0eUJhclZNW10gPSBbXTtcclxuICAgIHByaXZhdGUgX3Byb3BlcnR5QmFyQm94VHJlZURvbVJlZmVyZW5jZXM6IChIVE1MRGl2RWxlbWVudCB8IHVuZGVmaW5lZClbXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSBfcHJvcGVydHlCYXJCb3hUcmVlU2Nyb2xsSGFuZGxlZDogYm9vbGVhbltdID0gW107XHJcbiAgICBwdWJsaWMgaXNBamF4UmVxdWVzdFJ1bm5pbmc6IGJvb2xlYW4gPSBmYWxzZTsgLy8gVE9ETyBuZWVkIGEgdmFsdWUgdGhhdCBjb250YWlucyB1cGRhdGUgZGF0YSAoc28gdXNlciBjYW50IHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnZhbGlkIGRhdGEsIHdoaWNoIGlzIHRpbWUgYmV0d2VlbiByZXF1ZXN0IGZpbmlzaCBhbmQgdXBkYXRlIHJlZmVyZW5jZXMgKyByZW5kZXIpXHJcbiAgICAvLyBzbW9vdGggcmVzaXplIGhhbmRsZXJcclxuICAgIHB1YmxpYyByZXNpemVSdGltZTogRGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICBwdWJsaWMgcmVzaXplVGltZW91dDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgLy8gVUkgbGF5b3V0XHJcbiAgICBwdWJsaWMgbmF2aWdhdGlvbkhlaWd0aFB4OiBudW1iZXIgPSAzMjsvLyBUT0RPIDY0O1xyXG4gICAgcHVibGljIGNvbnRyb2xBcmVhV2lkdGhQeDogbnVtYmVyID0gNTAwO1xyXG4gICAgcHJpdmF0ZSBfcHJvcGVydHlCYXJDb3VudDogbnVtYmVyID0gNDsgLy8gZXhwZWN0ZWQgdG8gYmUgYXQgbGVhc3QgPiAwOyBhbHNvIGNvbXBhdGlibGUgd2l0aCB2aXNpYmxlUHJvcGVydHlCYXJDb3VudFxyXG5cclxuICAgIHB1YmxpYyBjbGllbnREYXRhOiBDYWxpZm9ybmlhQ2xpZW50Vmlld01vZGVsID0ge1xyXG4gICAgICAgIEN1cnJlbnRSZXZpc2lvbjogMCxcclxuICAgICAgICBTdGF0dXNUZXh0OiBcIlwiLFxyXG4gICAgICAgIENhbGlmb3JuaWFFdmVudDogQ2FsaWZvcm5pYUV2ZW50LlJlYWRJbml0aWFsQ2xpZW50RGF0YSxcclxuICAgICAgICBDYWxpZm9ybmlhUHJvamVjdDogbmV3IENhbGlmb3JuaWFQcm9qZWN0KCksXHJcbiAgICAgICAgQWxsQ3NzUHJvcGVydGllczogW10sXHJcbiAgICAgICAgU3R5bGVBdG9tQ3NzUHJvcGVydHlNYXBwaW5nOiB7fSxcclxuICAgICAgICBVcmxUb1JlYWRBbmRFZGl0OiBcIlwiLFxyXG4gICAgICAgIFVybFRvUmVhZE9ubHk6IFwiXCIsXHJcbiAgICAgICAgUGFydGlhbFVwZGF0ZTogbmV3IENhbGlmb3JuaWFDbGllbnRQYXJ0aWFsRGF0YSgpXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0b3IgPSBtYXF1ZXR0ZS5jcmVhdGVQcm9qZWN0b3IoKTtcclxuICAgICAgICAvL2lmIChNYXRoSmF4LkhUTUwuQ29va2llICE9PSB1bmRlZmluZWQpIHsgVE9ET1xyXG4gICAgICAgIHRoaXMucGFnZVByZXZpZXcgPSBuZXcgUGFnZVByZXZpZXcodGhpcyk7XHJcbiAgICAgICAgdGhpcy5wYWdlUHJldmlld1ZNID0gdGhpcy5wYWdlUHJldmlldy52aWV3TW9kZWw7XHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMucHJvcGVydHlCYXJDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eUJhciA9IG5ldyBQcm9wZXJ0eUJhcih0aGlzLCBpKTtcclxuICAgICAgICAgICAgdGhpcy5fcHJvcGVydHlCYXJzLnB1c2gocHJvcGVydHlCYXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eUJhclZNcy5wdXNoKHByb3BlcnR5QmFyLnZpZXdNb2RlbCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5QmFyQm94VHJlZURvbVJlZmVyZW5jZXMucHVzaCh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eUJhckJveFRyZWVTY3JvbGxIYW5kbGVkLnB1c2goZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgQ2FsaWZvcm5pYUNvbnRyb2xsZXIodGhpcyk7XHJcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSBuZXcgQ2FsaWZvcm5pYVJvdXRlcih0aGlzKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IENsaWVudFN0YXRlKHRoaXMpO1xyXG4gICAgICAgIC8vIGdldCBjbGllbnQgZGF0YSBUT0RPIHNlbmQgd2l0aCBpbml0aWFsIHBhZ2VcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuSW5pdGlhbENsaWVudERhdGFKc29uKG5ldyBEYXRlKCkudG9TdHJpbmcoKSlcclxuICAgICAgICAgICAgLmRvbmUoZnVuY3Rpb24gKGRhdGE6IGFueSk6IHZvaWQge1xyXG4gICAgICAgICAgICAgICAgQ2FsaWZvcm5pYUFwcC5DYWxpZm9ybmlhQXBwSW5zdGFuY2Uucm91dGVyLnVwZGF0ZURhdGEoZGF0YSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH0pLmZhaWwoZnVuY3Rpb24gKCk6IHZvaWQge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb3VsZCBub3QgZ2V0IGRhdGFcIik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGluaXRpYWxpemUgcHJvamVjdG9yIFxyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGZ1bmN0aW9uICgpOiB2b2lkIHtcclxuICAgICAgICAgICAgQ2FsaWZvcm5pYUFwcC5DYWxpZm9ybmlhQXBwSW5zdGFuY2UucHJvamVjdG9yLmFwcGVuZChDYWxpZm9ybmlhQXBwLkNhbGlmb3JuaWFBcHBJbnN0YW5jZS5jYWxpZm9ybmlhTWFpbkRpdiwgQ2FsaWZvcm5pYUFwcC5DYWxpZm9ybmlhQXBwSW5zdGFuY2UucmVuZGVyQ2FsaWZvcm5pYUFwcCk7IC8vIGNhbGlmb3JuaWFNYWluRGl2IGhhcyBoZWlnaHQ9MTAwJSBmb3IgaVBhZFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGZ1bmN0aW9uICgpOiB2b2lkIHtcclxuICAgICAgICAgICAgLy8gc21vb3RoIHJlc2l6ZVxyXG4gICAgICAgICAgICBDYWxpZm9ybmlhQXBwLkNhbGlmb3JuaWFBcHBJbnN0YW5jZS5yZXNpemVSdGltZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgIGlmIChDYWxpZm9ybmlhQXBwLkNhbGlmb3JuaWFBcHBJbnN0YW5jZS5yZXNpemVUaW1lb3V0ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgQ2FsaWZvcm5pYUFwcC5DYWxpZm9ybmlhQXBwSW5zdGFuY2UucmVzaXplVGltZW91dCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KENhbGlmb3JuaWFBcHAuQ2FsaWZvcm5pYUFwcEluc3RhbmNlLnJlc2l6ZUNoZWNrSGFuZGxlciwgUkVTSVpFX0hBTkRMRVJfREVMQVlfTVMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBnZXQgcHJvcGVydHlCYXJDb3VudCgpOiBudW1iZXIge1xyXG4gICAgICAgIC8vIGNvbnN0YW50XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnR5QmFyQ291bnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBnZXQgcHJvcGVydHlCYXJzKCk6IFByb3BlcnR5QmFyW10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9wZXJ0eUJhcnM7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBnZXQgcHJvcGVydHlCYXJWTXMoKTogUHJvcGVydHlCYXJWTVtdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydHlCYXJWTXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBnZXQgcHJvcGVydHlCYXJCb3hUcmVlRG9tUmVmZXJlbmNlcygpOiAoSFRNTERpdkVsZW1lbnR8dW5kZWZpbmVkKVtdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydHlCYXJCb3hUcmVlRG9tUmVmZXJlbmNlcztcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGdldCBwcm9wZXJ0eUJhckJveFRyZWVTY3JvbGxIYW5kbGVkKCk6IGJvb2xlYW5bXSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnR5QmFyQm94VHJlZVNjcm9sbEhhbmRsZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgcmVzaXplQ2hlY2tIYW5kbGVyID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGxldCBjdXJUaW1lOiBudW1iZXIgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGlmICgoY3VyVGltZSAtIENhbGlmb3JuaWFBcHAuQ2FsaWZvcm5pYUFwcEluc3RhbmNlLnJlc2l6ZVJ0aW1lLmdldE1pbGxpc2Vjb25kcygpKSA8IFJFU0laRV9IQU5ETEVSX0RFTEFZX01TKSB7Ly8gaWdub3JlIHJlc2l6ZSBldmVudFxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KENhbGlmb3JuaWFBcHAuQ2FsaWZvcm5pYUFwcEluc3RhbmNlLnJlc2l6ZUNoZWNrSGFuZGxlciwgUkVTSVpFX0hBTkRMRVJfREVMQVlfTVMpO1xyXG4gICAgICAgIH0gZWxzZSB7IC8vIERvbmUgcmVzaXppbmc7cmVzaXplZEJyb3dzZXJcclxuICAgICAgICAgICAgQ2FsaWZvcm5pYUFwcC5DYWxpZm9ybmlhQXBwSW5zdGFuY2UucmVzaXplQ2hhbmdlZEhhbmRsZXIoKTtcclxuICAgICAgICAgICAgQ2FsaWZvcm5pYUFwcC5DYWxpZm9ybmlhQXBwSW5zdGFuY2UucmVzaXplVGltZW91dCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlc2l6ZUNoYW5nZWRIYW5kbGVyID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIENhbGlmb3JuaWFBcHAuQ2FsaWZvcm5pYUFwcEluc3RhbmNlLnN0YXRlLm92ZXJyaWRlUmVzcG9uc2l2ZURldmljZUlkID0gMDtcclxuICAgICAgICBDYWxpZm9ybmlhQXBwLkNhbGlmb3JuaWFBcHBJbnN0YW5jZS5yb3V0ZXIuc2V0dXBVaUZvckRldmljZSgpOyAvLyBUT0RPIGNvc3RzIHRvbyBtdWNoIGVuZXJneSwgbWFrZSBpdCBhbHNvIG1hbnVhbGx5IGF2YWlsYWJsZVxyXG4gICAgICAgIENhbGlmb3JuaWFBcHAuQ2FsaWZvcm5pYUFwcEluc3RhbmNlLnByb2plY3Rvci5zY2hlZHVsZVJlbmRlcigpOyAvLyBUT0RPIG1pZ2h0IGJlIGNhbGxlZCB0b28gb2Z0ZW4gLy8gVE9ETyBkb2N1bWVudCByZW5kZXIgY2FsbHMgYnkgZnVuY3Rpb25cclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSByZW5kZXJDYWxpZm9ybmlhQXBwID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICBsZXQgYXBwU3R5bGVzID0ge1xyXG4gICAgICAgICAgICBcIndpZHRoXCI6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICBcIm1heC13aWR0aFwiOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgXCJoZWlnaHRcIjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgIFwibWF4LWhlaWdodFwiOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiZmxleFwiLFxyXG4gICAgICAgICAgICBcImZsZXgtZmxvd1wiOiBcInJvdyBub3dyYXBcIlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHJlbmRlcmVkUHJvcGVydHlCYXJzOiBWTm9kZVtdID0gW107IC8vIGVxdWFsbHkgc3BhY2VkLCBzZXBhcmF0ZSBvdmVyZmxvdzpzY3JvbGxcclxuICAgICAgICBsZXQgbWF4UmVuZGVyZWRQcm9wZXJ0eUJhckNvdW50OiBudW1iZXIgPSB0aGlzLnN0YXRlLnZpc2libGVQcm9wZXJ0eUJhck1heENvdW50ID4gdGhpcy5fcHJvcGVydHlCYXJDb3VudCA/IHRoaXMuX3Byb3BlcnR5QmFyQ291bnQgOiB0aGlzLnN0YXRlLnZpc2libGVQcm9wZXJ0eUJhck1heENvdW50XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhSZW5kZXJlZFByb3BlcnR5QmFyQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICByZW5kZXJlZFByb3BlcnR5QmFycy5wdXNoKHRoaXMuX3Byb3BlcnR5QmFyc1tpXS5yZW5kZXJQcm9wZXJ0eUJhcigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDxkaXYgc3R5bGVzPXthcHBTdHlsZXN9PlxyXG4gICAgICAgICAgICB7dGhpcy5wYWdlUHJldmlldy5yZW5kZXJQcmV2aWV3QXJlYSgpfVxyXG4gICAgICAgICAgICB7KHRoaXMuc3RhdGUuaXNIaWRlVXNlckludGVyZmFjZSB8fCB0aGlzLnN0YXRlLmVkaXRWaWV3TW9kZSA9PT0gRWRpdFZpZXdNb2RlLlBhZ2VQcmV2aWV3T25seSkgPyB1bmRlZmluZWQgOiByZW5kZXJlZFByb3BlcnR5QmFyc31cclxuICAgICAgICAgICAge3RoaXMuX3Byb3BlcnR5QmFyc1swXS5yZW5kZXJQcm9wZXJ0eUJhclBvcHBlcnNSZW5kZXJPbmNlKCl9XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vTW9kZWxzL0NhbGlmb3JuaWFBcHAudHN4IiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2pzeC50c1wiIC8+XHJcblwidXNlIHN0cmljdFwiO1xyXG5pbXBvcnQgeyBDYWxpZm9ybmlhQXBwLCBERUZBVUxUX0VYQ0VQVElPTiB9IGZyb20gXCIuL0NhbGlmb3JuaWFBcHBcIjtcclxuaW1wb3J0IHsgTGF5b3V0VHlwZSwgQ2FsaWZvcm5pYVZpZXcsIENhbGlmb3JuaWFFdmVudCB9IGZyb20gXCIuL0NhbGlmb3JuaWFHZW5lcmF0ZWRcIjtcclxuaW1wb3J0IHsgVHJhbnNhY3Rpb25Nb2RlIH0gZnJvbSBcIi4uL1ZpZXdNb2RlbHMvUHJvcGVydHlCYXJWTVwiO1xyXG5cclxubGV0IGN1cnJlbnRBcHA6IENhbGlmb3JuaWFBcHA7XHJcbmxldCBjdXJyZW50Q2xpZW50U3RhdGU6IENsaWVudFN0YXRlO1xyXG5cclxuZXhwb3J0IGNvbnN0IFNUQVRJQ19NQVJHSU5fUFg6IG51bWJlciA9IDI1O1xyXG5cclxuZXhwb3J0IGVudW0gU2VsZWN0aW9uTW9kZSB7XHJcbiAgICBTdHlsZXMgPSAwLFxyXG4gICAgQ29udGVudCA9IDEgICAgXHJcbn07XHJcblxyXG5leHBvcnQgZW51bSBSZWFkeVN0YXRlIHtcclxuICAgIE9rID0gMCxcclxuICAgIFBlbmRpbmcgPSAxXHJcbn07XHJcblxyXG5leHBvcnQgZW51bSBFZGl0Vmlld01vZGUge1xyXG4gICAgRGVmYXVsdCA9IDAsXHJcbiAgICBTaWRlYmFyT25seSA9IDEsXHJcbiAgICBQYWdlUHJldmlld09ubHkgPSAyXHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgQ2xpZW50U3RhdGUge1xyXG4gICAgcHVibGljIGlzRGF0YUxvYWRlZDogYm9vbGVhbiA9IGZhbHNlOyAvLyBUT0RPXHJcbiAgICBwdWJsaWMgaXNIaWRlVXNlckludGVyZmFjZTogYm9vbGVhbiA9IGZhbHNlOyAvLyBUT0RPXHJcbiAgICBwdWJsaWMgZWRpdFZpZXdNb2RlOiBFZGl0Vmlld01vZGUgPSBFZGl0Vmlld01vZGUuRGVmYXVsdDsgLy8gVE9ET1xyXG4gICAgcHVibGljIGN1cnJlbnRTZWxlY3Rpb25Nb2RlOiBTZWxlY3Rpb25Nb2RlID0gU2VsZWN0aW9uTW9kZS5Db250ZW50O1xyXG4gICAgcHVibGljIGN1cnJlbnRSZWFkeVN0YXRlOiBSZWFkeVN0YXRlID0gUmVhZHlTdGF0ZS5PazsgLy8gVE9ETyB1c2UgZXZlcnl3aGVyZVxyXG4gICAgcHVibGljIGlzSmF4T246IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIC8vIC0tLSByZXNwb25zaXZlIHNlbGVjdG9yOiBzaG93cyByZXNwb25zaXZlIGRldmljZSBmb3IgY3VycmVudCBjbGllbnQgc2l6ZSAoZS5nLiAxMjAwcHggYnJvd3NlciAtIDM1MHB4IFVJIHdpZHRoIGhpZ2hsaWdodHMgcmVzcF94LCB3aGVyZSByZXNwXyh4LTEpLldpZHRoVGhyZXNob2xkID09IDgwMHB4IDwgcmVzcF8oeCkuV2lkdGhUaHJlc2hvbGQgPT0gMTAwMHB4IDw9IHJlc3BfKHgrMSkuV2lkdGhUaHJlc2hvbGQgPT0gMTIwMHB4KVxyXG4gICAgLy8gdXNlciBjYW4gb3ZlcnJpZGUgdGhlIHRhcmdldCByZXNwb25zaXZlIGRldmljZSwgZm9yIGEgZGV2aWNlIGJldHdlZW4gbG93ZXN0V2lkdGhUaHJlc2hvbGQgYW5kIGhpZ2hlc3RXaWR0aFRocmVzaG9sZDsgaWYgaXQgaXMgc21hbGxlciB0aGFuIGNsaWVudCBzaXplLCBlbXB0eSBzcGFjZSBpcyBmaWxsZWQgd2l0aCBVSSBtYXJnaW47IGlmIGl0IGlzIGxhcmdlciwgdGhlIHByZXZpZXcgc2l6ZSBpcyBpbmNyZWFzZWQgKG92ZXJmbG93PXNjcm9sbClcclxuICAgIHB1YmxpYyBsb3dlc3RXaWR0aFRocmVzaG9sZFJlc3BvbnNpdmVEZXZpY2VJZDogbnVtYmVyID0gMDsgLy8gVE9ETyBpcyBub3QgY2xpZW50IHN0YXRlIGJ1dCBzZXJ2ZXIgZGF0YSBzdGF0ZSwgd2hpY2ggaXMgY2FsY3VsYXRlZCBvbiBjbGllbnRcclxuICAgIHB1YmxpYyBoaWdoZXN0V2lkdGhUaHJlc2hvbGRSZXNwb25zaXZlRGV2aWNlSWQ6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgc3BlY2lhbFN0eWxlSG9sZGVyOiBDYWxpZm9ybmlhVmlldyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuICAgIHB1YmxpYyBjdXJyZW50UmVzcG9uc2l2ZURldmljZUlkOiBudW1iZXIgPSAwO1xyXG4gICAgcHVibGljIG5vbmVSZXNwb25zaXZlRGV2aWNlSWQ6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgZGVmYXVsdFN5bW1ldHJpY1BhZ2VQcmV2aWV3SG9sZGVyTWFyZ2luUHg6IG51bWJlciA9IFNUQVRJQ19NQVJHSU5fUFg7IC8vIHN0YXRpYyBtYXJnaW4sIHVzZWQgaW4gdGhlIGRlZmF1bHQgdmlld1xyXG4gICAgcHVibGljIG92ZXJyaWRlUmVzcG9uc2l2ZURldmljZUlkOiBudW1iZXIgPSAwOyAvLyBjYW4gYmUgMCBmb3Igbm8gc2VsZWN0aW9uLCBvciByZXNwb25zaXZlIGRldmljZSBpZCBmb3IgYSBkZXZpY2U6IGxvd2VzdFdpZHRoVGhyZXNob2xkIDwgc2VsZWN0ZWQgZGV2aWNlIHdpZHRoVGhyZXNob2xkIDwgaGlnaGVzdFdpZHRoVGhyZXNob2xkXHJcbiAgICBwdWJsaWMgYXZhaWxhYmxlU3BhY2VQYWdlUHJldmlld1B4OiBudW1iZXI7XHJcbiAgICBwdWJsaWMgaXNFbm91Z2hBdmFpbGFibGVTcGFjZVBhZ2VQcmV2aWV3OiBib29sZWFuID0gdHJ1ZTtcclxuICAgIHB1YmxpYyB0YXJnZXRQYWdlUHJldmlld0hvbGRlck1hcmdpblB4OiBudW1iZXIgPSBTVEFUSUNfTUFSR0lOX1BYO1xyXG4gICAgcHVibGljIHRhcmdldFBhZ2VQcmV2aWV3V2lkdGhQeDogbnVtYmVyO1xyXG4gICAgcHVibGljIHZpc2libGVQcm9wZXJ0eUJhck1heENvdW50OiBudW1iZXIgPSAyOyAvLyBjYW4gYmUgMSwgMiBvciA0XHJcbiAgICBwdWJsaWMgcG9wdXBUYXJnZXRQcm9wZXJ0eUJhckluZGV4OiBudW1iZXIgPSAwO1xyXG4gICAgcHVibGljIGN1cnJlbnRUcmFuc2FjdGlvbk1vZGU6IFRyYW5zYWN0aW9uTW9kZSA9IFRyYW5zYWN0aW9uTW9kZS5Nb3ZlTGF5b3V0TW9sZWN1bGVJbnRvTGF5b3V0TW9sZWN1bGU7XHJcbiAgICBwdWJsaWMgaGlnaGxpZ2h0ZWRMYXlvdXRCYXNlSWQ6IG51bWJlciA9IDA7IC8vIFRPRE8gaGFuZGxpbmcgd2hlbiBpdGVtIGlzIGRlbGV0ZWQgd2hpbGUgYmVpbmcgaGlnaGxpZ2h0ZWRcclxuICAgIHB1YmxpYyBpc1NlbGVjdEFsbFRleHRBcmVhOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAvLyAtLS0gdW5kby9yZXBlYXQgLS0tXHJcbiAgICBwdWJsaWMgbGFzdENvbW1hbmQ6IENhbGlmb3JuaWFFdmVudCA9IENhbGlmb3JuaWFFdmVudC5SZWFkSW5pdGlhbENsaWVudERhdGE7XHJcbiAgICBwdWJsaWMgbGFzdENhbGlmb3JuaWFFdmVudERhdGE6IChzdHJpbmd8bnVtYmVyKVtdID0gW107XHJcbiAgICAvLyAtLS1cclxuICAgIC8vIC0tLSBob3Zlci9zZWxlY3Rpb24gc3RhdGUgLS0tXHJcbiAgICBwdWJsaWMgc2VsZWN0ZWRMYXlvdXRCYXNlSWQ6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgcHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQ6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgaXNEcmF3SGVscGVyTGluZXM6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHB1YmxpYyBob3ZlcmVkQm94VHJlZUxheW91dEJhc2VJZDogbnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBob3ZlcmVkUGFnZVByZXZpZXdMYXlvdXRCYXNlSWQ6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgaG92ZXJlZEluc2VydExheW91dEJhc2VJZDogbnVtYmVyID0gMDsgLy8gc2VsZWN0ZWRMYXlvdXRCYXNlSWQgaXMgdGFyZ2V0XHJcbiAgICBwdWJsaWMgYmFja3VwU29ydE9yZGVyOiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7IC8vIGhvdmVyZWRJbnNlcnRMYXlvdXRCYXNlSWQgZ2V0cyB0ZW1wb3Jhcnkgc29ydCBvcmRlciBrZXkgKGF0b20gaW4gYm94ID0+IG1heEludCBldGMuKVxyXG4gICAgLy8gLS0tXHJcbiAgICAvLyAtLS0gdW5pcXVlIHN0eWxlcyAtLS1cclxuICAgIHB1YmxpYyBuZXdCb3hTdHlsZU1vbGVjdWxlSWQ6IG51bWJlciA9IDA7XHJcbiAgICAvLyAtLS1cclxuICAgIGNvbnN0cnVjdG9yKGNhbGlmb3JuaWFBcHBBcmc6IENhbGlmb3JuaWFBcHApIHtcclxuICAgICAgICBjdXJyZW50Q2xpZW50U3RhdGUgPSB0aGlzO1xyXG4gICAgICAgIGN1cnJlbnRBcHAgPSBjYWxpZm9ybmlhQXBwQXJnO1xyXG4gICAgfTtcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL01vZGVscy9DbGllbnRTdGF0ZS50c3giLCJcInVzZSBzdHJpY3RcIjtcclxuaW1wb3J0ICogYXMgbWFxdWV0dGUgZnJvbSBcIm1hcXVldHRlXCI7XHJcbmNvbnN0IGggPSBtYXF1ZXR0ZS5oO1xyXG5pbXBvcnQgeyBQcm9wZXJ0eUJhciB9IGZyb20gXCIuLy4uL01vZGVscy9Qcm9wZXJ0eUJhclwiO1xyXG5pbXBvcnQgeyBTdHlsZVF1YW50dW0sIFN0eWxlQXRvbSwgU3R5bGVBdG9tVHlwZSwgU3R5bGVNb2xlY3VsZSwgTGF5b3V0Um93LCBMYXlvdXRCYXNlLCBDYWxpZm9ybmlhVmlldyB9IGZyb20gXCIuLi9Nb2RlbHMvQ2FsaWZvcm5pYUdlbmVyYXRlZFwiO1xyXG5pbXBvcnQgeyBDYWxpZm9ybmlhQXBwIH0gZnJvbSBcIi4uL01vZGVscy9DYWxpZm9ybmlhQXBwXCI7XHJcblxyXG5leHBvcnQgZW51bSBQcm9wZXJ0eUJhck1vZGUge1xyXG4gICAgTm9uZSA9IDAsXHJcbiAgICBDYWxpZm9ybmlhVmlldyA9IDEsXHJcbiAgICBMYXlvdXRNb2xlY3VsZXMgPSAyLFxyXG4gICAgTGF5b3V0QXRvbXMgPSAzLFxyXG4gICAgQWxsU3R5bGVRdWFudHVtcyA9IDQsXHJcbiAgICBBbGxTdHlsZUF0b21zID0gNSxcclxuICAgIEFsbFN0eWxlTW9sZWN1bGVzID0gNixcclxuICAgIFN0eWxlTW9sZWN1bGUgPSA3LFxyXG4gICAgQWxsTGF5b3V0TW9sZWN1bGVzID0gOCxcclxuICAgIExheW91dEJhc2UgPSA5LFxyXG4gICAgQWxsQ2FsaWZvcm5pYVZpZXdzID0gMTBcclxufTtcclxuXHJcbmV4cG9ydCBlbnVtIFBvcHVwU2Vjb25kYXJ5TW9kZSB7XHJcbiAgICBOb25lID0gMCxcclxuICAgIFNlbGVjdEJveEludG9Cb3ggPSAxLFxyXG4gICAgU2VsZWN0Qm94SW50b0JveEF0b21JblBsYWNlID0gMlxyXG59O1xyXG5cclxuZXhwb3J0IGVudW0gUG9wdXBNb2RlIHtcclxuICAgIE5vbmUgPSAwLFxyXG4gICAgQWRkQ3NzUHJvcGVydHkgPSAxLFxyXG4gICAgQWxsQ3NzUHJvcGVydGllcyA9IDIsXHJcbiAgICBVcGRhdGVDc3NWYWx1ZSA9IDMsXHJcbiAgICBNYXRjaGluZ1F1YW50dW1zID0gNCxcclxuICAgIFVwZGF0ZUNzc1F1YW50dW0gPSA1LFxyXG4gICAgQWxsQ3NzUHJvcGVydGllc0ZvclF1YW50dW0gPSA2LFxyXG4gICAgSW5zZXJ0TGF5b3V0Um93SW50b1ZpZXcgPSA3LFxyXG4gICAgSW5zZXJ0TGF5b3V0QXRvbUludG9Cb3ggPSA4LFxyXG4gICAgU2VsZWN0Qm94ID0gOSwgLy8gVE9ETyByZW5hbWUgdG8gU2VsZWN0Qm94SGFzU2Vjb25kYXJ5IG9yIGhvdyB0byBtYWtlIHN1cmUgc2Vjb25kYXJ5IG1vZGUgaXMgc2V0P1xyXG4gICAgTW92ZVN0eWxlQXRvbSA9IDEwLFxyXG4gICAgU2hhcmVDYWxpZm9ybmlhUHJvamVjdCA9IDExLFxyXG4gICAgU2VsZWN0SW50ZXJhY3Rpb25UYXJnZXQgPSAxMixcclxuICAgIFNlbGVjdEludGVyYWN0aW9uVGFyZ2V0TGF5b3V0RmlsdGVyID0gMTMsXHJcbiAgICBDYWxpZm9ybmlhVmlld1NlbGVjdGlvbiA9IDE0XHJcbn07XHJcblxyXG5leHBvcnQgZW51bSBUcmFuc2FjdGlvbk1vZGUge1xyXG4gICAgTW92ZUxheW91dE1vbGVjdWxlSW50b0xheW91dE1vbGVjdWxlID0gMCwgLy8gVE9ETyBuZWVkIGRlZmF1bHQgPT09IG5vbmU/XHJcbiAgICBNb3ZlTGF5b3V0TW9sZWN1bGVCZWZvcmVMYXlvdXRNb2xlY3VsZSA9IDEsIC8vIFRPRE8gZGlmZmVyZW50aWF0ZSBtb2RlXHJcbiAgICBTeW5jTGF5b3V0U3R5bGVzSW1pdGF0aW5nID0gMlxyXG59XHJcblxyXG5sZXQgY3VycmVudEFwcDogQ2FsaWZvcm5pYUFwcDtcclxuXHJcbmV4cG9ydCBjbGFzcyBQcm9wZXJ0eUJhclZNIHtcclxuICAgIHByaXZhdGUgcHJvcGVydHlCYXJWTUluZGV4OiBudW1iZXIgPSAtMTtcclxuICAgIHB1YmxpYyBjdXJyZW50UHJvcGVydHlCYXJNb2RlOiBQcm9wZXJ0eUJhck1vZGUgPSBQcm9wZXJ0eUJhck1vZGUuTm9uZTtcclxuICAgIHB1YmxpYyBjdXJyZW50UG9wdXBNb2RlOiBQb3B1cE1vZGUgPSBQb3B1cE1vZGUuTm9uZTtcclxuICAgIHB1YmxpYyBjdXJyZW50U2Vjb25kYXJ5UG9wdXBNb2RlOiBQb3B1cFNlY29uZGFyeU1vZGUgPSBQb3B1cFNlY29uZGFyeU1vZGUuTm9uZTtcclxuICAgIC8vIGRhdGFcclxuICAgIHB1YmxpYyB0ZW1wUXVhbnR1bU5hbWU6IHN0cmluZyA9IFwiUXVhbnR1bVwiO1xyXG4gICAgcHVibGljIHRlbXBDc3NQcm9wZXJ0eU5hbWU6IHN0cmluZyA9IFwiXCI7XHJcbiAgICBwdWJsaWMgdGVtcENzc1ZhbHVlOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHVibGljIGxhc3RVc2VkVGVtcENzc1ZhbHVlOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHVibGljIHRlbXBQc2V1ZG9TZWxlY3Rvcjogc3RyaW5nID0gXCJcIjtcclxuICAgIHB1YmxpYyB0ZW1wQ2FsaWZvcm5pYVZpZXdOYW1lOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHVibGljIHRlbXBDc3NWYWx1ZUZvckludGVyYWN0aW9uOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHVibGljIHNlbGVjdGVkU3R5bGVBdG9tSWQ6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgc2VsZWN0ZWRTdHlsZVZhbHVlSWQ6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgc2VsZWN0ZWRTdHlsZVF1YW50dW1JZDogbnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBzZWxlY3RlZFN0eWxlTW9sZWN1bGVJZDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgX3NlbGVjdGVkQ2FsaWZvcm5pYVZpZXdJZDogbnVtYmVyID0gMDsgLy8gY2FuIGJlIDBcclxuICAgIHB1YmxpYyBzZWxlY3RlZFJlc3BvbnNpdmVEZXZpY2VJZDogbnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBzZWxlY3RlZFN0YXRlTW9kaWZpZXI6IHN0cmluZyA9IFwiXCI7XHJcbiAgICBwdWJsaWMgc2VsZWN0ZWRTdHlsZUF0b21UeXBlOiBTdHlsZUF0b21UeXBlID0gU3R5bGVBdG9tVHlwZS5HZW5lcmljO1xyXG4gICAgcHVibGljIHNlbGVjdGVkTGF5b3V0QmFzZUlkRm9yRmlsdGVyOiBudW1iZXIgPSAwO1xyXG4gICAgcHVibGljIHNlbGVjdGVkTGF5b3V0U3R5bGVJbnRlcmFjdGlvbjogbnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyB0ZW1wT3JpZ2luYWxDb250ZW50OiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHVibGljIHRlbXBDb250ZW50OiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHVibGljIGVkaXRlZExheW91dEF0b21JZDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgX2RlZXBlc3RMZXZlbEFjdGl2ZVZpZXc6IG51bWJlciA9IDA7IC8vIHN1cHBvc2VkIHRvIGJlIHN0cmljdGx5IGxhcmdlciBlcXVhbCBhbnkgbGF5b3V0IGF0b20gbGV2ZWwgZm9yIGN1cnJlbnQgdmlld1xyXG4gICAgLy8gVE9ETyBkaWZmZXJlbnQgc2VsZWN0aW9ucyBvZiBzYW1lIG9iamVjdCB0eXBlIHBvc3NpYmxlIGRlcGVuZGluZyBvbiBjdXJyZW50IFVJIGZ1bmN0aW9uYWxpdHlcclxuICAgIHB1YmxpYyBzZWxlY3RlZFN0eWxlQXRvbUlkRm9yUG9wdXA6IG51bWJlciA9IDA7XHJcbiAgICAvLyBib3ggdHJlZVxyXG4gICAgcHVibGljIGlzU3luY2VkV2l0aEJveFRyZWVUb1RoZUxlZnQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHB1YmxpYyBpc1N5bmNlZFdpdGhQYWdlUHJldmlldzogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgLy8gY29tcG9uZW50c1xyXG4gICAgcHVibGljIHN0eWxlUXVhbnR1bVByb2plY3RvcjogbWFxdWV0dGUuTWFwcGluZzxTdHlsZVF1YW50dW0sIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+O1xyXG4gICAgcHVibGljIHN0eWxlQXRvbVByb2plY3RvcjogbWFxdWV0dGUuTWFwcGluZzxTdHlsZUF0b20sIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+O1xyXG4gICAgcHVibGljIHN0eWxlTW9sZWN1bGVQcm9qZWN0b3I6IG1hcXVldHRlLk1hcHBpbmc8U3R5bGVNb2xlY3VsZSwgeyByZW5kZXJNYXF1ZXR0ZTogKCkgPT4gbWFxdWV0dGUuVk5vZGUgfT47XHJcbiAgICBwdWJsaWMgaW5zdGFuY2VhYmxlQXRvbVByb2plY3RvcjogbWFxdWV0dGUuTWFwcGluZzxMYXlvdXRSb3csIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+O1xyXG4gICAgcHVibGljIGluc3RhbmNlYWJsZU1vbGVjdWxlUHJvamVjdG9yOiBtYXF1ZXR0ZS5NYXBwaW5nPExheW91dFJvdywgeyByZW5kZXJNYXF1ZXR0ZTogKCkgPT4gbWFxdWV0dGUuVk5vZGUgfT47XHJcbiAgICBwdWJsaWMgYWxsTGF5b3V0TW9sZWN1bGVzUHJvamVjdG9yOiBtYXF1ZXR0ZS5NYXBwaW5nPExheW91dEJhc2UsIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+O1xyXG4gICAgcHVibGljIGFsbENhbGlmb3JuaWFWaWV3c1Byb2plY3RvcjogbWFxdWV0dGUuTWFwcGluZzxDYWxpZm9ybmlhVmlldywgeyByZW5kZXJNYXF1ZXR0ZTogKCkgPT4gbWFxdWV0dGUuVk5vZGUgfT47XHJcbiAgICBwdWJsaWMgYm94VHJlZVByb2plY3RvcjogbWFxdWV0dGUuTWFwcGluZzxDYWxpZm9ybmlhVmlldywgeyByZW5kZXJNYXF1ZXR0ZTogKCkgPT4gbWFxdWV0dGUuVk5vZGUgfT47XHJcbiAgICAvLyBjbGllbnQgc2V0dGluZ3NcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eUJhckFyZzogUHJvcGVydHlCYXIsIHRhcmdldEluZGV4OiBudW1iZXIsIGNhbGlmb3JuaWFBcHBBcmc6IENhbGlmb3JuaWFBcHApIHtcclxuICAgICAgICBjdXJyZW50QXBwID0gY2FsaWZvcm5pYUFwcEFyZztcclxuICAgICAgICB0aGlzLnByb3BlcnR5QmFyVk1JbmRleCA9IHRhcmdldEluZGV4O1xyXG4gICAgICAgIHRoaXMuc3R5bGVRdWFudHVtUHJvamVjdG9yID0gcHJvcGVydHlCYXJBcmcucmVuZGVyU3R5bGVRdWFudHVtQXJyYXkocHJvcGVydHlCYXJBcmcpO1xyXG4gICAgICAgIHRoaXMuc3R5bGVBdG9tUHJvamVjdG9yID0gcHJvcGVydHlCYXJBcmcucmVuZGVyU3R5bGVBdG9tQXJyYXkocHJvcGVydHlCYXJBcmcpO1xyXG4gICAgICAgIHRoaXMuc3R5bGVNb2xlY3VsZVByb2plY3RvciA9IHByb3BlcnR5QmFyQXJnLnJlbmRlclN0eWxlTW9sZWN1bGVBcnJheShwcm9wZXJ0eUJhckFyZyk7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZWFibGVBdG9tUHJvamVjdG9yID0gcHJvcGVydHlCYXJBcmcucmVuZGVyTGF5b3V0Um93QXJyYXkocHJvcGVydHlCYXJBcmcpO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VhYmxlTW9sZWN1bGVQcm9qZWN0b3IgPSBwcm9wZXJ0eUJhckFyZy5yZW5kZXJMYXlvdXRSb3dBcnJheShwcm9wZXJ0eUJhckFyZyk7IC8vIFRPRE9cclxuICAgICAgICB0aGlzLmFsbExheW91dE1vbGVjdWxlc1Byb2plY3RvciA9IHByb3BlcnR5QmFyQXJnLnJlbmRlckxheW91dE1vbGVjdWxlQXJyYXkocHJvcGVydHlCYXJBcmcpO1xyXG4gICAgICAgIHRoaXMuYWxsQ2FsaWZvcm5pYVZpZXdzUHJvamVjdG9yID0gcHJvcGVydHlCYXJBcmcucmVuZGVyQ2FsaWZvcm5pYVZpZXdBcnJheShwcm9wZXJ0eUJhckFyZyk7XHJcbiAgICAgICAgdGhpcy5ib3hUcmVlUHJvamVjdG9yID0gcHJvcGVydHlCYXJBcmcucmVuZGVyQm94VHJlZUZvckNhbGlmb3JuaWFWaWV3KHByb3BlcnR5QmFyQXJnKTtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBnZXQgY3VycmVudFZNKCk6IFByb3BlcnR5QmFyVk0ge1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50QXBwLnByb3BlcnR5QmFyVk1zW3RoaXMucHJvcGVydHlCYXJWTUluZGV4XTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGdldCBzZWxlY3RlZENhbGlmb3JuaWFWaWV3SWQoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRDYWxpZm9ybmlhVmlld0lkO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgZ2V0IGRlZXBlc3RMZXZlbEFjdGl2ZVZpZXcoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVlcGVzdExldmVsQWN0aXZlVmlldztcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNldFNlbGVjdGVkUmVzcG9uc2l2ZURldmljZUlkID0gKHJlc3BvbnNpdmVEZXZpY2VJZDogbnVtYmVyLCBpc0ZvcmNlOiBib29sZWFuKTogdm9pZCA9PiB7XHJcbiAgICAgICAgaWYgKGlzRm9yY2UgfHwgdGhpcy5jdXJyZW50Vk0uc2VsZWN0ZWRSZXNwb25zaXZlRGV2aWNlSWQgPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWTS5zZWxlY3RlZFJlc3BvbnNpdmVEZXZpY2VJZCA9IHJlc3BvbnNpdmVEZXZpY2VJZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjbGVhclNlbGVjdGVkQ2FsaWZvcm5pYVZpZXcoaXNDbGVhcldoZW5Ob25FcXVhbDogYm9vbGVhbiwgY2xlYXJXaGVuRXF1YWxzQ2FsaWZvcm5pYVZpZXdJZDogbnVtYmVyKTogdm9pZCB7XHJcbiAgICAgICAgLy8gdmlldyBtb2RlbHMgY2FuIGhhdmUgbm8gc2VsZWN0aW9uXHJcbiAgICAgICAgaWYgKGlzQ2xlYXJXaGVuTm9uRXF1YWwgPT09IHRydWUgfHwgdGhpcy5jdXJyZW50Vk0uc2VsZWN0ZWRDYWxpZm9ybmlhVmlld0lkID09IGNsZWFyV2hlbkVxdWFsc0NhbGlmb3JuaWFWaWV3SWQpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Vk0uX3NlbGVjdGVkQ2FsaWZvcm5pYVZpZXdJZCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZNLl9kZWVwZXN0TGV2ZWxBY3RpdmVWaWV3ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Vk0uYm94VHJlZVByb2plY3Rvci5tYXAoW10pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNldFNlbGVjdGVkQ2FsaWZvcm5pYVZpZXcgPSAoY2FsaWZvcm5pYVZpZXc6IENhbGlmb3JuaWFWaWV3LCBpc0ZvcmNlOiBib29sZWFuKTogdm9pZCA9PiB7XHJcbiAgICAgICAgaWYgKGlzRm9yY2UgfHwgdGhpcy5jdXJyZW50Vk0uc2VsZWN0ZWRDYWxpZm9ybmlhVmlld0lkID09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Vk0uX3NlbGVjdGVkQ2FsaWZvcm5pYVZpZXdJZCA9IGNhbGlmb3JuaWFWaWV3LkNhbGlmb3JuaWFWaWV3SWQ7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZNLl9kZWVwZXN0TGV2ZWxBY3RpdmVWaWV3ID0gY2FsaWZvcm5pYVZpZXcuRGVlcGVzdExldmVsO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWTS5ib3hUcmVlUHJvamVjdG9yLm1hcChbY2FsaWZvcm5pYVZpZXddKTsgLy8gVE9ETyBtYXAgbm90IGNvbXBhdGlibGUgd2l0aCAuLi4gP1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Vk0uYm94VHJlZVByb2plY3Rvci5tYXAoW10pO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWTS5fZGVlcGVzdExldmVsQWN0aXZlVmlldyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZNLl9zZWxlY3RlZENhbGlmb3JuaWFWaWV3SWQgPSAwO1xyXG4gICAgICAgIH0gICAgICAgIFxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgdXBkYXRlRGF0YSA9IChzdHlsZVF1YW50dW1zOiBTdHlsZVF1YW50dW1bXSwgc3R5bGVBdG9tczogU3R5bGVBdG9tW10sIHN0eWxlTW9sZWN1bGVzOiBTdHlsZU1vbGVjdWxlW10sIGxheW91dE1vbGVjdWxlczogTGF5b3V0QmFzZVtdLCBhbGxDYWxpZm9ybmlhVmlld3M6IENhbGlmb3JuaWFWaWV3W10sIGluc3RhbmNlYWJsZUF0b21zVmlldzogQ2FsaWZvcm5pYVZpZXcsIGluc3RhbmNlYWJsZVJvd3NWaWV3OiBDYWxpZm9ybmlhVmlldyk6IHZvaWQgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFZNLnN0eWxlUXVhbnR1bVByb2plY3Rvci5tYXAoc3R5bGVRdWFudHVtcyk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Vk0uc3R5bGVBdG9tUHJvamVjdG9yLm1hcChzdHlsZUF0b21zKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRWTS5zdHlsZU1vbGVjdWxlUHJvamVjdG9yLm1hcChzdHlsZU1vbGVjdWxlcyk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Vk0uYWxsTGF5b3V0TW9sZWN1bGVzUHJvamVjdG9yLm1hcChsYXlvdXRNb2xlY3VsZXMpOyAvLyBUT0RPIHJldmVyc2Ugc2VydmVyIHNpZGU/IC8vIFRPRE8gb25seSByZXF1aXJlZCBvbmNlIGZvciBhbGwgcHJvcGVydHliYXJzXHJcbiAgICAgICAgdGhpcy5jdXJyZW50Vk0uYWxsQ2FsaWZvcm5pYVZpZXdzUHJvamVjdG9yLm1hcChhbGxDYWxpZm9ybmlhVmlld3MpOyAvLyBUT0RPIG5vIGludGVybmFsc1xyXG4gICAgICAgIHRoaXMuY3VycmVudFZNLmluc3RhbmNlYWJsZUF0b21Qcm9qZWN0b3IubWFwKGluc3RhbmNlYWJsZUF0b21zVmlldy5QbGFjZWRMYXlvdXRSb3dzKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRWTS5pbnN0YW5jZWFibGVNb2xlY3VsZVByb2plY3Rvci5tYXAoaW5zdGFuY2VhYmxlUm93c1ZpZXcuUGxhY2VkTGF5b3V0Um93cyk7XHJcbiAgICB9O1xyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vVmlld01vZGVscy9Qcm9wZXJ0eUJhclZNLnRzeCIsIi8qKiFcbiAqIEBmaWxlT3ZlcnZpZXcgS2lja2FzcyBsaWJyYXJ5IHRvIGNyZWF0ZSBhbmQgcGxhY2UgcG9wcGVycyBuZWFyIHRoZWlyIHJlZmVyZW5jZSBlbGVtZW50cy5cbiAqIEB2ZXJzaW9uIDEuMTQuM1xuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiBGZWRlcmljbyBaaXZvbG8gYW5kIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgbG9uZ2VyVGltZW91dEJyb3dzZXJzID0gWydFZGdlJywgJ1RyaWRlbnQnLCAnRmlyZWZveCddO1xudmFyIHRpbWVvdXREdXJhdGlvbiA9IDA7XG5mb3IgKHZhciBpID0gMDsgaSA8IGxvbmdlclRpbWVvdXRCcm93c2Vycy5sZW5ndGg7IGkgKz0gMSkge1xuICBpZiAoaXNCcm93c2VyICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihsb25nZXJUaW1lb3V0QnJvd3NlcnNbaV0pID49IDApIHtcbiAgICB0aW1lb3V0RHVyYXRpb24gPSAxO1xuICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1pY3JvdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgd2luZG93LlByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGVkID0gZmFsc2U7XG4gICAgICBmbigpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0YXNrRGVib3VuY2UoZm4pIHtcbiAgdmFyIHNjaGVkdWxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICBmbigpO1xuICAgICAgfSwgdGltZW91dER1cmF0aW9uKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBzdXBwb3J0c01pY3JvVGFza3MgPSBpc0Jyb3dzZXIgJiYgd2luZG93LlByb21pc2U7XG5cbi8qKlxuKiBDcmVhdGUgYSBkZWJvdW5jZWQgdmVyc2lvbiBvZiBhIG1ldGhvZCwgdGhhdCdzIGFzeW5jaHJvbm91c2x5IGRlZmVycmVkXG4qIGJ1dCBjYWxsZWQgaW4gdGhlIG1pbmltdW0gdGltZSBwb3NzaWJsZS5cbipcbiogQG1ldGhvZFxuKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4qIEBhcmd1bWVudCB7RnVuY3Rpb259IGZuXG4qIEByZXR1cm5zIHtGdW5jdGlvbn1cbiovXG52YXIgZGVib3VuY2UgPSBzdXBwb3J0c01pY3JvVGFza3MgPyBtaWNyb3Rhc2tEZWJvdW5jZSA6IHRhc2tEZWJvdW5jZTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBmdW5jdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBbnl9IGZ1bmN0aW9uVG9DaGVjayAtIHZhcmlhYmxlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvOiBpcyBhIGZ1bmN0aW9uP1xuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmN0aW9uVG9DaGVjaykge1xuICB2YXIgZ2V0VHlwZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb25Ub0NoZWNrICYmIGdldFR5cGUudG9TdHJpbmcuY2FsbChmdW5jdGlvblRvQ2hlY2spID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIEdldCBDU1MgY29tcHV0ZWQgcHJvcGVydHkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHlcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICByZXR1cm4gcHJvcGVydHkgPyBjc3NbcHJvcGVydHldIDogY3NzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhcmVudE5vZGUgb3IgdGhlIGhvc3Qgb2YgdGhlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHJldHVybiBlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudC5ob3N0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNjcm9sbGluZyBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHNjcm9sbCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gUmV0dXJuIGJvZHksIGBnZXRTY3JvbGxgIHdpbGwgdGFrZSBjYXJlIHRvIGdldCB0aGUgY29ycmVjdCBgc2Nyb2xsVG9wYCBmcm9tIGl0XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgc3dpdGNoIChlbGVtZW50Lm5vZGVOYW1lKSB7XG4gICAgY2FzZSAnSFRNTCc6XG4gICAgY2FzZSAnQk9EWSc6XG4gICAgICByZXR1cm4gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgIHJldHVybiBlbGVtZW50LmJvZHk7XG4gIH1cblxuICAvLyBGaXJlZm94IHdhbnQgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcblxuICB2YXIgX2dldFN0eWxlQ29tcHV0ZWRQcm9wID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3csXG4gICAgICBvdmVyZmxvd1ggPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WTtcblxuICBpZiAoLyhhdXRvfHNjcm9sbHxvdmVybGF5KS8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG59XG5cbnZhciBpc0lFMTEgPSBpc0Jyb3dzZXIgJiYgISEod2luZG93Lk1TSW5wdXRNZXRob2RDb250ZXh0ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSk7XG52YXIgaXNJRTEwID0gaXNCcm93c2VyICYmIC9NU0lFIDEwLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGJyb3dzZXIgaXMgSW50ZXJuZXQgRXhwbG9yZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7TnVtYmVyfSB2ZXJzaW9uIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXNJRVxuICovXG5mdW5jdGlvbiBpc0lFKHZlcnNpb24pIHtcbiAgaWYgKHZlcnNpb24gPT09IDExKSB7XG4gICAgcmV0dXJuIGlzSUUxMTtcbiAgfVxuICBpZiAodmVyc2lvbiA9PT0gMTApIHtcbiAgICByZXR1cm4gaXNJRTEwO1xuICB9XG4gIHJldHVybiBpc0lFMTEgfHwgaXNJRTEwO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG9mZnNldCBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIHZhciBub09mZnNldFBhcmVudCA9IGlzSUUoMTApID8gZG9jdW1lbnQuYm9keSA6IG51bGw7XG5cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgdmFyIG9mZnNldFBhcmVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAvLyBTa2lwIGhpZGRlbiBlbGVtZW50cyB3aGljaCBkb24ndCBoYXZlIGFuIG9mZnNldFBhcmVudFxuICB3aGlsZSAob2Zmc2V0UGFyZW50ID09PSBub09mZnNldFBhcmVudCAmJiBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZykge1xuICAgIG9mZnNldFBhcmVudCA9IChlbGVtZW50ID0gZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpLm9mZnNldFBhcmVudDtcbiAgfVxuXG4gIHZhciBub2RlTmFtZSA9IG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQubm9kZU5hbWU7XG5cbiAgaWYgKCFub2RlTmFtZSB8fCBub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudCA/IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyAub2Zmc2V0UGFyZW50IHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IFREIG9yIFRBQkxFIGluIGNhc2VcbiAgLy8gbm8gb2Zmc2V0UGFyZW50IGlzIHByZXNlbnQsIEkgaGF0ZSB0aGlzIGpvYi4uLlxuICBpZiAoWydURCcsICdUQUJMRSddLmluZGV4T2Yob2Zmc2V0UGFyZW50Lm5vZGVOYW1lKSAhPT0gLTEgJiYgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KG9mZnNldFBhcmVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudDtcbn1cblxuZnVuY3Rpb24gaXNPZmZzZXRDb250YWluZXIoZWxlbWVudCkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ0hUTUwnIHx8IGdldE9mZnNldFBhcmVudChlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSA9PT0gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgcm9vdCBub2RlIChkb2N1bWVudCwgc2hhZG93RE9NIHJvb3QpIG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm5zIHtFbGVtZW50fSByb290IG5vZGVcbiAqL1xuZnVuY3Rpb24gZ2V0Um9vdChub2RlKSB7XG4gIGlmIChub2RlLnBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZ2V0Um9vdChub2RlLnBhcmVudE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIG9mZnNldCBwYXJlbnQgY29tbW9uIHRvIHRoZSB0d28gcHJvdmlkZWQgbm9kZXNcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudDFcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudDJcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBjb21tb24gb2Zmc2V0IHBhcmVudFxuICovXG5mdW5jdGlvbiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxLCBlbGVtZW50Mikge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50MSB8fCAhZWxlbWVudDEubm9kZVR5cGUgfHwgIWVsZW1lbnQyIHx8ICFlbGVtZW50Mi5ub2RlVHlwZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyBIZXJlIHdlIG1ha2Ugc3VyZSB0byBnaXZlIGFzIFwic3RhcnRcIiB0aGUgZWxlbWVudCB0aGF0IGNvbWVzIGZpcnN0IGluIHRoZSBET01cbiAgdmFyIG9yZGVyID0gZWxlbWVudDEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWxlbWVudDIpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc7XG4gIHZhciBzdGFydCA9IG9yZGVyID8gZWxlbWVudDEgOiBlbGVtZW50MjtcbiAgdmFyIGVuZCA9IG9yZGVyID8gZWxlbWVudDIgOiBlbGVtZW50MTtcblxuICAvLyBHZXQgY29tbW9uIGFuY2VzdG9yIGNvbnRhaW5lclxuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICByYW5nZS5zZXRTdGFydChzdGFydCwgMCk7XG4gIHJhbmdlLnNldEVuZChlbmQsIDApO1xuICB2YXIgY29tbW9uQW5jZXN0b3JDb250YWluZXIgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcblxuICAvLyBCb3RoIG5vZGVzIGFyZSBpbnNpZGUgI2RvY3VtZW50XG5cbiAgaWYgKGVsZW1lbnQxICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciAmJiBlbGVtZW50MiAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgfHwgc3RhcnQuY29udGFpbnMoZW5kKSkge1xuICAgIGlmIChpc09mZnNldENvbnRhaW5lcihjb21tb25BbmNlc3RvckNvbnRhaW5lcikpIHtcbiAgICAgIHJldHVybiBjb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKTtcbiAgfVxuXG4gIC8vIG9uZSBvZiB0aGUgbm9kZXMgaXMgaW5zaWRlIHNoYWRvd0RPTSwgZmluZCB3aGljaCBvbmVcbiAgdmFyIGVsZW1lbnQxcm9vdCA9IGdldFJvb3QoZWxlbWVudDEpO1xuICBpZiAoZWxlbWVudDFyb290Lmhvc3QpIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MXJvb3QuaG9zdCwgZWxlbWVudDIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxLCBnZXRSb290KGVsZW1lbnQyKS5ob3N0KTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIHNjcm9sbCB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBpbiB0aGUgZ2l2ZW4gc2lkZSAodG9wIGFuZCBsZWZ0KVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge1N0cmluZ30gc2lkZSBgdG9wYCBvciBgbGVmdGBcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGFtb3VudCBvZiBzY3JvbGxlZCBwaXhlbHNcbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsKGVsZW1lbnQpIHtcbiAgdmFyIHNpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICd0b3AnO1xuXG4gIHZhciB1cHBlclNpZGUgPSBzaWRlID09PSAndG9wJyA/ICdzY3JvbGxUb3AnIDogJ3Njcm9sbExlZnQnO1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICB2YXIgaHRtbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgdmFyIHNjcm9sbGluZ0VsZW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBodG1sO1xuICAgIHJldHVybiBzY3JvbGxpbmdFbGVtZW50W3VwcGVyU2lkZV07XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFt1cHBlclNpZGVdO1xufVxuXG4vKlxuICogU3VtIG9yIHN1YnRyYWN0IHRoZSBlbGVtZW50IHNjcm9sbCB2YWx1ZXMgKGxlZnQgYW5kIHRvcCkgZnJvbSBhIGdpdmVuIHJlY3Qgb2JqZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdCAtIFJlY3Qgb2JqZWN0IHlvdSB3YW50IHRvIGNoYW5nZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IGZyb20gdGhlIGZ1bmN0aW9uIHJlYWRzIHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN1YnRyYWN0IC0gc2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gc3VidHJhY3QgdGhlIHNjcm9sbCB2YWx1ZXNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVjdCAtIFRoZSBtb2RpZmllciByZWN0IG9iamVjdFxuICovXG5mdW5jdGlvbiBpbmNsdWRlU2Nyb2xsKHJlY3QsIGVsZW1lbnQpIHtcbiAgdmFyIHN1YnRyYWN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICd0b3AnKTtcbiAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgdmFyIG1vZGlmaWVyID0gc3VidHJhY3QgPyAtMSA6IDE7XG4gIHJlY3QudG9wICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmJvdHRvbSArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5sZWZ0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJldHVybiByZWN0O1xufVxuXG4vKlxuICogSGVscGVyIHRvIGRldGVjdCBib3JkZXJzIG9mIGEgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcbiAqIFJlc3VsdCBvZiBgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5YCBvbiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGF4aXMgLSBgeGAgb3IgYHlgXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGJvcmRlcnMgLSBUaGUgYm9yZGVycyBzaXplIG9mIHRoZSBnaXZlbiBheGlzXG4gKi9cblxuZnVuY3Rpb24gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCBheGlzKSB7XG4gIHZhciBzaWRlQSA9IGF4aXMgPT09ICd4JyA/ICdMZWZ0JyA6ICdUb3AnO1xuICB2YXIgc2lkZUIgPSBzaWRlQSA9PT0gJ0xlZnQnID8gJ1JpZ2h0JyA6ICdCb3R0b20nO1xuXG4gIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlc1snYm9yZGVyJyArIHNpZGVBICsgJ1dpZHRoJ10sIDEwKSArIHBhcnNlRmxvYXQoc3R5bGVzWydib3JkZXInICsgc2lkZUIgKyAnV2lkdGgnXSwgMTApO1xufVxuXG5mdW5jdGlvbiBnZXRTaXplKGF4aXMsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KGJvZHlbJ29mZnNldCcgKyBheGlzXSwgYm9keVsnc2Nyb2xsJyArIGF4aXNdLCBodG1sWydjbGllbnQnICsgYXhpc10sIGh0bWxbJ29mZnNldCcgKyBheGlzXSwgaHRtbFsnc2Nyb2xsJyArIGF4aXNdLCBpc0lFKDEwKSA/IGh0bWxbJ29mZnNldCcgKyBheGlzXSArIGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnVG9wJyA6ICdMZWZ0JyldICsgY29tcHV0ZWRTdHlsZVsnbWFyZ2luJyArIChheGlzID09PSAnSGVpZ2h0JyA/ICdCb3R0b20nIDogJ1JpZ2h0JyldIDogMCk7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1NpemVzKCkge1xuICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gIHZhciBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgY29tcHV0ZWRTdHlsZSA9IGlzSUUoMTApICYmIGdldENvbXB1dGVkU3R5bGUoaHRtbCk7XG5cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IGdldFNpemUoJ0hlaWdodCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpLFxuICAgIHdpZHRoOiBnZXRTaXplKCdXaWR0aCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpXG4gIH07XG59XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuXG5cblxudmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBHaXZlbiBlbGVtZW50IG9mZnNldHMsIGdlbmVyYXRlIGFuIG91dHB1dCBzaW1pbGFyIHRvIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IG9mZnNldHNcbiAqIEByZXR1cm5zIHtPYmplY3R9IENsaWVudFJlY3QgbGlrZSBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdChvZmZzZXRzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgb2Zmc2V0cywge1xuICAgIHJpZ2h0OiBvZmZzZXRzLmxlZnQgKyBvZmZzZXRzLndpZHRoLFxuICAgIGJvdHRvbTogb2Zmc2V0cy50b3AgKyBvZmZzZXRzLmhlaWdodFxuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7T2JqZWN0fSBjbGllbnQgcmVjdFxuICovXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IHt9O1xuXG4gIC8vIElFMTAgMTAgRklYOiBQbGVhc2UsIGRvbid0IGFzaywgdGhlIGVsZW1lbnQgaXNuJ3RcbiAgLy8gY29uc2lkZXJlZCBpbiBET00gaW4gc29tZSBjaXJjdW1zdGFuY2VzLi4uXG4gIC8vIFRoaXMgaXNuJ3QgcmVwcm9kdWNpYmxlIGluIElFMTAgY29tcGF0aWJpbGl0eSBtb2RlIG9mIElFMTFcbiAgdHJ5IHtcbiAgICBpZiAoaXNJRSgxMCkpIHtcbiAgICAgIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICAgICAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5sZWZ0ICs9IHNjcm9sbExlZnQ7XG4gICAgICByZWN0LmJvdHRvbSArPSBzY3JvbGxUb3A7XG4gICAgICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0ge1xuICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICB0b3A6IHJlY3QudG9wLFxuICAgIHdpZHRoOiByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LFxuICAgIGhlaWdodDogcmVjdC5ib3R0b20gLSByZWN0LnRvcFxuICB9O1xuXG4gIC8vIHN1YnRyYWN0IHNjcm9sbGJhciBzaXplIGZyb20gc2l6ZXNcbiAgdmFyIHNpemVzID0gZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnID8gZ2V0V2luZG93U2l6ZXMoKSA6IHt9O1xuICB2YXIgd2lkdGggPSBzaXplcy53aWR0aCB8fCBlbGVtZW50LmNsaWVudFdpZHRoIHx8IHJlc3VsdC5yaWdodCAtIHJlc3VsdC5sZWZ0O1xuICB2YXIgaGVpZ2h0ID0gc2l6ZXMuaGVpZ2h0IHx8IGVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IHJlc3VsdC5ib3R0b20gLSByZXN1bHQudG9wO1xuXG4gIHZhciBob3JpelNjcm9sbGJhciA9IGVsZW1lbnQub2Zmc2V0V2lkdGggLSB3aWR0aDtcbiAgdmFyIHZlcnRTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldEhlaWdodCAtIGhlaWdodDtcblxuICAvLyBpZiBhbiBoeXBvdGhldGljYWwgc2Nyb2xsYmFyIGlzIGRldGVjdGVkLCB3ZSBtdXN0IGJlIHN1cmUgaXQncyBub3QgYSBgYm9yZGVyYFxuICAvLyB3ZSBtYWtlIHRoaXMgY2hlY2sgY29uZGl0aW9uYWwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAgaWYgKGhvcml6U2Nyb2xsYmFyIHx8IHZlcnRTY3JvbGxiYXIpIHtcbiAgICB2YXIgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpO1xuICAgIGhvcml6U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3gnKTtcbiAgICB2ZXJ0U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3knKTtcblxuICAgIHJlc3VsdC53aWR0aCAtPSBob3JpelNjcm9sbGJhcjtcbiAgICByZXN1bHQuaGVpZ2h0IC09IHZlcnRTY3JvbGxiYXI7XG4gIH1cblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChyZXN1bHQpO1xufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoY2hpbGRyZW4sIHBhcmVudCkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFyIGlzSUUxMCA9IGlzSUUoMTApO1xuICB2YXIgaXNIVE1MID0gcGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCc7XG4gIHZhciBjaGlsZHJlblJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoY2hpbGRyZW4pO1xuICB2YXIgcGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChwYXJlbnQpO1xuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGNoaWxkcmVuKTtcblxuICB2YXIgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KHBhcmVudCk7XG4gIHZhciBib3JkZXJUb3BXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlclRvcFdpZHRoLCAxMCk7XG4gIHZhciBib3JkZXJMZWZ0V2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJMZWZ0V2lkdGgsIDEwKTtcblxuICAvLyBJbiBjYXNlcyB3aGVyZSB0aGUgcGFyZW50IGlzIGZpeGVkLCB3ZSBtdXN0IGlnbm9yZSBuZWdhdGl2ZSBzY3JvbGwgaW4gb2Zmc2V0IGNhbGNcbiAgaWYgKGZpeGVkUG9zaXRpb24gJiYgcGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICBwYXJlbnRSZWN0LnRvcCA9IE1hdGgubWF4KHBhcmVudFJlY3QudG9wLCAwKTtcbiAgICBwYXJlbnRSZWN0LmxlZnQgPSBNYXRoLm1heChwYXJlbnRSZWN0LmxlZnQsIDApO1xuICB9XG4gIHZhciBvZmZzZXRzID0gZ2V0Q2xpZW50UmVjdCh7XG4gICAgdG9wOiBjaGlsZHJlblJlY3QudG9wIC0gcGFyZW50UmVjdC50b3AgLSBib3JkZXJUb3BXaWR0aCxcbiAgICBsZWZ0OiBjaGlsZHJlblJlY3QubGVmdCAtIHBhcmVudFJlY3QubGVmdCAtIGJvcmRlckxlZnRXaWR0aCxcbiAgICB3aWR0aDogY2hpbGRyZW5SZWN0LndpZHRoLFxuICAgIGhlaWdodDogY2hpbGRyZW5SZWN0LmhlaWdodFxuICB9KTtcbiAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSAwO1xuICBvZmZzZXRzLm1hcmdpbkxlZnQgPSAwO1xuXG4gIC8vIFN1YnRyYWN0IG1hcmdpbnMgb2YgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgaXQncyBiZWluZyB1c2VkIGFzIHBhcmVudFxuICAvLyB3ZSBkbyB0aGlzIG9ubHkgb24gSFRNTCBiZWNhdXNlIGl0J3MgdGhlIG9ubHkgZWxlbWVudCB0aGF0IGJlaGF2ZXNcbiAgLy8gZGlmZmVyZW50bHkgd2hlbiBtYXJnaW5zIGFyZSBhcHBsaWVkIHRvIGl0LiBUaGUgbWFyZ2lucyBhcmUgaW5jbHVkZWQgaW5cbiAgLy8gdGhlIGJveCBvZiB0aGUgZG9jdW1lbnRFbGVtZW50LCBpbiB0aGUgb3RoZXIgY2FzZXMgbm90LlxuICBpZiAoIWlzSUUxMCAmJiBpc0hUTUwpIHtcbiAgICB2YXIgbWFyZ2luVG9wID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wLCAxMCk7XG4gICAgdmFyIG1hcmdpbkxlZnQgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5MZWZ0LCAxMCk7XG5cbiAgICBvZmZzZXRzLnRvcCAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLmJvdHRvbSAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLmxlZnQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcbiAgICBvZmZzZXRzLnJpZ2h0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG5cbiAgICAvLyBBdHRhY2ggbWFyZ2luVG9wIGFuZCBtYXJnaW5MZWZ0IGJlY2F1c2UgaW4gc29tZSBjaXJjdW1zdGFuY2VzIHdlIG1heSBuZWVkIHRoZW1cbiAgICBvZmZzZXRzLm1hcmdpblRvcCA9IG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLm1hcmdpbkxlZnQgPSBtYXJnaW5MZWZ0O1xuICB9XG5cbiAgaWYgKGlzSUUxMCAmJiAhZml4ZWRQb3NpdGlvbiA/IHBhcmVudC5jb250YWlucyhzY3JvbGxQYXJlbnQpIDogcGFyZW50ID09PSBzY3JvbGxQYXJlbnQgJiYgc2Nyb2xsUGFyZW50Lm5vZGVOYW1lICE9PSAnQk9EWScpIHtcbiAgICBvZmZzZXRzID0gaW5jbHVkZVNjcm9sbChvZmZzZXRzLCBwYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShlbGVtZW50KSB7XG4gIHZhciBleGNsdWRlU2Nyb2xsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaHRtbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciByZWxhdGl2ZU9mZnNldCA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShlbGVtZW50LCBodG1sKTtcbiAgdmFyIHdpZHRoID0gTWF0aC5tYXgoaHRtbC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG4gIHZhciBoZWlnaHQgPSBNYXRoLm1heChodG1sLmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuXG4gIHZhciBzY3JvbGxUb3AgPSAhZXhjbHVkZVNjcm9sbCA/IGdldFNjcm9sbChodG1sKSA6IDA7XG4gIHZhciBzY3JvbGxMZWZ0ID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCwgJ2xlZnQnKSA6IDA7XG5cbiAgdmFyIG9mZnNldCA9IHtcbiAgICB0b3A6IHNjcm9sbFRvcCAtIHJlbGF0aXZlT2Zmc2V0LnRvcCArIHJlbGF0aXZlT2Zmc2V0Lm1hcmdpblRvcCxcbiAgICBsZWZ0OiBzY3JvbGxMZWZ0IC0gcmVsYXRpdmVPZmZzZXQubGVmdCArIHJlbGF0aXZlT2Zmc2V0Lm1hcmdpbkxlZnQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3Qob2Zmc2V0KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBmaXhlZCBvciBpcyBpbnNpZGUgYSBmaXhlZCBwYXJlbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBjdXN0b21Db250YWluZXJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBhbnN3ZXIgdG8gXCJpc0ZpeGVkP1wiXG4gKi9cbmZ1bmN0aW9uIGlzRml4ZWQoZWxlbWVudCkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgJ3Bvc2l0aW9uJykgPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gaXNGaXhlZChnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgZmlyc3QgcGFyZW50IG9mIGFuIGVsZW1lbnQgdGhhdCBoYXMgYSB0cmFuc2Zvcm1lZCBwcm9wZXJ0eSBkZWZpbmVkXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBmaXJzdCB0cmFuc2Zvcm1lZCBwYXJlbnQgb3IgZG9jdW1lbnRFbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQucGFyZW50RWxlbWVudCB8fCBpc0lFKCkpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG4gIHZhciBlbCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgd2hpbGUgKGVsICYmIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbCwgJ3RyYW5zZm9ybScpID09PSAnbm9uZScpIHtcbiAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGVsIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbn1cblxuLyoqXG4gKiBDb21wdXRlZCB0aGUgYm91bmRhcmllcyBsaW1pdHMgYW5kIHJldHVybiB0aGVtXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmdcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50IC0gRWxlbWVudCB1c2VkIHRvIGRlZmluZSB0aGUgYm91bmRhcmllc1xuICogQHBhcmFtIHtCb29sZWFufSBmaXhlZFBvc2l0aW9uIC0gSXMgaW4gZml4ZWQgcG9zaXRpb24gbW9kZVxuICogQHJldHVybnMge09iamVjdH0gQ29vcmRpbmF0ZXMgb2YgdGhlIGJvdW5kYXJpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRhcmllcyhwb3BwZXIsIHJlZmVyZW5jZSwgcGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuXG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG5cbiAgdmFyIGJvdW5kYXJpZXMgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuICB2YXIgb2Zmc2V0UGFyZW50ID0gZml4ZWRQb3NpdGlvbiA/IGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQocG9wcGVyKSA6IGZpbmRDb21tb25PZmZzZXRQYXJlbnQocG9wcGVyLCByZWZlcmVuY2UpO1xuXG4gIC8vIEhhbmRsZSB2aWV3cG9ydCBjYXNlXG4gIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgIGJvdW5kYXJpZXMgPSBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUob2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBIYW5kbGUgb3RoZXIgY2FzZXMgYmFzZWQgb24gRE9NIGVsZW1lbnQgdXNlZCBhcyBib3VuZGFyaWVzXG4gICAgdmFyIGJvdW5kYXJpZXNOb2RlID0gdm9pZCAwO1xuICAgIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3Njcm9sbFBhcmVudCcpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUocmVmZXJlbmNlKSk7XG4gICAgICBpZiAoYm91bmRhcmllc05vZGUubm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgICAgICBib3VuZGFyaWVzTm9kZSA9IHBvcHBlci5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnd2luZG93Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gYm91bmRhcmllc0VsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldHMgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoYm91bmRhcmllc05vZGUsIG9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG5cbiAgICAvLyBJbiBjYXNlIG9mIEhUTUwsIHdlIG5lZWQgYSBkaWZmZXJlbnQgY29tcHV0YXRpb25cbiAgICBpZiAoYm91bmRhcmllc05vZGUubm9kZU5hbWUgPT09ICdIVE1MJyAmJiAhaXNGaXhlZChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICB2YXIgX2dldFdpbmRvd1NpemVzID0gZ2V0V2luZG93U2l6ZXMoKSxcbiAgICAgICAgICBoZWlnaHQgPSBfZ2V0V2luZG93U2l6ZXMuaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoID0gX2dldFdpbmRvd1NpemVzLndpZHRoO1xuXG4gICAgICBib3VuZGFyaWVzLnRvcCArPSBvZmZzZXRzLnRvcCAtIG9mZnNldHMubWFyZ2luVG9wO1xuICAgICAgYm91bmRhcmllcy5ib3R0b20gPSBoZWlnaHQgKyBvZmZzZXRzLnRvcDtcbiAgICAgIGJvdW5kYXJpZXMubGVmdCArPSBvZmZzZXRzLmxlZnQgLSBvZmZzZXRzLm1hcmdpbkxlZnQ7XG4gICAgICBib3VuZGFyaWVzLnJpZ2h0ID0gd2lkdGggKyBvZmZzZXRzLmxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvciBhbGwgdGhlIG90aGVyIERPTSBlbGVtZW50cywgdGhpcyBvbmUgaXMgZ29vZFxuICAgICAgYm91bmRhcmllcyA9IG9mZnNldHM7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHBhZGRpbmdzXG4gIGJvdW5kYXJpZXMubGVmdCArPSBwYWRkaW5nO1xuICBib3VuZGFyaWVzLnRvcCArPSBwYWRkaW5nO1xuICBib3VuZGFyaWVzLnJpZ2h0IC09IHBhZGRpbmc7XG4gIGJvdW5kYXJpZXMuYm90dG9tIC09IHBhZGRpbmc7XG5cbiAgcmV0dXJuIGJvdW5kYXJpZXM7XG59XG5cbmZ1bmN0aW9uIGdldEFyZWEoX3JlZikge1xuICB2YXIgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQ7XG5cbiAgcmV0dXJuIHdpZHRoICogaGVpZ2h0O1xufVxuXG4vKipcbiAqIFV0aWxpdHkgdXNlZCB0byB0cmFuc2Zvcm0gdGhlIGBhdXRvYCBwbGFjZW1lbnQgdG8gdGhlIHBsYWNlbWVudCB3aXRoIG1vcmVcbiAqIGF2YWlsYWJsZSBzcGFjZS5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHBsYWNlbWVudCwgcmVmUmVjdCwgcG9wcGVyLCByZWZlcmVuY2UsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIHZhciBwYWRkaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiAwO1xuXG4gIGlmIChwbGFjZW1lbnQuaW5kZXhPZignYXV0bycpID09PSAtMSkge1xuICAgIHJldHVybiBwbGFjZW1lbnQ7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KTtcblxuICB2YXIgcmVjdHMgPSB7XG4gICAgdG9wOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogcmVmUmVjdC50b3AgLSBib3VuZGFyaWVzLnRvcFxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLnJpZ2h0IC0gcmVmUmVjdC5yaWdodCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5oZWlnaHRcbiAgICB9LFxuICAgIGJvdHRvbToge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuYm90dG9tIC0gcmVmUmVjdC5ib3R0b21cbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgIHdpZHRoOiByZWZSZWN0LmxlZnQgLSBib3VuZGFyaWVzLmxlZnQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfVxuICB9O1xuXG4gIHZhciBzb3J0ZWRBcmVhcyA9IE9iamVjdC5rZXlzKHJlY3RzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBrZXk6IGtleVxuICAgIH0sIHJlY3RzW2tleV0sIHtcbiAgICAgIGFyZWE6IGdldEFyZWEocmVjdHNba2V5XSlcbiAgICB9KTtcbiAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLmFyZWEgLSBhLmFyZWE7XG4gIH0pO1xuXG4gIHZhciBmaWx0ZXJlZEFyZWFzID0gc29ydGVkQXJlYXMuZmlsdGVyKGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciB3aWR0aCA9IF9yZWYyLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfcmVmMi5oZWlnaHQ7XG4gICAgcmV0dXJuIHdpZHRoID49IHBvcHBlci5jbGllbnRXaWR0aCAmJiBoZWlnaHQgPj0gcG9wcGVyLmNsaWVudEhlaWdodDtcbiAgfSk7XG5cbiAgdmFyIGNvbXB1dGVkUGxhY2VtZW50ID0gZmlsdGVyZWRBcmVhcy5sZW5ndGggPiAwID8gZmlsdGVyZWRBcmVhc1swXS5rZXkgOiBzb3J0ZWRBcmVhc1swXS5rZXk7XG5cbiAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIHJldHVybiBjb21wdXRlZFBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG59XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IHJlZmVyZW5jZSAtIHRoZSByZWZlcmVuY2UgZWxlbWVudCAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGZpeGVkUG9zaXRpb24gLSBpcyBpbiBmaXhlZCBwb3NpdGlvbiBtb2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb2Zmc2V0cyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlclxuICovXG5mdW5jdGlvbiBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICB2YXIgY29tbW9uT2Zmc2V0UGFyZW50ID0gZml4ZWRQb3NpdGlvbiA/IGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQocG9wcGVyKSA6IGZpbmRDb21tb25PZmZzZXRQYXJlbnQocG9wcGVyLCByZWZlcmVuY2UpO1xuICByZXR1cm4gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKHJlZmVyZW5jZSwgY29tbW9uT2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG91dGVyIHNpemVzIG9mIHRoZSBnaXZlbiBlbGVtZW50IChvZmZzZXQgc2l6ZSArIG1hcmdpbnMpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCBjb250YWluaW5nIHdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBnZXRPdXRlclNpemVzKGVsZW1lbnQpIHtcbiAgdmFyIHN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHZhciB4ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wKSArIHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkJvdHRvbSk7XG4gIHZhciB5ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5SaWdodCk7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgd2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGggKyB5LFxuICAgIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHQgKyB4XG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudFxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHZhciBoYXNoID0geyBsZWZ0OiAncmlnaHQnLCByaWdodDogJ2xlZnQnLCBib3R0b206ICd0b3AnLCB0b3A6ICdib3R0b20nIH07XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiAtIENTUyBwb3NpdGlvbiB0aGUgUG9wcGVyIHdpbGwgZ2V0IGFwcGxpZWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHMgLSB0aGUgcmVmZXJlbmNlIG9mZnNldHMgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHBhcmFtIHtTdHJpbmd9IHBsYWNlbWVudCAtIG9uZSBvZiB0aGUgdmFsaWQgcGxhY2VtZW50IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IHBvcHBlck9mZnNldHMgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb2Zmc2V0cyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlclxuICovXG5mdW5jdGlvbiBnZXRQb3BwZXJPZmZzZXRzKHBvcHBlciwgcmVmZXJlbmNlT2Zmc2V0cywgcGxhY2VtZW50KSB7XG4gIHBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIC8vIEdldCBwb3BwZXIgbm9kZSBzaXplc1xuICB2YXIgcG9wcGVyUmVjdCA9IGdldE91dGVyU2l6ZXMocG9wcGVyKTtcblxuICAvLyBBZGQgcG9zaXRpb24sIHdpZHRoIGFuZCBoZWlnaHQgdG8gb3VyIG9mZnNldHMgb2JqZWN0XG4gIHZhciBwb3BwZXJPZmZzZXRzID0ge1xuICAgIHdpZHRoOiBwb3BwZXJSZWN0LndpZHRoLFxuICAgIGhlaWdodDogcG9wcGVyUmVjdC5oZWlnaHRcbiAgfTtcblxuICAvLyBkZXBlbmRpbmcgYnkgdGhlIHBvcHBlciBwbGFjZW1lbnQgd2UgaGF2ZSB0byBjb21wdXRlIGl0cyBvZmZzZXRzIHNsaWdodGx5IGRpZmZlcmVudGx5XG4gIHZhciBpc0hvcml6ID0gWydyaWdodCcsICdsZWZ0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIG1haW5TaWRlID0gaXNIb3JpeiA/ICd0b3AnIDogJ2xlZnQnO1xuICB2YXIgc2Vjb25kYXJ5U2lkZSA9IGlzSG9yaXogPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG1lYXN1cmVtZW50ID0gaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNlY29uZGFyeU1lYXN1cmVtZW50ID0gIWlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgcG9wcGVyT2Zmc2V0c1ttYWluU2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW21haW5TaWRlXSArIHJlZmVyZW5jZU9mZnNldHNbbWVhc3VyZW1lbnRdIC8gMiAtIHBvcHBlclJlY3RbbWVhc3VyZW1lbnRdIC8gMjtcbiAgaWYgKHBsYWNlbWVudCA9PT0gc2Vjb25kYXJ5U2lkZSkge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW3NlY29uZGFyeVNpZGVdIC0gcG9wcGVyUmVjdFtzZWNvbmRhcnlNZWFzdXJlbWVudF07XG4gIH0gZWxzZSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQoc2Vjb25kYXJ5U2lkZSldO1xuICB9XG5cbiAgcmV0dXJuIHBvcHBlck9mZnNldHM7XG59XG5cbi8qKlxuICogTWltaWNzIHRoZSBgZmluZGAgbWV0aG9kIG9mIEFycmF5XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAqIEBhcmd1bWVudCBwcm9wXG4gKiBAYXJndW1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIGluZGV4IG9yIC0xXG4gKi9cbmZ1bmN0aW9uIGZpbmQoYXJyLCBjaGVjaykge1xuICAvLyB1c2UgbmF0aXZlIGZpbmQgaWYgc3VwcG9ydGVkXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZCkge1xuICAgIHJldHVybiBhcnIuZmluZChjaGVjayk7XG4gIH1cblxuICAvLyB1c2UgYGZpbHRlcmAgdG8gb2J0YWluIHRoZSBzYW1lIGJlaGF2aW9yIG9mIGBmaW5kYFxuICByZXR1cm4gYXJyLmZpbHRlcihjaGVjaylbMF07XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hpbmcgb2JqZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAqIEBhcmd1bWVudCBwcm9wXG4gKiBAYXJndW1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIGluZGV4IG9yIC0xXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnIsIHByb3AsIHZhbHVlKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZEluZGV4IGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCkge1xuICAgIHJldHVybiBhcnIuZmluZEluZGV4KGZ1bmN0aW9uIChjdXIpIHtcbiAgICAgIHJldHVybiBjdXJbcHJvcF0gPT09IHZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gdXNlIGBmaW5kYCArIGBpbmRleE9mYCBpZiBgZmluZEluZGV4YCBpc24ndCBzdXBwb3J0ZWRcbiAgdmFyIG1hdGNoID0gZmluZChhcnIsIGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqW3Byb3BdID09PSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBhcnIuaW5kZXhPZihtYXRjaCk7XG59XG5cbi8qKlxuICogTG9vcCB0cm91Z2ggdGhlIGxpc3Qgb2YgbW9kaWZpZXJzIGFuZCBydW4gdGhlbSBpbiBvcmRlcixcbiAqIGVhY2ggb2YgdGhlbSB3aWxsIHRoZW4gZWRpdCB0aGUgZGF0YSBvYmplY3QuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyc1xuICogQHBhcmFtIHtTdHJpbmd9IGVuZHMgLSBPcHRpb25hbCBtb2RpZmllciBuYW1lIHVzZWQgYXMgc3RvcHBlclxuICogQHJldHVybnMge2RhdGFPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHJ1bk1vZGlmaWVycyhtb2RpZmllcnMsIGRhdGEsIGVuZHMpIHtcbiAgdmFyIG1vZGlmaWVyc1RvUnVuID0gZW5kcyA9PT0gdW5kZWZpbmVkID8gbW9kaWZpZXJzIDogbW9kaWZpZXJzLnNsaWNlKDAsIGZpbmRJbmRleChtb2RpZmllcnMsICduYW1lJywgZW5kcykpO1xuXG4gIG1vZGlmaWVyc1RvUnVuLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKG1vZGlmaWVyWydmdW5jdGlvbiddKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgICAgY29uc29sZS53YXJuKCdgbW9kaWZpZXIuZnVuY3Rpb25gIGlzIGRlcHJlY2F0ZWQsIHVzZSBgbW9kaWZpZXIuZm5gIScpO1xuICAgIH1cbiAgICB2YXIgZm4gPSBtb2RpZmllclsnZnVuY3Rpb24nXSB8fCBtb2RpZmllci5mbjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICBpZiAobW9kaWZpZXIuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgLy8gQWRkIHByb3BlcnRpZXMgdG8gb2Zmc2V0cyB0byBtYWtlIHRoZW0gYSBjb21wbGV0ZSBjbGllbnRSZWN0IG9iamVjdFxuICAgICAgLy8gd2UgZG8gdGhpcyBiZWZvcmUgZWFjaCBtb2RpZmllciB0byBtYWtlIHN1cmUgdGhlIHByZXZpb3VzIG9uZSBkb2Vzbid0XG4gICAgICAvLyBtZXNzIHdpdGggdGhlc2UgdmFsdWVzXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcbiAgICAgIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UpO1xuXG4gICAgICBkYXRhID0gZm4oZGF0YSwgbW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcHBlciwgY29tcHV0aW5nIHRoZSBuZXcgb2Zmc2V0cyBhbmQgYXBwbHlpbmdcbiAqIHRoZSBuZXcgc3R5bGUuPGJyIC8+XG4gKiBQcmVmZXIgYHNjaGVkdWxlVXBkYXRlYCBvdmVyIGB1cGRhdGVgIGJlY2F1c2Ugb2YgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gdXBkYXRlKCkge1xuICAvLyBpZiBwb3BwZXIgaXMgZGVzdHJveWVkLCBkb24ndCBwZXJmb3JtIGFueSBmdXJ0aGVyIHVwZGF0ZVxuICBpZiAodGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkYXRhID0ge1xuICAgIGluc3RhbmNlOiB0aGlzLFxuICAgIHN0eWxlczoge30sXG4gICAgYXJyb3dTdHlsZXM6IHt9LFxuICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgIGZsaXBwZWQ6IGZhbHNlLFxuICAgIG9mZnNldHM6IHt9XG4gIH07XG5cbiAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHRoaXMuc3RhdGUsIHRoaXMucG9wcGVyLCB0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIGNvbXB1dGUgYXV0byBwbGFjZW1lbnQsIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LFxuICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gIC8vIGFuZCByZWZlciB0byBvcmlnaW5hbFBsYWNlbWVudCB0byBrbm93IHRoZSBvcmlnaW5hbCB2YWx1ZVxuICBkYXRhLnBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KHRoaXMub3B0aW9ucy5wbGFjZW1lbnQsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIHRoaXMucG9wcGVyLCB0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LCB0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAucGFkZGluZyk7XG5cbiAgLy8gc3RvcmUgdGhlIGNvbXB1dGVkIHBsYWNlbWVudCBpbnNpZGUgYG9yaWdpbmFsUGxhY2VtZW50YFxuICBkYXRhLm9yaWdpbmFsUGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG5cbiAgZGF0YS5wb3NpdGlvbkZpeGVkID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQ7XG5cbiAgLy8gY29tcHV0ZSB0aGUgcG9wcGVyIG9mZnNldHNcbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldFBvcHBlck9mZnNldHModGhpcy5wb3BwZXIsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KTtcblxuICBkYXRhLm9mZnNldHMucG9wcGVyLnBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJztcblxuICAvLyBydW4gdGhlIG1vZGlmaWVyc1xuICBkYXRhID0gcnVuTW9kaWZpZXJzKHRoaXMubW9kaWZpZXJzLCBkYXRhKTtcblxuICAvLyB0aGUgZmlyc3QgYHVwZGF0ZWAgd2lsbCBjYWxsIGBvbkNyZWF0ZWAgY2FsbGJhY2tcbiAgLy8gdGhlIG90aGVyIG9uZXMgd2lsbCBjYWxsIGBvblVwZGF0ZWAgY2FsbGJhY2tcbiAgaWYgKCF0aGlzLnN0YXRlLmlzQ3JlYXRlZCkge1xuICAgIHRoaXMuc3RhdGUuaXNDcmVhdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMub25DcmVhdGUoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLm9uVXBkYXRlKGRhdGEpO1xuICB9XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgaXMgZW5hYmxlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vZGlmaWVyRW5hYmxlZChtb2RpZmllcnMsIG1vZGlmaWVyTmFtZSkge1xuICByZXR1cm4gbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgZW5hYmxlZCA9IF9yZWYuZW5hYmxlZDtcbiAgICByZXR1cm4gZW5hYmxlZCAmJiBuYW1lID09PSBtb2RpZmllck5hbWU7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJlZml4ZWQgc3VwcG9ydGVkIHByb3BlcnR5IG5hbWVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwcm9wZXJ0eSAoY2FtZWxDYXNlKVxuICogQHJldHVybnMge1N0cmluZ30gcHJlZml4ZWQgcHJvcGVydHkgKGNhbWVsQ2FzZSBvciBQYXNjYWxDYXNlLCBkZXBlbmRpbmcgb24gdGhlIHZlbmRvciBwcmVmaXgpXG4gKi9cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZShwcm9wZXJ0eSkge1xuICB2YXIgcHJlZml4ZXMgPSBbZmFsc2UsICdtcycsICdXZWJraXQnLCAnTW96JywgJ08nXTtcbiAgdmFyIHVwcGVyUHJvcCA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcmVmaXggPSBwcmVmaXhlc1tpXTtcbiAgICB2YXIgdG9DaGVjayA9IHByZWZpeCA/ICcnICsgcHJlZml4ICsgdXBwZXJQcm9wIDogcHJvcGVydHk7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudC5ib2R5LnN0eWxlW3RvQ2hlY2tdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRvQ2hlY2s7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIERlc3Ryb3kgdGhlIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkZXN0cm95KCkge1xuICB0aGlzLnN0YXRlLmlzRGVzdHJveWVkID0gdHJ1ZTtcblxuICAvLyB0b3VjaCBET00gb25seSBpZiBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgaXMgZW5hYmxlZFxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQodGhpcy5tb2RpZmllcnMsICdhcHBseVN0eWxlJykpIHtcbiAgICB0aGlzLnBvcHBlci5yZW1vdmVBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50Jyk7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS50b3AgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUucmlnaHQgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5ib3R0b20gPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS53aWxsQ2hhbmdlID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGVbZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKV0gPSAnJztcbiAgfVxuXG4gIHRoaXMuZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgLy8gcmVtb3ZlIHRoZSBwb3BwZXIgaWYgdXNlciBleHBsaWNpdHkgYXNrZWQgZm9yIHRoZSBkZWxldGlvbiBvbiBkZXN0cm95XG4gIC8vIGRvIG5vdCB1c2UgYHJlbW92ZWAgYmVjYXVzZSBJRTExIGRvZXNuJ3Qgc3VwcG9ydCBpdFxuICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZU9uRGVzdHJveSkge1xuICAgIHRoaXMucG9wcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wb3BwZXIpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEdldCB0aGUgd2luZG93IGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudFxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7V2luZG93fVxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coZWxlbWVudCkge1xuICB2YXIgb3duZXJEb2N1bWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogd2luZG93O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hUb1Njcm9sbFBhcmVudHMoc2Nyb2xsUGFyZW50LCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpIHtcbiAgdmFyIGlzQm9keSA9IHNjcm9sbFBhcmVudC5ub2RlTmFtZSA9PT0gJ0JPRFknO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gc2Nyb2xsUGFyZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiBzY3JvbGxQYXJlbnQ7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYWxsYmFjaywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gIGlmICghaXNCb2R5KSB7XG4gICAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKGdldFNjcm9sbFBhcmVudCh0YXJnZXQucGFyZW50Tm9kZSksIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cyk7XG4gIH1cbiAgc2Nyb2xsUGFyZW50cy5wdXNoKHRhcmdldCk7XG59XG5cbi8qKlxuICogU2V0dXAgbmVlZGVkIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXR1cEV2ZW50TGlzdGVuZXJzKHJlZmVyZW5jZSwgb3B0aW9ucywgc3RhdGUsIHVwZGF0ZUJvdW5kKSB7XG4gIC8vIFJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3dcbiAgc3RhdGUudXBkYXRlQm91bmQgPSB1cGRhdGVCb3VuZDtcbiAgZ2V0V2luZG93KHJlZmVyZW5jZSkuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3RhdGUudXBkYXRlQm91bmQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICAvLyBTY3JvbGwgZXZlbnQgbGlzdGVuZXIgb24gc2Nyb2xsIHBhcmVudHNcbiAgdmFyIHNjcm9sbEVsZW1lbnQgPSBnZXRTY3JvbGxQYXJlbnQocmVmZXJlbmNlKTtcbiAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbEVsZW1lbnQsICdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCwgc3RhdGUuc2Nyb2xsUGFyZW50cyk7XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBzY3JvbGxFbGVtZW50O1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gdHJ1ZTtcblxuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogSXQgd2lsbCBhZGQgcmVzaXplL3Njcm9sbCBldmVudHMgYW5kIHN0YXJ0IHJlY2FsY3VsYXRpbmdcbiAqIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIgZWxlbWVudCB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICghdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHNldHVwRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucywgdGhpcy5zdGF0ZSwgdGhpcy5zY2hlZHVsZVVwZGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHJlZmVyZW5jZSwgc3RhdGUpIHtcbiAgLy8gUmVtb3ZlIHJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3dcbiAgZ2V0V2luZG93KHJlZmVyZW5jZSkucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3RhdGUudXBkYXRlQm91bmQpO1xuXG4gIC8vIFJlbW92ZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIgb24gc2Nyb2xsIHBhcmVudHNcbiAgc3RhdGUuc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQpO1xuICB9KTtcblxuICAvLyBSZXNldCBzdGF0ZVxuICBzdGF0ZS51cGRhdGVCb3VuZCA9IG51bGw7XG4gIHN0YXRlLnNjcm9sbFBhcmVudHMgPSBbXTtcbiAgc3RhdGUuc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gIHN0YXRlLmV2ZW50c0VuYWJsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgcmVtb3ZlIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCB3b24ndCByZWNhbGN1bGF0ZSBwb3BwZXIgcG9zaXRpb25cbiAqIHdoZW4gdGhleSBhcmUgdHJpZ2dlcmVkLiBJdCBhbHNvIHdvbid0IHRyaWdnZXIgb25VcGRhdGUgY2FsbGJhY2sgYW55bW9yZSxcbiAqIHVubGVzcyB5b3UgY2FsbCBgdXBkYXRlYCBtZXRob2QgbWFudWFsbHkuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICAgIHRoaXMuc3RhdGUgPSByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5zdGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUZWxscyBpZiBhIGdpdmVuIGlucHV0IGlzIGEgbnVtYmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0geyp9IGlucHV0IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc051bWVyaWMobikge1xuICByZXR1cm4gbiAhPT0gJycgJiYgIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgc3R5bGUgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgc3R5bGUgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldFN0eWxlcyhlbGVtZW50LCBzdHlsZXMpIHtcbiAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHVuaXQgPSAnJztcbiAgICAvLyBhZGQgdW5pdCBpZiB0aGUgdmFsdWUgaXMgbnVtZXJpYyBhbmQgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmdcbiAgICBpZiAoWyd3aWR0aCcsICdoZWlnaHQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uaW5kZXhPZihwcm9wKSAhPT0gLTEgJiYgaXNOdW1lcmljKHN0eWxlc1twcm9wXSkpIHtcbiAgICAgIHVuaXQgPSAncHgnO1xuICAgIH1cbiAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gc3R5bGVzW3Byb3BdICsgdW5pdDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBhdHRyaWJ1dGVzIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIGF0dHJpYnV0ZXMgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICBpZiAodmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLnN0eWxlcyAtIExpc3Qgb2Ygc3R5bGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuYXR0cmlidXRlcyAtIExpc3Qgb2YgYXR0cmlidXRlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzYW1lIGRhdGEgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3R5bGUoZGF0YSkge1xuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5zdHlsZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyBpbiB0aGlzIHdheSB3ZSBjYW4gbWFrZSB0aGUgM3JkIHBhcnR5IG1vZGlmaWVycyBhZGQgY3VzdG9tIHN0eWxlcyB0byBpdFxuICAvLyBCZSBhd2FyZSwgbW9kaWZpZXJzIGNvdWxkIG92ZXJyaWRlIHRoZSBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhlIHByZXZpb3VzXG4gIC8vIGxpbmVzIG9mIHRoaXMgbW9kaWZpZXIhXG4gIHNldFN0eWxlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5zdHlsZXMpO1xuXG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLmF0dHJpYnV0ZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyB0aGV5IHdpbGwgYmUgc2V0IGFzIEhUTUwgYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudFxuICBzZXRBdHRyaWJ1dGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmF0dHJpYnV0ZXMpO1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBkZWZpbmVkIGFuZCBhcnJvd1N0eWxlcyBoYXMgc29tZSBwcm9wZXJ0aWVzXG4gIGlmIChkYXRhLmFycm93RWxlbWVudCAmJiBPYmplY3Qua2V5cyhkYXRhLmFycm93U3R5bGVzKS5sZW5ndGgpIHtcbiAgICBzZXRTdHlsZXMoZGF0YS5hcnJvd0VsZW1lbnQsIGRhdGEuYXJyb3dTdHlsZXMpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogU2V0IHRoZSB4LXBsYWNlbWVudCBhdHRyaWJ1dGUgYmVmb3JlIGV2ZXJ5dGhpbmcgZWxzZSBiZWNhdXNlIGl0IGNvdWxkIGJlIHVzZWRcbiAqIHRvIGFkZCBtYXJnaW5zIHRvIHRoZSBwb3BwZXIgbWFyZ2lucyBuZWVkcyB0byBiZSBjYWxjdWxhdGVkIHRvIGdldCB0aGVcbiAqIGNvcnJlY3QgcG9wcGVyIG9mZnNldHMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLm1vZGlmaWVyc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgZWxlbWVudCB1c2VkIGFzIHBvcHBlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBQb3BwZXIuanMgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlT25Mb2FkKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIHN0YXRlKSB7XG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICB2YXIgcmVmZXJlbmNlT2Zmc2V0cyA9IGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIGNvbXB1dGUgYXV0byBwbGFjZW1lbnQsIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LFxuICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gIC8vIGFuZCByZWZlciB0byBvcmlnaW5hbFBsYWNlbWVudCB0byBrbm93IHRoZSBvcmlnaW5hbCB2YWx1ZVxuICB2YXIgcGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQob3B0aW9ucy5wbGFjZW1lbnQsIHJlZmVyZW5jZU9mZnNldHMsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIHBvcHBlci5zZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JywgcGxhY2VtZW50KTtcblxuICAvLyBBcHBseSBgcG9zaXRpb25gIHRvIHBvcHBlciBiZWZvcmUgYW55dGhpbmcgZWxzZSBiZWNhdXNlXG4gIC8vIHdpdGhvdXQgdGhlIHBvc2l0aW9uIGFwcGxpZWQgd2UgY2FuJ3QgZ3VhcmFudGVlIGNvcnJlY3QgY29tcHV0YXRpb25zXG4gIHNldFN0eWxlcyhwb3BwZXIsIHsgcG9zaXRpb246IG9wdGlvbnMucG9zaXRpb25GaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnIH0pO1xuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlU3R5bGUoZGF0YSwgb3B0aW9ucykge1xuICB2YXIgeCA9IG9wdGlvbnMueCxcbiAgICAgIHkgPSBvcHRpb25zLnk7XG4gIHZhciBwb3BwZXIgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuXG4gIC8vIFJlbW92ZSB0aGlzIGxlZ2FjeSBzdXBwb3J0IGluIFBvcHBlci5qcyB2MlxuXG4gIHZhciBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gPSBmaW5kKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ2FwcGx5U3R5bGUnO1xuICB9KS5ncHVBY2NlbGVyYXRpb247XG4gIGlmIChsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnNvbGUud2FybignV0FSTklORzogYGdwdUFjY2VsZXJhdGlvbmAgb3B0aW9uIG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyIGFuZCB3aWxsIG5vdCBiZSBzdXBwb3J0ZWQgaW4gZnV0dXJlIHZlcnNpb25zIG9mIFBvcHBlci5qcyEnKTtcbiAgfVxuICB2YXIgZ3B1QWNjZWxlcmF0aW9uID0gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQgPyBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gOiBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbjtcblxuICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgdmFyIG9mZnNldFBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcblxuICAvLyBTdHlsZXNcbiAgdmFyIHN0eWxlcyA9IHtcbiAgICBwb3NpdGlvbjogcG9wcGVyLnBvc2l0aW9uXG4gIH07XG5cbiAgLy8gQXZvaWQgYmx1cnJ5IHRleHQgYnkgdXNpbmcgZnVsbCBwaXhlbCBpbnRlZ2Vycy5cbiAgLy8gRm9yIHBpeGVsLXBlcmZlY3QgcG9zaXRpb25pbmcsIHRvcC9ib3R0b20gcHJlZmVycyByb3VuZGVkXG4gIC8vIHZhbHVlcywgd2hpbGUgbGVmdC9yaWdodCBwcmVmZXJzIGZsb29yZWQgdmFsdWVzLlxuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICBsZWZ0OiBNYXRoLmZsb29yKHBvcHBlci5sZWZ0KSxcbiAgICB0b3A6IE1hdGgucm91bmQocG9wcGVyLnRvcCksXG4gICAgYm90dG9tOiBNYXRoLnJvdW5kKHBvcHBlci5ib3R0b20pLFxuICAgIHJpZ2h0OiBNYXRoLmZsb29yKHBvcHBlci5yaWdodClcbiAgfTtcblxuICB2YXIgc2lkZUEgPSB4ID09PSAnYm90dG9tJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gIHZhciBzaWRlQiA9IHkgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuXG4gIC8vIGlmIGdwdUFjY2VsZXJhdGlvbiBpcyBzZXQgdG8gYHRydWVgIGFuZCB0cmFuc2Zvcm0gaXMgc3VwcG9ydGVkLFxuICAvLyAgd2UgdXNlIGB0cmFuc2xhdGUzZGAgdG8gYXBwbHkgdGhlIHBvc2l0aW9uIHRvIHRoZSBwb3BwZXIgd2VcbiAgLy8gYXV0b21hdGljYWxseSB1c2UgdGhlIHN1cHBvcnRlZCBwcmVmaXhlZCB2ZXJzaW9uIGlmIG5lZWRlZFxuICB2YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyk7XG5cbiAgLy8gbm93LCBsZXQncyBtYWtlIGEgc3RlcCBiYWNrIGFuZCBsb29rIGF0IHRoaXMgY29kZSBjbG9zZWx5ICh3dGY/KVxuICAvLyBJZiB0aGUgY29udGVudCBvZiB0aGUgcG9wcGVyIGdyb3dzIG9uY2UgaXQncyBiZWVuIHBvc2l0aW9uZWQsIGl0XG4gIC8vIG1heSBoYXBwZW4gdGhhdCB0aGUgcG9wcGVyIGdldHMgbWlzcGxhY2VkIGJlY2F1c2Ugb2YgdGhlIG5ldyBjb250ZW50XG4gIC8vIG92ZXJmbG93aW5nIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUbyBhdm9pZCB0aGlzIHByb2JsZW0sIHdlIHByb3ZpZGUgdHdvIG9wdGlvbnMgKHggYW5kIHkpLCB3aGljaCBhbGxvd1xuICAvLyB0aGUgY29uc3VtZXIgdG8gZGVmaW5lIHRoZSBvZmZzZXQgb3JpZ2luLlxuICAvLyBJZiB3ZSBwb3NpdGlvbiBhIHBvcHBlciBvbiB0b3Agb2YgYSByZWZlcmVuY2UgZWxlbWVudCwgd2UgY2FuIHNldFxuICAvLyBgeGAgdG8gYHRvcGAgdG8gbWFrZSB0aGUgcG9wcGVyIGdyb3cgdG93YXJkcyBpdHMgdG9wIGluc3RlYWQgb2ZcbiAgLy8gaXRzIGJvdHRvbS5cbiAgdmFyIGxlZnQgPSB2b2lkIDAsXG4gICAgICB0b3AgPSB2b2lkIDA7XG4gIGlmIChzaWRlQSA9PT0gJ2JvdHRvbScpIHtcbiAgICB0b3AgPSAtb2Zmc2V0UGFyZW50UmVjdC5oZWlnaHQgKyBvZmZzZXRzLmJvdHRvbTtcbiAgfSBlbHNlIHtcbiAgICB0b3AgPSBvZmZzZXRzLnRvcDtcbiAgfVxuICBpZiAoc2lkZUIgPT09ICdyaWdodCcpIHtcbiAgICBsZWZ0ID0gLW9mZnNldFBhcmVudFJlY3Qud2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICB9IGVsc2Uge1xuICAgIGxlZnQgPSBvZmZzZXRzLmxlZnQ7XG4gIH1cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbiAmJiBwcmVmaXhlZFByb3BlcnR5KSB7XG4gICAgc3R5bGVzW3ByZWZpeGVkUHJvcGVydHldID0gJ3RyYW5zbGF0ZTNkKCcgKyBsZWZ0ICsgJ3B4LCAnICsgdG9wICsgJ3B4LCAwKSc7XG4gICAgc3R5bGVzW3NpZGVBXSA9IDA7XG4gICAgc3R5bGVzW3NpZGVCXSA9IDA7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSAndHJhbnNmb3JtJztcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGh3ZXJpc2UsIHdlIHVzZSB0aGUgc3RhbmRhcmQgYHRvcGAsIGBsZWZ0YCwgYGJvdHRvbWAgYW5kIGByaWdodGAgcHJvcGVydGllc1xuICAgIHZhciBpbnZlcnRUb3AgPSBzaWRlQSA9PT0gJ2JvdHRvbScgPyAtMSA6IDE7XG4gICAgdmFyIGludmVydExlZnQgPSBzaWRlQiA9PT0gJ3JpZ2h0JyA/IC0xIDogMTtcbiAgICBzdHlsZXNbc2lkZUFdID0gdG9wICogaW52ZXJ0VG9wO1xuICAgIHN0eWxlc1tzaWRlQl0gPSBsZWZ0ICogaW52ZXJ0TGVmdDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9IHNpZGVBICsgJywgJyArIHNpZGVCO1xuICB9XG5cbiAgLy8gQXR0cmlidXRlc1xuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAneC1wbGFjZW1lbnQnOiBkYXRhLnBsYWNlbWVudFxuICB9O1xuXG4gIC8vIFVwZGF0ZSBgZGF0YWAgYXR0cmlidXRlcywgc3R5bGVzIGFuZCBhcnJvd1N0eWxlc1xuICBkYXRhLmF0dHJpYnV0ZXMgPSBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywgZGF0YS5hdHRyaWJ1dGVzKTtcbiAgZGF0YS5zdHlsZXMgPSBfZXh0ZW5kcyh7fSwgc3R5bGVzLCBkYXRhLnN0eWxlcyk7XG4gIGRhdGEuYXJyb3dTdHlsZXMgPSBfZXh0ZW5kcyh7fSwgZGF0YS5vZmZzZXRzLmFycm93LCBkYXRhLmFycm93U3R5bGVzKTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBkZXBlbmRzIGZyb20gYW5vdGhlciBvbmUuPGJyIC8+XG4gKiBJdCBjaGVja3MgaWYgdGhlIG5lZWRlZCBtb2RpZmllciBpcyBsaXN0ZWQgYW5kIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnMgLSBsaXN0IG9mIG1vZGlmaWVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RpbmdOYW1lIC0gbmFtZSBvZiByZXF1ZXN0aW5nIG1vZGlmaWVyXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGVkTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGVkIG1vZGlmaWVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllclJlcXVpcmVkKG1vZGlmaWVycywgcmVxdWVzdGluZ05hbWUsIHJlcXVlc3RlZE5hbWUpIHtcbiAgdmFyIHJlcXVlc3RpbmcgPSBmaW5kKG1vZGlmaWVycywgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICByZXR1cm4gbmFtZSA9PT0gcmVxdWVzdGluZ05hbWU7XG4gIH0pO1xuXG4gIHZhciBpc1JlcXVpcmVkID0gISFyZXF1ZXN0aW5nICYmIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSByZXF1ZXN0ZWROYW1lICYmIG1vZGlmaWVyLmVuYWJsZWQgJiYgbW9kaWZpZXIub3JkZXIgPCByZXF1ZXN0aW5nLm9yZGVyO1xuICB9KTtcblxuICBpZiAoIWlzUmVxdWlyZWQpIHtcbiAgICB2YXIgX3JlcXVlc3RpbmcgPSAnYCcgKyByZXF1ZXN0aW5nTmFtZSArICdgJztcbiAgICB2YXIgcmVxdWVzdGVkID0gJ2AnICsgcmVxdWVzdGVkTmFtZSArICdgJztcbiAgICBjb25zb2xlLndhcm4ocmVxdWVzdGVkICsgJyBtb2RpZmllciBpcyByZXF1aXJlZCBieSAnICsgX3JlcXVlc3RpbmcgKyAnIG1vZGlmaWVyIGluIG9yZGVyIHRvIHdvcmssIGJlIHN1cmUgdG8gaW5jbHVkZSBpdCBiZWZvcmUgJyArIF9yZXF1ZXN0aW5nICsgJyEnKTtcbiAgfVxuICByZXR1cm4gaXNSZXF1aXJlZDtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGFycm93KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMkYXJyb3c7XG5cbiAgLy8gYXJyb3cgZGVwZW5kcyBvbiBrZWVwVG9nZXRoZXIgaW4gb3JkZXIgdG8gd29ya1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2Fycm93JywgJ2tlZXBUb2dldGhlcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYXJyb3dFbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBhIHN0cmluZywgc3VwcG9zZSBpdCdzIGEgQ1NTIHNlbGVjdG9yXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIC8vIGlmIGFycm93RWxlbWVudCBpcyBub3QgZm91bmQsIGRvbid0IHJ1biB0aGUgbW9kaWZpZXJcbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGlmIHRoZSBhcnJvd0VsZW1lbnQgaXNuJ3QgYSBxdWVyeSBzZWxlY3RvciB3ZSBtdXN0IGNoZWNrIHRoYXQgdGhlXG4gICAgLy8gcHJvdmlkZWQgRE9NIG5vZGUgaXMgY2hpbGQgb2YgaXRzIHBvcHBlciBub2RlXG4gICAgaWYgKCFkYXRhLmluc3RhbmNlLnBvcHBlci5jb250YWlucyhhcnJvd0VsZW1lbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBhcnJvdy5lbGVtZW50YCBtdXN0IGJlIGNoaWxkIG9mIGl0cyBwb3BwZXIgZWxlbWVudCEnKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzVmVydGljYWwgPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuXG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICB2YXIgc2lkZUNhcGl0YWxpemVkID0gaXNWZXJ0aWNhbCA/ICdUb3AnIDogJ0xlZnQnO1xuICB2YXIgc2lkZSA9IHNpZGVDYXBpdGFsaXplZC50b0xvd2VyQ2FzZSgpO1xuICB2YXIgYWx0U2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gIHZhciBhcnJvd0VsZW1lbnRTaXplID0gZ2V0T3V0ZXJTaXplcyhhcnJvd0VsZW1lbnQpW2xlbl07XG5cbiAgLy9cbiAgLy8gZXh0ZW5kcyBrZWVwVG9nZXRoZXIgYmVoYXZpb3IgbWFraW5nIHN1cmUgdGhlIHBvcHBlciBhbmQgaXRzXG4gIC8vIHJlZmVyZW5jZSBoYXZlIGVub3VnaCBwaXhlbHMgaW4gY29uanVjdGlvblxuICAvL1xuXG4gIC8vIHRvcC9sZWZ0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSA8IHBvcHBlcltzaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLT0gcG9wcGVyW3NpZGVdIC0gKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSk7XG4gIH1cbiAgLy8gYm90dG9tL3JpZ2h0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgPiBwb3BwZXJbb3BTaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gKz0gcmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSAtIHBvcHBlcltvcFNpZGVdO1xuICB9XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuXG4gIC8vIGNvbXB1dGUgY2VudGVyIG9mIHRoZSBwb3BwZXJcbiAgdmFyIGNlbnRlciA9IHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVtsZW5dIC8gMiAtIGFycm93RWxlbWVudFNpemUgLyAyO1xuXG4gIC8vIENvbXB1dGUgdGhlIHNpZGVWYWx1ZSB1c2luZyB0aGUgdXBkYXRlZCBwb3BwZXIgb2Zmc2V0c1xuICAvLyB0YWtlIHBvcHBlciBtYXJnaW4gaW4gYWNjb3VudCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgdGhpcyBpbmZvIGF2YWlsYWJsZVxuICB2YXIgY3NzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgdmFyIHBvcHBlck1hcmdpblNpZGUgPSBwYXJzZUZsb2F0KGNzc1snbWFyZ2luJyArIHNpZGVDYXBpdGFsaXplZF0sIDEwKTtcbiAgdmFyIHBvcHBlckJvcmRlclNpZGUgPSBwYXJzZUZsb2F0KGNzc1snYm9yZGVyJyArIHNpZGVDYXBpdGFsaXplZCArICdXaWR0aCddLCAxMCk7XG4gIHZhciBzaWRlVmFsdWUgPSBjZW50ZXIgLSBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC0gcG9wcGVyTWFyZ2luU2lkZSAtIHBvcHBlckJvcmRlclNpZGU7XG5cbiAgLy8gcHJldmVudCBhcnJvd0VsZW1lbnQgZnJvbSBiZWluZyBwbGFjZWQgbm90IGNvbnRpZ3VvdXNseSB0byBpdHMgcG9wcGVyXG4gIHNpZGVWYWx1ZSA9IE1hdGgubWF4KE1hdGgubWluKHBvcHBlcltsZW5dIC0gYXJyb3dFbGVtZW50U2l6ZSwgc2lkZVZhbHVlKSwgMCk7XG5cbiAgZGF0YS5hcnJvd0VsZW1lbnQgPSBhcnJvd0VsZW1lbnQ7XG4gIGRhdGEub2Zmc2V0cy5hcnJvdyA9IChfZGF0YSRvZmZzZXRzJGFycm93ID0ge30sIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIHNpZGUsIE1hdGgucm91bmQoc2lkZVZhbHVlKSksIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIGFsdFNpZGUsICcnKSwgX2RhdGEkb2Zmc2V0cyRhcnJvdyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgdmFyaWF0aW9uIG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudCB2YXJpYXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKSB7XG4gIGlmICh2YXJpYXRpb24gPT09ICdlbmQnKSB7XG4gICAgcmV0dXJuICdzdGFydCc7XG4gIH0gZWxzZSBpZiAodmFyaWF0aW9uID09PSAnc3RhcnQnKSB7XG4gICAgcmV0dXJuICdlbmQnO1xuICB9XG4gIHJldHVybiB2YXJpYXRpb247XG59XG5cbi8qKlxuICogTGlzdCBvZiBhY2NlcHRlZCBwbGFjZW1lbnRzIHRvIHVzZSBhcyB2YWx1ZXMgb2YgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbi48YnIgLz5cbiAqIFZhbGlkIHBsYWNlbWVudHMgYXJlOlxuICogLSBgYXV0b2BcbiAqIC0gYHRvcGBcbiAqIC0gYHJpZ2h0YFxuICogLSBgYm90dG9tYFxuICogLSBgbGVmdGBcbiAqXG4gKiBFYWNoIHBsYWNlbWVudCBjYW4gaGF2ZSBhIHZhcmlhdGlvbiBmcm9tIHRoaXMgbGlzdDpcbiAqIC0gYC1zdGFydGBcbiAqIC0gYC1lbmRgXG4gKlxuICogVmFyaWF0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgZWFzaWx5IGlmIHlvdSB0aGluayBvZiB0aGVtIGFzIHRoZSBsZWZ0IHRvIHJpZ2h0XG4gKiB3cml0dGVuIGxhbmd1YWdlcy4gSG9yaXpvbnRhbGx5IChgdG9wYCBhbmQgYGJvdHRvbWApLCBgc3RhcnRgIGlzIGxlZnQgYW5kIGBlbmRgXG4gKiBpcyByaWdodC48YnIgLz5cbiAqIFZlcnRpY2FsbHkgKGBsZWZ0YCBhbmQgYHJpZ2h0YCksIGBzdGFydGAgaXMgdG9wIGFuZCBgZW5kYCBpcyBib3R0b20uXG4gKlxuICogU29tZSB2YWxpZCBleGFtcGxlcyBhcmU6XG4gKiAtIGB0b3AtZW5kYCAob24gdG9wIG9mIHJlZmVyZW5jZSwgcmlnaHQgYWxpZ25lZClcbiAqIC0gYHJpZ2h0LXN0YXJ0YCAob24gcmlnaHQgb2YgcmVmZXJlbmNlLCB0b3AgYWxpZ25lZClcbiAqIC0gYGJvdHRvbWAgKG9uIGJvdHRvbSwgY2VudGVyZWQpXG4gKiAtIGBhdXRvLXJpZ2h0YCAob24gdGhlIHNpZGUgd2l0aCBtb3JlIHNwYWNlIGF2YWlsYWJsZSwgYWxpZ25tZW50IGRlcGVuZHMgYnkgcGxhY2VtZW50KVxuICpcbiAqIEBzdGF0aWNcbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBlbnVtIHtTdHJpbmd9XG4gKiBAcmVhZG9ubHlcbiAqIEBtZXRob2QgcGxhY2VtZW50c1xuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG52YXIgcGxhY2VtZW50cyA9IFsnYXV0by1zdGFydCcsICdhdXRvJywgJ2F1dG8tZW5kJywgJ3RvcC1zdGFydCcsICd0b3AnLCAndG9wLWVuZCcsICdyaWdodC1zdGFydCcsICdyaWdodCcsICdyaWdodC1lbmQnLCAnYm90dG9tLWVuZCcsICdib3R0b20nLCAnYm90dG9tLXN0YXJ0JywgJ2xlZnQtZW5kJywgJ2xlZnQnLCAnbGVmdC1zdGFydCddO1xuXG4vLyBHZXQgcmlkIG9mIGBhdXRvYCBgYXV0by1zdGFydGAgYW5kIGBhdXRvLWVuZGBcbnZhciB2YWxpZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLnNsaWNlKDMpO1xuXG4vKipcbiAqIEdpdmVuIGFuIGluaXRpYWwgcGxhY2VtZW50LCByZXR1cm5zIGFsbCB0aGUgc3Vic2VxdWVudCBwbGFjZW1lbnRzXG4gKiBjbG9ja3dpc2UgKG9yIGNvdW50ZXItY2xvY2t3aXNlKS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IC0gQSB2YWxpZCBwbGFjZW1lbnQgKGl0IGFjY2VwdHMgdmFyaWF0aW9ucylcbiAqIEBhcmd1bWVudCB7Qm9vbGVhbn0gY291bnRlciAtIFNldCB0byB0cnVlIHRvIHdhbGsgdGhlIHBsYWNlbWVudHMgY291bnRlcmNsb2Nrd2lzZVxuICogQHJldHVybnMge0FycmF5fSBwbGFjZW1lbnRzIGluY2x1ZGluZyB0aGVpciB2YXJpYXRpb25zXG4gKi9cbmZ1bmN0aW9uIGNsb2Nrd2lzZShwbGFjZW1lbnQpIHtcbiAgdmFyIGNvdW50ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBpbmRleCA9IHZhbGlkUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCk7XG4gIHZhciBhcnIgPSB2YWxpZFBsYWNlbWVudHMuc2xpY2UoaW5kZXggKyAxKS5jb25jYXQodmFsaWRQbGFjZW1lbnRzLnNsaWNlKDAsIGluZGV4KSk7XG4gIHJldHVybiBjb3VudGVyID8gYXJyLnJldmVyc2UoKSA6IGFycjtcbn1cblxudmFyIEJFSEFWSU9SUyA9IHtcbiAgRkxJUDogJ2ZsaXAnLFxuICBDTE9DS1dJU0U6ICdjbG9ja3dpc2UnLFxuICBDT1VOVEVSQ0xPQ0tXSVNFOiAnY291bnRlcmNsb2Nrd2lzZSdcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBmbGlwKGRhdGEsIG9wdGlvbnMpIHtcbiAgLy8gaWYgYGlubmVyYCBtb2RpZmllciBpcyBlbmFibGVkLCB3ZSBjYW4ndCB1c2UgdGhlIGBmbGlwYCBtb2RpZmllclxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdpbm5lcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBpZiAoZGF0YS5mbGlwcGVkICYmIGRhdGEucGxhY2VtZW50ID09PSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50KSB7XG4gICAgLy8gc2VlbXMgbGlrZSBmbGlwIGlzIHRyeWluZyB0byBsb29wLCBwcm9iYWJseSB0aGVyZSdzIG5vdCBlbm91Z2ggc3BhY2Ugb24gYW55IG9mIHRoZSBmbGlwcGFibGUgc2lkZXNcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UsIG9wdGlvbnMucGFkZGluZywgb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCwgZGF0YS5wb3NpdGlvbkZpeGVkKTtcblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMV0gfHwgJyc7XG5cbiAgdmFyIGZsaXBPcmRlciA9IFtdO1xuXG4gIHN3aXRjaCAob3B0aW9ucy5iZWhhdmlvcikge1xuICAgIGNhc2UgQkVIQVZJT1JTLkZMSVA6XG4gICAgICBmbGlwT3JkZXIgPSBbcGxhY2VtZW50LCBwbGFjZW1lbnRPcHBvc2l0ZV07XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNPVU5URVJDTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50LCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBmbGlwT3JkZXIgPSBvcHRpb25zLmJlaGF2aW9yO1xuICB9XG5cbiAgZmxpcE9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHN0ZXAsIGluZGV4KSB7XG4gICAgaWYgKHBsYWNlbWVudCAhPT0gc3RlcCB8fCBmbGlwT3JkZXIubGVuZ3RoID09PSBpbmRleCArIDEpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gICAgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIHBvcHBlck9mZnNldHMgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuICAgIHZhciByZWZPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcblxuICAgIC8vIHVzaW5nIGZsb29yIGJlY2F1c2UgdGhlIHJlZmVyZW5jZSBvZmZzZXRzIG1heSBjb250YWluIGRlY2ltYWxzIHdlIGFyZSBub3QgZ29pbmcgdG8gY29uc2lkZXIgaGVyZVxuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgdmFyIG92ZXJsYXBzUmVmID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihyZWZPZmZzZXRzLmxlZnQpIHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IocmVmT2Zmc2V0cy5yaWdodCkgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihyZWZPZmZzZXRzLnRvcCkgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihyZWZPZmZzZXRzLmJvdHRvbSk7XG5cbiAgICB2YXIgb3ZlcmZsb3dzTGVmdCA9IGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihib3VuZGFyaWVzLmxlZnQpO1xuICAgIHZhciBvdmVyZmxvd3NSaWdodCA9IGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IoYm91bmRhcmllcy5yaWdodCk7XG4gICAgdmFyIG92ZXJmbG93c1RvcCA9IGZsb29yKHBvcHBlck9mZnNldHMudG9wKSA8IGZsb29yKGJvdW5kYXJpZXMudG9wKTtcbiAgICB2YXIgb3ZlcmZsb3dzQm90dG9tID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IoYm91bmRhcmllcy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0JvdW5kYXJpZXMgPSBwbGFjZW1lbnQgPT09ICdsZWZ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBvdmVyZmxvd3NSaWdodCB8fCBwbGFjZW1lbnQgPT09ICd0b3AnICYmIG92ZXJmbG93c1RvcCB8fCBwbGFjZW1lbnQgPT09ICdib3R0b20nICYmIG92ZXJmbG93c0JvdHRvbTtcblxuICAgIC8vIGZsaXAgdGhlIHZhcmlhdGlvbiBpZiByZXF1aXJlZFxuICAgIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbiA9ICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyAmJiAoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c1RvcCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c0JvdHRvbSk7XG5cbiAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcyB8fCBmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAvLyB0aGlzIGJvb2xlYW4gdG8gZGV0ZWN0IGFueSBmbGlwIGxvb3BcbiAgICAgIGRhdGEuZmxpcHBlZCA9IHRydWU7XG5cbiAgICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzKSB7XG4gICAgICAgIHBsYWNlbWVudCA9IGZsaXBPcmRlcltpbmRleCArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgICB2YXJpYXRpb24gPSBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnBsYWNlbWVudCA9IHBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG5cbiAgICAgIC8vIHRoaXMgb2JqZWN0IGNvbnRhaW5zIGBwb3NpdGlvbmAsIHdlIHdhbnQgdG8gcHJlc2VydmUgaXQgYWxvbmcgd2l0aFxuICAgICAgLy8gYW55IGFkZGl0aW9uYWwgcHJvcGVydHkgd2UgbWF5IGFkZCBpbiB0aGUgZnV0dXJlXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5wb3BwZXIsIGdldFBvcHBlck9mZnNldHMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KSk7XG5cbiAgICAgIGRhdGEgPSBydW5Nb2RpZmllcnMoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGRhdGEsICdmbGlwJyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBrZWVwVG9nZXRoZXIoZGF0YSkge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ3JpZ2h0JyA6ICdib3R0b20nO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gIGlmIChwb3BwZXJbc2lkZV0gPCBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkgLSBwb3BwZXJbbWVhc3VyZW1lbnRdO1xuICB9XG4gIGlmIChwb3BwZXJbb3BTaWRlXSA+IGZsb29yKHJlZmVyZW5jZVtzaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgY29udGFpbmluZyB2YWx1ZSArIHVuaXQgaW50byBhIHB4IHZhbHVlIG51bWJlclxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHN0ciAtIFZhbHVlICsgdW5pdCBzdHJpbmdcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBtZWFzdXJlbWVudCAtIGBoZWlnaHRgIG9yIGB3aWR0aGBcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICogQHJldHVybnMge051bWJlcnxTdHJpbmd9XG4gKiBWYWx1ZSBpbiBwaXhlbHMsIG9yIG9yaWdpbmFsIHN0cmluZyBpZiBubyB2YWx1ZXMgd2VyZSBleHRyYWN0ZWRcbiAqL1xuZnVuY3Rpb24gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKSB7XG4gIC8vIHNlcGFyYXRlIHZhbHVlIGZyb20gdW5pdFxuICB2YXIgc3BsaXQgPSBzdHIubWF0Y2goLygoPzpcXC18XFwrKT9cXGQqXFwuP1xcZCopKC4qKS8pO1xuICB2YXIgdmFsdWUgPSArc3BsaXRbMV07XG4gIHZhciB1bml0ID0gc3BsaXRbMl07XG5cbiAgLy8gSWYgaXQncyBub3QgYSBudW1iZXIgaXQncyBhbiBvcGVyYXRvciwgSSBndWVzc1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGlmICh1bml0LmluZGV4T2YoJyUnKSA9PT0gMCkge1xuICAgIHZhciBlbGVtZW50ID0gdm9pZCAwO1xuICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgY2FzZSAnJXAnOlxuICAgICAgICBlbGVtZW50ID0gcG9wcGVyT2Zmc2V0cztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICclJzpcbiAgICAgIGNhc2UgJyVyJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVsZW1lbnQgPSByZWZlcmVuY2VPZmZzZXRzO1xuICAgIH1cblxuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdChlbGVtZW50KTtcbiAgICByZXR1cm4gcmVjdFttZWFzdXJlbWVudF0gLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIGlmICh1bml0ID09PSAndmgnIHx8IHVuaXQgPT09ICd2dycpIHtcbiAgICAvLyBpZiBpcyBhIHZoIG9yIHZ3LCB3ZSBjYWxjdWxhdGUgdGhlIHNpemUgYmFzZWQgb24gdGhlIHZpZXdwb3J0XG4gICAgdmFyIHNpemUgPSB2b2lkIDA7XG4gICAgaWYgKHVuaXQgPT09ICd2aCcpIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZSAvIDEwMCAqIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIC8vIGlmIGlzIGFuIGV4cGxpY2l0IHBpeGVsIHVuaXQsIHdlIGdldCByaWQgb2YgdGhlIHVuaXQgYW5kIGtlZXAgdGhlIHZhbHVlXG4gICAgLy8gaWYgaXMgYW4gaW1wbGljaXQgdW5pdCwgaXQncyBweCwgYW5kIHdlIHJldHVybiBqdXN0IHRoZSB2YWx1ZVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGFuIGBvZmZzZXRgIHN0cmluZyB0byBleHRyYXBvbGF0ZSBgeGAgYW5kIGB5YCBudW1lcmljIG9mZnNldHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gb2Zmc2V0XG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBiYXNlUGxhY2VtZW50XG4gKiBAcmV0dXJucyB7QXJyYXl9IGEgdHdvIGNlbGxzIGFycmF5IHdpdGggeCBhbmQgeSBvZmZzZXRzIGluIG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzLCBiYXNlUGxhY2VtZW50KSB7XG4gIHZhciBvZmZzZXRzID0gWzAsIDBdO1xuXG4gIC8vIFVzZSBoZWlnaHQgaWYgcGxhY2VtZW50IGlzIGxlZnQgb3IgcmlnaHQgYW5kIGluZGV4IGlzIDAgb3RoZXJ3aXNlIHVzZSB3aWR0aFxuICAvLyBpbiB0aGlzIHdheSB0aGUgZmlyc3Qgb2Zmc2V0IHdpbGwgdXNlIGFuIGF4aXMgYW5kIHRoZSBzZWNvbmQgb25lXG4gIC8vIHdpbGwgdXNlIHRoZSBvdGhlciBvbmVcbiAgdmFyIHVzZUhlaWdodCA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIC8vIFNwbGl0IHRoZSBvZmZzZXQgc3RyaW5nIHRvIG9idGFpbiBhIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kc1xuICAvLyBUaGUgcmVnZXggYWRkcmVzc2VzIHZhbHVlcyB3aXRoIHRoZSBwbHVzIG9yIG1pbnVzIHNpZ24gaW4gZnJvbnQgKCsxMCwgLTIwLCBldGMpXG4gIHZhciBmcmFnbWVudHMgPSBvZmZzZXQuc3BsaXQoLyhcXCt8XFwtKS8pLm1hcChmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnRyaW0oKTtcbiAgfSk7XG5cbiAgLy8gRGV0ZWN0IGlmIHRoZSBvZmZzZXQgc3RyaW5nIGNvbnRhaW5zIGEgcGFpciBvZiB2YWx1ZXMgb3IgYSBzaW5nbGUgb25lXG4gIC8vIHRoZXkgY291bGQgYmUgc2VwYXJhdGVkIGJ5IGNvbW1hIG9yIHNwYWNlXG4gIHZhciBkaXZpZGVyID0gZnJhZ21lbnRzLmluZGV4T2YoZmluZChmcmFnbWVudHMsIGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgcmV0dXJuIGZyYWcuc2VhcmNoKC8sfFxccy8pICE9PSAtMTtcbiAgfSkpO1xuXG4gIGlmIChmcmFnbWVudHNbZGl2aWRlcl0gJiYgZnJhZ21lbnRzW2RpdmlkZXJdLmluZGV4T2YoJywnKSA9PT0gLTEpIHtcbiAgICBjb25zb2xlLndhcm4oJ09mZnNldHMgc2VwYXJhdGVkIGJ5IHdoaXRlIHNwYWNlKHMpIGFyZSBkZXByZWNhdGVkLCB1c2UgYSBjb21tYSAoLCkgaW5zdGVhZC4nKTtcbiAgfVxuXG4gIC8vIElmIGRpdmlkZXIgaXMgZm91bmQsIHdlIGRpdmlkZSB0aGUgbGlzdCBvZiB2YWx1ZXMgYW5kIG9wZXJhbmRzIHRvIGRpdmlkZVxuICAvLyB0aGVtIGJ5IG9mc2V0IFggYW5kIFkuXG4gIHZhciBzcGxpdFJlZ2V4ID0gL1xccyosXFxzKnxcXHMrLztcbiAgdmFyIG9wcyA9IGRpdmlkZXIgIT09IC0xID8gW2ZyYWdtZW50cy5zbGljZSgwLCBkaXZpZGVyKS5jb25jYXQoW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVswXV0pLCBbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzFdXS5jb25jYXQoZnJhZ21lbnRzLnNsaWNlKGRpdmlkZXIgKyAxKSldIDogW2ZyYWdtZW50c107XG5cbiAgLy8gQ29udmVydCB0aGUgdmFsdWVzIHdpdGggdW5pdHMgdG8gYWJzb2x1dGUgcGl4ZWxzIHRvIGFsbG93IG91ciBjb21wdXRhdGlvbnNcbiAgb3BzID0gb3BzLm1hcChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgLy8gTW9zdCBvZiB0aGUgdW5pdHMgcmVseSBvbiB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHBvcHBlclxuICAgIHZhciBtZWFzdXJlbWVudCA9IChpbmRleCA9PT0gMSA/ICF1c2VIZWlnaHQgOiB1c2VIZWlnaHQpID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgIHJldHVybiBvcFxuICAgIC8vIFRoaXMgYWdncmVnYXRlcyBhbnkgYCtgIG9yIGAtYCBzaWduIHRoYXQgYXJlbid0IGNvbnNpZGVyZWQgb3BlcmF0b3JzXG4gICAgLy8gZS5nLjogMTAgKyArNSA9PiBbMTAsICssICs1XVxuICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGlmIChhW2EubGVuZ3RoIC0gMV0gPT09ICcnICYmIFsnKycsICctJ10uaW5kZXhPZihiKSAhPT0gLTEpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdID0gYjtcbiAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSBpZiAobWVyZ2VXaXRoUHJldmlvdXMpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdICs9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgfVxuICAgIH0sIFtdKVxuICAgIC8vIEhlcmUgd2UgY29udmVydCB0aGUgc3RyaW5nIHZhbHVlcyBpbnRvIG51bWJlciB2YWx1ZXMgKGluIHB4KVxuICAgIC5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIExvb3AgdHJvdWdoIHRoZSBvZmZzZXRzIGFycmF5cyBhbmQgZXhlY3V0ZSB0aGUgb3BlcmF0aW9uc1xuICBvcHMuZm9yRWFjaChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgb3AuZm9yRWFjaChmdW5jdGlvbiAoZnJhZywgaW5kZXgyKSB7XG4gICAgICBpZiAoaXNOdW1lcmljKGZyYWcpKSB7XG4gICAgICAgIG9mZnNldHNbaW5kZXhdICs9IGZyYWcgKiAob3BbaW5kZXgyIC0gMV0gPT09ICctJyA/IC0xIDogMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAYXJndW1lbnQge051bWJlcnxTdHJpbmd9IG9wdGlvbnMub2Zmc2V0PTBcbiAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBvZmZzZXQoZGF0YSwgX3JlZikge1xuICB2YXIgb2Zmc2V0ID0gX3JlZi5vZmZzZXQ7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudCxcbiAgICAgIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgdmFyIG9mZnNldHMgPSB2b2lkIDA7XG4gIGlmIChpc051bWVyaWMoK29mZnNldCkpIHtcbiAgICBvZmZzZXRzID0gWytvZmZzZXQsIDBdO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldHMgPSBwYXJzZU9mZnNldChvZmZzZXQsIHBvcHBlciwgcmVmZXJlbmNlLCBiYXNlUGxhY2VtZW50KTtcbiAgfVxuXG4gIGlmIChiYXNlUGxhY2VtZW50ID09PSAnbGVmdCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAncmlnaHQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAnYm90dG9tJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzFdO1xuICB9XG5cbiAgZGF0YS5wb3BwZXIgPSBwb3BwZXI7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgYm91bmRhcmllc0VsZW1lbnQgPSBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50IHx8IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG5cbiAgLy8gSWYgb2Zmc2V0UGFyZW50IGlzIHRoZSByZWZlcmVuY2UgZWxlbWVudCwgd2UgcmVhbGx5IHdhbnQgdG9cbiAgLy8gZ28gb25lIHN0ZXAgdXAgYW5kIHVzZSB0aGUgbmV4dCBvZmZzZXRQYXJlbnQgYXMgcmVmZXJlbmNlIHRvXG4gIC8vIGF2b2lkIHRvIG1ha2UgdGhpcyBtb2RpZmllciBjb21wbGV0ZWx5IHVzZWxlc3MgYW5kIGxvb2sgbGlrZSBicm9rZW5cbiAgaWYgKGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlID09PSBib3VuZGFyaWVzRWxlbWVudCkge1xuICAgIGJvdW5kYXJpZXNFbGVtZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGJvdW5kYXJpZXNFbGVtZW50KTtcbiAgfVxuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXNldHMgdGhlIHBvcHBlcidzIHBvc2l0aW9uIHNvIHRoYXQgdGhlIGRvY3VtZW50IHNpemUgY2FuIGJlIGNhbGN1bGF0ZWQgZXhjbHVkaW5nXG4gIC8vIHRoZSBzaXplIG9mIHRoZSBwb3BwZXIgZWxlbWVudCBpdHNlbGZcbiAgdmFyIHRyYW5zZm9ybVByb3AgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuICB2YXIgcG9wcGVyU3R5bGVzID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIuc3R5bGU7IC8vIGFzc2lnbm1lbnQgdG8gaGVscCBtaW5pZmljYXRpb25cbiAgdmFyIHRvcCA9IHBvcHBlclN0eWxlcy50b3AsXG4gICAgICBsZWZ0ID0gcG9wcGVyU3R5bGVzLmxlZnQsXG4gICAgICB0cmFuc2Zvcm0gPSBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF07XG5cbiAgcG9wcGVyU3R5bGVzLnRvcCA9ICcnO1xuICBwb3BwZXJTdHlsZXMubGVmdCA9ICcnO1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSAnJztcblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50LCBkYXRhLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXN0b3JlcyB0aGUgb3JpZ2luYWwgc3R5bGUgcHJvcGVydGllcyBhZnRlciB0aGUgb2Zmc2V0cyBoYXZlIGJlZW4gY29tcHV0ZWRcbiAgcG9wcGVyU3R5bGVzLnRvcCA9IHRvcDtcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSBsZWZ0O1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm07XG5cbiAgb3B0aW9ucy5ib3VuZGFyaWVzID0gYm91bmRhcmllcztcblxuICB2YXIgb3JkZXIgPSBvcHRpb25zLnByaW9yaXR5O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICB2YXIgY2hlY2sgPSB7XG4gICAgcHJpbWFyeTogZnVuY3Rpb24gcHJpbWFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlcltwbGFjZW1lbnRdO1xuICAgICAgaWYgKHBvcHBlcltwbGFjZW1lbnRdIDwgYm91bmRhcmllc1twbGFjZW1lbnRdICYmICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2UpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1heChwb3BwZXJbcGxhY2VtZW50XSwgYm91bmRhcmllc1twbGFjZW1lbnRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgcGxhY2VtZW50LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZWNvbmRhcnk6IGZ1bmN0aW9uIHNlY29uZGFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciBtYWluU2lkZSA9IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgICAgdmFyIHZhbHVlID0gcG9wcGVyW21haW5TaWRlXTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA+IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5taW4ocG9wcGVyW21haW5TaWRlXSwgYm91bmRhcmllc1twbGFjZW1lbnRdIC0gKHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/IHBvcHBlci53aWR0aCA6IHBvcHBlci5oZWlnaHQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgbWFpblNpZGUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgb3JkZXIuZm9yRWFjaChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgdmFyIHNpZGUgPSBbJ2xlZnQnLCAndG9wJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMSA/ICdwcmltYXJ5JyA6ICdzZWNvbmRhcnknO1xuICAgIHBvcHBlciA9IF9leHRlbmRzKHt9LCBwb3BwZXIsIGNoZWNrW3NpZGVdKHBsYWNlbWVudCkpO1xuICB9KTtcblxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gcG9wcGVyO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBzaGlmdChkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHNoaWZ0dmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgLy8gaWYgc2hpZnQgc2hpZnR2YXJpYXRpb24gaXMgc3BlY2lmaWVkLCBydW4gdGhlIG1vZGlmaWVyXG4gIGlmIChzaGlmdHZhcmlhdGlvbikge1xuICAgIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXI7XG5cbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsnYm90dG9tJywgJ3RvcCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuICAgIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgIHZhciBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgICB2YXIgc2hpZnRPZmZzZXRzID0ge1xuICAgICAgc3RhcnQ6IGRlZmluZVByb3BlcnR5KHt9LCBzaWRlLCByZWZlcmVuY2Vbc2lkZV0pLFxuICAgICAgZW5kOiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW21lYXN1cmVtZW50XSAtIHBvcHBlclttZWFzdXJlbWVudF0pXG4gICAgfTtcblxuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBzaGlmdE9mZnNldHNbc2hpZnR2YXJpYXRpb25dKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gaGlkZShkYXRhKSB7XG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaGlkZScsICdwcmV2ZW50T3ZlcmZsb3cnKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIHJlZlJlY3QgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuICB2YXIgYm91bmQgPSBmaW5kKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ3ByZXZlbnRPdmVyZmxvdyc7XG4gIH0pLmJvdW5kYXJpZXM7XG5cbiAgaWYgKHJlZlJlY3QuYm90dG9tIDwgYm91bmQudG9wIHx8IHJlZlJlY3QubGVmdCA+IGJvdW5kLnJpZ2h0IHx8IHJlZlJlY3QudG9wID4gYm91bmQuYm90dG9tIHx8IHJlZlJlY3QucmlnaHQgPCBib3VuZC5sZWZ0KSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gdHJ1ZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSBmYWxzZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGlubmVyKGRhdGEpIHtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzSG9yaXogPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgc3VidHJhY3RMZW5ndGggPSBbJ3RvcCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA9PT0gLTE7XG5cbiAgcG9wcGVyW2lzSG9yaXogPyAnbGVmdCcgOiAndG9wJ10gPSByZWZlcmVuY2VbYmFzZVBsYWNlbWVudF0gLSAoc3VidHJhY3RMZW5ndGggPyBwb3BwZXJbaXNIb3JpeiA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gOiAwKTtcblxuICBkYXRhLnBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KHBvcHBlcik7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogTW9kaWZpZXIgZnVuY3Rpb24sIGVhY2ggbW9kaWZpZXIgY2FuIGhhdmUgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgYXNzaWduZWRcbiAqIHRvIGl0cyBgZm5gIHByb3BlcnR5LjxiciAvPlxuICogVGhlc2UgZnVuY3Rpb25zIHdpbGwgYmUgY2FsbGVkIG9uIGVhY2ggdXBkYXRlLCB0aGlzIG1lYW5zIHRoYXQgeW91IG11c3RcbiAqIG1ha2Ugc3VyZSB0aGV5IGFyZSBwZXJmb3JtYW50IGVub3VnaCB0byBhdm9pZCBwZXJmb3JtYW5jZSBib3R0bGVuZWNrcy5cbiAqXG4gKiBAZnVuY3Rpb24gTW9kaWZpZXJGblxuICogQGFyZ3VtZW50IHtkYXRhT2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cblxuLyoqXG4gKiBNb2RpZmllcnMgYXJlIHBsdWdpbnMgdXNlZCB0byBhbHRlciB0aGUgYmVoYXZpb3Igb2YgeW91ciBwb3BwZXJzLjxiciAvPlxuICogUG9wcGVyLmpzIHVzZXMgYSBzZXQgb2YgOSBtb2RpZmllcnMgdG8gcHJvdmlkZSBhbGwgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllc1xuICogbmVlZGVkIGJ5IHRoZSBsaWJyYXJ5LlxuICpcbiAqIFVzdWFsbHkgeW91IGRvbid0IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGBvcmRlcmAsIGBmbmAgYW5kIGBvbkxvYWRgIHByb3BzLlxuICogQWxsIHRoZSBvdGhlciBwcm9wZXJ0aWVzIGFyZSBjb25maWd1cmF0aW9ucyB0aGF0IGNvdWxkIGJlIHR3ZWFrZWQuXG4gKiBAbmFtZXNwYWNlIG1vZGlmaWVyc1xuICovXG52YXIgbW9kaWZpZXJzID0ge1xuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBzaGlmdCB0aGUgcG9wcGVyIG9uIHRoZSBzdGFydCBvciBlbmQgb2YgaXRzIHJlZmVyZW5jZVxuICAgKiBlbGVtZW50LjxiciAvPlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIHZhcmlhdGlvbiBvZiB0aGUgYHBsYWNlbWVudGAgcHJvcGVydHkuPGJyIC8+XG4gICAqIEl0IGNhbiBiZSBvbmUgZWl0aGVyIGAtZW5kYCBvciBgLXN0YXJ0YC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHNoaWZ0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTEwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogc2hpZnRcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGBvZmZzZXRgIG1vZGlmaWVyIGNhbiBzaGlmdCB5b3VyIHBvcHBlciBvbiBib3RoIGl0cyBheGlzLlxuICAgKlxuICAgKiBJdCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgdW5pdHM6XG4gICAqIC0gYHB4YCBvciB1bml0bGVzcywgaW50ZXJwcmV0ZWQgYXMgcGl4ZWxzXG4gICAqIC0gYCVgIG9yIGAlcmAsIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICogLSBgJXBgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHBvcHBlciBlbGVtZW50XG4gICAqIC0gYHZ3YCwgQ1NTIHZpZXdwb3J0IHdpZHRoIHVuaXRcbiAgICogLSBgdmhgLCBDU1Mgdmlld3BvcnQgaGVpZ2h0IHVuaXRcbiAgICpcbiAgICogRm9yIGxlbmd0aCBpcyBpbnRlbmRlZCB0aGUgbWFpbiBheGlzIHJlbGF0aXZlIHRvIHRoZSBwbGFjZW1lbnQgb2YgdGhlIHBvcHBlci48YnIgLz5cbiAgICogVGhpcyBtZWFucyB0aGF0IGlmIHRoZSBwbGFjZW1lbnQgaXMgYHRvcGAgb3IgYGJvdHRvbWAsIHRoZSBsZW5ndGggd2lsbCBiZSB0aGVcbiAgICogYHdpZHRoYC4gSW4gY2FzZSBvZiBgbGVmdGAgb3IgYHJpZ2h0YCwgaXQgd2lsbCBiZSB0aGUgaGVpZ2h0LlxuICAgKlxuICAgKiBZb3UgY2FuIHByb3ZpZGUgYSBzaW5nbGUgdmFsdWUgKGFzIGBOdW1iZXJgIG9yIGBTdHJpbmdgKSwgb3IgYSBwYWlyIG9mIHZhbHVlc1xuICAgKiBhcyBgU3RyaW5nYCBkaXZpZGVkIGJ5IGEgY29tbWEgb3Igb25lIChvciBtb3JlKSB3aGl0ZSBzcGFjZXMuPGJyIC8+XG4gICAqIFRoZSBsYXR0ZXIgaXMgYSBkZXByZWNhdGVkIG1ldGhvZCBiZWNhdXNlIGl0IGxlYWRzIHRvIGNvbmZ1c2lvbiBhbmQgd2lsbCBiZVxuICAgKiByZW1vdmVkIGluIHYyLjxiciAvPlxuICAgKiBBZGRpdGlvbmFsbHksIGl0IGFjY2VwdHMgYWRkaXRpb25zIGFuZCBzdWJ0cmFjdGlvbnMgYmV0d2VlbiBkaWZmZXJlbnQgdW5pdHMuXG4gICAqIE5vdGUgdGhhdCBtdWx0aXBsaWNhdGlvbnMgYW5kIGRpdmlzaW9ucyBhcmVuJ3Qgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBWYWxpZCBleGFtcGxlcyBhcmU6XG4gICAqIGBgYFxuICAgKiAxMFxuICAgKiAnMTAlJ1xuICAgKiAnMTAsIDEwJ1xuICAgKiAnMTAlLCAxMCdcbiAgICogJzEwICsgMTAlJ1xuICAgKiAnMTAgLSA1dmggKyAzJSdcbiAgICogJy0xMHB4ICsgNXZoLCA1cHggLSA2JSdcbiAgICogYGBgXG4gICAqID4gKipOQioqOiBJZiB5b3UgZGVzaXJlIHRvIGFwcGx5IG9mZnNldHMgdG8geW91ciBwb3BwZXJzIGluIGEgd2F5IHRoYXQgbWF5IG1ha2UgdGhlbSBvdmVybGFwXG4gICAqID4gd2l0aCB0aGVpciByZWZlcmVuY2UgZWxlbWVudCwgdW5mb3J0dW5hdGVseSwgeW91IHdpbGwgaGF2ZSB0byBkaXNhYmxlIHRoZSBgZmxpcGAgbW9kaWZpZXIuXG4gICAqID4gTW9yZSBvbiB0aGlzIFtyZWFkaW5nIHRoaXMgaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9GZXpWcmFzdGEvcG9wcGVyLmpzL2lzc3Vlcy8zNzMpXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBvZmZzZXQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAyMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBvZmZzZXQsXG4gICAgLyoqIEBwcm9wIHtOdW1iZXJ8U3RyaW5nfSBvZmZzZXQ9MFxuICAgICAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIG9mZnNldDogMFxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHByZXZlbnQgdGhlIHBvcHBlciBmcm9tIGJlaW5nIHBvc2l0aW9uZWQgb3V0c2lkZSB0aGUgYm91bmRhcnkuXG4gICAqXG4gICAqIEFuIHNjZW5hcmlvIGV4aXN0cyB3aGVyZSB0aGUgcmVmZXJlbmNlIGl0c2VsZiBpcyBub3Qgd2l0aGluIHRoZSBib3VuZGFyaWVzLjxiciAvPlxuICAgKiBXZSBjYW4gc2F5IGl0IGhhcyBcImVzY2FwZWQgdGhlIGJvdW5kYXJpZXNcIiDigJQgb3IganVzdCBcImVzY2FwZWRcIi48YnIgLz5cbiAgICogSW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHBvcHBlciBzaG91bGQgZWl0aGVyOlxuICAgKlxuICAgKiAtIGRldGFjaCBmcm9tIHRoZSByZWZlcmVuY2UgYW5kIHJlbWFpbiBcInRyYXBwZWRcIiBpbiB0aGUgYm91bmRhcmllcywgb3JcbiAgICogLSBpZiBpdCBzaG91bGQgaWdub3JlIHRoZSBib3VuZGFyeSBhbmQgXCJlc2NhcGUgd2l0aCBpdHMgcmVmZXJlbmNlXCJcbiAgICpcbiAgICogV2hlbiBgZXNjYXBlV2l0aFJlZmVyZW5jZWAgaXMgc2V0IHRvYHRydWVgIGFuZCByZWZlcmVuY2UgaXMgY29tcGxldGVseVxuICAgKiBvdXRzaWRlIGl0cyBib3VuZGFyaWVzLCB0aGUgcG9wcGVyIHdpbGwgb3ZlcmZsb3cgKG9yIGNvbXBsZXRlbHkgbGVhdmUpXG4gICAqIHRoZSBib3VuZGFyaWVzIGluIG9yZGVyIHRvIHJlbWFpbiBhdHRhY2hlZCB0byB0aGUgZWRnZSBvZiB0aGUgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgcHJldmVudE92ZXJmbG93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTMwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogcHJldmVudE92ZXJmbG93LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtBcnJheX0gW3ByaW9yaXR5PVsnbGVmdCcsJ3JpZ2h0JywndG9wJywnYm90dG9tJ11dXG4gICAgICogUG9wcGVyIHdpbGwgdHJ5IHRvIHByZXZlbnQgb3ZlcmZsb3cgZm9sbG93aW5nIHRoZXNlIHByaW9yaXRpZXMgYnkgZGVmYXVsdCxcbiAgICAgKiB0aGVuLCBpdCBjb3VsZCBvdmVyZmxvdyBvbiB0aGUgbGVmdCBhbmQgb24gdG9wIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcHJpb3JpdHk6IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ10sXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogQW1vdW50IG9mIHBpeGVsIHVzZWQgdG8gZGVmaW5lIGEgbWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib3VuZGFyaWVzXG4gICAgICogYW5kIHRoZSBwb3BwZXIgdGhpcyBtYWtlcyBzdXJlIHRoZSBwb3BwZXIgaGFzIGFsd2F5cyBhIGxpdHRsZSBwYWRkaW5nXG4gICAgICogYmV0d2VlbiB0aGUgZWRnZXMgb2YgaXRzIGNvbnRhaW5lclxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3Njcm9sbFBhcmVudCdcbiAgICAgKiBCb3VuZGFyaWVzIHVzZWQgYnkgdGhlIG1vZGlmaWVyLCBjYW4gYmUgYHNjcm9sbFBhcmVudGAsIGB3aW5kb3dgLFxuICAgICAqIGB2aWV3cG9ydGAgb3IgYW55IERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAnc2Nyb2xsUGFyZW50J1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgcmVmZXJlbmNlIGFuZCBpdHMgcG9wcGVyIHN0YXkgbmVhciBlYWNob3RoZXJzXG4gICAqIHdpdGhvdXQgbGVhdmluZyBhbnkgZ2FwIGJldHdlZW4gdGhlIHR3by4gRXhwZWNpYWxseSB1c2VmdWwgd2hlbiB0aGUgYXJyb3cgaXNcbiAgICogZW5hYmxlZCBhbmQgeW91IHdhbnQgdG8gYXNzdXJlIGl0IHRvIHBvaW50IHRvIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogSXQgY2FyZXMgb25seSBhYm91dCB0aGUgZmlyc3QgYXhpcywgeW91IGNhbiBzdGlsbCBoYXZlIHBvcHBlcnMgd2l0aCBtYXJnaW5cbiAgICogYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBrZWVwVG9nZXRoZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NDAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA0MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBrZWVwVG9nZXRoZXJcbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBtb2RpZmllciBpcyB1c2VkIHRvIG1vdmUgdGhlIGBhcnJvd0VsZW1lbnRgIG9mIHRoZSBwb3BwZXIgdG8gbWFrZVxuICAgKiBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgYmV0d2VlbiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgYW5kIGl0cyBwb3BwZXIgZWxlbWVudC5cbiAgICogSXQgd2lsbCByZWFkIHRoZSBvdXRlciBzaXplIG9mIHRoZSBgYXJyb3dFbGVtZW50YCBub2RlIHRvIGRldGVjdCBob3cgbWFueVxuICAgKiBwaXhlbHMgb2YgY29uanVjdGlvbiBhcmUgbmVlZGVkLlxuICAgKlxuICAgKiBJdCBoYXMgbm8gZWZmZWN0IGlmIG5vIGBhcnJvd0VsZW1lbnRgIGlzIHByb3ZpZGVkLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXJyb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA1MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcnJvdyxcbiAgICAvKiogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gZWxlbWVudD0nW3gtYXJyb3ddJyAtIFNlbGVjdG9yIG9yIG5vZGUgdXNlZCBhcyBhcnJvdyAqL1xuICAgIGVsZW1lbnQ6ICdbeC1hcnJvd10nXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gZmxpcCB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50IHdoZW4gaXQgc3RhcnRzIHRvIG92ZXJsYXAgaXRzXG4gICAqIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqXG4gICAqICoqTk9URToqKiB0aGlzIG1vZGlmaWVyIHdpbGwgaW50ZXJydXB0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZSBhbmQgd2lsbFxuICAgKiByZXN0YXJ0IGl0IGlmIGl0IGRldGVjdHMgdGhlIG5lZWQgdG8gZmxpcCB0aGUgcGxhY2VtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgZmxpcDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj02MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDYwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGZsaXAsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xBcnJheX0gYmVoYXZpb3I9J2ZsaXAnXG4gICAgICogVGhlIGJlaGF2aW9yIHVzZWQgdG8gY2hhbmdlIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQuIEl0IGNhbiBiZSBvbmUgb2ZcbiAgICAgKiBgZmxpcGAsIGBjbG9ja3dpc2VgLCBgY291bnRlcmNsb2Nrd2lzZWAgb3IgYW4gYXJyYXkgd2l0aCBhIGxpc3Qgb2YgdmFsaWRcbiAgICAgKiBwbGFjZW1lbnRzICh3aXRoIG9wdGlvbmFsIHZhcmlhdGlvbnMpLlxuICAgICAqL1xuICAgIGJlaGF2aW9yOiAnZmxpcCcsXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogVGhlIHBvcHBlciB3aWxsIGZsaXAgaWYgaXQgaGl0cyB0aGUgZWRnZXMgb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSd2aWV3cG9ydCdcbiAgICAgKiBUaGUgZWxlbWVudCB3aGljaCB3aWxsIGRlZmluZSB0aGUgYm91bmRhcmllcyBvZiB0aGUgcG9wcGVyIHBvc2l0aW9uLFxuICAgICAqIHRoZSBwb3BwZXIgd2lsbCBuZXZlciBiZSBwbGFjZWQgb3V0c2lkZSBvZiB0aGUgZGVmaW5lZCBib3VuZGFyaWVzXG4gICAgICogKGV4Y2VwdCBpZiBrZWVwVG9nZXRoZXIgaXMgZW5hYmxlZClcbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3ZpZXdwb3J0J1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2UgdGhlIHBvcHBlciBmbG93IHRvd2FyZCB0aGUgaW5uZXIgb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBCeSBkZWZhdWx0LCB3aGVuIHRoaXMgbW9kaWZpZXIgaXMgZGlzYWJsZWQsIHRoZSBwb3BwZXIgd2lsbCBiZSBwbGFjZWQgb3V0c2lkZVxuICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBpbm5lcjoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj03MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDcwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9ZmFsc2UgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaW5uZXJcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBoaWRlIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0c2lkZSBvZiB0aGVcbiAgICogcG9wcGVyIGJvdW5kYXJpZXMuIEl0IHdpbGwgc2V0IGEgYHgtb3V0LW9mLWJvdW5kYXJpZXNgIGF0dHJpYnV0ZSB3aGljaCBjYW5cbiAgICogYmUgdXNlZCB0byBoaWRlIHdpdGggYSBDU1Mgc2VsZWN0b3IgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgaXNcbiAgICogb3V0IG9mIGJvdW5kYXJpZXMuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGhpZGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBoaWRlXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBzdHlsZSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGVsZW1lbnQgdG8gZ2V0c1xuICAgKiBwcm9wZXJseSBwb3NpdGlvbmVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBtb2RpZmllciB3aWxsIG5vdCB0b3VjaCB0aGUgRE9NLCBpdCBqdXN0IHByZXBhcmVzIHRoZSBzdHlsZXNcbiAgICogc28gdGhhdCBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgY2FuIGFwcGx5IGl0LiBUaGlzIHNlcGFyYXRpb24gaXMgdXNlZnVsXG4gICAqIGluIGNhc2UgeW91IG5lZWQgdG8gcmVwbGFjZSBgYXBwbHlTdHlsZWAgd2l0aCBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtb2RpZmllciBoYXMgYDg1MGAgYXMgYG9yZGVyYCB2YWx1ZSB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAqIHdpdGggcHJldmlvdXMgdmVyc2lvbnMgb2YgUG9wcGVyLmpzLiBFeHBlY3QgdGhlIG1vZGlmaWVycyBvcmRlcmluZyBtZXRob2RcbiAgICogdG8gY2hhbmdlIGluIGZ1dHVyZSBtYWpvciB2ZXJzaW9ucyBvZiB0aGUgbGlicmFyeS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGNvbXB1dGVTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04NTAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDg1MCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGNvbXB1dGVTdHlsZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM2QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdib3R0b20nXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWCBheGlzIChgYm90dG9tYCBvciBgdG9wYCkuIEFLQSBYIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYGJvdHRvbWBcbiAgICAgKi9cbiAgICB4OiAnYm90dG9tJyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nbGVmdCddXG4gICAgICogV2hlcmUgdG8gYW5jaG9yIHRoZSBZIGF4aXMgKGBsZWZ0YCBvciBgcmlnaHRgKS4gQUtBIFkgb2Zmc2V0IG9yaWdpbi5cbiAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgcmlnaHRgXG4gICAgICovXG4gICAgeTogJ3JpZ2h0J1xuICB9LFxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBjb21wdXRlZCBzdHlsZXMgdG8gdGhlIHBvcHBlciBlbGVtZW50LlxuICAgKlxuICAgKiBBbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIGFyZSBsaW1pdGVkIHRvIHRoaXMgbW9kaWZpZXIuIFRoaXMgaXMgdXNlZnVsIGluIGNhc2VcbiAgICogeW91IHdhbnQgdG8gaW50ZWdyYXRlIFBvcHBlci5qcyBpbnNpZGUgYSBmcmFtZXdvcmsgb3IgdmlldyBsaWJyYXJ5IGFuZCB5b3VcbiAgICogd2FudCB0byBkZWxlZ2F0ZSBhbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIHRvIGl0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgaWYgeW91IGRpc2FibGUgdGhpcyBtb2RpZmllciwgeW91IG11c3QgbWFrZSBzdXJlIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiBoYXMgaXRzIHBvc2l0aW9uIHNldCB0byBgYWJzb2x1dGVgIGJlZm9yZSBQb3BwZXIuanMgY2FuIGRvIGl0cyB3b3JrIVxuICAgKlxuICAgKiBKdXN0IGRpc2FibGUgdGhpcyBtb2RpZmllciBhbmQgZGVmaW5lIHlvdSBvd24gdG8gYWNoaWV2ZSB0aGUgZGVzaXJlZCBlZmZlY3QuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcHBseVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTkwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogOTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXBwbHlTdHlsZSxcbiAgICAvKiogQHByb3Age0Z1bmN0aW9ufSAqL1xuICAgIG9uTG9hZDogYXBwbHlTdHlsZU9uTG9hZCxcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMTAuMCwgdGhlIHByb3BlcnR5IG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNkIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdW5kZWZpbmVkXG4gIH1cbn07XG5cbi8qKlxuICogVGhlIGBkYXRhT2JqZWN0YCBpcyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGluZm9ybWF0aW9ucyB1c2VkIGJ5IFBvcHBlci5qc1xuICogdGhpcyBvYmplY3QgZ2V0IHBhc3NlZCB0byBtb2RpZmllcnMgYW5kIHRvIHRoZSBgb25DcmVhdGVgIGFuZCBgb25VcGRhdGVgIGNhbGxiYWNrcy5cbiAqIEBuYW1lIGRhdGFPYmplY3RcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmluc3RhbmNlIFRoZSBQb3BwZXIuanMgaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLnBsYWNlbWVudCBQbGFjZW1lbnQgYXBwbGllZCB0byBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50IFBsYWNlbWVudCBvcmlnaW5hbGx5IGRlZmluZWQgb24gaW5pdFxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmZsaXBwZWQgVHJ1ZSBpZiBwb3BwZXIgaGFzIGJlZW4gZmxpcHBlZCBieSBmbGlwIG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRhdGEuaGlkZSBUcnVlIGlmIHRoZSByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXQgb2YgYm91bmRhcmllcywgdXNlZnVsIHRvIGtub3cgd2hlbiB0byBoaWRlIHRoZSBwb3BwZXIuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBkYXRhLmFycm93RWxlbWVudCBOb2RlIHVzZWQgYXMgYXJyb3cgYnkgYXJyb3cgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLnN0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciwgaXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmFycm93U3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGFycm93LCBpdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYm91bmRhcmllcyBPZmZzZXRzIG9mIHRoZSBwb3BwZXIgYm91bmRhcmllc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cyBUaGUgbWVhc3VyZW1lbnRzIG9mIHBvcHBlciwgcmVmZXJlbmNlIGFuZCBhcnJvdyBlbGVtZW50cy5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucG9wcGVyIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLmFycm93XSBgdG9wYCBhbmQgYGxlZnRgIG9mZnNldHMsIG9ubHkgb25lIG9mIHRoZW0gd2lsbCBiZSBkaWZmZXJlbnQgZnJvbSAwXG4gKi9cblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgcHJvdmlkZWQgdG8gUG9wcGVyLmpzIGNvbnN0cnVjdG9yLjxiciAvPlxuICogVGhlc2UgY2FuIGJlIG92ZXJyaWRlbiB1c2luZyB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50IG9mIFBvcHBlci5qcy48YnIgLz5cbiAqIFRvIG92ZXJyaWRlIGFuIG9wdGlvbiwgc2ltcGx5IHBhc3MgYXMgM3JkIGFyZ3VtZW50IGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lXG4gKiBzdHJ1Y3R1cmUgb2YgdGhpcyBvYmplY3QsIGV4YW1wbGU6XG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmLCBwb3AsIHtcbiAqICAgbW9kaWZpZXJzOiB7XG4gKiAgICAgcHJldmVudE92ZXJmbG93OiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICogQHR5cGUge09iamVjdH1cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIERlZmF1bHRzID0ge1xuICAvKipcbiAgICogUG9wcGVyJ3MgcGxhY2VtZW50XG4gICAqIEBwcm9wIHtQb3BwZXIucGxhY2VtZW50c30gcGxhY2VtZW50PSdib3R0b20nXG4gICAqL1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuXG4gIC8qKlxuICAgKiBTZXQgdGhpcyB0byB0cnVlIGlmIHlvdSB3YW50IHBvcHBlciB0byBwb3NpdGlvbiBpdCBzZWxmIGluICdmaXhlZCcgbW9kZVxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcG9zaXRpb25GaXhlZD1mYWxzZVxuICAgKi9cbiAgcG9zaXRpb25GaXhlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZXZlbnRzIChyZXNpemUsIHNjcm9sbCkgYXJlIGluaXRpYWxseSBlbmFibGVkXG4gICAqIEBwcm9wIHtCb29sZWFufSBldmVudHNFbmFibGVkPXRydWVcbiAgICovXG4gIGV2ZW50c0VuYWJsZWQ6IHRydWUsXG5cbiAgLyoqXG4gICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgcmVtb3ZlIHRoZSBwb3BwZXIgd2hlblxuICAgKiB5b3UgY2FsbCB0aGUgYGRlc3Ryb3lgIG1ldGhvZC5cbiAgICogQHByb3Age0Jvb2xlYW59IHJlbW92ZU9uRGVzdHJveT1mYWxzZVxuICAgKi9cbiAgcmVtb3ZlT25EZXN0cm95OiBmYWxzZSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyBjcmVhdGVkLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvbkNyZWF0ZX1cbiAgICovXG4gIG9uQ3JlYXRlOiBmdW5jdGlvbiBvbkNyZWF0ZSgpIHt9LFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIHVwZGF0ZWQsIHRoaXMgY2FsbGJhY2sgaXMgbm90IGNhbGxlZFxuICAgKiBvbiB0aGUgaW5pdGlhbGl6YXRpb24vY3JlYXRpb24gb2YgdGhlIHBvcHBlciwgYnV0IG9ubHkgb24gc3Vic2VxdWVudFxuICAgKiB1cGRhdGVzLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvblVwZGF0ZX1cbiAgICovXG4gIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZSgpIHt9LFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIG1vZGlmaWVycyB1c2VkIHRvIG1vZGlmeSB0aGUgb2Zmc2V0cyBiZWZvcmUgdGhleSBhcmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLlxuICAgKiBUaGV5IHByb3ZpZGUgbW9zdCBvZiB0aGUgZnVuY3Rpb25hbGl0aWVzIG9mIFBvcHBlci5qc1xuICAgKiBAcHJvcCB7bW9kaWZpZXJzfVxuICAgKi9cbiAgbW9kaWZpZXJzOiBtb2RpZmllcnNcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIG9uQ3JlYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBvblVwZGF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLy8gVXRpbHNcbi8vIE1ldGhvZHNcbnZhciBQb3BwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUG9wcGVyLmpzIGluc3RhbmNlXG4gICAqIEBjbGFzcyBQb3BwZXJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxyZWZlcmVuY2VPYmplY3R9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgZWxlbWVudCB1c2VkIGFzIHBvcHBlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBZb3VyIGN1c3RvbSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBvbmVzIGRlZmluZWQgaW4gW0RlZmF1bHRzXSgjZGVmYXVsdHMpXG4gICAqIEByZXR1cm4ge09iamVjdH0gaW5zdGFuY2UgLSBUaGUgZ2VuZXJhdGVkIFBvcHBlci5qcyBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQb3BwZXIpO1xuXG4gICAgdGhpcy5zY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3RoaXMudXBkYXRlKTtcbiAgICB9O1xuXG4gICAgLy8gbWFrZSB1cGRhdGUoKSBkZWJvdW5jZWQsIHNvIHRoYXQgaXQgb25seSBydW5zIGF0IG1vc3Qgb25jZS1wZXItdGlja1xuICAgIHRoaXMudXBkYXRlID0gZGVib3VuY2UodGhpcy51cGRhdGUuYmluZCh0aGlzKSk7XG5cbiAgICAvLyB3aXRoIHt9IHdlIGNyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgb3B0aW9ucyBpbnNpZGUgaXRcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgIC8vIGluaXQgc3RhdGVcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaXNEZXN0cm95ZWQ6IGZhbHNlLFxuICAgICAgaXNDcmVhdGVkOiBmYWxzZSxcbiAgICAgIHNjcm9sbFBhcmVudHM6IFtdXG4gICAgfTtcblxuICAgIC8vIGdldCByZWZlcmVuY2UgYW5kIHBvcHBlciBlbGVtZW50cyAoYWxsb3cgalF1ZXJ5IHdyYXBwZXJzKVxuICAgIHRoaXMucmVmZXJlbmNlID0gcmVmZXJlbmNlICYmIHJlZmVyZW5jZS5qcXVlcnkgPyByZWZlcmVuY2VbMF0gOiByZWZlcmVuY2U7XG4gICAgdGhpcy5wb3BwZXIgPSBwb3BwZXIgJiYgcG9wcGVyLmpxdWVyeSA/IHBvcHBlclswXSA6IHBvcHBlcjtcblxuICAgIC8vIERlZXAgbWVyZ2UgbW9kaWZpZXJzIG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMubW9kaWZpZXJzID0ge307XG4gICAgT2JqZWN0LmtleXMoX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnMsIG9wdGlvbnMubW9kaWZpZXJzKSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gPSBfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLm1vZGlmaWVyc1tuYW1lXSB8fCB7fSwgb3B0aW9ucy5tb2RpZmllcnMgPyBvcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA6IHt9KTtcbiAgICB9KTtcblxuICAgIC8vIFJlZmFjdG9yaW5nIG1vZGlmaWVycycgbGlzdCAoT2JqZWN0ID0+IEFycmF5KVxuICAgIHRoaXMubW9kaWZpZXJzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zLm1vZGlmaWVycykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9LCBfdGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSk7XG4gICAgfSlcbiAgICAvLyBzb3J0IHRoZSBtb2RpZmllcnMgYnkgb3JkZXJcbiAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEub3JkZXIgLSBiLm9yZGVyO1xuICAgIH0pO1xuXG4gICAgLy8gbW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSB3aGVuIFBvcHBlci5qcyBnZXQgaW5pdGVkXG4gICAgLy8gc3VjaCBjb2RlIGlzIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIG9mIGl0cyBtb2RpZmllclxuICAgIC8vIHRoZXkgY291bGQgYWRkIG5ldyBwcm9wZXJ0aWVzIHRvIHRoZWlyIG9wdGlvbnMgY29uZmlndXJhdGlvblxuICAgIC8vIEJFIEFXQVJFOiBkb24ndCBhZGQgb3B0aW9ucyB0byBgb3B0aW9ucy5tb2RpZmllcnMubmFtZWAgYnV0IHRvIGBtb2RpZmllck9wdGlvbnNgIVxuICAgIHRoaXMubW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyT3B0aW9ucykge1xuICAgICAgaWYgKG1vZGlmaWVyT3B0aW9ucy5lbmFibGVkICYmIGlzRnVuY3Rpb24obW9kaWZpZXJPcHRpb25zLm9uTG9hZCkpIHtcbiAgICAgICAgbW9kaWZpZXJPcHRpb25zLm9uTG9hZChfdGhpcy5yZWZlcmVuY2UsIF90aGlzLnBvcHBlciwgX3RoaXMub3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBfdGhpcy5zdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBmaXJlIHRoZSBmaXJzdCB1cGRhdGUgdG8gcG9zaXRpb24gdGhlIHBvcHBlciBpbiB0aGUgcmlnaHQgcGxhY2VcbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgdmFyIGV2ZW50c0VuYWJsZWQgPSB0aGlzLm9wdGlvbnMuZXZlbnRzRW5hYmxlZDtcbiAgICBpZiAoZXZlbnRzRW5hYmxlZCkge1xuICAgICAgLy8gc2V0dXAgZXZlbnQgbGlzdGVuZXJzLCB0aGV5IHdpbGwgdGFrZSBjYXJlIG9mIHVwZGF0ZSB0aGUgcG9zaXRpb24gaW4gc3BlY2lmaWMgc2l0dWF0aW9uc1xuICAgICAgdGhpcy5lbmFibGVFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGV2ZW50c0VuYWJsZWQ7XG4gIH1cblxuICAvLyBXZSBjYW4ndCB1c2UgY2xhc3MgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgZG9uJ3QgZ2V0IGxpc3RlZCBpbiB0aGVcbiAgLy8gY2xhc3MgcHJvdG90eXBlIGFuZCBicmVhayBzdHVmZiBsaWtlIFNpbm9uIHN0dWJzXG5cblxuICBjcmVhdGVDbGFzcyhQb3BwZXIsIFt7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlJCQxKCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95JCQxKCkge1xuICAgICAgcmV0dXJuIGRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbmFibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzJCQxKCkge1xuICAgICAgcmV0dXJuIGVuYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGlzYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZUV2ZW50TGlzdGVuZXJzJCQxKCkge1xuICAgICAgcmV0dXJuIGRpc2FibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlIGFuIHVwZGF0ZSwgaXQgd2lsbCBydW4gb24gdGhlIG5leHQgVUkgdXBkYXRlIGF2YWlsYWJsZVxuICAgICAqIEBtZXRob2Qgc2NoZWR1bGVVcGRhdGVcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIENvbGxlY3Rpb24gb2YgdXRpbGl0aWVzIHVzZWZ1bCB3aGVuIHdyaXRpbmcgY3VzdG9tIG1vZGlmaWVycy5cbiAgICAgKiBTdGFydGluZyBmcm9tIHZlcnNpb24gMS43LCB0aGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgb25seSBpZiB5b3VcbiAgICAgKiBpbmNsdWRlIGBwb3BwZXItdXRpbHMuanNgIGJlZm9yZSBgcG9wcGVyLmpzYC5cbiAgICAgKlxuICAgICAqICoqREVQUkVDQVRJT04qKjogVGhpcyB3YXkgdG8gYWNjZXNzIFBvcHBlclV0aWxzIGlzIGRlcHJlY2F0ZWRcbiAgICAgKiBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHYyISBVc2UgdGhlIFBvcHBlclV0aWxzIG1vZHVsZSBkaXJlY3RseSBpbnN0ZWFkLlxuICAgICAqIER1ZSB0byB0aGUgaGlnaCBpbnN0YWJpbGl0eSBvZiB0aGUgbWV0aG9kcyBjb250YWluZWQgaW4gVXRpbHMsIHdlIGNhbid0XG4gICAgICogZ3VhcmFudGVlIHRoZW0gdG8gZm9sbG93IHNlbXZlci4gVXNlIHRoZW0gYXQgeW91ciBvd24gcmlzayFcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS44XG4gICAgICogQG1lbWJlciBVdGlsc1xuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKi9cblxuICB9XSk7XG4gIHJldHVybiBQb3BwZXI7XG59KCk7XG5cbi8qKlxuICogVGhlIGByZWZlcmVuY2VPYmplY3RgIGlzIGFuIG9iamVjdCB0aGF0IHByb3ZpZGVzIGFuIGludGVyZmFjZSBjb21wYXRpYmxlIHdpdGggUG9wcGVyLmpzXG4gKiBhbmQgbGV0cyB5b3UgdXNlIGl0IGFzIHJlcGxhY2VtZW50IG9mIGEgcmVhbCBET00gbm9kZS48YnIgLz5cbiAqIFlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kIHRvIHBvc2l0aW9uIGEgcG9wcGVyIHJlbGF0aXZlbHkgdG8gYSBzZXQgb2YgY29vcmRpbmF0ZXNcbiAqIGluIGNhc2UgeW91IGRvbid0IGhhdmUgYSBET00gbm9kZSB0byB1c2UgYXMgcmVmZXJlbmNlLlxuICpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWZlcmVuY2VPYmplY3QsIHBvcHBlck5vZGUpO1xuICogYGBgXG4gKlxuICogTkI6IFRoaXMgZmVhdHVyZSBpc24ndCBzdXBwb3J0ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTBcbiAqIEBuYW1lIHJlZmVyZW5jZU9iamVjdFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZGF0YS5nZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2V0IG9mIGNvb3JkaW5hdGVzIGNvbXBhdGlibGUgd2l0aCB0aGUgbmF0aXZlIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgIG1ldGhvZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudFdpZHRoXG4gKiBBbiBFUzYgZ2V0dGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGEuY2xpZW50SGVpZ2h0XG4gKiBBbiBFUzYgZ2V0dGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIGhlaWdodCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqL1xuXG5cblBvcHBlci5VdGlscyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCkuUG9wcGVyVXRpbHM7XG5Qb3BwZXIucGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG5Qb3BwZXIuRGVmYXVsdHMgPSBEZWZhdWx0cztcblxuZXhwb3J0IGRlZmF1bHQgUG9wcGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9wcGVyLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcG9wcGVyLmpzL2Rpc3QvZXNtL3BvcHBlci5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcclxuXHJcbmV4cG9ydCBlbnVtIENvbnRlbnRBdG9tVHlwZSB7XHJcbiAgICBUZXh0ID0gMCxcclxuICAgIEh0bWwgPSAxLFxyXG4gICAgUGljdHVyZSA9IDIsXHJcbiAgICBMaW5rID0gMyxcclxuICAgIE5hdkxpbmsgPSA0LFxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vVHlwZXdyaXRlci9Db250ZW50QXRvbVR5cGUudHMiLCIvKiFcclxuICogalF1ZXJ5IFZhbGlkYXRpb24gUGx1Z2luIHYxLjE3LjBcclxuICpcclxuICogaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9cclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IErDtnJuIFphZWZmZXJlclxyXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbihmdW5jdGlvbiggZmFjdG9yeSApIHtcclxuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xyXG5cdFx0ZGVmaW5lKCBbXCJqcXVlcnlcIl0sIGZhY3RvcnkgKTtcclxuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggcmVxdWlyZSggXCJqcXVlcnlcIiApICk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGZhY3RvcnkoIGpRdWVyeSApO1xyXG5cdH1cclxufShmdW5jdGlvbiggJCApIHtcclxuXHJcbiQuZXh0ZW5kKCAkLmZuLCB7XG5cblx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy92YWxpZGF0ZS9cblx0dmFsaWRhdGU6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgbm90aGluZyBpcyBzZWxlY3RlZCwgcmV0dXJuIG5vdGhpbmc7IGNhbid0IGNoYWluIGFueXdheVxuXHRcdGlmICggIXRoaXMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBvcHRpb25zICYmIG9wdGlvbnMuZGVidWcgJiYgd2luZG93LmNvbnNvbGUgKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybiggXCJOb3RoaW5nIHNlbGVjdGVkLCBjYW4ndCB2YWxpZGF0ZSwgcmV0dXJuaW5nIG5vdGhpbmcuXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDaGVjayBpZiBhIHZhbGlkYXRvciBmb3IgdGhpcyBmb3JtIHdhcyBhbHJlYWR5IGNyZWF0ZWRcblx0XHR2YXIgdmFsaWRhdG9yID0gJC5kYXRhKCB0aGlzWyAwIF0sIFwidmFsaWRhdG9yXCIgKTtcblx0XHRpZiAoIHZhbGlkYXRvciApIHtcblx0XHRcdHJldHVybiB2YWxpZGF0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIG5vdmFsaWRhdGUgdGFnIGlmIEhUTUw1LlxuXHRcdHRoaXMuYXR0ciggXCJub3ZhbGlkYXRlXCIsIFwibm92YWxpZGF0ZVwiICk7XG5cblx0XHR2YWxpZGF0b3IgPSBuZXcgJC52YWxpZGF0b3IoIG9wdGlvbnMsIHRoaXNbIDAgXSApO1xuXHRcdCQuZGF0YSggdGhpc1sgMCBdLCBcInZhbGlkYXRvclwiLCB2YWxpZGF0b3IgKTtcblxuXHRcdGlmICggdmFsaWRhdG9yLnNldHRpbmdzLm9uc3VibWl0ICkge1xuXG5cdFx0XHR0aGlzLm9uKCBcImNsaWNrLnZhbGlkYXRlXCIsIFwiOnN1Ym1pdFwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gVHJhY2sgdGhlIHVzZWQgc3VibWl0IGJ1dHRvbiB0byBwcm9wZXJseSBoYW5kbGUgc2NyaXB0ZWRcblx0XHRcdFx0Ly8gc3VibWl0cyBsYXRlci5cblx0XHRcdFx0dmFsaWRhdG9yLnN1Ym1pdEJ1dHRvbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG5cblx0XHRcdFx0Ly8gQWxsb3cgc3VwcHJlc3NpbmcgdmFsaWRhdGlvbiBieSBhZGRpbmcgYSBjYW5jZWwgY2xhc3MgdG8gdGhlIHN1Ym1pdCBidXR0b25cblx0XHRcdFx0aWYgKCAkKCB0aGlzICkuaGFzQ2xhc3MoIFwiY2FuY2VsXCIgKSApIHtcblx0XHRcdFx0XHR2YWxpZGF0b3IuY2FuY2VsU3VibWl0ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFsbG93IHN1cHByZXNzaW5nIHZhbGlkYXRpb24gYnkgYWRkaW5nIHRoZSBodG1sNSBmb3Jtbm92YWxpZGF0ZSBhdHRyaWJ1dGUgdG8gdGhlIHN1Ym1pdCBidXR0b25cblx0XHRcdFx0aWYgKCAkKCB0aGlzICkuYXR0ciggXCJmb3Jtbm92YWxpZGF0ZVwiICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR2YWxpZGF0b3IuY2FuY2VsU3VibWl0ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXG5cdFx0XHQvLyBWYWxpZGF0ZSB0aGUgZm9ybSBvbiBzdWJtaXRcblx0XHRcdHRoaXMub24oIFwic3VibWl0LnZhbGlkYXRlXCIsIGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0aWYgKCB2YWxpZGF0b3Iuc2V0dGluZ3MuZGVidWcgKSB7XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IGZvcm0gc3VibWl0IHRvIGJlIGFibGUgdG8gc2VlIGNvbnNvbGUgb3V0cHV0XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmdW5jdGlvbiBoYW5kbGUoKSB7XG5cdFx0XHRcdFx0dmFyIGhpZGRlbiwgcmVzdWx0O1xuXG5cdFx0XHRcdFx0Ly8gSW5zZXJ0IGEgaGlkZGVuIGlucHV0IGFzIGEgcmVwbGFjZW1lbnQgZm9yIHRoZSBtaXNzaW5nIHN1Ym1pdCBidXR0b25cblx0XHRcdFx0XHQvLyBUaGUgaGlkZGVuIGlucHV0IGlzIGluc2VydGVkIGluIHR3byBjYXNlczpcblx0XHRcdFx0XHQvLyAgIC0gQSB1c2VyIGRlZmluZWQgYSBgc3VibWl0SGFuZGxlcmBcblx0XHRcdFx0XHQvLyAgIC0gVGhlcmUgd2FzIGEgcGVuZGluZyByZXF1ZXN0IGR1ZSB0byBgcmVtb3RlYCBtZXRob2QgYW5kIGBzdG9wUmVxdWVzdCgpYFxuXHRcdFx0XHRcdC8vICAgICB3YXMgY2FsbGVkIHRvIHN1Ym1pdCB0aGUgZm9ybSBpbiBjYXNlIGl0J3MgdmFsaWRcblx0XHRcdFx0XHRpZiAoIHZhbGlkYXRvci5zdWJtaXRCdXR0b24gJiYgKCB2YWxpZGF0b3Iuc2V0dGluZ3Muc3VibWl0SGFuZGxlciB8fCB2YWxpZGF0b3IuZm9ybVN1Ym1pdHRlZCApICkge1xuXHRcdFx0XHRcdFx0aGlkZGVuID0gJCggXCI8aW5wdXQgdHlwZT0naGlkZGVuJy8+XCIgKVxuXHRcdFx0XHRcdFx0XHQuYXR0ciggXCJuYW1lXCIsIHZhbGlkYXRvci5zdWJtaXRCdXR0b24ubmFtZSApXG5cdFx0XHRcdFx0XHRcdC52YWwoICQoIHZhbGlkYXRvci5zdWJtaXRCdXR0b24gKS52YWwoKSApXG5cdFx0XHRcdFx0XHRcdC5hcHBlbmRUbyggdmFsaWRhdG9yLmN1cnJlbnRGb3JtICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCB2YWxpZGF0b3Iuc2V0dGluZ3Muc3VibWl0SGFuZGxlciApIHtcblx0XHRcdFx0XHRcdHJlc3VsdCA9IHZhbGlkYXRvci5zZXR0aW5ncy5zdWJtaXRIYW5kbGVyLmNhbGwoIHZhbGlkYXRvciwgdmFsaWRhdG9yLmN1cnJlbnRGb3JtLCBldmVudCApO1xuXHRcdFx0XHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQW5kIGNsZWFuIHVwIGFmdGVyd2FyZHM7IHRoYW5rcyB0byBuby1ibG9jay1zY29wZSwgaGlkZGVuIGNhbiBiZSByZWZlcmVuY2VkXG5cdFx0XHRcdFx0XHRcdGhpZGRlbi5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggcmVzdWx0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJldmVudCBzdWJtaXQgZm9yIGludmFsaWQgZm9ybXMgb3IgY3VzdG9tIHN1Ym1pdCBoYW5kbGVyc1xuXHRcdFx0XHRpZiAoIHZhbGlkYXRvci5jYW5jZWxTdWJtaXQgKSB7XG5cdFx0XHRcdFx0dmFsaWRhdG9yLmNhbmNlbFN1Ym1pdCA9IGZhbHNlO1xuXHRcdFx0XHRcdHJldHVybiBoYW5kbGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHZhbGlkYXRvci5mb3JtKCkgKSB7XG5cdFx0XHRcdFx0aWYgKCB2YWxpZGF0b3IucGVuZGluZ1JlcXVlc3QgKSB7XG5cdFx0XHRcdFx0XHR2YWxpZGF0b3IuZm9ybVN1Ym1pdHRlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBoYW5kbGUoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWxpZGF0b3IuZm9jdXNJbnZhbGlkKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbGlkYXRvcjtcblx0fSxcblxuXHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL3ZhbGlkL1xuXHR2YWxpZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHZhbGlkLCB2YWxpZGF0b3IsIGVycm9yTGlzdDtcblxuXHRcdGlmICggJCggdGhpc1sgMCBdICkuaXMoIFwiZm9ybVwiICkgKSB7XG5cdFx0XHR2YWxpZCA9IHRoaXMudmFsaWRhdGUoKS5mb3JtKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVycm9yTGlzdCA9IFtdO1xuXHRcdFx0dmFsaWQgPSB0cnVlO1xuXHRcdFx0dmFsaWRhdG9yID0gJCggdGhpc1sgMCBdLmZvcm0gKS52YWxpZGF0ZSgpO1xuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFsaWQgPSB2YWxpZGF0b3IuZWxlbWVudCggdGhpcyApICYmIHZhbGlkO1xuXHRcdFx0XHRpZiAoICF2YWxpZCApIHtcblx0XHRcdFx0XHRlcnJvckxpc3QgPSBlcnJvckxpc3QuY29uY2F0KCB2YWxpZGF0b3IuZXJyb3JMaXN0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdHZhbGlkYXRvci5lcnJvckxpc3QgPSBlcnJvckxpc3Q7XG5cdFx0fVxuXHRcdHJldHVybiB2YWxpZDtcblx0fSxcblxuXHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL3J1bGVzL1xuXHRydWxlczogZnVuY3Rpb24oIGNvbW1hbmQsIGFyZ3VtZW50ICkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpc1sgMCBdLFxuXHRcdFx0c2V0dGluZ3MsIHN0YXRpY1J1bGVzLCBleGlzdGluZ1J1bGVzLCBkYXRhLCBwYXJhbSwgZmlsdGVyZWQ7XG5cblx0XHQvLyBJZiBub3RoaW5nIGlzIHNlbGVjdGVkLCByZXR1cm4gZW1wdHkgb2JqZWN0OyBjYW4ndCBjaGFpbiBhbnl3YXlcblx0XHRpZiAoIGVsZW1lbnQgPT0gbnVsbCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoICFlbGVtZW50LmZvcm0gJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoIFwiY29udGVudGVkaXRhYmxlXCIgKSApIHtcblx0XHRcdGVsZW1lbnQuZm9ybSA9IHRoaXMuY2xvc2VzdCggXCJmb3JtXCIgKVsgMCBdO1xuXHRcdFx0ZWxlbWVudC5uYW1lID0gdGhpcy5hdHRyKCBcIm5hbWVcIiApO1xuXHRcdH1cblxuXHRcdGlmICggZWxlbWVudC5mb3JtID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBjb21tYW5kICkge1xuXHRcdFx0c2V0dGluZ3MgPSAkLmRhdGEoIGVsZW1lbnQuZm9ybSwgXCJ2YWxpZGF0b3JcIiApLnNldHRpbmdzO1xuXHRcdFx0c3RhdGljUnVsZXMgPSBzZXR0aW5ncy5ydWxlcztcblx0XHRcdGV4aXN0aW5nUnVsZXMgPSAkLnZhbGlkYXRvci5zdGF0aWNSdWxlcyggZWxlbWVudCApO1xuXHRcdFx0c3dpdGNoICggY29tbWFuZCApIHtcblx0XHRcdGNhc2UgXCJhZGRcIjpcblx0XHRcdFx0JC5leHRlbmQoIGV4aXN0aW5nUnVsZXMsICQudmFsaWRhdG9yLm5vcm1hbGl6ZVJ1bGUoIGFyZ3VtZW50ICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgbWVzc2FnZXMgZnJvbSBydWxlcywgYnV0IGFsbG93IHRoZW0gdG8gYmUgc2V0IHNlcGFyYXRlbHlcblx0XHRcdFx0ZGVsZXRlIGV4aXN0aW5nUnVsZXMubWVzc2FnZXM7XG5cdFx0XHRcdHN0YXRpY1J1bGVzWyBlbGVtZW50Lm5hbWUgXSA9IGV4aXN0aW5nUnVsZXM7XG5cdFx0XHRcdGlmICggYXJndW1lbnQubWVzc2FnZXMgKSB7XG5cdFx0XHRcdFx0c2V0dGluZ3MubWVzc2FnZXNbIGVsZW1lbnQubmFtZSBdID0gJC5leHRlbmQoIHNldHRpbmdzLm1lc3NhZ2VzWyBlbGVtZW50Lm5hbWUgXSwgYXJndW1lbnQubWVzc2FnZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgXCJyZW1vdmVcIjpcblx0XHRcdFx0aWYgKCAhYXJndW1lbnQgKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHN0YXRpY1J1bGVzWyBlbGVtZW50Lm5hbWUgXTtcblx0XHRcdFx0XHRyZXR1cm4gZXhpc3RpbmdSdWxlcztcblx0XHRcdFx0fVxuXHRcdFx0XHRmaWx0ZXJlZCA9IHt9O1xuXHRcdFx0XHQkLmVhY2goIGFyZ3VtZW50LnNwbGl0KCAvXFxzLyApLCBmdW5jdGlvbiggaW5kZXgsIG1ldGhvZCApIHtcblx0XHRcdFx0XHRmaWx0ZXJlZFsgbWV0aG9kIF0gPSBleGlzdGluZ1J1bGVzWyBtZXRob2QgXTtcblx0XHRcdFx0XHRkZWxldGUgZXhpc3RpbmdSdWxlc1sgbWV0aG9kIF07XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIGZpbHRlcmVkO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGRhdGEgPSAkLnZhbGlkYXRvci5ub3JtYWxpemVSdWxlcyhcblx0XHQkLmV4dGVuZChcblx0XHRcdHt9LFxuXHRcdFx0JC52YWxpZGF0b3IuY2xhc3NSdWxlcyggZWxlbWVudCApLFxuXHRcdFx0JC52YWxpZGF0b3IuYXR0cmlidXRlUnVsZXMoIGVsZW1lbnQgKSxcblx0XHRcdCQudmFsaWRhdG9yLmRhdGFSdWxlcyggZWxlbWVudCApLFxuXHRcdFx0JC52YWxpZGF0b3Iuc3RhdGljUnVsZXMoIGVsZW1lbnQgKVxuXHRcdCksIGVsZW1lbnQgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSByZXF1aXJlZCBpcyBhdCBmcm9udFxuXHRcdGlmICggZGF0YS5yZXF1aXJlZCApIHtcblx0XHRcdHBhcmFtID0gZGF0YS5yZXF1aXJlZDtcblx0XHRcdGRlbGV0ZSBkYXRhLnJlcXVpcmVkO1xuXHRcdFx0ZGF0YSA9ICQuZXh0ZW5kKCB7IHJlcXVpcmVkOiBwYXJhbSB9LCBkYXRhICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHJlbW90ZSBpcyBhdCBiYWNrXG5cdFx0aWYgKCBkYXRhLnJlbW90ZSApIHtcblx0XHRcdHBhcmFtID0gZGF0YS5yZW1vdGU7XG5cdFx0XHRkZWxldGUgZGF0YS5yZW1vdGU7XG5cdFx0XHRkYXRhID0gJC5leHRlbmQoIGRhdGEsIHsgcmVtb3RlOiBwYXJhbSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGE7XG5cdH1cbn0gKTtcblxuLy8gQ3VzdG9tIHNlbGVjdG9yc1xuJC5leHRlbmQoICQuZXhwci5wc2V1ZG9zIHx8ICQuZXhwclsgXCI6XCIgXSwge1x0XHQvLyAnfHwgJC5leHByWyBcIjpcIiBdJyBoZXJlIGVuYWJsZXMgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgdG8galF1ZXJ5IDEuNy4gQ2FuIGJlIHJlbW92ZWQgd2hlbiBkcm9wcGluZyBqUSAxLjcueCBzdXBwb3J0XG5cblx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9ibGFuay1zZWxlY3Rvci9cblx0Ymxhbms6IGZ1bmN0aW9uKCBhICkge1xuXHRcdHJldHVybiAhJC50cmltKCBcIlwiICsgJCggYSApLnZhbCgpICk7XG5cdH0sXG5cblx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9maWxsZWQtc2VsZWN0b3IvXG5cdGZpbGxlZDogZnVuY3Rpb24oIGEgKSB7XG5cdFx0dmFyIHZhbCA9ICQoIGEgKS52YWwoKTtcblx0XHRyZXR1cm4gdmFsICE9PSBudWxsICYmICEhJC50cmltKCBcIlwiICsgdmFsICk7XG5cdH0sXG5cblx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy91bmNoZWNrZWQtc2VsZWN0b3IvXG5cdHVuY2hlY2tlZDogZnVuY3Rpb24oIGEgKSB7XG5cdFx0cmV0dXJuICEkKCBhICkucHJvcCggXCJjaGVja2VkXCIgKTtcblx0fVxufSApO1xuXG4vLyBDb25zdHJ1Y3RvciBmb3IgdmFsaWRhdG9yXG4kLnZhbGlkYXRvciA9IGZ1bmN0aW9uKCBvcHRpb25zLCBmb3JtICkge1xuXHR0aGlzLnNldHRpbmdzID0gJC5leHRlbmQoIHRydWUsIHt9LCAkLnZhbGlkYXRvci5kZWZhdWx0cywgb3B0aW9ucyApO1xuXHR0aGlzLmN1cnJlbnRGb3JtID0gZm9ybTtcblx0dGhpcy5pbml0KCk7XG59O1xuXG4vLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL2pRdWVyeS52YWxpZGF0b3IuZm9ybWF0L1xuJC52YWxpZGF0b3IuZm9ybWF0ID0gZnVuY3Rpb24oIHNvdXJjZSwgcGFyYW1zICkge1xuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGFyZ3MgPSAkLm1ha2VBcnJheSggYXJndW1lbnRzICk7XG5cdFx0XHRhcmdzLnVuc2hpZnQoIHNvdXJjZSApO1xuXHRcdFx0cmV0dXJuICQudmFsaWRhdG9yLmZvcm1hdC5hcHBseSggdGhpcywgYXJncyApO1xuXHRcdH07XG5cdH1cblx0aWYgKCBwYXJhbXMgPT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gc291cmNlO1xuXHR9XG5cdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgcGFyYW1zLmNvbnN0cnVjdG9yICE9PSBBcnJheSAgKSB7XG5cdFx0cGFyYW1zID0gJC5tYWtlQXJyYXkoIGFyZ3VtZW50cyApLnNsaWNlKCAxICk7XG5cdH1cblx0aWYgKCBwYXJhbXMuY29uc3RydWN0b3IgIT09IEFycmF5ICkge1xuXHRcdHBhcmFtcyA9IFsgcGFyYW1zIF07XG5cdH1cblx0JC5lYWNoKCBwYXJhbXMsIGZ1bmN0aW9uKCBpLCBuICkge1xuXHRcdHNvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKCBuZXcgUmVnRXhwKCBcIlxcXFx7XCIgKyBpICsgXCJcXFxcfVwiLCBcImdcIiApLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBuO1xuXHRcdH0gKTtcblx0fSApO1xuXHRyZXR1cm4gc291cmNlO1xufTtcblxuJC5leHRlbmQoICQudmFsaWRhdG9yLCB7XG5cblx0ZGVmYXVsdHM6IHtcblx0XHRtZXNzYWdlczoge30sXG5cdFx0Z3JvdXBzOiB7fSxcblx0XHRydWxlczoge30sXG5cdFx0ZXJyb3JDbGFzczogXCJlcnJvclwiLFxuXHRcdHBlbmRpbmdDbGFzczogXCJwZW5kaW5nXCIsXG5cdFx0dmFsaWRDbGFzczogXCJ2YWxpZFwiLFxuXHRcdGVycm9yRWxlbWVudDogXCJsYWJlbFwiLFxuXHRcdGZvY3VzQ2xlYW51cDogZmFsc2UsXG5cdFx0Zm9jdXNJbnZhbGlkOiB0cnVlLFxuXHRcdGVycm9yQ29udGFpbmVyOiAkKCBbXSApLFxuXHRcdGVycm9yTGFiZWxDb250YWluZXI6ICQoIFtdICksXG5cdFx0b25zdWJtaXQ6IHRydWUsXG5cdFx0aWdub3JlOiBcIjpoaWRkZW5cIixcblx0XHRpZ25vcmVUaXRsZTogZmFsc2UsXG5cdFx0b25mb2N1c2luOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdHRoaXMubGFzdEFjdGl2ZSA9IGVsZW1lbnQ7XG5cblx0XHRcdC8vIEhpZGUgZXJyb3IgbGFiZWwgYW5kIHJlbW92ZSBlcnJvciBjbGFzcyBvbiBmb2N1cyBpZiBlbmFibGVkXG5cdFx0XHRpZiAoIHRoaXMuc2V0dGluZ3MuZm9jdXNDbGVhbnVwICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy51bmhpZ2hsaWdodC5jYWxsKCB0aGlzLCBlbGVtZW50LCB0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MsIHRoaXMuc2V0dGluZ3MudmFsaWRDbGFzcyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuaGlkZVRoZXNlKCB0aGlzLmVycm9yc0ZvciggZWxlbWVudCApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvbmZvY3Vzb3V0OiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdGlmICggIXRoaXMuY2hlY2thYmxlKCBlbGVtZW50ICkgJiYgKCBlbGVtZW50Lm5hbWUgaW4gdGhpcy5zdWJtaXR0ZWQgfHwgIXRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSApICkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQoIGVsZW1lbnQgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9ua2V5dXA6IGZ1bmN0aW9uKCBlbGVtZW50LCBldmVudCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgcmV2YWxpZGF0ZSB0aGUgZmllbGQgd2hlbiBwcmVzc2luZyBvbmUgb2YgdGhlIGZvbGxvd2luZyBrZXlzXG5cdFx0XHQvLyBTaGlmdCAgICAgICA9PiAxNlxuXHRcdFx0Ly8gQ3RybCAgICAgICAgPT4gMTdcblx0XHRcdC8vIEFsdCAgICAgICAgID0+IDE4XG5cdFx0XHQvLyBDYXBzIGxvY2sgICA9PiAyMFxuXHRcdFx0Ly8gRW5kICAgICAgICAgPT4gMzVcblx0XHRcdC8vIEhvbWUgICAgICAgID0+IDM2XG5cdFx0XHQvLyBMZWZ0IGFycm93ICA9PiAzN1xuXHRcdFx0Ly8gVXAgYXJyb3cgICAgPT4gMzhcblx0XHRcdC8vIFJpZ2h0IGFycm93ID0+IDM5XG5cdFx0XHQvLyBEb3duIGFycm93ICA9PiA0MFxuXHRcdFx0Ly8gSW5zZXJ0ICAgICAgPT4gNDVcblx0XHRcdC8vIE51bSBsb2NrICAgID0+IDE0NFxuXHRcdFx0Ly8gQWx0R3Iga2V5ICAgPT4gMjI1XG5cdFx0XHR2YXIgZXhjbHVkZWRLZXlzID0gW1xuXHRcdFx0XHQxNiwgMTcsIDE4LCAyMCwgMzUsIDM2LCAzNyxcblx0XHRcdFx0MzgsIDM5LCA0MCwgNDUsIDE0NCwgMjI1XG5cdFx0XHRdO1xuXG5cdFx0XHRpZiAoIGV2ZW50LndoaWNoID09PSA5ICYmIHRoaXMuZWxlbWVudFZhbHVlKCBlbGVtZW50ICkgPT09IFwiXCIgfHwgJC5pbkFycmF5KCBldmVudC5rZXlDb2RlLCBleGNsdWRlZEtleXMgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQubmFtZSBpbiB0aGlzLnN1Ym1pdHRlZCB8fCBlbGVtZW50Lm5hbWUgaW4gdGhpcy5pbnZhbGlkICkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQoIGVsZW1lbnQgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9uY2xpY2s6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXG5cdFx0XHQvLyBDbGljayBvbiBzZWxlY3RzLCByYWRpb2J1dHRvbnMgYW5kIGNoZWNrYm94ZXNcblx0XHRcdGlmICggZWxlbWVudC5uYW1lIGluIHRoaXMuc3VibWl0dGVkICkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQoIGVsZW1lbnQgKTtcblxuXHRcdFx0Ly8gT3Igb3B0aW9uIGVsZW1lbnRzLCBjaGVjayBwYXJlbnQgc2VsZWN0IGluIHRoYXQgY2FzZVxuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5wYXJlbnROb2RlLm5hbWUgaW4gdGhpcy5zdWJtaXR0ZWQgKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudCggZWxlbWVudC5wYXJlbnROb2RlICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRoaWdobGlnaHQ6IGZ1bmN0aW9uKCBlbGVtZW50LCBlcnJvckNsYXNzLCB2YWxpZENsYXNzICkge1xuXHRcdFx0aWYgKCBlbGVtZW50LnR5cGUgPT09IFwicmFkaW9cIiApIHtcblx0XHRcdFx0dGhpcy5maW5kQnlOYW1lKCBlbGVtZW50Lm5hbWUgKS5hZGRDbGFzcyggZXJyb3JDbGFzcyApLnJlbW92ZUNsYXNzKCB2YWxpZENsYXNzICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkKCBlbGVtZW50ICkuYWRkQ2xhc3MoIGVycm9yQ2xhc3MgKS5yZW1vdmVDbGFzcyggdmFsaWRDbGFzcyApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dW5oaWdobGlnaHQ6IGZ1bmN0aW9uKCBlbGVtZW50LCBlcnJvckNsYXNzLCB2YWxpZENsYXNzICkge1xuXHRcdFx0aWYgKCBlbGVtZW50LnR5cGUgPT09IFwicmFkaW9cIiApIHtcblx0XHRcdFx0dGhpcy5maW5kQnlOYW1lKCBlbGVtZW50Lm5hbWUgKS5yZW1vdmVDbGFzcyggZXJyb3JDbGFzcyApLmFkZENsYXNzKCB2YWxpZENsYXNzICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkKCBlbGVtZW50ICkucmVtb3ZlQ2xhc3MoIGVycm9yQ2xhc3MgKS5hZGRDbGFzcyggdmFsaWRDbGFzcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL2pRdWVyeS52YWxpZGF0b3Iuc2V0RGVmYXVsdHMvXG5cdHNldERlZmF1bHRzOiBmdW5jdGlvbiggc2V0dGluZ3MgKSB7XG5cdFx0JC5leHRlbmQoICQudmFsaWRhdG9yLmRlZmF1bHRzLCBzZXR0aW5ncyApO1xuXHR9LFxuXG5cdG1lc3NhZ2VzOiB7XG5cdFx0cmVxdWlyZWQ6IFwiVGhpcyBmaWVsZCBpcyByZXF1aXJlZC5cIixcblx0XHRyZW1vdGU6IFwiUGxlYXNlIGZpeCB0aGlzIGZpZWxkLlwiLFxuXHRcdGVtYWlsOiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIGVtYWlsIGFkZHJlc3MuXCIsXG5cdFx0dXJsOiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIFVSTC5cIixcblx0XHRkYXRlOiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIGRhdGUuXCIsXG5cdFx0ZGF0ZUlTTzogXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBkYXRlIChJU08pLlwiLFxuXHRcdG51bWJlcjogXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBudW1iZXIuXCIsXG5cdFx0ZGlnaXRzOiBcIlBsZWFzZSBlbnRlciBvbmx5IGRpZ2l0cy5cIixcblx0XHRlcXVhbFRvOiBcIlBsZWFzZSBlbnRlciB0aGUgc2FtZSB2YWx1ZSBhZ2Fpbi5cIixcblx0XHRtYXhsZW5ndGg6ICQudmFsaWRhdG9yLmZvcm1hdCggXCJQbGVhc2UgZW50ZXIgbm8gbW9yZSB0aGFuIHswfSBjaGFyYWN0ZXJzLlwiICksXG5cdFx0bWlubGVuZ3RoOiAkLnZhbGlkYXRvci5mb3JtYXQoIFwiUGxlYXNlIGVudGVyIGF0IGxlYXN0IHswfSBjaGFyYWN0ZXJzLlwiICksXG5cdFx0cmFuZ2VsZW5ndGg6ICQudmFsaWRhdG9yLmZvcm1hdCggXCJQbGVhc2UgZW50ZXIgYSB2YWx1ZSBiZXR3ZWVuIHswfSBhbmQgezF9IGNoYXJhY3RlcnMgbG9uZy5cIiApLFxuXHRcdHJhbmdlOiAkLnZhbGlkYXRvci5mb3JtYXQoIFwiUGxlYXNlIGVudGVyIGEgdmFsdWUgYmV0d2VlbiB7MH0gYW5kIHsxfS5cIiApLFxuXHRcdG1heDogJC52YWxpZGF0b3IuZm9ybWF0KCBcIlBsZWFzZSBlbnRlciBhIHZhbHVlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB7MH0uXCIgKSxcblx0XHRtaW46ICQudmFsaWRhdG9yLmZvcm1hdCggXCJQbGVhc2UgZW50ZXIgYSB2YWx1ZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gezB9LlwiICksXG5cdFx0c3RlcDogJC52YWxpZGF0b3IuZm9ybWF0KCBcIlBsZWFzZSBlbnRlciBhIG11bHRpcGxlIG9mIHswfS5cIiApXG5cdH0sXG5cblx0YXV0b0NyZWF0ZVJhbmdlczogZmFsc2UsXG5cblx0cHJvdG90eXBlOiB7XG5cblx0XHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMubGFiZWxDb250YWluZXIgPSAkKCB0aGlzLnNldHRpbmdzLmVycm9yTGFiZWxDb250YWluZXIgKTtcblx0XHRcdHRoaXMuZXJyb3JDb250ZXh0ID0gdGhpcy5sYWJlbENvbnRhaW5lci5sZW5ndGggJiYgdGhpcy5sYWJlbENvbnRhaW5lciB8fCAkKCB0aGlzLmN1cnJlbnRGb3JtICk7XG5cdFx0XHR0aGlzLmNvbnRhaW5lcnMgPSAkKCB0aGlzLnNldHRpbmdzLmVycm9yQ29udGFpbmVyICkuYWRkKCB0aGlzLnNldHRpbmdzLmVycm9yTGFiZWxDb250YWluZXIgKTtcblx0XHRcdHRoaXMuc3VibWl0dGVkID0ge307XG5cdFx0XHR0aGlzLnZhbHVlQ2FjaGUgPSB7fTtcblx0XHRcdHRoaXMucGVuZGluZ1JlcXVlc3QgPSAwO1xuXHRcdFx0dGhpcy5wZW5kaW5nID0ge307XG5cdFx0XHR0aGlzLmludmFsaWQgPSB7fTtcblx0XHRcdHRoaXMucmVzZXQoKTtcblxuXHRcdFx0dmFyIGdyb3VwcyA9ICggdGhpcy5ncm91cHMgPSB7fSApLFxuXHRcdFx0XHRydWxlcztcblx0XHRcdCQuZWFjaCggdGhpcy5zZXR0aW5ncy5ncm91cHMsIGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnNwbGl0KCAvXFxzLyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdCQuZWFjaCggdmFsdWUsIGZ1bmN0aW9uKCBpbmRleCwgbmFtZSApIHtcblx0XHRcdFx0XHRncm91cHNbIG5hbWUgXSA9IGtleTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fSApO1xuXHRcdFx0cnVsZXMgPSB0aGlzLnNldHRpbmdzLnJ1bGVzO1xuXHRcdFx0JC5lYWNoKCBydWxlcywgZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdHJ1bGVzWyBrZXkgXSA9ICQudmFsaWRhdG9yLm5vcm1hbGl6ZVJ1bGUoIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cblx0XHRcdGZ1bmN0aW9uIGRlbGVnYXRlKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTZXQgZm9ybSBleHBhbmRvIG9uIGNvbnRlbnRlZGl0YWJsZVxuXHRcdFx0XHRpZiAoICF0aGlzLmZvcm0gJiYgdGhpcy5oYXNBdHRyaWJ1dGUoIFwiY29udGVudGVkaXRhYmxlXCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmZvcm0gPSAkKCB0aGlzICkuY2xvc2VzdCggXCJmb3JtXCIgKVsgMCBdO1xuXHRcdFx0XHRcdHRoaXMubmFtZSA9ICQoIHRoaXMgKS5hdHRyKCBcIm5hbWVcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHZhbGlkYXRvciA9ICQuZGF0YSggdGhpcy5mb3JtLCBcInZhbGlkYXRvclwiICksXG5cdFx0XHRcdFx0ZXZlbnRUeXBlID0gXCJvblwiICsgZXZlbnQudHlwZS5yZXBsYWNlKCAvXnZhbGlkYXRlLywgXCJcIiApLFxuXHRcdFx0XHRcdHNldHRpbmdzID0gdmFsaWRhdG9yLnNldHRpbmdzO1xuXHRcdFx0XHRpZiAoIHNldHRpbmdzWyBldmVudFR5cGUgXSAmJiAhJCggdGhpcyApLmlzKCBzZXR0aW5ncy5pZ25vcmUgKSApIHtcblx0XHRcdFx0XHRzZXR0aW5nc1sgZXZlbnRUeXBlIF0uY2FsbCggdmFsaWRhdG9yLCB0aGlzLCBldmVudCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCQoIHRoaXMuY3VycmVudEZvcm0gKVxuXHRcdFx0XHQub24oIFwiZm9jdXNpbi52YWxpZGF0ZSBmb2N1c291dC52YWxpZGF0ZSBrZXl1cC52YWxpZGF0ZVwiLFxuXHRcdFx0XHRcdFwiOnRleHQsIFt0eXBlPSdwYXNzd29yZCddLCBbdHlwZT0nZmlsZSddLCBzZWxlY3QsIHRleHRhcmVhLCBbdHlwZT0nbnVtYmVyJ10sIFt0eXBlPSdzZWFyY2gnXSwgXCIgK1xuXHRcdFx0XHRcdFwiW3R5cGU9J3RlbCddLCBbdHlwZT0ndXJsJ10sIFt0eXBlPSdlbWFpbCddLCBbdHlwZT0nZGF0ZXRpbWUnXSwgW3R5cGU9J2RhdGUnXSwgW3R5cGU9J21vbnRoJ10sIFwiICtcblx0XHRcdFx0XHRcIlt0eXBlPSd3ZWVrJ10sIFt0eXBlPSd0aW1lJ10sIFt0eXBlPSdkYXRldGltZS1sb2NhbCddLCBbdHlwZT0ncmFuZ2UnXSwgW3R5cGU9J2NvbG9yJ10sIFwiICtcblx0XHRcdFx0XHRcIlt0eXBlPSdyYWRpbyddLCBbdHlwZT0nY2hlY2tib3gnXSwgW2NvbnRlbnRlZGl0YWJsZV0sIFt0eXBlPSdidXR0b24nXVwiLCBkZWxlZ2F0ZSApXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lLCBvbGRJRVxuXHRcdFx0XHQvLyBcInNlbGVjdFwiIGlzIHByb3ZpZGVkIGFzIGV2ZW50LnRhcmdldCB3aGVuIGNsaWNraW5nIGEgb3B0aW9uXG5cdFx0XHRcdC5vbiggXCJjbGljay52YWxpZGF0ZVwiLCBcInNlbGVjdCwgb3B0aW9uLCBbdHlwZT0ncmFkaW8nXSwgW3R5cGU9J2NoZWNrYm94J11cIiwgZGVsZWdhdGUgKTtcblxuXHRcdFx0aWYgKCB0aGlzLnNldHRpbmdzLmludmFsaWRIYW5kbGVyICkge1xuXHRcdFx0XHQkKCB0aGlzLmN1cnJlbnRGb3JtICkub24oIFwiaW52YWxpZC1mb3JtLnZhbGlkYXRlXCIsIHRoaXMuc2V0dGluZ3MuaW52YWxpZEhhbmRsZXIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9WYWxpZGF0b3IuZm9ybS9cblx0XHRmb3JtOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuY2hlY2tGb3JtKCk7XG5cdFx0XHQkLmV4dGVuZCggdGhpcy5zdWJtaXR0ZWQsIHRoaXMuZXJyb3JNYXAgKTtcblx0XHRcdHRoaXMuaW52YWxpZCA9ICQuZXh0ZW5kKCB7fSwgdGhpcy5lcnJvck1hcCApO1xuXHRcdFx0aWYgKCAhdGhpcy52YWxpZCgpICkge1xuXHRcdFx0XHQkKCB0aGlzLmN1cnJlbnRGb3JtICkudHJpZ2dlckhhbmRsZXIoIFwiaW52YWxpZC1mb3JtXCIsIFsgdGhpcyBdICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNob3dFcnJvcnMoKTtcblx0XHRcdHJldHVybiB0aGlzLnZhbGlkKCk7XG5cdFx0fSxcblxuXHRcdGNoZWNrRm9ybTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnByZXBhcmVGb3JtKCk7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGVsZW1lbnRzID0gKCB0aGlzLmN1cnJlbnRFbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoKSApOyBlbGVtZW50c1sgaSBdOyBpKysgKSB7XG5cdFx0XHRcdHRoaXMuY2hlY2soIGVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnZhbGlkKCk7XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvVmFsaWRhdG9yLmVsZW1lbnQvXG5cdFx0ZWxlbWVudDogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgY2xlYW5FbGVtZW50ID0gdGhpcy5jbGVhbiggZWxlbWVudCApLFxuXHRcdFx0XHRjaGVja0VsZW1lbnQgPSB0aGlzLnZhbGlkYXRpb25UYXJnZXRGb3IoIGNsZWFuRWxlbWVudCApLFxuXHRcdFx0XHR2ID0gdGhpcyxcblx0XHRcdFx0cmVzdWx0ID0gdHJ1ZSxcblx0XHRcdFx0cnMsIGdyb3VwO1xuXG5cdFx0XHRpZiAoIGNoZWNrRWxlbWVudCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5pbnZhbGlkWyBjbGVhbkVsZW1lbnQubmFtZSBdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5wcmVwYXJlRWxlbWVudCggY2hlY2tFbGVtZW50ICk7XG5cdFx0XHRcdHRoaXMuY3VycmVudEVsZW1lbnRzID0gJCggY2hlY2tFbGVtZW50ICk7XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBlbGVtZW50IGlzIGdyb3VwZWQsIHRoZW4gdmFsaWRhdGUgYWxsIGdyb3VwIGVsZW1lbnRzIGFscmVhZHlcblx0XHRcdFx0Ly8gY29udGFpbmluZyBhIHZhbHVlXG5cdFx0XHRcdGdyb3VwID0gdGhpcy5ncm91cHNbIGNoZWNrRWxlbWVudC5uYW1lIF07XG5cdFx0XHRcdGlmICggZ3JvdXAgKSB7XG5cdFx0XHRcdFx0JC5lYWNoKCB0aGlzLmdyb3VwcywgZnVuY3Rpb24oIG5hbWUsIHRlc3Rncm91cCApIHtcblx0XHRcdFx0XHRcdGlmICggdGVzdGdyb3VwID09PSBncm91cCAmJiBuYW1lICE9PSBjaGVja0VsZW1lbnQubmFtZSApIHtcblx0XHRcdFx0XHRcdFx0Y2xlYW5FbGVtZW50ID0gdi52YWxpZGF0aW9uVGFyZ2V0Rm9yKCB2LmNsZWFuKCB2LmZpbmRCeU5hbWUoIG5hbWUgKSApICk7XG5cdFx0XHRcdFx0XHRcdGlmICggY2xlYW5FbGVtZW50ICYmIGNsZWFuRWxlbWVudC5uYW1lIGluIHYuaW52YWxpZCApIHtcblx0XHRcdFx0XHRcdFx0XHR2LmN1cnJlbnRFbGVtZW50cy5wdXNoKCBjbGVhbkVsZW1lbnQgKTtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQgPSB2LmNoZWNrKCBjbGVhbkVsZW1lbnQgKSAmJiByZXN1bHQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRycyA9IHRoaXMuY2hlY2soIGNoZWNrRWxlbWVudCApICE9PSBmYWxzZTtcblx0XHRcdFx0cmVzdWx0ID0gcmVzdWx0ICYmIHJzO1xuXHRcdFx0XHRpZiAoIHJzICkge1xuXHRcdFx0XHRcdHRoaXMuaW52YWxpZFsgY2hlY2tFbGVtZW50Lm5hbWUgXSA9IGZhbHNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuaW52YWxpZFsgY2hlY2tFbGVtZW50Lm5hbWUgXSA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoICF0aGlzLm51bWJlck9mSW52YWxpZHMoKSApIHtcblxuXHRcdFx0XHRcdC8vIEhpZGUgZXJyb3IgY29udGFpbmVycyBvbiBsYXN0IGVycm9yXG5cdFx0XHRcdFx0dGhpcy50b0hpZGUgPSB0aGlzLnRvSGlkZS5hZGQoIHRoaXMuY29udGFpbmVycyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc2hvd0Vycm9ycygpO1xuXG5cdFx0XHRcdC8vIEFkZCBhcmlhLWludmFsaWQgc3RhdHVzIGZvciBzY3JlZW4gcmVhZGVyc1xuXHRcdFx0XHQkKCBlbGVtZW50ICkuYXR0ciggXCJhcmlhLWludmFsaWRcIiwgIXJzICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvVmFsaWRhdG9yLnNob3dFcnJvcnMvXG5cdFx0c2hvd0Vycm9yczogZnVuY3Rpb24oIGVycm9ycyApIHtcblx0XHRcdGlmICggZXJyb3JzICkge1xuXHRcdFx0XHR2YXIgdmFsaWRhdG9yID0gdGhpcztcblxuXHRcdFx0XHQvLyBBZGQgaXRlbXMgdG8gZXJyb3IgbGlzdCBhbmQgbWFwXG5cdFx0XHRcdCQuZXh0ZW5kKCB0aGlzLmVycm9yTWFwLCBlcnJvcnMgKTtcblx0XHRcdFx0dGhpcy5lcnJvckxpc3QgPSAkLm1hcCggdGhpcy5lcnJvck1hcCwgZnVuY3Rpb24oIG1lc3NhZ2UsIG5hbWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdG1lc3NhZ2U6IG1lc3NhZ2UsXG5cdFx0XHRcdFx0XHRlbGVtZW50OiB2YWxpZGF0b3IuZmluZEJ5TmFtZSggbmFtZSApWyAwIF1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGl0ZW1zIGZyb20gc3VjY2VzcyBsaXN0XG5cdFx0XHRcdHRoaXMuc3VjY2Vzc0xpc3QgPSAkLmdyZXAoIHRoaXMuc3VjY2Vzc0xpc3QsIGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0XHRcdHJldHVybiAhKCBlbGVtZW50Lm5hbWUgaW4gZXJyb3JzICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5zZXR0aW5ncy5zaG93RXJyb3JzICkge1xuXHRcdFx0XHR0aGlzLnNldHRpbmdzLnNob3dFcnJvcnMuY2FsbCggdGhpcywgdGhpcy5lcnJvck1hcCwgdGhpcy5lcnJvckxpc3QgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZGVmYXVsdFNob3dFcnJvcnMoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9WYWxpZGF0b3IucmVzZXRGb3JtL1xuXHRcdHJlc2V0Rm9ybTogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICQuZm4ucmVzZXRGb3JtICkge1xuXHRcdFx0XHQkKCB0aGlzLmN1cnJlbnRGb3JtICkucmVzZXRGb3JtKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmludmFsaWQgPSB7fTtcblx0XHRcdHRoaXMuc3VibWl0dGVkID0ge307XG5cdFx0XHR0aGlzLnByZXBhcmVGb3JtKCk7XG5cdFx0XHR0aGlzLmhpZGVFcnJvcnMoKTtcblx0XHRcdHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoKVxuXHRcdFx0XHQucmVtb3ZlRGF0YSggXCJwcmV2aW91c1ZhbHVlXCIgKVxuXHRcdFx0XHQucmVtb3ZlQXR0ciggXCJhcmlhLWludmFsaWRcIiApO1xuXG5cdFx0XHR0aGlzLnJlc2V0RWxlbWVudHMoIGVsZW1lbnRzICk7XG5cdFx0fSxcblxuXHRcdHJlc2V0RWxlbWVudHM6IGZ1bmN0aW9uKCBlbGVtZW50cyApIHtcblx0XHRcdHZhciBpO1xuXG5cdFx0XHRpZiAoIHRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBlbGVtZW50c1sgaSBdOyBpKysgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy51bmhpZ2hsaWdodC5jYWxsKCB0aGlzLCBlbGVtZW50c1sgaSBdLFxuXHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzLCBcIlwiICk7XG5cdFx0XHRcdFx0dGhpcy5maW5kQnlOYW1lKCBlbGVtZW50c1sgaSBdLm5hbWUgKS5yZW1vdmVDbGFzcyggdGhpcy5zZXR0aW5ncy52YWxpZENsYXNzICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRzXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKCB0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MgKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggdGhpcy5zZXR0aW5ncy52YWxpZENsYXNzICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdG51bWJlck9mSW52YWxpZHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMub2JqZWN0TGVuZ3RoKCB0aGlzLmludmFsaWQgKTtcblx0XHR9LFxuXG5cdFx0b2JqZWN0TGVuZ3RoOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0LyoganNoaW50IHVudXNlZDogZmFsc2UgKi9cblx0XHRcdHZhciBjb3VudCA9IDAsXG5cdFx0XHRcdGk7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblxuXHRcdFx0XHQvLyBUaGlzIGNoZWNrIGFsbG93cyBjb3VudGluZyBlbGVtZW50cyB3aXRoIGVtcHR5IGVycm9yXG5cdFx0XHRcdC8vIG1lc3NhZ2UgYXMgaW52YWxpZCBlbGVtZW50c1xuXHRcdFx0XHRpZiAoIG9ialsgaSBdICE9PSB1bmRlZmluZWQgJiYgb2JqWyBpIF0gIT09IG51bGwgJiYgb2JqWyBpIF0gIT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjb3VudDtcblx0XHR9LFxuXG5cdFx0aGlkZUVycm9yczogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmhpZGVUaGVzZSggdGhpcy50b0hpZGUgKTtcblx0XHR9LFxuXG5cdFx0aGlkZVRoZXNlOiBmdW5jdGlvbiggZXJyb3JzICkge1xuXHRcdFx0ZXJyb3JzLm5vdCggdGhpcy5jb250YWluZXJzICkudGV4dCggXCJcIiApO1xuXHRcdFx0dGhpcy5hZGRXcmFwcGVyKCBlcnJvcnMgKS5oaWRlKCk7XG5cdFx0fSxcblxuXHRcdHZhbGlkOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLnNpemUoKSA9PT0gMDtcblx0XHR9LFxuXG5cdFx0c2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lcnJvckxpc3QubGVuZ3RoO1xuXHRcdH0sXG5cblx0XHRmb2N1c0ludmFsaWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCB0aGlzLnNldHRpbmdzLmZvY3VzSW52YWxpZCApIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQkKCB0aGlzLmZpbmRMYXN0QWN0aXZlKCkgfHwgdGhpcy5lcnJvckxpc3QubGVuZ3RoICYmIHRoaXMuZXJyb3JMaXN0WyAwIF0uZWxlbWVudCB8fCBbXSApXG5cdFx0XHRcdFx0LmZpbHRlciggXCI6dmlzaWJsZVwiIClcblx0XHRcdFx0XHQuZm9jdXMoKVxuXG5cdFx0XHRcdFx0Ly8gTWFudWFsbHkgdHJpZ2dlciBmb2N1c2luIGV2ZW50OyB3aXRob3V0IGl0LCBmb2N1c2luIGhhbmRsZXIgaXNuJ3QgY2FsbGVkLCBmaW5kTGFzdEFjdGl2ZSB3b24ndCBoYXZlIGFueXRoaW5nIHRvIGZpbmRcblx0XHRcdFx0XHQudHJpZ2dlciggXCJmb2N1c2luXCIgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyBJZ25vcmUgSUUgdGhyb3dpbmcgZXJyb3JzIHdoZW4gZm9jdXNpbmcgaGlkZGVuIGVsZW1lbnRzXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0ZmluZExhc3RBY3RpdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGxhc3RBY3RpdmUgPSB0aGlzLmxhc3RBY3RpdmU7XG5cdFx0XHRyZXR1cm4gbGFzdEFjdGl2ZSAmJiAkLmdyZXAoIHRoaXMuZXJyb3JMaXN0LCBmdW5jdGlvbiggbiApIHtcblx0XHRcdFx0cmV0dXJuIG4uZWxlbWVudC5uYW1lID09PSBsYXN0QWN0aXZlLm5hbWU7XG5cdFx0XHR9ICkubGVuZ3RoID09PSAxICYmIGxhc3RBY3RpdmU7XG5cdFx0fSxcblxuXHRcdGVsZW1lbnRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB2YWxpZGF0b3IgPSB0aGlzLFxuXHRcdFx0XHRydWxlc0NhY2hlID0ge307XG5cblx0XHRcdC8vIFNlbGVjdCBhbGwgdmFsaWQgaW5wdXRzIGluc2lkZSB0aGUgZm9ybSAobm8gc3VibWl0IG9yIHJlc2V0IGJ1dHRvbnMpXG5cdFx0XHRyZXR1cm4gJCggdGhpcy5jdXJyZW50Rm9ybSApXG5cdFx0XHQuZmluZCggXCJpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgW2NvbnRlbnRlZGl0YWJsZV1cIiApXG5cdFx0XHQubm90KCBcIjpzdWJtaXQsIDpyZXNldCwgOmltYWdlLCA6ZGlzYWJsZWRcIiApXG5cdFx0XHQubm90KCB0aGlzLnNldHRpbmdzLmlnbm9yZSApXG5cdFx0XHQuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5hbWUgPSB0aGlzLm5hbWUgfHwgJCggdGhpcyApLmF0dHIoIFwibmFtZVwiICk7IC8vIEZvciBjb250ZW50ZWRpdGFibGVcblx0XHRcdFx0aWYgKCAhbmFtZSAmJiB2YWxpZGF0b3Iuc2V0dGluZ3MuZGVidWcgJiYgd2luZG93LmNvbnNvbGUgKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvciggXCIlbyBoYXMgbm8gbmFtZSBhc3NpZ25lZFwiLCB0aGlzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgZm9ybSBleHBhbmRvIG9uIGNvbnRlbnRlZGl0YWJsZVxuXHRcdFx0XHRpZiAoIHRoaXMuaGFzQXR0cmlidXRlKCBcImNvbnRlbnRlZGl0YWJsZVwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5mb3JtID0gJCggdGhpcyApLmNsb3Nlc3QoIFwiZm9ybVwiIClbIDAgXTtcblx0XHRcdFx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2VsZWN0IG9ubHkgdGhlIGZpcnN0IGVsZW1lbnQgZm9yIGVhY2ggbmFtZSwgYW5kIG9ubHkgdGhvc2Ugd2l0aCBydWxlcyBzcGVjaWZpZWRcblx0XHRcdFx0aWYgKCBuYW1lIGluIHJ1bGVzQ2FjaGUgfHwgIXZhbGlkYXRvci5vYmplY3RMZW5ndGgoICQoIHRoaXMgKS5ydWxlcygpICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cnVsZXNDYWNoZVsgbmFtZSBdID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9ICk7XG5cdFx0fSxcblxuXHRcdGNsZWFuOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gJCggc2VsZWN0b3IgKVsgMCBdO1xuXHRcdH0sXG5cblx0XHRlcnJvcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGVycm9yQ2xhc3MgPSB0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3Muc3BsaXQoIFwiIFwiICkuam9pbiggXCIuXCIgKTtcblx0XHRcdHJldHVybiAkKCB0aGlzLnNldHRpbmdzLmVycm9yRWxlbWVudCArIFwiLlwiICsgZXJyb3JDbGFzcywgdGhpcy5lcnJvckNvbnRleHQgKTtcblx0XHR9LFxuXG5cdFx0cmVzZXRJbnRlcm5hbHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5zdWNjZXNzTGlzdCA9IFtdO1xuXHRcdFx0dGhpcy5lcnJvckxpc3QgPSBbXTtcblx0XHRcdHRoaXMuZXJyb3JNYXAgPSB7fTtcblx0XHRcdHRoaXMudG9TaG93ID0gJCggW10gKTtcblx0XHRcdHRoaXMudG9IaWRlID0gJCggW10gKTtcblx0XHR9LFxuXG5cdFx0cmVzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZXNldEludGVybmFscygpO1xuXHRcdFx0dGhpcy5jdXJyZW50RWxlbWVudHMgPSAkKCBbXSApO1xuXHRcdH0sXG5cblx0XHRwcmVwYXJlRm9ybTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnJlc2V0KCk7XG5cdFx0XHR0aGlzLnRvSGlkZSA9IHRoaXMuZXJyb3JzKCkuYWRkKCB0aGlzLmNvbnRhaW5lcnMgKTtcblx0XHR9LFxuXG5cdFx0cHJlcGFyZUVsZW1lbnQ6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0dGhpcy5yZXNldCgpO1xuXHRcdFx0dGhpcy50b0hpZGUgPSB0aGlzLmVycm9yc0ZvciggZWxlbWVudCApO1xuXHRcdH0sXG5cblx0XHRlbGVtZW50VmFsdWU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyICRlbGVtZW50ID0gJCggZWxlbWVudCApLFxuXHRcdFx0XHR0eXBlID0gZWxlbWVudC50eXBlLFxuXHRcdFx0XHR2YWwsIGlkeDtcblxuXHRcdFx0aWYgKCB0eXBlID09PSBcInJhZGlvXCIgfHwgdHlwZSA9PT0gXCJjaGVja2JveFwiICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5maW5kQnlOYW1lKCBlbGVtZW50Lm5hbWUgKS5maWx0ZXIoIFwiOmNoZWNrZWRcIiApLnZhbCgpO1xuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgZWxlbWVudC52YWxpZGl0eSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW1lbnQudmFsaWRpdHkuYmFkSW5wdXQgPyBcIk5hTlwiIDogJGVsZW1lbnQudmFsKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbWVudC5oYXNBdHRyaWJ1dGUoIFwiY29udGVudGVkaXRhYmxlXCIgKSApIHtcblx0XHRcdFx0dmFsID0gJGVsZW1lbnQudGV4dCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gJGVsZW1lbnQudmFsKCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJmaWxlXCIgKSB7XG5cblx0XHRcdFx0Ly8gTW9kZXJuIGJyb3dzZXIgKGNocm9tZSAmIHNhZmFyaSlcblx0XHRcdFx0aWYgKCB2YWwuc3Vic3RyKCAwLCAxMiApID09PSBcIkM6XFxcXGZha2VwYXRoXFxcXFwiICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWwuc3Vic3RyKCAxMiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTGVnYWN5IGJyb3dzZXJzXG5cdFx0XHRcdC8vIFVuaXgtYmFzZWQgcGF0aFxuXHRcdFx0XHRpZHggPSB2YWwubGFzdEluZGV4T2YoIFwiL1wiICk7XG5cdFx0XHRcdGlmICggaWR4ID49IDAgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbC5zdWJzdHIoIGlkeCArIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdpbmRvd3MtYmFzZWQgcGF0aFxuXHRcdFx0XHRpZHggPSB2YWwubGFzdEluZGV4T2YoIFwiXFxcXFwiICk7XG5cdFx0XHRcdGlmICggaWR4ID49IDAgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbC5zdWJzdHIoIGlkeCArIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEp1c3QgdGhlIGZpbGUgbmFtZVxuXHRcdFx0XHRyZXR1cm4gdmFsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdHJldHVybiB2YWwucmVwbGFjZSggL1xcci9nLCBcIlwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH0sXG5cblx0XHRjaGVjazogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHRlbGVtZW50ID0gdGhpcy52YWxpZGF0aW9uVGFyZ2V0Rm9yKCB0aGlzLmNsZWFuKCBlbGVtZW50ICkgKTtcblxuXHRcdFx0dmFyIHJ1bGVzID0gJCggZWxlbWVudCApLnJ1bGVzKCksXG5cdFx0XHRcdHJ1bGVzQ291bnQgPSAkLm1hcCggcnVsZXMsIGZ1bmN0aW9uKCBuLCBpICkge1xuXHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHR9ICkubGVuZ3RoLFxuXHRcdFx0XHRkZXBlbmRlbmN5TWlzbWF0Y2ggPSBmYWxzZSxcblx0XHRcdFx0dmFsID0gdGhpcy5lbGVtZW50VmFsdWUoIGVsZW1lbnQgKSxcblx0XHRcdFx0cmVzdWx0LCBtZXRob2QsIHJ1bGUsIG5vcm1hbGl6ZXI7XG5cblx0XHRcdC8vIFByaW9yaXRpemUgdGhlIGxvY2FsIG5vcm1hbGl6ZXIgZGVmaW5lZCBmb3IgdGhpcyBlbGVtZW50IG92ZXIgdGhlIGdsb2JhbCBvbmVcblx0XHRcdC8vIGlmIHRoZSBmb3JtZXIgZXhpc3RzLCBvdGhlcndpc2UgdXNlciB0aGUgZ2xvYmFsIG9uZSBpbiBjYXNlIGl0IGV4aXN0cy5cblx0XHRcdGlmICggdHlwZW9mIHJ1bGVzLm5vcm1hbGl6ZXIgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdFx0bm9ybWFsaXplciA9IHJ1bGVzLm5vcm1hbGl6ZXI7XG5cdFx0XHR9IGVsc2UgaWYgKFx0dHlwZW9mIHRoaXMuc2V0dGluZ3Mubm9ybWFsaXplciA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRcdFx0XHRub3JtYWxpemVyID0gdGhpcy5zZXR0aW5ncy5ub3JtYWxpemVyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBub3JtYWxpemVyIGlzIGRlZmluZWQsIHRoZW4gY2FsbCBpdCB0byByZXRyZWl2ZSB0aGUgY2hhbmdlZCB2YWx1ZSBpbnN0ZWFkXG5cdFx0XHQvLyBvZiB1c2luZyB0aGUgcmVhbCBvbmUuXG5cdFx0XHQvLyBOb3RlIHRoYXQgYHRoaXNgIGluIHRoZSBub3JtYWxpemVyIGlzIGBlbGVtZW50YC5cblx0XHRcdGlmICggbm9ybWFsaXplciApIHtcblx0XHRcdFx0dmFsID0gbm9ybWFsaXplci5jYWxsKCBlbGVtZW50LCB2YWwgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGVvZiB2YWwgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGUgbm9ybWFsaXplciBzaG91bGQgcmV0dXJuIGEgc3RyaW5nIHZhbHVlLlwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBEZWxldGUgdGhlIG5vcm1hbGl6ZXIgZnJvbSBydWxlcyB0byBhdm9pZCB0cmVhdGluZyBpdCBhcyBhIHByZS1kZWZpbmVkIG1ldGhvZC5cblx0XHRcdFx0ZGVsZXRlIHJ1bGVzLm5vcm1hbGl6ZXI7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIG1ldGhvZCBpbiBydWxlcyApIHtcblx0XHRcdFx0cnVsZSA9IHsgbWV0aG9kOiBtZXRob2QsIHBhcmFtZXRlcnM6IHJ1bGVzWyBtZXRob2QgXSB9O1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJlc3VsdCA9ICQudmFsaWRhdG9yLm1ldGhvZHNbIG1ldGhvZCBdLmNhbGwoIHRoaXMsIHZhbCwgZWxlbWVudCwgcnVsZS5wYXJhbWV0ZXJzICk7XG5cblx0XHRcdFx0XHQvLyBJZiBhIG1ldGhvZCBpbmRpY2F0ZXMgdGhhdCB0aGUgZmllbGQgaXMgb3B0aW9uYWwgYW5kIHRoZXJlZm9yZSB2YWxpZCxcblx0XHRcdFx0XHQvLyBkb24ndCBtYXJrIGl0IGFzIHZhbGlkIHdoZW4gdGhlcmUgYXJlIG5vIG90aGVyIHJ1bGVzXG5cdFx0XHRcdFx0aWYgKCByZXN1bHQgPT09IFwiZGVwZW5kZW5jeS1taXNtYXRjaFwiICYmIHJ1bGVzQ291bnQgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRkZXBlbmRlbmN5TWlzbWF0Y2ggPSB0cnVlO1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRlcGVuZGVuY3lNaXNtYXRjaCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCByZXN1bHQgPT09IFwicGVuZGluZ1wiICkge1xuXHRcdFx0XHRcdFx0dGhpcy50b0hpZGUgPSB0aGlzLnRvSGlkZS5ub3QoIHRoaXMuZXJyb3JzRm9yKCBlbGVtZW50ICkgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoICFyZXN1bHQgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmZvcm1hdEFuZEFkZCggZWxlbWVudCwgcnVsZSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLnNldHRpbmdzLmRlYnVnICYmIHdpbmRvdy5jb25zb2xlICkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coIFwiRXhjZXB0aW9uIG9jY3VycmVkIHdoZW4gY2hlY2tpbmcgZWxlbWVudCBcIiArIGVsZW1lbnQuaWQgKyBcIiwgY2hlY2sgdGhlICdcIiArIHJ1bGUubWV0aG9kICsgXCInIG1ldGhvZC5cIiwgZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGUgaW5zdGFuY2VvZiBUeXBlRXJyb3IgKSB7XG5cdFx0XHRcdFx0XHRlLm1lc3NhZ2UgKz0gXCIuICBFeGNlcHRpb24gb2NjdXJyZWQgd2hlbiBjaGVja2luZyBlbGVtZW50IFwiICsgZWxlbWVudC5pZCArIFwiLCBjaGVjayB0aGUgJ1wiICsgcnVsZS5tZXRob2QgKyBcIicgbWV0aG9kLlwiO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZGVwZW5kZW5jeU1pc21hdGNoICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMub2JqZWN0TGVuZ3RoKCBydWxlcyApICkge1xuXHRcdFx0XHR0aGlzLnN1Y2Nlc3NMaXN0LnB1c2goIGVsZW1lbnQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBSZXR1cm4gdGhlIGN1c3RvbSBtZXNzYWdlIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCBhbmQgdmFsaWRhdGlvbiBtZXRob2Rcblx0XHQvLyBzcGVjaWZpZWQgaW4gdGhlIGVsZW1lbnQncyBIVE1MNSBkYXRhIGF0dHJpYnV0ZVxuXHRcdC8vIHJldHVybiB0aGUgZ2VuZXJpYyBtZXNzYWdlIGlmIHByZXNlbnQgYW5kIG5vIG1ldGhvZCBzcGVjaWZpYyBtZXNzYWdlIGlzIHByZXNlbnRcblx0XHRjdXN0b21EYXRhTWVzc2FnZTogZnVuY3Rpb24oIGVsZW1lbnQsIG1ldGhvZCApIHtcblx0XHRcdHJldHVybiAkKCBlbGVtZW50ICkuZGF0YSggXCJtc2dcIiArIG1ldGhvZC5jaGFyQXQoIDAgKS50b1VwcGVyQ2FzZSgpICtcblx0XHRcdFx0bWV0aG9kLnN1YnN0cmluZyggMSApLnRvTG93ZXJDYXNlKCkgKSB8fCAkKCBlbGVtZW50ICkuZGF0YSggXCJtc2dcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBSZXR1cm4gdGhlIGN1c3RvbSBtZXNzYWdlIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCBuYW1lIGFuZCB2YWxpZGF0aW9uIG1ldGhvZFxuXHRcdGN1c3RvbU1lc3NhZ2U6IGZ1bmN0aW9uKCBuYW1lLCBtZXRob2QgKSB7XG5cdFx0XHR2YXIgbSA9IHRoaXMuc2V0dGluZ3MubWVzc2FnZXNbIG5hbWUgXTtcblx0XHRcdHJldHVybiBtICYmICggbS5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nID8gbSA6IG1bIG1ldGhvZCBdICk7XG5cdFx0fSxcblxuXHRcdC8vIFJldHVybiB0aGUgZmlyc3QgZGVmaW5lZCBhcmd1bWVudCwgYWxsb3dpbmcgZW1wdHkgc3RyaW5nc1xuXHRcdGZpbmREZWZpbmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBhcmd1bWVudHNbIGkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBhcmd1bWVudHNbIGkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9LFxuXG5cdFx0Ly8gVGhlIHNlY29uZCBwYXJhbWV0ZXIgJ3J1bGUnIHVzZWQgdG8gYmUgYSBzdHJpbmcsIGFuZCBleHRlbmRlZCB0byBhbiBvYmplY3QgbGl0ZXJhbFxuXHRcdC8vIG9mIHRoZSBmb2xsb3dpbmcgZm9ybTpcblx0XHQvLyBydWxlID0ge1xuXHRcdC8vICAgICBtZXRob2Q6IFwibWV0aG9kIG5hbWVcIixcblx0XHQvLyAgICAgcGFyYW1ldGVyczogXCJ0aGUgZ2l2ZW4gbWV0aG9kIHBhcmFtZXRlcnNcIlxuXHRcdC8vIH1cblx0XHQvL1xuXHRcdC8vIFRoZSBvbGQgYmVoYXZpb3Igc3RpbGwgc3VwcG9ydGVkLCBrZXB0IHRvIG1haW50YWluIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aFxuXHRcdC8vIG9sZCBjb2RlLCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdFx0ZGVmYXVsdE1lc3NhZ2U6IGZ1bmN0aW9uKCBlbGVtZW50LCBydWxlICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgcnVsZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0cnVsZSA9IHsgbWV0aG9kOiBydWxlIH07XG5cdFx0XHR9XG5cblx0XHRcdHZhciBtZXNzYWdlID0gdGhpcy5maW5kRGVmaW5lZChcblx0XHRcdFx0XHR0aGlzLmN1c3RvbU1lc3NhZ2UoIGVsZW1lbnQubmFtZSwgcnVsZS5tZXRob2QgKSxcblx0XHRcdFx0XHR0aGlzLmN1c3RvbURhdGFNZXNzYWdlKCBlbGVtZW50LCBydWxlLm1ldGhvZCApLFxuXG5cdFx0XHRcdFx0Ly8gJ3RpdGxlJyBpcyBuZXZlciB1bmRlZmluZWQsIHNvIGhhbmRsZSBlbXB0eSBzdHJpbmcgYXMgdW5kZWZpbmVkXG5cdFx0XHRcdFx0IXRoaXMuc2V0dGluZ3MuaWdub3JlVGl0bGUgJiYgZWxlbWVudC50aXRsZSB8fCB1bmRlZmluZWQsXG5cdFx0XHRcdFx0JC52YWxpZGF0b3IubWVzc2FnZXNbIHJ1bGUubWV0aG9kIF0sXG5cdFx0XHRcdFx0XCI8c3Ryb25nPldhcm5pbmc6IE5vIG1lc3NhZ2UgZGVmaW5lZCBmb3IgXCIgKyBlbGVtZW50Lm5hbWUgKyBcIjwvc3Ryb25nPlwiXG5cdFx0XHRcdCksXG5cdFx0XHRcdHRoZXJlZ2V4ID0gL1xcJD9cXHsoXFxkKylcXH0vZztcblx0XHRcdGlmICggdHlwZW9mIG1lc3NhZ2UgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdFx0bWVzc2FnZSA9IG1lc3NhZ2UuY2FsbCggdGhpcywgcnVsZS5wYXJhbWV0ZXJzLCBlbGVtZW50ICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGVyZWdleC50ZXN0KCBtZXNzYWdlICkgKSB7XG5cdFx0XHRcdG1lc3NhZ2UgPSAkLnZhbGlkYXRvci5mb3JtYXQoIG1lc3NhZ2UucmVwbGFjZSggdGhlcmVnZXgsIFwieyQxfVwiICksIHJ1bGUucGFyYW1ldGVycyApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWVzc2FnZTtcblx0XHR9LFxuXG5cdFx0Zm9ybWF0QW5kQWRkOiBmdW5jdGlvbiggZWxlbWVudCwgcnVsZSApIHtcblx0XHRcdHZhciBtZXNzYWdlID0gdGhpcy5kZWZhdWx0TWVzc2FnZSggZWxlbWVudCwgcnVsZSApO1xuXG5cdFx0XHR0aGlzLmVycm9yTGlzdC5wdXNoKCB7XG5cdFx0XHRcdG1lc3NhZ2U6IG1lc3NhZ2UsXG5cdFx0XHRcdGVsZW1lbnQ6IGVsZW1lbnQsXG5cdFx0XHRcdG1ldGhvZDogcnVsZS5tZXRob2Rcblx0XHRcdH0gKTtcblxuXHRcdFx0dGhpcy5lcnJvck1hcFsgZWxlbWVudC5uYW1lIF0gPSBtZXNzYWdlO1xuXHRcdFx0dGhpcy5zdWJtaXR0ZWRbIGVsZW1lbnQubmFtZSBdID0gbWVzc2FnZTtcblx0XHR9LFxuXG5cdFx0YWRkV3JhcHBlcjogZnVuY3Rpb24oIHRvVG9nZ2xlICkge1xuXHRcdFx0aWYgKCB0aGlzLnNldHRpbmdzLndyYXBwZXIgKSB7XG5cdFx0XHRcdHRvVG9nZ2xlID0gdG9Ub2dnbGUuYWRkKCB0b1RvZ2dsZS5wYXJlbnQoIHRoaXMuc2V0dGluZ3Mud3JhcHBlciApICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdG9Ub2dnbGU7XG5cdFx0fSxcblxuXHRcdGRlZmF1bHRTaG93RXJyb3JzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpLCBlbGVtZW50cywgZXJyb3I7XG5cdFx0XHRmb3IgKCBpID0gMDsgdGhpcy5lcnJvckxpc3RbIGkgXTsgaSsrICkge1xuXHRcdFx0XHRlcnJvciA9IHRoaXMuZXJyb3JMaXN0WyBpIF07XG5cdFx0XHRcdGlmICggdGhpcy5zZXR0aW5ncy5oaWdobGlnaHQgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5oaWdobGlnaHQuY2FsbCggdGhpcywgZXJyb3IuZWxlbWVudCwgdGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzLCB0aGlzLnNldHRpbmdzLnZhbGlkQ2xhc3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnNob3dMYWJlbCggZXJyb3IuZWxlbWVudCwgZXJyb3IubWVzc2FnZSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmVycm9yTGlzdC5sZW5ndGggKSB7XG5cdFx0XHRcdHRoaXMudG9TaG93ID0gdGhpcy50b1Nob3cuYWRkKCB0aGlzLmNvbnRhaW5lcnMgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5zZXR0aW5ncy5zdWNjZXNzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgdGhpcy5zdWNjZXNzTGlzdFsgaSBdOyBpKysgKSB7XG5cdFx0XHRcdFx0dGhpcy5zaG93TGFiZWwoIHRoaXMuc3VjY2Vzc0xpc3RbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBlbGVtZW50cyA9IHRoaXMudmFsaWRFbGVtZW50cygpOyBlbGVtZW50c1sgaSBdOyBpKysgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy51bmhpZ2hsaWdodC5jYWxsKCB0aGlzLCBlbGVtZW50c1sgaSBdLCB0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MsIHRoaXMuc2V0dGluZ3MudmFsaWRDbGFzcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnRvSGlkZSA9IHRoaXMudG9IaWRlLm5vdCggdGhpcy50b1Nob3cgKTtcblx0XHRcdHRoaXMuaGlkZUVycm9ycygpO1xuXHRcdFx0dGhpcy5hZGRXcmFwcGVyKCB0aGlzLnRvU2hvdyApLnNob3coKTtcblx0XHR9LFxuXG5cdFx0dmFsaWRFbGVtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5jdXJyZW50RWxlbWVudHMubm90KCB0aGlzLmludmFsaWRFbGVtZW50cygpICk7XG5cdFx0fSxcblxuXHRcdGludmFsaWRFbGVtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gJCggdGhpcy5lcnJvckxpc3QgKS5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50O1xuXHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHRzaG93TGFiZWw6IGZ1bmN0aW9uKCBlbGVtZW50LCBtZXNzYWdlICkge1xuXHRcdFx0dmFyIHBsYWNlLCBncm91cCwgZXJyb3JJRCwgdixcblx0XHRcdFx0ZXJyb3IgPSB0aGlzLmVycm9yc0ZvciggZWxlbWVudCApLFxuXHRcdFx0XHRlbGVtZW50SUQgPSB0aGlzLmlkT3JOYW1lKCBlbGVtZW50ICksXG5cdFx0XHRcdGRlc2NyaWJlZEJ5ID0gJCggZWxlbWVudCApLmF0dHIoIFwiYXJpYS1kZXNjcmliZWRieVwiICk7XG5cblx0XHRcdGlmICggZXJyb3IubGVuZ3RoICkge1xuXG5cdFx0XHRcdC8vIFJlZnJlc2ggZXJyb3Ivc3VjY2VzcyBjbGFzc1xuXHRcdFx0XHRlcnJvci5yZW1vdmVDbGFzcyggdGhpcy5zZXR0aW5ncy52YWxpZENsYXNzICkuYWRkQ2xhc3MoIHRoaXMuc2V0dGluZ3MuZXJyb3JDbGFzcyApO1xuXG5cdFx0XHRcdC8vIFJlcGxhY2UgbWVzc2FnZSBvbiBleGlzdGluZyBsYWJlbFxuXHRcdFx0XHRlcnJvci5odG1sKCBtZXNzYWdlICk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIENyZWF0ZSBlcnJvciBlbGVtZW50XG5cdFx0XHRcdGVycm9yID0gJCggXCI8XCIgKyB0aGlzLnNldHRpbmdzLmVycm9yRWxlbWVudCArIFwiPlwiIClcblx0XHRcdFx0XHQuYXR0ciggXCJpZFwiLCBlbGVtZW50SUQgKyBcIi1lcnJvclwiIClcblx0XHRcdFx0XHQuYWRkQ2xhc3MoIHRoaXMuc2V0dGluZ3MuZXJyb3JDbGFzcyApXG5cdFx0XHRcdFx0Lmh0bWwoIG1lc3NhZ2UgfHwgXCJcIiApO1xuXG5cdFx0XHRcdC8vIE1haW50YWluIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCB0byBiZSBwbGFjZWQgaW50byB0aGUgRE9NXG5cdFx0XHRcdHBsYWNlID0gZXJyb3I7XG5cdFx0XHRcdGlmICggdGhpcy5zZXR0aW5ncy53cmFwcGVyICkge1xuXG5cdFx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoZSBlbGVtZW50IGlzIHZpc2libGUsIGV2ZW4gaW4gSUVcblx0XHRcdFx0XHQvLyBhY3R1YWxseSBzaG93aW5nIHRoZSB3cmFwcGVkIGVsZW1lbnQgaXMgaGFuZGxlZCBlbHNld2hlcmVcblx0XHRcdFx0XHRwbGFjZSA9IGVycm9yLmhpZGUoKS5zaG93KCkud3JhcCggXCI8XCIgKyB0aGlzLnNldHRpbmdzLndyYXBwZXIgKyBcIi8+XCIgKS5wYXJlbnQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRoaXMubGFiZWxDb250YWluZXIubGVuZ3RoICkge1xuXHRcdFx0XHRcdHRoaXMubGFiZWxDb250YWluZXIuYXBwZW5kKCBwbGFjZSApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLnNldHRpbmdzLmVycm9yUGxhY2VtZW50ICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuZXJyb3JQbGFjZW1lbnQuY2FsbCggdGhpcywgcGxhY2UsICQoIGVsZW1lbnQgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBsYWNlLmluc2VydEFmdGVyKCBlbGVtZW50ICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMaW5rIGVycm9yIGJhY2sgdG8gdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCBlcnJvci5pcyggXCJsYWJlbFwiICkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB0aGUgZXJyb3IgaXMgYSBsYWJlbCwgdGhlbiBhc3NvY2lhdGUgdXNpbmcgJ2Zvcidcblx0XHRcdFx0XHRlcnJvci5hdHRyKCBcImZvclwiLCBlbGVtZW50SUQgKTtcblxuXHRcdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGlzIG5vdCBhIGNoaWxkIG9mIGFuIGFzc29jaWF0ZWQgbGFiZWwsIHRoZW4gaXQncyBuZWNlc3Nhcnlcblx0XHRcdFx0XHQvLyB0byBleHBsaWNpdGx5IGFwcGx5IGFyaWEtZGVzY3JpYmVkYnlcblx0XHRcdFx0fSBlbHNlIGlmICggZXJyb3IucGFyZW50cyggXCJsYWJlbFtmb3I9J1wiICsgdGhpcy5lc2NhcGVDc3NNZXRhKCBlbGVtZW50SUQgKSArIFwiJ11cIiApLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdFx0XHRlcnJvcklEID0gZXJyb3IuYXR0ciggXCJpZFwiICk7XG5cblx0XHRcdFx0XHQvLyBSZXNwZWN0IGV4aXN0aW5nIG5vbi1lcnJvciBhcmlhLWRlc2NyaWJlZGJ5XG5cdFx0XHRcdFx0aWYgKCAhZGVzY3JpYmVkQnkgKSB7XG5cdFx0XHRcdFx0XHRkZXNjcmliZWRCeSA9IGVycm9ySUQ7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggIWRlc2NyaWJlZEJ5Lm1hdGNoKCBuZXcgUmVnRXhwKCBcIlxcXFxiXCIgKyB0aGlzLmVzY2FwZUNzc01ldGEoIGVycm9ySUQgKSArIFwiXFxcXGJcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEFkZCB0byBlbmQgb2YgbGlzdCBpZiBub3QgYWxyZWFkeSBwcmVzZW50XG5cdFx0XHRcdFx0XHRkZXNjcmliZWRCeSArPSBcIiBcIiArIGVycm9ySUQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCQoIGVsZW1lbnQgKS5hdHRyKCBcImFyaWEtZGVzY3JpYmVkYnlcIiwgZGVzY3JpYmVkQnkgKTtcblxuXHRcdFx0XHRcdC8vIElmIHRoaXMgZWxlbWVudCBpcyBncm91cGVkLCB0aGVuIGFzc2lnbiB0byBhbGwgZWxlbWVudHMgaW4gdGhlIHNhbWUgZ3JvdXBcblx0XHRcdFx0XHRncm91cCA9IHRoaXMuZ3JvdXBzWyBlbGVtZW50Lm5hbWUgXTtcblx0XHRcdFx0XHRpZiAoIGdyb3VwICkge1xuXHRcdFx0XHRcdFx0diA9IHRoaXM7XG5cdFx0XHRcdFx0XHQkLmVhY2goIHYuZ3JvdXBzLCBmdW5jdGlvbiggbmFtZSwgdGVzdGdyb3VwICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHRlc3Rncm91cCA9PT0gZ3JvdXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0JCggXCJbbmFtZT0nXCIgKyB2LmVzY2FwZUNzc01ldGEoIG5hbWUgKSArIFwiJ11cIiwgdi5jdXJyZW50Rm9ybSApXG5cdFx0XHRcdFx0XHRcdFx0XHQuYXR0ciggXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIGVycm9yLmF0dHIoIFwiaWRcIiApICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggIW1lc3NhZ2UgJiYgdGhpcy5zZXR0aW5ncy5zdWNjZXNzICkge1xuXHRcdFx0XHRlcnJvci50ZXh0KCBcIlwiICk7XG5cdFx0XHRcdGlmICggdHlwZW9mIHRoaXMuc2V0dGluZ3Muc3VjY2VzcyA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRlcnJvci5hZGRDbGFzcyggdGhpcy5zZXR0aW5ncy5zdWNjZXNzICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5zdWNjZXNzKCBlcnJvciwgZWxlbWVudCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnRvU2hvdyA9IHRoaXMudG9TaG93LmFkZCggZXJyb3IgKTtcblx0XHR9LFxuXG5cdFx0ZXJyb3JzRm9yOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdHZhciBuYW1lID0gdGhpcy5lc2NhcGVDc3NNZXRhKCB0aGlzLmlkT3JOYW1lKCBlbGVtZW50ICkgKSxcblx0XHRcdFx0ZGVzY3JpYmVyID0gJCggZWxlbWVudCApLmF0dHIoIFwiYXJpYS1kZXNjcmliZWRieVwiICksXG5cdFx0XHRcdHNlbGVjdG9yID0gXCJsYWJlbFtmb3I9J1wiICsgbmFtZSArIFwiJ10sIGxhYmVsW2Zvcj0nXCIgKyBuYW1lICsgXCInXSAqXCI7XG5cblx0XHRcdC8vICdhcmlhLWRlc2NyaWJlZGJ5JyBzaG91bGQgZGlyZWN0bHkgcmVmZXJlbmNlIHRoZSBlcnJvciBlbGVtZW50XG5cdFx0XHRpZiAoIGRlc2NyaWJlciApIHtcblx0XHRcdFx0c2VsZWN0b3IgPSBzZWxlY3RvciArIFwiLCAjXCIgKyB0aGlzLmVzY2FwZUNzc01ldGEoIGRlc2NyaWJlciApXG5cdFx0XHRcdFx0LnJlcGxhY2UoIC9cXHMrL2csIFwiLCAjXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHRcdFx0LmVycm9ycygpXG5cdFx0XHRcdC5maWx0ZXIoIHNlbGVjdG9yICk7XG5cdFx0fSxcblxuXHRcdC8vIFNlZSBodHRwczovL2FwaS5qcXVlcnkuY29tL2NhdGVnb3J5L3NlbGVjdG9ycy8sIGZvciBDU1Ncblx0XHQvLyBtZXRhLWNoYXJhY3RlcnMgdGhhdCBzaG91bGQgYmUgZXNjYXBlZCBpbiBvcmRlciB0byBiZSB1c2VkIHdpdGggSlF1ZXJ5XG5cdFx0Ly8gYXMgYSBsaXRlcmFsIHBhcnQgb2YgYSBuYW1lL2lkIG9yIGFueSBzZWxlY3Rvci5cblx0XHRlc2NhcGVDc3NNZXRhOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCAvKFtcXFxcIVwiIyQlJicoKSorLC4vOjs8PT4/QFxcW1xcXV5ge3x9fl0pL2csIFwiXFxcXCQxXCIgKTtcblx0XHR9LFxuXG5cdFx0aWRPck5hbWU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ3JvdXBzWyBlbGVtZW50Lm5hbWUgXSB8fCAoIHRoaXMuY2hlY2thYmxlKCBlbGVtZW50ICkgPyBlbGVtZW50Lm5hbWUgOiBlbGVtZW50LmlkIHx8IGVsZW1lbnQubmFtZSApO1xuXHRcdH0sXG5cblx0XHR2YWxpZGF0aW9uVGFyZ2V0Rm9yOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblxuXHRcdFx0Ly8gSWYgcmFkaW8vY2hlY2tib3gsIHZhbGlkYXRlIGZpcnN0IGVsZW1lbnQgaW4gZ3JvdXAgaW5zdGVhZFxuXHRcdFx0aWYgKCB0aGlzLmNoZWNrYWJsZSggZWxlbWVudCApICkge1xuXHRcdFx0XHRlbGVtZW50ID0gdGhpcy5maW5kQnlOYW1lKCBlbGVtZW50Lm5hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWx3YXlzIGFwcGx5IGlnbm9yZSBmaWx0ZXJcblx0XHRcdHJldHVybiAkKCBlbGVtZW50ICkubm90KCB0aGlzLnNldHRpbmdzLmlnbm9yZSApWyAwIF07XG5cdFx0fSxcblxuXHRcdGNoZWNrYWJsZTogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gKCAvcmFkaW98Y2hlY2tib3gvaSApLnRlc3QoIGVsZW1lbnQudHlwZSApO1xuXHRcdH0sXG5cblx0XHRmaW5kQnlOYW1lOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRcdHJldHVybiAkKCB0aGlzLmN1cnJlbnRGb3JtICkuZmluZCggXCJbbmFtZT0nXCIgKyB0aGlzLmVzY2FwZUNzc01ldGEoIG5hbWUgKSArIFwiJ11cIiApO1xuXHRcdH0sXG5cblx0XHRnZXRMZW5ndGg6IGZ1bmN0aW9uKCB2YWx1ZSwgZWxlbWVudCApIHtcblx0XHRcdHN3aXRjaCAoIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcblx0XHRcdGNhc2UgXCJzZWxlY3RcIjpcblx0XHRcdFx0cmV0dXJuICQoIFwib3B0aW9uOnNlbGVjdGVkXCIsIGVsZW1lbnQgKS5sZW5ndGg7XG5cdFx0XHRjYXNlIFwiaW5wdXRcIjpcblx0XHRcdFx0aWYgKCB0aGlzLmNoZWNrYWJsZSggZWxlbWVudCApICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmZpbmRCeU5hbWUoIGVsZW1lbnQubmFtZSApLmZpbHRlciggXCI6Y2hlY2tlZFwiICkubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWUubGVuZ3RoO1xuXHRcdH0sXG5cblx0XHRkZXBlbmQ6IGZ1bmN0aW9uKCBwYXJhbSwgZWxlbWVudCApIHtcblx0XHRcdHJldHVybiB0aGlzLmRlcGVuZFR5cGVzWyB0eXBlb2YgcGFyYW0gXSA/IHRoaXMuZGVwZW5kVHlwZXNbIHR5cGVvZiBwYXJhbSBdKCBwYXJhbSwgZWxlbWVudCApIDogdHJ1ZTtcblx0XHR9LFxuXG5cdFx0ZGVwZW5kVHlwZXM6IHtcblx0XHRcdFwiYm9vbGVhblwiOiBmdW5jdGlvbiggcGFyYW0gKSB7XG5cdFx0XHRcdHJldHVybiBwYXJhbTtcblx0XHRcdH0sXG5cdFx0XHRcInN0cmluZ1wiOiBmdW5jdGlvbiggcGFyYW0sIGVsZW1lbnQgKSB7XG5cdFx0XHRcdHJldHVybiAhISQoIHBhcmFtLCBlbGVtZW50LmZvcm0gKS5sZW5ndGg7XG5cdFx0XHR9LFxuXHRcdFx0XCJmdW5jdGlvblwiOiBmdW5jdGlvbiggcGFyYW0sIGVsZW1lbnQgKSB7XG5cdFx0XHRcdHJldHVybiBwYXJhbSggZWxlbWVudCApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRvcHRpb25hbDogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgdmFsID0gdGhpcy5lbGVtZW50VmFsdWUoIGVsZW1lbnQgKTtcblx0XHRcdHJldHVybiAhJC52YWxpZGF0b3IubWV0aG9kcy5yZXF1aXJlZC5jYWxsKCB0aGlzLCB2YWwsIGVsZW1lbnQgKSAmJiBcImRlcGVuZGVuY3ktbWlzbWF0Y2hcIjtcblx0XHR9LFxuXG5cdFx0c3RhcnRSZXF1ZXN0OiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdGlmICggIXRoaXMucGVuZGluZ1sgZWxlbWVudC5uYW1lIF0gKSB7XG5cdFx0XHRcdHRoaXMucGVuZGluZ1JlcXVlc3QrKztcblx0XHRcdFx0JCggZWxlbWVudCApLmFkZENsYXNzKCB0aGlzLnNldHRpbmdzLnBlbmRpbmdDbGFzcyApO1xuXHRcdFx0XHR0aGlzLnBlbmRpbmdbIGVsZW1lbnQubmFtZSBdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c3RvcFJlcXVlc3Q6IGZ1bmN0aW9uKCBlbGVtZW50LCB2YWxpZCApIHtcblx0XHRcdHRoaXMucGVuZGluZ1JlcXVlc3QtLTtcblxuXHRcdFx0Ly8gU29tZXRpbWVzIHN5bmNocm9uaXphdGlvbiBmYWlscywgbWFrZSBzdXJlIHBlbmRpbmdSZXF1ZXN0IGlzIG5ldmVyIDwgMFxuXHRcdFx0aWYgKCB0aGlzLnBlbmRpbmdSZXF1ZXN0IDwgMCApIHtcblx0XHRcdFx0dGhpcy5wZW5kaW5nUmVxdWVzdCA9IDA7XG5cdFx0XHR9XG5cdFx0XHRkZWxldGUgdGhpcy5wZW5kaW5nWyBlbGVtZW50Lm5hbWUgXTtcblx0XHRcdCQoIGVsZW1lbnQgKS5yZW1vdmVDbGFzcyggdGhpcy5zZXR0aW5ncy5wZW5kaW5nQ2xhc3MgKTtcblx0XHRcdGlmICggdmFsaWQgJiYgdGhpcy5wZW5kaW5nUmVxdWVzdCA9PT0gMCAmJiB0aGlzLmZvcm1TdWJtaXR0ZWQgJiYgdGhpcy5mb3JtKCkgKSB7XG5cdFx0XHRcdCQoIHRoaXMuY3VycmVudEZvcm0gKS5zdWJtaXQoKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgdGhlIGhpZGRlbiBpbnB1dCB0aGF0IHdhcyB1c2VkIGFzIGEgcmVwbGFjZW1lbnQgZm9yIHRoZVxuXHRcdFx0XHQvLyBtaXNzaW5nIHN1Ym1pdCBidXR0b24uIFRoZSBoaWRkZW4gaW5wdXQgaXMgYWRkZWQgYnkgYGhhbmRsZSgpYFxuXHRcdFx0XHQvLyB0byBlbnN1cmUgdGhhdCB0aGUgdmFsdWUgb2YgdGhlIHVzZWQgc3VibWl0IGJ1dHRvbiBpcyBwYXNzZWQgb25cblx0XHRcdFx0Ly8gZm9yIHNjcmlwdGVkIHN1Ym1pdHMgdHJpZ2dlcmVkIGJ5IHRoaXMgbWV0aG9kXG5cdFx0XHRcdGlmICggdGhpcy5zdWJtaXRCdXR0b24gKSB7XG5cdFx0XHRcdFx0JCggXCJpbnB1dDpoaWRkZW5bbmFtZT0nXCIgKyB0aGlzLnN1Ym1pdEJ1dHRvbi5uYW1lICsgXCInXVwiLCB0aGlzLmN1cnJlbnRGb3JtICkucmVtb3ZlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmZvcm1TdWJtaXR0ZWQgPSBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoICF2YWxpZCAmJiB0aGlzLnBlbmRpbmdSZXF1ZXN0ID09PSAwICYmIHRoaXMuZm9ybVN1Ym1pdHRlZCApIHtcblx0XHRcdFx0JCggdGhpcy5jdXJyZW50Rm9ybSApLnRyaWdnZXJIYW5kbGVyKCBcImludmFsaWQtZm9ybVwiLCBbIHRoaXMgXSApO1xuXHRcdFx0XHR0aGlzLmZvcm1TdWJtaXR0ZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0cHJldmlvdXNWYWx1ZTogZnVuY3Rpb24oIGVsZW1lbnQsIG1ldGhvZCApIHtcblx0XHRcdG1ldGhvZCA9IHR5cGVvZiBtZXRob2QgPT09IFwic3RyaW5nXCIgJiYgbWV0aG9kIHx8IFwicmVtb3RlXCI7XG5cblx0XHRcdHJldHVybiAkLmRhdGEoIGVsZW1lbnQsIFwicHJldmlvdXNWYWx1ZVwiICkgfHwgJC5kYXRhKCBlbGVtZW50LCBcInByZXZpb3VzVmFsdWVcIiwge1xuXHRcdFx0XHRvbGQ6IG51bGwsXG5cdFx0XHRcdHZhbGlkOiB0cnVlLFxuXHRcdFx0XHRtZXNzYWdlOiB0aGlzLmRlZmF1bHRNZXNzYWdlKCBlbGVtZW50LCB7IG1ldGhvZDogbWV0aG9kIH0gKVxuXHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHQvLyBDbGVhbnMgdXAgYWxsIGZvcm1zIGFuZCBlbGVtZW50cywgcmVtb3ZlcyB2YWxpZGF0b3Itc3BlY2lmaWMgZXZlbnRzXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnJlc2V0Rm9ybSgpO1xuXG5cdFx0XHQkKCB0aGlzLmN1cnJlbnRGb3JtIClcblx0XHRcdFx0Lm9mZiggXCIudmFsaWRhdGVcIiApXG5cdFx0XHRcdC5yZW1vdmVEYXRhKCBcInZhbGlkYXRvclwiIClcblx0XHRcdFx0LmZpbmQoIFwiLnZhbGlkYXRlLWVxdWFsVG8tYmx1clwiIClcblx0XHRcdFx0XHQub2ZmKCBcIi52YWxpZGF0ZS1lcXVhbFRvXCIgKVxuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggXCJ2YWxpZGF0ZS1lcXVhbFRvLWJsdXJcIiApO1xuXHRcdH1cblxuXHR9LFxuXG5cdGNsYXNzUnVsZVNldHRpbmdzOiB7XG5cdFx0cmVxdWlyZWQ6IHsgcmVxdWlyZWQ6IHRydWUgfSxcblx0XHRlbWFpbDogeyBlbWFpbDogdHJ1ZSB9LFxuXHRcdHVybDogeyB1cmw6IHRydWUgfSxcblx0XHRkYXRlOiB7IGRhdGU6IHRydWUgfSxcblx0XHRkYXRlSVNPOiB7IGRhdGVJU086IHRydWUgfSxcblx0XHRudW1iZXI6IHsgbnVtYmVyOiB0cnVlIH0sXG5cdFx0ZGlnaXRzOiB7IGRpZ2l0czogdHJ1ZSB9LFxuXHRcdGNyZWRpdGNhcmQ6IHsgY3JlZGl0Y2FyZDogdHJ1ZSB9XG5cdH0sXG5cblx0YWRkQ2xhc3NSdWxlczogZnVuY3Rpb24oIGNsYXNzTmFtZSwgcnVsZXMgKSB7XG5cdFx0aWYgKCBjbGFzc05hbWUuY29uc3RydWN0b3IgPT09IFN0cmluZyApIHtcblx0XHRcdHRoaXMuY2xhc3NSdWxlU2V0dGluZ3NbIGNsYXNzTmFtZSBdID0gcnVsZXM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdCQuZXh0ZW5kKCB0aGlzLmNsYXNzUnVsZVNldHRpbmdzLCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH0sXG5cblx0Y2xhc3NSdWxlczogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dmFyIHJ1bGVzID0ge30sXG5cdFx0XHRjbGFzc2VzID0gJCggZWxlbWVudCApLmF0dHIoIFwiY2xhc3NcIiApO1xuXG5cdFx0aWYgKCBjbGFzc2VzICkge1xuXHRcdFx0JC5lYWNoKCBjbGFzc2VzLnNwbGl0KCBcIiBcIiApLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzIGluICQudmFsaWRhdG9yLmNsYXNzUnVsZVNldHRpbmdzICkge1xuXHRcdFx0XHRcdCQuZXh0ZW5kKCBydWxlcywgJC52YWxpZGF0b3IuY2xhc3NSdWxlU2V0dGluZ3NbIHRoaXMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBydWxlcztcblx0fSxcblxuXHRub3JtYWxpemVBdHRyaWJ1dGVSdWxlOiBmdW5jdGlvbiggcnVsZXMsIHR5cGUsIG1ldGhvZCwgdmFsdWUgKSB7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSB2YWx1ZSB0byBhIG51bWJlciBmb3IgbnVtYmVyIGlucHV0cywgYW5kIGZvciB0ZXh0IGZvciBiYWNrd2FyZHMgY29tcGFiaWxpdHlcblx0XHQvLyBhbGxvd3MgdHlwZT1cImRhdGVcIiBhbmQgb3RoZXJzIHRvIGJlIGNvbXBhcmVkIGFzIHN0cmluZ3Ncblx0XHRpZiAoIC9taW58bWF4fHN0ZXAvLnRlc3QoIG1ldGhvZCApICYmICggdHlwZSA9PT0gbnVsbCB8fCAvbnVtYmVyfHJhbmdlfHRleHQvLnRlc3QoIHR5cGUgKSApICkge1xuXHRcdFx0dmFsdWUgPSBOdW1iZXIoIHZhbHVlICk7XG5cblx0XHRcdC8vIFN1cHBvcnQgT3BlcmEgTWluaSwgd2hpY2ggcmV0dXJucyBOYU4gZm9yIHVuZGVmaW5lZCBtaW5sZW5ndGhcblx0XHRcdGlmICggaXNOYU4oIHZhbHVlICkgKSB7XG5cdFx0XHRcdHZhbHVlID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgfHwgdmFsdWUgPT09IDAgKSB7XG5cdFx0XHRydWxlc1sgbWV0aG9kIF0gPSB2YWx1ZTtcblx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBtZXRob2QgJiYgdHlwZSAhPT0gXCJyYW5nZVwiICkge1xuXG5cdFx0XHQvLyBFeGNlcHRpb246IHRoZSBqcXVlcnkgdmFsaWRhdGUgJ3JhbmdlJyBtZXRob2Rcblx0XHRcdC8vIGRvZXMgbm90IHRlc3QgZm9yIHRoZSBodG1sNSAncmFuZ2UnIHR5cGVcblx0XHRcdHJ1bGVzWyBtZXRob2QgXSA9IHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdGF0dHJpYnV0ZVJ1bGVzOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR2YXIgcnVsZXMgPSB7fSxcblx0XHRcdCRlbGVtZW50ID0gJCggZWxlbWVudCApLFxuXHRcdFx0dHlwZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApLFxuXHRcdFx0bWV0aG9kLCB2YWx1ZTtcblxuXHRcdGZvciAoIG1ldGhvZCBpbiAkLnZhbGlkYXRvci5tZXRob2RzICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGZvciA8aW5wdXQgcmVxdWlyZWQ+IGluIGJvdGggaHRtbDUgYW5kIG9sZGVyIGJyb3dzZXJzXG5cdFx0XHRpZiAoIG1ldGhvZCA9PT0gXCJyZXF1aXJlZFwiICkge1xuXHRcdFx0XHR2YWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCBtZXRob2QgKTtcblxuXHRcdFx0XHQvLyBTb21lIGJyb3dzZXJzIHJldHVybiBhbiBlbXB0eSBzdHJpbmcgZm9yIHRoZSByZXF1aXJlZCBhdHRyaWJ1dGVcblx0XHRcdFx0Ly8gYW5kIG5vbi1IVE1MNSBicm93c2VycyBtaWdodCBoYXZlIHJlcXVpcmVkPVwiXCIgbWFya3VwXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwiXCIgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2Ugbm9uLUhUTUw1IGJyb3dzZXJzIHRvIHJldHVybiBib29sXG5cdFx0XHRcdHZhbHVlID0gISF2YWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbHVlID0gJGVsZW1lbnQuYXR0ciggbWV0aG9kICk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubm9ybWFsaXplQXR0cmlidXRlUnVsZSggcnVsZXMsIHR5cGUsIG1ldGhvZCwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyAnbWF4bGVuZ3RoJyBtYXkgYmUgcmV0dXJuZWQgYXMgLTEsIDIxNDc0ODM2NDcgKCBJRSApIGFuZCA1MjQyODggKCBzYWZhcmkgKSBmb3IgdGV4dCBpbnB1dHNcblx0XHRpZiAoIHJ1bGVzLm1heGxlbmd0aCAmJiAvLTF8MjE0NzQ4MzY0N3w1MjQyODgvLnRlc3QoIHJ1bGVzLm1heGxlbmd0aCApICkge1xuXHRcdFx0ZGVsZXRlIHJ1bGVzLm1heGxlbmd0aDtcblx0XHR9XG5cblx0XHRyZXR1cm4gcnVsZXM7XG5cdH0sXG5cblx0ZGF0YVJ1bGVzOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR2YXIgcnVsZXMgPSB7fSxcblx0XHRcdCRlbGVtZW50ID0gJCggZWxlbWVudCApLFxuXHRcdFx0dHlwZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApLFxuXHRcdFx0bWV0aG9kLCB2YWx1ZTtcblxuXHRcdGZvciAoIG1ldGhvZCBpbiAkLnZhbGlkYXRvci5tZXRob2RzICkge1xuXHRcdFx0dmFsdWUgPSAkZWxlbWVudC5kYXRhKCBcInJ1bGVcIiArIG1ldGhvZC5jaGFyQXQoIDAgKS50b1VwcGVyQ2FzZSgpICsgbWV0aG9kLnN1YnN0cmluZyggMSApLnRvTG93ZXJDYXNlKCkgKTtcblx0XHRcdHRoaXMubm9ybWFsaXplQXR0cmlidXRlUnVsZSggcnVsZXMsIHR5cGUsIG1ldGhvZCwgdmFsdWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJ1bGVzO1xuXHR9LFxuXG5cdHN0YXRpY1J1bGVzOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHR2YXIgcnVsZXMgPSB7fSxcblx0XHRcdHZhbGlkYXRvciA9ICQuZGF0YSggZWxlbWVudC5mb3JtLCBcInZhbGlkYXRvclwiICk7XG5cblx0XHRpZiAoIHZhbGlkYXRvci5zZXR0aW5ncy5ydWxlcyApIHtcblx0XHRcdHJ1bGVzID0gJC52YWxpZGF0b3Iubm9ybWFsaXplUnVsZSggdmFsaWRhdG9yLnNldHRpbmdzLnJ1bGVzWyBlbGVtZW50Lm5hbWUgXSApIHx8IHt9O1xuXHRcdH1cblx0XHRyZXR1cm4gcnVsZXM7XG5cdH0sXG5cblx0bm9ybWFsaXplUnVsZXM6IGZ1bmN0aW9uKCBydWxlcywgZWxlbWVudCApIHtcblxuXHRcdC8vIEhhbmRsZSBkZXBlbmRlbmN5IGNoZWNrXG5cdFx0JC5lYWNoKCBydWxlcywgZnVuY3Rpb24oIHByb3AsIHZhbCApIHtcblxuXHRcdFx0Ly8gSWdub3JlIHJ1bGUgd2hlbiBwYXJhbSBpcyBleHBsaWNpdGx5IGZhbHNlLCBlZy4gcmVxdWlyZWQ6ZmFsc2Vcblx0XHRcdGlmICggdmFsID09PSBmYWxzZSApIHtcblx0XHRcdFx0ZGVsZXRlIHJ1bGVzWyBwcm9wIF07XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICggdmFsLnBhcmFtIHx8IHZhbC5kZXBlbmRzICkge1xuXHRcdFx0XHR2YXIga2VlcFJ1bGUgPSB0cnVlO1xuXHRcdFx0XHRzd2l0Y2ggKCB0eXBlb2YgdmFsLmRlcGVuZHMgKSB7XG5cdFx0XHRcdGNhc2UgXCJzdHJpbmdcIjpcblx0XHRcdFx0XHRrZWVwUnVsZSA9ICEhJCggdmFsLmRlcGVuZHMsIGVsZW1lbnQuZm9ybSApLmxlbmd0aDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImZ1bmN0aW9uXCI6XG5cdFx0XHRcdFx0a2VlcFJ1bGUgPSB2YWwuZGVwZW5kcy5jYWxsKCBlbGVtZW50LCBlbGVtZW50ICk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBrZWVwUnVsZSApIHtcblx0XHRcdFx0XHRydWxlc1sgcHJvcCBdID0gdmFsLnBhcmFtICE9PSB1bmRlZmluZWQgPyB2YWwucGFyYW0gOiB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCQuZGF0YSggZWxlbWVudC5mb3JtLCBcInZhbGlkYXRvclwiICkucmVzZXRFbGVtZW50cyggJCggZWxlbWVudCApICk7XG5cdFx0XHRcdFx0ZGVsZXRlIHJ1bGVzWyBwcm9wIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHQvLyBFdmFsdWF0ZSBwYXJhbWV0ZXJzXG5cdFx0JC5lYWNoKCBydWxlcywgZnVuY3Rpb24oIHJ1bGUsIHBhcmFtZXRlciApIHtcblx0XHRcdHJ1bGVzWyBydWxlIF0gPSAkLmlzRnVuY3Rpb24oIHBhcmFtZXRlciApICYmIHJ1bGUgIT09IFwibm9ybWFsaXplclwiID8gcGFyYW1ldGVyKCBlbGVtZW50ICkgOiBwYXJhbWV0ZXI7XG5cdFx0fSApO1xuXG5cdFx0Ly8gQ2xlYW4gbnVtYmVyIHBhcmFtZXRlcnNcblx0XHQkLmVhY2goIFsgXCJtaW5sZW5ndGhcIiwgXCJtYXhsZW5ndGhcIiBdLCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggcnVsZXNbIHRoaXMgXSApIHtcblx0XHRcdFx0cnVsZXNbIHRoaXMgXSA9IE51bWJlciggcnVsZXNbIHRoaXMgXSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHQkLmVhY2goIFsgXCJyYW5nZWxlbmd0aFwiLCBcInJhbmdlXCIgXSwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcGFydHM7XG5cdFx0XHRpZiAoIHJ1bGVzWyB0aGlzIF0gKSB7XG5cdFx0XHRcdGlmICggJC5pc0FycmF5KCBydWxlc1sgdGhpcyBdICkgKSB7XG5cdFx0XHRcdFx0cnVsZXNbIHRoaXMgXSA9IFsgTnVtYmVyKCBydWxlc1sgdGhpcyBdWyAwIF0gKSwgTnVtYmVyKCBydWxlc1sgdGhpcyBdWyAxIF0gKSBdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgcnVsZXNbIHRoaXMgXSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRwYXJ0cyA9IHJ1bGVzWyB0aGlzIF0ucmVwbGFjZSggL1tcXFtcXF1dL2csIFwiXCIgKS5zcGxpdCggL1tcXHMsXSsvICk7XG5cdFx0XHRcdFx0cnVsZXNbIHRoaXMgXSA9IFsgTnVtYmVyKCBwYXJ0c1sgMCBdICksIE51bWJlciggcGFydHNbIDEgXSApIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHRpZiAoICQudmFsaWRhdG9yLmF1dG9DcmVhdGVSYW5nZXMgKSB7XG5cblx0XHRcdC8vIEF1dG8tY3JlYXRlIHJhbmdlc1xuXHRcdFx0aWYgKCBydWxlcy5taW4gIT0gbnVsbCAmJiBydWxlcy5tYXggIT0gbnVsbCApIHtcblx0XHRcdFx0cnVsZXMucmFuZ2UgPSBbIHJ1bGVzLm1pbiwgcnVsZXMubWF4IF07XG5cdFx0XHRcdGRlbGV0ZSBydWxlcy5taW47XG5cdFx0XHRcdGRlbGV0ZSBydWxlcy5tYXg7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHJ1bGVzLm1pbmxlbmd0aCAhPSBudWxsICYmIHJ1bGVzLm1heGxlbmd0aCAhPSBudWxsICkge1xuXHRcdFx0XHRydWxlcy5yYW5nZWxlbmd0aCA9IFsgcnVsZXMubWlubGVuZ3RoLCBydWxlcy5tYXhsZW5ndGggXTtcblx0XHRcdFx0ZGVsZXRlIHJ1bGVzLm1pbmxlbmd0aDtcblx0XHRcdFx0ZGVsZXRlIHJ1bGVzLm1heGxlbmd0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcnVsZXM7XG5cdH0sXG5cblx0Ly8gQ29udmVydHMgYSBzaW1wbGUgc3RyaW5nIHRvIGEge3N0cmluZzogdHJ1ZX0gcnVsZSwgZS5nLiwgXCJyZXF1aXJlZFwiIHRvIHtyZXF1aXJlZDp0cnVlfVxuXHRub3JtYWxpemVSdWxlOiBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dmFyIHRyYW5zZm9ybWVkID0ge307XG5cdFx0XHQkLmVhY2goIGRhdGEuc3BsaXQoIC9cXHMvICksIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0cmFuc2Zvcm1lZFsgdGhpcyBdID0gdHJ1ZTtcblx0XHRcdH0gKTtcblx0XHRcdGRhdGEgPSB0cmFuc2Zvcm1lZDtcblx0XHR9XG5cdFx0cmV0dXJuIGRhdGE7XG5cdH0sXG5cblx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9qUXVlcnkudmFsaWRhdG9yLmFkZE1ldGhvZC9cblx0YWRkTWV0aG9kOiBmdW5jdGlvbiggbmFtZSwgbWV0aG9kLCBtZXNzYWdlICkge1xuXHRcdCQudmFsaWRhdG9yLm1ldGhvZHNbIG5hbWUgXSA9IG1ldGhvZDtcblx0XHQkLnZhbGlkYXRvci5tZXNzYWdlc1sgbmFtZSBdID0gbWVzc2FnZSAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZSA6ICQudmFsaWRhdG9yLm1lc3NhZ2VzWyBuYW1lIF07XG5cdFx0aWYgKCBtZXRob2QubGVuZ3RoIDwgMyApIHtcblx0XHRcdCQudmFsaWRhdG9yLmFkZENsYXNzUnVsZXMoIG5hbWUsICQudmFsaWRhdG9yLm5vcm1hbGl6ZVJ1bGUoIG5hbWUgKSApO1xuXHRcdH1cblx0fSxcblxuXHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL2pRdWVyeS52YWxpZGF0b3IubWV0aG9kcy9cblx0bWV0aG9kczoge1xuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9yZXF1aXJlZC1tZXRob2QvXG5cdFx0cmVxdWlyZWQ6IGZ1bmN0aW9uKCB2YWx1ZSwgZWxlbWVudCwgcGFyYW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGlmIGRlcGVuZGVuY3kgaXMgbWV0XG5cdFx0XHRpZiAoICF0aGlzLmRlcGVuZCggcGFyYW0sIGVsZW1lbnQgKSApIHtcblx0XHRcdFx0cmV0dXJuIFwiZGVwZW5kZW5jeS1taXNtYXRjaFwiO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic2VsZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gQ291bGQgYmUgYW4gYXJyYXkgZm9yIHNlbGVjdC1tdWx0aXBsZSBvciBhIHN0cmluZywgYm90aCBhcmUgZmluZSB0aGlzIHdheVxuXHRcdFx0XHR2YXIgdmFsID0gJCggZWxlbWVudCApLnZhbCgpO1xuXHRcdFx0XHRyZXR1cm4gdmFsICYmIHZhbC5sZW5ndGggPiAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmNoZWNrYWJsZSggZWxlbWVudCApICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRMZW5ndGgoIHZhbHVlLCBlbGVtZW50ICkgPiAwO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlLmxlbmd0aCA+IDA7XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvZW1haWwtbWV0aG9kL1xuXHRcdGVtYWlsOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQgKSB7XG5cblx0XHRcdC8vIEZyb20gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCN2YWxpZC1lLW1haWwtYWRkcmVzc1xuXHRcdFx0Ly8gUmV0cmlldmVkIDIwMTQtMDEtMTRcblx0XHRcdC8vIElmIHlvdSBoYXZlIGEgcHJvYmxlbSB3aXRoIHRoaXMgaW1wbGVtZW50YXRpb24sIHJlcG9ydCBhIGJ1ZyBhZ2FpbnN0IHRoZSBhYm92ZSBzcGVjXG5cdFx0XHQvLyBPciB1c2UgY3VzdG9tIG1ldGhvZHMgdG8gaW1wbGVtZW50IHlvdXIgb3duIGVtYWlsIHZhbGlkYXRpb25cblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbmFsKCBlbGVtZW50ICkgfHwgL15bYS16QS1aMC05LiEjJCUmJyorXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC8udGVzdCggdmFsdWUgKTtcblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy91cmwtbWV0aG9kL1xuXHRcdHVybDogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50ICkge1xuXG5cdFx0XHQvLyBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMyBEaWVnbyBQZXJpbmksIE1JVCBsaWNlbnNlZFxuXHRcdFx0Ly8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZHBlcmluaS83MjkyOTRcblx0XHRcdC8vIHNlZSBhbHNvIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9kZW1vL3VybC1yZWdleFxuXHRcdFx0Ly8gbW9kaWZpZWQgdG8gYWxsb3cgcHJvdG9jb2wtcmVsYXRpdmUgVVJMc1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSB8fCAvXig/Oig/Oig/Omh0dHBzP3xmdHApOik/XFwvXFwvKSg/OlxcUysoPzo6XFxTKik/QCk/KD86KD8hKD86MTB8MTI3KSg/OlxcLlxcZHsxLDN9KXszfSkoPyEoPzoxNjlcXC4yNTR8MTkyXFwuMTY4KSg/OlxcLlxcZHsxLDN9KXsyfSkoPyExNzJcXC4oPzoxWzYtOV18MlxcZHwzWzAtMV0pKD86XFwuXFxkezEsM30pezJ9KSg/OlsxLTldXFxkP3wxXFxkXFxkfDJbMDFdXFxkfDIyWzAtM10pKD86XFwuKD86MT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkpezJ9KD86XFwuKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNF0pKXwoPzooPzpbYS16XFx1MDBhMS1cXHVmZmZmMC05XS0qKSpbYS16XFx1MDBhMS1cXHVmZmZmMC05XSspKD86XFwuKD86W2EtelxcdTAwYTEtXFx1ZmZmZjAtOV0tKikqW2EtelxcdTAwYTEtXFx1ZmZmZjAtOV0rKSooPzpcXC4oPzpbYS16XFx1MDBhMS1cXHVmZmZmXXsyLH0pKS4/KSg/OjpcXGR7Miw1fSk/KD86Wy8/I11cXFMqKT8kL2kudGVzdCggdmFsdWUgKTtcblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9kYXRlLW1ldGhvZC9cblx0XHRkYXRlOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25hbCggZWxlbWVudCApIHx8ICEvSW52YWxpZHxOYU4vLnRlc3QoIG5ldyBEYXRlKCB2YWx1ZSApLnRvU3RyaW5nKCkgKTtcblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9kYXRlSVNPLW1ldGhvZC9cblx0XHRkYXRlSVNPOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25hbCggZWxlbWVudCApIHx8IC9eXFxkezR9W1xcL1xcLV0oMD9bMS05XXwxWzAxMl0pW1xcL1xcLV0oMD9bMS05XXxbMTJdWzAtOV18M1swMV0pJC8udGVzdCggdmFsdWUgKTtcblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9udW1iZXItbWV0aG9kL1xuXHRcdG51bWJlcjogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50ICkge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSB8fCAvXig/Oi0/XFxkK3wtP1xcZHsxLDN9KD86LFxcZHszfSkrKT8oPzpcXC5cXGQrKT8kLy50ZXN0KCB2YWx1ZSApO1xuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL2RpZ2l0cy1tZXRob2QvXG5cdFx0ZGlnaXRzOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25hbCggZWxlbWVudCApIHx8IC9eXFxkKyQvLnRlc3QoIHZhbHVlICk7XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvbWlubGVuZ3RoLW1ldGhvZC9cblx0XHRtaW5sZW5ndGg6IGZ1bmN0aW9uKCB2YWx1ZSwgZWxlbWVudCwgcGFyYW0gKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gJC5pc0FycmF5KCB2YWx1ZSApID8gdmFsdWUubGVuZ3RoIDogdGhpcy5nZXRMZW5ndGgoIHZhbHVlLCBlbGVtZW50ICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25hbCggZWxlbWVudCApIHx8IGxlbmd0aCA+PSBwYXJhbTtcblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9tYXhsZW5ndGgtbWV0aG9kL1xuXHRcdG1heGxlbmd0aDogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50LCBwYXJhbSApIHtcblx0XHRcdHZhciBsZW5ndGggPSAkLmlzQXJyYXkoIHZhbHVlICkgPyB2YWx1ZS5sZW5ndGggOiB0aGlzLmdldExlbmd0aCggdmFsdWUsIGVsZW1lbnQgKTtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbmFsKCBlbGVtZW50ICkgfHwgbGVuZ3RoIDw9IHBhcmFtO1xuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL3JhbmdlbGVuZ3RoLW1ldGhvZC9cblx0XHRyYW5nZWxlbmd0aDogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50LCBwYXJhbSApIHtcblx0XHRcdHZhciBsZW5ndGggPSAkLmlzQXJyYXkoIHZhbHVlICkgPyB2YWx1ZS5sZW5ndGggOiB0aGlzLmdldExlbmd0aCggdmFsdWUsIGVsZW1lbnQgKTtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbmFsKCBlbGVtZW50ICkgfHwgKCBsZW5ndGggPj0gcGFyYW1bIDAgXSAmJiBsZW5ndGggPD0gcGFyYW1bIDEgXSApO1xuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL21pbi1tZXRob2QvXG5cdFx0bWluOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQsIHBhcmFtICkge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSB8fCB2YWx1ZSA+PSBwYXJhbTtcblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9tYXgtbWV0aG9kL1xuXHRcdG1heDogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50LCBwYXJhbSApIHtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbmFsKCBlbGVtZW50ICkgfHwgdmFsdWUgPD0gcGFyYW07XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvcmFuZ2UtbWV0aG9kL1xuXHRcdHJhbmdlOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQsIHBhcmFtICkge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSB8fCAoIHZhbHVlID49IHBhcmFtWyAwIF0gJiYgdmFsdWUgPD0gcGFyYW1bIDEgXSApO1xuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL3N0ZXAtbWV0aG9kL1xuXHRcdHN0ZXA6IGZ1bmN0aW9uKCB2YWx1ZSwgZWxlbWVudCwgcGFyYW0gKSB7XG5cdFx0XHR2YXIgdHlwZSA9ICQoIGVsZW1lbnQgKS5hdHRyKCBcInR5cGVcIiApLFxuXHRcdFx0XHRlcnJvck1lc3NhZ2UgPSBcIlN0ZXAgYXR0cmlidXRlIG9uIGlucHV0IHR5cGUgXCIgKyB0eXBlICsgXCIgaXMgbm90IHN1cHBvcnRlZC5cIixcblx0XHRcdFx0c3VwcG9ydGVkVHlwZXMgPSBbIFwidGV4dFwiLCBcIm51bWJlclwiLCBcInJhbmdlXCIgXSxcblx0XHRcdFx0cmUgPSBuZXcgUmVnRXhwKCBcIlxcXFxiXCIgKyB0eXBlICsgXCJcXFxcYlwiICksXG5cdFx0XHRcdG5vdFN1cHBvcnRlZCA9IHR5cGUgJiYgIXJlLnRlc3QoIHN1cHBvcnRlZFR5cGVzLmpvaW4oKSApLFxuXHRcdFx0XHRkZWNpbWFsUGxhY2VzID0gZnVuY3Rpb24oIG51bSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2ggPSAoIFwiXCIgKyBudW0gKS5tYXRjaCggLyg/OlxcLihcXGQrKSk/JC8gKTtcblx0XHRcdFx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE51bWJlciBvZiBkaWdpdHMgcmlnaHQgb2YgZGVjaW1hbCBwb2ludC5cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hbIDEgXSA/IG1hdGNoWyAxIF0ubGVuZ3RoIDogMDtcblx0XHRcdFx0fSxcblx0XHRcdFx0dG9JbnQgPSBmdW5jdGlvbiggbnVtICkge1xuXHRcdFx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCBudW0gKiBNYXRoLnBvdyggMTAsIGRlY2ltYWxzICkgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dmFsaWQgPSB0cnVlLFxuXHRcdFx0XHRkZWNpbWFscztcblxuXHRcdFx0Ly8gV29ya3Mgb25seSBmb3IgdGV4dCwgbnVtYmVyIGFuZCByYW5nZSBpbnB1dCB0eXBlc1xuXHRcdFx0Ly8gVE9ETyBmaW5kIGEgd2F5IHRvIHN1cHBvcnQgaW5wdXQgdHlwZXMgZGF0ZSwgZGF0ZXRpbWUsIGRhdGV0aW1lLWxvY2FsLCBtb250aCwgdGltZSBhbmQgd2Vla1xuXHRcdFx0aWYgKCBub3RTdXBwb3J0ZWQgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggZXJyb3JNZXNzYWdlICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlY2ltYWxzID0gZGVjaW1hbFBsYWNlcyggcGFyYW0gKTtcblxuXHRcdFx0Ly8gVmFsdWUgY2FuJ3QgaGF2ZSB0b28gbWFueSBkZWNpbWFsc1xuXHRcdFx0aWYgKCBkZWNpbWFsUGxhY2VzKCB2YWx1ZSApID4gZGVjaW1hbHMgfHwgdG9JbnQoIHZhbHVlICkgJSB0b0ludCggcGFyYW0gKSAhPT0gMCApIHtcblx0XHRcdFx0dmFsaWQgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSB8fCB2YWxpZDtcblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9lcXVhbFRvLW1ldGhvZC9cblx0XHRlcXVhbFRvOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQsIHBhcmFtICkge1xuXG5cdFx0XHQvLyBCaW5kIHRvIHRoZSBibHVyIGV2ZW50IG9mIHRoZSB0YXJnZXQgaW4gb3JkZXIgdG8gcmV2YWxpZGF0ZSB3aGVuZXZlciB0aGUgdGFyZ2V0IGZpZWxkIGlzIHVwZGF0ZWRcblx0XHRcdHZhciB0YXJnZXQgPSAkKCBwYXJhbSApO1xuXHRcdFx0aWYgKCB0aGlzLnNldHRpbmdzLm9uZm9jdXNvdXQgJiYgdGFyZ2V0Lm5vdCggXCIudmFsaWRhdGUtZXF1YWxUby1ibHVyXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHRhcmdldC5hZGRDbGFzcyggXCJ2YWxpZGF0ZS1lcXVhbFRvLWJsdXJcIiApLm9uKCBcImJsdXIudmFsaWRhdGUtZXF1YWxUb1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQkKCBlbGVtZW50ICkudmFsaWQoKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB0YXJnZXQudmFsKCk7XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvcmVtb3RlLW1ldGhvZC9cblx0XHRyZW1vdGU6IGZ1bmN0aW9uKCB2YWx1ZSwgZWxlbWVudCwgcGFyYW0sIG1ldGhvZCApIHtcblx0XHRcdGlmICggdGhpcy5vcHRpb25hbCggZWxlbWVudCApICkge1xuXHRcdFx0XHRyZXR1cm4gXCJkZXBlbmRlbmN5LW1pc21hdGNoXCI7XG5cdFx0XHR9XG5cblx0XHRcdG1ldGhvZCA9IHR5cGVvZiBtZXRob2QgPT09IFwic3RyaW5nXCIgJiYgbWV0aG9kIHx8IFwicmVtb3RlXCI7XG5cblx0XHRcdHZhciBwcmV2aW91cyA9IHRoaXMucHJldmlvdXNWYWx1ZSggZWxlbWVudCwgbWV0aG9kICksXG5cdFx0XHRcdHZhbGlkYXRvciwgZGF0YSwgb3B0aW9uRGF0YVN0cmluZztcblxuXHRcdFx0aWYgKCAhdGhpcy5zZXR0aW5ncy5tZXNzYWdlc1sgZWxlbWVudC5uYW1lIF0gKSB7XG5cdFx0XHRcdHRoaXMuc2V0dGluZ3MubWVzc2FnZXNbIGVsZW1lbnQubmFtZSBdID0ge307XG5cdFx0XHR9XG5cdFx0XHRwcmV2aW91cy5vcmlnaW5hbE1lc3NhZ2UgPSBwcmV2aW91cy5vcmlnaW5hbE1lc3NhZ2UgfHwgdGhpcy5zZXR0aW5ncy5tZXNzYWdlc1sgZWxlbWVudC5uYW1lIF1bIG1ldGhvZCBdO1xuXHRcdFx0dGhpcy5zZXR0aW5ncy5tZXNzYWdlc1sgZWxlbWVudC5uYW1lIF1bIG1ldGhvZCBdID0gcHJldmlvdXMubWVzc2FnZTtcblxuXHRcdFx0cGFyYW0gPSB0eXBlb2YgcGFyYW0gPT09IFwic3RyaW5nXCIgJiYgeyB1cmw6IHBhcmFtIH0gfHwgcGFyYW07XG5cdFx0XHRvcHRpb25EYXRhU3RyaW5nID0gJC5wYXJhbSggJC5leHRlbmQoIHsgZGF0YTogdmFsdWUgfSwgcGFyYW0uZGF0YSApICk7XG5cdFx0XHRpZiAoIHByZXZpb3VzLm9sZCA9PT0gb3B0aW9uRGF0YVN0cmluZyApIHtcblx0XHRcdFx0cmV0dXJuIHByZXZpb3VzLnZhbGlkO1xuXHRcdFx0fVxuXG5cdFx0XHRwcmV2aW91cy5vbGQgPSBvcHRpb25EYXRhU3RyaW5nO1xuXHRcdFx0dmFsaWRhdG9yID0gdGhpcztcblx0XHRcdHRoaXMuc3RhcnRSZXF1ZXN0KCBlbGVtZW50ICk7XG5cdFx0XHRkYXRhID0ge307XG5cdFx0XHRkYXRhWyBlbGVtZW50Lm5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0JC5hamF4KCAkLmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRtb2RlOiBcImFib3J0XCIsXG5cdFx0XHRcdHBvcnQ6IFwidmFsaWRhdGVcIiArIGVsZW1lbnQubmFtZSxcblx0XHRcdFx0ZGF0YVR5cGU6IFwianNvblwiLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRjb250ZXh0OiB2YWxpZGF0b3IuY3VycmVudEZvcm0sXG5cdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uKCByZXNwb25zZSApIHtcblx0XHRcdFx0XHR2YXIgdmFsaWQgPSByZXNwb25zZSA9PT0gdHJ1ZSB8fCByZXNwb25zZSA9PT0gXCJ0cnVlXCIsXG5cdFx0XHRcdFx0XHRlcnJvcnMsIG1lc3NhZ2UsIHN1Ym1pdHRlZDtcblxuXHRcdFx0XHRcdHZhbGlkYXRvci5zZXR0aW5ncy5tZXNzYWdlc1sgZWxlbWVudC5uYW1lIF1bIG1ldGhvZCBdID0gcHJldmlvdXMub3JpZ2luYWxNZXNzYWdlO1xuXHRcdFx0XHRcdGlmICggdmFsaWQgKSB7XG5cdFx0XHRcdFx0XHRzdWJtaXR0ZWQgPSB2YWxpZGF0b3IuZm9ybVN1Ym1pdHRlZDtcblx0XHRcdFx0XHRcdHZhbGlkYXRvci5yZXNldEludGVybmFscygpO1xuXHRcdFx0XHRcdFx0dmFsaWRhdG9yLnRvSGlkZSA9IHZhbGlkYXRvci5lcnJvcnNGb3IoIGVsZW1lbnQgKTtcblx0XHRcdFx0XHRcdHZhbGlkYXRvci5mb3JtU3VibWl0dGVkID0gc3VibWl0dGVkO1xuXHRcdFx0XHRcdFx0dmFsaWRhdG9yLnN1Y2Nlc3NMaXN0LnB1c2goIGVsZW1lbnQgKTtcblx0XHRcdFx0XHRcdHZhbGlkYXRvci5pbnZhbGlkWyBlbGVtZW50Lm5hbWUgXSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0dmFsaWRhdG9yLnNob3dFcnJvcnMoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0ZXJyb3JzID0ge307XG5cdFx0XHRcdFx0XHRtZXNzYWdlID0gcmVzcG9uc2UgfHwgdmFsaWRhdG9yLmRlZmF1bHRNZXNzYWdlKCBlbGVtZW50LCB7IG1ldGhvZDogbWV0aG9kLCBwYXJhbWV0ZXJzOiB2YWx1ZSB9ICk7XG5cdFx0XHRcdFx0XHRlcnJvcnNbIGVsZW1lbnQubmFtZSBdID0gcHJldmlvdXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdFx0XHRcdFx0XHR2YWxpZGF0b3IuaW52YWxpZFsgZWxlbWVudC5uYW1lIF0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0dmFsaWRhdG9yLnNob3dFcnJvcnMoIGVycm9ycyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwcmV2aW91cy52YWxpZCA9IHZhbGlkO1xuXHRcdFx0XHRcdHZhbGlkYXRvci5zdG9wUmVxdWVzdCggZWxlbWVudCwgdmFsaWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgcGFyYW0gKSApO1xuXHRcdFx0cmV0dXJuIFwicGVuZGluZ1wiO1xuXHRcdH1cblx0fVxuXG59ICk7XG5cclxuLy8gQWpheCBtb2RlOiBhYm9ydFxuLy8gdXNhZ2U6ICQuYWpheCh7IG1vZGU6IFwiYWJvcnRcIlssIHBvcnQ6IFwidW5pcXVlcG9ydFwiXX0pO1xuLy8gaWYgbW9kZTpcImFib3J0XCIgaXMgdXNlZCwgdGhlIHByZXZpb3VzIHJlcXVlc3Qgb24gdGhhdCBwb3J0IChwb3J0IGNhbiBiZSB1bmRlZmluZWQpIGlzIGFib3J0ZWQgdmlhIFhNTEh0dHBSZXF1ZXN0LmFib3J0KClcblxudmFyIHBlbmRpbmdSZXF1ZXN0cyA9IHt9LFxuXHRhamF4O1xuXG4vLyBVc2UgYSBwcmVmaWx0ZXIgaWYgYXZhaWxhYmxlICgxLjUrKVxuaWYgKCAkLmFqYXhQcmVmaWx0ZXIgKSB7XG5cdCQuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHNldHRpbmdzLCBfLCB4aHIgKSB7XG5cdFx0dmFyIHBvcnQgPSBzZXR0aW5ncy5wb3J0O1xuXHRcdGlmICggc2V0dGluZ3MubW9kZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0aWYgKCBwZW5kaW5nUmVxdWVzdHNbIHBvcnQgXSApIHtcblx0XHRcdFx0cGVuZGluZ1JlcXVlc3RzWyBwb3J0IF0uYWJvcnQoKTtcblx0XHRcdH1cblx0XHRcdHBlbmRpbmdSZXF1ZXN0c1sgcG9ydCBdID0geGhyO1xuXHRcdH1cblx0fSApO1xufSBlbHNlIHtcblxuXHQvLyBQcm94eSBhamF4XG5cdGFqYXggPSAkLmFqYXg7XG5cdCQuYWpheCA9IGZ1bmN0aW9uKCBzZXR0aW5ncyApIHtcblx0XHR2YXIgbW9kZSA9ICggXCJtb2RlXCIgaW4gc2V0dGluZ3MgPyBzZXR0aW5ncyA6ICQuYWpheFNldHRpbmdzICkubW9kZSxcblx0XHRcdHBvcnQgPSAoIFwicG9ydFwiIGluIHNldHRpbmdzID8gc2V0dGluZ3MgOiAkLmFqYXhTZXR0aW5ncyApLnBvcnQ7XG5cdFx0aWYgKCBtb2RlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRpZiAoIHBlbmRpbmdSZXF1ZXN0c1sgcG9ydCBdICkge1xuXHRcdFx0XHRwZW5kaW5nUmVxdWVzdHNbIHBvcnQgXS5hYm9ydCgpO1xuXHRcdFx0fVxuXHRcdFx0cGVuZGluZ1JlcXVlc3RzWyBwb3J0IF0gPSBhamF4LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdHJldHVybiBwZW5kaW5nUmVxdWVzdHNbIHBvcnQgXTtcblx0XHR9XG5cdFx0cmV0dXJuIGFqYXguYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR9O1xufVxucmV0dXJuICQ7XHJcbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcXVlcnktdmFsaWRhdGlvbi9kaXN0L2pxdWVyeS52YWxpZGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcclxuKiogVW5vYnRydXNpdmUgdmFsaWRhdGlvbiBzdXBwb3J0IGxpYnJhcnkgZm9yIGpRdWVyeSBhbmQgalF1ZXJ5IFZhbGlkYXRlXHJcbioqIENvcHlyaWdodCAoQykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4qL1xyXG5cclxuLypqc2xpbnQgd2hpdGU6IHRydWUsIGJyb3dzZXI6IHRydWUsIG9uZXZhcjogdHJ1ZSwgdW5kZWY6IHRydWUsIG5vbWVuOiB0cnVlLCBlcWVxZXE6IHRydWUsIHBsdXNwbHVzOiB0cnVlLCBiaXR3aXNlOiB0cnVlLCByZWdleHA6IHRydWUsIG5ld2NhcDogdHJ1ZSwgaW1tZWQ6IHRydWUsIHN0cmljdDogZmFsc2UgKi9cclxuLypnbG9iYWwgZG9jdW1lbnQ6IGZhbHNlLCBqUXVlcnk6IGZhbHNlICovXHJcblxyXG4oZnVuY3Rpb24gKCQpIHtcclxuICAgIHZhciAkalF2YWwgPSAkLnZhbGlkYXRvcixcclxuICAgICAgICBhZGFwdGVycyxcclxuICAgICAgICBkYXRhX3ZhbGlkYXRpb24gPSBcInVub2J0cnVzaXZlVmFsaWRhdGlvblwiO1xyXG5cclxuICAgIGZ1bmN0aW9uIHNldFZhbGlkYXRpb25WYWx1ZXMob3B0aW9ucywgcnVsZU5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgb3B0aW9ucy5ydWxlc1tydWxlTmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMubWVzc2FnZXNbcnVsZU5hbWVdID0gb3B0aW9ucy5tZXNzYWdlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzcGxpdEFuZFRyaW0odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgXCJcIikuc3BsaXQoL1xccyosXFxzKi9nKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlc2NhcGVBdHRyaWJ1dGVWYWx1ZSh2YWx1ZSkge1xyXG4gICAgICAgIC8vIEFzIG1lbnRpb25lZCBvbiBodHRwOi8vYXBpLmpxdWVyeS5jb20vY2F0ZWdvcnkvc2VsZWN0b3JzL1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC8oWyFcIiMkJSYnKCkqKywuLzo7PD0+P0BcXFtcXFxcXFxdXmB7fH1+XSkvZywgXCJcXFxcJDFcIik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0TW9kZWxQcmVmaXgoZmllbGROYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpZWxkTmFtZS5zdWJzdHIoMCwgZmllbGROYW1lLmxhc3RJbmRleE9mKFwiLlwiKSArIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGVuZE1vZGVsUHJlZml4KHZhbHVlLCBwcmVmaXgpIHtcclxuICAgICAgICBpZiAodmFsdWUuaW5kZXhPZihcIiouXCIpID09PSAwKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShcIiouXCIsIHByZWZpeCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvbkVycm9yKGVycm9yLCBpbnB1dEVsZW1lbnQpIHsgIC8vICd0aGlzJyBpcyB0aGUgZm9ybSBlbGVtZW50XHJcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9ICQodGhpcykuZmluZChcIltkYXRhLXZhbG1zZy1mb3I9J1wiICsgZXNjYXBlQXR0cmlidXRlVmFsdWUoaW5wdXRFbGVtZW50WzBdLm5hbWUpICsgXCInXVwiKSxcclxuICAgICAgICAgICAgcmVwbGFjZUF0dHJWYWx1ZSA9IGNvbnRhaW5lci5hdHRyKFwiZGF0YS12YWxtc2ctcmVwbGFjZVwiKSxcclxuICAgICAgICAgICAgcmVwbGFjZSA9IHJlcGxhY2VBdHRyVmFsdWUgPyAkLnBhcnNlSlNPTihyZXBsYWNlQXR0clZhbHVlKSAhPT0gZmFsc2UgOiBudWxsO1xyXG5cclxuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2xhc3MoXCJmaWVsZC12YWxpZGF0aW9uLXZhbGlkXCIpLmFkZENsYXNzKFwiZmllbGQtdmFsaWRhdGlvbi1lcnJvclwiKTtcclxuICAgICAgICBlcnJvci5kYXRhKFwidW5vYnRydXNpdmVDb250YWluZXJcIiwgY29udGFpbmVyKTtcclxuXHJcbiAgICAgICAgaWYgKHJlcGxhY2UpIHtcclxuICAgICAgICAgICAgY29udGFpbmVyLmVtcHR5KCk7XHJcbiAgICAgICAgICAgIGVycm9yLnJlbW92ZUNsYXNzKFwiaW5wdXQtdmFsaWRhdGlvbi1lcnJvclwiKS5hcHBlbmRUbyhjb250YWluZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXJyb3IuaGlkZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvbkVycm9ycyhldmVudCwgdmFsaWRhdG9yKSB7ICAvLyAndGhpcycgaXMgdGhlIGZvcm0gZWxlbWVudFxyXG4gICAgICAgIHZhciBjb250YWluZXIgPSAkKHRoaXMpLmZpbmQoXCJbZGF0YS12YWxtc2ctc3VtbWFyeT10cnVlXVwiKSxcclxuICAgICAgICAgICAgbGlzdCA9IGNvbnRhaW5lci5maW5kKFwidWxcIik7XHJcblxyXG4gICAgICAgIGlmIChsaXN0ICYmIGxpc3QubGVuZ3RoICYmIHZhbGlkYXRvci5lcnJvckxpc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxpc3QuZW1wdHkoKTtcclxuICAgICAgICAgICAgY29udGFpbmVyLmFkZENsYXNzKFwidmFsaWRhdGlvbi1zdW1tYXJ5LWVycm9yc1wiKS5yZW1vdmVDbGFzcyhcInZhbGlkYXRpb24tc3VtbWFyeS12YWxpZFwiKTtcclxuXHJcbiAgICAgICAgICAgICQuZWFjaCh2YWxpZGF0b3IuZXJyb3JMaXN0LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAkKFwiPGxpIC8+XCIpLmh0bWwodGhpcy5tZXNzYWdlKS5hcHBlbmRUbyhsaXN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG9uU3VjY2VzcyhlcnJvcikgeyAgLy8gJ3RoaXMnIGlzIHRoZSBmb3JtIGVsZW1lbnRcclxuICAgICAgICB2YXIgY29udGFpbmVyID0gZXJyb3IuZGF0YShcInVub2J0cnVzaXZlQ29udGFpbmVyXCIpO1xyXG5cclxuICAgICAgICBpZiAoY29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHZhciByZXBsYWNlQXR0clZhbHVlID0gY29udGFpbmVyLmF0dHIoXCJkYXRhLXZhbG1zZy1yZXBsYWNlXCIpLFxyXG4gICAgICAgICAgICAgICAgcmVwbGFjZSA9IHJlcGxhY2VBdHRyVmFsdWUgPyAkLnBhcnNlSlNPTihyZXBsYWNlQXR0clZhbHVlKSA6IG51bGw7XHJcblxyXG4gICAgICAgICAgICBjb250YWluZXIuYWRkQ2xhc3MoXCJmaWVsZC12YWxpZGF0aW9uLXZhbGlkXCIpLnJlbW92ZUNsYXNzKFwiZmllbGQtdmFsaWRhdGlvbi1lcnJvclwiKTtcclxuICAgICAgICAgICAgZXJyb3IucmVtb3ZlRGF0YShcInVub2J0cnVzaXZlQ29udGFpbmVyXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHJlcGxhY2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5lbXB0eSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG9uUmVzZXQoZXZlbnQpIHsgIC8vICd0aGlzJyBpcyB0aGUgZm9ybSBlbGVtZW50XHJcbiAgICAgICAgdmFyICRmb3JtID0gJCh0aGlzKSxcclxuICAgICAgICAgICAga2V5ID0gJ19fanF1ZXJ5X3Vub2J0cnVzaXZlX3ZhbGlkYXRpb25fZm9ybV9yZXNldCc7XHJcbiAgICAgICAgaWYgKCRmb3JtLmRhdGEoa2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNldCBhIGZsYWcgdGhhdCBpbmRpY2F0ZXMgd2UncmUgY3VycmVudGx5IHJlc2V0dGluZyB0aGUgZm9ybS5cclxuICAgICAgICAkZm9ybS5kYXRhKGtleSwgdHJ1ZSk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgJGZvcm0uZGF0YShcInZhbGlkYXRvclwiKS5yZXNldEZvcm0oKTtcclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICAkZm9ybS5yZW1vdmVEYXRhKGtleSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAkZm9ybS5maW5kKFwiLnZhbGlkYXRpb24tc3VtbWFyeS1lcnJvcnNcIilcclxuICAgICAgICAgICAgLmFkZENsYXNzKFwidmFsaWRhdGlvbi1zdW1tYXJ5LXZhbGlkXCIpXHJcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhcInZhbGlkYXRpb24tc3VtbWFyeS1lcnJvcnNcIik7XHJcbiAgICAgICAgJGZvcm0uZmluZChcIi5maWVsZC12YWxpZGF0aW9uLWVycm9yXCIpXHJcbiAgICAgICAgICAgIC5hZGRDbGFzcyhcImZpZWxkLXZhbGlkYXRpb24tdmFsaWRcIilcclxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKFwiZmllbGQtdmFsaWRhdGlvbi1lcnJvclwiKVxyXG4gICAgICAgICAgICAucmVtb3ZlRGF0YShcInVub2J0cnVzaXZlQ29udGFpbmVyXCIpXHJcbiAgICAgICAgICAgIC5maW5kKFwiPipcIikgIC8vIElmIHdlIHdlcmUgdXNpbmcgdmFsbXNnLXJlcGxhY2UsIGdldCB0aGUgdW5kZXJseWluZyBlcnJvclxyXG4gICAgICAgICAgICAgICAgLnJlbW92ZURhdGEoXCJ1bm9idHJ1c2l2ZUNvbnRhaW5lclwiKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB2YWxpZGF0aW9uSW5mbyhmb3JtKSB7XHJcbiAgICAgICAgdmFyICRmb3JtID0gJChmb3JtKSxcclxuICAgICAgICAgICAgcmVzdWx0ID0gJGZvcm0uZGF0YShkYXRhX3ZhbGlkYXRpb24pLFxyXG4gICAgICAgICAgICBvblJlc2V0UHJveHkgPSAkLnByb3h5KG9uUmVzZXQsIGZvcm0pLFxyXG4gICAgICAgICAgICBkZWZhdWx0T3B0aW9ucyA9ICRqUXZhbC51bm9idHJ1c2l2ZS5vcHRpb25zIHx8IHt9LFxyXG4gICAgICAgICAgICBleGVjSW5Db250ZXh0ID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmdW5jID0gZGVmYXVsdE9wdGlvbnNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICBmdW5jICYmICQuaXNGdW5jdGlvbihmdW5jKSAmJiBmdW5jLmFwcGx5KGZvcm0sIGFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghcmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHsgIC8vIG9wdGlvbnMgc3RydWN0dXJlIHBhc3NlZCB0byBqUXVlcnkgVmFsaWRhdGUncyB2YWxpZGF0ZSgpIG1ldGhvZFxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yQ2xhc3M6IGRlZmF1bHRPcHRpb25zLmVycm9yQ2xhc3MgfHwgXCJpbnB1dC12YWxpZGF0aW9uLWVycm9yXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JFbGVtZW50OiBkZWZhdWx0T3B0aW9ucy5lcnJvckVsZW1lbnQgfHwgXCJzcGFuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JQbGFjZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvci5hcHBseShmb3JtLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjSW5Db250ZXh0KFwiZXJyb3JQbGFjZW1lbnRcIiwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRIYW5kbGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3JzLmFwcGx5KGZvcm0sIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNJbkNvbnRleHQoXCJpbnZhbGlkSGFuZGxlclwiLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzcy5hcHBseShmb3JtLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjSW5Db250ZXh0KFwic3VjY2Vzc1wiLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBhdHRhY2hWYWxpZGF0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJGZvcm1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLm9mZihcInJlc2V0LlwiICsgZGF0YV92YWxpZGF0aW9uLCBvblJlc2V0UHJveHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbihcInJlc2V0LlwiICsgZGF0YV92YWxpZGF0aW9uLCBvblJlc2V0UHJveHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC52YWxpZGF0ZSh0aGlzLm9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7ICAvLyBhIHZhbGlkYXRpb24gZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgYnkgdW5vYnRydXNpdmUgQWpheFxyXG4gICAgICAgICAgICAgICAgICAgICRmb3JtLnZhbGlkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRmb3JtLnZhbGlkKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICRmb3JtLmRhdGEoZGF0YV92YWxpZGF0aW9uLCByZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAkalF2YWwudW5vYnRydXNpdmUgPSB7XHJcbiAgICAgICAgYWRhcHRlcnM6IFtdLFxyXG5cclxuICAgICAgICBwYXJzZUVsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtZW50LCBza2lwQXR0YWNoKSB7XHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIFBhcnNlcyBhIHNpbmdsZSBIVE1MIGVsZW1lbnQgZm9yIHVub2J0cnVzaXZlIHZhbGlkYXRpb24gYXR0cmlidXRlcy5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZWxlbWVudFwiIGRvbUVsZW1lbnQ9XCJ0cnVlXCI+VGhlIEhUTUwgZWxlbWVudCB0byBiZSBwYXJzZWQuPC9wYXJhbT5cclxuICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2tpcEF0dGFjaFwiIHR5cGU9XCJCb29sZWFuXCI+W09wdGlvbmFsXSB0cnVlIHRvIHNraXAgYXR0YWNoaW5nIHRoZVxyXG4gICAgICAgICAgICAvLy8gdmFsaWRhdGlvbiB0byB0aGUgZm9ybS4gSWYgcGFyc2luZyBqdXN0IHRoaXMgc2luZ2xlIGVsZW1lbnQsIHlvdSBzaG91bGQgc3BlY2lmeSB0cnVlLlxyXG4gICAgICAgICAgICAvLy8gSWYgcGFyc2luZyBzZXZlcmFsIGVsZW1lbnRzLCB5b3Ugc2hvdWxkIHNwZWNpZnkgZmFsc2UsIGFuZCBtYW51YWxseSBhdHRhY2ggdGhlIHZhbGlkYXRpb25cclxuICAgICAgICAgICAgLy8vIHRvIHRoZSBmb3JtIHdoZW4geW91IGFyZSBmaW5pc2hlZC4gVGhlIGRlZmF1bHQgaXMgZmFsc2UuPC9wYXJhbT5cclxuICAgICAgICAgICAgdmFyICRlbGVtZW50ID0gJChlbGVtZW50KSxcclxuICAgICAgICAgICAgICAgIGZvcm0gPSAkZWxlbWVudC5wYXJlbnRzKFwiZm9ybVwiKVswXSxcclxuICAgICAgICAgICAgICAgIHZhbEluZm8sIHJ1bGVzLCBtZXNzYWdlcztcclxuXHJcbiAgICAgICAgICAgIGlmICghZm9ybSkgeyAgLy8gQ2Fubm90IGRvIGNsaWVudC1zaWRlIHZhbGlkYXRpb24gd2l0aG91dCBhIGZvcm1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFsSW5mbyA9IHZhbGlkYXRpb25JbmZvKGZvcm0pO1xyXG4gICAgICAgICAgICB2YWxJbmZvLm9wdGlvbnMucnVsZXNbZWxlbWVudC5uYW1lXSA9IHJ1bGVzID0ge307XHJcbiAgICAgICAgICAgIHZhbEluZm8ub3B0aW9ucy5tZXNzYWdlc1tlbGVtZW50Lm5hbWVdID0gbWVzc2FnZXMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICQuZWFjaCh0aGlzLmFkYXB0ZXJzLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gXCJkYXRhLXZhbC1cIiArIHRoaXMubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gJGVsZW1lbnQuYXR0cihwcmVmaXgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtVmFsdWVzID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UgIT09IHVuZGVmaW5lZCkgeyAgLy8gQ29tcGFyZSBhZ2FpbnN0IHVuZGVmaW5lZCwgYmVjYXVzZSBhbiBlbXB0eSBtZXNzYWdlIGlzIGxlZ2FsIChhbmQgZmFsc3kpXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ICs9IFwiLVwiO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAkLmVhY2godGhpcy5wYXJhbXMsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1WYWx1ZXNbdGhpc10gPSAkZWxlbWVudC5hdHRyKHByZWZpeCArIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkYXB0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybTogZm9ybSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbVZhbHVlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXM6IHJ1bGVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAkLmV4dGVuZChydWxlcywgeyBcIl9fZHVtbXlfX1wiOiB0cnVlIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFza2lwQXR0YWNoKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxJbmZvLmF0dGFjaFZhbGlkYXRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgLy8vIDxzdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gUGFyc2VzIGFsbCB0aGUgSFRNTCBlbGVtZW50cyBpbiB0aGUgc3BlY2lmaWVkIHNlbGVjdG9yLiBJdCBsb29rcyBmb3IgaW5wdXQgZWxlbWVudHMgZGVjb3JhdGVkXHJcbiAgICAgICAgICAgIC8vLyB3aXRoIHRoZSBbZGF0YS12YWw9dHJ1ZV0gYXR0cmlidXRlIHZhbHVlIGFuZCBlbmFibGVzIHZhbGlkYXRpb24gYWNjb3JkaW5nIHRvIHRoZSBkYXRhLXZhbC0qXHJcbiAgICAgICAgICAgIC8vLyBhdHRyaWJ1dGUgdmFsdWVzLlxyXG4gICAgICAgICAgICAvLy8gPC9zdW1tYXJ5PlxyXG4gICAgICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJzZWxlY3RvclwiIHR5cGU9XCJTdHJpbmdcIj5BbnkgdmFsaWQgalF1ZXJ5IHNlbGVjdG9yLjwvcGFyYW0+XHJcblxyXG4gICAgICAgICAgICAvLyAkZm9ybXMgaW5jbHVkZXMgYWxsIGZvcm1zIGluIHNlbGVjdG9yJ3MgRE9NIGhpZXJhcmNoeSAocGFyZW50LCBjaGlsZHJlbiBhbmQgc2VsZikgdGhhdCBoYXZlIGF0IGxlYXN0IG9uZVxyXG4gICAgICAgICAgICAvLyBlbGVtZW50IHdpdGggZGF0YS12YWw9dHJ1ZVxyXG4gICAgICAgICAgICB2YXIgJHNlbGVjdG9yID0gJChzZWxlY3RvciksXHJcbiAgICAgICAgICAgICAgICAkZm9ybXMgPSAkc2VsZWN0b3IucGFyZW50cygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQmFjaygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKFwiZm9ybVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZCgkc2VsZWN0b3IuZmluZChcImZvcm1cIikpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaGFzKFwiW2RhdGEtdmFsPXRydWVdXCIpO1xyXG5cclxuICAgICAgICAgICAgJHNlbGVjdG9yLmZpbmQoXCJbZGF0YS12YWw9dHJ1ZV1cIikuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAkalF2YWwudW5vYnRydXNpdmUucGFyc2VFbGVtZW50KHRoaXMsIHRydWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICRmb3Jtcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gdmFsaWRhdGlvbkluZm8odGhpcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZm8uYXR0YWNoVmFsaWRhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGFkYXB0ZXJzID0gJGpRdmFsLnVub2J0cnVzaXZlLmFkYXB0ZXJzO1xyXG5cclxuICAgIGFkYXB0ZXJzLmFkZCA9IGZ1bmN0aW9uIChhZGFwdGVyTmFtZSwgcGFyYW1zLCBmbikge1xyXG4gICAgICAgIC8vLyA8c3VtbWFyeT5BZGRzIGEgbmV3IGFkYXB0ZXIgdG8gY29udmVydCB1bm9idHJ1c2l2ZSBIVE1MIGludG8gYSBqUXVlcnkgVmFsaWRhdGUgdmFsaWRhdGlvbi48L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYWRhcHRlck5hbWVcIiB0eXBlPVwiU3RyaW5nXCI+VGhlIG5hbWUgb2YgdGhlIGFkYXB0ZXIgdG8gYmUgYWRkZWQuIFRoaXMgbWF0Y2hlcyB0aGUgbmFtZSB1c2VkXHJcbiAgICAgICAgLy8vIGluIHRoZSBkYXRhLXZhbC1ubm5uIEhUTUwgYXR0cmlidXRlICh3aGVyZSBubm5uIGlzIHRoZSBhZGFwdGVyIG5hbWUpLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicGFyYW1zXCIgdHlwZT1cIkFycmF5XCIgb3B0aW9uYWw9XCJ0cnVlXCI+W09wdGlvbmFsXSBBbiBhcnJheSBvZiBwYXJhbWV0ZXIgbmFtZXMgKHN0cmluZ3MpIHRoYXQgd2lsbFxyXG4gICAgICAgIC8vLyBiZSBleHRyYWN0ZWQgZnJvbSB0aGUgZGF0YS12YWwtbm5ubi1tbW1tIEhUTUwgYXR0cmlidXRlcyAod2hlcmUgbm5ubiBpcyB0aGUgYWRhcHRlciBuYW1lLCBhbmRcclxuICAgICAgICAvLy8gbW1tbSBpcyB0aGUgcGFyYW1ldGVyIG5hbWUpLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiZm5cIiB0eXBlPVwiRnVuY3Rpb25cIj5UaGUgZnVuY3Rpb24gdG8gY2FsbCwgd2hpY2ggYWRhcHRzIHRoZSB2YWx1ZXMgZnJvbSB0aGUgSFRNTFxyXG4gICAgICAgIC8vLyBhdHRyaWJ1dGVzIGludG8galF1ZXJ5IFZhbGlkYXRlIHJ1bGVzIGFuZC9vciBtZXNzYWdlcy48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cmV0dXJucyB0eXBlPVwialF1ZXJ5LnZhbGlkYXRvci51bm9idHJ1c2l2ZS5hZGFwdGVyc1wiIC8+XHJcbiAgICAgICAgaWYgKCFmbikgeyAgLy8gQ2FsbGVkIHdpdGggbm8gcGFyYW1zLCBqdXN0IGEgZnVuY3Rpb25cclxuICAgICAgICAgICAgZm4gPSBwYXJhbXM7XHJcbiAgICAgICAgICAgIHBhcmFtcyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnB1c2goeyBuYW1lOiBhZGFwdGVyTmFtZSwgcGFyYW1zOiBwYXJhbXMsIGFkYXB0OiBmbiB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcblxyXG4gICAgYWRhcHRlcnMuYWRkQm9vbCA9IGZ1bmN0aW9uIChhZGFwdGVyTmFtZSwgcnVsZU5hbWUpIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+QWRkcyBhIG5ldyBhZGFwdGVyIHRvIGNvbnZlcnQgdW5vYnRydXNpdmUgSFRNTCBpbnRvIGEgalF1ZXJ5IFZhbGlkYXRlIHZhbGlkYXRpb24sIHdoZXJlXHJcbiAgICAgICAgLy8vIHRoZSBqUXVlcnkgVmFsaWRhdGUgdmFsaWRhdGlvbiBydWxlIGhhcyBubyBwYXJhbWV0ZXIgdmFsdWVzLjwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhZGFwdGVyTmFtZVwiIHR5cGU9XCJTdHJpbmdcIj5UaGUgbmFtZSBvZiB0aGUgYWRhcHRlciB0byBiZSBhZGRlZC4gVGhpcyBtYXRjaGVzIHRoZSBuYW1lIHVzZWRcclxuICAgICAgICAvLy8gaW4gdGhlIGRhdGEtdmFsLW5ubm4gSFRNTCBhdHRyaWJ1dGUgKHdoZXJlIG5ubm4gaXMgdGhlIGFkYXB0ZXIgbmFtZSkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJydWxlTmFtZVwiIHR5cGU9XCJTdHJpbmdcIiBvcHRpb25hbD1cInRydWVcIj5bT3B0aW9uYWxdIFRoZSBuYW1lIG9mIHRoZSBqUXVlcnkgVmFsaWRhdGUgcnVsZS4gSWYgbm90IHByb3ZpZGVkLCB0aGUgdmFsdWVcclxuICAgICAgICAvLy8gb2YgYWRhcHRlck5hbWUgd2lsbCBiZSB1c2VkIGluc3RlYWQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnMgdHlwZT1cImpRdWVyeS52YWxpZGF0b3IudW5vYnRydXNpdmUuYWRhcHRlcnNcIiAvPlxyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZChhZGFwdGVyTmFtZSwgZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgc2V0VmFsaWRhdGlvblZhbHVlcyhvcHRpb25zLCBydWxlTmFtZSB8fCBhZGFwdGVyTmFtZSwgdHJ1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGFkYXB0ZXJzLmFkZE1pbk1heCA9IGZ1bmN0aW9uIChhZGFwdGVyTmFtZSwgbWluUnVsZU5hbWUsIG1heFJ1bGVOYW1lLCBtaW5NYXhSdWxlTmFtZSwgbWluQXR0cmlidXRlLCBtYXhBdHRyaWJ1dGUpIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+QWRkcyBhIG5ldyBhZGFwdGVyIHRvIGNvbnZlcnQgdW5vYnRydXNpdmUgSFRNTCBpbnRvIGEgalF1ZXJ5IFZhbGlkYXRlIHZhbGlkYXRpb24sIHdoZXJlXHJcbiAgICAgICAgLy8vIHRoZSBqUXVlcnkgVmFsaWRhdGUgdmFsaWRhdGlvbiBoYXMgdGhyZWUgcG90ZW50aWFsIHJ1bGVzIChvbmUgZm9yIG1pbi1vbmx5LCBvbmUgZm9yIG1heC1vbmx5LCBhbmRcclxuICAgICAgICAvLy8gb25lIGZvciBtaW4tYW5kLW1heCkuIFRoZSBIVE1MIHBhcmFtZXRlcnMgYXJlIGV4cGVjdGVkIHRvIGJlIG5hbWVkIC1taW4gYW5kIC1tYXguPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFkYXB0ZXJOYW1lXCIgdHlwZT1cIlN0cmluZ1wiPlRoZSBuYW1lIG9mIHRoZSBhZGFwdGVyIHRvIGJlIGFkZGVkLiBUaGlzIG1hdGNoZXMgdGhlIG5hbWUgdXNlZFxyXG4gICAgICAgIC8vLyBpbiB0aGUgZGF0YS12YWwtbm5ubiBIVE1MIGF0dHJpYnV0ZSAod2hlcmUgbm5ubiBpcyB0aGUgYWRhcHRlciBuYW1lKS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1pblJ1bGVOYW1lXCIgdHlwZT1cIlN0cmluZ1wiPlRoZSBuYW1lIG9mIHRoZSBqUXVlcnkgVmFsaWRhdGUgcnVsZSB0byBiZSB1c2VkIHdoZW4geW91IG9ubHlcclxuICAgICAgICAvLy8gaGF2ZSBhIG1pbmltdW0gdmFsdWUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJtYXhSdWxlTmFtZVwiIHR5cGU9XCJTdHJpbmdcIj5UaGUgbmFtZSBvZiB0aGUgalF1ZXJ5IFZhbGlkYXRlIHJ1bGUgdG8gYmUgdXNlZCB3aGVuIHlvdSBvbmx5XHJcbiAgICAgICAgLy8vIGhhdmUgYSBtYXhpbXVtIHZhbHVlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibWluTWF4UnVsZU5hbWVcIiB0eXBlPVwiU3RyaW5nXCI+VGhlIG5hbWUgb2YgdGhlIGpRdWVyeSBWYWxpZGF0ZSBydWxlIHRvIGJlIHVzZWQgd2hlbiB5b3VcclxuICAgICAgICAvLy8gaGF2ZSBib3RoIGEgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1pbkF0dHJpYnV0ZVwiIHR5cGU9XCJTdHJpbmdcIiBvcHRpb25hbD1cInRydWVcIj5bT3B0aW9uYWxdIFRoZSBuYW1lIG9mIHRoZSBIVE1MIGF0dHJpYnV0ZSB0aGF0XHJcbiAgICAgICAgLy8vIGNvbnRhaW5zIHRoZSBtaW5pbXVtIHZhbHVlLiBUaGUgZGVmYXVsdCBpcyBcIm1pblwiLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibWF4QXR0cmlidXRlXCIgdHlwZT1cIlN0cmluZ1wiIG9wdGlvbmFsPVwidHJ1ZVwiPltPcHRpb25hbF0gVGhlIG5hbWUgb2YgdGhlIEhUTUwgYXR0cmlidXRlIHRoYXRcclxuICAgICAgICAvLy8gY29udGFpbnMgdGhlIG1heGltdW0gdmFsdWUuIFRoZSBkZWZhdWx0IGlzIFwibWF4XCIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnMgdHlwZT1cImpRdWVyeS52YWxpZGF0b3IudW5vYnRydXNpdmUuYWRhcHRlcnNcIiAvPlxyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZChhZGFwdGVyTmFtZSwgW21pbkF0dHJpYnV0ZSB8fCBcIm1pblwiLCBtYXhBdHRyaWJ1dGUgfHwgXCJtYXhcIl0sIGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBtaW4gPSBvcHRpb25zLnBhcmFtcy5taW4sXHJcbiAgICAgICAgICAgICAgICBtYXggPSBvcHRpb25zLnBhcmFtcy5tYXg7XHJcblxyXG4gICAgICAgICAgICBpZiAobWluICYmIG1heCkge1xyXG4gICAgICAgICAgICAgICAgc2V0VmFsaWRhdGlvblZhbHVlcyhvcHRpb25zLCBtaW5NYXhSdWxlTmFtZSwgW21pbiwgbWF4XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobWluKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRWYWxpZGF0aW9uVmFsdWVzKG9wdGlvbnMsIG1pblJ1bGVOYW1lLCBtaW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG1heCkge1xyXG4gICAgICAgICAgICAgICAgc2V0VmFsaWRhdGlvblZhbHVlcyhvcHRpb25zLCBtYXhSdWxlTmFtZSwgbWF4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBhZGFwdGVycy5hZGRTaW5nbGVWYWwgPSBmdW5jdGlvbiAoYWRhcHRlck5hbWUsIGF0dHJpYnV0ZSwgcnVsZU5hbWUpIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+QWRkcyBhIG5ldyBhZGFwdGVyIHRvIGNvbnZlcnQgdW5vYnRydXNpdmUgSFRNTCBpbnRvIGEgalF1ZXJ5IFZhbGlkYXRlIHZhbGlkYXRpb24sIHdoZXJlXHJcbiAgICAgICAgLy8vIHRoZSBqUXVlcnkgVmFsaWRhdGUgdmFsaWRhdGlvbiBydWxlIGhhcyBhIHNpbmdsZSB2YWx1ZS48L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYWRhcHRlck5hbWVcIiB0eXBlPVwiU3RyaW5nXCI+VGhlIG5hbWUgb2YgdGhlIGFkYXB0ZXIgdG8gYmUgYWRkZWQuIFRoaXMgbWF0Y2hlcyB0aGUgbmFtZSB1c2VkXHJcbiAgICAgICAgLy8vIGluIHRoZSBkYXRhLXZhbC1ubm5uIEhUTUwgYXR0cmlidXRlKHdoZXJlIG5ubm4gaXMgdGhlIGFkYXB0ZXIgbmFtZSkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhdHRyaWJ1dGVcIiB0eXBlPVwiU3RyaW5nXCI+W09wdGlvbmFsXSBUaGUgbmFtZSBvZiB0aGUgSFRNTCBhdHRyaWJ1dGUgdGhhdCBjb250YWlucyB0aGUgdmFsdWUuXHJcbiAgICAgICAgLy8vIFRoZSBkZWZhdWx0IGlzIFwidmFsXCIuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJydWxlTmFtZVwiIHR5cGU9XCJTdHJpbmdcIiBvcHRpb25hbD1cInRydWVcIj5bT3B0aW9uYWxdIFRoZSBuYW1lIG9mIHRoZSBqUXVlcnkgVmFsaWRhdGUgcnVsZS4gSWYgbm90IHByb3ZpZGVkLCB0aGUgdmFsdWVcclxuICAgICAgICAvLy8gb2YgYWRhcHRlck5hbWUgd2lsbCBiZSB1c2VkIGluc3RlYWQuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnMgdHlwZT1cImpRdWVyeS52YWxpZGF0b3IudW5vYnRydXNpdmUuYWRhcHRlcnNcIiAvPlxyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZChhZGFwdGVyTmFtZSwgW2F0dHJpYnV0ZSB8fCBcInZhbFwiXSwgZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgc2V0VmFsaWRhdGlvblZhbHVlcyhvcHRpb25zLCBydWxlTmFtZSB8fCBhZGFwdGVyTmFtZSwgb3B0aW9ucy5wYXJhbXNbYXR0cmlidXRlXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgICRqUXZhbC5hZGRNZXRob2QoXCJfX2R1bW15X19cIiwgZnVuY3Rpb24gKHZhbHVlLCBlbGVtZW50LCBwYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0pO1xyXG5cclxuICAgICRqUXZhbC5hZGRNZXRob2QoXCJyZWdleFwiLCBmdW5jdGlvbiAodmFsdWUsIGVsZW1lbnQsIHBhcmFtcykge1xyXG4gICAgICAgIHZhciBtYXRjaDtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25hbChlbGVtZW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG1hdGNoID0gbmV3IFJlZ0V4cChwYXJhbXMpLmV4ZWModmFsdWUpO1xyXG4gICAgICAgIHJldHVybiAobWF0Y2ggJiYgKG1hdGNoLmluZGV4ID09PSAwKSAmJiAobWF0Y2hbMF0ubGVuZ3RoID09PSB2YWx1ZS5sZW5ndGgpKTtcclxuICAgIH0pO1xyXG5cclxuICAgICRqUXZhbC5hZGRNZXRob2QoXCJub25hbHBoYW1pblwiLCBmdW5jdGlvbiAodmFsdWUsIGVsZW1lbnQsIG5vbmFscGhhbWluKSB7XHJcbiAgICAgICAgdmFyIG1hdGNoO1xyXG4gICAgICAgIGlmIChub25hbHBoYW1pbikge1xyXG4gICAgICAgICAgICBtYXRjaCA9IHZhbHVlLm1hdGNoKC9cXFcvZyk7XHJcbiAgICAgICAgICAgIG1hdGNoID0gbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID49IG5vbmFscGhhbWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoJGpRdmFsLm1ldGhvZHMuZXh0ZW5zaW9uKSB7XHJcbiAgICAgICAgYWRhcHRlcnMuYWRkU2luZ2xlVmFsKFwiYWNjZXB0XCIsIFwibWltdHlwZVwiKTtcclxuICAgICAgICBhZGFwdGVycy5hZGRTaW5nbGVWYWwoXCJleHRlbnNpb25cIiwgXCJleHRlbnNpb25cIik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB3aGVuIHRoZSAnZXh0ZW5zaW9uJyB2YWxpZGF0aW9uIG1ldGhvZCBkb2VzIG5vdCBleGlzdCwgc3VjaCBhcyB3aXRoIHZlcnNpb25zXHJcbiAgICAgICAgLy8gb2YgSlF1ZXJ5IFZhbGlkYXRpb24gcGx1Z2luIHByaW9yIHRvIDEuMTAsIHdlIHNob3VsZCB1c2UgdGhlICdhY2NlcHQnIG1ldGhvZCBmb3JcclxuICAgICAgICAvLyB2YWxpZGF0aW5nIHRoZSBleHRlbnNpb24sIGFuZCBpZ25vcmUgbWltZS10eXBlIHZhbGlkYXRpb25zIGFzIHRoZXkgYXJlIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgICAgYWRhcHRlcnMuYWRkU2luZ2xlVmFsKFwiZXh0ZW5zaW9uXCIsIFwiZXh0ZW5zaW9uXCIsIFwiYWNjZXB0XCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGFkYXB0ZXJzLmFkZFNpbmdsZVZhbChcInJlZ2V4XCIsIFwicGF0dGVyblwiKTtcclxuICAgIGFkYXB0ZXJzLmFkZEJvb2woXCJjcmVkaXRjYXJkXCIpLmFkZEJvb2woXCJkYXRlXCIpLmFkZEJvb2woXCJkaWdpdHNcIikuYWRkQm9vbChcImVtYWlsXCIpLmFkZEJvb2woXCJudW1iZXJcIikuYWRkQm9vbChcInVybFwiKTtcclxuICAgIGFkYXB0ZXJzLmFkZE1pbk1heChcImxlbmd0aFwiLCBcIm1pbmxlbmd0aFwiLCBcIm1heGxlbmd0aFwiLCBcInJhbmdlbGVuZ3RoXCIpLmFkZE1pbk1heChcInJhbmdlXCIsIFwibWluXCIsIFwibWF4XCIsIFwicmFuZ2VcIik7XHJcbiAgICBhZGFwdGVycy5hZGRNaW5NYXgoXCJtaW5sZW5ndGhcIiwgXCJtaW5sZW5ndGhcIikuYWRkTWluTWF4KFwibWF4bGVuZ3RoXCIsIFwibWlubGVuZ3RoXCIsIFwibWF4bGVuZ3RoXCIpO1xyXG4gICAgYWRhcHRlcnMuYWRkKFwiZXF1YWx0b1wiLCBbXCJvdGhlclwiXSwgZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgcHJlZml4ID0gZ2V0TW9kZWxQcmVmaXgob3B0aW9ucy5lbGVtZW50Lm5hbWUpLFxyXG4gICAgICAgICAgICBvdGhlciA9IG9wdGlvbnMucGFyYW1zLm90aGVyLFxyXG4gICAgICAgICAgICBmdWxsT3RoZXJOYW1lID0gYXBwZW5kTW9kZWxQcmVmaXgob3RoZXIsIHByZWZpeCksXHJcbiAgICAgICAgICAgIGVsZW1lbnQgPSAkKG9wdGlvbnMuZm9ybSkuZmluZChcIjppbnB1dFwiKS5maWx0ZXIoXCJbbmFtZT0nXCIgKyBlc2NhcGVBdHRyaWJ1dGVWYWx1ZShmdWxsT3RoZXJOYW1lKSArIFwiJ11cIilbMF07XHJcblxyXG4gICAgICAgIHNldFZhbGlkYXRpb25WYWx1ZXMob3B0aW9ucywgXCJlcXVhbFRvXCIsIGVsZW1lbnQpO1xyXG4gICAgfSk7XHJcbiAgICBhZGFwdGVycy5hZGQoXCJyZXF1aXJlZFwiLCBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIC8vIGpRdWVyeSBWYWxpZGF0ZSBlcXVhdGVzIFwicmVxdWlyZWRcIiB3aXRoIFwibWFuZGF0b3J5XCIgZm9yIGNoZWNrYm94IGVsZW1lbnRzXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZWxlbWVudC50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09IFwiSU5QVVRcIiB8fCBvcHRpb25zLmVsZW1lbnQudHlwZS50b1VwcGVyQ2FzZSgpICE9PSBcIkNIRUNLQk9YXCIpIHtcclxuICAgICAgICAgICAgc2V0VmFsaWRhdGlvblZhbHVlcyhvcHRpb25zLCBcInJlcXVpcmVkXCIsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgYWRhcHRlcnMuYWRkKFwicmVtb3RlXCIsIFtcInVybFwiLCBcInR5cGVcIiwgXCJhZGRpdGlvbmFsZmllbGRzXCJdLCBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHtcclxuICAgICAgICAgICAgdXJsOiBvcHRpb25zLnBhcmFtcy51cmwsXHJcbiAgICAgICAgICAgIHR5cGU6IG9wdGlvbnMucGFyYW1zLnR5cGUgfHwgXCJHRVRcIixcclxuICAgICAgICAgICAgZGF0YToge31cclxuICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcmVmaXggPSBnZXRNb2RlbFByZWZpeChvcHRpb25zLmVsZW1lbnQubmFtZSk7XHJcblxyXG4gICAgICAgICQuZWFjaChzcGxpdEFuZFRyaW0ob3B0aW9ucy5wYXJhbXMuYWRkaXRpb25hbGZpZWxkcyB8fCBvcHRpb25zLmVsZW1lbnQubmFtZSksIGZ1bmN0aW9uIChpLCBmaWVsZE5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtTmFtZSA9IGFwcGVuZE1vZGVsUHJlZml4KGZpZWxkTmFtZSwgcHJlZml4KTtcclxuICAgICAgICAgICAgdmFsdWUuZGF0YVtwYXJhbU5hbWVdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gJChvcHRpb25zLmZvcm0pLmZpbmQoXCI6aW5wdXRcIikuZmlsdGVyKFwiW25hbWU9J1wiICsgZXNjYXBlQXR0cmlidXRlVmFsdWUocGFyYW1OYW1lKSArIFwiJ11cIik7XHJcbiAgICAgICAgICAgICAgICAvLyBGb3IgY2hlY2tib3hlcyBhbmQgcmFkaW8gYnV0dG9ucywgb25seSBwaWNrIHVwIHZhbHVlcyBmcm9tIGNoZWNrZWQgZmllbGRzLlxyXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLmlzKFwiOmNoZWNrYm94XCIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkLmZpbHRlcihcIjpjaGVja2VkXCIpLnZhbCgpIHx8IGZpZWxkLmZpbHRlcihcIjpoaWRkZW5cIikudmFsKCkgfHwgJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5pcyhcIjpyYWRpb1wiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZC5maWx0ZXIoXCI6Y2hlY2tlZFwiKS52YWwoKSB8fCAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZC52YWwoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc2V0VmFsaWRhdGlvblZhbHVlcyhvcHRpb25zLCBcInJlbW90ZVwiLCB2YWx1ZSk7XHJcbiAgICB9KTtcclxuICAgIGFkYXB0ZXJzLmFkZChcInBhc3N3b3JkXCIsIFtcIm1pblwiLCBcIm5vbmFscGhhbWluXCIsIFwicmVnZXhcIl0sIGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMucGFyYW1zLm1pbikge1xyXG4gICAgICAgICAgICBzZXRWYWxpZGF0aW9uVmFsdWVzKG9wdGlvbnMsIFwibWlubGVuZ3RoXCIsIG9wdGlvbnMucGFyYW1zLm1pbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLnBhcmFtcy5ub25hbHBoYW1pbikge1xyXG4gICAgICAgICAgICBzZXRWYWxpZGF0aW9uVmFsdWVzKG9wdGlvbnMsIFwibm9uYWxwaGFtaW5cIiwgb3B0aW9ucy5wYXJhbXMubm9uYWxwaGFtaW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5wYXJhbXMucmVnZXgpIHtcclxuICAgICAgICAgICAgc2V0VmFsaWRhdGlvblZhbHVlcyhvcHRpb25zLCBcInJlZ2V4XCIsIG9wdGlvbnMucGFyYW1zLnJlZ2V4KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAkKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAkalF2YWwudW5vYnRydXNpdmUucGFyc2UoZG9jdW1lbnQpO1xyXG4gICAgfSk7XHJcbn0oalF1ZXJ5KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXZhbGlkYXRpb24tdW5vYnRydXNpdmUvanF1ZXJ5LnZhbGlkYXRlLnVub2J0cnVzaXZlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiEgdGV0aGVyIDEuNC4zICovXG5cbihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5UZXRoZXIgPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbnZhciBUZXRoZXJCYXNlID0gdW5kZWZpbmVkO1xuaWYgKHR5cGVvZiBUZXRoZXJCYXNlID09PSAndW5kZWZpbmVkJykge1xuICBUZXRoZXJCYXNlID0geyBtb2R1bGVzOiBbXSB9O1xufVxuXG52YXIgemVyb0VsZW1lbnQgPSBudWxsO1xuXG4vLyBTYW1lIGFzIG5hdGl2ZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QsIGV4Y2VwdCBpdCB0YWtlcyBpbnRvIGFjY291bnQgcGFyZW50IDxmcmFtZT4gb2Zmc2V0c1xuLy8gaWYgdGhlIGVsZW1lbnQgbGllcyB3aXRoaW4gYSBuZXN0ZWQgZG9jdW1lbnQgKDxmcmFtZT4gb3IgPGlmcmFtZT4tbGlrZSkuXG5mdW5jdGlvbiBnZXRBY3R1YWxCb3VuZGluZ0NsaWVudFJlY3Qobm9kZSkge1xuICB2YXIgYm91bmRpbmdSZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAvLyBUaGUgb3JpZ2luYWwgb2JqZWN0IHJldHVybmVkIGJ5IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyBpbW11dGFibGUsIHNvIHdlIGNsb25lIGl0XG4gIC8vIFdlIGNhbid0IHVzZSBleHRlbmQgYmVjYXVzZSB0aGUgcHJvcGVydGllcyBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgb2JqZWN0IGJ5IGhhc093blByb3BlcnR5IGluIElFOVxuICB2YXIgcmVjdCA9IHt9O1xuICBmb3IgKHZhciBrIGluIGJvdW5kaW5nUmVjdCkge1xuICAgIHJlY3Rba10gPSBib3VuZGluZ1JlY3Rba107XG4gIH1cblxuICBpZiAobm9kZS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCkge1xuICAgIHZhciBfZnJhbWVFbGVtZW50ID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmZyYW1lRWxlbWVudDtcbiAgICBpZiAoX2ZyYW1lRWxlbWVudCkge1xuICAgICAgdmFyIGZyYW1lUmVjdCA9IGdldEFjdHVhbEJvdW5kaW5nQ2xpZW50UmVjdChfZnJhbWVFbGVtZW50KTtcbiAgICAgIHJlY3QudG9wICs9IGZyYW1lUmVjdC50b3A7XG4gICAgICByZWN0LmJvdHRvbSArPSBmcmFtZVJlY3QudG9wO1xuICAgICAgcmVjdC5sZWZ0ICs9IGZyYW1lUmVjdC5sZWZ0O1xuICAgICAgcmVjdC5yaWdodCArPSBmcmFtZVJlY3QubGVmdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50cyhlbCkge1xuICAvLyBJbiBmaXJlZm94IGlmIHRoZSBlbCBpcyBpbnNpZGUgYW4gaWZyYW1lIHdpdGggZGlzcGxheTogbm9uZTsgd2luZG93LmdldENvbXB1dGVkU3R5bGUoKSB3aWxsIHJldHVybiBudWxsO1xuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NDgzOTdcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsKSB8fCB7fTtcbiAgdmFyIHBvc2l0aW9uID0gY29tcHV0ZWRTdHlsZS5wb3NpdGlvbjtcbiAgdmFyIHBhcmVudHMgPSBbXTtcblxuICBpZiAocG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gW2VsXTtcbiAgfVxuXG4gIHZhciBwYXJlbnQgPSBlbDtcbiAgd2hpbGUgKChwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZSkgJiYgcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIHZhciBzdHlsZSA9IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHBhcmVudCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgc3R5bGUgPT09IG51bGwpIHtcbiAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgfVxuXG4gICAgdmFyIF9zdHlsZSA9IHN0eWxlO1xuICAgIHZhciBvdmVyZmxvdyA9IF9zdHlsZS5vdmVyZmxvdztcbiAgICB2YXIgb3ZlcmZsb3dYID0gX3N0eWxlLm92ZXJmbG93WDtcbiAgICB2YXIgb3ZlcmZsb3dZID0gX3N0eWxlLm92ZXJmbG93WTtcblxuICAgIGlmICgvKGF1dG98c2Nyb2xsfG92ZXJsYXkpLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKSkge1xuICAgICAgaWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnIHx8IFsncmVsYXRpdmUnLCAnYWJzb2x1dGUnLCAnZml4ZWQnXS5pbmRleE9mKHN0eWxlLnBvc2l0aW9uKSA+PSAwKSB7XG4gICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBhcmVudHMucHVzaChlbC5vd25lckRvY3VtZW50LmJvZHkpO1xuXG4gIC8vIElmIHRoZSBub2RlIGlzIHdpdGhpbiBhIGZyYW1lLCBhY2NvdW50IGZvciB0aGUgcGFyZW50IHdpbmRvdyBzY3JvbGxcbiAgaWYgKGVsLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50KSB7XG4gICAgcGFyZW50cy5wdXNoKGVsLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpO1xuICB9XG5cbiAgcmV0dXJuIHBhcmVudHM7XG59XG5cbnZhciB1bmlxdWVJZCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBpZCA9IDA7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICsraWQ7XG4gIH07XG59KSgpO1xuXG52YXIgemVyb1Bvc0NhY2hlID0ge307XG52YXIgZ2V0T3JpZ2luID0gZnVuY3Rpb24gZ2V0T3JpZ2luKCkge1xuICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgdW5mb3J0dW5hdGVseSB0b28gYWNjdXJhdGUuICBJdCBpbnRyb2R1Y2VzIGEgcGl4ZWwgb3IgdHdvIG9mXG4gIC8vIGppdHRlciBhcyB0aGUgdXNlciBzY3JvbGxzIHRoYXQgbWVzc2VzIHdpdGggb3VyIGFiaWxpdHkgdG8gZGV0ZWN0IGlmIHR3byBwb3NpdGlvbnNcbiAgLy8gYXJlIGVxdWl2aWxhbnQgb3Igbm90LiAgV2UgcGxhY2UgYW4gZWxlbWVudCBhdCB0aGUgdG9wIGxlZnQgb2YgdGhlIHBhZ2UgdGhhdCB3aWxsXG4gIC8vIGdldCB0aGUgc2FtZSBqaXR0ZXIsIHNvIHdlIGNhbiBjYW5jZWwgdGhlIHR3byBvdXQuXG4gIHZhciBub2RlID0gemVyb0VsZW1lbnQ7XG4gIGlmICghbm9kZSB8fCAhZG9jdW1lbnQuYm9keS5jb250YWlucyhub2RlKSkge1xuICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS10ZXRoZXItaWQnLCB1bmlxdWVJZCgpKTtcbiAgICBleHRlbmQobm9kZS5zdHlsZSwge1xuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSk7XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vZGUpO1xuXG4gICAgemVyb0VsZW1lbnQgPSBub2RlO1xuICB9XG5cbiAgdmFyIGlkID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGV0aGVyLWlkJyk7XG4gIGlmICh0eXBlb2YgemVyb1Bvc0NhY2hlW2lkXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB6ZXJvUG9zQ2FjaGVbaWRdID0gZ2V0QWN0dWFsQm91bmRpbmdDbGllbnRSZWN0KG5vZGUpO1xuXG4gICAgLy8gQ2xlYXIgdGhlIGNhY2hlIHdoZW4gdGhpcyBwb3NpdGlvbiBjYWxsIGlzIGRvbmVcbiAgICBkZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICBkZWxldGUgemVyb1Bvc0NhY2hlW2lkXTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB6ZXJvUG9zQ2FjaGVbaWRdO1xufTtcblxuZnVuY3Rpb24gcmVtb3ZlVXRpbEVsZW1lbnRzKCkge1xuICBpZiAoemVyb0VsZW1lbnQpIHtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHplcm9FbGVtZW50KTtcbiAgfVxuICB6ZXJvRWxlbWVudCA9IG51bGw7XG59O1xuXG5mdW5jdGlvbiBnZXRCb3VuZHMoZWwpIHtcbiAgdmFyIGRvYyA9IHVuZGVmaW5lZDtcbiAgaWYgKGVsID09PSBkb2N1bWVudCkge1xuICAgIGRvYyA9IGRvY3VtZW50O1xuICAgIGVsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQ7XG4gIH1cblxuICB2YXIgZG9jRWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG4gIHZhciBib3ggPSBnZXRBY3R1YWxCb3VuZGluZ0NsaWVudFJlY3QoZWwpO1xuXG4gIHZhciBvcmlnaW4gPSBnZXRPcmlnaW4oKTtcblxuICBib3gudG9wIC09IG9yaWdpbi50b3A7XG4gIGJveC5sZWZ0IC09IG9yaWdpbi5sZWZ0O1xuXG4gIGlmICh0eXBlb2YgYm94LndpZHRoID09PSAndW5kZWZpbmVkJykge1xuICAgIGJveC53aWR0aCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsV2lkdGggLSBib3gubGVmdCAtIGJveC5yaWdodDtcbiAgfVxuICBpZiAodHlwZW9mIGJveC5oZWlnaHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgYm94LmhlaWdodCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0IC0gYm94LnRvcCAtIGJveC5ib3R0b207XG4gIH1cblxuICBib3gudG9wID0gYm94LnRvcCAtIGRvY0VsLmNsaWVudFRvcDtcbiAgYm94LmxlZnQgPSBib3gubGVmdCAtIGRvY0VsLmNsaWVudExlZnQ7XG4gIGJveC5yaWdodCA9IGRvYy5ib2R5LmNsaWVudFdpZHRoIC0gYm94LndpZHRoIC0gYm94LmxlZnQ7XG4gIGJveC5ib3R0b20gPSBkb2MuYm9keS5jbGllbnRIZWlnaHQgLSBib3guaGVpZ2h0IC0gYm94LnRvcDtcblxuICByZXR1cm4gYm94O1xufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWwpIHtcbiAgcmV0dXJuIGVsLm9mZnNldFBhcmVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbnZhciBfc2Nyb2xsQmFyU2l6ZSA9IG51bGw7XG5mdW5jdGlvbiBnZXRTY3JvbGxCYXJTaXplKCkge1xuICBpZiAoX3Njcm9sbEJhclNpemUpIHtcbiAgICByZXR1cm4gX3Njcm9sbEJhclNpemU7XG4gIH1cbiAgdmFyIGlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGlubmVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICBpbm5lci5zdHlsZS5oZWlnaHQgPSAnMjAwcHgnO1xuXG4gIHZhciBvdXRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBleHRlbmQob3V0ZXIuc3R5bGUsIHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbiAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gICAgd2lkdGg6ICcyMDBweCcsXG4gICAgaGVpZ2h0OiAnMTUwcHgnLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICB9KTtcblxuICBvdXRlci5hcHBlbmRDaGlsZChpbm5lcik7XG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdXRlcik7XG5cbiAgdmFyIHdpZHRoQ29udGFpbmVkID0gaW5uZXIub2Zmc2V0V2lkdGg7XG4gIG91dGVyLnN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7XG4gIHZhciB3aWR0aFNjcm9sbCA9IGlubmVyLm9mZnNldFdpZHRoO1xuXG4gIGlmICh3aWR0aENvbnRhaW5lZCA9PT0gd2lkdGhTY3JvbGwpIHtcbiAgICB3aWR0aFNjcm9sbCA9IG91dGVyLmNsaWVudFdpZHRoO1xuICB9XG5cbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdXRlcik7XG5cbiAgdmFyIHdpZHRoID0gd2lkdGhDb250YWluZWQgLSB3aWR0aFNjcm9sbDtcblxuICBfc2Nyb2xsQmFyU2l6ZSA9IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IHdpZHRoIH07XG4gIHJldHVybiBfc2Nyb2xsQmFyU2l6ZTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICB2YXIgb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG5cbiAgdmFyIGFyZ3MgPSBbXTtcblxuICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuXG4gIGFyZ3Muc2xpY2UoMSkuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKG9iaikge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgIG91dFtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgZWwuY2xhc3NMaXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIG5hbWUuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgIGlmIChjbHMudHJpbSgpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCcoXnwgKScgKyBuYW1lLnNwbGl0KCcgJykuam9pbignfCcpICsgJyggfCQpJywgJ2dpJyk7XG4gICAgdmFyIGNsYXNzTmFtZSA9IGdldENsYXNzTmFtZShlbCkucmVwbGFjZShyZWdleCwgJyAnKTtcbiAgICBzZXRDbGFzc05hbWUoZWwsIGNsYXNzTmFtZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBlbC5jbGFzc0xpc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbmFtZS5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xuICAgICAgaWYgKGNscy50cmltKCkpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZUNsYXNzKGVsLCBuYW1lKTtcbiAgICB2YXIgY2xzID0gZ2V0Q2xhc3NOYW1lKGVsKSArICgnICcgKyBuYW1lKTtcbiAgICBzZXRDbGFzc05hbWUoZWwsIGNscyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzQ2xhc3MoZWwsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBlbC5jbGFzc0xpc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcbiAgfVxuICB2YXIgY2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKGVsKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoJyhefCApJyArIG5hbWUgKyAnKCB8JCknLCAnZ2knKS50ZXN0KGNsYXNzTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENsYXNzTmFtZShlbCkge1xuICAvLyBDYW4ndCB1c2UganVzdCBTVkdBbmltYXRlZFN0cmluZyBoZXJlIHNpbmNlIG5vZGVzIHdpdGhpbiBhIEZyYW1lIGluIElFIGhhdmVcbiAgLy8gY29tcGxldGVseSBzZXBhcmF0ZWx5IFNWR0FuaW1hdGVkU3RyaW5nIGJhc2UgY2xhc3Nlc1xuICBpZiAoZWwuY2xhc3NOYW1lIGluc3RhbmNlb2YgZWwub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5TVkdBbmltYXRlZFN0cmluZykge1xuICAgIHJldHVybiBlbC5jbGFzc05hbWUuYmFzZVZhbDtcbiAgfVxuICByZXR1cm4gZWwuY2xhc3NOYW1lO1xufVxuXG5mdW5jdGlvbiBzZXRDbGFzc05hbWUoZWwsIGNsYXNzTmFtZSkge1xuICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xhc3NOYW1lKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3NlcyhlbCwgYWRkLCBhbGwpIHtcbiAgLy8gT2YgdGhlIHNldCBvZiAnYWxsJyBjbGFzc2VzLCB3ZSBuZWVkIHRoZSAnYWRkJyBjbGFzc2VzLCBhbmQgb25seSB0aGVcbiAgLy8gJ2FkZCcgY2xhc3NlcyB0byBiZSBzZXQuXG4gIGFsbC5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICBpZiAoYWRkLmluZGV4T2YoY2xzKSA9PT0gLTEgJiYgaGFzQ2xhc3MoZWwsIGNscykpIHtcbiAgICAgIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xuICAgIH1cbiAgfSk7XG5cbiAgYWRkLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xuICAgIGlmICghaGFzQ2xhc3MoZWwsIGNscykpIHtcbiAgICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBkZWZlcnJlZCA9IFtdO1xuXG52YXIgZGVmZXIgPSBmdW5jdGlvbiBkZWZlcihmbikge1xuICBkZWZlcnJlZC5wdXNoKGZuKTtcbn07XG5cbnZhciBmbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICB2YXIgZm4gPSB1bmRlZmluZWQ7XG4gIHdoaWxlIChmbiA9IGRlZmVycmVkLnBvcCgpKSB7XG4gICAgZm4oKTtcbiAgfVxufTtcblxudmFyIEV2ZW50ZWQgPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmVudGVkKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudGVkKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFdmVudGVkLCBbe1xuICAgIGtleTogJ29uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24oZXZlbnQsIGhhbmRsZXIsIGN0eCkge1xuICAgICAgdmFyIG9uY2UgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDMgfHwgYXJndW1lbnRzWzNdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1szXTtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLmJpbmRpbmdzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmJpbmRpbmdzID0ge307XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXMuYmluZGluZ3NbZXZlbnRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XSA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0ucHVzaCh7IGhhbmRsZXI6IGhhbmRsZXIsIGN0eDogY3R4LCBvbmNlOiBvbmNlIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbmNlKGV2ZW50LCBoYW5kbGVyLCBjdHgpIHtcbiAgICAgIHRoaXMub24oZXZlbnQsIGhhbmRsZXIsIGN0eCwgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb2ZmJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuYmluZGluZ3MgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB0aGlzLmJpbmRpbmdzW2V2ZW50XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmJpbmRpbmdzW2V2ZW50XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLmJpbmRpbmdzW2V2ZW50XS5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAodGhpcy5iaW5kaW5nc1tldmVudF1baV0uaGFuZGxlciA9PT0gaGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0uc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndHJpZ2dlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyaWdnZXIoZXZlbnQpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5iaW5kaW5ncyAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5iaW5kaW5nc1tldmVudF0pIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLmJpbmRpbmdzW2V2ZW50XS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgX2JpbmRpbmdzJGV2ZW50JGkgPSB0aGlzLmJpbmRpbmdzW2V2ZW50XVtpXTtcbiAgICAgICAgICB2YXIgaGFuZGxlciA9IF9iaW5kaW5ncyRldmVudCRpLmhhbmRsZXI7XG4gICAgICAgICAgdmFyIGN0eCA9IF9iaW5kaW5ncyRldmVudCRpLmN0eDtcbiAgICAgICAgICB2YXIgb25jZSA9IF9iaW5kaW5ncyRldmVudCRpLm9uY2U7XG5cbiAgICAgICAgICB2YXIgY29udGV4dCA9IGN0eDtcbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuXG4gICAgICAgICAgaWYgKG9uY2UpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbZXZlbnRdLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFdmVudGVkO1xufSkoKTtcblxuVGV0aGVyQmFzZS5VdGlscyA9IHtcbiAgZ2V0QWN0dWFsQm91bmRpbmdDbGllbnRSZWN0OiBnZXRBY3R1YWxCb3VuZGluZ0NsaWVudFJlY3QsXG4gIGdldFNjcm9sbFBhcmVudHM6IGdldFNjcm9sbFBhcmVudHMsXG4gIGdldEJvdW5kczogZ2V0Qm91bmRzLFxuICBnZXRPZmZzZXRQYXJlbnQ6IGdldE9mZnNldFBhcmVudCxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIGFkZENsYXNzOiBhZGRDbGFzcyxcbiAgcmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxuICBoYXNDbGFzczogaGFzQ2xhc3MsXG4gIHVwZGF0ZUNsYXNzZXM6IHVwZGF0ZUNsYXNzZXMsXG4gIGRlZmVyOiBkZWZlcixcbiAgZmx1c2g6IGZsdXNoLFxuICB1bmlxdWVJZDogdW5pcXVlSWQsXG4gIEV2ZW50ZWQ6IEV2ZW50ZWQsXG4gIGdldFNjcm9sbEJhclNpemU6IGdldFNjcm9sbEJhclNpemUsXG4gIHJlbW92ZVV0aWxFbGVtZW50czogcmVtb3ZlVXRpbEVsZW1lbnRzXG59O1xuLyogZ2xvYmFscyBUZXRoZXJCYXNlLCBwZXJmb3JtYW5jZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pWydyZXR1cm4nXSkgX2lbJ3JldHVybiddKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UnKTsgfSB9OyB9KSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeDYsIF94NywgX3g4KSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94NiwgcHJvcGVydHkgPSBfeDcsIHJlY2VpdmVyID0gX3g4OyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94NiA9IHBhcmVudDsgX3g3ID0gcHJvcGVydHk7IF94OCA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pZiAodHlwZW9mIFRldGhlckJhc2UgPT09ICd1bmRlZmluZWQnKSB7XG4gIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgaW5jbHVkZSB0aGUgdXRpbHMuanMgZmlsZSBiZWZvcmUgdGV0aGVyLmpzJyk7XG59XG5cbnZhciBfVGV0aGVyQmFzZSRVdGlscyA9IFRldGhlckJhc2UuVXRpbHM7XG52YXIgZ2V0U2Nyb2xsUGFyZW50cyA9IF9UZXRoZXJCYXNlJFV0aWxzLmdldFNjcm9sbFBhcmVudHM7XG52YXIgZ2V0Qm91bmRzID0gX1RldGhlckJhc2UkVXRpbHMuZ2V0Qm91bmRzO1xudmFyIGdldE9mZnNldFBhcmVudCA9IF9UZXRoZXJCYXNlJFV0aWxzLmdldE9mZnNldFBhcmVudDtcbnZhciBleHRlbmQgPSBfVGV0aGVyQmFzZSRVdGlscy5leHRlbmQ7XG52YXIgYWRkQ2xhc3MgPSBfVGV0aGVyQmFzZSRVdGlscy5hZGRDbGFzcztcbnZhciByZW1vdmVDbGFzcyA9IF9UZXRoZXJCYXNlJFV0aWxzLnJlbW92ZUNsYXNzO1xudmFyIHVwZGF0ZUNsYXNzZXMgPSBfVGV0aGVyQmFzZSRVdGlscy51cGRhdGVDbGFzc2VzO1xudmFyIGRlZmVyID0gX1RldGhlckJhc2UkVXRpbHMuZGVmZXI7XG52YXIgZmx1c2ggPSBfVGV0aGVyQmFzZSRVdGlscy5mbHVzaDtcbnZhciBnZXRTY3JvbGxCYXJTaXplID0gX1RldGhlckJhc2UkVXRpbHMuZ2V0U2Nyb2xsQmFyU2l6ZTtcbnZhciByZW1vdmVVdGlsRWxlbWVudHMgPSBfVGV0aGVyQmFzZSRVdGlscy5yZW1vdmVVdGlsRWxlbWVudHM7XG5cbmZ1bmN0aW9uIHdpdGhpbihhLCBiKSB7XG4gIHZhciBkaWZmID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gMSA6IGFyZ3VtZW50c1syXTtcblxuICByZXR1cm4gYSArIGRpZmYgPj0gYiAmJiBiID49IGEgLSBkaWZmO1xufVxuXG52YXIgdHJhbnNmb3JtS2V5ID0gKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgdmFyIHRyYW5zZm9ybXMgPSBbJ3RyYW5zZm9ybScsICdXZWJraXRUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnbXNUcmFuc2Zvcm0nXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGtleSA9IHRyYW5zZm9ybXNbaV07XG4gICAgaWYgKGVsLnN0eWxlW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cbn0pKCk7XG5cbnZhciB0ZXRoZXJzID0gW107XG5cbnZhciBwb3NpdGlvbiA9IGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xuICB0ZXRoZXJzLmZvckVhY2goZnVuY3Rpb24gKHRldGhlcikge1xuICAgIHRldGhlci5wb3NpdGlvbihmYWxzZSk7XG4gIH0pO1xuICBmbHVzaCgpO1xufTtcblxuZnVuY3Rpb24gbm93KCkge1xuICBpZiAodHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICB9XG4gIHJldHVybiArbmV3IERhdGUoKTtcbn1cblxuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxhc3RDYWxsID0gbnVsbDtcbiAgdmFyIGxhc3REdXJhdGlvbiA9IG51bGw7XG4gIHZhciBwZW5kaW5nVGltZW91dCA9IG51bGw7XG5cbiAgdmFyIHRpY2sgPSBmdW5jdGlvbiB0aWNrKCkge1xuICAgIGlmICh0eXBlb2YgbGFzdER1cmF0aW9uICE9PSAndW5kZWZpbmVkJyAmJiBsYXN0RHVyYXRpb24gPiAxNikge1xuICAgICAgLy8gV2Ugdm9sdW50YXJpbHkgdGhyb3R0bGUgb3Vyc2VsdmVzIGlmIHdlIGNhbid0IG1hbmFnZSA2MGZwc1xuICAgICAgbGFzdER1cmF0aW9uID0gTWF0aC5taW4obGFzdER1cmF0aW9uIC0gMTYsIDI1MCk7XG5cbiAgICAgIC8vIEp1c3QgaW4gY2FzZSB0aGlzIGlzIHRoZSBsYXN0IGV2ZW50LCByZW1lbWJlciB0byBwb3NpdGlvbiBqdXN0IG9uY2UgbW9yZVxuICAgICAgcGVuZGluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KHRpY2ssIDI1MCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsYXN0Q2FsbCAhPT0gJ3VuZGVmaW5lZCcgJiYgbm93KCkgLSBsYXN0Q2FsbCA8IDEwKSB7XG4gICAgICAvLyBTb21lIGJyb3dzZXJzIGNhbGwgZXZlbnRzIGEgbGl0dGxlIHRvbyBmcmVxdWVudGx5LCByZWZ1c2UgdG8gcnVuIG1vcmUgdGhhbiBpcyByZWFzb25hYmxlXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBlbmRpbmdUaW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dChwZW5kaW5nVGltZW91dCk7XG4gICAgICBwZW5kaW5nVGltZW91dCA9IG51bGw7XG4gICAgfVxuXG4gICAgbGFzdENhbGwgPSBub3coKTtcbiAgICBwb3NpdGlvbigpO1xuICAgIGxhc3REdXJhdGlvbiA9IG5vdygpIC0gbGFzdENhbGw7XG4gIH07XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBbJ3Jlc2l6ZScsICdzY3JvbGwnLCAndG91Y2htb3ZlJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aWNrKTtcbiAgICB9KTtcbiAgfVxufSkoKTtcblxudmFyIE1JUlJPUl9MUiA9IHtcbiAgY2VudGVyOiAnY2VudGVyJyxcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0J1xufTtcblxudmFyIE1JUlJPUl9UQiA9IHtcbiAgbWlkZGxlOiAnbWlkZGxlJyxcbiAgdG9wOiAnYm90dG9tJyxcbiAgYm90dG9tOiAndG9wJ1xufTtcblxudmFyIE9GRlNFVF9NQVAgPSB7XG4gIHRvcDogMCxcbiAgbGVmdDogMCxcbiAgbWlkZGxlOiAnNTAlJyxcbiAgY2VudGVyOiAnNTAlJyxcbiAgYm90dG9tOiAnMTAwJScsXG4gIHJpZ2h0OiAnMTAwJSdcbn07XG5cbnZhciBhdXRvVG9GaXhlZEF0dGFjaG1lbnQgPSBmdW5jdGlvbiBhdXRvVG9GaXhlZEF0dGFjaG1lbnQoYXR0YWNobWVudCwgcmVsYXRpdmVUb0F0dGFjaG1lbnQpIHtcbiAgdmFyIGxlZnQgPSBhdHRhY2htZW50LmxlZnQ7XG4gIHZhciB0b3AgPSBhdHRhY2htZW50LnRvcDtcblxuICBpZiAobGVmdCA9PT0gJ2F1dG8nKSB7XG4gICAgbGVmdCA9IE1JUlJPUl9MUltyZWxhdGl2ZVRvQXR0YWNobWVudC5sZWZ0XTtcbiAgfVxuXG4gIGlmICh0b3AgPT09ICdhdXRvJykge1xuICAgIHRvcCA9IE1JUlJPUl9UQltyZWxhdGl2ZVRvQXR0YWNobWVudC50b3BdO1xuICB9XG5cbiAgcmV0dXJuIHsgbGVmdDogbGVmdCwgdG9wOiB0b3AgfTtcbn07XG5cbnZhciBhdHRhY2htZW50VG9PZmZzZXQgPSBmdW5jdGlvbiBhdHRhY2htZW50VG9PZmZzZXQoYXR0YWNobWVudCkge1xuICB2YXIgbGVmdCA9IGF0dGFjaG1lbnQubGVmdDtcbiAgdmFyIHRvcCA9IGF0dGFjaG1lbnQudG9wO1xuXG4gIGlmICh0eXBlb2YgT0ZGU0VUX01BUFthdHRhY2htZW50LmxlZnRdICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxlZnQgPSBPRkZTRVRfTUFQW2F0dGFjaG1lbnQubGVmdF07XG4gIH1cblxuICBpZiAodHlwZW9mIE9GRlNFVF9NQVBbYXR0YWNobWVudC50b3BdICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRvcCA9IE9GRlNFVF9NQVBbYXR0YWNobWVudC50b3BdO1xuICB9XG5cbiAgcmV0dXJuIHsgbGVmdDogbGVmdCwgdG9wOiB0b3AgfTtcbn07XG5cbmZ1bmN0aW9uIGFkZE9mZnNldCgpIHtcbiAgdmFyIG91dCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG9mZnNldHMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBvZmZzZXRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgb2Zmc2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIHRvcCA9IF9yZWYudG9wO1xuICAgIHZhciBsZWZ0ID0gX3JlZi5sZWZ0O1xuXG4gICAgaWYgKHR5cGVvZiB0b3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0b3AgPSBwYXJzZUZsb2F0KHRvcCwgMTApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGxlZnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsZWZ0ID0gcGFyc2VGbG9hdChsZWZ0LCAxMCk7XG4gICAgfVxuXG4gICAgb3V0LnRvcCArPSB0b3A7XG4gICAgb3V0LmxlZnQgKz0gbGVmdDtcbiAgfSk7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0VG9QeChvZmZzZXQsIHNpemUpIHtcbiAgaWYgKHR5cGVvZiBvZmZzZXQubGVmdCA9PT0gJ3N0cmluZycgJiYgb2Zmc2V0LmxlZnQuaW5kZXhPZignJScpICE9PSAtMSkge1xuICAgIG9mZnNldC5sZWZ0ID0gcGFyc2VGbG9hdChvZmZzZXQubGVmdCwgMTApIC8gMTAwICogc2l6ZS53aWR0aDtcbiAgfVxuICBpZiAodHlwZW9mIG9mZnNldC50b3AgPT09ICdzdHJpbmcnICYmIG9mZnNldC50b3AuaW5kZXhPZignJScpICE9PSAtMSkge1xuICAgIG9mZnNldC50b3AgPSBwYXJzZUZsb2F0KG9mZnNldC50b3AsIDEwKSAvIDEwMCAqIHNpemUuaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldDtcbn1cblxudmFyIHBhcnNlT2Zmc2V0ID0gZnVuY3Rpb24gcGFyc2VPZmZzZXQodmFsdWUpIHtcbiAgdmFyIF92YWx1ZSRzcGxpdCA9IHZhbHVlLnNwbGl0KCcgJyk7XG5cbiAgdmFyIF92YWx1ZSRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfdmFsdWUkc3BsaXQsIDIpO1xuXG4gIHZhciB0b3AgPSBfdmFsdWUkc3BsaXQyWzBdO1xuICB2YXIgbGVmdCA9IF92YWx1ZSRzcGxpdDJbMV07XG5cbiAgcmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcbn07XG52YXIgcGFyc2VBdHRhY2htZW50ID0gcGFyc2VPZmZzZXQ7XG5cbnZhciBUZXRoZXJDbGFzcyA9IChmdW5jdGlvbiAoX0V2ZW50ZWQpIHtcbiAgX2luaGVyaXRzKFRldGhlckNsYXNzLCBfRXZlbnRlZCk7XG5cbiAgZnVuY3Rpb24gVGV0aGVyQ2xhc3Mob3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV0aGVyQ2xhc3MpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGV0aGVyQ2xhc3MucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbi5iaW5kKHRoaXMpO1xuXG4gICAgdGV0aGVycy5wdXNoKHRoaXMpO1xuXG4gICAgdGhpcy5oaXN0b3J5ID0gW107XG5cbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucywgZmFsc2UpO1xuXG4gICAgVGV0aGVyQmFzZS5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgaWYgKHR5cGVvZiBtb2R1bGUuaW5pdGlhbGl6ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbW9kdWxlLmluaXRpYWxpemUuY2FsbChfdGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnBvc2l0aW9uKCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVGV0aGVyQ2xhc3MsIFt7XG4gICAga2V5OiAnZ2V0Q2xhc3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbGFzcygpIHtcbiAgICAgIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyAnJyA6IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBjbGFzc2VzID0gdGhpcy5vcHRpb25zLmNsYXNzZXM7XG5cbiAgICAgIGlmICh0eXBlb2YgY2xhc3NlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2xhc3Nlc1trZXldKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY2xhc3Nlc1trZXldO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuY2xhc3NQcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jbGFzc1ByZWZpeCArICctJyArIGtleTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0T3B0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBwb3MgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgIG9mZnNldDogJzAgMCcsXG4gICAgICAgIHRhcmdldE9mZnNldDogJzAgMCcsXG4gICAgICAgIHRhcmdldEF0dGFjaG1lbnQ6ICdhdXRvIGF1dG8nLFxuICAgICAgICBjbGFzc1ByZWZpeDogJ3RldGhlcidcbiAgICAgIH07XG5cbiAgICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgIHZhciBfb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHZhciBlbGVtZW50ID0gX29wdGlvbnMuZWxlbWVudDtcbiAgICAgIHZhciB0YXJnZXQgPSBfb3B0aW9ucy50YXJnZXQ7XG4gICAgICB2YXIgdGFyZ2V0TW9kaWZpZXIgPSBfb3B0aW9ucy50YXJnZXRNb2RpZmllcjtcblxuICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgdGhpcy50YXJnZXRNb2RpZmllciA9IHRhcmdldE1vZGlmaWVyO1xuXG4gICAgICBpZiAodGhpcy50YXJnZXQgPT09ICd2aWV3cG9ydCcpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICB0aGlzLnRhcmdldE1vZGlmaWVyID0gJ3Zpc2libGUnO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnRhcmdldCA9PT0gJ3Njcm9sbC1oYW5kbGUnKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgdGhpcy50YXJnZXRNb2RpZmllciA9ICdzY3JvbGwtaGFuZGxlJztcbiAgICAgIH1cblxuICAgICAgWydlbGVtZW50JywgJ3RhcmdldCddLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIF90aGlzMltrZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGV0aGVyIEVycm9yOiBCb3RoIGVsZW1lbnQgYW5kIHRhcmdldCBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgX3RoaXMyW2tleV0uanF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIF90aGlzMltrZXldID0gX3RoaXMyW2tleV1bMF07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGlzMltrZXldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIF90aGlzMltrZXldID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihfdGhpczJba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBhZGRDbGFzcyh0aGlzLmVsZW1lbnQsIHRoaXMuZ2V0Q2xhc3MoJ2VsZW1lbnQnKSk7XG4gICAgICBpZiAoISh0aGlzLm9wdGlvbnMuYWRkVGFyZ2V0Q2xhc3NlcyA9PT0gZmFsc2UpKSB7XG4gICAgICAgIGFkZENsYXNzKHRoaXMudGFyZ2V0LCB0aGlzLmdldENsYXNzKCd0YXJnZXQnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmF0dGFjaG1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXRoZXIgRXJyb3I6IFlvdSBtdXN0IHByb3ZpZGUgYW4gYXR0YWNobWVudCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRhcmdldEF0dGFjaG1lbnQgPSBwYXJzZUF0dGFjaG1lbnQodGhpcy5vcHRpb25zLnRhcmdldEF0dGFjaG1lbnQpO1xuICAgICAgdGhpcy5hdHRhY2htZW50ID0gcGFyc2VBdHRhY2htZW50KHRoaXMub3B0aW9ucy5hdHRhY2htZW50KTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gcGFyc2VPZmZzZXQodGhpcy5vcHRpb25zLm9mZnNldCk7XG4gICAgICB0aGlzLnRhcmdldE9mZnNldCA9IHBhcnNlT2Zmc2V0KHRoaXMub3B0aW9ucy50YXJnZXRPZmZzZXQpO1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuc2Nyb2xsUGFyZW50cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRhcmdldE1vZGlmaWVyID09PSAnc2Nyb2xsLWhhbmRsZScpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnRzID0gW3RoaXMudGFyZ2V0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50cyA9IGdldFNjcm9sbFBhcmVudHModGhpcy50YXJnZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoISh0aGlzLm9wdGlvbnMuZW5hYmxlZCA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlKHBvcyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VGFyZ2V0Qm91bmRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGFyZ2V0Qm91bmRzKCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnRhcmdldE1vZGlmaWVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodGhpcy50YXJnZXRNb2RpZmllciA9PT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgaWYgKHRoaXMudGFyZ2V0ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB0b3A6IHBhZ2VZT2Zmc2V0LCBsZWZ0OiBwYWdlWE9mZnNldCwgaGVpZ2h0OiBpbm5lckhlaWdodCwgd2lkdGg6IGlubmVyV2lkdGggfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGJvdW5kcyA9IGdldEJvdW5kcyh0aGlzLnRhcmdldCk7XG5cbiAgICAgICAgICAgIHZhciBvdXQgPSB7XG4gICAgICAgICAgICAgIGhlaWdodDogYm91bmRzLmhlaWdodCxcbiAgICAgICAgICAgICAgd2lkdGg6IGJvdW5kcy53aWR0aCxcbiAgICAgICAgICAgICAgdG9wOiBib3VuZHMudG9wLFxuICAgICAgICAgICAgICBsZWZ0OiBib3VuZHMubGVmdFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgb3V0LmhlaWdodCA9IE1hdGgubWluKG91dC5oZWlnaHQsIGJvdW5kcy5oZWlnaHQgLSAocGFnZVlPZmZzZXQgLSBib3VuZHMudG9wKSk7XG4gICAgICAgICAgICBvdXQuaGVpZ2h0ID0gTWF0aC5taW4ob3V0LmhlaWdodCwgYm91bmRzLmhlaWdodCAtIChib3VuZHMudG9wICsgYm91bmRzLmhlaWdodCAtIChwYWdlWU9mZnNldCArIGlubmVySGVpZ2h0KSkpO1xuICAgICAgICAgICAgb3V0LmhlaWdodCA9IE1hdGgubWluKGlubmVySGVpZ2h0LCBvdXQuaGVpZ2h0KTtcbiAgICAgICAgICAgIG91dC5oZWlnaHQgLT0gMjtcblxuICAgICAgICAgICAgb3V0LndpZHRoID0gTWF0aC5taW4ob3V0LndpZHRoLCBib3VuZHMud2lkdGggLSAocGFnZVhPZmZzZXQgLSBib3VuZHMubGVmdCkpO1xuICAgICAgICAgICAgb3V0LndpZHRoID0gTWF0aC5taW4ob3V0LndpZHRoLCBib3VuZHMud2lkdGggLSAoYm91bmRzLmxlZnQgKyBib3VuZHMud2lkdGggLSAocGFnZVhPZmZzZXQgKyBpbm5lcldpZHRoKSkpO1xuICAgICAgICAgICAgb3V0LndpZHRoID0gTWF0aC5taW4oaW5uZXJXaWR0aCwgb3V0LndpZHRoKTtcbiAgICAgICAgICAgIG91dC53aWR0aCAtPSAyO1xuXG4gICAgICAgICAgICBpZiAob3V0LnRvcCA8IHBhZ2VZT2Zmc2V0KSB7XG4gICAgICAgICAgICAgIG91dC50b3AgPSBwYWdlWU9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdXQubGVmdCA8IHBhZ2VYT2Zmc2V0KSB7XG4gICAgICAgICAgICAgIG91dC5sZWZ0ID0gcGFnZVhPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudGFyZ2V0TW9kaWZpZXIgPT09ICdzY3JvbGwtaGFuZGxlJykge1xuICAgICAgICAgIHZhciBib3VuZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgICAgICAgIGlmICh0YXJnZXQgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgICAgICAgYm91bmRzID0ge1xuICAgICAgICAgICAgICBsZWZ0OiBwYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgdG9wOiBwYWdlWU9mZnNldCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBpbm5lckhlaWdodCxcbiAgICAgICAgICAgICAgd2lkdGg6IGlubmVyV2lkdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvdW5kcyA9IGdldEJvdW5kcyh0YXJnZXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcblxuICAgICAgICAgIHZhciBoYXNCb3R0b21TY3JvbGwgPSB0YXJnZXQuc2Nyb2xsV2lkdGggPiB0YXJnZXQuY2xpZW50V2lkdGggfHwgW3N0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1hdLmluZGV4T2YoJ3Njcm9sbCcpID49IDAgfHwgdGhpcy50YXJnZXQgIT09IGRvY3VtZW50LmJvZHk7XG5cbiAgICAgICAgICB2YXIgc2Nyb2xsQm90dG9tID0gMDtcbiAgICAgICAgICBpZiAoaGFzQm90dG9tU2Nyb2xsKSB7XG4gICAgICAgICAgICBzY3JvbGxCb3R0b20gPSAxNTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaGVpZ2h0ID0gYm91bmRzLmhlaWdodCAtIHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyVG9wV2lkdGgpIC0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJCb3R0b21XaWR0aCkgLSBzY3JvbGxCb3R0b207XG5cbiAgICAgICAgICB2YXIgb3V0ID0ge1xuICAgICAgICAgICAgd2lkdGg6IDE1LFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKiAwLjk3NSAqIChoZWlnaHQgLyB0YXJnZXQuc2Nyb2xsSGVpZ2h0KSxcbiAgICAgICAgICAgIGxlZnQ6IGJvdW5kcy5sZWZ0ICsgYm91bmRzLndpZHRoIC0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJMZWZ0V2lkdGgpIC0gMTVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIGZpdEFkaiA9IDA7XG4gICAgICAgICAgaWYgKGhlaWdodCA8IDQwOCAmJiB0aGlzLnRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgZml0QWRqID0gLTAuMDAwMTEgKiBNYXRoLnBvdyhoZWlnaHQsIDIpIC0gMC4wMDcyNyAqIGhlaWdodCArIDIyLjU4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnRhcmdldCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgb3V0LmhlaWdodCA9IE1hdGgubWF4KG91dC5oZWlnaHQsIDI0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2Nyb2xsUGVyY2VudGFnZSA9IHRoaXMudGFyZ2V0LnNjcm9sbFRvcCAvICh0YXJnZXQuc2Nyb2xsSGVpZ2h0IC0gaGVpZ2h0KTtcbiAgICAgICAgICBvdXQudG9wID0gc2Nyb2xsUGVyY2VudGFnZSAqIChoZWlnaHQgLSBvdXQuaGVpZ2h0IC0gZml0QWRqKSArIGJvdW5kcy50b3AgKyBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlclRvcFdpZHRoKTtcblxuICAgICAgICAgIGlmICh0aGlzLnRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgb3V0LmhlaWdodCA9IE1hdGgubWF4KG91dC5oZWlnaHQsIDI0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0Qm91bmRzKHRoaXMudGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjbGVhckNhY2hlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2FjaGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWNoZShrLCBnZXR0ZXIpIHtcbiAgICAgIC8vIE1vcmUgdGhhbiBvbmUgbW9kdWxlIHdpbGwgb2Z0ZW4gbmVlZCB0aGUgc2FtZSBET00gaW5mbywgc29cbiAgICAgIC8vIHdlIGtlZXAgYSBjYWNoZSB3aGljaCBpcyBjbGVhcmVkIG9uIGVhY2ggcG9zaXRpb24gY2FsbFxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jYWNoZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jYWNoZVtrXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVba10gPSBnZXR0ZXIuY2FsbCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlW2tdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VuYWJsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgcG9zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgaWYgKCEodGhpcy5vcHRpb25zLmFkZFRhcmdldENsYXNzZXMgPT09IGZhbHNlKSkge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLnRhcmdldCwgdGhpcy5nZXRDbGFzcygnZW5hYmxlZCcpKTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzKHRoaXMuZWxlbWVudCwgdGhpcy5nZXRDbGFzcygnZW5hYmxlZCcpKTtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cbiAgICAgIHRoaXMuc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudCAhPT0gX3RoaXMzLnRhcmdldC5vd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIF90aGlzMy5wb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAocG9zKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkaXNhYmxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICByZW1vdmVDbGFzcyh0aGlzLnRhcmdldCwgdGhpcy5nZXRDbGFzcygnZW5hYmxlZCcpKTtcbiAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWxlbWVudCwgdGhpcy5nZXRDbGFzcygnZW5hYmxlZCcpKTtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuc2Nyb2xsUGFyZW50cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBfdGhpczQucG9zaXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB0aGlzLmRpc2FibGUoKTtcblxuICAgICAgdGV0aGVycy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXRoZXIsIGkpIHtcbiAgICAgICAgaWYgKHRldGhlciA9PT0gX3RoaXM1KSB7XG4gICAgICAgICAgdGV0aGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZW1vdmUgYW55IGVsZW1lbnRzIHdlIHdlcmUgdXNpbmcgZm9yIGNvbnZlbmllbmNlIGZyb20gdGhlIERPTVxuICAgICAgaWYgKHRldGhlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlbW92ZVV0aWxFbGVtZW50cygpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZUF0dGFjaENsYXNzZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVBdHRhY2hDbGFzc2VzKGVsZW1lbnRBdHRhY2gsIHRhcmdldEF0dGFjaCkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIGVsZW1lbnRBdHRhY2ggPSBlbGVtZW50QXR0YWNoIHx8IHRoaXMuYXR0YWNobWVudDtcbiAgICAgIHRhcmdldEF0dGFjaCA9IHRhcmdldEF0dGFjaCB8fCB0aGlzLnRhcmdldEF0dGFjaG1lbnQ7XG4gICAgICB2YXIgc2lkZXMgPSBbJ2xlZnQnLCAndG9wJywgJ2JvdHRvbScsICdyaWdodCcsICdtaWRkbGUnLCAnY2VudGVyJ107XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fYWRkQXR0YWNoQ2xhc3NlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5fYWRkQXR0YWNoQ2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gdXBkYXRlQXR0YWNoQ2xhc3NlcyBjYW4gYmUgY2FsbGVkIG1vcmUgdGhhbiBvbmNlIGluIGEgcG9zaXRpb24gY2FsbCwgc29cbiAgICAgICAgLy8gd2UgbmVlZCB0byBjbGVhbiB1cCBhZnRlciBvdXJzZWx2ZXMgc3VjaCB0aGF0IHdoZW4gdGhlIGxhc3QgZGVmZXIgZ2V0c1xuICAgICAgICAvLyByYW4gaXQgZG9lc24ndCBhZGQgYW55IGV4dHJhIGNsYXNzZXMgZnJvbSBwcmV2aW91cyBjYWxscy5cbiAgICAgICAgdGhpcy5fYWRkQXR0YWNoQ2xhc3Nlcy5zcGxpY2UoMCwgdGhpcy5fYWRkQXR0YWNoQ2xhc3Nlcy5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2FkZEF0dGFjaENsYXNzZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuX2FkZEF0dGFjaENsYXNzZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBhZGQgPSB0aGlzLl9hZGRBdHRhY2hDbGFzc2VzO1xuXG4gICAgICBpZiAoZWxlbWVudEF0dGFjaC50b3ApIHtcbiAgICAgICAgYWRkLnB1c2godGhpcy5nZXRDbGFzcygnZWxlbWVudC1hdHRhY2hlZCcpICsgJy0nICsgZWxlbWVudEF0dGFjaC50b3ApO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnRBdHRhY2gubGVmdCkge1xuICAgICAgICBhZGQucHVzaCh0aGlzLmdldENsYXNzKCdlbGVtZW50LWF0dGFjaGVkJykgKyAnLScgKyBlbGVtZW50QXR0YWNoLmxlZnQpO1xuICAgICAgfVxuICAgICAgaWYgKHRhcmdldEF0dGFjaC50b3ApIHtcbiAgICAgICAgYWRkLnB1c2godGhpcy5nZXRDbGFzcygndGFyZ2V0LWF0dGFjaGVkJykgKyAnLScgKyB0YXJnZXRBdHRhY2gudG9wKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXRBdHRhY2gubGVmdCkge1xuICAgICAgICBhZGQucHVzaCh0aGlzLmdldENsYXNzKCd0YXJnZXQtYXR0YWNoZWQnKSArICctJyArIHRhcmdldEF0dGFjaC5sZWZ0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFsbCA9IFtdO1xuICAgICAgc2lkZXMuZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgICBhbGwucHVzaChfdGhpczYuZ2V0Q2xhc3MoJ2VsZW1lbnQtYXR0YWNoZWQnKSArICctJyArIHNpZGUpO1xuICAgICAgICBhbGwucHVzaChfdGhpczYuZ2V0Q2xhc3MoJ3RhcmdldC1hdHRhY2hlZCcpICsgJy0nICsgc2lkZSk7XG4gICAgICB9KTtcblxuICAgICAgZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoISh0eXBlb2YgX3RoaXM2Ll9hZGRBdHRhY2hDbGFzc2VzICE9PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVDbGFzc2VzKF90aGlzNi5lbGVtZW50LCBfdGhpczYuX2FkZEF0dGFjaENsYXNzZXMsIGFsbCk7XG4gICAgICAgIGlmICghKF90aGlzNi5vcHRpb25zLmFkZFRhcmdldENsYXNzZXMgPT09IGZhbHNlKSkge1xuICAgICAgICAgIHVwZGF0ZUNsYXNzZXMoX3RoaXM2LnRhcmdldCwgX3RoaXM2Ll9hZGRBdHRhY2hDbGFzc2VzLCBhbGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIF90aGlzNi5fYWRkQXR0YWNoQ2xhc3NlcztcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3Bvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zaXRpb24oKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdmFyIGZsdXNoQ2hhbmdlcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgIC8vIGZsdXNoQ2hhbmdlcyBjb21taXRzIHRoZSBjaGFuZ2VzIGltbWVkaWF0ZWx5LCBsZWF2ZSB0cnVlIHVubGVzcyB5b3UgYXJlIHBvc2l0aW9uaW5nIG11bHRpcGxlXG4gICAgICAvLyB0ZXRoZXJzIChpbiB3aGljaCBjYXNlIGNhbGwgVGV0aGVyLlV0aWxzLmZsdXNoIHlvdXJzZWxmIHdoZW4geW91J3JlIGRvbmUpXG5cbiAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XG5cbiAgICAgIC8vIFR1cm4gJ2F1dG8nIGF0dGFjaG1lbnRzIGludG8gdGhlIGFwcHJvcHJpYXRlIGNvcm5lciBvciBlZGdlXG4gICAgICB2YXIgdGFyZ2V0QXR0YWNobWVudCA9IGF1dG9Ub0ZpeGVkQXR0YWNobWVudCh0aGlzLnRhcmdldEF0dGFjaG1lbnQsIHRoaXMuYXR0YWNobWVudCk7XG5cbiAgICAgIHRoaXMudXBkYXRlQXR0YWNoQ2xhc3Nlcyh0aGlzLmF0dGFjaG1lbnQsIHRhcmdldEF0dGFjaG1lbnQpO1xuXG4gICAgICB2YXIgZWxlbWVudFBvcyA9IHRoaXMuY2FjaGUoJ2VsZW1lbnQtYm91bmRzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ2V0Qm91bmRzKF90aGlzNy5lbGVtZW50KTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgd2lkdGggPSBlbGVtZW50UG9zLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGVsZW1lbnRQb3MuaGVpZ2h0O1xuXG4gICAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwICYmIHR5cGVvZiB0aGlzLmxhc3RTaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgX2xhc3RTaXplID0gdGhpcy5sYXN0U2l6ZTtcblxuICAgICAgICAvLyBXZSBjYWNoZSB0aGUgaGVpZ2h0IGFuZCB3aWR0aCB0byBtYWtlIGl0IHBvc3NpYmxlIHRvIHBvc2l0aW9uIGVsZW1lbnRzIHRoYXQgYXJlXG4gICAgICAgIC8vIGdldHRpbmcgaGlkZGVuLlxuICAgICAgICB3aWR0aCA9IF9sYXN0U2l6ZS53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gX2xhc3RTaXplLmhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGFzdFNpemUgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRhcmdldFBvcyA9IHRoaXMuY2FjaGUoJ3RhcmdldC1ib3VuZHMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczcuZ2V0VGFyZ2V0Qm91bmRzKCk7XG4gICAgICB9KTtcbiAgICAgIHZhciB0YXJnZXRTaXplID0gdGFyZ2V0UG9zO1xuXG4gICAgICAvLyBHZXQgYW4gYWN0dWFsIHB4IG9mZnNldCBmcm9tIHRoZSBhdHRhY2htZW50XG4gICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0VG9QeChhdHRhY2htZW50VG9PZmZzZXQodGhpcy5hdHRhY2htZW50KSwgeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO1xuICAgICAgdmFyIHRhcmdldE9mZnNldCA9IG9mZnNldFRvUHgoYXR0YWNobWVudFRvT2Zmc2V0KHRhcmdldEF0dGFjaG1lbnQpLCB0YXJnZXRTaXplKTtcblxuICAgICAgdmFyIG1hbnVhbE9mZnNldCA9IG9mZnNldFRvUHgodGhpcy5vZmZzZXQsIHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTtcbiAgICAgIHZhciBtYW51YWxUYXJnZXRPZmZzZXQgPSBvZmZzZXRUb1B4KHRoaXMudGFyZ2V0T2Zmc2V0LCB0YXJnZXRTaXplKTtcblxuICAgICAgLy8gQWRkIHRoZSBtYW51YWxseSBwcm92aWRlZCBvZmZzZXRcbiAgICAgIG9mZnNldCA9IGFkZE9mZnNldChvZmZzZXQsIG1hbnVhbE9mZnNldCk7XG4gICAgICB0YXJnZXRPZmZzZXQgPSBhZGRPZmZzZXQodGFyZ2V0T2Zmc2V0LCBtYW51YWxUYXJnZXRPZmZzZXQpO1xuXG4gICAgICAvLyBJdCdzIG5vdyBvdXIgZ29hbCB0byBtYWtlIChlbGVtZW50IHBvc2l0aW9uICsgb2Zmc2V0KSA9PSAodGFyZ2V0IHBvc2l0aW9uICsgdGFyZ2V0IG9mZnNldClcbiAgICAgIHZhciBsZWZ0ID0gdGFyZ2V0UG9zLmxlZnQgKyB0YXJnZXRPZmZzZXQubGVmdCAtIG9mZnNldC5sZWZ0O1xuICAgICAgdmFyIHRvcCA9IHRhcmdldFBvcy50b3AgKyB0YXJnZXRPZmZzZXQudG9wIC0gb2Zmc2V0LnRvcDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBUZXRoZXJCYXNlLm1vZHVsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIF9tb2R1bGUyID0gVGV0aGVyQmFzZS5tb2R1bGVzW2ldO1xuICAgICAgICB2YXIgcmV0ID0gX21vZHVsZTIucG9zaXRpb24uY2FsbCh0aGlzLCB7XG4gICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICB0YXJnZXRBdHRhY2htZW50OiB0YXJnZXRBdHRhY2htZW50LFxuICAgICAgICAgIHRhcmdldFBvczogdGFyZ2V0UG9zLFxuICAgICAgICAgIGVsZW1lbnRQb3M6IGVsZW1lbnRQb3MsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgICAgdGFyZ2V0T2Zmc2V0OiB0YXJnZXRPZmZzZXQsXG4gICAgICAgICAgbWFudWFsT2Zmc2V0OiBtYW51YWxPZmZzZXQsXG4gICAgICAgICAgbWFudWFsVGFyZ2V0T2Zmc2V0OiBtYW51YWxUYXJnZXRPZmZzZXQsXG4gICAgICAgICAgc2Nyb2xsYmFyU2l6ZTogc2Nyb2xsYmFyU2l6ZSxcbiAgICAgICAgICBhdHRhY2htZW50OiB0aGlzLmF0dGFjaG1lbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJldCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHJldCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3AgPSByZXQudG9wO1xuICAgICAgICAgIGxlZnQgPSByZXQubGVmdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBXZSBkZXNjcmliZSB0aGUgcG9zaXRpb24gdGhyZWUgZGlmZmVyZW50IHdheXMgdG8gZ2l2ZSB0aGUgb3B0aW1pemVyXG4gICAgICAvLyBhIGNoYW5jZSB0byBkZWNpZGUgdGhlIGJlc3QgcG9zc2libGUgd2F5IHRvIHBvc2l0aW9uIHRoZSBlbGVtZW50XG4gICAgICAvLyB3aXRoIHRoZSBmZXdlc3QgcmVwYWludHMuXG4gICAgICB2YXIgbmV4dCA9IHtcbiAgICAgICAgLy8gSXQncyBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgcGFnZSAoYWJzb2x1dGUgcG9zaXRpb25pbmcgd2hlblxuICAgICAgICAvLyB0aGUgZWxlbWVudCBpcyBhIGNoaWxkIG9mIHRoZSBib2R5KVxuICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgbGVmdDogbGVmdFxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEl0J3MgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0IChmaXhlZCBwb3NpdGlvbmluZylcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICB0b3A6IHRvcCAtIHBhZ2VZT2Zmc2V0LFxuICAgICAgICAgIGJvdHRvbTogcGFnZVlPZmZzZXQgLSB0b3AgLSBoZWlnaHQgKyBpbm5lckhlaWdodCxcbiAgICAgICAgICBsZWZ0OiBsZWZ0IC0gcGFnZVhPZmZzZXQsXG4gICAgICAgICAgcmlnaHQ6IHBhZ2VYT2Zmc2V0IC0gbGVmdCAtIHdpZHRoICsgaW5uZXJXaWR0aFxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgZG9jID0gdGhpcy50YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIHZhciB3aW4gPSBkb2MuZGVmYXVsdFZpZXc7XG5cbiAgICAgIHZhciBzY3JvbGxiYXJTaXplID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHdpbi5pbm5lckhlaWdodCA+IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgIHNjcm9sbGJhclNpemUgPSB0aGlzLmNhY2hlKCdzY3JvbGxiYXItc2l6ZScsIGdldFNjcm9sbEJhclNpemUpO1xuICAgICAgICBuZXh0LnZpZXdwb3J0LmJvdHRvbSAtPSBzY3JvbGxiYXJTaXplLmhlaWdodDtcbiAgICAgIH1cblxuICAgICAgaWYgKHdpbi5pbm5lcldpZHRoID4gZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCkge1xuICAgICAgICBzY3JvbGxiYXJTaXplID0gdGhpcy5jYWNoZSgnc2Nyb2xsYmFyLXNpemUnLCBnZXRTY3JvbGxCYXJTaXplKTtcbiAgICAgICAgbmV4dC52aWV3cG9ydC5yaWdodCAtPSBzY3JvbGxiYXJTaXplLndpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAoWycnLCAnc3RhdGljJ10uaW5kZXhPZihkb2MuYm9keS5zdHlsZS5wb3NpdGlvbikgPT09IC0xIHx8IFsnJywgJ3N0YXRpYyddLmluZGV4T2YoZG9jLmJvZHkucGFyZW50RWxlbWVudC5zdHlsZS5wb3NpdGlvbikgPT09IC0xKSB7XG4gICAgICAgIC8vIEFic29sdXRlIHBvc2l0aW9uaW5nIGluIHRoZSBib2R5IHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhlIHBhZ2UsIG5vdCB0aGUgJ2luaXRpYWwgY29udGFpbmluZyBibG9jaydcbiAgICAgICAgbmV4dC5wYWdlLmJvdHRvbSA9IGRvYy5ib2R5LnNjcm9sbEhlaWdodCAtIHRvcCAtIGhlaWdodDtcbiAgICAgICAgbmV4dC5wYWdlLnJpZ2h0ID0gZG9jLmJvZHkuc2Nyb2xsV2lkdGggLSBsZWZ0IC0gd2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9wdGltaXphdGlvbnMgIT09ICd1bmRlZmluZWQnICYmIHRoaXMub3B0aW9ucy5vcHRpbWl6YXRpb25zLm1vdmVFbGVtZW50ICE9PSBmYWxzZSAmJiAhKHR5cGVvZiB0aGlzLnRhcmdldE1vZGlmaWVyICE9PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gX3RoaXM3LmNhY2hlKCd0YXJnZXQtb2Zmc2V0cGFyZW50JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChfdGhpczcudGFyZ2V0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgb2Zmc2V0UG9zaXRpb24gPSBfdGhpczcuY2FjaGUoJ3RhcmdldC1vZmZzZXRwYXJlbnQtYm91bmRzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJvdW5kcyhvZmZzZXRQYXJlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBvZmZzZXRQYXJlbnRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KTtcbiAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50U2l6ZSA9IG9mZnNldFBvc2l0aW9uO1xuXG4gICAgICAgICAgdmFyIG9mZnNldEJvcmRlciA9IHt9O1xuICAgICAgICAgIFsnVG9wJywgJ0xlZnQnLCAnQm90dG9tJywgJ1JpZ2h0J10uZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgICAgICAgb2Zmc2V0Qm9yZGVyW3NpZGUudG9Mb3dlckNhc2UoKV0gPSBwYXJzZUZsb2F0KG9mZnNldFBhcmVudFN0eWxlWydib3JkZXInICsgc2lkZSArICdXaWR0aCddKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG9mZnNldFBvc2l0aW9uLnJpZ2h0ID0gZG9jLmJvZHkuc2Nyb2xsV2lkdGggLSBvZmZzZXRQb3NpdGlvbi5sZWZ0IC0gb2Zmc2V0UGFyZW50U2l6ZS53aWR0aCArIG9mZnNldEJvcmRlci5yaWdodDtcbiAgICAgICAgICBvZmZzZXRQb3NpdGlvbi5ib3R0b20gPSBkb2MuYm9keS5zY3JvbGxIZWlnaHQgLSBvZmZzZXRQb3NpdGlvbi50b3AgLSBvZmZzZXRQYXJlbnRTaXplLmhlaWdodCArIG9mZnNldEJvcmRlci5ib3R0b207XG5cbiAgICAgICAgICBpZiAobmV4dC5wYWdlLnRvcCA+PSBvZmZzZXRQb3NpdGlvbi50b3AgKyBvZmZzZXRCb3JkZXIudG9wICYmIG5leHQucGFnZS5ib3R0b20gPj0gb2Zmc2V0UG9zaXRpb24uYm90dG9tKSB7XG4gICAgICAgICAgICBpZiAobmV4dC5wYWdlLmxlZnQgPj0gb2Zmc2V0UG9zaXRpb24ubGVmdCArIG9mZnNldEJvcmRlci5sZWZ0ICYmIG5leHQucGFnZS5yaWdodCA+PSBvZmZzZXRQb3NpdGlvbi5yaWdodCkge1xuICAgICAgICAgICAgICAvLyBXZSdyZSB3aXRoaW4gdGhlIHZpc2libGUgcGFydCBvZiB0aGUgdGFyZ2V0J3Mgc2Nyb2xsIHBhcmVudFxuICAgICAgICAgICAgICB2YXIgc2Nyb2xsVG9wID0gb2Zmc2V0UGFyZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBvZmZzZXRQYXJlbnQuc2Nyb2xsTGVmdDtcblxuICAgICAgICAgICAgICAvLyBJdCdzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSB0YXJnZXQncyBvZmZzZXQgcGFyZW50IChhYnNvbHV0ZSBwb3NpdGlvbmluZyB3aGVuXG4gICAgICAgICAgICAgIC8vIHRoZSBlbGVtZW50IGlzIG1vdmVkIHRvIGJlIGEgY2hpbGQgb2YgdGhlIHRhcmdldCdzIG9mZnNldCBwYXJlbnQpLlxuICAgICAgICAgICAgICBuZXh0Lm9mZnNldCA9IHtcbiAgICAgICAgICAgICAgICB0b3A6IG5leHQucGFnZS50b3AgLSBvZmZzZXRQb3NpdGlvbi50b3AgKyBzY3JvbGxUb3AgLSBvZmZzZXRCb3JkZXIudG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IG5leHQucGFnZS5sZWZ0IC0gb2Zmc2V0UG9zaXRpb24ubGVmdCArIHNjcm9sbExlZnQgLSBvZmZzZXRCb3JkZXIubGVmdFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgY291bGQgYWxzbyB0cmF2ZWwgdXAgdGhlIERPTSBhbmQgdHJ5IGVhY2ggY29udGFpbmluZyBjb250ZXh0LCByYXRoZXIgdGhhbiBvbmx5XG4gICAgICAvLyBsb29raW5nIGF0IHRoZSBib2R5LCBidXQgd2UncmUgZ29ubmEgZ2V0IGRpbWluaXNoaW5nIHJldHVybnMuXG5cbiAgICAgIHRoaXMubW92ZShuZXh0KTtcblxuICAgICAgdGhpcy5oaXN0b3J5LnVuc2hpZnQobmV4dCk7XG5cbiAgICAgIGlmICh0aGlzLmhpc3RvcnkubGVuZ3RoID4gMykge1xuICAgICAgICB0aGlzLmhpc3RvcnkucG9wKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmbHVzaENoYW5nZXMpIHtcbiAgICAgICAgZmx1c2goKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gVEhFIElTU1VFXG4gIH0sIHtcbiAgICBrZXk6ICdtb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZShwb3MpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICBpZiAoISh0eXBlb2YgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzYW1lID0ge307XG5cbiAgICAgIGZvciAodmFyIHR5cGUgaW4gcG9zKSB7XG4gICAgICAgIHNhbWVbdHlwZV0gPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcG9zW3R5cGVdKSB7XG4gICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaGlzdG9yeS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gdGhpcy5oaXN0b3J5W2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwb2ludFt0eXBlXSAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpdGhpbihwb2ludFt0eXBlXVtrZXldLCBwb3NbdHlwZV1ba2V5XSkpIHtcbiAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICBzYW1lW3R5cGVdW2tleV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY3NzID0geyB0b3A6ICcnLCBsZWZ0OiAnJywgcmlnaHQ6ICcnLCBib3R0b206ICcnIH07XG5cbiAgICAgIHZhciB0cmFuc2NyaWJlID0gZnVuY3Rpb24gdHJhbnNjcmliZShfc2FtZSwgX3Bvcykge1xuICAgICAgICB2YXIgaGFzT3B0aW1pemF0aW9ucyA9IHR5cGVvZiBfdGhpczgub3B0aW9ucy5vcHRpbWl6YXRpb25zICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgdmFyIGdwdSA9IGhhc09wdGltaXphdGlvbnMgPyBfdGhpczgub3B0aW9ucy5vcHRpbWl6YXRpb25zLmdwdSA6IG51bGw7XG4gICAgICAgIGlmIChncHUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIHlQb3MgPSB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHhQb3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKF9zYW1lLnRvcCkge1xuICAgICAgICAgICAgY3NzLnRvcCA9IDA7XG4gICAgICAgICAgICB5UG9zID0gX3Bvcy50b3A7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNzcy5ib3R0b20gPSAwO1xuICAgICAgICAgICAgeVBvcyA9IC1fcG9zLmJvdHRvbTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX3NhbWUubGVmdCkge1xuICAgICAgICAgICAgY3NzLmxlZnQgPSAwO1xuICAgICAgICAgICAgeFBvcyA9IF9wb3MubGVmdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3NzLnJpZ2h0ID0gMDtcbiAgICAgICAgICAgIHhQb3MgPSAtX3Bvcy5yaWdodDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEpIHtcbiAgICAgICAgICAgIC8vIEh1YlNwb3QvdGV0aGVyIzIwN1xuICAgICAgICAgICAgdmFyIHJldGluYSA9IHdpbmRvdy5tYXRjaE1lZGlhKCdvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAxLjNkcHB4KScpLm1hdGNoZXMgfHwgd2luZG93Lm1hdGNoTWVkaWEoJ29ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAxLjMpJykubWF0Y2hlcztcbiAgICAgICAgICAgIGlmICghcmV0aW5hKSB7XG4gICAgICAgICAgICAgIHhQb3MgPSBNYXRoLnJvdW5kKHhQb3MpO1xuICAgICAgICAgICAgICB5UG9zID0gTWF0aC5yb3VuZCh5UG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjc3NbdHJhbnNmb3JtS2V5XSA9ICd0cmFuc2xhdGVYKCcgKyB4UG9zICsgJ3B4KSB0cmFuc2xhdGVZKCcgKyB5UG9zICsgJ3B4KSc7XG5cbiAgICAgICAgICBpZiAodHJhbnNmb3JtS2V5ICE9PSAnbXNUcmFuc2Zvcm0nKSB7XG4gICAgICAgICAgICAvLyBUaGUgWiB0cmFuc2Zvcm0gd2lsbCBrZWVwIHRoaXMgaW4gdGhlIEdQVSAoZmFzdGVyLCBhbmQgcHJldmVudHMgYXJ0aWZhY3RzKSxcbiAgICAgICAgICAgIC8vIGJ1dCBJRTkgZG9lc24ndCBzdXBwb3J0IDNkIHRyYW5zZm9ybXMgYW5kIHdpbGwgY2hva2UuXG4gICAgICAgICAgICBjc3NbdHJhbnNmb3JtS2V5XSArPSBcIiB0cmFuc2xhdGVaKDApXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChfc2FtZS50b3ApIHtcbiAgICAgICAgICAgIGNzcy50b3AgPSBfcG9zLnRvcCArICdweCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNzcy5ib3R0b20gPSBfcG9zLmJvdHRvbSArICdweCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9zYW1lLmxlZnQpIHtcbiAgICAgICAgICAgIGNzcy5sZWZ0ID0gX3Bvcy5sZWZ0ICsgJ3B4JztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3NzLnJpZ2h0ID0gX3Bvcy5yaWdodCArICdweCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgbW92ZWQgPSBmYWxzZTtcbiAgICAgIGlmICgoc2FtZS5wYWdlLnRvcCB8fCBzYW1lLnBhZ2UuYm90dG9tKSAmJiAoc2FtZS5wYWdlLmxlZnQgfHwgc2FtZS5wYWdlLnJpZ2h0KSkge1xuICAgICAgICBjc3MucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0cmFuc2NyaWJlKHNhbWUucGFnZSwgcG9zLnBhZ2UpO1xuICAgICAgfSBlbHNlIGlmICgoc2FtZS52aWV3cG9ydC50b3AgfHwgc2FtZS52aWV3cG9ydC5ib3R0b20pICYmIChzYW1lLnZpZXdwb3J0LmxlZnQgfHwgc2FtZS52aWV3cG9ydC5yaWdodCkpIHtcbiAgICAgICAgY3NzLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgICAgdHJhbnNjcmliZShzYW1lLnZpZXdwb3J0LCBwb3Mudmlld3BvcnQpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2FtZS5vZmZzZXQgIT09ICd1bmRlZmluZWQnICYmIHNhbWUub2Zmc2V0LnRvcCAmJiBzYW1lLm9mZnNldC5sZWZ0KSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY3NzLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gX3RoaXM4LmNhY2hlKCd0YXJnZXQtb2Zmc2V0cGFyZW50JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChfdGhpczgudGFyZ2V0KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChnZXRPZmZzZXRQYXJlbnQoX3RoaXM4LmVsZW1lbnQpICE9PSBvZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIGRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3RoaXM4LmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChfdGhpczguZWxlbWVudCk7XG4gICAgICAgICAgICAgIG9mZnNldFBhcmVudC5hcHBlbmRDaGlsZChfdGhpczguZWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0cmFuc2NyaWJlKHNhbWUub2Zmc2V0LCBwb3Mub2Zmc2V0KTtcbiAgICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICAgIH0pKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjc3MucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0cmFuc2NyaWJlKHsgdG9wOiB0cnVlLCBsZWZ0OiB0cnVlIH0sIHBvcy5wYWdlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtb3ZlZCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJvZHlFbGVtZW50KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5wYXJlbnROb2RlICE9PSB0aGlzLm9wdGlvbnMuYm9keUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5ib2R5RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50SXNCb2R5ID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUgJiYgY3VycmVudE5vZGUubm9kZVR5cGUgPT09IDEgJiYgY3VycmVudE5vZGUudGFnTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgICAgICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSkucG9zaXRpb24gIT09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgICAgIG9mZnNldFBhcmVudElzQm9keSA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghb2Zmc2V0UGFyZW50SXNCb2R5KSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBbnkgY3NzIGNoYW5nZSB3aWxsIHRyaWdnZXIgYSByZXBhaW50LCBzbyBsZXQncyBhdm9pZCBvbmUgaWYgbm90aGluZyBjaGFuZ2VkXG4gICAgICB2YXIgd3JpdGVDU1MgPSB7fTtcbiAgICAgIHZhciB3cml0ZSA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIga2V5IGluIGNzcykge1xuICAgICAgICB2YXIgdmFsID0gY3NzW2tleV07XG4gICAgICAgIHZhciBlbFZhbCA9IHRoaXMuZWxlbWVudC5zdHlsZVtrZXldO1xuXG4gICAgICAgIGlmIChlbFZhbCAhPT0gdmFsKSB7XG4gICAgICAgICAgd3JpdGUgPSB0cnVlO1xuICAgICAgICAgIHdyaXRlQ1NTW2tleV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHdyaXRlKSB7XG4gICAgICAgIGRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBleHRlbmQoX3RoaXM4LmVsZW1lbnQuc3R5bGUsIHdyaXRlQ1NTKTtcbiAgICAgICAgICBfdGhpczgudHJpZ2dlcigncmVwb3NpdGlvbmVkJyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUZXRoZXJDbGFzcztcbn0pKEV2ZW50ZWQpO1xuXG5UZXRoZXJDbGFzcy5tb2R1bGVzID0gW107XG5cblRldGhlckJhc2UucG9zaXRpb24gPSBwb3NpdGlvbjtcblxudmFyIFRldGhlciA9IGV4dGVuZChUZXRoZXJDbGFzcywgVGV0aGVyQmFzZSk7XG4vKiBnbG9iYWxzIFRldGhlckJhc2UgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVsncmV0dXJuJ10pIF9pWydyZXR1cm4nXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7IH0gfTsgfSkoKTtcblxudmFyIF9UZXRoZXJCYXNlJFV0aWxzID0gVGV0aGVyQmFzZS5VdGlscztcbnZhciBnZXRCb3VuZHMgPSBfVGV0aGVyQmFzZSRVdGlscy5nZXRCb3VuZHM7XG52YXIgZXh0ZW5kID0gX1RldGhlckJhc2UkVXRpbHMuZXh0ZW5kO1xudmFyIHVwZGF0ZUNsYXNzZXMgPSBfVGV0aGVyQmFzZSRVdGlscy51cGRhdGVDbGFzc2VzO1xudmFyIGRlZmVyID0gX1RldGhlckJhc2UkVXRpbHMuZGVmZXI7XG5cbnZhciBCT1VORFNfRk9STUFUID0gWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXTtcblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdSZWN0KHRldGhlciwgdG8pIHtcbiAgaWYgKHRvID09PSAnc2Nyb2xsUGFyZW50Jykge1xuICAgIHRvID0gdGV0aGVyLnNjcm9sbFBhcmVudHNbMF07XG4gIH0gZWxzZSBpZiAodG8gPT09ICd3aW5kb3cnKSB7XG4gICAgdG8gPSBbcGFnZVhPZmZzZXQsIHBhZ2VZT2Zmc2V0LCBpbm5lcldpZHRoICsgcGFnZVhPZmZzZXQsIGlubmVySGVpZ2h0ICsgcGFnZVlPZmZzZXRdO1xuICB9XG5cbiAgaWYgKHRvID09PSBkb2N1bWVudCkge1xuICAgIHRvID0gdG8uZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0by5ub2RlVHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5vZGUgPSB0bztcbiAgICAgIHZhciBzaXplID0gZ2V0Qm91bmRzKHRvKTtcbiAgICAgIHZhciBwb3MgPSBzaXplO1xuICAgICAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0byk7XG5cbiAgICAgIHRvID0gW3Bvcy5sZWZ0LCBwb3MudG9wLCBzaXplLndpZHRoICsgcG9zLmxlZnQsIHNpemUuaGVpZ2h0ICsgcG9zLnRvcF07XG5cbiAgICAgIC8vIEFjY291bnQgYW55IHBhcmVudCBGcmFtZXMgc2Nyb2xsIG9mZnNldFxuICAgICAgaWYgKG5vZGUub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIHdpbiA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgICAgdG9bMF0gKz0gd2luLnBhZ2VYT2Zmc2V0O1xuICAgICAgICB0b1sxXSArPSB3aW4ucGFnZVlPZmZzZXQ7XG4gICAgICAgIHRvWzJdICs9IHdpbi5wYWdlWE9mZnNldDtcbiAgICAgICAgdG9bM10gKz0gd2luLnBhZ2VZT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBCT1VORFNfRk9STUFULmZvckVhY2goZnVuY3Rpb24gKHNpZGUsIGkpIHtcbiAgICAgICAgc2lkZSA9IHNpZGVbMF0udG9VcHBlckNhc2UoKSArIHNpZGUuc3Vic3RyKDEpO1xuICAgICAgICBpZiAoc2lkZSA9PT0gJ1RvcCcgfHwgc2lkZSA9PT0gJ0xlZnQnKSB7XG4gICAgICAgICAgdG9baV0gKz0gcGFyc2VGbG9hdChzdHlsZVsnYm9yZGVyJyArIHNpZGUgKyAnV2lkdGgnXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9baV0gLT0gcGFyc2VGbG9hdChzdHlsZVsnYm9yZGVyJyArIHNpZGUgKyAnV2lkdGgnXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH1cblxuICByZXR1cm4gdG87XG59XG5cblRldGhlckJhc2UubW9kdWxlcy5wdXNoKHtcbiAgcG9zaXRpb246IGZ1bmN0aW9uIHBvc2l0aW9uKF9yZWYpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHRvcCA9IF9yZWYudG9wO1xuICAgIHZhciBsZWZ0ID0gX3JlZi5sZWZ0O1xuICAgIHZhciB0YXJnZXRBdHRhY2htZW50ID0gX3JlZi50YXJnZXRBdHRhY2htZW50O1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuY29uc3RyYWludHMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBfY2FjaGUgPSB0aGlzLmNhY2hlKCdlbGVtZW50LWJvdW5kcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXRCb3VuZHMoX3RoaXMuZWxlbWVudCk7XG4gICAgfSk7XG5cbiAgICB2YXIgaGVpZ2h0ID0gX2NhY2hlLmhlaWdodDtcbiAgICB2YXIgd2lkdGggPSBfY2FjaGUud2lkdGg7XG5cbiAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwICYmIHR5cGVvZiB0aGlzLmxhc3RTaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIF9sYXN0U2l6ZSA9IHRoaXMubGFzdFNpemU7XG5cbiAgICAgIC8vIEhhbmRsZSB0aGUgaXRlbSBnZXR0aW5nIGhpZGRlbiBhcyBhIHJlc3VsdCBvZiBvdXIgcG9zaXRpb25pbmcgd2l0aG91dCBnbGl0Y2hpbmdcbiAgICAgIC8vIHRoZSBjbGFzc2VzIGluIGFuZCBvdXRcbiAgICAgIHdpZHRoID0gX2xhc3RTaXplLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gX2xhc3RTaXplLmhlaWdodDtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0U2l6ZSA9IHRoaXMuY2FjaGUoJ3RhcmdldC1ib3VuZHMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuZ2V0VGFyZ2V0Qm91bmRzKCk7XG4gICAgfSk7XG5cbiAgICB2YXIgdGFyZ2V0SGVpZ2h0ID0gdGFyZ2V0U2l6ZS5oZWlnaHQ7XG4gICAgdmFyIHRhcmdldFdpZHRoID0gdGFyZ2V0U2l6ZS53aWR0aDtcblxuICAgIHZhciBhbGxDbGFzc2VzID0gW3RoaXMuZ2V0Q2xhc3MoJ3Bpbm5lZCcpLCB0aGlzLmdldENsYXNzKCdvdXQtb2YtYm91bmRzJyldO1xuXG4gICAgdGhpcy5vcHRpb25zLmNvbnN0cmFpbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgIHZhciBvdXRPZkJvdW5kc0NsYXNzID0gY29uc3RyYWludC5vdXRPZkJvdW5kc0NsYXNzO1xuICAgICAgdmFyIHBpbm5lZENsYXNzID0gY29uc3RyYWludC5waW5uZWRDbGFzcztcblxuICAgICAgaWYgKG91dE9mQm91bmRzQ2xhc3MpIHtcbiAgICAgICAgYWxsQ2xhc3Nlcy5wdXNoKG91dE9mQm91bmRzQ2xhc3MpO1xuICAgICAgfVxuICAgICAgaWYgKHBpbm5lZENsYXNzKSB7XG4gICAgICAgIGFsbENsYXNzZXMucHVzaChwaW5uZWRDbGFzcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhbGxDbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xuICAgICAgWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXS5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICAgIGFsbENsYXNzZXMucHVzaChjbHMgKyAnLScgKyBzaWRlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIGFkZENsYXNzZXMgPSBbXTtcblxuICAgIHZhciB0QXR0YWNobWVudCA9IGV4dGVuZCh7fSwgdGFyZ2V0QXR0YWNobWVudCk7XG4gICAgdmFyIGVBdHRhY2htZW50ID0gZXh0ZW5kKHt9LCB0aGlzLmF0dGFjaG1lbnQpO1xuXG4gICAgdGhpcy5vcHRpb25zLmNvbnN0cmFpbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgIHZhciB0byA9IGNvbnN0cmFpbnQudG87XG4gICAgICB2YXIgYXR0YWNobWVudCA9IGNvbnN0cmFpbnQuYXR0YWNobWVudDtcbiAgICAgIHZhciBwaW4gPSBjb25zdHJhaW50LnBpbjtcblxuICAgICAgaWYgKHR5cGVvZiBhdHRhY2htZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBhdHRhY2htZW50ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGFuZ2VBdHRhY2hYID0gdW5kZWZpbmVkLFxuICAgICAgICAgIGNoYW5nZUF0dGFjaFkgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoYXR0YWNobWVudC5pbmRleE9mKCcgJykgPj0gMCkge1xuICAgICAgICB2YXIgX2F0dGFjaG1lbnQkc3BsaXQgPSBhdHRhY2htZW50LnNwbGl0KCcgJyk7XG5cbiAgICAgICAgdmFyIF9hdHRhY2htZW50JHNwbGl0MiA9IF9zbGljZWRUb0FycmF5KF9hdHRhY2htZW50JHNwbGl0LCAyKTtcblxuICAgICAgICBjaGFuZ2VBdHRhY2hZID0gX2F0dGFjaG1lbnQkc3BsaXQyWzBdO1xuICAgICAgICBjaGFuZ2VBdHRhY2hYID0gX2F0dGFjaG1lbnQkc3BsaXQyWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhbmdlQXR0YWNoWCA9IGNoYW5nZUF0dGFjaFkgPSBhdHRhY2htZW50O1xuICAgICAgfVxuXG4gICAgICB2YXIgYm91bmRzID0gZ2V0Qm91bmRpbmdSZWN0KF90aGlzLCB0byk7XG5cbiAgICAgIGlmIChjaGFuZ2VBdHRhY2hZID09PSAndGFyZ2V0JyB8fCBjaGFuZ2VBdHRhY2hZID09PSAnYm90aCcpIHtcbiAgICAgICAgaWYgKHRvcCA8IGJvdW5kc1sxXSAmJiB0QXR0YWNobWVudC50b3AgPT09ICd0b3AnKSB7XG4gICAgICAgICAgdG9wICs9IHRhcmdldEhlaWdodDtcbiAgICAgICAgICB0QXR0YWNobWVudC50b3AgPSAnYm90dG9tJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3AgKyBoZWlnaHQgPiBib3VuZHNbM10gJiYgdEF0dGFjaG1lbnQudG9wID09PSAnYm90dG9tJykge1xuICAgICAgICAgIHRvcCAtPSB0YXJnZXRIZWlnaHQ7XG4gICAgICAgICAgdEF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZUF0dGFjaFkgPT09ICd0b2dldGhlcicpIHtcbiAgICAgICAgaWYgKHRBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICBpZiAoZUF0dGFjaG1lbnQudG9wID09PSAnYm90dG9tJyAmJiB0b3AgPCBib3VuZHNbMV0pIHtcbiAgICAgICAgICAgIHRvcCArPSB0YXJnZXRIZWlnaHQ7XG4gICAgICAgICAgICB0QXR0YWNobWVudC50b3AgPSAnYm90dG9tJztcblxuICAgICAgICAgICAgdG9wICs9IGhlaWdodDtcbiAgICAgICAgICAgIGVBdHRhY2htZW50LnRvcCA9ICd0b3AnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZUF0dGFjaG1lbnQudG9wID09PSAndG9wJyAmJiB0b3AgKyBoZWlnaHQgPiBib3VuZHNbM10gJiYgdG9wIC0gKGhlaWdodCAtIHRhcmdldEhlaWdodCkgPj0gYm91bmRzWzFdKSB7XG4gICAgICAgICAgICB0b3AgLT0gaGVpZ2h0IC0gdGFyZ2V0SGVpZ2h0O1xuICAgICAgICAgICAgdEF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XG5cbiAgICAgICAgICAgIGVBdHRhY2htZW50LnRvcCA9ICdib3R0b20nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0QXR0YWNobWVudC50b3AgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgaWYgKGVBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcgJiYgdG9wICsgaGVpZ2h0ID4gYm91bmRzWzNdKSB7XG4gICAgICAgICAgICB0b3AgLT0gdGFyZ2V0SGVpZ2h0O1xuICAgICAgICAgICAgdEF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XG5cbiAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgICBlQXR0YWNobWVudC50b3AgPSAnYm90dG9tJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGVBdHRhY2htZW50LnRvcCA9PT0gJ2JvdHRvbScgJiYgdG9wIDwgYm91bmRzWzFdICYmIHRvcCArIChoZWlnaHQgKiAyIC0gdGFyZ2V0SGVpZ2h0KSA8PSBib3VuZHNbM10pIHtcbiAgICAgICAgICAgIHRvcCArPSBoZWlnaHQgLSB0YXJnZXRIZWlnaHQ7XG4gICAgICAgICAgICB0QXR0YWNobWVudC50b3AgPSAndG9wJztcblxuICAgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRBdHRhY2htZW50LnRvcCA9PT0gJ21pZGRsZScpIHtcbiAgICAgICAgICBpZiAodG9wICsgaGVpZ2h0ID4gYm91bmRzWzNdICYmIGVBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgICBlQXR0YWNobWVudC50b3AgPSAnYm90dG9tJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHRvcCA8IGJvdW5kc1sxXSAmJiBlQXR0YWNobWVudC50b3AgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICB0b3AgKz0gaGVpZ2h0O1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VBdHRhY2hYID09PSAndGFyZ2V0JyB8fCBjaGFuZ2VBdHRhY2hYID09PSAnYm90aCcpIHtcbiAgICAgICAgaWYgKGxlZnQgPCBib3VuZHNbMF0gJiYgdEF0dGFjaG1lbnQubGVmdCA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgbGVmdCArPSB0YXJnZXRXaWR0aDtcbiAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZWZ0ICsgd2lkdGggPiBib3VuZHNbMl0gJiYgdEF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIGxlZnQgLT0gdGFyZ2V0V2lkdGg7XG4gICAgICAgICAgdEF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlQXR0YWNoWCA9PT0gJ3RvZ2V0aGVyJykge1xuICAgICAgICBpZiAobGVmdCA8IGJvdW5kc1swXSAmJiB0QXR0YWNobWVudC5sZWZ0ID09PSAnbGVmdCcpIHtcbiAgICAgICAgICBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgbGVmdCArPSB0YXJnZXRXaWR0aDtcbiAgICAgICAgICAgIHRBdHRhY2htZW50LmxlZnQgPSAncmlnaHQnO1xuXG4gICAgICAgICAgICBsZWZ0ICs9IHdpZHRoO1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGVBdHRhY2htZW50LmxlZnQgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgbGVmdCArPSB0YXJnZXRXaWR0aDtcbiAgICAgICAgICAgIHRBdHRhY2htZW50LmxlZnQgPSAncmlnaHQnO1xuXG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdyaWdodCc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxlZnQgKyB3aWR0aCA+IGJvdW5kc1syXSAmJiB0QXR0YWNobWVudC5sZWZ0ID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgaWYgKGVBdHRhY2htZW50LmxlZnQgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgbGVmdCAtPSB0YXJnZXRXaWR0aDtcbiAgICAgICAgICAgIHRBdHRhY2htZW50LmxlZnQgPSAnbGVmdCc7XG5cbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGVBdHRhY2htZW50LmxlZnQgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIGxlZnQgLT0gdGFyZ2V0V2lkdGg7XG4gICAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ2xlZnQnO1xuXG4gICAgICAgICAgICBsZWZ0ICs9IHdpZHRoO1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodEF0dGFjaG1lbnQubGVmdCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICBpZiAobGVmdCArIHdpZHRoID4gYm91bmRzWzJdICYmIGVBdHRhY2htZW50LmxlZnQgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAncmlnaHQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCA8IGJvdW5kc1swXSAmJiBlQXR0YWNobWVudC5sZWZ0ID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICBsZWZ0ICs9IHdpZHRoO1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZUF0dGFjaFkgPT09ICdlbGVtZW50JyB8fCBjaGFuZ2VBdHRhY2hZID09PSAnYm90aCcpIHtcbiAgICAgICAgaWYgKHRvcCA8IGJvdW5kc1sxXSAmJiBlQXR0YWNobWVudC50b3AgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgdG9wICs9IGhlaWdodDtcbiAgICAgICAgICBlQXR0YWNobWVudC50b3AgPSAndG9wJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3AgKyBoZWlnaHQgPiBib3VuZHNbM10gJiYgZUF0dGFjaG1lbnQudG9wID09PSAndG9wJykge1xuICAgICAgICAgIHRvcCAtPSBoZWlnaHQ7XG4gICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZUF0dGFjaFggPT09ICdlbGVtZW50JyB8fCBjaGFuZ2VBdHRhY2hYID09PSAnYm90aCcpIHtcbiAgICAgICAgaWYgKGxlZnQgPCBib3VuZHNbMF0pIHtcbiAgICAgICAgICBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgbGVmdCArPSB3aWR0aDtcbiAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAnbGVmdCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChlQXR0YWNobWVudC5sZWZ0ID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgbGVmdCArPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ2xlZnQnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZWZ0ICsgd2lkdGggPiBib3VuZHNbMl0pIHtcbiAgICAgICAgICBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdyaWdodCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChlQXR0YWNobWVudC5sZWZ0ID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBwaW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBpbiA9IHBpbi5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICAgIHJldHVybiBwLnRyaW0oKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHBpbiA9PT0gdHJ1ZSkge1xuICAgICAgICBwaW4gPSBbJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdHRvbSddO1xuICAgICAgfVxuXG4gICAgICBwaW4gPSBwaW4gfHwgW107XG5cbiAgICAgIHZhciBwaW5uZWQgPSBbXTtcbiAgICAgIHZhciBvb2IgPSBbXTtcblxuICAgICAgaWYgKHRvcCA8IGJvdW5kc1sxXSkge1xuICAgICAgICBpZiAocGluLmluZGV4T2YoJ3RvcCcpID49IDApIHtcbiAgICAgICAgICB0b3AgPSBib3VuZHNbMV07XG4gICAgICAgICAgcGlubmVkLnB1c2goJ3RvcCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9vYi5wdXNoKCd0b3AnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodG9wICsgaGVpZ2h0ID4gYm91bmRzWzNdKSB7XG4gICAgICAgIGlmIChwaW4uaW5kZXhPZignYm90dG9tJykgPj0gMCkge1xuICAgICAgICAgIHRvcCA9IGJvdW5kc1szXSAtIGhlaWdodDtcbiAgICAgICAgICBwaW5uZWQucHVzaCgnYm90dG9tJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb29iLnB1c2goJ2JvdHRvbScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsZWZ0IDwgYm91bmRzWzBdKSB7XG4gICAgICAgIGlmIChwaW4uaW5kZXhPZignbGVmdCcpID49IDApIHtcbiAgICAgICAgICBsZWZ0ID0gYm91bmRzWzBdO1xuICAgICAgICAgIHBpbm5lZC5wdXNoKCdsZWZ0Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb29iLnB1c2goJ2xlZnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGVmdCArIHdpZHRoID4gYm91bmRzWzJdKSB7XG4gICAgICAgIGlmIChwaW4uaW5kZXhPZigncmlnaHQnKSA+PSAwKSB7XG4gICAgICAgICAgbGVmdCA9IGJvdW5kc1syXSAtIHdpZHRoO1xuICAgICAgICAgIHBpbm5lZC5wdXNoKCdyaWdodCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9vYi5wdXNoKCdyaWdodCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwaW5uZWQubGVuZ3RoKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHBpbm5lZENsYXNzID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMub3B0aW9ucy5waW5uZWRDbGFzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBpbm5lZENsYXNzID0gX3RoaXMub3B0aW9ucy5waW5uZWRDbGFzcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGlubmVkQ2xhc3MgPSBfdGhpcy5nZXRDbGFzcygncGlubmVkJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWRkQ2xhc3Nlcy5wdXNoKHBpbm5lZENsYXNzKTtcbiAgICAgICAgICBwaW5uZWQuZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgICAgICAgYWRkQ2xhc3Nlcy5wdXNoKHBpbm5lZENsYXNzICsgJy0nICsgc2lkZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvb2IubGVuZ3RoKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG9vYkNsYXNzID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMub3B0aW9ucy5vdXRPZkJvdW5kc0NsYXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgb29iQ2xhc3MgPSBfdGhpcy5vcHRpb25zLm91dE9mQm91bmRzQ2xhc3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9vYkNsYXNzID0gX3RoaXMuZ2V0Q2xhc3MoJ291dC1vZi1ib3VuZHMnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhZGRDbGFzc2VzLnB1c2gob29iQ2xhc3MpO1xuICAgICAgICAgIG9vYi5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICAgICAgICBhZGRDbGFzc2VzLnB1c2gob29iQ2xhc3MgKyAnLScgKyBzaWRlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBpbm5lZC5pbmRleE9mKCdsZWZ0JykgPj0gMCB8fCBwaW5uZWQuaW5kZXhPZigncmlnaHQnKSA+PSAwKSB7XG4gICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSB0QXR0YWNobWVudC5sZWZ0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAocGlubmVkLmluZGV4T2YoJ3RvcCcpID49IDAgfHwgcGlubmVkLmluZGV4T2YoJ2JvdHRvbScpID49IDApIHtcbiAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gdEF0dGFjaG1lbnQudG9wID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0QXR0YWNobWVudC50b3AgIT09IHRhcmdldEF0dGFjaG1lbnQudG9wIHx8IHRBdHRhY2htZW50LmxlZnQgIT09IHRhcmdldEF0dGFjaG1lbnQubGVmdCB8fCBlQXR0YWNobWVudC50b3AgIT09IF90aGlzLmF0dGFjaG1lbnQudG9wIHx8IGVBdHRhY2htZW50LmxlZnQgIT09IF90aGlzLmF0dGFjaG1lbnQubGVmdCkge1xuICAgICAgICBfdGhpcy51cGRhdGVBdHRhY2hDbGFzc2VzKGVBdHRhY2htZW50LCB0QXR0YWNobWVudCk7XG4gICAgICAgIF90aGlzLnRyaWdnZXIoJ3VwZGF0ZScsIHtcbiAgICAgICAgICBhdHRhY2htZW50OiBlQXR0YWNobWVudCxcbiAgICAgICAgICB0YXJnZXRBdHRhY2htZW50OiB0QXR0YWNobWVudFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghKF90aGlzLm9wdGlvbnMuYWRkVGFyZ2V0Q2xhc3NlcyA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHVwZGF0ZUNsYXNzZXMoX3RoaXMudGFyZ2V0LCBhZGRDbGFzc2VzLCBhbGxDbGFzc2VzKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZUNsYXNzZXMoX3RoaXMuZWxlbWVudCwgYWRkQ2xhc3NlcywgYWxsQ2xhc3Nlcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9O1xuICB9XG59KTtcbi8qIGdsb2JhbHMgVGV0aGVyQmFzZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfVGV0aGVyQmFzZSRVdGlscyA9IFRldGhlckJhc2UuVXRpbHM7XG52YXIgZ2V0Qm91bmRzID0gX1RldGhlckJhc2UkVXRpbHMuZ2V0Qm91bmRzO1xudmFyIHVwZGF0ZUNsYXNzZXMgPSBfVGV0aGVyQmFzZSRVdGlscy51cGRhdGVDbGFzc2VzO1xudmFyIGRlZmVyID0gX1RldGhlckJhc2UkVXRpbHMuZGVmZXI7XG5cblRldGhlckJhc2UubW9kdWxlcy5wdXNoKHtcbiAgcG9zaXRpb246IGZ1bmN0aW9uIHBvc2l0aW9uKF9yZWYpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHRvcCA9IF9yZWYudG9wO1xuICAgIHZhciBsZWZ0ID0gX3JlZi5sZWZ0O1xuXG4gICAgdmFyIF9jYWNoZSA9IHRoaXMuY2FjaGUoJ2VsZW1lbnQtYm91bmRzJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldEJvdW5kcyhfdGhpcy5lbGVtZW50KTtcbiAgICB9KTtcblxuICAgIHZhciBoZWlnaHQgPSBfY2FjaGUuaGVpZ2h0O1xuICAgIHZhciB3aWR0aCA9IF9jYWNoZS53aWR0aDtcblxuICAgIHZhciB0YXJnZXRQb3MgPSB0aGlzLmdldFRhcmdldEJvdW5kcygpO1xuXG4gICAgdmFyIGJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XG5cbiAgICB2YXIgYWJ1dHRlZCA9IFtdO1xuICAgIGlmICh0b3AgPD0gdGFyZ2V0UG9zLmJvdHRvbSAmJiBib3R0b20gPj0gdGFyZ2V0UG9zLnRvcCkge1xuICAgICAgWydsZWZ0JywgJ3JpZ2h0J10uZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgICB2YXIgdGFyZ2V0UG9zU2lkZSA9IHRhcmdldFBvc1tzaWRlXTtcbiAgICAgICAgaWYgKHRhcmdldFBvc1NpZGUgPT09IGxlZnQgfHwgdGFyZ2V0UG9zU2lkZSA9PT0gcmlnaHQpIHtcbiAgICAgICAgICBhYnV0dGVkLnB1c2goc2lkZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChsZWZ0IDw9IHRhcmdldFBvcy5yaWdodCAmJiByaWdodCA+PSB0YXJnZXRQb3MubGVmdCkge1xuICAgICAgWyd0b3AnLCAnYm90dG9tJ10uZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgICB2YXIgdGFyZ2V0UG9zU2lkZSA9IHRhcmdldFBvc1tzaWRlXTtcbiAgICAgICAgaWYgKHRhcmdldFBvc1NpZGUgPT09IHRvcCB8fCB0YXJnZXRQb3NTaWRlID09PSBib3R0b20pIHtcbiAgICAgICAgICBhYnV0dGVkLnB1c2goc2lkZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBhbGxDbGFzc2VzID0gW107XG4gICAgdmFyIGFkZENsYXNzZXMgPSBbXTtcblxuICAgIHZhciBzaWRlcyA9IFsnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJ107XG4gICAgYWxsQ2xhc3Nlcy5wdXNoKHRoaXMuZ2V0Q2xhc3MoJ2FidXR0ZWQnKSk7XG4gICAgc2lkZXMuZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgYWxsQ2xhc3Nlcy5wdXNoKF90aGlzLmdldENsYXNzKCdhYnV0dGVkJykgKyAnLScgKyBzaWRlKTtcbiAgICB9KTtcblxuICAgIGlmIChhYnV0dGVkLmxlbmd0aCkge1xuICAgICAgYWRkQ2xhc3Nlcy5wdXNoKHRoaXMuZ2V0Q2xhc3MoJ2FidXR0ZWQnKSk7XG4gICAgfVxuXG4gICAgYWJ1dHRlZC5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICBhZGRDbGFzc2VzLnB1c2goX3RoaXMuZ2V0Q2xhc3MoJ2FidXR0ZWQnKSArICctJyArIHNpZGUpO1xuICAgIH0pO1xuXG4gICAgZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCEoX3RoaXMub3B0aW9ucy5hZGRUYXJnZXRDbGFzc2VzID09PSBmYWxzZSkpIHtcbiAgICAgICAgdXBkYXRlQ2xhc3NlcyhfdGhpcy50YXJnZXQsIGFkZENsYXNzZXMsIGFsbENsYXNzZXMpO1xuICAgICAgfVxuICAgICAgdXBkYXRlQ2xhc3NlcyhfdGhpcy5lbGVtZW50LCBhZGRDbGFzc2VzLCBhbGxDbGFzc2VzKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59KTtcbi8qIGdsb2JhbHMgVGV0aGVyQmFzZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pWydyZXR1cm4nXSkgX2lbJ3JldHVybiddKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UnKTsgfSB9OyB9KSgpO1xuXG5UZXRoZXJCYXNlLm1vZHVsZXMucHVzaCh7XG4gIHBvc2l0aW9uOiBmdW5jdGlvbiBwb3NpdGlvbihfcmVmKSB7XG4gICAgdmFyIHRvcCA9IF9yZWYudG9wO1xuICAgIHZhciBsZWZ0ID0gX3JlZi5sZWZ0O1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hpZnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2hpZnQgPSB0aGlzLm9wdGlvbnMuc2hpZnQ7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuc2hpZnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNoaWZ0ID0gdGhpcy5vcHRpb25zLnNoaWZ0LmNhbGwodGhpcywgeyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9KTtcbiAgICB9XG5cbiAgICB2YXIgc2hpZnRUb3AgPSB1bmRlZmluZWQsXG4gICAgICAgIHNoaWZ0TGVmdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIHNoaWZ0ID09PSAnc3RyaW5nJykge1xuICAgICAgc2hpZnQgPSBzaGlmdC5zcGxpdCgnICcpO1xuICAgICAgc2hpZnRbMV0gPSBzaGlmdFsxXSB8fCBzaGlmdFswXTtcblxuICAgICAgdmFyIF9zaGlmdCA9IHNoaWZ0O1xuXG4gICAgICB2YXIgX3NoaWZ0MiA9IF9zbGljZWRUb0FycmF5KF9zaGlmdCwgMik7XG5cbiAgICAgIHNoaWZ0VG9wID0gX3NoaWZ0MlswXTtcbiAgICAgIHNoaWZ0TGVmdCA9IF9zaGlmdDJbMV07XG5cbiAgICAgIHNoaWZ0VG9wID0gcGFyc2VGbG9hdChzaGlmdFRvcCwgMTApO1xuICAgICAgc2hpZnRMZWZ0ID0gcGFyc2VGbG9hdChzaGlmdExlZnQsIDEwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hpZnRUb3AgPSBzaGlmdC50b3A7XG4gICAgICBzaGlmdExlZnQgPSBzaGlmdC5sZWZ0O1xuICAgIH1cblxuICAgIHRvcCArPSBzaGlmdFRvcDtcbiAgICBsZWZ0ICs9IHNoaWZ0TGVmdDtcblxuICAgIHJldHVybiB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH07XG4gIH1cbn0pO1xucmV0dXJuIFRldGhlcjtcblxufSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdGV0aGVyL2Rpc3QvanMvdGV0aGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zYXNzL21haW4uc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbmltcG9ydCB7IENhbGlmb3JuaWFBcHAgfSBmcm9tIFwiLi9Nb2RlbHMvQ2FsaWZvcm5pYUFwcFwiO1xyXG5DYWxpZm9ybmlhQXBwLkNhbGlmb3JuaWFBcHBJbnN0YW5jZSA9IG5ldyBDYWxpZm9ybmlhQXBwKCk7XHJcblxyXG4vLyBUT0RPIHBvbHlmaWxsIGZvciBBcnJheS5maW5kIChpZXhwbG9yZTExKVxyXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxyXG5pZiAoIUFycmF5LnByb3RvdHlwZS5maW5kKSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXkucHJvdG90eXBlLCAnZmluZCcsIHtcclxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKHByZWRpY2F0ZTogYW55KSB7XHJcbiAgICAgICAvLyAxLiBMZXQgTyBiZSA/IFRvT2JqZWN0KHRoaXMgdmFsdWUpLlxyXG4gICAgICAgIGlmICh0aGlzID09IG51bGwpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widGhpc1wiIGlzIG51bGwgb3Igbm90IGRlZmluZWQnKTtcclxuICAgICAgICB9XHJcbiAgXHJcbiAgICAgICAgdmFyIG8gPSBPYmplY3QodGhpcyk7XHJcbiAgXHJcbiAgICAgICAgLy8gMi4gTGV0IGxlbiBiZSA/IFRvTGVuZ3RoKD8gR2V0KE8sIFwibGVuZ3RoXCIpKS5cclxuICAgICAgICB2YXIgbGVuID0gby5sZW5ndGggPj4+IDA7XHJcbiAgXHJcbiAgICAgICAgLy8gMy4gSWYgSXNDYWxsYWJsZShwcmVkaWNhdGUpIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXHJcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ByZWRpY2F0ZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcclxuICAgICAgICB9XHJcbiAgXHJcbiAgICAgICAgLy8gNC4gSWYgdGhpc0FyZyB3YXMgc3VwcGxpZWQsIGxldCBUIGJlIHRoaXNBcmc7IGVsc2UgbGV0IFQgYmUgdW5kZWZpbmVkLlxyXG4gICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xyXG4gIFxyXG4gICAgICAgIC8vIDUuIExldCBrIGJlIDAuXHJcbiAgICAgICAgdmFyIGsgPSAwO1xyXG4gIFxyXG4gICAgICAgIC8vIDYuIFJlcGVhdCwgd2hpbGUgayA8IGxlblxyXG4gICAgICAgIHdoaWxlIChrIDwgbGVuKSB7XHJcbiAgICAgICAgICAvLyBhLiBMZXQgUGsgYmUgISBUb1N0cmluZyhrKS5cclxuICAgICAgICAgIC8vIGIuIExldCBrVmFsdWUgYmUgPyBHZXQoTywgUGspLlxyXG4gICAgICAgICAgLy8gYy4gTGV0IHRlc3RSZXN1bHQgYmUgVG9Cb29sZWFuKD8gQ2FsbChwcmVkaWNhdGUsIFQsIMKrIGtWYWx1ZSwgaywgTyDCuykpLlxyXG4gICAgICAgICAgLy8gZC4gSWYgdGVzdFJlc3VsdCBpcyB0cnVlLCByZXR1cm4ga1ZhbHVlLlxyXG4gICAgICAgICAgdmFyIGtWYWx1ZSA9IG9ba107XHJcbiAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywga1ZhbHVlLCBrLCBvKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ga1ZhbHVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gZS4gSW5jcmVhc2UgayBieSAxLlxyXG4gICAgICAgICAgaysrO1xyXG4gICAgICAgIH1cclxuICBcclxuICAgICAgICAvLyA3LiBSZXR1cm4gdW5kZWZpbmVkLlxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbi8vIFRPRE8gcG9seWZpbGwgZm9yIEFycmF5LmZpbmRJbmRleCAoaWV4cGxvcmUxMSlcclxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRJbmRleFxyXG5pZiAoIUFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpIHtcclxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXkucHJvdG90eXBlLCAnZmluZEluZGV4Jywge1xyXG4gICAgdmFsdWU6IGZ1bmN0aW9uKHByZWRpY2F0ZTogYW55KSB7XHJcbiAgICAgLy8gMS4gTGV0IE8gYmUgPyBUb09iamVjdCh0aGlzIHZhbHVlKS5cclxuICAgICAgaWYgKHRoaXMgPT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widGhpc1wiIGlzIG51bGwgb3Igbm90IGRlZmluZWQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIG8gPSBPYmplY3QodGhpcyk7XHJcblxyXG4gICAgICAvLyAyLiBMZXQgbGVuIGJlID8gVG9MZW5ndGgoPyBHZXQoTywgXCJsZW5ndGhcIikpLlxyXG4gICAgICB2YXIgbGVuID0gby5sZW5ndGggPj4+IDA7XHJcblxyXG4gICAgICAvLyAzLiBJZiBJc0NhbGxhYmxlKHByZWRpY2F0ZSkgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cclxuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcmVkaWNhdGUgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIDQuIElmIHRoaXNBcmcgd2FzIHN1cHBsaWVkLCBsZXQgVCBiZSB0aGlzQXJnOyBlbHNlIGxldCBUIGJlIHVuZGVmaW5lZC5cclxuICAgICAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHNbMV07XHJcblxyXG4gICAgICAvLyA1LiBMZXQgayBiZSAwLlxyXG4gICAgICB2YXIgayA9IDA7XHJcblxyXG4gICAgICAvLyA2LiBSZXBlYXQsIHdoaWxlIGsgPCBsZW5cclxuICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcclxuICAgICAgICAvLyBhLiBMZXQgUGsgYmUgISBUb1N0cmluZyhrKS5cclxuICAgICAgICAvLyBiLiBMZXQga1ZhbHVlIGJlID8gR2V0KE8sIFBrKS5cclxuICAgICAgICAvLyBjLiBMZXQgdGVzdFJlc3VsdCBiZSBUb0Jvb2xlYW4oPyBDYWxsKHByZWRpY2F0ZSwgVCwgwqsga1ZhbHVlLCBrLCBPIMK7KSkuXHJcbiAgICAgICAgLy8gZC4gSWYgdGVzdFJlc3VsdCBpcyB0cnVlLCByZXR1cm4gay5cclxuICAgICAgICB2YXIga1ZhbHVlID0gb1trXTtcclxuICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywga1ZhbHVlLCBrLCBvKSkge1xyXG4gICAgICAgICAgcmV0dXJuIGs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGUuIEluY3JlYXNlIGsgYnkgMS5cclxuICAgICAgICBrKys7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIDcuIFJldHVybiAtMS5cclxuICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2l0ZS50c3giLCJcclxuXHJcbi8vLzxyZWZlcmVuY2UgdHlwZXM9XCJqcXVlcnlcIiAvPlxuaW1wb3J0ICogYXMgaGVscGVycyBmcm9tIFwiLi90c2dlbkhlbHBlcnNcIjsgXHJcbmltcG9ydCB7IENhbGlmb3JuaWFBcHAgfSBmcm9tIFwiLi8uLi9Nb2RlbHMvQ2FsaWZvcm5pYUFwcFwiO1xyXG5sZXQgY3VycmVudEFwcDogQ2FsaWZvcm5pYUFwcDtcclxuZXhwb3J0IGNsYXNzIENhbGlmb3JuaWFDb250cm9sbGVyIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcihjYWxpZm9ybmlhQXBwQXJnOiBDYWxpZm9ybmlhQXBwKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAgPSBjYWxpZm9ybmlhQXBwQXJnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgYmVmb3JlU2VuZEFqYXggPSAoanFYSFI6IEpRdWVyeVhIUiwgc2V0dGluZ3M6IGFueSk6IGZhbHNlIHwgdm9pZCA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50QXBwLmlzQWpheFJlcXVlc3RSdW5uaW5nID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImlnbm9yZWQgcmVxdWVzdCAoYWpheCBjYWxsIHN0aWxsIGluIHByb2dyZXNzKVwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50QXBwLmlzQWpheFJlcXVlc3RSdW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAganFYSFIuZG9uZSh4aHIgPT4ge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEFwcC5pc0FqYXhSZXF1ZXN0UnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9KS5mYWlsKHhociA9PiB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QXBwLmlzQWpheFJlcXVlc3RSdW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnByb2plY3Rvci5zY2hlZHVsZVJlbmRlcigpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHB1YmxpYyBMb2dvdXRBY3Rpb24gPSAoKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkFjdGlvbihgL2NhbGlmb3JuaWEvTG9nb3V0YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgSW5kZXhBY3Rpb24gPSAoaWQ6IHN0cmluZywgdG9rZW46IHN0cmluZykgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5BY3Rpb24oYC9jYWxpZm9ybmlhL0luZGV4JHtlbmNvZGVVUklDb21wb25lbnQoaWQpfT90b2tlbj0ke2VuY29kZVVSSUNvbXBvbmVudCh0b2tlbil9YCwgXCJnZXRcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBEZWxldGVMYXlvdXRTdHlsZUludGVyYWN0aW9uSnNvbiA9IChsYXlvdXRTdHlsZUludGVyYWN0aW9uSWQ6IG51bWJlciB8IHVuZGVmaW5lZCkgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5Kc29uKGAvY2FsaWZvcm5pYS9EZWxldGVMYXlvdXRTdHlsZUludGVyYWN0aW9uP2xheW91dFN0eWxlSW50ZXJhY3Rpb25JZD0ke2xheW91dFN0eWxlSW50ZXJhY3Rpb25JZH1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBEZWxldGVTdHlsZVZhbHVlSW50ZXJhY3Rpb25Kc29uID0gKGxheW91dFN0eWxlSW50ZXJhY3Rpb25JZDogbnVtYmVyIHwgdW5kZWZpbmVkLCBzdHlsZVZhbHVlSWQ6IG51bWJlciB8IHVuZGVmaW5lZCkgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5Kc29uKGAvY2FsaWZvcm5pYS9EZWxldGVTdHlsZVZhbHVlSW50ZXJhY3Rpb24/bGF5b3V0U3R5bGVJbnRlcmFjdGlvbklkPSR7bGF5b3V0U3R5bGVJbnRlcmFjdGlvbklkfSZzdHlsZVZhbHVlSWQ9JHtzdHlsZVZhbHVlSWR9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgQ3JlYXRlTGF5b3V0U3R5bGVJbnRlcmFjdGlvbkZvckxheW91dEF0b21Kc29uID0gKGxheW91dEF0b21JZDogbnVtYmVyIHwgdW5kZWZpbmVkKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL0NyZWF0ZUxheW91dFN0eWxlSW50ZXJhY3Rpb25Gb3JMYXlvdXRBdG9tP2xheW91dEF0b21JZD0ke2xheW91dEF0b21JZH1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBTdGF0aWNDc3NBY3Rpb24gPSAoKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkFjdGlvbihgL2NhbGlmb3JuaWEvU3RhdGljQ3NzYCwgXCJnZXRcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBTdGF0aWNKc0FjdGlvbiA9ICgpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuQWN0aW9uKGAvY2FsaWZvcm5pYS9TdGF0aWNKc2AsIFwiZ2V0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgcHViQWN0aW9uID0gKHZpZXc6IHN0cmluZywgaWQ6IHN0cmluZykgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5BY3Rpb24oYC9jYWxpZm9ybmlhL3B1YiR7ZW5jb2RlVVJJQ29tcG9uZW50KGlkKX0/dmlldz0ke2VuY29kZVVSSUNvbXBvbmVudCh2aWV3KX1gLCBcImdldFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIFB1Ymxpc2hBY3Rpb24gPSAoY2FsaWZvcm5pYVByb2plY3RJZDogbnVtYmVyIHwgdW5kZWZpbmVkKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkFjdGlvbihgL2NhbGlmb3JuaWEvUHVibGlzaD9jYWxpZm9ybmlhUHJvamVjdElkPSR7Y2FsaWZvcm5pYVByb2plY3RJZH1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBJbml0aWFsQ2xpZW50RGF0YUpzb24gPSAoanNUaW1lU3RyaW5nOiBzdHJpbmcpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvSW5pdGlhbENsaWVudERhdGE/anNUaW1lU3RyaW5nPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGpzVGltZVN0cmluZyl9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgU2V0U3BlY2lhbExheW91dEJveFR5cGVKc29uID0gKGxheW91dEJveElkOiBudW1iZXIgfCB1bmRlZmluZWQsIHNwZWNpYWxMYXlvdXRCb3hUeXBlOiBudW1iZXIgfCB1bmRlZmluZWQpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvU2V0U3BlY2lhbExheW91dEJveFR5cGU/bGF5b3V0Qm94SWQ9JHtsYXlvdXRCb3hJZH0mc3BlY2lhbExheW91dEJveFR5cGU9JHtzcGVjaWFsTGF5b3V0Qm94VHlwZX1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBEZWxldGVTdHlsZVF1YW50dW1Kc29uID0gKHN0eWxlUXVhbnR1bUlkOiBudW1iZXIgfCB1bmRlZmluZWQpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvRGVsZXRlU3R5bGVRdWFudHVtP3N0eWxlUXVhbnR1bUlkPSR7c3R5bGVRdWFudHVtSWR9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgRGVsZXRlTGF5b3V0SnNvbiA9IChsYXlvdXRCYXNlSWQ6IG51bWJlciB8IHVuZGVmaW5lZCwgaXNPbmx5QmVsb3c6IGJvb2xlYW4pIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvRGVsZXRlTGF5b3V0P2xheW91dEJhc2VJZD0ke2xheW91dEJhc2VJZH0maXNPbmx5QmVsb3c9JHtpc09ubHlCZWxvd31gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBTZXRTdHlsZU1vbGVjdWxlQXNSZWZlcmVuY2VTdHlsZUpzb24gPSAoc3R5bGVNb2xlY3VsZUlkOiBudW1iZXIgfCB1bmRlZmluZWQpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvU2V0U3R5bGVNb2xlY3VsZUFzUmVmZXJlbmNlU3R5bGU/c3R5bGVNb2xlY3VsZUlkPSR7c3R5bGVNb2xlY3VsZUlkfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIFNldFN0eWxlTW9sZWN1bGVSZWZlcmVuY2VKc29uID0gKHN0eWxlTW9sZWN1bGVJZDogbnVtYmVyIHwgdW5kZWZpbmVkLCByZWZlcmVuY2VTdHlsZU1vbGVjdWxlSWQ6IG51bWJlciB8IHVuZGVmaW5lZCkgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5Kc29uKGAvY2FsaWZvcm5pYS9TZXRTdHlsZU1vbGVjdWxlUmVmZXJlbmNlP3N0eWxlTW9sZWN1bGVJZD0ke3N0eWxlTW9sZWN1bGVJZH0mcmVmZXJlbmNlU3R5bGVNb2xlY3VsZUlkPSR7cmVmZXJlbmNlU3R5bGVNb2xlY3VsZUlkfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIFN5bmNTdHlsZU1vbGVjdWxlVG9SZWZlcmVuY2VTdHlsZUpzb24gPSAoc3R5bGVNb2xlY3VsZUlkOiBudW1iZXIgfCB1bmRlZmluZWQpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvU3luY1N0eWxlTW9sZWN1bGVUb1JlZmVyZW5jZVN0eWxlP3N0eWxlTW9sZWN1bGVJZD0ke3N0eWxlTW9sZWN1bGVJZH1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBTeW5jU3R5bGVNb2xlY3VsZUZyb21SZWZlcmVuY2VTdHlsZUpzb24gPSAoc3R5bGVNb2xlY3VsZUlkOiBudW1iZXIgfCB1bmRlZmluZWQpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvU3luY1N0eWxlTW9sZWN1bGVGcm9tUmVmZXJlbmNlU3R5bGU/c3R5bGVNb2xlY3VsZUlkPSR7c3R5bGVNb2xlY3VsZUlkfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIFN5bmNMYXlvdXRTdHlsZXNJbWl0YXRpbmdSZWZlcmVuY2VMYXlvdXRKc29uID0gKHRhcmdldExheW91dE1vbGVjdWxlSWQ6IG51bWJlciB8IHVuZGVmaW5lZCwgcmVmZXJlbmNlTGF5b3V0TW9sZWN1bGVJZDogbnVtYmVyIHwgdW5kZWZpbmVkKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL1N5bmNMYXlvdXRTdHlsZXNJbWl0YXRpbmdSZWZlcmVuY2VMYXlvdXQ/dGFyZ2V0TGF5b3V0TW9sZWN1bGVJZD0ke3RhcmdldExheW91dE1vbGVjdWxlSWR9JnJlZmVyZW5jZUxheW91dE1vbGVjdWxlSWQ9JHtyZWZlcmVuY2VMYXlvdXRNb2xlY3VsZUlkfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIFNldExheW91dEJveENvdW50Rm9yUm93T3JCb3hKc29uID0gKGxheW91dFJvd0lkOiBudW1iZXIgfCB1bmRlZmluZWQsIGJveFN0eWxlTW9sZWN1bGVJZDogbnVtYmVyIHwgdW5kZWZpbmVkLCB0YXJnZXRCb3hDb3VudDogbnVtYmVyIHwgdW5kZWZpbmVkLCBpc0ZpdFdpZHRoOiBib29sZWFuKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL1NldExheW91dEJveENvdW50Rm9yUm93T3JCb3g/bGF5b3V0Um93SWQ9JHtsYXlvdXRSb3dJZH0mYm94U3R5bGVNb2xlY3VsZUlkPSR7Ym94U3R5bGVNb2xlY3VsZUlkfSZ0YXJnZXRCb3hDb3VudD0ke3RhcmdldEJveENvdW50fSZpc0ZpdFdpZHRoPSR7aXNGaXRXaWR0aH1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBDcmVhdGVTdHlsZVZhbHVlRm9yQXRvbUpzb24gPSAoc3R5bGVBdG9tSWQ6IG51bWJlciB8IHVuZGVmaW5lZCwgY3NzUHJvcGVydHk6IHN0cmluZykgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5Kc29uKGAvY2FsaWZvcm5pYS9DcmVhdGVTdHlsZVZhbHVlRm9yQXRvbT9zdHlsZUF0b21JZD0ke3N0eWxlQXRvbUlkfSZjc3NQcm9wZXJ0eT0ke2VuY29kZVVSSUNvbXBvbmVudChjc3NQcm9wZXJ0eSl9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgQ3JlYXRlQ2FsaWZvcm5pYVZpZXdKc29uID0gKGNhbGlmb3JuaWFQcm9qZWN0SWQ6IG51bWJlciB8IHVuZGVmaW5lZCwgY2FsaWZvcm5pYVZpZXdOYW1lOiBzdHJpbmcpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvQ3JlYXRlQ2FsaWZvcm5pYVZpZXc/Y2FsaWZvcm5pYVByb2plY3RJZD0ke2NhbGlmb3JuaWFQcm9qZWN0SWR9JmNhbGlmb3JuaWFWaWV3TmFtZT0ke2VuY29kZVVSSUNvbXBvbmVudChjYWxpZm9ybmlhVmlld05hbWUpfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIENyZWF0ZUNhbGlmb3JuaWFWaWV3RnJvbVJlZmVyZW5jZVZpZXdKc29uID0gKGNhbGlmb3JuaWFQcm9qZWN0SWQ6IG51bWJlciB8IHVuZGVmaW5lZCwgY2FsaWZvcm5pYVZpZXdOYW1lOiBzdHJpbmcsIHJlZmVyZW5jZUNhbGlmb3JuaWFWaWV3SWQ6IG51bWJlciB8IHVuZGVmaW5lZCkgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5Kc29uKGAvY2FsaWZvcm5pYS9DcmVhdGVDYWxpZm9ybmlhVmlld0Zyb21SZWZlcmVuY2VWaWV3P2NhbGlmb3JuaWFQcm9qZWN0SWQ9JHtjYWxpZm9ybmlhUHJvamVjdElkfSZjYWxpZm9ybmlhVmlld05hbWU9JHtlbmNvZGVVUklDb21wb25lbnQoY2FsaWZvcm5pYVZpZXdOYW1lKX0mcmVmZXJlbmNlQ2FsaWZvcm5pYVZpZXdJZD0ke3JlZmVyZW5jZUNhbGlmb3JuaWFWaWV3SWR9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgRGVsZXRlQ2FsaWZvcm5pYVZpZXdKc29uID0gKGNhbGlmb3JuaWFWaWV3SWQ6IG51bWJlciB8IHVuZGVmaW5lZCkgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5Kc29uKGAvY2FsaWZvcm5pYS9EZWxldGVDYWxpZm9ybmlhVmlldz9jYWxpZm9ybmlhVmlld0lkPSR7Y2FsaWZvcm5pYVZpZXdJZH1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBDcmVhdGVTdHlsZVZhbHVlSW50ZXJhY3Rpb25Kc29uID0gKGxheW91dFN0eWxlSW50ZXJhY3Rpb25JZDogbnVtYmVyIHwgdW5kZWZpbmVkLCBzdHlsZVZhbHVlSWQ6IG51bWJlciB8IHVuZGVmaW5lZCwgY3NzVmFsdWU6IHN0cmluZykgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5Kc29uKGAvY2FsaWZvcm5pYS9DcmVhdGVTdHlsZVZhbHVlSW50ZXJhY3Rpb24/bGF5b3V0U3R5bGVJbnRlcmFjdGlvbklkPSR7bGF5b3V0U3R5bGVJbnRlcmFjdGlvbklkfSZzdHlsZVZhbHVlSWQ9JHtzdHlsZVZhbHVlSWR9JmNzc1ZhbHVlPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGNzc1ZhbHVlKX1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBDcmVhdGVTdHlsZUF0b21Gb3JNb2xlY3VsZUpzb24gPSAoc3R5bGVNb2xlY3VsZUlkOiBudW1iZXIgfCB1bmRlZmluZWQsIHN0eWxlQXRvbVR5cGU6IG51bWJlciB8IHVuZGVmaW5lZCwgcmVzcG9uc2l2ZURldmljZUlkOiBudW1iZXIgfCB1bmRlZmluZWQsIHN0YXRlTW9kaWZpZXI6IHN0cmluZykgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5Kc29uKGAvY2FsaWZvcm5pYS9DcmVhdGVTdHlsZUF0b21Gb3JNb2xlY3VsZT9zdHlsZU1vbGVjdWxlSWQ9JHtzdHlsZU1vbGVjdWxlSWR9JnN0eWxlQXRvbVR5cGU9JHtzdHlsZUF0b21UeXBlfSZyZXNwb25zaXZlRGV2aWNlSWQ9JHtyZXNwb25zaXZlRGV2aWNlSWR9JnN0YXRlTW9kaWZpZXI9JHtlbmNvZGVVUklDb21wb25lbnQoc3RhdGVNb2RpZmllcil9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgRGVsZXRlU3R5bGVBdG9tSnNvbiA9IChzdHlsZUF0b21JZDogbnVtYmVyIHwgdW5kZWZpbmVkKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL0RlbGV0ZVN0eWxlQXRvbT9zdHlsZUF0b21JZD0ke3N0eWxlQXRvbUlkfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIEFwcGx5U3R5bGVRdWFudHVtVG9BdG9tSnNvbiA9IChzdHlsZUF0b21JZDogbnVtYmVyIHwgdW5kZWZpbmVkLCBzdHlsZVF1YW50dW1JZDogbnVtYmVyIHwgdW5kZWZpbmVkKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL0FwcGx5U3R5bGVRdWFudHVtVG9BdG9tP3N0eWxlQXRvbUlkPSR7c3R5bGVBdG9tSWR9JnN0eWxlUXVhbnR1bUlkPSR7c3R5bGVRdWFudHVtSWR9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgQ3JlYXRlU3R5bGVRdWFudHVtSnNvbiA9IChjYWxpZm9ybmlhUHJvamVjdElkOiBudW1iZXIgfCB1bmRlZmluZWQsIHF1YW50dW1OYW1lOiBzdHJpbmcsIGNzc1Byb3BlcnR5OiBzdHJpbmcsIGNzc1ZhbHVlOiBzdHJpbmcpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvQ3JlYXRlU3R5bGVRdWFudHVtP2NhbGlmb3JuaWFQcm9qZWN0SWQ9JHtjYWxpZm9ybmlhUHJvamVjdElkfSZxdWFudHVtTmFtZT0ke2VuY29kZVVSSUNvbXBvbmVudChxdWFudHVtTmFtZSl9JmNzc1Byb3BlcnR5PSR7ZW5jb2RlVVJJQ29tcG9uZW50KGNzc1Byb3BlcnR5KX0mY3NzVmFsdWU9JHtlbmNvZGVVUklDb21wb25lbnQoY3NzVmFsdWUpfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIFVwZGF0ZVRleHRDb250ZW50QXRvbUpzb24gPSAoY29udGVudEF0b21JZDogbnVtYmVyIHwgdW5kZWZpbmVkLCB1cGRhdGVkVGV4dENvbnRlbnQ6IHN0cmluZykgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5Kc29uKGAvY2FsaWZvcm5pYS9VcGRhdGVUZXh0Q29udGVudEF0b20/Y29udGVudEF0b21JZD0ke2NvbnRlbnRBdG9tSWR9JnVwZGF0ZWRUZXh0Q29udGVudD0ke2VuY29kZVVSSUNvbXBvbmVudCh1cGRhdGVkVGV4dENvbnRlbnQpfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIFVwZGF0ZVN0eWxlUXVhbnR1bUpzb24gPSAoc3R5bGVRdWFudHVtSWQ6IG51bWJlciB8IHVuZGVmaW5lZCwgY3NzVmFsdWU6IHN0cmluZykgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5Kc29uKGAvY2FsaWZvcm5pYS9VcGRhdGVTdHlsZVF1YW50dW0/c3R5bGVRdWFudHVtSWQ9JHtzdHlsZVF1YW50dW1JZH0mY3NzVmFsdWU9JHtlbmNvZGVVUklDb21wb25lbnQoY3NzVmFsdWUpfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIFVwZGF0ZVN0eWxlVmFsdWVKc29uID0gKHN0eWxlVmFsdWVJZDogbnVtYmVyIHwgdW5kZWZpbmVkLCBjc3NWYWx1ZTogc3RyaW5nKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL1VwZGF0ZVN0eWxlVmFsdWU/c3R5bGVWYWx1ZUlkPSR7c3R5bGVWYWx1ZUlkfSZjc3NWYWx1ZT0ke2VuY29kZVVSSUNvbXBvbmVudChjc3NWYWx1ZSl9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgRGVsZXRlU3R5bGVWYWx1ZUpzb24gPSAoc3R5bGVWYWx1ZUlkOiBudW1iZXIgfCB1bmRlZmluZWQpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvRGVsZXRlU3R5bGVWYWx1ZT9zdHlsZVZhbHVlSWQ9JHtzdHlsZVZhbHVlSWR9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgRHVwbGljYXRlU3R5bGVRdWFudHVtSnNvbiA9IChzdHlsZVF1YW50dW1JZDogbnVtYmVyIHwgdW5kZWZpbmVkKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL0R1cGxpY2F0ZVN0eWxlUXVhbnR1bT9zdHlsZVF1YW50dW1JZD0ke3N0eWxlUXVhbnR1bUlkfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIENyZWF0ZUxheW91dEF0b21Gb3JCb3hKc29uID0gKHRhcmdldExheW91dEJveElkOiBudW1iZXIgfCB1bmRlZmluZWQsIHJlZmVyZW5jZUxheW91dEF0b21JZDogbnVtYmVyIHwgdW5kZWZpbmVkKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL0NyZWF0ZUxheW91dEF0b21Gb3JCb3g/dGFyZ2V0TGF5b3V0Qm94SWQ9JHt0YXJnZXRMYXlvdXRCb3hJZH0mcmVmZXJlbmNlTGF5b3V0QXRvbUlkPSR7cmVmZXJlbmNlTGF5b3V0QXRvbUlkfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIENyZWF0ZUxheW91dEJveEZvckJveE9yUm93SnNvbiA9ICh0YXJnZXRMYXlvdXRCb3hPclJvd0lkOiBudW1iZXIgfCB1bmRlZmluZWQsIHJlZmVyZW5jZUxheW91dEJveElkOiBudW1iZXIgfCB1bmRlZmluZWQpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvQ3JlYXRlTGF5b3V0Qm94Rm9yQm94T3JSb3c/dGFyZ2V0TGF5b3V0Qm94T3JSb3dJZD0ke3RhcmdldExheW91dEJveE9yUm93SWR9JnJlZmVyZW5jZUxheW91dEJveElkPSR7cmVmZXJlbmNlTGF5b3V0Qm94SWR9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgQ3JlYXRlTGF5b3V0Qm94Rm9yQXRvbUluUGxhY2VKc29uID0gKHRhcmdldExheW91dEF0b21JZDogbnVtYmVyIHwgdW5kZWZpbmVkLCByZWZlcmVuY2VMYXlvdXRCb3hJZDogbnVtYmVyIHwgdW5kZWZpbmVkKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL0NyZWF0ZUxheW91dEJveEZvckF0b21JblBsYWNlP3RhcmdldExheW91dEF0b21JZD0ke3RhcmdldExheW91dEF0b21JZH0mcmVmZXJlbmNlTGF5b3V0Qm94SWQ9JHtyZWZlcmVuY2VMYXlvdXRCb3hJZH1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBDcmVhdGVMYXlvdXRSb3dGb3JWaWV3SnNvbiA9ICh0YXJnZXRDYWxpZm9ybmlhVmlld0lkOiBudW1iZXIgfCB1bmRlZmluZWQsIHJlZmVyZW5jZUxheW91dFJvd0lkOiBudW1iZXIgfCB1bmRlZmluZWQpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvQ3JlYXRlTGF5b3V0Um93Rm9yVmlldz90YXJnZXRDYWxpZm9ybmlhVmlld0lkPSR7dGFyZ2V0Q2FsaWZvcm5pYVZpZXdJZH0mcmVmZXJlbmNlTGF5b3V0Um93SWQ9JHtyZWZlcmVuY2VMYXlvdXRSb3dJZH1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBTZXRMYXlvdXRSb3dPckJveEFzSW5zdGFuY2VhYmxlSnNvbiA9IChjYWxpZm9ybmlhUHJvamVjdElkOiBudW1iZXIgfCB1bmRlZmluZWQsIGxheW91dFJvd09yQm94SWQ6IG51bWJlciB8IHVuZGVmaW5lZCkgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5Kc29uKGAvY2FsaWZvcm5pYS9TZXRMYXlvdXRSb3dPckJveEFzSW5zdGFuY2VhYmxlP2NhbGlmb3JuaWFQcm9qZWN0SWQ9JHtjYWxpZm9ybmlhUHJvamVjdElkfSZsYXlvdXRSb3dPckJveElkPSR7bGF5b3V0Um93T3JCb3hJZH1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBNb3ZlU3R5bGVBdG9tVG9SZXNwb25zaXZlRGV2aWNlSnNvbiA9IChzdHlsZUF0b21JZDogbnVtYmVyIHwgdW5kZWZpbmVkLCB0YXJnZXRSZXNwb25zaXZlRGV2aWNlSWQ6IG51bWJlciB8IHVuZGVmaW5lZCkgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5Kc29uKGAvY2FsaWZvcm5pYS9Nb3ZlU3R5bGVBdG9tVG9SZXNwb25zaXZlRGV2aWNlP3N0eWxlQXRvbUlkPSR7c3R5bGVBdG9tSWR9JnRhcmdldFJlc3BvbnNpdmVEZXZpY2VJZD0ke3RhcmdldFJlc3BvbnNpdmVEZXZpY2VJZH1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBNb3ZlTGF5b3V0TW9sZWN1bGVJbnRvTGF5b3V0TW9sZWN1bGVKc29uID0gKG1vdmVkTGF5b3V0TW9sZWN1bGVJZDogbnVtYmVyIHwgdW5kZWZpbmVkLCB0YXJnZXRDb250YWluZXJMYXlvdXRNb2xlY3VsZUlkOiBudW1iZXIgfCB1bmRlZmluZWQpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvTW92ZUxheW91dE1vbGVjdWxlSW50b0xheW91dE1vbGVjdWxlP21vdmVkTGF5b3V0TW9sZWN1bGVJZD0ke21vdmVkTGF5b3V0TW9sZWN1bGVJZH0mdGFyZ2V0Q29udGFpbmVyTGF5b3V0TW9sZWN1bGVJZD0ke3RhcmdldENvbnRhaW5lckxheW91dE1vbGVjdWxlSWR9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgTW92ZUxheW91dE1vbGVjdWxlTmV4dFRvTGF5b3V0TW9sZWN1bGVKc29uID0gKG1vdmVkTGF5b3V0TW9sZWN1bGVJZDogbnVtYmVyIHwgdW5kZWZpbmVkLCB0YXJnZXROZWlnaGJvckxheW91dE1vbGVjdWxlSWQ6IG51bWJlciB8IHVuZGVmaW5lZCwgaXNNb3ZlQmVmb3JlOiBib29sZWFuKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL01vdmVMYXlvdXRNb2xlY3VsZU5leHRUb0xheW91dE1vbGVjdWxlP21vdmVkTGF5b3V0TW9sZWN1bGVJZD0ke21vdmVkTGF5b3V0TW9sZWN1bGVJZH0mdGFyZ2V0TmVpZ2hib3JMYXlvdXRNb2xlY3VsZUlkPSR7dGFyZ2V0TmVpZ2hib3JMYXlvdXRNb2xlY3VsZUlkfSZpc01vdmVCZWZvcmU9JHtpc01vdmVCZWZvcmV9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9UeXBld3JpdGVyL0NhbGlmb3JuaWFDb250cm9sbGVyLnRzIiwiLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJqcXVlcnlcIiAvPlxyXG5leHBvcnQgZnVuY3Rpb24gSnNvbih1cmw6IHN0cmluZywgbWV0aG9kOiBzdHJpbmcsIGRhdGE6IGFueSwgYmVmb3JlU2VuZENhbGxiYWNrOiBhbnkpOiBKUXVlcnlYSFIge1xyXG4gICAgLy8gVE9ETyBkb2VzIG5vdCB3b3JrIHJlbGlhYmx5OiBjYWNoZSBzZXQgdG8gZmFsc2UgZm9yIGFsbCBjb250cm9sbGVyIGFjdGlvbnMgYnkgZGVmYXVsdCAocmVhc29uOiBpcGFkIGJ1ZyB3aGVyZSBmdW5jdGlvbiB3YXMgaHR0cEdFVCBvcmlnaW5hbGx5IGFuZCBjYWNoZWQgcmVzcG9uc2Ugd2FzIHVzZWQgZm9yIHNhbWUgZnVuY3Rpb24gYXMgaHR0cFBPU1QpXHJcbiAgICBsZXQgcmVxdWVzdDogSlF1ZXJ5WEhSO1xyXG4gICAgaWYgKGRhdGEgIT09IG51bGwpIHtcclxuICAgICAgICByZXF1ZXN0ID0galF1ZXJ5LmFqYXgodXJsLCB7IG1ldGhvZDogbWV0aG9kLCBkYXRhOiBKU09OLnN0cmluZ2lmeShkYXRhKSwgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLCBiZWZvcmVTZW5kOiBiZWZvcmVTZW5kQ2FsbGJhY2sgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXF1ZXN0ID0galF1ZXJ5LmFqYXgodXJsLCB7IG1ldGhvZDogbWV0aG9kLCBiZWZvcmVTZW5kOiBiZWZvcmVTZW5kQ2FsbGJhY2sgfSk7XHJcbiAgICB9XHJcbiAgICByZXF1ZXN0LmZhaWwoKGRhdGE6IEpRdWVyeVhIUik6IHZvaWQgPT4ge1xyXG4gICAgICAgIGlmICgoZGF0YS5yZXNwb25zZUpTT04gIT09IHVuZGVmaW5lZCkgJiYgKGRhdGEucmVzcG9uc2VKU09OLlN0YXR1c1RleHQgIT09IHVuZGVmaW5lZCkpIC8vIFRPRE8gaXMgdGhpcyBzdGlsbCBjb3JyZWN0XHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhLnJlc3BvbnNlSlNPTi5TdGF0dXNUZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXF1ZXN0OyAvLyBUT0RPIG11bHRpcGxlIHF1ZXVlcywgcnVubmluZywgZG9uZSwgZmFpbCwgcmVzY2hlZHVsZTsgY29tcGFyZSByZXZpc2lvbiBhbmQgXHJcbiAgICAvLyBUT0RPIHBhdXNlIHdoZW4gZGV0ZWN0aW5nIGhvbGVzXHJcbn07XHJcbmV4cG9ydCBmdW5jdGlvbiBBY3Rpb24odXJsOiBzdHJpbmcsIG1ldGhvZDogc3RyaW5nLCBkYXRhOiBhbnksIGJlZm9yZVNlbmRDYWxsYmFjazogYW55KTogSlF1ZXJ5WEhSIHtcclxuICAgIC8vIFRPRE8gZG9lcyBub3Qgd29yayByZWxpYWJseTogY2FjaGUgc2V0IHRvIGZhbHNlIGZvciBhbGwgY29udHJvbGxlciBhY3Rpb25zIGJ5IGRlZmF1bHQgKHJlYXNvbjogaXBhZCBidWcgd2hlcmUgZnVuY3Rpb24gd2FzIGh0dHBHRVQgb3JpZ2luYWxseSBhbmQgY2FjaGVkIHJlc3BvbnNlIHdhcyB1c2VkIGZvciBzYW1lIGZ1bmN0aW9uIGFzIGh0dHBQT1NUKVxyXG4gICAgbGV0IHJlcXVlc3Q6IEpRdWVyeVhIUjtcclxuICAgIGlmIChkYXRhICE9PSBudWxsKSB7XHJcbiAgICAgICAgcmVxdWVzdCA9IGpRdWVyeS5hamF4KHVybCwgeyBtZXRob2Q6IG1ldGhvZCwgZGF0YTogSlNPTi5zdHJpbmdpZnkoZGF0YSksIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIiwgYmVmb3JlU2VuZDogYmVmb3JlU2VuZENhbGxiYWNrIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmVxdWVzdCA9IGpRdWVyeS5hamF4KHVybCwgeyBtZXRob2Q6IG1ldGhvZCwgYmVmb3JlU2VuZDogYmVmb3JlU2VuZENhbGxiYWNrIH0pO1xyXG4gICAgfVxyXG4gICAgcmVxdWVzdC5mYWlsKChkYXRhOiBKUXVlcnlYSFIpOiB2b2lkID0+IHtcclxuICAgICAgICBpZiAoZGF0YS5zdGF0dXNUZXh0ICE9PSB1bmRlZmluZWQpIHsgLy8gVE9ETyBpcyB0aGlzIHN0aWxsIGNvcnJlY3RcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YS5zdGF0dXNUZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXF1ZXN0O1xyXG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvdHNnZW5IZWxwZXJzLnRzIiwiXHJcblxyXG5leHBvcnQgZW51bSBDYWxpZm9ybmlhRXZlbnQge1xyXG4gICAgUmVhZEluaXRpYWxDbGllbnREYXRhID0gMCxcclxuICAgIENyZWF0ZVN0b3JlID0gMSxcclxuICAgIFJlYWRTdG9yZSA9IDIsXHJcbiAgICBDcmVhdGVTdHlsZVF1YW50dW0gPSAzLFxyXG4gICAgRHVwbGljYXRlU3R5bGVRdWFudHVtID0gNCxcclxuICAgIERlbGV0ZVN0eWxlUXVhbnR1bSA9IDUsXHJcbiAgICBEZWxldGVTdHlsZVZhbHVlID0gNixcclxuICAgIENyZWF0ZVN0eWxlVmFsdWVGb3JBdG9tID0gNyxcclxuICAgIFVwZGF0ZVN0eWxlVmFsdWUgPSA4LFxyXG4gICAgVXBkYXRlU3R5bGVRdWFudHVtID0gOSxcclxuICAgIEFwcGx5U3R5bGVRdWFudHVtVG9BdG9tID0gMTAsXHJcbiAgICBDcmVhdGVTdHlsZUF0b21Gb3JNb2xlY3VsZSA9IDExLFxyXG4gICAgRGVsZXRlU3R5bGVBdG9tID0gMTIsXHJcbiAgICBVcGRhdGVDb250ZW50QXRvbSA9IDEzLFxyXG4gICAgQ3JlYXRlTGF5b3V0QXRvbUZvckJveCA9IDE0LFxyXG4gICAgQ3JlYXRlTGF5b3V0Um93Rm9yVmlldyA9IDE1LFxyXG4gICAgRGVsZXRlTGF5b3V0ID0gMTYsXHJcbiAgICBTZXRCb3hDb3VudCA9IDE3LFxyXG4gICAgQ3JlYXRlTGF5b3V0Qm94Rm9yQm94T3JSb3cgPSAxOCxcclxuICAgIE1vdmVTdHlsZUF0b21Ub1Jlc3BvbnNpdmVEZXZpY2UgPSAxOSxcclxuICAgIFNldFN0eWxlTW9sZWN1bGVSZWZlcmVuY2UgPSAyMCxcclxuICAgIFNldFN0eWxlTW9sZWN1bGVBc1JlZmVyZW5jZSA9IDIxLFxyXG4gICAgU2V0TGF5b3V0TW9sZWN1bGVBc0luc3RhbmNlYWJsZSA9IDIyLFxyXG4gICAgU3luY1N0eWxlTW9sZWN1bGVUb1JlZmVyZW5jZSA9IDIzLFxyXG4gICAgU3luY1N0eWxlTW9sZWN1bGVGcm9tUmVmZXJlbmNlID0gMjQsXHJcbiAgICBNb3ZlTGF5b3V0TW9sZWN1bGVJbnRvTGF5b3V0TW9sZWN1bGUgPSAyNSxcclxuICAgIE1vdmVMYXlvdXRNb2xlY3VsZU5leHRUb0xheW91dE1vbGVjdWxlID0gMjYsXHJcbiAgICBQdWJsaXNoID0gMjcsXHJcbiAgICBWaWV3ID0gMjgsXHJcbiAgICBDcmVhdGVDYWxpZm9ybmlhVmlldyA9IDI5LFxyXG4gICAgRGVsZXRlQ2FsaWZvcm5pYVZpZXcgPSAzMCxcclxuICAgIENyZWF0ZUxheW91dFN0eWxlSW50ZXJhY3Rpb24gPSAzMSxcclxuICAgIENyZWF0ZVN0eWxlVmFsdWVJbnRlcmFjdGlvbiA9IDMyLFxyXG4gICAgRGVsZXRlTGF5b3V0U3R5bGVJbnRlcmFjdGlvbiA9IDMzLFxyXG4gICAgQ3JlYXRlTGF5b3V0Qm94Rm9yQXRvbUluUGxhY2UgPSAzNCxcclxuICAgIFN5bmNMYXlvdXRTdHlsZXNJbWl0YXRpbmdSZWZlcmVuY2UgPSAzNSxcclxuICAgIENyZWF0ZUNhbGlmb3JuaWFWaWV3RnJvbVJlZmVyZW5jZVZpZXcgPSAzNixcclxuICAgIERlbGV0ZVN0eWxlVmFsdWVJbnRlcmFjdGlvbiA9IDM3LFxyXG4gICAgU2V0U3BlY2lhbExheW91dEJveFR5cGUgPSAzOCxcclxuICAgIFZpZXdKcyA9IDM5LFxyXG4gICAgVmlld0NzcyA9IDQwLFxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vVHlwZXdyaXRlci9DYWxpZm9ybmlhRXZlbnQudHMiLCJcclxuXHJcbmltcG9ydCB7U3R5bGVRdWFudHVtfSBmcm9tIFwiLi9TdHlsZVF1YW50dW1cIjtcbmltcG9ydCB7U3R5bGVBdG9tfSBmcm9tIFwiLi9TdHlsZUF0b21cIjtcbmltcG9ydCB7U3R5bGVNb2xlY3VsZX0gZnJvbSBcIi4vU3R5bGVNb2xlY3VsZVwiO1xuaW1wb3J0IHtSZXNwb25zaXZlRGV2aWNlfSBmcm9tIFwiLi9SZXNwb25zaXZlRGV2aWNlXCI7XG5pbXBvcnQge0NvbnRlbnRBdG9tfSBmcm9tIFwiLi9Db250ZW50QXRvbVwiO1xuaW1wb3J0IHtQaWN0dXJlQ29udGVudH0gZnJvbSBcIi4vUGljdHVyZUNvbnRlbnRcIjtcbmltcG9ydCB7Q2FsaWZvcm5pYVZpZXd9IGZyb20gXCIuL0NhbGlmb3JuaWFWaWV3XCI7XG5pbXBvcnQge1NoYXJlZFByb2plY3RJbmZvfSBmcm9tIFwiLi9TaGFyZWRQcm9qZWN0SW5mb1wiO1xuaW1wb3J0IHtTdHlsZVZhbHVlfSBmcm9tIFwiLi9TdHlsZVZhbHVlXCI7XG5pbXBvcnQge0xheW91dEJhc2V9IGZyb20gXCIuL0xheW91dEJhc2VcIjtcbmltcG9ydCB7TGF5b3V0U3R5bGVJbnRlcmFjdGlvbn0gZnJvbSBcIi4vTGF5b3V0U3R5bGVJbnRlcmFjdGlvblwiOyBcclxuZXhwb3J0IGNsYXNzIENhbGlmb3JuaWFQcm9qZWN0IHsgXHJcbiAgICBDYWxpZm9ybmlhUHJvamVjdElkOiBudW1iZXI7XHJcbiAgICBOYW1lOiBzdHJpbmc7XHJcbiAgICBTdHlsZVZhbHVlczogU3R5bGVWYWx1ZVtdO1xyXG4gICAgU3R5bGVRdWFudHVtczogU3R5bGVRdWFudHVtW107XHJcbiAgICBTdHlsZUF0b21zOiBTdHlsZUF0b21bXTtcclxuICAgIFN0eWxlTW9sZWN1bGVzOiBTdHlsZU1vbGVjdWxlW107XHJcbiAgICBSZXNwb25zaXZlRGV2aWNlczogUmVzcG9uc2l2ZURldmljZVtdO1xyXG4gICAgTGF5b3V0TW9sZWN1bGVzOiBMYXlvdXRCYXNlW107XHJcbiAgICBMYXlvdXRTdHlsZUludGVyYWN0aW9uczogTGF5b3V0U3R5bGVJbnRlcmFjdGlvbltdO1xyXG4gICAgQ29udGVudEF0b21zOiBDb250ZW50QXRvbVtdO1xyXG4gICAgUGljdHVyZUNvbnRlbnRzOiBQaWN0dXJlQ29udGVudFtdO1xyXG4gICAgQ2FsaWZvcm5pYVZpZXdzOiBDYWxpZm9ybmlhVmlld1tdO1xyXG4gICAgU2hhcmVkUHJvamVjdEluZm9zOiBTaGFyZWRQcm9qZWN0SW5mb1tdO1xyXG4gICAgUHJvamVjdERlZmF1bHRzUmV2aXNpb246IG51bWJlcjtcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvQ2FsaWZvcm5pYVByb2plY3QudHMiLCJcclxuXHJcbmludGVyZmFjZSBDYWxpZm9ybmlhU3RvcmUgeyBDYWxpZm9ybmlhU3RvcmVJZDogc3RyaW5nOyB9XG4gXHJcbmV4cG9ydCBjbGFzcyBDYWxpZm9ybmlhVXNlckRlZmF1bHRzIHsgXHJcbiAgICBDYWxpZm9ybmlhVXNlckRlZmF1bHRzSWQ6IG51bWJlcjtcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvQ2FsaWZvcm5pYVVzZXJEZWZhdWx0cy50cyIsIlxyXG5cclxuaW1wb3J0IHtDYWxpZm9ybmlhUHJvamVjdH0gZnJvbSBcIi4vQ2FsaWZvcm5pYVByb2plY3RcIjtcbmltcG9ydCB7U3R5bGVRdWFudHVtfSBmcm9tIFwiLi9TdHlsZVF1YW50dW1cIjtcbmltcG9ydCB7Q2FsaWZvcm5pYUNsaWVudFBhcnRpYWxEYXRhfSBmcm9tIFwiLi9DYWxpZm9ybmlhQ2xpZW50UGFydGlhbERhdGFcIjsgXHJcbmV4cG9ydCBjbGFzcyBDYWxpZm9ybmlhQ2xpZW50Vmlld01vZGVsIHsgXHJcbiAgICBTdGF0dXNUZXh0OiBzdHJpbmcgfCB1bmRlZmluZWRcclxuICAgIEN1cnJlbnRSZXZpc2lvbjogbnVtYmVyO1xyXG4gICAgQ2FsaWZvcm5pYUV2ZW50OiBudW1iZXI7XHJcbiAgICBDYWxpZm9ybmlhUHJvamVjdDogQ2FsaWZvcm5pYVByb2plY3Q7XHJcbiAgICBTdHlsZUF0b21Dc3NQcm9wZXJ0eU1hcHBpbmc6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nW107IH07XHJcbiAgICBBbGxDc3NQcm9wZXJ0aWVzOiBzdHJpbmdbXTtcclxuICAgIFVybFRvUmVhZE9ubHk6IHN0cmluZyB8IHVuZGVmaW5lZFxyXG4gICAgVXJsVG9SZWFkQW5kRWRpdDogc3RyaW5nIHwgdW5kZWZpbmVkXHJcbiAgICBQYXJ0aWFsVXBkYXRlOiBDYWxpZm9ybmlhQ2xpZW50UGFydGlhbERhdGE7XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9UeXBld3JpdGVyL0NhbGlmb3JuaWFDbGllbnRWaWV3TW9kZWwudHMiLCJcclxuXHJcbmltcG9ydCB7Q2FsaWZvcm5pYVByb2plY3R9IGZyb20gXCIuL0NhbGlmb3JuaWFQcm9qZWN0XCI7XG5pbXBvcnQge1N0eWxlTW9sZWN1bGVBdG9tTWFwcGluZ30gZnJvbSBcIi4vU3R5bGVNb2xlY3VsZUF0b21NYXBwaW5nXCI7XG5pbXBvcnQge0NvbnRlbnRBdG9tfSBmcm9tIFwiLi9Db250ZW50QXRvbVwiO1xuaW1wb3J0IHtMYXlvdXRCYXNlfSBmcm9tIFwiLi9MYXlvdXRCYXNlXCI7IFxyXG5leHBvcnQgY2xhc3MgU3R5bGVNb2xlY3VsZSB7IFxyXG4gICAgU3R5bGVNb2xlY3VsZUlkOiBudW1iZXI7XHJcbiAgICBOYW1lOiBzdHJpbmc7XHJcbiAgICBOYW1lU2hvcnQ6IHN0cmluZztcclxuICAgIEh0bWxUYWc6IHN0cmluZyB8IHVuZGVmaW5lZFxyXG4gICAgQ2xvbmVkRnJvbVN0eWxlSWQ6IG51bWJlciB8IHVuZGVmaW5lZDtcclxuICAgIENsb25lZEZyb21TdHlsZTogU3R5bGVNb2xlY3VsZTtcclxuICAgIENsb25lT2ZTdHlsZXM6IFN0eWxlTW9sZWN1bGVbXTtcclxuICAgIFN0eWxlRm9yTGF5b3V0SWQ6IG51bWJlcjtcclxuICAgIFN0eWxlRm9yTGF5b3V0OiBMYXlvdXRCYXNlO1xyXG4gICAgTWFwcGVkU3R5bGVBdG9tczogU3R5bGVNb2xlY3VsZUF0b21NYXBwaW5nW107XHJcbiAgICBJc1Bvc2l0aW9uRml4ZWQ6IGJvb2xlYW47XHJcbiAgICBUb3BDc3NWYWx1ZVB4OiBzdHJpbmcgfCB1bmRlZmluZWRcclxuICAgIExlZnRDc3NWYWx1ZVB4OiBzdHJpbmcgfCB1bmRlZmluZWRcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvU3R5bGVNb2xlY3VsZS50cyIsIlxyXG5cclxuaW1wb3J0IHtDYWxpZm9ybmlhUHJvamVjdH0gZnJvbSBcIi4vQ2FsaWZvcm5pYVByb2plY3RcIjtcbmltcG9ydCB7U3R5bGVBdG9tUXVhbnR1bU1hcHBpbmd9IGZyb20gXCIuL1N0eWxlQXRvbVF1YW50dW1NYXBwaW5nXCI7IFxyXG5leHBvcnQgY2xhc3MgU3R5bGVRdWFudHVtIHsgXHJcbiAgICBTdHlsZVF1YW50dW1JZDogbnVtYmVyO1xyXG4gICAgTmFtZTogc3RyaW5nO1xyXG4gICAgQ3NzUHJvcGVydHk6IHN0cmluZztcclxuICAgIENzc1ZhbHVlOiBzdHJpbmc7XHJcbiAgICBJc0RlbGV0YWJsZTogYm9vbGVhbjtcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvU3R5bGVRdWFudHVtLnRzIiwiXHJcblxyXG5pbXBvcnQge0NhbGlmb3JuaWFQcm9qZWN0fSBmcm9tIFwiLi9DYWxpZm9ybmlhUHJvamVjdFwiO1xuaW1wb3J0IHtTdHlsZUF0b21UeXBlfSBmcm9tIFwiLi9TdHlsZUF0b21UeXBlXCI7XG5pbXBvcnQge1N0eWxlQXRvbVF1YW50dW1NYXBwaW5nfSBmcm9tIFwiLi9TdHlsZUF0b21RdWFudHVtTWFwcGluZ1wiO1xuaW1wb3J0IHtTdHlsZVZhbHVlfSBmcm9tIFwiLi9TdHlsZVZhbHVlXCI7XG5pbXBvcnQge1N0eWxlTW9sZWN1bGVBdG9tTWFwcGluZ30gZnJvbSBcIi4vU3R5bGVNb2xlY3VsZUF0b21NYXBwaW5nXCI7IFxyXG5leHBvcnQgY2xhc3MgU3R5bGVBdG9tIHsgXHJcbiAgICBTdHlsZUF0b21JZDogbnVtYmVyO1xyXG4gICAgTmFtZTogc3RyaW5nO1xyXG4gICAgU3R5bGVBdG9tVHlwZTogU3R5bGVBdG9tVHlwZTtcclxuICAgIEFwcGxpZWRWYWx1ZXM6IFN0eWxlVmFsdWVbXTtcclxuICAgIE1hcHBlZFF1YW50dW1zOiBTdHlsZUF0b21RdWFudHVtTWFwcGluZ1tdO1xyXG4gICAgTWFwcGVkVG9Nb2xlY3VsZUlkOiBudW1iZXI7XHJcbiAgICBJc0RlbGV0YWJsZTogYm9vbGVhbjtcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvU3R5bGVBdG9tLnRzIiwiXHJcblxyXG5leHBvcnQgZW51bSBTdHlsZUF0b21UeXBlIHtcclxuICAgIEdlbmVyaWMgPSAwLFxyXG4gICAgRm9udCA9IDEsXHJcbiAgICBUeXBvZ3JhcGh5ID0gMixcclxuICAgIERpdmlkZXIgPSAzLFxyXG4gICAgQmFja2dyb3VuZCA9IDQsXHJcbiAgICBTcGFjaW5nID0gNSxcclxuICAgIFBpY3R1cmUgPSA2LFxyXG4gICAgR3JpZCA9IDcsXHJcbiAgICBSb3cgPSA4LFxyXG4gICAgTmF2YmFyID0gOSxcclxuICAgIExpc3QgPSAxMCxcclxuICAgIEJveCA9IDExLFxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vVHlwZXdyaXRlci9TdHlsZUF0b21UeXBlLnRzIiwiXHJcblxyXG5pbXBvcnQge0NhbGlmb3JuaWFQcm9qZWN0fSBmcm9tIFwiLi9DYWxpZm9ybmlhUHJvamVjdFwiO1xuaW1wb3J0IHtTdHlsZUF0b219IGZyb20gXCIuL1N0eWxlQXRvbVwiOyBcclxuZXhwb3J0IGNsYXNzIFN0eWxlVmFsdWUgeyBcclxuICAgIFN0eWxlVmFsdWVJZDogbnVtYmVyO1xyXG4gICAgU3R5bGVBdG9tSWQ6IG51bWJlcjtcclxuICAgIENzc1Byb3BlcnR5OiBzdHJpbmc7XHJcbiAgICBDc3NWYWx1ZTogc3RyaW5nO1xyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vVHlwZXdyaXRlci9TdHlsZVZhbHVlLnRzIiwiXHJcblxyXG5pbXBvcnQge0NhbGlmb3JuaWFQcm9qZWN0fSBmcm9tIFwiLi9DYWxpZm9ybmlhUHJvamVjdFwiO1xuaW1wb3J0IHtTdHlsZU1vbGVjdWxlQXRvbU1hcHBpbmd9IGZyb20gXCIuL1N0eWxlTW9sZWN1bGVBdG9tTWFwcGluZ1wiOyBcclxuZXhwb3J0IGNsYXNzIFJlc3BvbnNpdmVEZXZpY2UgeyBcclxuICAgIFJlc3BvbnNpdmVEZXZpY2VJZDogbnVtYmVyO1xyXG4gICAgTmFtZTogc3RyaW5nO1xyXG4gICAgTmFtZVNob3J0OiBzdHJpbmc7XHJcbiAgICBXaWR0aFRocmVzaG9sZDogbnVtYmVyO1xyXG4gICAgQXBwbGllZFRvTWFwcGluZ3M6IFN0eWxlTW9sZWN1bGVBdG9tTWFwcGluZ1tdO1xyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vVHlwZXdyaXRlci9SZXNwb25zaXZlRGV2aWNlLnRzIiwiXHJcblxyXG5pbXBvcnQge0NhbGlmb3JuaWFQcm9qZWN0fSBmcm9tIFwiLi9DYWxpZm9ybmlhUHJvamVjdFwiO1xuaW1wb3J0IHtMYXlvdXRSb3d9IGZyb20gXCIuL0xheW91dFJvd1wiO1xuaW1wb3J0IHtRdWVyeVZpZXdMYXlvdXRCb3hNYXBwaW5nfSBmcm9tIFwiLi9RdWVyeVZpZXdMYXlvdXRCb3hNYXBwaW5nXCI7IFxyXG5leHBvcnQgY2xhc3MgQ2FsaWZvcm5pYVZpZXcgeyBcclxuICAgIENhbGlmb3JuaWFWaWV3SWQ6IG51bWJlcjtcclxuICAgIE5hbWU6IHN0cmluZztcclxuICAgIFF1ZXJ5VXJsOiBzdHJpbmc7XHJcbiAgICBIb3N0ZWRCeUxheW91dE1hcHBpbmdzOiBRdWVyeVZpZXdMYXlvdXRCb3hNYXBwaW5nW107XHJcbiAgICBQbGFjZWRMYXlvdXRSb3dzOiBMYXlvdXRSb3dbXTtcclxuICAgIFZpZXdTb3J0T3JkZXJLZXk6IG51bWJlcjtcclxuICAgIElzSW50ZXJuYWw6IGJvb2xlYW47XHJcbiAgICBEZWVwZXN0TGV2ZWw6IG51bWJlcjtcclxuICAgIFNwZWNpYWxTdHlsZVZpZXdTdHlsZU1vbGVjdWxlSWQ6IG51bWJlcjtcclxuICAgIFNwZWNpYWxTdHlsZUJvZHlTdHlsZU1vbGVjdWxlSWQ6IG51bWJlcjtcclxuICAgIFNwZWNpYWxTdHlsZUh0bWxTdHlsZU1vbGVjdWxlSWQ6IG51bWJlcjtcclxuICAgIFNwZWNpYWxTdHlsZVZpZXdTdHlsZU1vbGVjdWxlSWRTdHJpbmc6IHN0cmluZztcclxuICAgIFNwZWNpYWxTdHlsZUJvZHlTdHlsZU1vbGVjdWxlSWRTdHJpbmc6IHN0cmluZztcclxuICAgIFNwZWNpYWxTdHlsZUh0bWxTdHlsZU1vbGVjdWxlSWRTdHJpbmc6IHN0cmluZztcclxuICAgIFNwZWNpYWxTdHlsZVZpZXdTdHlsZVN0cmluZzogc3RyaW5nO1xyXG4gICAgU3BlY2lhbFN0eWxlQm9keVN0eWxlU3RyaW5nOiBzdHJpbmc7XHJcbiAgICBTcGVjaWFsU3R5bGVIdG1sU3R5bGVTdHJpbmc6IHN0cmluZztcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvQ2FsaWZvcm5pYVZpZXcudHMiLCJcclxuXHJcbmltcG9ydCB7Q2FsaWZvcm5pYVByb2plY3R9IGZyb20gXCIuL0NhbGlmb3JuaWFQcm9qZWN0XCI7XG5pbXBvcnQge0xheW91dEJveH0gZnJvbSBcIi4vTGF5b3V0Qm94XCI7XG5pbXBvcnQge1N0eWxlTW9sZWN1bGV9IGZyb20gXCIuL1N0eWxlTW9sZWN1bGVcIjtcbmltcG9ydCB7Q2FsaWZvcm5pYVZpZXd9IGZyb20gXCIuL0NhbGlmb3JuaWFWaWV3XCI7XG5pbXBvcnQge0xheW91dFR5cGV9IGZyb20gXCIuL0xheW91dFR5cGVcIjsgXHJcbmV4cG9ydCBjbGFzcyBMYXlvdXRSb3cgeyBcclxuICAgIExheW91dEJhc2VJZDogbnVtYmVyO1xyXG4gICAgU3R5bGVNb2xlY3VsZTogU3R5bGVNb2xlY3VsZTtcclxuICAgIExheW91dFNvcnRPcmRlcktleTogbnVtYmVyO1xyXG4gICAgTGF5b3V0VHlwZTogTGF5b3V0VHlwZTtcclxuICAgIEFsbEJveGVzQmVsb3dSb3c6IExheW91dEJveFtdO1xyXG4gICAgUGxhY2VkT25WaWV3SWQ6IG51bWJlcjtcclxuICAgIERlZXBlc3RMZXZlbDogbnVtYmVyO1xyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vVHlwZXdyaXRlci9MYXlvdXRSb3cudHMiLCJcclxuXHJcbmltcG9ydCB7Q2FsaWZvcm5pYVByb2plY3R9IGZyb20gXCIuL0NhbGlmb3JuaWFQcm9qZWN0XCI7XG5pbXBvcnQge0xheW91dFJvd30gZnJvbSBcIi4vTGF5b3V0Um93XCI7XG5pbXBvcnQge0xheW91dEF0b219IGZyb20gXCIuL0xheW91dEF0b21cIjtcbmltcG9ydCB7U3R5bGVNb2xlY3VsZX0gZnJvbSBcIi4vU3R5bGVNb2xlY3VsZVwiO1xuaW1wb3J0IHtRdWVyeVZpZXdMYXlvdXRCb3hNYXBwaW5nfSBmcm9tIFwiLi9RdWVyeVZpZXdMYXlvdXRCb3hNYXBwaW5nXCI7XG5pbXBvcnQge0xheW91dFR5cGV9IGZyb20gXCIuL0xheW91dFR5cGVcIjtcbmltcG9ydCB7U3BlY2lhbExheW91dEJveFR5cGV9IGZyb20gXCIuL1NwZWNpYWxMYXlvdXRCb3hUeXBlXCI7IFxyXG5leHBvcnQgY2xhc3MgTGF5b3V0Qm94IHsgXHJcbiAgICBMYXlvdXRCYXNlSWQ6IG51bWJlcjtcclxuICAgIFN0eWxlTW9sZWN1bGU6IFN0eWxlTW9sZWN1bGU7XHJcbiAgICBMYXlvdXRTb3J0T3JkZXJLZXk6IG51bWJlcjtcclxuICAgIExheW91dFR5cGU6IExheW91dFR5cGU7XHJcbiAgICBQbGFjZWRJbkJveEF0b21zOiBMYXlvdXRBdG9tW107XHJcbiAgICBQbGFjZWRJbkJveEJveGVzOiBMYXlvdXRCb3hbXTtcclxuICAgIFBsYWNlZEJveEluQm94SWQ6IG51bWJlciB8IHVuZGVmaW5lZDtcclxuICAgIFBsYWNlZEJveEluQm94OiBMYXlvdXRCb3g7XHJcbiAgICBCb3hPd25lclJvd0lkOiBudW1iZXI7XHJcbiAgICBCb3hPd25lclJvdzogTGF5b3V0Um93O1xyXG4gICAgSG9zdGVkVmlld01hcHBpbmdzOiBRdWVyeVZpZXdMYXlvdXRCb3hNYXBwaW5nW107XHJcbiAgICBTcGVjaWFsTGF5b3V0Qm94VHlwZTogU3BlY2lhbExheW91dEJveFR5cGU7XHJcbiAgICBMZXZlbDogbnVtYmVyO1xyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vVHlwZXdyaXRlci9MYXlvdXRCb3gudHMiLCJcclxuXHJcbmltcG9ydCB7Q2FsaWZvcm5pYVByb2plY3R9IGZyb20gXCIuL0NhbGlmb3JuaWFQcm9qZWN0XCI7XHJcbmltcG9ydCB7Q29udGVudEF0b219IGZyb20gXCIuL0NvbnRlbnRBdG9tXCI7XHJcbmltcG9ydCB7TGF5b3V0Qm94fSBmcm9tIFwiLi9MYXlvdXRCb3hcIjtcclxuaW1wb3J0IHtTdHlsZU1vbGVjdWxlfSBmcm9tIFwiLi9TdHlsZU1vbGVjdWxlXCI7XHJcbmltcG9ydCB7TGF5b3V0VHlwZX0gZnJvbSBcIi4vTGF5b3V0VHlwZVwiO1xyXG5pbXBvcnQge0xheW91dFN0eWxlSW50ZXJhY3Rpb259IGZyb20gXCIuL0xheW91dFN0eWxlSW50ZXJhY3Rpb25cIjsgXHJcbmV4cG9ydCBjbGFzcyBMYXlvdXRBdG9tIHsgXHJcbiAgICBMYXlvdXRCYXNlSWQ6IG51bWJlcjtcclxuICAgIFN0eWxlTW9sZWN1bGU6IFN0eWxlTW9sZWN1bGU7XHJcbiAgICBMYXlvdXRTb3J0T3JkZXJLZXk6IG51bWJlcjtcclxuICAgIExheW91dFR5cGU6IExheW91dFR5cGU7XHJcbiAgICBQbGFjZWRBdG9tSW5Cb3hJZDogbnVtYmVyO1xyXG4gICAgUGxhY2VkQXRvbUluQm94OiBMYXlvdXRCb3g7XHJcbiAgICBIb3N0ZWRDb250ZW50QXRvbTogQ29udGVudEF0b207XHJcbiAgICBMYXlvdXRTdHlsZUludGVyYWN0aW9uczogTGF5b3V0U3R5bGVJbnRlcmFjdGlvbltdO1xyXG4gICAgTGV2ZWw6IG51bWJlcjtcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvTGF5b3V0QXRvbS50cyIsIlxyXG5cclxuaW1wb3J0IHtTdHlsZU1vbGVjdWxlfSBmcm9tIFwiLi9TdHlsZU1vbGVjdWxlXCI7XG5pbXBvcnQge1N0eWxlQXRvbX0gZnJvbSBcIi4vU3R5bGVBdG9tXCI7XG5pbXBvcnQge1Jlc3BvbnNpdmVEZXZpY2V9IGZyb20gXCIuL1Jlc3BvbnNpdmVEZXZpY2VcIjsgXHJcbmV4cG9ydCBjbGFzcyBTdHlsZU1vbGVjdWxlQXRvbU1hcHBpbmcgeyBcclxuICAgIFN0eWxlTW9sZWN1bGVBdG9tTWFwcGluZ0lkOiBudW1iZXI7XHJcbiAgICBTdHlsZU1vbGVjdWxlSWQ6IG51bWJlcjtcclxuICAgIFN0eWxlTW9sZWN1bGU6IFN0eWxlTW9sZWN1bGU7XHJcbiAgICBSZXNwb25zaXZlRGV2aWNlSWQ6IG51bWJlcjtcclxuICAgIFJlc3BvbnNpdmVEZXZpY2U6IFJlc3BvbnNpdmVEZXZpY2U7XHJcbiAgICBTdGF0ZU1vZGlmaWVyOiBzdHJpbmcgfCB1bmRlZmluZWRcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvU3R5bGVNb2xlY3VsZUF0b21NYXBwaW5nLnRzIiwiXHJcblxyXG5pbXBvcnQge0NhbGlmb3JuaWFQcm9qZWN0fSBmcm9tIFwiLi9DYWxpZm9ybmlhUHJvamVjdFwiO1xyXG5pbXBvcnQge1N0eWxlTW9sZWN1bGV9IGZyb20gXCIuL1N0eWxlTW9sZWN1bGVcIjtcclxuaW1wb3J0IHtDb250ZW50QXRvbVR5cGV9IGZyb20gXCIuL0NvbnRlbnRBdG9tVHlwZVwiO1xyXG5pbXBvcnQge1BpY3R1cmVDb250ZW50fSBmcm9tIFwiLi9QaWN0dXJlQ29udGVudFwiO1xyXG5pbXBvcnQge0NhbGlmb3JuaWFWaWV3fSBmcm9tIFwiLi9DYWxpZm9ybmlhVmlld1wiO1xyXG5pbXBvcnQge0xheW91dEF0b219IGZyb20gXCIuL0xheW91dEF0b21cIjsgXHJcbmV4cG9ydCBjbGFzcyBDb250ZW50QXRvbSB7IFxyXG4gICAgQ29udGVudEF0b21JZDogbnVtYmVyO1xyXG4gICAgQ29udGVudEF0b21UeXBlOiBDb250ZW50QXRvbVR5cGU7XHJcbiAgICBUZXh0Q29udGVudDogc3RyaW5nIHwgdW5kZWZpbmVkXHJcbiAgICBVcmw6IHN0cmluZyB8IHVuZGVmaW5lZFxyXG4gICAgUGljdHVyZUNvbnRlbnRJZDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgUGljdHVyZUNvbnRlbnQ6IFBpY3R1cmVDb250ZW50O1xyXG4gICAgSXNEZWxldGVkOiBib29sZWFuO1xyXG4gICAgRGVsZXRlZERhdGU6IERhdGUgfCBzdHJpbmdcclxuICAgIEluc3RhbmNlZE9uTGF5b3V0SWQ6IG51bWJlciB8IHVuZGVmaW5lZDtcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvQ29udGVudEF0b20udHMiLCJcclxuXHJcbmltcG9ydCB7U3R5bGVNb2xlY3VsZX0gZnJvbSBcIi4vU3R5bGVNb2xlY3VsZVwiO1xuaW1wb3J0IHtMYXlvdXRUeXBlfSBmcm9tIFwiLi9MYXlvdXRUeXBlXCI7IFxyXG5leHBvcnQgY2xhc3MgTGF5b3V0QmFzZSB7IFxyXG4gICAgTGF5b3V0QmFzZUlkOiBudW1iZXI7XHJcbiAgICBTdHlsZU1vbGVjdWxlOiBTdHlsZU1vbGVjdWxlO1xyXG4gICAgTGF5b3V0U29ydE9yZGVyS2V5OiBudW1iZXI7XHJcbiAgICBMYXlvdXRUeXBlOiBMYXlvdXRUeXBlO1xyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vVHlwZXdyaXRlci9MYXlvdXRCYXNlLnRzIiwiXHJcblxyXG5leHBvcnQgZW51bSBMYXlvdXRUeXBlIHtcclxuICAgIFJvdyA9IDAsXHJcbiAgICBCb3ggPSAxLFxyXG4gICAgQXRvbSA9IDIsXHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9UeXBld3JpdGVyL0xheW91dFR5cGUudHMiLCJcclxuXHJcbmV4cG9ydCBlbnVtIFNwZWNpYWxMYXlvdXRCb3hUeXBlIHtcclxuICAgIERlZmF1bHQgPSAwLFxyXG4gICAgQ2FsaWZvcm5pYVZpZXdIb2xkZXIgPSAxLFxyXG4gICAgTmF2aWdhdGlvbiA9IDIsXHJcbiAgICBVbnNvcnRlZExpc3QgPSAzLFxyXG4gICAgU29ydGVkTGlzdCA9IDQsXHJcbiAgICBMaXN0SXRlbSA9IDUsXHJcbiAgICBSaWNoVGV4dCA9IDYsXHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9UeXBld3JpdGVyL1NwZWNpYWxMYXlvdXRCb3hUeXBlLnRzIiwiXHJcblxyXG5pbXBvcnQge1N0eWxlVmFsdWVJbnRlcmFjdGlvbk1hcHBpbmd9IGZyb20gXCIuL1N0eWxlVmFsdWVJbnRlcmFjdGlvbk1hcHBpbmdcIjtcbmltcG9ydCB7TGF5b3V0U3R5bGVJbnRlcmFjdGlvblR5cGV9IGZyb20gXCIuL0xheW91dFN0eWxlSW50ZXJhY3Rpb25UeXBlXCI7IFxyXG5leHBvcnQgY2xhc3MgTGF5b3V0U3R5bGVJbnRlcmFjdGlvbiB7IFxyXG4gICAgTGF5b3V0U3R5bGVJbnRlcmFjdGlvbklkOiBudW1iZXI7XHJcbiAgICBMYXlvdXRBdG9tSWQ6IG51bWJlcjtcclxuICAgIFN0eWxlVmFsdWVJbnRlcmFjdGlvbnM6IFN0eWxlVmFsdWVJbnRlcmFjdGlvbk1hcHBpbmdbXTtcclxuICAgIExheW91dFN0eWxlSW50ZXJhY3Rpb25UeXBlOiBMYXlvdXRTdHlsZUludGVyYWN0aW9uVHlwZTtcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvTGF5b3V0U3R5bGVJbnRlcmFjdGlvbi50cyIsIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9qc3gudHNcIiAvPlxyXG5cInVzZSBzdHJpY3RcIjtcclxuaW1wb3J0IHsgVk5vZGUsIFZOb2RlUHJvcGVydGllcyB9IGZyb20gXCJtYXF1ZXR0ZVwiO1xyXG5pbXBvcnQgKiBhcyBtYXF1ZXR0ZSBmcm9tIFwibWFxdWV0dGVcIjtcclxuY29uc3QgaCA9IG1hcXVldHRlLmg7XHJcbmltcG9ydCB7IENhbGlmb3JuaWFBcHAsIERFRkFVTFRfRVhDRVBUSU9OLCBwYXJzZUludEZyb21BdHRyaWJ1dGUsIGdldEFycmF5Rm9yRW51bSwgVUlfWl9JTkRFWCB9IGZyb20gXCIuL0NhbGlmb3JuaWFBcHBcIjtcclxuaW1wb3J0IHsgUGFnZVByZXZpZXdWTSB9IGZyb20gXCIuLy4uL1ZpZXdNb2RlbHMvUGFnZVByZXZpZXdWTVwiO1xyXG5pbXBvcnQgeyBDYWxpZm9ybmlhVmlldywgTGF5b3V0Um93LCBTdHlsZU1vbGVjdWxlLCBMYXlvdXRCb3gsIExheW91dEF0b20sIFJlc3BvbnNpdmVEZXZpY2UsIFN0eWxlQXRvbSwgU3R5bGVNb2xlY3VsZUF0b21NYXBwaW5nLCBDb250ZW50QXRvbSwgU3R5bGVWYWx1ZSwgU3BlY2lhbExheW91dEJveFR5cGUsIENhbGlmb3JuaWFDbGllbnRWaWV3TW9kZWwsIExheW91dFR5cGUsIExheW91dEJhc2UsIENhbGlmb3JuaWFFdmVudCB9IGZyb20gXCIuL0NhbGlmb3JuaWFHZW5lcmF0ZWRcIjtcclxuaW1wb3J0IHsgU2VsZWN0aW9uTW9kZSwgUmVhZHlTdGF0ZSwgRWRpdFZpZXdNb2RlIH0gZnJvbSBcIi4vQ2xpZW50U3RhdGVcIjtcclxuaW1wb3J0IHsgQ29udGVudEF0b21UeXBlIH0gZnJvbSBcIi4uL1R5cGV3cml0ZXIvQ29udGVudEF0b21UeXBlXCI7XHJcbmltcG9ydCB7IFByb3BlcnR5QmFyVk0gfSBmcm9tIFwiLi4vVmlld01vZGVscy9Qcm9wZXJ0eUJhclZNXCI7XHJcbmltcG9ydCB7IFZFUllfSElHSF9WQUxVRSB9IGZyb20gXCIuL1Byb3BlcnR5QmFyXCI7XHJcblxyXG5sZXQgY3VycmVudEFwcDogQ2FsaWZvcm5pYUFwcDtcclxubGV0IGN1cnJlbnRQYWdlUHJldmlldzogUGFnZVByZXZpZXc7XHJcblxyXG5leHBvcnQgY29uc3QgSElHSExJR0hUX0JBQ0tHUk9VTkRfQ09MT1JfU1RSSU5HOiBzdHJpbmcgPSBcInJnYigyMzMsMjMzLDIzMylcIjtcclxuZXhwb3J0IGNvbnN0IE1BTlVBTExZX0hJR0hMSUdIVF9CQUNLR1JPVU5EX0NPTE9SX1NUUklORzogc3RyaW5nID0gXCJyZ2IoMjIyLDIyMiwyMjIpXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgUGFnZVByZXZpZXcge1xyXG4gICAgcHVibGljIHZpZXdNb2RlbDogUGFnZVByZXZpZXdWTTtcclxuICAgIC8vIHZpcnR1YWwgc3R5bGUgc2hlZXRzXHJcbiAgICBwdWJsaWMgZHluYW1pY0NsaWVudEdyaWRCcmVha3BvaW50czogbnVtYmVyW10gPSBbXTtcclxuICAgIHB1YmxpYyB2aXJ0dWFsU3R5bGVJbmRleDogeyBba2V5OiBudW1iZXJdOiBudW1iZXIgfVtdID0gW107XHJcbiAgICBwdWJsaWMgdmlydHVhbFBzZXVkb1N0eWxlSW5kZXg6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH1bXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSBfdmlzaWJsZUxheW91dEF0b21Eb21Ob2RlUmVmZXJlbmNlczogSFRNTEVsZW1lbnRbXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSBfYWN0aXZlVmlld0xheW91dEF0b21Eb21Ob2RlUmVmZXJlbmNlczogeyBba2V5OiBzdHJpbmddOiBIVE1MRWxlbWVudCB9ID0ge307XHJcbiAgICBwcml2YXRlIF92aXNpYmxlTGF5b3V0QXRvbUtleXM6IHN0cmluZ1tdID0gW107XHJcbiAgICBwcml2YXRlIF9tb3N0VXBwZXJWaXNpYmxlTGF5b3V0QXRvbUlkOiBudW1iZXIgPSAwO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNhbGlmb3JuaWFBcHBBcmc6IENhbGlmb3JuaWFBcHApIHtcclxuICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcgPSB0aGlzO1xyXG4gICAgICAgIGN1cnJlbnRBcHAgPSBjYWxpZm9ybmlhQXBwQXJnO1xyXG4gICAgICAgIHRoaXMudmlld01vZGVsID0gbmV3IFBhZ2VQcmV2aWV3Vk0odGhpcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgZ2V0IHZpc2libGVMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXMoKTogSFRNTEVsZW1lbnRbXSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGVMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBnZXQgdmlzaWJsZUxheW91dEF0b21LZXlzKCk6IHN0cmluZ1tdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZUxheW91dEF0b21LZXlzO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIGdldCBhY3RpdmVWaWV3TGF5b3V0QXRvbURvbU5vZGVSZWZlcmVuY2VzKCk6IHsgW2tleTogc3RyaW5nXTogSFRNTEVsZW1lbnQgfSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVZpZXdMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBnZXQgbW9zdFVwcGVyVmlzaWJsZUxheW91dEF0b21JZCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tb3N0VXBwZXJWaXNpYmxlTGF5b3V0QXRvbUlkO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyUHJldmlld0FyZWEgPSAoKTogVk5vZGUgPT4ge1xyXG4gICAgICAgIGxldCBwcmV2aWV3QXJlYVN0eWxlcyA9IHtcclxuICAgICAgICAgICAgXCJmbGV4XCI6IGN1cnJlbnRBcHAuc3RhdGUuZWRpdFZpZXdNb2RlID09PSBFZGl0Vmlld01vZGUuU2lkZWJhck9ubHkgPyBcIjAgMCAxcHhcIiAgOiBcIjEgMSA3NzdweFwiLCAvLyA+MXB4IGZvciBJRTExXHJcbiAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcImZsZXhcIixcclxuICAgICAgICAgICAgXCJmbGV4LWZsb3dcIjogXCJjb2x1bW4gbm93cmFwXCIsXHJcbiAgICAgICAgICAgIFwid2lkdGhcIjogXCI1MzNweFwiLFxyXG4gICAgICAgICAgICBcIm1heC13aWR0aFwiOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgLy9cIm1pbi13aWR0aFwiOiBjdXJyZW50QXBwLnN0YXRlLmVkaXRWaWV3TW9kZSA9PT0gRWRpdFZpZXdNb2RlLlNpZGViYXJPbmx5ID8gdW5kZWZpbmVkIDogXCIxMDBweFwiLCAvLyBwcmV2ZW50cyBoaWRpbmcgb2YgcHJldmlldyBhcmVhIHdoZW4gdXNpbmcgYnJvd3NlciB6b29tIG9yIHJlc2l6aW5nIFRPRE8gbWVzc2VzIHdpdGggdGhlIHdpZHRoIGNvbXB1dGF0aW9uIGZyb20gZmxleC4uLlxyXG4gICAgICAgICAgICBcImhlaWdodFwiOiBcIjEwMCVcIiwgLy8gMTAwJSBmb3IgaVBhZCxcclxuICAgICAgICAgICAgXCJvdmVyZmxvd1wiOiBcInZpc2libGVcIiAvLyBmb3IgdG9wIG5hdiBUT0RPXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgaXNSUkJ1dHRvbkVuYWJsZWQ6IGJvb2xlYW4gPSBjdXJyZW50QXBwLnN0YXRlLmxhc3RDYWxpZm9ybmlhRXZlbnREYXRhLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgcmV0dXJuIDxkaXYga2V5PVwiMFwiIHN0eWxlcz17cHJldmlld0FyZWFTdHlsZXN9PlxyXG4gICAgICAgICAgICB7Y3VycmVudEFwcC5zdGF0ZS5pc0hpZGVVc2VySW50ZXJmYWNlID8gdW5kZWZpbmVkIDogY3VycmVudFBhZ2VQcmV2aWV3LnJlbmRlck5hdmlnYXRpb24oKX1cclxuICAgICAgICAgICAge2N1cnJlbnRBcHAuc3RhdGUuZWRpdFZpZXdNb2RlID09PSBFZGl0Vmlld01vZGUuU2lkZWJhck9ubHkgPyB1bmRlZmluZWQgOiBjdXJyZW50UGFnZVByZXZpZXcucmVuZGVyUGFnZVByZXZpZXdIb2xkZXIoKX1cclxuICAgICAgICAgICAge2N1cnJlbnRBcHAuc3RhdGUuaXNIaWRlVXNlckludGVyZmFjZSA/IDxkaXYga2V5PVwiMlwiIHN0eWxlcz17eyBcInBvc2l0aW9uXCI6IFwiYWJzb2x1dGVcIiwgXCJsZWZ0XCI6IFwiMFwiLCBcInRvcFwiOiBcIjBcIiwgXCJ6LWluZGV4XCI6IFVJX1pfSU5ERVgudG9TdHJpbmcoKSwgXCJkaXNwbGF5XCI6IFwiZmxleFwiLCBcImZsZXgtZmxvd1wiOiBcImNvbHVtbiBub3dyYXBcIiB9fT5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIG9uY2xpY2s9e2N1cnJlbnRQYWdlUHJldmlldy5wcmV2aWV3Q2xpY2tIYW5kbGVyfT4mIzgyMzA7PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImJcIiBvbmNsaWNrPXtjdXJyZW50QXBwLnByb3BlcnR5QmFyc1swXS5pbnNlcnRMYXlvdXRSb3dJbnRvVmlld0NsaWNrSGFuZGxlcn0+KyhSKTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAge2lzUlJCdXR0b25FbmFibGVkID8gPGJ1dHRvbiBrZXk9XCJjXCIgb25jbGljaz17Y3VycmVudFBhZ2VQcmV2aWV3LnJlcGVhdENsaWNrSGFuZGxlcn0gc3R5bGVzPXt7IFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsIFwid2lkdGhcIjogXCJhdXRvXCIgfX0+UlI8L2J1dHRvbj4gOlxyXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gZGlzYWJsZWQga2V5PVwiYzBcIiBvbmNsaWNrPXtjdXJyZW50UGFnZVByZXZpZXcucmVwZWF0Q2xpY2tIYW5kbGVyfSBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIiwgXCJ3aWR0aFwiOiBcImF1dG9cIiB9fT5SUjwvYnV0dG9uPn1cclxuICAgICAgICAgICAgPC9kaXY+IDogdW5kZWZpbmVkfVxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlbmRlck5hdmlnYXRpb24gPSAoKTogVk5vZGUgPT4ge1xyXG4gICAgICAgIGxldCBuYXZpZ2F0aW9uU3R5bGVzID0ge1xyXG4gICAgICAgICAgICBcImZsZXhcIjogYDAgMCAke2N1cnJlbnRBcHAubmF2aWdhdGlvbkhlaWd0aFB4fXB4YCxcclxuICAgICAgICAgICAgXCJwb3NpdGlvblwiOiBcInJlbGF0aXZlXCIsIC8vIGZvciBsb2FkaW5nIGluZGljYXRvciBwb3NpdGlvbmluZyxcclxuICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiZmxleFwiLFxyXG4gICAgICAgICAgICBcImZsZXgtZmxvd1wiOiBcInJvdyBub3dyYXBcIixcclxuICAgICAgICAgICAgXCJ6LWluZGV4XCI6IFwiM1wiXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgbG9hZGluZ0luZGljYXRvclN0eWxlcyA9IHtcclxuICAgICAgICAgICAgXCJwb3NpdGlvblwiOiBcImFic29sdXRlXCIsXHJcbiAgICAgICAgICAgIFwicmlnaHRcIjogXCIwcHhcIixcclxuICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwicmVkXCIsXHJcbiAgICAgICAgICAgIFwiY29sb3JcIjogXCJ3aGl0ZVwiLFxyXG4gICAgICAgICAgICBcImJvcmRlclwiOiBcInNvbGlkIGJsYWNrIDFweFwiXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgbmF2aWdhdGlvbkJ1dHRvblN0eWxlcyA9IHtcclxuICAgICAgICAgICAgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IGlzUlJCdXR0b25FbmFibGVkOiBib29sZWFuID0gY3VycmVudEFwcC5zdGF0ZS5sYXN0Q2FsaWZvcm5pYUV2ZW50RGF0YS5sZW5ndGggPiAwO1xyXG4gICAgICAgIC8vIGNhbiBiZSB1c2VkIGFzIFRFU1QgZm9yIGRhdGFiYXNlIG1vZGVsIChjcmVhdGUvZGVsZXRlKSBhbmQgVEVTVCBkaXNwbGF5IHdpdGggbm8gZXJyb3JzIGFuZCBURVNUIGRpc3BsYXkgYWxsIGRhdGEgYW5kIFRFU1QgZGF0YSB0cmFuc21pdHRlZCBhbmQgc28gb25cclxuICAgICAgICByZXR1cm4gPGRpdiBrZXk9XCIwXCIgc3R5bGVzPXtuYXZpZ2F0aW9uU3R5bGVzfT5cclxuICAgICAgICAgICAge2N1cnJlbnRBcHAuaXNBamF4UmVxdWVzdFJ1bm5pbmcgPyA8cCBrZXk9XCJ6XCIgc3R5bGVzPXtsb2FkaW5nSW5kaWNhdG9yU3R5bGVzfT5Mb2FkaW5nLi4uPC9wPiA6IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgb25jbGljaz17Y3VycmVudFBhZ2VQcmV2aWV3LnByZXZpZXdDbGlja0hhbmRsZXJ9IHN0eWxlcz17eyBcImZsZXhcIjogXCIwIDAgYXV0b1wiLCBcIndpZHRoXCI6IFwiYXV0b1wiIH19PlByZXZpZXc8L2J1dHRvbj5cclxuICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJiXCIgZWlkPXtFZGl0Vmlld01vZGUuUGFnZVByZXZpZXdPbmx5LnRvU3RyaW5nKCl9IG9uY2xpY2s9e2N1cnJlbnRQYWdlUHJldmlldy5jaGFuZ2VFZGl0TW9kZUNsaWNrSGFuZGxlcn0gc3R5bGVzPXt7IFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBjdXJyZW50QXBwLnN0YXRlLmVkaXRWaWV3TW9kZSA9PT0gRWRpdFZpZXdNb2RlLlBhZ2VQcmV2aWV3T25seSA/IFwicmVkXCIgOiB1bmRlZmluZWQgfX0+UDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8YnV0dG9uIGtleT1cImNcIiBlaWQ9e0VkaXRWaWV3TW9kZS5TaWRlYmFyT25seS50b1N0cmluZygpfSBvbmNsaWNrPXtjdXJyZW50UGFnZVByZXZpZXcuY2hhbmdlRWRpdE1vZGVDbGlja0hhbmRsZXJ9IHN0eWxlcz17eyBcImZsZXhcIjogXCIwIDAgYXV0b1wiLCBcImJhY2tncm91bmQtY29sb3JcIjogY3VycmVudEFwcC5zdGF0ZS5lZGl0Vmlld01vZGUgPT09IEVkaXRWaWV3TW9kZS5TaWRlYmFyT25seSA/IFwicmVkXCIgOiB1bmRlZmluZWQgfX0+UzwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8YnV0dG9uIGtleT1cImRcIiBvbmNsaWNrPXtjdXJyZW50UGFnZVByZXZpZXcudG9nZ2xlU2lkZUJhckNvdW50fSBjaWQ9XCIxXCIgc3R5bGVzPXt7IFwiZmxleFwiOiBcIjAgMCBhdXRvXCIgfX0+eDE8L2J1dHRvbj5cclxuICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJlXCIgb25jbGljaz17Y3VycmVudFBhZ2VQcmV2aWV3LnRvZ2dsZVNpZGVCYXJDb3VudH0gY2lkPVwiMlwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIwIDAgYXV0b1wiIH19PngyPC9idXR0b24+XHJcbiAgICAgICAgICAgIDxidXR0b24ga2V5PVwiZlwiIG9uY2xpY2s9e2N1cnJlbnRQYWdlUHJldmlldy50b2dnbGVTaWRlQmFyQ291bnR9IGNpZD1cIjRcIiBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIiB9fT54NDwvYnV0dG9uPlxyXG4gICAgICAgICAgICB7Y3VycmVudFBhZ2VQcmV2aWV3LnJlbmRlclJlc3BvbnNpdmVEZXZpY2VTZWxlY3RvcnMoKX1cclxuICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJoXCIgb25jbGljaz17Y3VycmVudFBhZ2VQcmV2aWV3LmNoYW5nZVNlbGVjdGlvbk1vZGVDbGlja0hhbmRsZXJ9IHN0eWxlcz17eyBcImZsZXhcIjogXCIwIDAgYXV0b1wiLCBcImJhY2tncm91bmQtY29sb3JcIjogY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50U2VsZWN0aW9uTW9kZSA9PT0gU2VsZWN0aW9uTW9kZS5Db250ZW50ID8gXCJyZWRcIiA6IHVuZGVmaW5lZCwgXCJjb2xvclwiOiBjdXJyZW50QXBwLnN0YXRlLmN1cnJlbnRTZWxlY3Rpb25Nb2RlID09PSBTZWxlY3Rpb25Nb2RlLlN0eWxlcyA/IFwicmVkXCIgOiB1bmRlZmluZWQgfX0+e1NlbGVjdGlvbk1vZGVbY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50U2VsZWN0aW9uTW9kZV19PC9idXR0b24+XHJcbiAgICAgICAgICAgIDxidXR0b24ga2V5PVwiaVwiIG9uY2xpY2s9e2N1cnJlbnRQYWdlUHJldmlldy5wdWJsaXNoQ2xpY2tIYW5kbGVyfSBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIiwgXCJ3aWR0aFwiOiBcImF1dG9cIiB9fT5TYXZlPC9idXR0b24+XHJcbiAgICAgICAgICAgIDxidXR0b24ga2V5PVwialwiIG9uY2xpY2s9e2N1cnJlbnRQYWdlUHJldmlldy5wdWJsaXNoQW5kT3BlbkNsaWNrSGFuZGxlcn0gc3R5bGVzPXt7IFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsIFwid2lkdGhcIjogXCJhdXRvXCIgfX0+U2F2ZSZPcGVuPC9idXR0b24+XHJcbiAgICAgICAgICAgIDxidXR0b24ga2V5PVwia1wiIG9uY2xpY2s9e2N1cnJlbnRQYWdlUHJldmlldy5yZWZyZXNoQ2xpY2tIYW5kbGVyfSBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIiwgXCJ3aWR0aFwiOiBcImF1dG9cIiB9fT5KQVg8L2J1dHRvbj5cclxuICAgICAgICAgICAge2lzUlJCdXR0b25FbmFibGVkID8gPGJ1dHRvbiBrZXk9XCJsXCIgb25jbGljaz17Y3VycmVudFBhZ2VQcmV2aWV3LnJlcGVhdENsaWNrSGFuZGxlcn0gc3R5bGVzPXt7IFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsIFwid2lkdGhcIjogXCJhdXRvXCIgfX0+UlI8L2J1dHRvbj4gOlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJsMFwiIG9uY2xpY2s9e2N1cnJlbnRQYWdlUHJldmlldy5yZXBlYXRDbGlja0hhbmRsZXJ9IHN0eWxlcz17eyBcImZsZXhcIjogXCIwIDAgYXV0b1wiLCBcIndpZHRoXCI6IFwiYXV0b1wiIH19PlJSPC9idXR0b24+fVxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHRvZ2dsZVNpZGVCYXJDb3VudCA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgc2lkZWJhckNvdW50OiBudW1iZXIgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJjaWRcIik7XHJcbiAgICAgICAgaWYgKHNpZGViYXJDb3VudCA+IDAgJiYgc2lkZWJhckNvdW50IDw9IDQpIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS52aXNpYmxlUHJvcGVydHlCYXJNYXhDb3VudCA9IHNpZGViYXJDb3VudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTsgLy8gVE9ET1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHB1Ymxpc2hDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7IC8vIFRPRE8gb3B0aW1pemU6IDEgZXZlbnQgaGFuZGxlciwgY29udHJvbGxlZCBieSBodG1sXHJcbiAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnB1Ymxpc2goZmFsc2UpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcHVibGlzaEFuZE9wZW5DbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnB1Ymxpc2godHJ1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgcHVibGlzaCA9IChpc09wZW46IGJvb2xlYW4pID0+IHtcclxuICAgICAgICBsZXQgY3VycmVudENhbGlmb3JuaWFWaWV3OiBDYWxpZm9ybmlhVmlldyA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5DYWxpZm9ybmlhVmlld3MuZmluZCh2ID0+IHYuQ2FsaWZvcm5pYVZpZXdJZCA9PSBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLmFjdGl2ZUNhbGlmb3JuaWFWaWV3SWQpIGFzIENhbGlmb3JuaWFWaWV3O1xyXG4gICAgICAgIGlmIChpc09wZW4pIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLlB1Ymxpc2hBY3Rpb24oY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFQcm9qZWN0SWQpLmRvbmUoKHJlc3BvbnNlOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24od2luZG93LmxvY2F0aW9uLm9yaWdpbiArIGAvY2FsaWZvcm5pYS9wdWIvJHtjdXJyZW50Q2FsaWZvcm5pYVZpZXcuTmFtZX1gKTsgLy8gVE9ETyBoYXJkY29kZWQgbGluayAvLyBUT0RPIHNlY3VyaXR5IGF1ZGl0XHJcbiAgICAgICAgICAgIH0pLmZhaWwoKHJlcTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLlB1Ymxpc2hBY3Rpb24oY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFQcm9qZWN0SWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlZnJlc2hDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKCFjdXJyZW50QXBwLnN0YXRlLmlzSmF4T24pIHtcclxuICAgICAgICAgICAgLy8gVE9ETyBpcyB0aGlzIGxvYWQgYXN5bmM/IFRPRE8gc2VjdXJpdHkgYXVkaXQgVE9ETyBsb2NhbGl6YXRpb24gVE9ETyBsb2FkIG9mIHNvbWUgc3ViIGRlcGVuZGVudCBmaWxlcyBmYWlscyBUT0RPIGNvZGUgZHVwbGljYXRpb24gKGFsbW9zdCBleGNlcHQgcm9vdCBwYXRoKSB3aXRoIHB1Ymxpc2ggbGF5b3V0XHJcbiAgICAgICAgICAgIC8vIFRPRE8gc2hvd1Byb2Nlc3NpbmdNZXNzYWdlczogZmFsc2UsXHJcbiAgICAgICAgICAgIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLCBzY3JpcHQ7XHJcbiAgICAgICAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XHJcbiAgICAgICAgICAgIHNjcmlwdC50eXBlID0gXCJ0ZXh0L3gtbWF0aGpheC1jb25maWdcIjtcclxuICAgICAgICAgICAgc2NyaXB0LnRleHQgPVxyXG4gICAgICAgICAgICAgICAgXCJNYXRoSmF4Lkh1Yi5Db25maWcoe1xcblwiICtcclxuICAgICAgICAgICAgICAgIFwiICByb290OiBcXFwiLi4vdGhpcmRfcGFydHkvbWF0aGpheFxcXCIsXFxuXCIgK1xyXG4gICAgICAgICAgICAgICAgXCIgIGV4dGVuc2lvbnM6IFtcXFwidGV4MmpheC5qc1xcXCJdLFxcblwiICtcclxuICAgICAgICAgICAgICAgIFwiICBqYXg6IFtcXFwiaW5wdXQvVGVYXFxcIiwgXFxcIm91dHB1dC9IVE1MLUNTU1xcXCJdLFxcblwiICtcclxuICAgICAgICAgICAgICAgIC8vXCIgIHNraXBTdGFydHVwVHlwZXNldDogdHJ1ZSxcXG5cIiArXHJcbiAgICAgICAgICAgICAgICAvL1wiICBjb25maWc6IFtcXFwiVGVYLUFNU19IVE1MLmpzXFxcIl0sXFxuXCIgKyBUT0RPIHRoaXMgc2VlbXMgbm90IHRvIGJlIHJlcXVpcmVkIG9yIGxvYWRlZCBieSBkZWZhdWx0XHJcbiAgICAgICAgICAgICAgICBcIiAgdGV4MmpheDogeyBpbmxpbmVNYXRoOiBbWyckJywnJCddLCBbJ1xcXFxcXFxcKCcsJ1xcXFxcXFxcKSddXSwgc2tpcFRhZ3M6IFtcXFwic2NyaXB0XFxcIixcXFwibm9zY3JpcHRcXFwiLFxcXCJzdHlsZVxcXCIsXFxcInRleHRhcmVhXFxcIixcXFwicHJlXFxcIixcXFwiY29kZVxcXCIsXFxcImlucHV0XFxcIl0sIHByb2Nlc3NFc2NhcGVzOiB0cnVlfSxcXG5cIiArXHJcbiAgICAgICAgICAgICAgICBcIiAgVGVYOiB7IGV4dGVuc2lvbnM6IFtcXFwiQU1TbWF0aC5qc1xcXCIsIFxcXCJBTVNzeW1ib2xzLmpzXFxcIl0sIGVxdWF0aW9uTnVtYmVyczogeyBhdXRvTnVtYmVyOiBcXFwiQU1TXFxcIiB9IH0sIHNob3dQcm9jZXNzaW5nTWVzc2FnZXM6IHRydWUsIG1lc3NhZ2VTdHlsZTpcXFwibm9ybWFsXFxcIixcXG5cIiArXHJcbiAgICAgICAgICAgICAgICBcIiAgXFxcIkhUTUwtQ1NTXFxcIjogeyBhdmFpbGFibGVGb250czogW1xcXCJUZVhcXFwiXSwgcHJlZmVycmVkRm9udDogXFxcIlRlWFxcXCIsIGltYWdlRm9udDogbnVsbCB9XFxuXCIgKyAvKlRPRE8gY29uY2VwdCBmb3IgbGluZWJyZWFrczoge2F1dG9tYXRpYzogdHJ1ZSwgd2lkdGg6IFxcXCJjb250YWluZXJcXFwifSovXHJcbiAgICAgICAgICAgICAgICBcIn0pO1wiO1xyXG4gICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XHJcbiAgICAgICAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XHJcbiAgICAgICAgICAgIHNjcmlwdC50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcclxuICAgICAgICAgICAgLy9zY3JpcHQuc3JjID0gXCIuLi90aGlyZF9wYXJ0eS9tYXRoamF4L01hdGhKYXguanM/ZGVsYXlTdGFydHVwVW50aWw9Y29uZmlndXJlZFwiO1xyXG4gICAgICAgICAgICBzY3JpcHQuc3JjID0gXCIuLi90aGlyZF9wYXJ0eS9tYXRoamF4L01hdGhKYXguanNcIjtcclxuICAgICAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHsgY3VycmVudEFwcC5zdGF0ZS5pc0pheE9uID0gdHJ1ZTsgfTtcclxuICAgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xyXG4gICAgICAgICAgICAvL01hdGhKYXguSHViLkNvbmZpZ3VyZWQoKTsgLy8gVE9ETyBkb3dubG9hZCArIGFjdGl2YXRlIG9uIHVzZXIgcmVxdWVzdCAvIHdoZW4gbGF0ZXggZWxlbWVudHMgYXJlIHRoZXJlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBNYXRoSmF4Lkh1Yi5RdWV1ZShbXCJyZXNldEVxdWF0aW9uTnVtYmVyc1wiLCBNYXRoSmF4LklucHV0SmF4LlRlWF0pO1xyXG4gICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcucmVzZXRFcXVhdGlvbk51bWJlcnNXaGVuTW9kaWZ5aW5nKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlcGVhdENsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5sYXN0Q29tbWFuZCA9PT0gQ2FsaWZvcm5pYUV2ZW50LkNyZWF0ZUxheW91dEJveEZvckJveE9yUm93KSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5DcmVhdGVMYXlvdXRCb3hGb3JCb3hPclJvd0pzb24oY3VycmVudEFwcC5zdGF0ZS5sYXN0Q2FsaWZvcm5pYUV2ZW50RGF0YVswXSBhcyBudW1iZXIsIGN1cnJlbnRBcHAuc3RhdGUubGFzdENhbGlmb3JuaWFFdmVudERhdGFbMV0gYXMgbnVtYmVyKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRBcHAuc3RhdGUubGFzdENvbW1hbmQgPT09IENhbGlmb3JuaWFFdmVudC5DcmVhdGVMYXlvdXRSb3dGb3JWaWV3KSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5DcmVhdGVMYXlvdXRSb3dGb3JWaWV3SnNvbihjdXJyZW50QXBwLnN0YXRlLmxhc3RDYWxpZm9ybmlhRXZlbnREYXRhWzBdIGFzIG51bWJlciwgY3VycmVudEFwcC5zdGF0ZS5sYXN0Q2FsaWZvcm5pYUV2ZW50RGF0YVsxXSBhcyBudW1iZXIpLmRvbmUoZGF0YSA9PiBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE9cclxuICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVzZXRFcXVhdGlvbk51bWJlcnNXaGVuTW9kaWZ5aW5nID0gKGlzUmVwcm9jZXNzOiBib29sZWFuKSA9PiB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUuaXNKYXhPbikge1xyXG4gICAgICAgICAgICAvL01hdGhKYXguSHViLlF1ZXVlKFtcInJlc2V0RXF1YXRpb25OdW1iZXJzXCIsIE1hdGhKYXguSW5wdXRKYXguVGVYXSk7IHRocm93cyBlcnJvcnMgPT4gb24gbWFudWFsIHJlcXVlc3RcclxuICAgICAgICAgICAgaWYgKGlzUmVwcm9jZXNzKSB7XHJcbiAgICAgICAgICAgICAgICBNYXRoSmF4Lkh1Yi5RdWV1ZShbXCJQcmVQcm9jZXNzXCIsIE1hdGhKYXguSHViXSk7IC8vIFRPRE8gb25seSB3aGVuIGNoYW5nZWQgc29tZXRoaW5nIHdpdGggbGFiZWwgYWZ0ZXIgc29tZSBkZWxheVxyXG4gICAgICAgICAgICAgICAgTWF0aEpheC5IdWIuUXVldWUoW1wiUmVwcm9jZXNzXCIsIE1hdGhKYXguSHViXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBwcmV2aWV3Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuaXNIaWRlVXNlckludGVyZmFjZSA9ICFjdXJyZW50QXBwLnN0YXRlLmlzSGlkZVVzZXJJbnRlcmZhY2U7XHJcbiAgICAgICAgY3VycmVudEFwcC5wcm9qZWN0b3IucmVuZGVyTm93KCk7IC8vIFRPRE8gd29ya2Fyb3VuZCAyIHJlbmRlcnMgZm9yIHNwYWNlIGNhbGN1bGF0aW9uID0+IHVzZSBjbGllbnQgd2lkdGggaW5zdGVhZFxyXG4gICAgICAgIGN1cnJlbnRBcHAucmVzaXplQ2hhbmdlZEhhbmRsZXIoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNoYW5nZUVkaXRNb2RlQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCBzZWxlY3RlZEVkaXRWaWV3TW9kZTogRWRpdFZpZXdNb2RlID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwiZWlkXCIpO1xyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLmVkaXRWaWV3TW9kZSA9PT0gc2VsZWN0ZWRFZGl0Vmlld01vZGUpIHtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUuZWRpdFZpZXdNb2RlID09PSBFZGl0Vmlld01vZGUuRGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5lZGl0Vmlld01vZGUgPSBFZGl0Vmlld01vZGUuRGVmYXVsdDtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucHJvamVjdG9yLnJlbmRlck5vdygpOyAvLyBUT0RPIHdvcmthcm91bmQgMiByZW5kZXJzIGZvciBzcGFjZSBjYWxjdWxhdGlvbiA9PiB1c2UgY2xpZW50IHdpZHRoIGluc3RlYWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5lZGl0Vmlld01vZGUgPSBzZWxlY3RlZEVkaXRWaWV3TW9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudEFwcC5yZXNpemVDaGFuZ2VkSGFuZGxlcigpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY2hhbmdlU2VsZWN0aW9uTW9kZUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmN1cnJlbnRTZWxlY3Rpb25Nb2RlID0gY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50U2VsZWN0aW9uTW9kZSA9PT0gU2VsZWN0aW9uTW9kZS5Db250ZW50ID8gU2VsZWN0aW9uTW9kZS5TdHlsZXMgOiBTZWxlY3Rpb25Nb2RlLkNvbnRlbnQ7XHJcbiAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnJlc2V0Q29udGVudEF0b21FZGl0TW9kZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyUmVzcG9uc2l2ZURldmljZVNlbGVjdG9ycyA9ICgpOiBWTm9kZSA9PiB7XHJcbiAgICAgICAgbGV0IHJlc3BvbnNpdmVHcm91cFN0eWxlcyA9IHtcclxuICAgICAgICAgICAgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIixcclxuICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiZmxleFwiLFxyXG4gICAgICAgICAgICBcImZsZXgtZmxvd1wiOiBcInJvdyBub3dyYXBcIlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIDxkaXYga2V5PVwiMVwiIHN0eWxlcz17cmVzcG9uc2l2ZUdyb3VwU3R5bGVzfT5cclxuICAgICAgICAgICAgeyhjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuUmVzcG9uc2l2ZURldmljZXMgIT09IHVuZGVmaW5lZCkgPyBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuUmVzcG9uc2l2ZURldmljZXMubWFwKHIgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIuV2lkdGhUaHJlc2hvbGQgPCAwKSB7IC8vIHJlc3BvbnNpdmUgZGV2aWNlIFwiTm9uZVwiIGNhbiBub3QgYmUgdXNlZCBhcyBvdmVycmlkZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2l2ZUJ1dHRvblN0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBcImZsZXhcIjogXCIwIDAgYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiByLlJlc3BvbnNpdmVEZXZpY2VJZCA9PSBjdXJyZW50QXBwLnN0YXRlLm92ZXJyaWRlUmVzcG9uc2l2ZURldmljZUlkID8gXCJyZWRcIiA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCI6IChyLlJlc3BvbnNpdmVEZXZpY2VJZCA9PSBjdXJyZW50QXBwLnN0YXRlLmN1cnJlbnRSZXNwb25zaXZlRGV2aWNlSWQgJiYgY3VycmVudEFwcC5zdGF0ZS5vdmVycmlkZVJlc3BvbnNpdmVEZXZpY2VJZCA9PSAwKSA/IFwicmVkXCIgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2l2ZURldmljZUlkU3RyaW5nOiBzdHJpbmcgPSByLlJlc3BvbnNpdmVEZXZpY2VJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxidXR0b24ga2V5PXtyZXNwb25zaXZlRGV2aWNlSWRTdHJpbmd9IHJpZD17cmVzcG9uc2l2ZURldmljZUlkU3RyaW5nfSBvbmNsaWNrPXtjdXJyZW50UGFnZVByZXZpZXcuc2VsZWN0UmVzcG9uc2l2ZURldmljZUNsaWNrSGFuZGxlcn0gc3R5bGVzPXtyZXNwb25zaXZlQnV0dG9uU3R5bGVzfT57ci5OYW1lU2hvcnR9ey8qVE9ETyByZWVuYWJsZSwgdGFrZXMgbXVjaCBzcGFjZSAobWluOntyLldpZHRoVGhyZXNob2xkfXB4KSovfTwvYnV0dG9uPiBhcyBWTm9kZTtcclxuICAgICAgICAgICAgfSkgOiB1bmRlZmluZWR9XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2VsZWN0UmVzcG9uc2l2ZURldmljZUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgc2VsZWN0ZWRJZCA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcInJpZFwiKTtcclxuICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5vdmVycmlkZVJlc3BvbnNpdmVEZXZpY2VJZCA9PSBzZWxlY3RlZElkKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUub3ZlcnJpZGVSZXNwb25zaXZlRGV2aWNlSWQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5vdmVycmlkZVJlc3BvbnNpdmVEZXZpY2VJZCA9IHNlbGVjdGVkSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy51cGRhdGVQYWdlUHJldmlld0RpbWVuc2lvbnMoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlbmRlclBhZ2VQcmV2aWV3SG9sZGVyID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICAvLyBwYWdlIHByZXZpZXcgc2l6ZSBkZXBlbmRzIG9uIGN1cnJlbnQgcHJldmlldyBicmVha3BvaW50XHJcbiAgICAgICAgbGV0IHBhZ2VQcmV2aWV3SG9sZGVyU3R5bGVzID0geyAvLyBpbnNpZGUgZmxleC1jb2x1bW4tbm93cmFwXHJcbiAgICAgICAgICAgIFwiZmxleFwiOiBjdXJyZW50QXBwLnN0YXRlLmlzSGlkZVVzZXJJbnRlcmZhY2UgPyBcIjEgMSBhdXRvXCIgOiBcIjEgMSAxMDAlXCIsIC8vIDFweCBmb3IgSUUxMSA9PiAxMDAlIGZvciBpUGFkXHJcbiAgICAgICAgICAgIFwibWFyZ2luXCI6IChjdXJyZW50QXBwLnN0YXRlLmlzSGlkZVVzZXJJbnRlcmZhY2UgfHwgY3VycmVudEFwcC5zdGF0ZS5lZGl0Vmlld01vZGUgPT09IEVkaXRWaWV3TW9kZS5QYWdlUHJldmlld09ubHkpID8gLypUT0RPKi9cIjBcIiA6IGAwICR7Y3VycmVudEFwcC5zdGF0ZS50YXJnZXRQYWdlUHJldmlld0hvbGRlck1hcmdpblB4fXB4YCxcclxuICAgICAgICAgICAgXCJwb3NpdGlvblwiOiBcInJlbGF0aXZlXCIsIC8vIFRPRE8gZG9jdW1lbnQ6IGZvciBmaXhlZCBjb250ZW50XHJcbiAgICAgICAgICAgIFwiaGVpZ2h0XCI6IFwiMTAwJVwiLCAvLyAxMDAlIGZvciBpUGFkXHJcbiAgICAgICAgICAgIFwibWF4LWhlaWdodFwiOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgXCJvdmVyZmxvd1wiOiBcImF1dG9cIlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHNjcm9sbGVkUGFnZVByZXZpZXcgPSB7XHJcbiAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcImZsZXhcIixcclxuICAgICAgICAgICAgXCJmbGV4LWZsb3dcIjogXCJjb2x1bW4gbm93cmFwXCIsXHJcbiAgICAgICAgICAgIC8vXCJvdmVyZmxvd1wiOiBcImF1dG9cIiwgLy8gcGFyZW50IGVsZW1lbnQgb2YgcGFnZSBwcmV2aWV3XHJcbiAgICAgICAgICAgIFwiaGVpZ2h0XCI6IFwiMTAwJVwiLCAvLyAxMDAlIGZvciBpUGFkXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gPGRpdiBrZXk9XCIxXCJcclxuICAgICAgICAgICAgc3R5bGVzPXtwYWdlUHJldmlld0hvbGRlclN0eWxlc31cclxuICAgICAgICAgICAgb25zY3JvbGw9e2N1cnJlbnRQYWdlUHJldmlldy5wYWdlUHJldmlld0hvbGRlclNjcm9sbEhhbmRsZXJ9XHJcbiAgICAgICAgICAgIGFmdGVyQ3JlYXRlPXtjdXJyZW50UGFnZVByZXZpZXcucGFnZVByZXZpZXdIb2xkZXJBZnRlckNyZWF0ZUhhbmRsZXJ9XHJcbiAgICAgICAgICAgIGFmdGVyVXBkYXRlPXtjdXJyZW50UGFnZVByZXZpZXcucGFnZVByZXZpZXdIb2xkZXJBZnRlclVwZGF0ZUhhbmRsZXJ9PlxyXG4gICAgICAgICAgICA8ZGl2IGtleT1cInAwXCIgc3R5bGVzPXtzY3JvbGxlZFBhZ2VQcmV2aWV3fT57Y3VycmVudFBhZ2VQcmV2aWV3LnJlbmRlclBhZ2VQcmV2aWV3KCl9PC9kaXY+XHJcbiAgICAgICAgICAgIHtjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLmZpeGVkTGF5b3V0Um93c1Byb2plY3Rvci5yZXN1bHRzLm1hcChyID0+IHIucmVuZGVyTWFxdWV0dGUoKSl9XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIHBhZ2VQcmV2aWV3SG9sZGVyQWZ0ZXJDcmVhdGVIYW5kbGVyID0gKGVsZW1lbnQ6IEVsZW1lbnQsIHByb2plY3Rpb25PcHRpb25zOiBtYXF1ZXR0ZS5Qcm9qZWN0aW9uT3B0aW9ucywgdm5vZGVTZWxlY3Rvcjogc3RyaW5nLCBwcm9wZXJ0aWVzOiBtYXF1ZXR0ZS5WTm9kZVByb3BlcnRpZXMsIGNoaWxkcmVuOiBWTm9kZVtdKSA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5wYWdlUHJldmlld0hvbGRlciA9IGVsZW1lbnQgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgY3VycmVudEFwcC5yZXNpemVDaGFuZ2VkSGFuZGxlcigpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIHBhZ2VQcmV2aWV3SG9sZGVyQWZ0ZXJVcGRhdGVIYW5kbGVyID0gKGVsZW1lbnQ6IEVsZW1lbnQsIHByb2plY3Rpb25PcHRpb25zOiBtYXF1ZXR0ZS5Qcm9qZWN0aW9uT3B0aW9ucywgdm5vZGVTZWxlY3Rvcjogc3RyaW5nLCBwcm9wZXJ0aWVzOiBtYXF1ZXR0ZS5WTm9kZVByb3BlcnRpZXMsIGNoaWxkcmVuOiBWTm9kZVtdKSA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5wYWdlUHJldmlld0hvbGRlciA9IGVsZW1lbnQgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgLy8gVE9ETyB0aGlzIG1ldGhvZCBydW5zIHdheSB0b28gb2Z0ZW4hP1xyXG4gICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy51cGRhdGVWaXNpYmxlTGF5b3V0QXRvbXMoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBwYWdlUHJldmlld0hvbGRlclNjcm9sbEhhbmRsZXIgPSAoZXZ0OiBVSUV2ZW50KSA9PiB7XHJcbiAgICAgICAgLy8gVE9ETyBkZWxheSByZWNhbGN1bGF0aW9uIHNpbWlsYXIgdG8gcmVzaXplXHJcbiAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUudmlzaWJsZVByb3BlcnR5QmFyTWF4Q291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy51cGRhdGVWaXNpYmxlTGF5b3V0QXRvbXMoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzeW5jU2Nyb2xsUG9zaXRpb25Gcm9tQm94VHJlZSA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgICBpZiAoY3VycmVudEFwcC5wcm9wZXJ0eUJhclZNc1swXS5pc1N5bmNlZFdpdGhQYWdlUHJldmlldykge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudEFwcC5wYWdlUHJldmlld0hvbGRlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3RhdGljT2Zmc2V0UHg6IG51bWJlciA9IGN1cnJlbnRBcHAubmF2aWdhdGlvbkhlaWd0aFB4O1xyXG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldExheW91dEF0b21JZDogbnVtYmVyID0gY3VycmVudEFwcC5wcm9wZXJ0eUJhcnNbMF0ubW9zdFVwcGVyVmlzaWJsZUxheW91dEF0b21JZDtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJwcmV2aWV3IGZyb20gdHJlZSBmb3IgdGFyZ2V0IGxheW91dCAjXCIgKyB0YXJnZXRMYXlvdXRBdG9tSWQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRvbU5vZGVPZlRhcmdldExheW91dDogSFRNTEVsZW1lbnQgfCB1bmRlZmluZWQgPSBjdXJyZW50UGFnZVByZXZpZXcuX3Zpc2libGVMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXMuZmluZChyID0+IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShyLCBcImFpZFwiIC8qVE9ETyB1c2UgZGljdCovKSA9PSB0YXJnZXRMYXlvdXRBdG9tSWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRvbU5vZGVPZlRhcmdldExheW91dCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tTm9kZU9mVGFyZ2V0TGF5b3V0ID0gY3VycmVudFBhZ2VQcmV2aWV3Ll9hY3RpdmVWaWV3TGF5b3V0QXRvbURvbU5vZGVSZWZlcmVuY2VzW3RhcmdldExheW91dEF0b21JZF0gYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5wYWdlUHJldmlld0hvbGRlci5zY3JvbGxUb3AgPSBjdXJyZW50QXBwLnBhZ2VQcmV2aWV3SG9sZGVyLnNjcm9sbFRvcCArIChkb21Ob2RlT2ZUYXJnZXRMYXlvdXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gc3RhdGljT2Zmc2V0UHgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgdXBkYXRlVmlzaWJsZUxheW91dEF0b21zID0gKCkgPT4ge1xyXG4gICAgICAgIC8vIFRPRE8gY2FsbGVkIHRvbyBvZnRlbiBUT0RPIGluaXRpYWwgcmVuZGVyXHJcbiAgICAgICAgbGV0IHBhZ2VQcmV2aWV3SG9sZGVyOiBIVE1MRGl2RWxlbWVudCA9IGN1cnJlbnRBcHAucGFnZVByZXZpZXdIb2xkZXIgYXMgSFRNTERpdkVsZW1lbnQ7XHJcbiAgICAgICAgLy8gdXBkYXRlIHZpc2libGUgbGF5b3V0IGF0b20gZG9tIG5vZGUgcmVmZXJlbmNlc1xyXG4gICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy5fdmlzaWJsZUxheW91dEF0b21Eb21Ob2RlUmVmZXJlbmNlcyA9IFtdO1xyXG4gICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy5fdmlzaWJsZUxheW91dEF0b21LZXlzID0gW107XHJcbiAgICAgICAgbGV0IHByb2Nlc3NlZEVsZW1lbnRDb3VudDogbnVtYmVyID0gMDtcclxuICAgICAgICBsZXQgbW9zdFVwcGVyVmlzaWJsZUluZGV4OiBudW1iZXIgPSAtMTtcclxuICAgICAgICBsZXQgbW9zdFVwcGVyVmlzaWJsZUxheW91dEF0b21JZDogbnVtYmVyID0gMDtcclxuICAgICAgICBsZXQgbW9zdFVwcGVyVmlzaWJsZURlbHRhVG9wTGVmdDogbnVtYmVyID0gcGFnZVByZXZpZXdIb2xkZXIuY2xpZW50SGVpZ2h0ICsgMTsgLy8gb3RoZXJ3aXNlIGVsZW1lbnQgaXMgYmVsb3cgdmlzaWJsZSBhcmVhXHJcbiAgICAgICAgbGV0IHN0YXRpY09mZnNldFB4OiBudW1iZXIgPSBjdXJyZW50QXBwLm5hdmlnYXRpb25IZWlndGhQeDsgLy8gVE9ETyBldmVyeXdoZXJlOiBwaXhlbCBhbGlhc2luZyBhcmUgbWF5YmUgYmVjYXVzZSBjb21wYXJpbmcgbm90IG51bWVyaWNhbGx5LCBidXQgc3RyaWN0bHkgKGVwcylcclxuICAgICAgICBsZXQgY3VycmVudFNjcm9sbFRvcDogbnVtYmVyID0gcGFnZVByZXZpZXdIb2xkZXIuc2Nyb2xsVG9wO1xyXG4gICAgICAgIGxldCBtaW5YUHJldmlldzogbnVtYmVyID0gMDsgLy8gMCBiYXNlZCBmb3IgdG9wIGxlZnQgY29ybmVyIGluIHZpZXdwb3J0L3BhZ2VwcmV2aWV3XHJcbiAgICAgICAgbGV0IG1heFhQcmV2aWV3OiBudW1iZXIgPSBwYWdlUHJldmlld0hvbGRlci5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcInNjcm9sbGVkIHByZXZpZXcgdG9cIiArIGN1cnJlbnRTY3JvbGxUb3AgKyBcIiBhdCBjbGllbnQgaGVpZ2h0IFwiICsgcGFnZVByZXZpZXdIb2xkZXIuY2xpZW50SGVpZ2h0ICsgXCIgZnJvbSBtYXggaGVpZ2h0XCIgKyBwYWdlUHJldmlld0hvbGRlci5zY3JvbGxIZWlnaHQgICsgXCIgbWluWCBcIiArIG1pblhQcmV2aWV3ICsgXCIgbWF4WFwiICsgbWF4WFByZXZpZXcpO1xyXG4gICAgICAgIGZvcihsZXQgZWxlbWVudEtleSBpbiBjdXJyZW50UGFnZVByZXZpZXcuX2FjdGl2ZVZpZXdMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXMpIHtcclxuICAgICAgICAgICAgLy8gVE9ETyBvcmRlciBhbGwgbGF5b3V0IGVsZW1lbnRzIGFuZCBwcm9jZXNzIG9ubHkgc3BlY2lmaWMgcmFuZ2Ugb3IgbW92ZSBwcm9jZXNzaW5nIHJhbmdlIHdpdGggc2Nyb2xsXHJcbiAgICAgICAgICAgIGxldCBkb21Ob2RlOiBIVE1MRWxlbWVudCA9IGN1cnJlbnRQYWdlUHJldmlldy5fYWN0aXZlVmlld0xheW91dEF0b21Eb21Ob2RlUmVmZXJlbmNlc1tlbGVtZW50S2V5XTtcclxuICAgICAgICAgICAgbGV0IGlzRG9tTm9kZVZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInByb2Nlc3NpbmcgZWxlbWVudDogY2xpZW50VG9wIFwiICsgZG9tTm9kZS5jbGllbnRIZWlnaHQgKyBcIiwgb2Zmc2V0VG9wIFwiICsgZG9tTm9kZS5vZmZzZXRUb3ApO1xyXG4gICAgICAgICAgICBsZXQgYm91bmRpbmdSZWN0RWxlbWVudDogQ2xpZW50UmVjdCA9IGRvbU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgIC8vbGV0IGZpcnN0Q2xpZW50UmVjdEVsZW1lbnQ6IENsaWVudFJlY3QgPSBkb21Ob2RlLmdldENsaWVudFJlY3RzKClbMF07XHJcbiAgICAgICAgICAgIGxldCBtaW5YRWxlbWVudERlbHRhVG9wTGVmdDogbnVtYmVyID0gYm91bmRpbmdSZWN0RWxlbWVudC50b3AgLSBzdGF0aWNPZmZzZXRQeDtcclxuICAgICAgICAgICAgbGV0IG1heFhFbGVtZW50RGVsdGFCb3R0b21MZWZ0OiBudW1iZXIgPSBwYWdlUHJldmlld0hvbGRlci5jbGllbnRIZWlnaHQgLSAoYm91bmRpbmdSZWN0RWxlbWVudC50b3AgLSBzdGF0aWNPZmZzZXRQeCArIGN1cnJlbnRTY3JvbGxUb3AgKyBib3VuZGluZ1JlY3RFbGVtZW50LmhlaWdodCkgKyBjdXJyZW50U2Nyb2xsVG9wO1xyXG4gICAgICAgICAgICBpZiAoYm91bmRpbmdSZWN0RWxlbWVudC5oZWlnaHQgPiAwKSB7IC8vIGhlaWdodCBjYW4gYmUgMCA9PiBpbnZpc2libGVcclxuICAgICAgICAgICAgICAgIGlmIChtaW5YRWxlbWVudERlbHRhVG9wTGVmdCA+PSAwLjAgJiYgbWluWEVsZW1lbnREZWx0YVRvcExlZnQgPD0gcGFnZVByZXZpZXdIb2xkZXIuY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNEb21Ob2RlVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXhYRWxlbWVudERlbHRhQm90dG9tTGVmdCA+PSAwLjAgJiYgbWF4WEVsZW1lbnREZWx0YUJvdHRvbUxlZnQgPD0gcGFnZVByZXZpZXdIb2xkZXIuY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNEb21Ob2RlVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtaW5YRWxlbWVudERlbHRhVG9wTGVmdCA8PSAwLjAgJiYgbWF4WEVsZW1lbnREZWx0YUJvdHRvbUxlZnQgPD0gMC4wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNEb21Ob2RlVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImVsZW1lbnQ6IGJvdW5kaW5nIHJlY3QgdG9wIFwiICsgYm91bmRpbmdSZWN0RWxlbWVudC50b3AgKyBcIiwgcmVjdCBib3R0b20gXCIgKyBib3VuZGluZ1JlY3RFbGVtZW50LmJvdHRvbSArIFwiLCBtaW5YRWxlbWVudERlbHRhVG9wTGVmdDogXCIgKyBtaW5YRWxlbWVudERlbHRhVG9wTGVmdCArIFwiLCBtYXhYRWxlbWVudERlbHRhQm90dG9tTGVmdDogXCIgKyBtYXhYRWxlbWVudERlbHRhQm90dG9tTGVmdCk7XHJcbiAgICAgICAgICAgIGlmIChpc0RvbU5vZGVWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcuX3Zpc2libGVMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXMucHVzaChkb21Ob2RlKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy5fdmlzaWJsZUxheW91dEF0b21LZXlzLnB1c2goZWxlbWVudEtleSk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwidmlzaWJsZSBlbGVtZW50OiBmaXJzdCBjbGllbnQgcmVjdCB0b3AgXCIgKyBmaXJzdENsaWVudFJlY3RFbGVtZW50LnRvcCArIFwiLCByZWN0IGJvdHRvbSBcIiArIGZpcnN0Q2xpZW50UmVjdEVsZW1lbnQuYm90dG9tKTtcclxuICAgICAgICAgICAgICAgIGlmIChtaW5YRWxlbWVudERlbHRhVG9wTGVmdCA8IG1vc3RVcHBlclZpc2libGVEZWx0YVRvcExlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3N0VXBwZXJWaXNpYmxlRGVsdGFUb3BMZWZ0ID0gbWluWEVsZW1lbnREZWx0YVRvcExlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9zdFVwcGVyVmlzaWJsZUluZGV4ID0gY3VycmVudFBhZ2VQcmV2aWV3Ll92aXNpYmxlTGF5b3V0QXRvbUtleXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vc3RVcHBlclZpc2libGVMYXlvdXRBdG9tSWQgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZG9tTm9kZSwgXCJhaWRcIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1vc3RVcHBlclZpc2libGVMYXlvdXRBdG9tSWQgIT0gY3VycmVudFBhZ2VQcmV2aWV3Ll9tb3N0VXBwZXJWaXNpYmxlTGF5b3V0QXRvbUlkKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcuX21vc3RVcHBlclZpc2libGVMYXlvdXRBdG9tSWQgPSBtb3N0VXBwZXJWaXNpYmxlTGF5b3V0QXRvbUlkO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1vc3RVcHBlclZpc2libGVMYXlvdXRBdG9tSWQgIT0gMCAmJiBjdXJyZW50QXBwLnByb3BlcnR5QmFyVk1zWzBdLmlzU3luY2VkV2l0aFBhZ2VQcmV2aWV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5wcm9wZXJ0eUJhcnNbMF0uc3luY1Njcm9sbFBvc2l0aW9uRnJvbVBhZ2VQcmV2aWV3KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJvY2Vzc2VkRWxlbWVudENvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJwYWdlUHJldmlldyBzY3JvbGw6IHByb2Nlc3NlZCBcIiArIHByb2Nlc3NlZEVsZW1lbnRDb3VudCArIFwiIG9iamVjdCBwb3NpdGlvbnMsIHZpc2libGU6IFwiICsgY3VycmVudFBhZ2VQcmV2aWV3Ll92aXNpYmxlTGF5b3V0QXRvbURvbU5vZGVSZWZlcmVuY2VzLmxlbmd0aC50b1N0cmluZygpICsgXCIgbW9zdCB1cHBlciB2aXNpYmxlIGluZGV4OiBcIiArIG1vc3RVcHBlclZpc2libGVJbmRleCArIFwiIG1vc3QgdXBwZXIgdmlzaWJsZSBsYXlvdXQgaWQ6IFwiICsgY3VycmVudFBhZ2VQcmV2aWV3Ll9tb3N0VXBwZXJWaXNpYmxlTGF5b3V0QXRvbUlkKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyUGFnZVByZXZpZXcgPSAoKTogVk5vZGUgPT4ge1xyXG4gICAgICAgIC8vIFRPRE8gZG8gbm90IHNldCB3aGVuIGJvZHkgaGVpZ2h0IGlzIHNldCBpbiBjdXJyZW50IHZpZXdcclxuICAgICAgICBsZXQgcGFnZVByZXZpZXdTdHlsZXMgPSB7XHJcbiAgICAgICAgICAgIC8vVE9ETyBcImZsZXhcIjogXCIxIDEgYXV0b1wiLCAvLyAxcHggZm9yIElFMTEgPT4gYXV0byBmb3IgaVBob25lXHJcbiAgICAgICAgICAgIC8vXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVcIixcclxuICAgICAgICAgICAgXCJ3aWR0aFwiOiAoY3VycmVudEFwcC5zdGF0ZS5pc0RhdGFMb2FkZWQgJiYgIWN1cnJlbnRBcHAuc3RhdGUuaXNFbm91Z2hBdmFpbGFibGVTcGFjZVBhZ2VQcmV2aWV3KSA/IChjdXJyZW50QXBwLnN0YXRlLnRhcmdldFBhZ2VQcmV2aWV3V2lkdGhQeCkgKyBcInB4XCIgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcImZsZXhcIixcclxuICAgICAgICAgICAgLy9UT0RPIFwiaGVpZ2h0XCI6IFwiMXB4XCIgLy8gVE9ETyBjdXJyZW50QXBwLnN0YXRlLmlzSGlkZVVzZXJJbnRlcmZhY2UgPyAvKlRPRE8qL1wiMTAwJVwiIDogXCJhdXRvXCIsIC8vIDFweCA9PiBhdXRvIGZvciBpUGhvbmVcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBpc1JlbmRlclZpZXc6IGJvb2xlYW4gPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ2FsaWZvcm5pYVZpZXdzICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IGNhbGlmb3JuaWFWaWV3Qm9keVN0eWxlU3RyaW5nOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5DYWxpZm9ybmlhVmlld3MgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjYWxpZm9ybmlhVmlld0JvZHlTdHlsZVN0cmluZyA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ2FsaWZvcm5pYVZpZXdzLmZpbmQodiA9PiB2LkNhbGlmb3JuaWFWaWV3SWQgPT0gY3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC5hY3RpdmVDYWxpZm9ybmlhVmlld0lkKSBhcyBDYWxpZm9ybmlhVmlldykuU3BlY2lhbFN0eWxlQm9keVN0eWxlU3RyaW5nOyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNSZW5kZXJWaWV3ID8gPGRpdiBrZXk9e2B2cCR7Y3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC5hY3RpdmVDYWxpZm9ybmlhVmlld0lkfWB9IGNsYXNzPXtjYWxpZm9ybmlhVmlld0JvZHlTdHlsZVN0cmluZ30gc3R5bGVzPXtwYWdlUHJldmlld1N0eWxlc30+XHJcbiAgICAgICAgICAgIHtjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLmNhbGlmb3JuaWFWaWV3UHJvamVjdG9yLnJlc3VsdHMubWFwKHIgPT4gci5yZW5kZXJNYXF1ZXR0ZSgpKX1cclxuICAgICAgICAgICAgPC9kaXY+IGFzIFZOb2RlIDogPGRpdiBrZXk9XCJ2cDBcIiBzdHlsZXM9e3BhZ2VQcmV2aWV3U3R5bGVzfT48L2Rpdj4gYXMgVk5vZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJDYWxpZm9ybmlhVmlld0FycmF5ID0gKCk6IG1hcXVldHRlLk1hcHBpbmc8Q2FsaWZvcm5pYVZpZXcsIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+ID0+IHtcclxuICAgICAgICByZXR1cm4gbWFxdWV0dGUuY3JlYXRlTWFwcGluZzxDYWxpZm9ybmlhVmlldywgYW55PihcclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U2VjdGlvblNvdXJjZUtleShzb3VyY2U6IENhbGlmb3JuaWFWaWV3KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlLkNhbGlmb3JuaWFWaWV3SWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb25UYXJnZXQoc291cmNlOiBDYWxpZm9ybmlhVmlldykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZUNhbGlmb3JuaWFWaWV3SWRTdHJpbmcgPSBzb3VyY2UuQ2FsaWZvcm5pYVZpZXdJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxheW91dFJvd3MgPSBjdXJyZW50UGFnZVByZXZpZXcucmVuZGVyTGF5b3V0Um93QXJyYXkoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0Um93cy5tYXAoc291cmNlLlBsYWNlZExheW91dFJvd3MpO1xyXG4gICAgICAgICAgICAgICAgLy8gLS0tIFRPRE8gY29kZSBkdXBsaWNhdGlvblxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAvLyAtLS0gY29kZSBkdXBsaWNhdGlvbiBlbmRcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gc2hvdyBib2R5K2h0bWwgc3R5bGUgbW9sZWN1bGUgaW4gcGFnZSBwcmV2aWV3XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlck1hcXVldHRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjYWxpZm9ybmlhVmlld1N0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxleFwiOiBcIjEgMSAxcHhcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPGRpdiBjbGFzcz17c291cmNlLlNwZWNpYWxTdHlsZVZpZXdTdHlsZVN0cmluZ30ga2V5PXtzb3VyY2VDYWxpZm9ybmlhVmlld0lkU3RyaW5nfSBpZD17YGNhbGlmb3JuaWEtdiR7c291cmNlLkNhbGlmb3JuaWFWaWV3SWR9XyR7c291cmNlLk5hbWV9YH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZD17c291cmNlQ2FsaWZvcm5pYVZpZXdJZFN0cmluZ30gc3R5bGVzPXtjYWxpZm9ybmlhVmlld1N0eWxlc30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bGF5b3V0Um93cy5yZXN1bHRzLm1hcChyID0+IHIucmVuZGVyTWFxdWV0dGUoKSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PjtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKHVwZGF0ZWRTb3VyY2U6IENhbGlmb3JuaWFWaWV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHVwZGF0ZWRTb3VyY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dFJvd3MubWFwKHNvdXJjZS5QbGFjZWRMYXlvdXRSb3dzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQ2FsaWZvcm5pYVZpZXdJZFN0cmluZyA9IHNvdXJjZS5DYWxpZm9ybmlhVmlld0lkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlU2VjdGlvblRhcmdldCh1cGRhdGVkU291cmNlOiBDYWxpZm9ybmlhVmlldywgdGFyZ2V0OiB7IHJlbmRlck1hcXVldHRlKCk6IGFueSwgdXBkYXRlKHVwZGF0ZWRTb3VyY2U6IENhbGlmb3JuaWFWaWV3KTogdm9pZCB9KSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQudXBkYXRlKHVwZGF0ZWRTb3VyY2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlbmRlckxheW91dFJvd0FycmF5ID0gKGlzUmVuZGVyRml4ZWRMYXlvdXQ6IGJvb2xlYW4pOiBtYXF1ZXR0ZS5NYXBwaW5nPExheW91dFJvdywgeyByZW5kZXJNYXF1ZXR0ZTogKCkgPT4gbWFxdWV0dGUuVk5vZGUgfT4gPT4geyAvLyBUT0RPIGNvZGUgZHVwbGljYXRpb24gd2l0aCBwYWdlIHByZXZpZXdcclxuICAgICAgICByZXR1cm4gbWFxdWV0dGUuY3JlYXRlTWFwcGluZzxMYXlvdXRSb3csIGFueT4oXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFNlY3Rpb25Tb3VyY2VLZXkoc291cmNlOiBMYXlvdXRSb3cpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2UuTGF5b3V0QmFzZUlkO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVTZWN0aW9uVGFyZ2V0KHNvdXJjZTogTGF5b3V0Um93KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc291cmNlTGF5b3V0Um93SWRTdHJpbmcgPSBzb3VyY2UuTGF5b3V0QmFzZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVNb2xlY3VsZTogU3R5bGVNb2xlY3VsZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcy5maW5kKG0gPT4gbS5TdHlsZUZvckxheW91dElkID09IHNvdXJjZS5MYXlvdXRCYXNlSWQpIGFzIFN0eWxlTW9sZWN1bGU7IC8vIFRPRE8gZXhwZW5zaXZlXHJcbiAgICAgICAgICAgICAgICBsZXQgbGF5b3V0Qm94TWFwcGluZyA9IGN1cnJlbnRQYWdlUHJldmlldy5yZW5kZXJMYXlvdXRCb3hBcnJheShpc1JlbmRlckZpeGVkTGF5b3V0LCBzdHlsZU1vbGVjdWxlLklzUG9zaXRpb25GaXhlZCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgdW5zb3J0ZWRCb3hlczogTGF5b3V0Qm94W10gPSBzb3VyY2UuQWxsQm94ZXNCZWxvd1Jvdy5maWx0ZXIoYiA9PiBiLlBsYWNlZEJveEluQm94SWQgPT09IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc29ydGVkQm94ZXM6IExheW91dEJveFtdID0gdW5zb3J0ZWRCb3hlcy5zb3J0KChib3hBOiBMYXlvdXRCb3gsIGJveEI6IExheW91dEJveCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib3hBLkxheW91dFNvcnRPcmRlcktleSA8IGJveEIuTGF5b3V0U29ydE9yZGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYm94QS5MYXlvdXRTb3J0T3JkZXJLZXkgPT0gYm94Qi5MYXlvdXRTb3J0T3JkZXJLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBib3hBLkxheW91dFNvcnRPcmRlcktleSA+IGJveEIuTGF5b3V0U29ydE9yZGVyS2V5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0Qm94TWFwcGluZy5tYXAoc29ydGVkQm94ZXMpO1xyXG4gICAgICAgICAgICAgICAgLy8gLS0tIFRPRE8gY29kZSBkdXBsaWNhdGlvbiAvLyBUT0RPIGZpeCBtYXgtd2lkdGggZm9yIHJlc3BvbnNpdmUgdmlld3MgLy8gVE9ETyBmaXggZm9yIGJvdHRvbS9yaWdodCBpbnN0ZWFkIG9mIHRvcC9sZWZ0IC8vIFRPRE8gZml4IGZvciBpc0hpZGVVc2VySW50ZXJmYWNlIC8vIFRPRE8gdHJ5IHJlbmRlcmluZyBmaXhlZCBpdGVtcyBhcyBhYnNvbHV0ZSBwb3NpdGlvbmVkIGRpcmVjdGx5IHVuZGVyIHBhZ2UgcHJldmlldyBob2xkZXJcclxuICAgICAgICAgICAgICAgIGxldCBwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZCB9O1xyXG4gICAgICAgICAgICAgICAgbGV0IG1hcmdpblRvcE92ZXJyaWRlVmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGxldCB0b3BPdmVycmlkZVZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWFyZ2luTGVmdE92ZXJyaWRlVmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGlmIChzdHlsZU1vbGVjdWxlLklzUG9zaXRpb25GaXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcE92ZXJyaWRlVmFsdWUgPSBgJHtzdHlsZU1vbGVjdWxlLlRvcENzc1ZhbHVlUHh9cHhgO1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcE92ZXJyaWRlVmFsdWUgPSBzdHlsZU1vbGVjdWxlLlRvcENzc1ZhbHVlUHggIT09IHVuZGVmaW5lZCA/IGAke2N1cnJlbnRBcHAubmF2aWdhdGlvbkhlaWd0aFB4fXB4YCA6IHVuZGVmaW5lZDsgLy8gVE9ETyBleHBlbnNpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdE92ZXJyaWRlVmFsdWUgPSBgJHtzdHlsZU1vbGVjdWxlLkxlZnRDc3NWYWx1ZVB4fXB4YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcE92ZXJyaWRlVmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9wT3ZlcnJpZGVWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0T3ZlcnJpZGVWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIC0tLSBUT0RPIGNvZGUgZHVwbGljYXRpb24gZW5kXHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVNb2xlY3VsZUlkOiBudW1iZXIgPSBzdHlsZU1vbGVjdWxlLlN0eWxlTW9sZWN1bGVJZDtcclxuICAgICAgICAgICAgICAgIGxldCBzdHlsZU1vbGVjdWxlSWRTdHJpbmc6IHN0cmluZyA9IHN0eWxlTW9sZWN1bGVJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxheW91dFJvd1N0eWxlQ2xhc3M6IHN0cmluZyA9IGBzJHtzdHlsZU1vbGVjdWxlSWRTdHJpbmd9YDtcclxuICAgICAgICAgICAgICAgIGxldCBob2xkZXJLZXlTdHJpbmc6IHN0cmluZyA9IGAke2lzUmVuZGVyRml4ZWRMYXlvdXQgPyBcImZcIiA6IFwiZ1wifSR7c291cmNlTGF5b3V0Um93SWRTdHJpbmd9YDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTWFxdWV0dGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlbmRlcmVkTGF5b3V0Qm94ZXM6IFZOb2RlW10gPSBsYXlvdXRCb3hNYXBwaW5nLnJlc3VsdHMubGVuZ3RoID4gMCA/IGxheW91dEJveE1hcHBpbmcucmVzdWx0cy5tYXAociA9PiByLnJlbmRlck1hcXVldHRlKCkpIDogW107IC8qVE9ETyA8ZGl2IGtleT1cIi0xXCI+PHA+QWRkIGNvbHVtbnMuLi48L3A+PC9kaXY+Ki9cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzSG92ZXJlZEluQm94VHJlZTogYm9vbGVhbiA9IGN1cnJlbnRBcHAuc3RhdGUuaG92ZXJlZEJveFRyZWVMYXlvdXRCYXNlSWQgPT0gc291cmNlLkxheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1JlbmRlckZpeGVkTGF5b3V0ICYmIHN0eWxlTW9sZWN1bGUuSXNQb3NpdGlvbkZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZU1vbGVjdWxlLklzUG9zaXRpb25GaXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKlwibWFyZ2luLXRvcFwiOiBtYXJnaW5Ub3BPdmVycmlkZVZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLWxlZnRcIjogbWFyZ2luTGVmdE92ZXJyaWRlVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0b3BcIjogdG9wT3ZlcnJpZGVWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImxlZnRcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWF4LXdpZHRoXCI6IHVuZGVmaW5lZCwqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicG9zaXRpb25cIjogXCJhYnNvbHV0ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmVuZGVyRml4ZWRMYXlvdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVuZGVyZWRMYXlvdXRCb3hlcy5maWx0ZXIodiA9PiB2ICE9PSB1bmRlZmluZWQpLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKlwibWFyZ2luLXRvcFwiOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tbGVmdFwiOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0b3BcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGVmdFwiOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXgtd2lkdGhcIjogdW5kZWZpbmVkLCovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwb3NpdGlvblwiOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlc1tcImJhY2tncm91bmQtY29sb3JcIl0gPSBpc0hvdmVyZWRJbkJveFRyZWUgPyBISUdITElHSFRfQkFDS0dST1VORF9DT0xPUl9TVFJJTkcgOiB1bmRlZmluZWQ7ICAvLyBUT0RPIGhpZ2hsaWdodCBmaXJzdCBhdG9tIG9yIGRyYXcgb3V0bGluZSBpbnN0ZWFkIChhdG9tIGJnLWNvbG9yIGNhbiBvdmVycmlkZSA9PiBubyBoaWdobGlnaHQgdmlzaWJsZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5MYXlvdXRCYXNlSWQgPT0gY3VycmVudEFwcC5zdGF0ZS5oaWdobGlnaHRlZExheW91dEJhc2VJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlc1tcIm91dGxpbmVcIl0gPSBcInNvbGlkIDFweCBibGFja1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlc1tcIm91dGxpbmUtb2Zmc2V0XCJdID0gXCItMXB4XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzW1wiYmFja2dyb3VuZC1jb2xvclwiXSA9IE1BTlVBTExZX0hJR0hMSUdIVF9CQUNLR1JPVU5EX0NPTE9SX1NUUklORztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJvdXRsaW5lXCJdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlc1tcIm91dGxpbmUtb2Zmc2V0XCJdID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZU1vbGVjdWxlLklzUG9zaXRpb25GaXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9wYWdlUHJldmlld092ZXJyaWRlU3R5bGVzW1wibWF4LXdpZHRoXCJdID0gc3R5bGVNb2xlY3VsZS5Jc1Bvc2l0aW9uRml4ZWQgJiYgY3VycmVudEFwcC5zdGF0ZS5pc0RhdGFMb2FkZWQgJiYgY3VycmVudEFwcC5zdGF0ZS5pc0Vub3VnaEF2YWlsYWJsZVNwYWNlUGFnZVByZXZpZXcgJiYgY3VycmVudEFwcC5zdGF0ZS5lZGl0Vmlld01vZGUgIT09IEVkaXRWaWV3TW9kZS5QYWdlUHJldmlld09ubHkgPyBgJHtjdXJyZW50QXBwLnN0YXRlLnRhcmdldFBhZ2VQcmV2aWV3V2lkdGhQeH1weGAgOiB1bmRlZmluZWQ7IC8vIFRPRE8gZXhwZW5zaXZlIFRPRE8gZHVwbGljYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlc1tcImxlZnRcIl0gPSBzdHlsZU1vbGVjdWxlLklzUG9zaXRpb25GaXhlZCAmJiBzdHlsZU1vbGVjdWxlLkxlZnRDc3NWYWx1ZVB4ICE9PSB1bmRlZmluZWQgPyBgJHtwYXJzZUludChzdHlsZU1vbGVjdWxlLkxlZnRDc3NWYWx1ZVB4KSArIGN1cnJlbnRBcHAuc3RhdGUudGFyZ2V0UGFnZVByZXZpZXdIb2xkZXJNYXJnaW5QeH1weGAgOiB1bmRlZmluZWQ7IC8vIFRPRE8gZXhwZW5zaXZlIC8vIFRPRE8gZGFuZ2Vyb3VzIC8vIFRPRE8gbWFnaWMgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYga2V5PXtob2xkZXJLZXlTdHJpbmd9IGNsYXNzPXtsYXlvdXRSb3dTdHlsZUNsYXNzfSBzdHlsZXM9e3BhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3JlbmRlcmVkTGF5b3V0Qm94ZXN9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKHVwZGF0ZWRTb3VyY2U6IExheW91dFJvdykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSB1cGRhdGVkU291cmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VMYXlvdXRSb3dJZFN0cmluZyA9IHNvdXJjZS5MYXlvdXRCYXNlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVNb2xlY3VsZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcy5maW5kKG0gPT4gbS5TdHlsZUZvckxheW91dElkID09IHNvdXJjZS5MYXlvdXRCYXNlSWQpIGFzIFN0eWxlTW9sZWN1bGU7IC8vIFRPRE8gZXhwZW5zaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEJveE1hcHBpbmcgPSBjdXJyZW50UGFnZVByZXZpZXcucmVuZGVyTGF5b3V0Qm94QXJyYXkoaXNSZW5kZXJGaXhlZExheW91dCwgc3R5bGVNb2xlY3VsZS5Jc1Bvc2l0aW9uRml4ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnNvcnRlZEJveGVzID0gc291cmNlLkFsbEJveGVzQmVsb3dSb3cuZmlsdGVyKGIgPT4gYi5QbGFjZWRCb3hJbkJveElkID09PSB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0ZWRCb3hlcyA9IHVuc29ydGVkQm94ZXMuc29ydCgoYm94QTogTGF5b3V0Qm94LCBib3hCOiBMYXlvdXRCb3gpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib3hBLkxheW91dFNvcnRPcmRlcktleSA8IGJveEIuTGF5b3V0U29ydE9yZGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYm94QS5MYXlvdXRTb3J0T3JkZXJLZXkgPT0gYm94Qi5MYXlvdXRTb3J0T3JkZXJLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBib3hBLkxheW91dFNvcnRPcmRlcktleSA+IGJveEIuTGF5b3V0U29ydE9yZGVyS2V5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRCb3hNYXBwaW5nLm1hcChzb3J0ZWRCb3hlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0tLSBUT0RPIGNvZGUgZHVwbGljYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlTW9sZWN1bGUuSXNQb3NpdGlvbkZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3BPdmVycmlkZVZhbHVlID0gYCR7c3R5bGVNb2xlY3VsZS5Ub3BDc3NWYWx1ZVB4fXB4YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcE92ZXJyaWRlVmFsdWUgPSBzdHlsZU1vbGVjdWxlLlRvcENzc1ZhbHVlUHggIT09IHVuZGVmaW5lZCA/IGAke2N1cnJlbnRBcHAubmF2aWdhdGlvbkhlaWd0aFB4fXB4YCA6IHVuZGVmaW5lZDsgLy8gVE9ETyBleHBlbnNpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0T3ZlcnJpZGVWYWx1ZSA9IGAke3N0eWxlTW9sZWN1bGUuTGVmdENzc1ZhbHVlUHh9cHhgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wT3ZlcnJpZGVWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcE92ZXJyaWRlVmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0T3ZlcnJpZGVWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAtLS0gVE9ETyBjb2RlIGR1cGxpY2F0aW9uIGVuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZU1vbGVjdWxlSWQgPSBzdHlsZU1vbGVjdWxlLlN0eWxlTW9sZWN1bGVJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVNb2xlY3VsZUlkU3RyaW5nID0gc3R5bGVNb2xlY3VsZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dFJvd1N0eWxlQ2xhc3MgPSBgcyR7c3R5bGVNb2xlY3VsZUlkfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlcktleVN0cmluZyA9IGAke2lzUmVuZGVyRml4ZWRMYXlvdXQgPyBcImZcIiA6IFwiZ1wifSR7c291cmNlTGF5b3V0Um93SWRTdHJpbmd9YDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVTZWN0aW9uVGFyZ2V0KHVwZGF0ZWRTb3VyY2U6IExheW91dFJvdywgdGFyZ2V0OiB7IHJlbmRlck1hcXVldHRlKCk6IGFueSwgdXBkYXRlKHVwZGF0ZWRTb3VyY2U6IExheW91dFJvdyk6IHZvaWQgfSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnVwZGF0ZSh1cGRhdGVkU291cmNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgcmVuZGVyTGF5b3V0Qm94QXJyYXkgPSAoaXNSZW5kZXJGaXhlZExheW91dDogYm9vbGVhbiwgaXNMYXlvdXRCb3hJbnNpZGVGaXhlZDogYm9vbGVhbik6IG1hcXVldHRlLk1hcHBpbmc8TGF5b3V0Qm94LCB7IHJlbmRlck1hcXVldHRlOiAoKSA9PiBtYXF1ZXR0ZS5WTm9kZSB9PiA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG1hcXVldHRlLmNyZWF0ZU1hcHBpbmc8TGF5b3V0Qm94LCBhbnk+KFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRTZWN0aW9uU291cmNlS2V5KHNvdXJjZTogTGF5b3V0Qm94KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlLkxheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlU2VjdGlvblRhcmdldChzb3VyY2U6IExheW91dEJveCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZUxheW91dEJveElkU3RyaW5nID0gc291cmNlLkxheW91dEJhc2VJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlTW9sZWN1bGU6IFN0eWxlTW9sZWN1bGUgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChtID0+IG0uU3R5bGVGb3JMYXlvdXRJZCA9PSBzb3VyY2UuTGF5b3V0QmFzZUlkKSBhcyBTdHlsZU1vbGVjdWxlOyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgbGV0IHJlbmRlcmVkTGF5b3V0QXRvbXMgPSBjdXJyZW50UGFnZVByZXZpZXcucmVuZGVyTGF5b3V0QXRvbUFycmF5KGlzUmVuZGVyRml4ZWRMYXlvdXQsIHN0eWxlTW9sZWN1bGUuSXNQb3NpdGlvbkZpeGVkIHx8IGlzTGF5b3V0Qm94SW5zaWRlRml4ZWQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlbmRlcmVkTGF5b3V0Qm94ZXMgPSBjdXJyZW50UGFnZVByZXZpZXcucmVuZGVyTGF5b3V0Qm94QXJyYXkoaXNSZW5kZXJGaXhlZExheW91dCwgc3R5bGVNb2xlY3VsZS5Jc1Bvc2l0aW9uRml4ZWQgfHwgaXNMYXlvdXRCb3hJbnNpZGVGaXhlZCk7XHJcbiAgICAgICAgICAgICAgICAvLyAtLS0gVE9ETyBjb2RlIGR1cGxpY2F0aW9uIC8vIFRPRE8gZml4IG1heC13aWR0aCBmb3IgcmVzcG9uc2l2ZSB2aWV3cyAvLyBUT0RPIGZpeCBmb3IgYm90dG9tL3JpZ2h0IGluc3RlYWQgb2YgdG9wL2xlZnQgLy8gVE9ETyBmaXggZm9yIGlzSGlkZVVzZXJJbnRlcmZhY2VcclxuICAgICAgICAgICAgICAgIGxldCBwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZCB9O1xyXG4gICAgICAgICAgICAgICAgbGV0IG1hcmdpblRvcE92ZXJyaWRlVmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGxldCB0b3BPdmVycmlkZVZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWFyZ2luTGVmdE92ZXJyaWRlVmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGlmIChzdHlsZU1vbGVjdWxlLklzUG9zaXRpb25GaXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcE92ZXJyaWRlVmFsdWUgPSBgJHtzdHlsZU1vbGVjdWxlLlRvcENzc1ZhbHVlUHh9cHhgO1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcE92ZXJyaWRlVmFsdWUgPSBzdHlsZU1vbGVjdWxlLlRvcENzc1ZhbHVlUHggIT09IHVuZGVmaW5lZCA/IGAke2N1cnJlbnRBcHAubmF2aWdhdGlvbkhlaWd0aFB4fXB4YCA6IHVuZGVmaW5lZDsgLy8gVE9ETyBleHBlbnNpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdE92ZXJyaWRlVmFsdWUgPSBgJHtzdHlsZU1vbGVjdWxlLkxlZnRDc3NWYWx1ZVB4fXB4YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcE92ZXJyaWRlVmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9wT3ZlcnJpZGVWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0T3ZlcnJpZGVWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIC0tLSBUT0RPIGNvZGUgZHVwbGljYXRpb24gZW5kXHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVNb2xlY3VsZUlkOiBudW1iZXIgPSBzdHlsZU1vbGVjdWxlLlN0eWxlTW9sZWN1bGVJZDtcclxuICAgICAgICAgICAgICAgIGxldCBzdHlsZU1vbGVjdWxlSWRTdHJpbmc6IHN0cmluZyA9IHN0eWxlTW9sZWN1bGVJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxheW91dEJveFN0eWxlQ2xhc3M6IHN0cmluZyA9IGBzJHtzdHlsZU1vbGVjdWxlSWR9YDtcclxuICAgICAgICAgICAgICAgIGxldCByaWNoVGV4dFRhZzogc3RyaW5nID0gXCJwXCI7XHJcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLlNwZWNpYWxMYXlvdXRCb3hUeXBlID09PSBTcGVjaWFsTGF5b3V0Qm94VHlwZS5SaWNoVGV4dCAmJiBzb3VyY2UuUGxhY2VkSW5Cb3hBdG9tcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxheW91dElkT2ZGaXJzdEF0b206IG51bWJlciA9IHNvdXJjZS5QbGFjZWRJbkJveEF0b21zWzBdLkxheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3R5bGVPZkZpcnN0QXRvbTogU3R5bGVNb2xlY3VsZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcy5maW5kKG0gPT4gbS5TdHlsZUZvckxheW91dElkID09IGxheW91dElkT2ZGaXJzdEF0b20pIGFzIFN0eWxlTW9sZWN1bGU7Ly8gVE9ETyBleHBlbnNpdmVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVPZkZpcnN0QXRvbS5IdG1sVGFnICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmljaFRleHRUYWcgPSBzdHlsZU9mRmlyc3RBdG9tLkh0bWxUYWc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7IC8vIFRPRE9cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlck1hcXVldHRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZW5kZXJlZEJveENvbnRlbnQ6IFZOb2RlW10gPSBjdXJyZW50UGFnZVByZXZpZXcubWFwQW5kUmVuZGVyTGF5b3V0Qm94Q29udGVudChzb3VyY2UsIHNvdXJjZS5QbGFjZWRJbkJveEF0b21zLCByZW5kZXJlZExheW91dEF0b21zLCBzb3VyY2UuUGxhY2VkSW5Cb3hCb3hlcywgcmVuZGVyZWRMYXlvdXRCb3hlcyk7IC8vIHNvcnRlZCB0d2ljZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXNIb3ZlcmVkSW5Cb3hUcmVlOiBib29sZWFuID0gY3VycmVudEFwcC5zdGF0ZS5ob3ZlcmVkQm94VHJlZUxheW91dEJhc2VJZCA9PSBzb3VyY2UuTGF5b3V0QmFzZUlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVuZGVyRml4ZWRMYXlvdXQgJiYgc3R5bGVNb2xlY3VsZS5Jc1Bvc2l0aW9uRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlTW9sZWN1bGUuSXNQb3NpdGlvbkZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qXCJtYXJnaW4tdG9wXCI6IG1hcmdpblRvcE92ZXJyaWRlVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tbGVmdFwiOiBtYXJnaW5MZWZ0T3ZlcnJpZGVWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRvcFwiOiB0b3BPdmVycmlkZVZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGVmdFwiOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXgtd2lkdGhcIjogdW5kZWZpbmVkKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCI6IFwiYWJzb2x1dGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1JlbmRlckZpeGVkTGF5b3V0ICYmICFpc0xheW91dEJveEluc2lkZUZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbmRlcmVkQm94Q29udGVudC5maWx0ZXIodiA9PiB2ICE9PSB1bmRlZmluZWQpLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKlwibWFyZ2luLXRvcFwiOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tbGVmdFwiOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0b3BcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGVmdFwiOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXgtd2lkdGhcIjogdW5kZWZpbmVkKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCI6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzW1wiYmFja2dyb3VuZC1jb2xvclwiXSA9IGlzSG92ZXJlZEluQm94VHJlZSA/IEhJR0hMSUdIVF9CQUNLR1JPVU5EX0NPTE9SX1NUUklORyA6IHVuZGVmaW5lZDsgLy8gVE9ETyBoaWdobGlnaHQgZmlyc3QgYXRvbSBvciBkcmF3IG91dGxpbmUgaW5zdGVhZCAoYXRvbSBiZy1jb2xvciBjYW4gb3ZlcnJpZGUgPT4gbm8gaGlnaGxpZ2h0IHZpc2libGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuTGF5b3V0QmFzZUlkID09IGN1cnJlbnRBcHAuc3RhdGUuaGlnaGxpZ2h0ZWRMYXlvdXRCYXNlSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJvdXRsaW5lXCJdID0gXCJzb2xpZCAxcHggYmxhY2tcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJvdXRsaW5lLW9mZnNldFwiXSA9IFwiLTFweFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlc1tcImJhY2tncm91bmQtY29sb3JcIl0gPSBNQU5VQUxMWV9ISUdITElHSFRfQkFDS0dST1VORF9DT0xPUl9TVFJJTkc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzW1wib3V0bGluZVwiXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJvdXRsaW5lLW9mZnNldFwiXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVNb2xlY3VsZS5Jc1Bvc2l0aW9uRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlc1tcIm1heC13aWR0aFwiXSA9IHN0eWxlTW9sZWN1bGUuSXNQb3NpdGlvbkZpeGVkICYmIGN1cnJlbnRBcHAuc3RhdGUuaXNEYXRhTG9hZGVkICYmIGN1cnJlbnRBcHAuc3RhdGUuaXNFbm91Z2hBdmFpbGFibGVTcGFjZVBhZ2VQcmV2aWV3ICYmIGN1cnJlbnRBcHAuc3RhdGUuZWRpdFZpZXdNb2RlICE9PSBFZGl0Vmlld01vZGUuUGFnZVByZXZpZXdPbmx5ID8gYCR7Y3VycmVudEFwcC5zdGF0ZS50YXJnZXRQYWdlUHJldmlld1dpZHRoUHh9cHhgIDogdW5kZWZpbmVkOyAvLyBUT0RPIGV4cGVuc2l2ZSBUT0RPIGR1cGxpY2F0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3BhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJsZWZ0XCJdID0gc3R5bGVNb2xlY3VsZS5Jc1Bvc2l0aW9uRml4ZWQgJiYgc3R5bGVNb2xlY3VsZS5MZWZ0Q3NzVmFsdWVQeCAhPT0gdW5kZWZpbmVkID8gYCR7cGFyc2VJbnQoc3R5bGVNb2xlY3VsZS5MZWZ0Q3NzVmFsdWVQeCkgKyBjdXJyZW50QXBwLnN0YXRlLnRhcmdldFBhZ2VQcmV2aWV3SG9sZGVyTWFyZ2luUHh9cHhgIDogdW5kZWZpbmVkOyAvLyBUT0RPIGV4cGVuc2l2ZSAvLyBUT0RPIGRhbmdlcm91cyAvLyBUT0RPIG1hZ2ljIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gY2hlY2sgZXZlcnl3aGVyZTogYXJlIGNvbW1lbnRzIGZyb20gdHN4IHN0cmlwcGVkIG91dD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChzb3VyY2UuU3BlY2lhbExheW91dEJveFR5cGUgPT09IFNwZWNpYWxMYXlvdXRCb3hUeXBlLkRlZmF1bHQpID8gPGRpdiBrZXk9e3NvdXJjZUxheW91dEJveElkU3RyaW5nfSBjbGFzcz17bGF5b3V0Qm94U3R5bGVDbGFzc30gc3R5bGVzPXtwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtyZW5kZXJlZEJveENvbnRlbnR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PiA6IChzb3VyY2UuU3BlY2lhbExheW91dEJveFR5cGUgPT09IFNwZWNpYWxMYXlvdXRCb3hUeXBlLlVuc29ydGVkTGlzdCkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1bCBrZXk9e3NvdXJjZUxheW91dEJveElkU3RyaW5nfSBjbGFzcz17bGF5b3V0Qm94U3R5bGVDbGFzc30gc3R5bGVzPXtwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7cmVuZGVyZWRCb3hDb250ZW50fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC91bD4gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzb3VyY2UuU3BlY2lhbExheW91dEJveFR5cGUgPT09IFNwZWNpYWxMYXlvdXRCb3hUeXBlLlNvcnRlZExpc3QpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9sIGtleT17c291cmNlTGF5b3V0Qm94SWRTdHJpbmd9IGNsYXNzPXtsYXlvdXRCb3hTdHlsZUNsYXNzfSBzdHlsZXM9e3BhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtyZW5kZXJlZEJveENvbnRlbnR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvb2w+IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNvdXJjZS5TcGVjaWFsTGF5b3V0Qm94VHlwZSA9PT0gU3BlY2lhbExheW91dEJveFR5cGUuTGlzdEl0ZW0pID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBrZXk9e3NvdXJjZUxheW91dEJveElkU3RyaW5nfSBjbGFzcz17bGF5b3V0Qm94U3R5bGVDbGFzc30gc3R5bGVzPXtwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7cmVuZGVyZWRCb3hDb250ZW50Lmxlbmd0aCA+IDAgPyByZW5kZXJlZEJveENvbnRlbnQgOiA8cD5hZGQgYXRvbXMuLi48L3A+fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT4gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNvdXJjZS5TcGVjaWFsTGF5b3V0Qm94VHlwZSA9PT0gU3BlY2lhbExheW91dEJveFR5cGUuUmljaFRleHQpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoKHJpY2hUZXh0VGFnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogc291cmNlTGF5b3V0Qm94SWRTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczogcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IGxheW91dEJveFN0eWxlQ2xhc3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbcmVuZGVyZWRCb3hDb250ZW50Lmxlbmd0aCA+IDAgPyByZW5kZXJlZEJveENvbnRlbnQgOiBoKFwicFwiLCBbXCJhZGQgYXRvbXMuLi5cIl0pXSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwPlRPRE8gQm94IFR5cGUgbm90IGltcGxlbWVudGVkITwvcD47XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICh1cGRhdGVkU291cmNlOiBMYXlvdXRCb3gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gdXBkYXRlZFNvdXJjZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTGF5b3V0Qm94SWRTdHJpbmcgPSBzb3VyY2UuTGF5b3V0QmFzZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlTW9sZWN1bGUgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChtID0+IG0uU3R5bGVGb3JMYXlvdXRJZCA9PSBzb3VyY2UuTGF5b3V0QmFzZUlkKSBhcyBTdHlsZU1vbGVjdWxlOyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZExheW91dEF0b21zID0gY3VycmVudFBhZ2VQcmV2aWV3LnJlbmRlckxheW91dEF0b21BcnJheShpc1JlbmRlckZpeGVkTGF5b3V0LCBzdHlsZU1vbGVjdWxlLklzUG9zaXRpb25GaXhlZCB8fCBpc0xheW91dEJveEluc2lkZUZpeGVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRMYXlvdXRCb3hlcyA9IGN1cnJlbnRQYWdlUHJldmlldy5yZW5kZXJMYXlvdXRCb3hBcnJheShpc1JlbmRlckZpeGVkTGF5b3V0LCBzdHlsZU1vbGVjdWxlLklzUG9zaXRpb25GaXhlZCB8fCBpc0xheW91dEJveEluc2lkZUZpeGVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLS0tIFRPRE8gY29kZSBkdXBsaWNhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVNb2xlY3VsZS5Jc1Bvc2l0aW9uRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcE92ZXJyaWRlVmFsdWUgPSBgJHtzdHlsZU1vbGVjdWxlLlRvcENzc1ZhbHVlUHh9cHhgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wT3ZlcnJpZGVWYWx1ZSA9IHN0eWxlTW9sZWN1bGUuVG9wQ3NzVmFsdWVQeCAhPT0gdW5kZWZpbmVkID8gYCR7Y3VycmVudEFwcC5uYXZpZ2F0aW9uSGVpZ3RoUHh9cHhgIDogdW5kZWZpbmVkOyAvLyBUT0RPIGV4cGVuc2l2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkxlZnRPdmVycmlkZVZhbHVlID0gYCR7c3R5bGVNb2xlY3VsZS5MZWZ0Q3NzVmFsdWVQeH1weGA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3BPdmVycmlkZVZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wT3ZlcnJpZGVWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkxlZnRPdmVycmlkZVZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0tLSBUT0RPIGNvZGUgZHVwbGljYXRpb24gZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlTW9sZWN1bGVJZCA9IHN0eWxlTW9sZWN1bGUuU3R5bGVNb2xlY3VsZUlkOyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZU1vbGVjdWxlSWRTdHJpbmcgPSBzdHlsZU1vbGVjdWxlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0Qm94U3R5bGVDbGFzcyA9IGBzJHtzdHlsZU1vbGVjdWxlSWR9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmljaFRleHRUYWcgPSBcInBcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5TcGVjaWFsTGF5b3V0Qm94VHlwZSA9PT0gU3BlY2lhbExheW91dEJveFR5cGUuUmljaFRleHQgJiYgc291cmNlLlBsYWNlZEluQm94QXRvbXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxheW91dElkT2ZGaXJzdEF0b206IG51bWJlciA9IHNvdXJjZS5QbGFjZWRJbkJveEF0b21zWzBdLkxheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdHlsZU9mRmlyc3RBdG9tOiBTdHlsZU1vbGVjdWxlID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlTW9sZWN1bGVzLmZpbmQobSA9PiBtLlN0eWxlRm9yTGF5b3V0SWQgPT0gbGF5b3V0SWRPZkZpcnN0QXRvbSkgYXMgU3R5bGVNb2xlY3VsZTsvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlT2ZGaXJzdEF0b20uSHRtbFRhZyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmljaFRleHRUYWcgPSBzdHlsZU9mRmlyc3RBdG9tLkh0bWxUYWc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7IC8vIFRPRE9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNlY3Rpb25UYXJnZXQodXBkYXRlZFNvdXJjZTogTGF5b3V0Qm94LCB0YXJnZXQ6IHsgcmVuZGVyTWFxdWV0dGUoKTogYW55LCB1cGRhdGUodXBkYXRlZFNvdXJjZTogTGF5b3V0Qm94KTogdm9pZCB9KSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQudXBkYXRlKHVwZGF0ZWRTb3VyY2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSByZW5kZXJMYXlvdXRBdG9tQXJyYXkgPSAoaXNSZW5kZXJGaXhlZExheW91dDogYm9vbGVhbiwgaXNMYXlvdXRBdG9tSW5zaWRlRml4ZWQ6IGJvb2xlYW4pOiBtYXF1ZXR0ZS5NYXBwaW5nPExheW91dEF0b20sIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+ID0+IHtcclxuICAgICAgICByZXR1cm4gbWFxdWV0dGUuY3JlYXRlTWFwcGluZzxMYXlvdXRBdG9tLCBhbnk+KFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRTZWN0aW9uU291cmNlS2V5KHNvdXJjZTogTGF5b3V0QXRvbSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5MYXlvdXRCYXNlSWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb25UYXJnZXQoc291cmNlOiBMYXlvdXRBdG9tKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc291cmNlTGF5b3V0QXRvbUlkU3RyaW5nID0gc291cmNlLkxheW91dEJhc2VJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZUNvbnRlbnRBdG9tSWRTdHJpbmcgPSBzb3VyY2UuSG9zdGVkQ29udGVudEF0b20uQ29udGVudEF0b21JZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgLy8gLS0tIFRPRE8gY29kZSBkdXBsaWNhdGlvbiAvLyBUT0RPIGZpeCBtYXgtd2lkdGggZm9yIHJlc3BvbnNpdmUgdmlld3MgLy8gVE9ETyBmaXggZm9yIGJvdHRvbS9yaWdodCBpbnN0ZWFkIG9mIHRvcC9sZWZ0IC8vIFRPRE8gZml4IGZvciBpc0hpZGVVc2VySW50ZXJmYWNlXHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVNb2xlY3VsZTogU3R5bGVNb2xlY3VsZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcy5maW5kKG0gPT4gbS5TdHlsZUZvckxheW91dElkID09IHNvdXJjZS5MYXlvdXRCYXNlSWQpIGFzIFN0eWxlTW9sZWN1bGU7IC8vIFRPRE8gZXhwZW5zaXZlXHJcbiAgICAgICAgICAgICAgICBsZXQgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQgfTtcclxuICAgICAgICAgICAgICAgIGxldCBtYXJnaW5Ub3BPdmVycmlkZVZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgdG9wT3ZlcnJpZGVWYWx1ZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgbGV0IG1hcmdpbkxlZnRPdmVycmlkZVZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgYmFja2dyb3VuZE92ZXJyaWRlVmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGlmIChzdHlsZU1vbGVjdWxlLklzUG9zaXRpb25GaXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcE92ZXJyaWRlVmFsdWUgPSBgJHtzdHlsZU1vbGVjdWxlLlRvcENzc1ZhbHVlUHh9cHhgO1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcE92ZXJyaWRlVmFsdWUgPSBzdHlsZU1vbGVjdWxlLlRvcENzc1ZhbHVlUHggIT09IHVuZGVmaW5lZCA/IGAke2N1cnJlbnRBcHAubmF2aWdhdGlvbkhlaWd0aFB4fXB4YCA6IHVuZGVmaW5lZDsgLy8gVE9ETyBleHBlbnNpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdE92ZXJyaWRlVmFsdWUgPSBgJHtzdHlsZU1vbGVjdWxlLkxlZnRDc3NWYWx1ZVB4fXB4YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcE92ZXJyaWRlVmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9wT3ZlcnJpZGVWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0T3ZlcnJpZGVWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIC0tLSBUT0RPIGNvZGUgZHVwbGljYXRpb24gZW5kXHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVNb2xlY3VsZUlkOiBudW1iZXIgPSBzdHlsZU1vbGVjdWxlLlN0eWxlTW9sZWN1bGVJZDtcclxuICAgICAgICAgICAgICAgIGxldCBzdHlsZU1vbGVjdWxlSWRTdHJpbmc6IHN0cmluZyA9IHN0eWxlTW9sZWN1bGVJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxheW91dEF0b21TdHlsZUNsYXNzOiBzdHJpbmcgPSBgcyR7c3R5bGVNb2xlY3VsZUlkU3RyaW5nfWA7IC8vIFRPRE8gY3JlYXRlIGFsbCBvZiB0aGVzZSBjb25zdGFudCBzdHJpbmdzIHdoZW4gcGFyc2luZyBkYXRhID0+IG9uZSBpbnN0YW5jZSBpbiBtZW1vcnkgISEhXHJcbiAgICAgICAgICAgICAgICBsZXQgaG9zdGVkQ29udGVudEF0b206IENvbnRlbnRBdG9tID0gKGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5Db250ZW50QXRvbXMuZmluZChjID0+IGMuQ29udGVudEF0b21JZCA9PSBzb3VyY2UuSG9zdGVkQ29udGVudEF0b20uQ29udGVudEF0b21JZCkgYXMgQ29udGVudEF0b20pOyAvLyBUT0RPIGV4cGVuc2l2ZSAoMiBjb3BpZXMgb2YgY29udGVudClcclxuICAgICAgICAgICAgICAgIGlmIChzdHlsZU1vbGVjdWxlLkh0bWxUYWcgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IGxheW91dEF0b21IdG1sVGFnOiBzdHJpbmcgPSBzdHlsZU1vbGVjdWxlLkh0bWxUYWcgIT09IHVuZGVmaW5lZCA/IHN0eWxlTW9sZWN1bGUuSHRtbFRhZyA6IFwicFwiO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5QbGFjZWRBdG9tSW5Cb3guU3BlY2lhbExheW91dEJveFR5cGUgPT09IFNwZWNpYWxMYXlvdXRCb3hUeXBlLlJpY2hUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0QXRvbUh0bWxUYWcgPSBcInNwYW5cIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTWFxdWV0dGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBzaW5jZSBpdCBpcyBuZWNlc3NhcnkgdG8ga25vdyB3aGljaCBhdG9tcyBhcmUgdmlzaWJsZSB0byB0aGUgdXNlciwgYW5kIHRoaXMgaXMgdHJhY2tlZCBvbiBzY3JvbGwgZXRjLi4uIGl0IGlzIHBvc3NpYmxlIHRvIHNhdmUgdmlzaWJsZSBzdGF0ZSBoZXJlIGFuZCBqdXN0IHBlcmZvcm0gc3R5bGUgY2FsY3VsYXRpb25zIHdoZW4gaXRzIHZpc2libGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzSG92ZXJlZEluQm94VHJlZTogYm9vbGVhbiA9IGN1cnJlbnRBcHAuc3RhdGUuaG92ZXJlZEJveFRyZWVMYXlvdXRCYXNlSWQgPT0gc291cmNlLkxheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmVuZGVyRml4ZWRMYXlvdXQgJiYgIWlzTGF5b3V0QXRvbUluc2lkZUZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZU1vbGVjdWxlLklzUG9zaXRpb25GaXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi10b3BcIjogbWFyZ2luVG9wT3ZlcnJpZGVWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1sZWZ0XCI6IG1hcmdpbkxlZnRPdmVycmlkZVZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidG9wXCI6IHRvcE92ZXJyaWRlVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsZWZ0XCI6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1heC13aWR0aFwiOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ6LWluZGV4XCI6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi10b3BcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLWxlZnRcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidG9wXCI6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImxlZnRcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWF4LXdpZHRoXCI6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInotaW5kZXhcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlc1tcImJhY2tncm91bmQtY29sb3JcIl0gPSBpc0hvdmVyZWRJbkJveFRyZWUgPyBISUdITElHSFRfQkFDS0dST1VORF9DT0xPUl9TVFJJTkcgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuTGF5b3V0QmFzZUlkID09IGN1cnJlbnRBcHAuc3RhdGUuaGlnaGxpZ2h0ZWRMYXlvdXRCYXNlSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJvdXRsaW5lXCJdID0gXCJzb2xpZCAxcHggYmxhY2tcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJvdXRsaW5lLW9mZnNldFwiXSA9IFwiLTFweFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlc1tcImJhY2tncm91bmQtY29sb3JcIl0gPSBNQU5VQUxMWV9ISUdITElHSFRfQkFDS0dST1VORF9DT0xPUl9TVFJJTkc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzW1wib3V0bGluZVwiXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJvdXRsaW5lLW9mZnNldFwiXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVNb2xlY3VsZS5Jc1Bvc2l0aW9uRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJtYXgtd2lkdGhcIl0gPSBzdHlsZU1vbGVjdWxlLklzUG9zaXRpb25GaXhlZCAmJiBjdXJyZW50QXBwLnN0YXRlLmlzRGF0YUxvYWRlZCAmJiBjdXJyZW50QXBwLnN0YXRlLmlzRW5vdWdoQXZhaWxhYmxlU3BhY2VQYWdlUHJldmlldyAmJiBjdXJyZW50QXBwLnN0YXRlLmVkaXRWaWV3TW9kZSAhPT0gRWRpdFZpZXdNb2RlLlBhZ2VQcmV2aWV3T25seSA/IGAke2N1cnJlbnRBcHAuc3RhdGUudGFyZ2V0UGFnZVByZXZpZXdXaWR0aFB4fXB4YCA6IHVuZGVmaW5lZDsgLy8gVE9ETyBleHBlbnNpdmUgVE9ETyBkdXBsaWNhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlc1tcImxlZnRcIl0gPSBzdHlsZU1vbGVjdWxlLklzUG9zaXRpb25GaXhlZCAmJiBzdHlsZU1vbGVjdWxlLkxlZnRDc3NWYWx1ZVB4ICE9PSB1bmRlZmluZWQgPyBgJHtwYXJzZUludChzdHlsZU1vbGVjdWxlLkxlZnRDc3NWYWx1ZVB4KSArIGN1cnJlbnRBcHAuc3RhdGUudGFyZ2V0UGFnZVByZXZpZXdIb2xkZXJNYXJnaW5QeH1weGAgOiB1bmRlZmluZWQ7IC8vIFRPRE8gZXhwZW5zaXZlIC8vIFRPRE8gZGFuZ2Vyb3VzIC8vIFRPRE8gbWFnaWMgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzRWRpdGVkTGF5b3V0QXRvbUlkOiBib29sZWFuID0gc291cmNlLkxheW91dEJhc2VJZCA9PSBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLmVkaXRlZExheW91dEF0b21JZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlc1tcInotaW5kZXhcIl0gPSBpc0VkaXRlZExheW91dEF0b21JZCA/IFwiMzBcIiA6IHVuZGVmaW5lZDsgLy8gVE9ETyBkb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRWRpdGVkTGF5b3V0QXRvbUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG93IGlucHV0IGZpZWxkIGluc3RlYWQgb2YgcmVuZGVyZWQgYXRvbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDx0ZXh0YXJlYSBrZXk9e2BpJHtzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmd9YH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz17bGF5b3V0QXRvbVN0eWxlQ2xhc3N9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2N1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwudGVtcENvbnRlbnR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25pbnB1dD17Y3VycmVudFBhZ2VQcmV2aWV3LmNvbnRlbnRBdG9tSW5wdXRIYW5kbGVyfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uYmx1cj17Y3VycmVudFBhZ2VQcmV2aWV3LmNvbnRlbnRBdG9tTG9zdEZvY3VzSGFuZGxlcn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmtleWRvd249e2N1cnJlbnRQYWdlUHJldmlldy5jb250ZW50QXRvbUtleURvd25IYW5kbGVyfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyQ3JlYXRlPXtjdXJyZW50UGFnZVByZXZpZXcuY29udGVudEF0b21BZnRlckNyZWF0ZUhhbmRsZXJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJVcGRhdGU9e2N1cnJlbnRQYWdlUHJldmlldy5jb250ZW50QXRvbUFmdGVyVXBkYXRlSGFuZGxlcn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0QW5pbWF0aW9uPXtjdXJyZW50UGFnZVByZXZpZXcuY29udGVudEF0b21FeGl0QW5pbWF0aW9uSGFuZGxlcn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaWQ9e3NvdXJjZUNvbnRlbnRBdG9tSWRTdHJpbmd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzPXtwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzfT48L3RleHRhcmVhPiBhcyBWTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9zdGVkQ29udGVudEF0b20uQ29udGVudEF0b21UeXBlID09PSBDb250ZW50QXRvbVR5cGUuVGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGgobGF5b3V0QXRvbUh0bWxUYWcsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHNvdXJjZUxheW91dEF0b21JZFN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogbGF5b3V0QXRvbVN0eWxlQ2xhc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljazogY3VycmVudFBhZ2VQcmV2aWV3LmxheW91dEF0b21DbGlja0hhbmRsZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25kYmxjbGljazogY3VycmVudFBhZ2VQcmV2aWV3LmxheW91dEF0b21EYmxDbGlja0hhbmRsZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3VzdG9tIGh0bWwgZmllbGRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWlkOiBzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2lkOiBzb3VyY2VDb250ZW50QXRvbUlkU3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczogcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlckNyZWF0ZTogY3VycmVudFBhZ2VQcmV2aWV3LmxheW91dEF0b21BZnRlckNyZWF0ZUhhbmRsZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJVcGRhdGU6IGN1cnJlbnRQYWdlUHJldmlldy5sYXlvdXRBdG9tQWZ0ZXJVcGRhdGVIYW5kbGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXRBbmltYXRpb246IGN1cnJlbnRQYWdlUHJldmlldy5sYXlvdXRBdG9tRXhpdEFuaW1hdGlvbkhhbmRsZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25tb3VzZWVudGVyOiBjdXJyZW50UGFnZVByZXZpZXcubGF5b3V0QXRvbU1vdXNlRW50ZXJIYW5kbGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ubW91c2VsZWF2ZTogY3VycmVudFBhZ2VQcmV2aWV3LmxheW91dEF0b21Nb3VzZUxlYXZlSGFuZGxlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW2hvc3RlZENvbnRlbnRBdG9tLlRleHRDb250ZW50XSkgLy8gVE9ETyBubyB1bnNldCB2YWx1ZSBmb3IgZGVsZXRlIFwiYW5pbWF0aW9uXCIgPSBzZXQgY29udGVudCB0byBudWxsIHRoZW4gZGVsZXRlIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSAvLyBUT0RPIHRoaXMgY291bGQgYmUgcHJlcGFyZWQgb24gc2VydmVyIGluIG9uZSBcInJlbmRlci9kaXNwbGF5IGNvbnRlbnQgZmllbGRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChob3N0ZWRDb250ZW50QXRvbS5Db250ZW50QXRvbVR5cGUgPT09IENvbnRlbnRBdG9tVHlwZS5MaW5rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaChsYXlvdXRBdG9tSHRtbFRhZywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogc291cmNlTGF5b3V0QXRvbUlkU3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBsYXlvdXRBdG9tU3R5bGVDbGFzcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrOiBjdXJyZW50UGFnZVByZXZpZXcubGF5b3V0QXRvbUNsaWNrSGFuZGxlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmRibGNsaWNrOiBjdXJyZW50UGFnZVByZXZpZXcubGF5b3V0QXRvbURibENsaWNrSGFuZGxlciwgLy8gVE9ETyBvcGVuIGxpbmsgaW4gbmV3IHRhYlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1c3RvbSBodG1sIGZpZWxkc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFpZDogc291cmNlTGF5b3V0QXRvbUlkU3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNpZDogc291cmNlQ29udGVudEF0b21JZFN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmOiBcIlwiLCAvLyBuZWVkIHRvIHNldCB0byB0cmlnZ2VyIGJyb3dzZXIgdXJsIHJlbmRlcmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczogcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbm1vdXNlZW50ZXI6IGN1cnJlbnRQYWdlUHJldmlldy5sYXlvdXRBdG9tTW91c2VFbnRlckhhbmRsZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25tb3VzZWxlYXZlOiBjdXJyZW50UGFnZVByZXZpZXcubGF5b3V0QXRvbU1vdXNlTGVhdmVIYW5kbGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbaG9zdGVkQ29udGVudEF0b20uVXJsXSkgLy8gVE9ETyBubyB1bnNldCB2YWx1ZSBmb3IgZGVsZXRlIFwiYW5pbWF0aW9uXCIgPSBzZXQgY29udGVudCB0byBudWxsIHRoZW4gZGVsZXRlIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKHVwZGF0ZWRTb3VyY2U6IExheW91dEF0b20pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gdXBkYXRlZFNvdXJjZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTGF5b3V0QXRvbUlkU3RyaW5nID0gc291cmNlLkxheW91dEJhc2VJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VDb250ZW50QXRvbUlkU3RyaW5nID0gc291cmNlLkhvc3RlZENvbnRlbnRBdG9tLkNvbnRlbnRBdG9tSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVNb2xlY3VsZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcy5maW5kKG0gPT4gbS5TdHlsZUZvckxheW91dElkID09IHNvdXJjZS5MYXlvdXRCYXNlSWQpIGFzIFN0eWxlTW9sZWN1bGU7IC8vIFRPRE8gZXhwZW5zaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0tLSBUT0RPIGNvZGUgZHVwbGljYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlTW9sZWN1bGUuSXNQb3NpdGlvbkZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3BPdmVycmlkZVZhbHVlID0gYCR7c3R5bGVNb2xlY3VsZS5Ub3BDc3NWYWx1ZVB4fXB4YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcE92ZXJyaWRlVmFsdWUgPSBzdHlsZU1vbGVjdWxlLlRvcENzc1ZhbHVlUHggIT09IHVuZGVmaW5lZCA/IGAke2N1cnJlbnRBcHAubmF2aWdhdGlvbkhlaWd0aFB4fXB4YCA6IHVuZGVmaW5lZDsgLy8gVE9ETyBleHBlbnNpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0T3ZlcnJpZGVWYWx1ZSA9IGAke3N0eWxlTW9sZWN1bGUuTGVmdENzc1ZhbHVlUHh9cHhgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wT3ZlcnJpZGVWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcE92ZXJyaWRlVmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0T3ZlcnJpZGVWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAtLS0gVE9ETyBjb2RlIGR1cGxpY2F0aW9uIGVuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZU1vbGVjdWxlSWQgPSBzdHlsZU1vbGVjdWxlLlN0eWxlTW9sZWN1bGVJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVNb2xlY3VsZUlkU3RyaW5nID0gc3R5bGVNb2xlY3VsZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEF0b21TdHlsZUNsYXNzID0gYHMke3N0eWxlTW9sZWN1bGVJZH1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0ZWRDb250ZW50QXRvbSA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ29udGVudEF0b21zLmZpbmQoYyA9PiBjLkNvbnRlbnRBdG9tSWQgPT0gc291cmNlLkhvc3RlZENvbnRlbnRBdG9tLkNvbnRlbnRBdG9tSWQpIGFzIENvbnRlbnRBdG9tKTsgLy8gVE9ETyBleHBlbnNpdmUgKDIgY29waWVzIG9mIGNvbnRlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZU1vbGVjdWxlLkh0bWxUYWcgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEF0b21IdG1sVGFnID0gc3R5bGVNb2xlY3VsZS5IdG1sVGFnICE9PSB1bmRlZmluZWQgPyBzdHlsZU1vbGVjdWxlLkh0bWxUYWcgOiBcInBcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5QbGFjZWRBdG9tSW5Cb3guU3BlY2lhbExheW91dEJveFR5cGUgPT09IFNwZWNpYWxMYXlvdXRCb3hUeXBlLlJpY2hUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRBdG9tSHRtbFRhZyA9IFwic3BhblwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlU2VjdGlvblRhcmdldCh1cGRhdGVkU291cmNlOiBMYXlvdXRBdG9tLCB0YXJnZXQ6IHsgcmVuZGVyTWFxdWV0dGUoKTogYW55LCB1cGRhdGUodXBkYXRlZFNvdXJjZTogTGF5b3V0QXRvbSk6IHZvaWQgfSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnVwZGF0ZSh1cGRhdGVkU291cmNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgcmVzZXRDb250ZW50QXRvbUVkaXRNb2RlID0gKCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy5yZXNldEVxdWF0aW9uTnVtYmVyc1doZW5Nb2RpZnlpbmcoZmFsc2UpO1xyXG4gICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwuZWRpdGVkTGF5b3V0QXRvbUlkID0gMDtcclxuICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBDb250ZW50ID0gXCJcIjtcclxuICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBPcmlnaW5hbENvbnRlbnQgPSBcIlwiO1xyXG4gICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwuc3R5bGVzT2ZFZGl0ZWRDb250ZW50ID0ge307XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgY29udGVudEF0b21Mb3N0Rm9jdXNIYW5kbGVyID0gKGV2dDogRm9jdXNFdmVudCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy51cGRhdGVDb250ZW50QXRvbShwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJjaWRcIikpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIHVwZGF0ZUNvbnRlbnRBdG9tID0gKGNvbnRlbnRBdG9tSWQ6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGlmIChjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLmVkaXRlZExheW91dEF0b21JZCAhPSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBDb250ZW50ICE9PSBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBPcmlnaW5hbENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb250ZW50QXRvbTogQ29udGVudEF0b20gPSAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNvbnRlbnRBdG9tcy5maW5kKGEgPT4gYS5JbnN0YW5jZWRPbkxheW91dElkID09IGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwuZWRpdGVkTGF5b3V0QXRvbUlkKSBhcyBDb250ZW50QXRvbSk7IC8vIFRPRE8gZXhwZW5zaXZlIGJ1dCBmZWVscyBiZXR0ZXJcclxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50QXRvbS5Db250ZW50QXRvbVR5cGUgPT09IENvbnRlbnRBdG9tVHlwZS5UZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudEF0b20uVGV4dENvbnRlbnQgPSBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBDb250ZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGVudEF0b20uQ29udGVudEF0b21UeXBlID09PSBDb250ZW50QXRvbVR5cGUuTGluaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRBdG9tLlVybCA9IGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwudGVtcENvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwudGVtcENvbnRlbnQgPT09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHRoaXMgY29kZSBwYXRoIHNob3VsZCBiZSBwb3NzaWJsZSB3aGVyZXZlciBjb250ZW50IGlzIHVwZGF0ZWQgKD8pIChpLmUuIGNoYWluZWQgY2FsbHMgd2l0aCBpbnNlcnQgYXRvbSlcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuRGVsZXRlTGF5b3V0SnNvbihjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLmVkaXRlZExheW91dEF0b21JZCwgZmFsc2UpLmRvbmUoKGRhdGE6IGFueSkgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBmb2N1cyBwcmV2aW91cyBsYXlvdXQgYXRvbSAoaW4gc2FtZSBib3g/IG9yIGFsbCBib3hlcyBhbmQgcHJldmlvdXMgc29ydG9yZGVyPylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFJlYWR5U3RhdGUgPSBSZWFkeVN0YXRlLlBlbmRpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLlVwZGF0ZVRleHRDb250ZW50QXRvbUpzb24oY29udGVudEF0b21JZCwgY3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC50ZW1wQ29udGVudCkuZG9uZSgoZGF0YTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy5yZXNldEVxdWF0aW9uTnVtYmVyc1doZW5Nb2RpZnlpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLmFsd2F5cygoZGF0YTogYW55KSA9PiBjdXJyZW50QXBwLnN0YXRlLmN1cnJlbnRSZWFkeVN0YXRlID0gUmVhZHlTdGF0ZS5Payk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnJlc2V0Q29udGVudEF0b21FZGl0TW9kZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIGNvbnRlbnRBdG9tS2V5RG93bkhhbmRsZXIgPSAoZXZ0OiBLZXlib2FyZEV2ZW50KSA9PiB7IC8vIFRPRE8gY29kZSBkdXBsaWNhdGlvblxyXG4gICAgICAgIGlmIChldnQua2V5Q29kZSA9PSAxMyAvKkVOVEVSKi8pIHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGlmIChldnQuc2hpZnRLZXkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy5jb250ZW50QXRvbUNyZWF0ZU5ld0xpbmUocGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwiY2lkXCIpKTsgLy8gVE9ETyBtdWx0aXBsZSByZXF1ZXN0cyB3aGVuIGRhdGEgaGFzIGNoYW5nZWQgPT4gY29tYmluZWQgcmVxdWVzdCBjaGFpbjsgY3VycmVudGx5IHJlbGllcyBvbiBmdW5jdGlvbiBvcmRlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIChldnQudGFyZ2V0IGFzIEhUTUxUZXh0QXJlYUVsZW1lbnQpLmJsdXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXZ0LmtleUNvZGUgPT0gMjcgLypFU0MqLykge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnJlc2V0Q29udGVudEF0b21FZGl0TW9kZSgpO1xyXG4gICAgICAgICAgICAoZXZ0LnRhcmdldCBhcyBIVE1MVGV4dEFyZWFFbGVtZW50KS5ibHVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV2dC5rZXlDb2RlID09IHVuZGVmaW5lZCAvKnRleHQgYXJlYSBmb2N1cyBsb3N0Ki8pIHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE8gY2xlYW4gd2hpdGVzcGFjZXNcclxuICAgICAgICAvLyBUT0RPIGF1dG9zaXplXHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgY29udGVudEF0b21DcmVhdGVOZXdMaW5lID0gKGNvbnRlbnRBdG9tSWQ6IG51bWJlcik6IHZvaWQgPT4ge1xyXG4gICAgICAgIC8vIFRPRE8gdGFyZ2V0IGF0b20gdHlwZSBjb3VsZCBiZSBkZWZhdWx0IHR5cGUgZm9yIGJveCB0eXBlIChub25lID0+IHRleHQsIGxpc3QgPT4gbGlzdCBpdGVtLCAuLi4pIGJ1dCBkb2VzIG5vdCB3b3JrIGZvciBoZWFkaW5nc1xyXG4gICAgICAgIC8vIFRPRE8gdGFyZ2V0IGF0b20gdHlwZSBjb3VsZCBiZSB0aGF0IG9mIGN1cnJlbnQgZWRpdGVkIGxheW91dCBhdG9tXHJcbiAgICAgICAgaWYgKGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwuZWRpdGVkTGF5b3V0QXRvbUlkICE9IDApIHtcclxuICAgICAgICAgICAgbGV0IGVkaXRlZExheW91dEF0b206IExheW91dEF0b20gPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuTGF5b3V0TW9sZWN1bGVzLmZpbmQobCA9PiBsLkxheW91dEJhc2VJZCA9PSBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLmVkaXRlZExheW91dEF0b21JZCkgYXMgTGF5b3V0QXRvbTsgLy8gVE9ETyBleHBlbnNpdmVcclxuICAgICAgICAgICAgbGV0IGVkaXRlZExheW91dEF0b21JZENoYWluZWRDYWxsOiBudW1iZXIgPSBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLmVkaXRlZExheW91dEF0b21JZDtcclxuICAgICAgICAgICAgbGV0IHBsYWNlZEF0b21JbkJveElkQ2hhaW5lZENhbGw6IG51bWJlciA9IGVkaXRlZExheW91dEF0b20uUGxhY2VkQXRvbUluQm94SWQ7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBDb250ZW50ICE9PSBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBPcmlnaW5hbENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFJlYWR5U3RhdGUgPSBSZWFkeVN0YXRlLlBlbmRpbmc7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuVXBkYXRlVGV4dENvbnRlbnRBdG9tSnNvbihjb250ZW50QXRvbUlkLCBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBDb250ZW50KS5kb25lKChkYXRhOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcuY2hhaW5lZEFkZE1vdmVMYXlvdXRBdG9tQ2FsbFdpdGhGdWxsVXBkYXRlKHBsYWNlZEF0b21JbkJveElkQ2hhaW5lZENhbGwsIGVkaXRlZExheW91dEF0b21JZENoYWluZWRDYWxsKTsgICAgXHJcbiAgICAgICAgICAgICAgICB9KS5hbHdheXMoKGRhdGE6IGFueSkgPT4gY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50UmVhZHlTdGF0ZSA9IFJlYWR5U3RhdGUuT2spO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnJlc2V0Q29udGVudEF0b21FZGl0TW9kZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LmNoYWluZWRBZGRNb3ZlTGF5b3V0QXRvbUNhbGxXaXRoRnVsbFVwZGF0ZShwbGFjZWRBdG9tSW5Cb3hJZENoYWluZWRDYWxsLCBlZGl0ZWRMYXlvdXRBdG9tSWRDaGFpbmVkQ2FsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjaGFpbmVkQWRkTW92ZUxheW91dEF0b21DYWxsV2l0aEZ1bGxVcGRhdGUgPSAocGxhY2VkQXRvbUluQm94SWRDaGFpbmVkQ2FsbDogbnVtYmVyLCBlZGl0ZWRMYXlvdXRBdG9tSWRDaGFpbmVkQ2FsbDogbnVtYmVyKTogdm9pZCA9PiB7XHJcbiAgICAgICAgLy8gVE9ETyBzaG91bGQgYmUgb25lIGJpZyBiYWNrZW5kIG9wZXJhdGlvbiBvciBhZGQgdHJpZ2dlciB0byBiYWNrZW5kIHRvIHNhdmUgaW50ZXJtZWRpYXRlIGRhdGEgdHJhbnNmZXJcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuQ3JlYXRlTGF5b3V0QXRvbUZvckJveEpzb24ocGxhY2VkQXRvbUluQm94SWRDaGFpbmVkQ2FsbCwgZWRpdGVkTGF5b3V0QXRvbUlkQ2hhaW5lZENhbGwpLmRvbmUoKGRhdGFTdWI6IENhbGlmb3JuaWFDbGllbnRWaWV3TW9kZWwpID0+IHtcclxuICAgICAgICAgICAgbGV0IHN1YkJveEF0b21zOiBMYXlvdXRCYXNlW10gPSBkYXRhU3ViLkNhbGlmb3JuaWFQcm9qZWN0LkxheW91dE1vbGVjdWxlcy5maWx0ZXIobSA9PiBtLkxheW91dFR5cGUgPT09IExheW91dFR5cGUuQXRvbSAmJiAobSBhcyBMYXlvdXRBdG9tKS5QbGFjZWRBdG9tSW5Cb3hJZCA9PSBwbGFjZWRBdG9tSW5Cb3hJZENoYWluZWRDYWxsKTtcclxuICAgICAgICAgICAgbGV0IGNyZWF0ZWRMYXlvdXRNb2xlY3VsZUlkOiBudW1iZXIgPSBzdWJCb3hBdG9tc1tzdWJCb3hBdG9tcy5sZW5ndGggLSAxXS5MYXlvdXRCYXNlSWQ7IC8vIFRPRE8gd2lsZCBndWVzczogbGFzdCBlbnRyeSBpbiBsaXN0IGlzIHRoZSBjcmVhdGVkIGF0b21cclxuICAgICAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLk1vdmVMYXlvdXRNb2xlY3VsZU5leHRUb0xheW91dE1vbGVjdWxlSnNvbihjcmVhdGVkTGF5b3V0TW9sZWN1bGVJZCwgZWRpdGVkTGF5b3V0QXRvbUlkQ2hhaW5lZENhbGwsIHRydWUpLmRvbmUoKGRhdGFTdWJTdWI6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLk1vdmVMYXlvdXRNb2xlY3VsZU5leHRUb0xheW91dE1vbGVjdWxlSnNvbihlZGl0ZWRMYXlvdXRBdG9tSWRDaGFpbmVkQ2FsbCwgY3JlYXRlZExheW91dE1vbGVjdWxlSWQsIHRydWUpLmRvbmUoKGRhdGFTdWJTdWJTdWI6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YVN1YlN1YlN1Yik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhvc3RlZENvbnRlbnRBdG9tOiBDb250ZW50QXRvbSA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ29udGVudEF0b21zLmZpbmQoYyA9PiBjLkluc3RhbmNlZE9uTGF5b3V0SWQgPT0gY3JlYXRlZExheW91dE1vbGVjdWxlSWQpIGFzIENvbnRlbnRBdG9tKTsgLy8gVE9ETyBleHBlbnNpdmUgKDIgY29waWVzIG9mIGNvbnRlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC50ZW1wQ29udGVudCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC50ZW1wT3JpZ2luYWxDb250ZW50ID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaG9zdGVkQ29udGVudEF0b20uQ29udGVudEF0b21UeXBlID09PSBDb250ZW50QXRvbVR5cGUuVGV4dCkgeyAvLyBUT0RPIGNvZGUgZHVwbGljYXRpb24gZm9yIGNvbnRlbnQgc2VsZWN0aW9uIGF0IG11bHRpcGxlIHBsYWNlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBPcmlnaW5hbENvbnRlbnQgPSBob3N0ZWRDb250ZW50QXRvbS5UZXh0Q29udGVudCBhcyBzdHJpbmc7IC8vIFRPRE8gZGVmYXVsdCB0ZXh0IHNob3VsZCBiZSBlbXB0eSB3aGVuIGNyZWF0aW5nIGEgbmV3IGVsZW1lbnQgd2l0aCBzaG9ydGN1dCAocHJlc3NpbmcgZXNjYXBlIGxlYXZlcyBlbGVtZW50IHdpdGggZGVmYXVsdCB0ZXh0IGluc3RlYWQgb2YgcmVtb3ZpbmcgaXQgYWdhaW4pXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhvc3RlZENvbnRlbnRBdG9tLkNvbnRlbnRBdG9tVHlwZSA9PT0gQ29udGVudEF0b21UeXBlLkxpbmspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC50ZW1wT3JpZ2luYWxDb250ZW50ID0gaG9zdGVkQ29udGVudEF0b20uVXJsIGFzIHN0cmluZztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLmVkaXRlZExheW91dEF0b21JZCA9IGNyZWF0ZWRMYXlvdXRNb2xlY3VsZUlkO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIGNvbnRlbnRBdG9tQWZ0ZXJDcmVhdGVIYW5kbGVyID0gKGVsZW1lbnQ6IEVsZW1lbnQsIHByb2plY3Rpb25PcHRpb25zOiBtYXF1ZXR0ZS5Qcm9qZWN0aW9uT3B0aW9ucywgdm5vZGVTZWxlY3Rvcjogc3RyaW5nLCBwcm9wZXJ0aWVzOiBtYXF1ZXR0ZS5WTm9kZVByb3BlcnRpZXMsIGNoaWxkcmVuOiBWTm9kZVtdKSA9PiB7XHJcbiAgICAgICAgbGV0IHRhcmdldEVsZW1lbnQ6IEhUTUxUZXh0QXJlYUVsZW1lbnQgPSBlbGVtZW50IGFzIEhUTUxUZXh0QXJlYUVsZW1lbnQ7XHJcbiAgICAgICAgJCh0YXJnZXRFbGVtZW50KS5jc3MoY3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC5zdHlsZXNPZkVkaXRlZENvbnRlbnQpO1xyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLmlzU2VsZWN0QWxsVGV4dEFyZWEgPT09IHRydWUpIHsgLy8gVE9ETyBkb2VzIG5vdCB3b3JrIHdpdGggY2xpY2svZGJsY2xpY2sgZGlmZmVyZW50aWF0aW9uIGJlY2F1c2UgY2xpY2sgYWx3YXlzIGZpcmVzIGJlZm9yZSBkYmxjbGljayA9PiB1c2UgdGltZW91dCBvciBkaWZmZXJlbnRpYXRlIHByZXNlbGVjdGlvbiB3aXNoIHdpdGggdWkgc3RhdGVcclxuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZSgwLCBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBDb250ZW50Lmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRhcmdldEVsZW1lbnQuZm9jdXMoKTsgLy9UT0RPIGRvZXMgbm90IHdvcmsgd2l0aCB0ZXh0IGFyZWEgKG9uIGlwaG9uZSkgLyBUT0RPIHRyeSByZW5kZXJOb3dcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBjb250ZW50QXRvbUFmdGVyVXBkYXRlSGFuZGxlciA9IChlbGVtZW50OiBFbGVtZW50LCBwcm9qZWN0aW9uT3B0aW9uczogbWFxdWV0dGUuUHJvamVjdGlvbk9wdGlvbnMsIHZub2RlU2VsZWN0b3I6IHN0cmluZywgcHJvcGVydGllczogbWFxdWV0dGUuVk5vZGVQcm9wZXJ0aWVzLCBjaGlsZHJlbjogVk5vZGVbXSkgPT4ge1xyXG4gICAgICAgIC8vIGRvIG5vdGhpbmdcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBjb250ZW50QXRvbUV4aXRBbmltYXRpb25IYW5kbGVyID0gKGVsZW1lbnQ6IEVsZW1lbnQsIHJlbW92ZUVsZW1lbnQ6ICgpID0+IHZvaWQsIHByb3BlcnRpZXM/OiBWTm9kZVByb3BlcnRpZXMpOiB2b2lkID0+IHtcclxuICAgICAgICByZW1vdmVFbGVtZW50KCk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBwcml2YXRlIGxheW91dEF0b21BZnRlckNyZWF0ZUhhbmRsZXIgPSAoZWxlbWVudDogRWxlbWVudCwgcHJvamVjdGlvbk9wdGlvbnM6IG1hcXVldHRlLlByb2plY3Rpb25PcHRpb25zLCB2bm9kZVNlbGVjdG9yOiBzdHJpbmcsIHByb3BlcnRpZXM6IG1hcXVldHRlLlZOb2RlUHJvcGVydGllcywgY2hpbGRyZW46IFZOb2RlW10pID0+IHtcclxuICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5pc0pheE9uKSB7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXRFbGVtZW50OiBIVE1MRWxlbWVudCA9IGVsZW1lbnQgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy5fYWN0aXZlVmlld0xheW91dEF0b21Eb21Ob2RlUmVmZXJlbmNlc1twcm9wZXJ0aWVzLmtleSBhcyBzdHJpbmddID0gdGFyZ2V0RWxlbWVudDtcclxuICAgICAgICAgICAgaWYgKHRhcmdldEVsZW1lbnQuaW5uZXJUZXh0LmluZGV4T2YoXCIkXCIpICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBNYXRoSmF4Lkh1Yi5RdWV1ZShbXCJUeXBlc2V0XCIsIE1hdGhKYXguSHViLCB0YXJnZXRFbGVtZW50XSk7IC8vIFRPRE8gdXNlIEh1Yi5RdWV1ZS5TdXNwZW5kXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgbGF5b3V0QXRvbUV4aXRBbmltYXRpb25IYW5kbGVyID0gKGVsZW1lbnQ6IEVsZW1lbnQsIHJlbW92ZUVsZW1lbnQ6ICgpID0+IHZvaWQsIHByb3BlcnRpZXM6IFZOb2RlUHJvcGVydGllcyk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGRlbGV0ZSBjdXJyZW50UGFnZVByZXZpZXcuX2FjdGl2ZVZpZXdMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXNbcHJvcGVydGllcy5rZXkgYXMgc3RyaW5nXTtcclxuICAgICAgICByZW1vdmVFbGVtZW50KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgbGF5b3V0QXRvbU1vdXNlRW50ZXJIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCB0YXJnZXRFbGVtZW50OiBIVE1MRWxlbWVudCA9IGV2dC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmhvdmVyZWRQYWdlUHJldmlld0xheW91dEJhc2VJZCA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZSh0YXJnZXRFbGVtZW50LCBcImFpZFwiKTtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBsYXlvdXRBdG9tTW91c2VMZWF2ZUhhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5ob3ZlcmVkUGFnZVByZXZpZXdMYXlvdXRCYXNlSWQgPSAwO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcHJpdmF0ZSBsYXlvdXRBdG9tQWZ0ZXJVcGRhdGVIYW5kbGVyID0gKGVsZW1lbnQ6IEVsZW1lbnQsIHByb2plY3Rpb25PcHRpb25zOiBtYXF1ZXR0ZS5Qcm9qZWN0aW9uT3B0aW9ucywgdm5vZGVTZWxlY3Rvcjogc3RyaW5nLCBwcm9wZXJ0aWVzOiBtYXF1ZXR0ZS5WTm9kZVByb3BlcnRpZXMsIGNoaWxkcmVuOiBWTm9kZVtdKSA9PiB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUuaXNKYXhPbikge1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0RWxlbWVudDogSFRNTEVsZW1lbnQgPSBlbGVtZW50IGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgICAgICB2YXIgbWF0aDogYW55ID0gTWF0aEpheC5IdWIuZ2V0QWxsSmF4KHRhcmdldEVsZW1lbnQpWzBdO1xyXG4gICAgICAgICAgICBpZiAobWF0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvKmxldCBsYXlvdXRBdG9tSWRTdHJpbmc6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHByb3BlcnRpZXNbXCJhaWRcIl07XHJcbiAgICAgICAgICAgICAgICBpZiAobGF5b3V0QXRvbUlkU3RyaW5nICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGVuYWJsZSB1cGRhdGVyICsgcmVudW1iZXI6IGRpc2FibGVkLCBiZWNhdXNlIG5lZWQgdG8gZXh0cmFjdCBtYXRoIGZyb20gdGV4dCBjb250ZW50LCBlbHNlIGRvdWJsZSBjb250ZW50IChvbmNlIG5vcm1hbCByZW5kZXIsIG9uY2UgYXMgbWF0aClcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGF5b3V0QXRvbUlkOiBudW1iZXIgPSBwYXJzZUludChsYXlvdXRBdG9tSWRTdHJpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudEFwcC5wcm9wZXJ0eUJhckNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldFZNOiBQcm9wZXJ0eUJhclZNID0gY3VycmVudEFwcC5wcm9wZXJ0eUJhcnNbaV0udmlld01vZGVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Vk0uZWRpdGVkTGF5b3V0QXRvbUlkID09IGxheW91dEF0b21JZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aEpheC5IdWIuUXVldWUoW1wiVGV4dFwiLCBtYXRoLCB0YXJnZXRWTS50ZW1wQ29udGVudF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy5yZXNldEVxdWF0aW9uTnVtYmVyc1doZW5Nb2RpZnlpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgICAgICAgICAgfSovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0RWxlbWVudC5pbm5lclRleHQuaW5kZXhPZihcIiRcIikgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gd2h5IGlzIHRoZSBmb3JtdWxhIGRlc3Ryb3llZCB3aGVuIHRoZSByZW5kZXJlZCBjb250ZW50IGNoYW5nZXMgPT4gdHJpZ2dlciBmb3JtdWxhIHVwZGF0ZSBpbnN0ZWFkXHJcbiAgICAgICAgICAgICAgICBNYXRoSmF4Lkh1Yi5RdWV1ZShbXCJUeXBlc2V0XCIsIE1hdGhKYXguSHViLCB0YXJnZXRFbGVtZW50XSk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcucmVzZXRFcXVhdGlvbk51bWJlcnNXaGVuTW9kaWZ5aW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE8gYWxzbyBzdXBwb3J0cyByZXJlbmRlciAob25seSB3aGVuIGNzcyBjaGFuZ2VzKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBjb250ZW50QXRvbUlucHV0SGFuZGxlciA9IChldnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBDb250ZW50ID0gKGV2dC50YXJnZXQgYXMgSFRNTFRleHRBcmVhRWxlbWVudCkudmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgbGF5b3V0QXRvbURibENsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTsgLy8gVE9ETyB0aGlzIGlzIHNldCBmb3IgZXZlcnkgY29udGVudCBhdG9tIGluIHByZXZpZXcuLi4gcGVyZm9ybWFuY2U/XHJcbiAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFJlYWR5U3RhdGUgIT09IFJlYWR5U3RhdGUuT2spIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwZW5kaW5nLi4uXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLmN1cnJlbnRTZWxlY3Rpb25Nb2RlID09PSBTZWxlY3Rpb25Nb2RlLkNvbnRlbnQpIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldEVsZW1lbnQ6IEhUTUxFbGVtZW50ID0gZXZ0LmN1cnJlbnRUYXJnZXQgYXMgSFRNTEVsZW1lbnQ7ICAvLyBoYWQgdG8gYmUgY3VycmVudFRhcmdldCBhZnRlciBpbm5lckh0bWwgd2FzIG1hbmlwdWxhdGVkIHVzaW5nIG1hdGhqYXggLy8gVE9ETyBjb2RlIGR1cGxpY2F0aW9uXHJcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwuc3R5bGVzT2ZFZGl0ZWRDb250ZW50ID0gY3VycmVudFBhZ2VQcmV2aWV3LmdldFN0eWxlT2JqZWN0KHRhcmdldEVsZW1lbnQpOyAvLyBUT0RPIGRvZXMgdGhpcyBoYXZlIHRvIGJlIGV2ZXJ5d2hlcmUgaS5lLiBhbmltYXRpb25zP1xyXG4gICAgICAgICAgICBsZXQgY29udGVudElkOiBudW1iZXIgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUodGFyZ2V0RWxlbWVudCwgXCJjaWRcIik7XHJcbiAgICAgICAgICAgIGxldCBsYXlvdXRJZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKHRhcmdldEVsZW1lbnQsIFwiYWlkXCIpO1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0V2lkdGg6IG51bWJlciA9IHRhcmdldEVsZW1lbnQuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXRIZWlnaHQ6IG51bWJlciA9IHRhcmdldEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgICAgICBsZXQgbWF4SXRlcmF0aW9uczogbnVtYmVyID0gMTA7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50SXRlcmF0aW9uOiBudW1iZXIgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudEl0ZXJhdGlvbisrIDwgbWF4SXRlcmF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFdpZHRoID09IDAgfHwgdGFyZ2V0SGVpZ2h0ID09IDApIHsgLy8gaGFwcGVucyBmb3IgPHNwYW4+IGluc2lkZSByaWNoIHRleHRcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RWxlbWVudC5wYXJlbnRFbGVtZW50ICE9PSBudWxsKSB7IC8vIFRPRE8gcmVjdXJzaXZlIHdoaWxlIGxvb3AgbWF4IDEwIGl0ZXJhdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0V2lkdGggPSB0YXJnZXRFbGVtZW50LnBhcmVudEVsZW1lbnQuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEhlaWdodCA9IHRhcmdldEVsZW1lbnQucGFyZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQgPSB0YXJnZXRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy5sYXlvdXRBdG9tVG9UZXh0QXJlYVNldHVwKGNvbnRlbnRJZCwgbGF5b3V0SWQsIHRydWUsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVE9ET1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBsYXlvdXRBdG9tQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBUT0RPIHRoaXMgaXMgc2V0IGZvciBldmVyeSBjb250ZW50IGF0b20gaW4gcHJldmlldy4uLiBwZXJmb3JtYW5jZT9cclxuICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50UmVhZHlTdGF0ZSAhPT0gUmVhZHlTdGF0ZS5Paykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInBlbmRpbmcuLi5cIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFNlbGVjdGlvbk1vZGUgPT09IFNlbGVjdGlvbk1vZGUuQ29udGVudCkge1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0RWxlbWVudDogSFRNTEVsZW1lbnQgPSBldnQuY3VycmVudFRhcmdldCBhcyBIVE1MRWxlbWVudDsgIC8vIGhhZCB0byBiZSBjdXJyZW50VGFyZ2V0IGFmdGVyIGlubmVySHRtbCB3YXMgbWFuaXB1bGF0ZWQgdXNpbmcgbWF0aGpheCAvLyBUT0RPIGNvZGUgZHVwbGljYXRpb25cclxuICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC5zdHlsZXNPZkVkaXRlZENvbnRlbnQgPSBjdXJyZW50UGFnZVByZXZpZXcuZ2V0U3R5bGVPYmplY3QodGFyZ2V0RWxlbWVudCk7IC8vIFRPRE8gZG9lcyB0aGlzIGhhdmUgdG8gYmUgZXZlcnl3aGVyZSBpLmUuIGFuaW1hdGlvbnM/XHJcbiAgICAgICAgICAgIGxldCBjb250ZW50SWQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZSh0YXJnZXRFbGVtZW50LCBcImNpZFwiKTtcclxuICAgICAgICAgICAgbGV0IGxheW91dElkOiBudW1iZXIgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUodGFyZ2V0RWxlbWVudCwgXCJhaWRcIik7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXRXaWR0aDogbnVtYmVyID0gdGFyZ2V0RWxlbWVudC5jbGllbnRXaWR0aDtcclxuICAgICAgICAgICAgbGV0IHRhcmdldEhlaWdodDogbnVtYmVyID0gdGFyZ2V0RWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgICAgIGxldCBtYXhJdGVyYXRpb25zOiBudW1iZXIgPSAxMDtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRJdGVyYXRpb246IG51bWJlciA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50SXRlcmF0aW9uKysgPCBtYXhJdGVyYXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0V2lkdGggPT0gMCB8fCB0YXJnZXRIZWlnaHQgPT0gMCkgeyAvLyBoYXBwZW5zIGZvciA8c3Bhbj4gaW5zaWRlIHJpY2ggdGV4dFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRFbGVtZW50LnBhcmVudEVsZW1lbnQgIT09IG51bGwpIHsgLy8gVE9ETyByZWN1cnNpdmUgd2hpbGUgbG9vcCBtYXggMTAgaXRlcmF0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRXaWR0aCA9IHRhcmdldEVsZW1lbnQucGFyZW50RWxlbWVudC5jbGllbnRXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SGVpZ2h0ID0gdGFyZ2V0RWxlbWVudC5wYXJlbnRFbGVtZW50LmNsaWVudEhlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudCA9IHRhcmdldEVsZW1lbnQucGFyZW50RWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LmxheW91dEF0b21Ub1RleHRBcmVhU2V0dXAoY29udGVudElkLCBsYXlvdXRJZCwgdHJ1ZSwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIGxheW91dEF0b21Ub1RleHRBcmVhU2V0dXAgPSAoY29udGVudEF0b21JZDogbnVtYmVyLCBsYXlvdXRBdG9tSWQ6IG51bWJlciwgaXNQcmVTZWxlY3RBbGw6IGJvb2xlYW4sIHRhcmdldFdpZHRoUHg6IG51bWJlciwgdGFyZ2V0SGVpZ2h0UHg6IG51bWJlcik6IHZvaWQgPT4ge1xyXG4gICAgICAgIC8vIFRPRE8gZ2V0IHBvc2l0aW9uLCBoZWlnaHQgKyB3aWR0aCBhbmQgcGxhY2UgYXMgYWJzb2x1dGUgYWJvdmUgZWRpdGVkIGxheW91dCAobm8gcmVwbGFjZW1lbnQgZWxlbWVudClcclxuICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmlzU2VsZWN0QWxsVGV4dEFyZWEgPSBpc1ByZVNlbGVjdEFsbDtcclxuICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnN0eWxlc09mRWRpdGVkQ29udGVudFtcIm91dGxpbmVcIl0gPSBcInNvbGlkIDFweCByZ2IoMjAwLDIwMCwyMDApXCI7IC8vIHRleHQgYXJlYSBjYW4ndCBmb2N1cyBkaXJlY3RseSBvbiBpUGhvbmUgPT4gc2hvdyBpbnRlcm1lZGlhdGUgc3RhdGUgVE9ETyB0cnkgcmVuZGVyTm93KClcclxuICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnN0eWxlc09mRWRpdGVkQ29udGVudFtcIm91dGxpbmUtb2Zmc2V0XCJdID0gXCItMXB4XCI7XHJcbiAgICAgICAgLy8ga2VlcCBzcGFjZSBmb3IgcmVuZGVyZWQgZm9udHMgdGhlIHNhbWUgKGFkZCBzcGFjZSBmb3Igc2Nyb2xsYmFyIG9mIHRleHRhcmVhKVxyXG4gICAgICAgIGlmIChjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnN0eWxlc09mRWRpdGVkQ29udGVudFtcIndpZHRoXCJdID09PSB1bmRlZmluZWQgfHwgY3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC5zdHlsZXNPZkVkaXRlZENvbnRlbnRbXCJoZWlnaHRcIl0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBhbHdheXMgZXhwZWN0ZWQgdG8gYmUgYWxyZWFkeSBzZXQgYnkgYnJvd3NlciBvciBjc3NcclxuICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldFdpZHRoU3RyaW5nOiBzdHJpbmcgPSAodGFyZ2V0V2lkdGhQeCA9PSAwID8gMzAwIDogdGFyZ2V0V2lkdGhQeCkudG9TdHJpbmcoKSArIFwicHhcIjtcclxuICAgICAgICAgICAgbGV0IHRhcmdldEhlaWdodFN0cmluZzogc3RyaW5nID0gKHRhcmdldEhlaWdodFB4ID09IDAgPyAzMDAgOiB0YXJnZXRIZWlnaHRQeCkudG9TdHJpbmcoKSArIFwicHhcIjtcclxuICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC5zdHlsZXNPZkVkaXRlZENvbnRlbnRbXCJ3aWR0aFwiXSA9IHRhcmdldFdpZHRoU3RyaW5nO1xyXG4gICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnN0eWxlc09mRWRpdGVkQ29udGVudFtcIm1pbi13aWR0aFwiXSA9IHRhcmdldFdpZHRoU3RyaW5nO1xyXG4gICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnN0eWxlc09mRWRpdGVkQ29udGVudFtcImhlaWdodFwiXSA9IHRhcmdldEhlaWdodFN0cmluZztcclxuICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC5zdHlsZXNPZkVkaXRlZENvbnRlbnRbXCJtaW4taGVpZ2h0XCJdID0gdGFyZ2V0SGVpZ2h0U3RyaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgaG9zdGVkQ29udGVudEF0b206IENvbnRlbnRBdG9tID0gKGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5Db250ZW50QXRvbXMuZmluZChjID0+IGMuQ29udGVudEF0b21JZCA9PSBjb250ZW50QXRvbUlkKSBhcyBDb250ZW50QXRvbSk7IC8vIFRPRE8gZXhwZW5zaXZlICgyIGNvcGllcyBvZiBjb250ZW50KVxyXG4gICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwudGVtcENvbnRlbnQgPSBcIlwiO1xyXG4gICAgICAgIGlmIChob3N0ZWRDb250ZW50QXRvbS5Db250ZW50QXRvbVR5cGUgPT09IENvbnRlbnRBdG9tVHlwZS5UZXh0KSB7IC8vIFRPRE8gY29kZSBkdXBsaWNhdGlvbiBmb3IgY29udGVudCBzZWxlY3Rpb24gYXQgbXVsdGlwbGUgcGxhY2VzXHJcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwudGVtcENvbnRlbnQgPSBob3N0ZWRDb250ZW50QXRvbS5UZXh0Q29udGVudCBhcyBzdHJpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhvc3RlZENvbnRlbnRBdG9tLkNvbnRlbnRBdG9tVHlwZSA9PT0gQ29udGVudEF0b21UeXBlLkxpbmspIHtcclxuICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC50ZW1wQ29udGVudCA9IGhvc3RlZENvbnRlbnRBdG9tLlVybCBhcyBzdHJpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC50ZW1wT3JpZ2luYWxDb250ZW50ID0gY3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC50ZW1wQ29udGVudDtcclxuICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLmVkaXRlZExheW91dEF0b21JZCA9IGxheW91dEF0b21JZDtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHByaXZhdGUgZ2V0U3R5bGVPYmplY3QgPSAodGFyZ2V0RWxlbWVudDogSFRNTEVsZW1lbnQpOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0+IHtcclxuICAgICAgICB2YXIgZG9tID0gJCh0YXJnZXRFbGVtZW50KS5nZXQoMCk7XHJcbiAgICAgICAgdmFyIHN0eWxlO1xyXG4gICAgICAgIHZhciByZXR1cm5zOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge307XHJcbiAgICAgICAgLy9pZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcclxuICAgICAgICB2YXIgY2FtZWxpemUgPSBmdW5jdGlvbiAoYTogc3RyaW5nLCBiOiBzdHJpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGIudG9VcHBlckNhc2UoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tLCB1bmRlZmluZWQpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3R5bGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wID0gc3R5bGVbaV07XHJcbiAgICAgICAgICAgIHZhciBjYW1lbCA9IHByb3AucmVwbGFjZSgvXFwtKFthLXpdKS9nLCBjYW1lbGl6ZSk7XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApO1xyXG4gICAgICAgICAgICByZXR1cm5zW2NhbWVsXSA9IHZhbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiByZXR1cm5zO1xyXG4gICAgICAgIC8vfTtcclxuICAgICAgICAvKmlmIChzdHlsZSA9IGRvbS5jdXJyZW50U3R5bGUpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuc1twcm9wXSA9IHN0eWxlW3Byb3BdO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJucztcclxuICAgICAgICB9OyovXHJcbiAgICAgICAgLy9yZXR1cm4gJCh0YXJnZXRFbGVtZW50KS5jc3MoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIG1hcEFuZFJlbmRlckxheW91dEJveENvbnRlbnQgPSAocmVmTGF5b3V0Qm94OiBMYXlvdXRCb3gsIC8vIFRPRE8gbWFyayBhcyBzdGF0aWMgLyBubyBzaWRlIGVmZmVjdHNcclxuICAgICAgICB1bnNvcnRlZEF0b21zOiBMYXlvdXRBdG9tW10sIGF0b21NYXBwaW5nOiBtYXF1ZXR0ZS5NYXBwaW5nPExheW91dEF0b20sIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+LFxyXG4gICAgICAgIHVuc29ydGVkQm94ZXM6IExheW91dEJveFtdLCBib3hNYXBwaW5nOiBtYXF1ZXR0ZS5NYXBwaW5nPExheW91dEJveCwgeyByZW5kZXJNYXF1ZXR0ZTogKCkgPT4gbWFxdWV0dGUuVk5vZGUgfT4pOiBWTm9kZVtdID0+IHtcclxuICAgICAgICBpZiAodW5zb3J0ZWRBdG9tcy5sZW5ndGggPT0gMCAmJiB1bnNvcnRlZEJveGVzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTsgLy8gWzxwIGtleT1cIjBcIj5BZGQgYXRvbXMuLi48L3A+IGFzIFZOb2RlXTsgVE9ET1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHNvcnRlZEF0b21zOiBMYXlvdXRBdG9tW10gPSB1bnNvcnRlZEF0b21zLnNvcnQoKGF0b21BOiBMYXlvdXRBdG9tLCBhdG9tQjogTGF5b3V0QXRvbSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYXRvbUEuTGF5b3V0U29ydE9yZGVyS2V5IDwgYXRvbUIuTGF5b3V0U29ydE9yZGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYXRvbUEuTGF5b3V0U29ydE9yZGVyS2V5ID09IGF0b21CLkxheW91dFNvcnRPcmRlcktleSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7IC8vIGF0b21BLkxheW91dFNvcnRPcmRlcktleSA+IGF0b21CLkxheW91dFNvcnRPcmRlcktleVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgc29ydGVkQm94ZXM6IExheW91dEJveFtdID0gdW5zb3J0ZWRCb3hlcy5zb3J0KChib3hBOiBMYXlvdXRCb3gsIGJveEI6IExheW91dEJveCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYm94QS5MYXlvdXRTb3J0T3JkZXJLZXkgPCBib3hCLkxheW91dFNvcnRPcmRlcktleSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGJveEEuTGF5b3V0U29ydE9yZGVyS2V5ID09IGJveEIuTGF5b3V0U29ydE9yZGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHsgLy8gYm94QS5MYXlvdXRTb3J0T3JkZXJLZXkgPiBib3hCLkxheW91dFNvcnRPcmRlcktleVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBhdG9tTWFwcGluZy5tYXAoc29ydGVkQXRvbXMpO1xyXG4gICAgICAgIGJveE1hcHBpbmcubWFwKHNvcnRlZEJveGVzKTtcclxuICAgICAgICAvLyBleHBlY3RzIGF0b21zIGFuZCBib3hlcyBzb3J0ZWQgYnkgTGF5b3V0U29ydE9yZGVyS2V5IGFuZCBtYXBwaW5ncyBpbiB0aGUgc2FtZSBvcmRlclxyXG4gICAgICAgIGxldCByZW5kZXJlZEF0b21zQW5kQm94ZXM6IFZOb2RlW10gPSBbXTtcclxuICAgICAgICBsZXQgYXRvbUluZGV4OiBudW1iZXIgPSAwO1xyXG4gICAgICAgIGxldCBib3hJbmRleDogbnVtYmVyID0gMDtcclxuICAgICAgICBsZXQgYXRvbXNMZW5ndGg6IG51bWJlciA9IHNvcnRlZEF0b21zLmxlbmd0aDtcclxuICAgICAgICBsZXQgYm94ZXNMZW5ndGg6IG51bWJlciA9IHNvcnRlZEJveGVzLmxlbmd0aDtcclxuICAgICAgICBsZXQgdG90YWxJdGVtczogbnVtYmVyID0gYXRvbXNMZW5ndGggKyBib3hlc0xlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsSXRlbXM7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudEF0b206IExheW91dEF0b20gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50Qm94OiBMYXlvdXRCb3ggfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGlmIChhdG9tSW5kZXggPCBhdG9tc0xlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEF0b20gPSBzb3J0ZWRBdG9tc1thdG9tSW5kZXhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChib3hJbmRleCA8IGJveGVzTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Qm94ID0gc29ydGVkQm94ZXNbYm94SW5kZXhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50QXRvbSAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnRCb3ggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBdG9tLkxheW91dFNvcnRPcmRlcktleSA8IGN1cnJlbnRCb3guTGF5b3V0U29ydE9yZGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRBdG9tc0FuZEJveGVzLnB1c2goYXRvbU1hcHBpbmcucmVzdWx0c1thdG9tSW5kZXgrK10ucmVuZGVyTWFxdWV0dGUoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZEF0b21zQW5kQm94ZXMucHVzaChib3hNYXBwaW5nLnJlc3VsdHNbYm94SW5kZXgrK10ucmVuZGVyTWFxdWV0dGUoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudEF0b20gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlbWFpbmluZ0F0b21zOiBudW1iZXIgPSBhdG9tc0xlbmd0aCAtIGF0b21JbmRleDtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVtYWluaW5nQXRvbXM7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkQXRvbXNBbmRCb3hlcy5wdXNoKGF0b21NYXBwaW5nLnJlc3VsdHNbYXRvbUluZGV4KytdLnJlbmRlck1hcXVldHRlKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7Ly8gaWYgKGN1cnJlbnRCb3ggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlbWFpbmluZ0JveGVzOiBudW1iZXIgPSBib3hlc0xlbmd0aCAtIGJveEluZGV4O1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZW1haW5pbmdCb3hlczsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRBdG9tc0FuZEJveGVzLnB1c2goYm94TWFwcGluZy5yZXN1bHRzW2JveEluZGV4KytdLnJlbmRlck1hcXVldHRlKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkQXRvbXNBbmRCb3hlcztcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGdldENzc1J1bGVPZiA9IChzdHlsZU1vbGVjdWxlOiBTdHlsZU1vbGVjdWxlLCByZXNwb25zaXZlRGV2aWNlOiBSZXNwb25zaXZlRGV2aWNlLCBzdGF0ZU1vZGlmaWVyOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBzdHJpbmcgPT4ge1xyXG4gICAgICAgIC8vbGV0IHJlc3BvbnNpdmVTZXR0aW5nOiBSZWFjdG9yUmVzcG9uc2l2ZVNldHRpbmcgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuVXNlclJlc3BvbnNpdmVTZXR0aW5nc1tyZXNwb25zaXZlSWRdO1xyXG4gICAgICAgIGxldCBzZWxlY3Rvcjogc3RyaW5nID0gYC5zJHtzdHlsZU1vbGVjdWxlLlN0eWxlTW9sZWN1bGVJZH1gO1xyXG4gICAgICAgIGlmICgoc3RhdGVNb2RpZmllciA9PT0gdW5kZWZpbmVkKSB8fCAoc3RhdGVNb2RpZmllciA9PT0gXCJcIikpIHtcclxuICAgICAgICAgICAgbGV0IHN0eWxlUnVsZTogc3RyaW5nID0gYCR7c2VsZWN0b3J9e2A7XHJcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgc3R5bGUgaXMgdGFyZ2V0XHJcbiAgICAgICAgICAgIGZvciAobGV0IHN0eWxlQXRvbU1hcHBpbmcgb2Ygc3R5bGVNb2xlY3VsZS5NYXBwZWRTdHlsZUF0b21zLmZpbHRlcihzdHlsZUF0b21NYXAgPT4gc3R5bGVBdG9tTWFwLlJlc3BvbnNpdmVEZXZpY2VJZCA9PSByZXNwb25zaXZlRGV2aWNlLlJlc3BvbnNpdmVEZXZpY2VJZCAmJiAoc3R5bGVBdG9tTWFwLlN0YXRlTW9kaWZpZXIgPT09IHVuZGVmaW5lZCB8fCBzdHlsZUF0b21NYXAuU3RhdGVNb2RpZmllciA9PT0gXCJcIikpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVBdG9tSWQ6IG51bWJlciA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVBdG9tcy5maW5kKGEgPT4gYS5NYXBwZWRUb01vbGVjdWxlSWQgPT0gc3R5bGVBdG9tTWFwcGluZy5TdHlsZU1vbGVjdWxlQXRvbU1hcHBpbmdJZCkgYXMgU3R5bGVBdG9tKS5TdHlsZUF0b21JZDsgLy8gVE9ETyBzbG93XHJcbiAgICAgICAgICAgICAgICBsZXQgYXBwbGllZFZhbHVlczogU3R5bGVWYWx1ZVtdID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlVmFsdWVzLmZpbHRlcih2ID0+IHYuU3R5bGVBdG9tSWQgPT0gc3R5bGVBdG9tSWQpOyAvLyBUT0RPIHNsb3dcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNzc1Byb3Agb2YgYXBwbGllZFZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjc3NQcm9wLkNzc1ZhbHVlICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlUnVsZSArPSBgJHtjc3NQcm9wLkNzc1Byb3BlcnR5fTogJHtjc3NQcm9wLkNzc1ZhbHVlfTtgO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdHlsZVJ1bGUgKz0gXCJ9XCI7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50UGFnZVByZXZpZXcud3JhcENzc01lZGlhUXVlcnkoc3R5bGVSdWxlLCByZXNwb25zaXZlRGV2aWNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHBzZXVkbyBzdHlsZSBpcyB0YXJnZXRcclxuICAgICAgICAgICAgLy8gY3JlYXRlIGEgY3NzIGRlY2xhcmF0aW9uIGZvciB0YXJnZXQgcHNldWRvIHN0eWxlXHJcbiAgICAgICAgICAgIGxldCBwc2V1ZG9TdHlsZVJ1bGU6IHN0cmluZyA9IGAke3NlbGVjdG9yfSR7c3RhdGVNb2RpZmllcn17YDtcclxuICAgICAgICAgICAgZm9yIChsZXQgcHNldWRvU3R5bGVBdG9tTWFwcGluZyBvZiBzdHlsZU1vbGVjdWxlLk1hcHBlZFN0eWxlQXRvbXMuZmlsdGVyKHN0eWxlQXRvbU1hcCA9PiBzdHlsZUF0b21NYXAuUmVzcG9uc2l2ZURldmljZUlkID09IHJlc3BvbnNpdmVEZXZpY2UuUmVzcG9uc2l2ZURldmljZUlkICYmIHN0eWxlQXRvbU1hcC5TdGF0ZU1vZGlmaWVyID09PSBzdGF0ZU1vZGlmaWVyKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlQXRvbUlkOiBudW1iZXIgPSAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlQXRvbXMuZmluZChhID0+IGEuTWFwcGVkVG9Nb2xlY3VsZUlkID09IHBzZXVkb1N0eWxlQXRvbU1hcHBpbmcuU3R5bGVNb2xlY3VsZUF0b21NYXBwaW5nSWQpIGFzIFN0eWxlQXRvbSkuU3R5bGVBdG9tSWQ7IC8vIFRPRE8gc2xvd1xyXG4gICAgICAgICAgICAgICAgbGV0IGFwcGxpZWRWYWx1ZXM6IFN0eWxlVmFsdWVbXSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZVZhbHVlcy5maWx0ZXIodiA9PiB2LlN0eWxlQXRvbUlkID09IHN0eWxlQXRvbUlkKTsgLy8gVE9ETyBzbG93XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjc3NQcm9wIG9mIGFwcGxpZWRWYWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3NzUHJvcC5Dc3NWYWx1ZSAhPT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwc2V1ZG9TdHlsZVJ1bGUgKz0gYCR7Y3NzUHJvcC5Dc3NQcm9wZXJ0eX06ICR7Y3NzUHJvcC5Dc3NWYWx1ZX07YDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHNldWRvU3R5bGVSdWxlICs9IFwifVwiO1xyXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFBhZ2VQcmV2aWV3LndyYXBDc3NNZWRpYVF1ZXJ5KHBzZXVkb1N0eWxlUnVsZSwgcmVzcG9uc2l2ZURldmljZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIHdyYXBDc3NNZWRpYVF1ZXJ5ID0gKHN0eWxlUnVsZTogc3RyaW5nLCByZXNwb25zaXZlRGV2aWNlOiBSZXNwb25zaXZlRGV2aWNlKTogc3RyaW5nID0+IHtcclxuICAgICAgICAvLyBjc3MgZm9yIGRlZmF1bHQgKyBzbWFsbGVzdCBkZXZpY2UgKG1vZEluZGV4IDAsIDEpIGFyZSBcImNsYXNzaWNcIiBjc3MgcnVsZXNcclxuICAgICAgICBpZiAocmVzcG9uc2l2ZURldmljZS5XaWR0aFRocmVzaG9sZCAhPT0gdW5kZWZpbmVkICYmIHJlc3BvbnNpdmVEZXZpY2UuV2lkdGhUaHJlc2hvbGQgPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIG1lZGl1bSBkZXZpY2UgKyAuLi4gKyBsYXJnZXN0IGRldmljZSBcIm1lZGlhXCIgY3NzIHJ1bGVzXHJcbiAgICAgICAgICAgIHJldHVybiBgQG1lZGlhKG1pbi13aWR0aDoke2N1cnJlbnRQYWdlUHJldmlldy5keW5hbWljQ2xpZW50R3JpZEJyZWFrcG9pbnRzW2N1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5SZXNwb25zaXZlRGV2aWNlcy5pbmRleE9mKHJlc3BvbnNpdmVEZXZpY2UpXX1weCl7JHtzdHlsZVJ1bGV9fWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBkb250IHdyYXBcclxuICAgICAgICAgICAgcmV0dXJuIHN0eWxlUnVsZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBhcHBlbmRTdHlsZVJ1bGVzRm9yID0gKHN0eWxlTW9sZWN1bGU6IFN0eWxlTW9sZWN1bGUsIHN0eWxlU2hlZXQ6IENTU1N0eWxlU2hlZXQpOiB2b2lkID0+IHtcclxuICAgICAgICBsZXQgcnVsZUluZGV4OiBudW1iZXI7XHJcbiAgICAgICAgbGV0IHN0eWxlUnVsZTogc3RyaW5nO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCByZXNwb25zaXZlRGV2aWNlID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzW2ldO1xyXG4gICAgICAgICAgICBydWxlSW5kZXggPSBzdHlsZVNoZWV0LmNzc1J1bGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgc3R5bGVSdWxlID0gY3VycmVudFBhZ2VQcmV2aWV3LmdldENzc1J1bGVPZihzdHlsZU1vbGVjdWxlLCByZXNwb25zaXZlRGV2aWNlLCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICBzdHlsZVNoZWV0Lmluc2VydFJ1bGUoc3R5bGVSdWxlLCBydWxlSW5kZXgpO1xyXG4gICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudmlydHVhbFN0eWxlSW5kZXhbaV1bc3R5bGVNb2xlY3VsZS5TdHlsZU1vbGVjdWxlSWRdID0gcnVsZUluZGV4O1xyXG5cclxuICAgICAgICAgICAgbGV0IHN0YXRlTW9kaWZpZXJzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0eWxlTW9sZWN1bGUuTWFwcGVkU3R5bGVBdG9tcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlQXRvbU1hcCA9IHN0eWxlTW9sZWN1bGUuTWFwcGVkU3R5bGVBdG9tc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChzdHlsZUF0b21NYXAuUmVzcG9uc2l2ZURldmljZUlkID09IHJlc3BvbnNpdmVEZXZpY2UuUmVzcG9uc2l2ZURldmljZUlkICYmIHN0eWxlQXRvbU1hcC5TdGF0ZU1vZGlmaWVyICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVNb2RpZmllcnMuZmluZEluZGV4KHMgPT4gcyA9PT0gc3R5bGVBdG9tTWFwLlN0YXRlTW9kaWZpZXIpID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVNb2RpZmllcnMucHVzaChzdHlsZUF0b21NYXAuU3RhdGVNb2RpZmllcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgc3RhdGVNb2RpZmllciBvZiBzdGF0ZU1vZGlmaWVycykge1xyXG4gICAgICAgICAgICAgICAgLy9pZiAoc3RhdGVNb2RpZmllciA9PT0gXCI6aG92ZXJcIikgeyAvLyBUT0RPIG11c3Qgd2hpdGVsaXN0IGFjY2VwdGFibGUgc2VsZWN0b3JzIG9yIGJyb3dzZXIgdGhyb3dzIGV4Y2VwdGlvblxyXG4gICAgICAgICAgICAgICAgcnVsZUluZGV4ID0gc3R5bGVTaGVldC5jc3NSdWxlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBzdHlsZVJ1bGUgPSBjdXJyZW50UGFnZVByZXZpZXcuZ2V0Q3NzUnVsZU9mKHN0eWxlTW9sZWN1bGUsIHJlc3BvbnNpdmVEZXZpY2UsIHN0YXRlTW9kaWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldC5pbnNlcnRSdWxlKHN0eWxlUnVsZSwgcnVsZUluZGV4KTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy52aXJ0dWFsUHNldWRvU3R5bGVJbmRleFtpXVtgJHtzdHlsZU1vbGVjdWxlLlN0eWxlTW9sZWN1bGVJZH0ke3N0YXRlTW9kaWZpZXJ9YF0gPSBydWxlSW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZWxvYWRDc3NTdHlsZXMgPSAoKTogdm9pZCA9PiB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IGN1cnJlbnRBcHAuc3R5bGVTaGVldC5jc3NSdWxlcy5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdHlsZVNoZWV0LmRlbGV0ZVJ1bGUoaSAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgc3R5bGVNb2xlY3VsZTogU3R5bGVNb2xlY3VsZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlc1tpXTtcclxuICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LmFwcGVuZFN0eWxlUnVsZXNGb3Ioc3R5bGVNb2xlY3VsZSwgY3VycmVudEFwcC5zdHlsZVNoZWV0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyB1cGRhdGVQYWdlUHJldmlld0RpbWVuc2lvbnMgPSAoKTogdm9pZCA9PiB7XHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIHBhZ2UgcHJldmlldyBob2xkZXIgdGFyZ2V0IHdpZHRoIGZvciBvdmVycmlkZGVuIHJlc3BvbnNpdmUgZGV2aWNlXHJcbiAgICAgICAgbGV0IHN0YXRpY01hcmdpbjogbnVtYmVyID0gY3VycmVudEFwcC5zdGF0ZS5kZWZhdWx0U3ltbWV0cmljUGFnZVByZXZpZXdIb2xkZXJNYXJnaW5QeDtcclxuICAgICAgICBsZXQgdGFyZ2V0V2lkdGhQeDogbnVtYmVyID0gMDtcclxuICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5vdmVycmlkZVJlc3BvbnNpdmVEZXZpY2VJZCA9PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIGRlZmF1bHQ6IHVzZSBhdmFpbGFibGUgc3BhY2UgdG8gZmlsbCB2aWV3cG9ydCBob3Jpem9udGFsbHlcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS50YXJnZXRQYWdlUHJldmlld0hvbGRlck1hcmdpblB4ID0gc3RhdGljTWFyZ2luO1xyXG4gICAgICAgICAgICB0YXJnZXRXaWR0aFB4ID0gY3VycmVudEFwcC5zdGF0ZS5hdmFpbGFibGVTcGFjZVBhZ2VQcmV2aWV3UHggLSAyICogc3RhdGljTWFyZ2luO1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLnRhcmdldFBhZ2VQcmV2aWV3V2lkdGhQeCA9IHRhcmdldFdpZHRoUHg7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuaXNFbm91Z2hBdmFpbGFibGVTcGFjZVBhZ2VQcmV2aWV3ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHNwZWNpZmljIHByZXZpZXcgc2l6ZSB3YXMgc2V0IGJ5IHVzZXIgPT4gbW9kaWZ5IHRhcmdldCB3aWR0aCBmb3Igb3ZlcnJpZGRlbiByZXNwb25zaXZlIGRldmljZVxyXG4gICAgICAgICAgICBsZXQgb3ZlcnJpZGVXaXRoUmVzcG9uc2l2ZURldmljZTogUmVzcG9uc2l2ZURldmljZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5SZXNwb25zaXZlRGV2aWNlcy5maW5kKHIgPT4gci5SZXNwb25zaXZlRGV2aWNlSWQgPT0gY3VycmVudEFwcC5zdGF0ZS5vdmVycmlkZVJlc3BvbnNpdmVEZXZpY2VJZCkgYXMgUmVzcG9uc2l2ZURldmljZTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUub3ZlcnJpZGVSZXNwb25zaXZlRGV2aWNlSWQgPT0gY3VycmVudEFwcC5zdGF0ZS5oaWdoZXN0V2lkdGhUaHJlc2hvbGRSZXNwb25zaXZlRGV2aWNlSWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGFkZCAxcHggdG8gaGlnaGVzdCByZXNwb25zaXZlIHNldHRpbmcgd2lkdGggdGhyZXNob2xkLCBzdWNoIHRoYXQgdGFyZ2V0V2lkdGggaXMgaGlnaGVyIHRoYW4gaGlnaGVzdCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0V2lkdGhQeCA9IG92ZXJyaWRlV2l0aFJlc3BvbnNpdmVEZXZpY2UuV2lkdGhUaHJlc2hvbGQgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldFJlc3BvbnNpdmVTZXR0aW5nQWJvdmU6IFJlc3BvbnNpdmVEZXZpY2UgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuUmVzcG9uc2l2ZURldmljZXNbY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzLmluZGV4T2Yob3ZlcnJpZGVXaXRoUmVzcG9uc2l2ZURldmljZSkgKyAxXTsgLy8gcmVsaWVzIG9uIHNvcnRlZCBkZXZpY2VzXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRXaWR0aFB4ID0gdGFyZ2V0UmVzcG9uc2l2ZVNldHRpbmdBYm92ZS5XaWR0aFRocmVzaG9sZCAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChjdXJyZW50QXBwLnN0YXRlLmF2YWlsYWJsZVNwYWNlUGFnZVByZXZpZXdQeCAtIDIgKiBzdGF0aWNNYXJnaW4pID49IHRhcmdldFdpZHRoUHgpIHtcclxuICAgICAgICAgICAgICAgIGxldCByZW1haW5pbmdTcGFjZVB4OiBudW1iZXIgPSAoKGN1cnJlbnRBcHAuc3RhdGUuYXZhaWxhYmxlU3BhY2VQYWdlUHJldmlld1B4IC0gMiAqIHN0YXRpY01hcmdpbikgLSB0YXJnZXRXaWR0aFB4KTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUudGFyZ2V0UGFnZVByZXZpZXdIb2xkZXJNYXJnaW5QeCA9IHN0YXRpY01hcmdpbiArIChyZW1haW5pbmdTcGFjZVB4IC8gMik7IC8vIFRPRE8gZG8gd2UgbmVlZCBmbG9vcj8gMXB4IGVycm9yIFRPRE8gYWxzbyBicm93c2VyIGRpc3BsYXlzIHdpZHRoIHBpeGVscyB3aXRoIGZyYWN0aW9uXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLnRhcmdldFBhZ2VQcmV2aWV3V2lkdGhQeCA9IGN1cnJlbnRBcHAuc3RhdGUuYXZhaWxhYmxlU3BhY2VQYWdlUHJldmlld1B4IC0gcmVtYWluaW5nU3BhY2VQeDtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuaXNFbm91Z2hBdmFpbGFibGVTcGFjZVBhZ2VQcmV2aWV3ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5pc0Vub3VnaEF2YWlsYWJsZVNwYWNlUGFnZVByZXZpZXcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUudGFyZ2V0UGFnZVByZXZpZXdIb2xkZXJNYXJnaW5QeCA9IHN0YXRpY01hcmdpbjtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUudGFyZ2V0UGFnZVByZXZpZXdXaWR0aFB4ID0gdGFyZ2V0V2lkdGhQeDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5pc0RhdGFMb2FkZWQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRSZXNwb25zaXZlRGV2aWNlSW5kZXggPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuUmVzcG9uc2l2ZURldmljZXMuZmluZEluZGV4KHIgPT4gdGFyZ2V0V2lkdGhQeCA8IHIuV2lkdGhUaHJlc2hvbGQpOyAvLyBkZXBlbmRzIG9uIHNvcnQgb3JkZXJcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRSZXNwb25zaXZlRGV2aWNlSW5kZXggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0V2lkdGhQeCA9PSAwXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudFJlc3BvbnNpdmVEZXZpY2VJbmRleCA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbm90IGZvdW5kID0+IGxhcmdlciB0aGFuIGhpZ2hlc3RcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFJlc3BvbnNpdmVEZXZpY2VJZCA9IGN1cnJlbnRBcHAuc3RhdGUuaGlnaGVzdFdpZHRoVGhyZXNob2xkUmVzcG9uc2l2ZURldmljZUlkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50UmVzcG9uc2l2ZURldmljZUlkID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzW2N1cnJlbnRSZXNwb25zaXZlRGV2aWNlSW5kZXggLSAxXS5SZXNwb25zaXZlRGV2aWNlSWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGFkanVzdCBtZWRpYSBxdWVyeSBtaW4td2lkdGhzIG9mIHBhZ2UgcHJldmlldyBzdHlsZXMsIHN1Y2ggdGhhdCBwYWdlIHByZXZpZXcgc2hvd3MgcmVzcG9uc2l2ZSBkZXZpY2UgdmlldzsgaW5kZXBlbmRlbnQgb2YgY2xpZW50IHdpZHRoIGFuZCBVSSB3aWR0aFxyXG4gICAgICAgIC8vIGNzcyBtZWRpYSBxdWVyeSByZW5kZXJpbmcgb3JkZXIgb2YgYnJvd3NlcnMgaXMgbW9iaWxlIGZpcnN0IChubyBtaW4td2lkdGgsIG1pbi13aWR0aF8xIDwgbWluLXdpZHRoXzIgPCAuLi4pXHJcbiAgICAgICAgLy8gVE9ETyBjcmVhdGUgZHluYW1pYyBjbGllbnQgYnJlYWtwb2ludHMgc3VjaCB0aGF0IGEgYnJvd3NlciByZXNpemUgdG8gc21hbGxlciB2aWV3IGRvZXMgbm90IHRyaWdnZXIgc21hbGxlciBicmVha3BvaW50cyBiZWZvcmUgcmVjYWxjdWxhdGluZyB1aSBzaXplICsgY2xpZW50IGJyZWFrcG9pbnRzXHJcbiAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LmR5bmFtaWNDbGllbnRHcmlkQnJlYWtwb2ludHMgPSBbXTtcclxuICAgICAgICBsZXQgY2FsaWZvcm5pYUFwcFdpZHRoOiBudW1iZXIgfCB1bmRlZmluZWQgPSAkKHdpbmRvdykud2lkdGgoKTsgLy8gVE9ETyB1c2UgaW5uZXIgb3Igb3V0ZXIgd2lkdGhcclxuICAgICAgICBpZiAoY2FsaWZvcm5pYUFwcFdpZHRoID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjYWxpZm9ybmlhVUlXaWR0aCA9IGNhbGlmb3JuaWFBcHBXaWR0aCAtIGN1cnJlbnRBcHAuc3RhdGUuYXZhaWxhYmxlU3BhY2VQYWdlUHJldmlld1B4O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCByZXNwb25zaXZlRGV2aWNlOiBSZXNwb25zaXZlRGV2aWNlID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzW2ldO1xyXG4gICAgICAgICAgICBpZiAocmVzcG9uc2l2ZURldmljZS5XaWR0aFRocmVzaG9sZCA8IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgKyB4cyBhcmUgZGVmYXVsdCBjc3MgKG5vIG1lZGlhIHF1ZXJ5KSBhbmQgYWx3YXlzIGFwcGxpZWQgKG9yZGVyIG1hdHRlcnMsIHhzIGNzcyBvdmVyd3JpdGVzIGRlZmF1bHQgY3NzKVxyXG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdC9Ob25lID09IC0xOyBzbWFsbGVzdCBkZXZpY2UgPT0gMFxyXG4gICAgICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LmR5bmFtaWNDbGllbnRHcmlkQnJlYWtwb2ludHMucHVzaCgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zaXZlRGV2aWNlLldpZHRoVGhyZXNob2xkID09IDApIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy5keW5hbWljQ2xpZW50R3JpZEJyZWFrcG9pbnRzLnB1c2goMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXNwb25zaXZlIGRldmljZXMgZ2V0IGFuIGFkanVzdGVkIHZhbHVlIGZvciBXaWR0aFRocmVzaG9sZDogbG93ZXIgdGhhbiBjdXJyZW50IGNsaWVudCB3aWR0aCBmb3IgV2lkdGhUaHJlc2hvbGQgPCBjdXJyZW50UmVzcG9uc2l2ZURldmljZS5XaWR0aFRocmVzaG9sZDsgaGlnaGVyIHRoYW4gY2xpZW50IHdpZHRoIGZvciBXaWR0aFRocmVzaG9sZCA+IGN1cnJlbnRSZXNwb25zaXZlRGV2aWNlLldpZHRoVGhyZXNob2xkOyBtdXN0IGJlIHN0cmljdGx5IG1vbm90b25pY2FsbHkgaW5jcmVhc2luZ1xyXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnREZXZpY2VJbmRleCA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5SZXNwb25zaXZlRGV2aWNlcy5maW5kSW5kZXgociA9PiByLlJlc3BvbnNpdmVEZXZpY2VJZCA9PSBjdXJyZW50QXBwLnN0YXRlLmN1cnJlbnRSZXNwb25zaXZlRGV2aWNlSWQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNhZmV0eU1hcmdpblB4OiBudW1iZXIgPSA1MDsgLy8gc2Nyb2xsIGJhclxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPD0gY3VycmVudERldmljZUluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFkanVzdGVkQnJlYWtQb2ludCA9IGNhbGlmb3JuaWFBcHBXaWR0aCAtIHNhZmV0eU1hcmdpblB4IC0gKChjdXJyZW50RGV2aWNlSW5kZXggKyAxIC0gaSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy5keW5hbWljQ2xpZW50R3JpZEJyZWFrcG9pbnRzLnB1c2goYWRqdXN0ZWRCcmVha1BvaW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBhZGp1c3RlZEJyZWFrUG9pbnQgPSBjYWxpZm9ybmlhQXBwV2lkdGggKyBzYWZldHlNYXJnaW5QeCArIChpIC0gY3VycmVudERldmljZUluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcuZHluYW1pY0NsaWVudEdyaWRCcmVha3BvaW50cy5wdXNoKGFkanVzdGVkQnJlYWtQb2ludCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnJlbG9hZENzc1N0eWxlcygpO1xyXG4gICAgfTtcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL01vZGVscy9QYWdlUHJldmlldy50c3giLCJcInVzZSBzdHJpY3RcIjtcclxuaW1wb3J0ICogYXMgbWFxdWV0dGUgZnJvbSBcIm1hcXVldHRlXCI7XHJcbmNvbnN0IGggPSBtYXF1ZXR0ZS5oO1xyXG5pbXBvcnQgeyBQYWdlUHJldmlldyB9IGZyb20gXCIuLy4uL01vZGVscy9QYWdlUHJldmlld1wiO1xyXG5pbXBvcnQgeyBDYWxpZm9ybmlhVmlldywgTGF5b3V0Um93IH0gZnJvbSBcIi4uL01vZGVscy9DYWxpZm9ybmlhR2VuZXJhdGVkXCI7XHJcbmxldCBjdXJyZW50Vk06IFBhZ2VQcmV2aWV3Vk07XHJcblxyXG5leHBvcnQgY2xhc3MgUGFnZVByZXZpZXdWTSB7XHJcbiAgICAvLyBkYXRhXHJcbiAgICBwdWJsaWMgdGVtcE9yaWdpbmFsQ29udGVudDogc3RyaW5nID0gXCJcIjtcclxuICAgIHB1YmxpYyB0ZW1wQ29udGVudDogc3RyaW5nID0gXCJcIjtcclxuICAgIHB1YmxpYyBlZGl0ZWRMYXlvdXRBdG9tSWQ6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgc3R5bGVzT2ZFZGl0ZWRDb250ZW50OiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0ge307XHJcbiAgICBwdWJsaWMgYWN0aXZlQ2FsaWZvcm5pYVZpZXdJZDogbnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBhY3RpdmVDYWxpZm9ybmlhVmlld0JvZHlTdHlsZVN0cmluZzogc3RyaW5nID0gXCJcIjtcclxuICAgIHB1YmxpYyBhY3RpdmVDYWxpZm9ybmlhVmlld1N0eWxlU3RyaW5nOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgLy8gY29tcG9uZW50c1xyXG4gICAgcHVibGljIGNhbGlmb3JuaWFWaWV3UHJvamVjdG9yOiBtYXF1ZXR0ZS5NYXBwaW5nPENhbGlmb3JuaWFWaWV3LCB7IHJlbmRlck1hcXVldHRlOiAoKSA9PiBtYXF1ZXR0ZS5WTm9kZSB9PjtcclxuICAgIHB1YmxpYyBmaXhlZExheW91dFJvd3NQcm9qZWN0b3I6IG1hcXVldHRlLk1hcHBpbmc8TGF5b3V0Um93LCB7IHJlbmRlck1hcXVldHRlOiAoKSA9PiBtYXF1ZXR0ZS5WTm9kZSB9PjtcclxuXHJcbiAgICAvLyBjbGllbnQgc2V0dGluZ3NcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwYWdlUHJldmlld0FyZzogUGFnZVByZXZpZXcpIHtcclxuICAgICAgICBjdXJyZW50Vk0gPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY2FsaWZvcm5pYVZpZXdQcm9qZWN0b3IgPSBwYWdlUHJldmlld0FyZy5yZW5kZXJDYWxpZm9ybmlhVmlld0FycmF5KCk7XHJcbiAgICAgICAgdGhpcy5maXhlZExheW91dFJvd3NQcm9qZWN0b3IgPSBwYWdlUHJldmlld0FyZy5yZW5kZXJMYXlvdXRSb3dBcnJheSh0cnVlKTtcclxuICAgIH07XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9WaWV3TW9kZWxzL1BhZ2VQcmV2aWV3Vk0udHN4IiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2pzeC50c1wiIC8+XHJcblwidXNlIHN0cmljdFwiO1xyXG5pbXBvcnQgeyBWTm9kZSwgVk5vZGVQcm9wZXJ0aWVzIH0gZnJvbSBcIm1hcXVldHRlXCI7XHJcbmRlY2xhcmUgdmFyIHJlcXVpcmU6IGFueTtcclxudmFyIHZlbG9jaXR5OiBhbnkgPSByZXF1aXJlKFwidmVsb2NpdHktYW5pbWF0ZVwiKTtcclxuaW1wb3J0ICogYXMgbWFxdWV0dGUgZnJvbSBcIm1hcXVldHRlXCI7XHJcbmNvbnN0IGggPSBtYXF1ZXR0ZS5oO1xyXG5pbXBvcnQgeyBDYWxpZm9ybmlhQXBwLCBERUZBVUxUX0VYQ0VQVElPTiwgZ2V0QXJyYXlGb3JFbnVtLCBwYXJzZUludEZyb21BdHRyaWJ1dGUsIHBhcnNlU3RyaW5nRnJvbUF0dHJpYnV0ZSB9IGZyb20gXCIuL0NhbGlmb3JuaWFBcHBcIjtcclxuaW1wb3J0IHsgUHJvcGVydHlCYXJNb2RlLCBQcm9wZXJ0eUJhclZNLCBQb3B1cE1vZGUsIFBvcHVwU2Vjb25kYXJ5TW9kZSwgVHJhbnNhY3Rpb25Nb2RlIH0gZnJvbSBcIi4vLi4vVmlld01vZGVscy9Qcm9wZXJ0eUJhclZNXCI7XHJcbmltcG9ydCB7IFN0eWxlUXVhbnR1bSwgU3R5bGVBdG9tLCBTdHlsZVZhbHVlLCBTdHlsZUF0b21UeXBlLCBTdHlsZU1vbGVjdWxlLCBSZXNwb25zaXZlRGV2aWNlLCBTdHlsZU1vbGVjdWxlQXRvbU1hcHBpbmcsIExheW91dEJhc2UsIExheW91dFJvdywgTGF5b3V0Qm94LCBMYXlvdXRBdG9tLCBMYXlvdXRUeXBlLCBDYWxpZm9ybmlhVmlldywgU3BlY2lhbExheW91dEJveFR5cGUsIENvbnRlbnRBdG9tLCBDYWxpZm9ybmlhRXZlbnQgfSBmcm9tIFwiLi9DYWxpZm9ybmlhR2VuZXJhdGVkXCI7XHJcbmltcG9ydCB7IEVkaXRWaWV3TW9kZSwgUmVhZHlTdGF0ZSwgU2VsZWN0aW9uTW9kZSB9IGZyb20gXCIuL0NsaWVudFN0YXRlXCI7XHJcbmltcG9ydCAqIGFzIHBvcHBlcmpzIGZyb20gXCJwb3BwZXIuanNcIjtcclxuaW1wb3J0IHsgQ29udGVudEF0b21UeXBlIH0gZnJvbSBcIi4uL1R5cGV3cml0ZXIvQ29udGVudEF0b21UeXBlXCI7XHJcblxyXG5sZXQgY3VycmVudEFwcDogQ2FsaWZvcm5pYUFwcDtcclxuXHJcbmV4cG9ydCBjb25zdCBWRVJZX0hJR0hfVkFMVUU6IG51bWJlciA9IDIzMDAwMDAwMDA7XHJcblxyXG5lbnVtIENhbGlmb3JuaWFWaWV3U3BlY2lhbFN0eWxlIHtcclxuICAgIFZpZXcgPSAwLFxyXG4gICAgQm9keSA9IDEsXHJcbiAgICBIdG1sID0gMlxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgUHJvcGVydHlCYXIge1xyXG4gICAgcHVibGljIHZpZXdNb2RlbDogUHJvcGVydHlCYXJWTTtcclxuICAgIHByaXZhdGUgcHJvcGVydHlCYXJJbmRleDogbnVtYmVyID0gLTE7XHJcbiAgICBwcml2YXRlIF92aXNpYmxlTGF5b3V0QXRvbURvbU5vZGVSZWZlcmVuY2VzOiBIVE1MRWxlbWVudFtdID0gW107XHJcbiAgICBwcml2YXRlIF9hY3RpdmVWaWV3TGF5b3V0QXRvbURvbU5vZGVSZWZlcmVuY2VzOiB7IFtrZXk6IHN0cmluZ106IEhUTUxFbGVtZW50IH0gPSB7fTtcclxuICAgIHByaXZhdGUgX3Zpc2libGVMYXlvdXRBdG9tS2V5czogc3RyaW5nW10gPSBbXTtcclxuICAgIHByaXZhdGUgX21vc3RVcHBlclZpc2libGVMYXlvdXRBdG9tSWQ6IG51bWJlciA9IDA7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY2FsaWZvcm5pYUFwcEFyZzogQ2FsaWZvcm5pYUFwcCwgdGFyZ2V0SW5kZXg6IG51bWJlcikge1xyXG4gICAgICAgIGN1cnJlbnRBcHAgPSBjYWxpZm9ybmlhQXBwQXJnO1xyXG4gICAgICAgIHRoaXMucHJvcGVydHlCYXJJbmRleCA9IHRhcmdldEluZGV4O1xyXG4gICAgICAgIHRoaXMudmlld01vZGVsID0gbmV3IFByb3BlcnR5QmFyVk0odGhpcywgdGFyZ2V0SW5kZXgsIGNhbGlmb3JuaWFBcHBBcmcpO1xyXG4gICAgICAgIHRoaXMudmlld01vZGVsLmlzU3luY2VkV2l0aEJveFRyZWVUb1RoZUxlZnQgPSBmYWxzZTsvLyBUT0RPIHRhcmdldEluZGV4ICE9IDA7XHJcbiAgICAgICAgdGhpcy52aWV3TW9kZWwuaXNTeW5jZWRXaXRoUGFnZVByZXZpZXcgPSBmYWxzZTsvLyBUT0RPIHRhcmdldEluZGV4ID09IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgZ2V0IGN1cnJlbnRQcm9wZXJ0eUJhcigpOiBQcm9wZXJ0eUJhciB7XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRBcHAucHJvcGVydHlCYXJzW3RoaXMucHJvcGVydHlCYXJJbmRleF07XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgZ2V0IG5leHRFeGNlcHRMYXN0UHJvcGVydHlCYXIoKTogUHJvcGVydHlCYXIge1xyXG4gICAgICAgIGxldCBuZXh0UHJvcGVydHlCYXJJbmRleDogbnVtYmVyID0gdGhpcy5wcm9wZXJ0eUJhckluZGV4ICsgMTtcclxuICAgICAgICBpZiAobmV4dFByb3BlcnR5QmFySW5kZXggPCBjdXJyZW50QXBwLnN0YXRlLnZpc2libGVQcm9wZXJ0eUJhck1heENvdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50QXBwLnByb3BlcnR5QmFyc1tuZXh0UHJvcGVydHlCYXJJbmRleF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50UHJvcGVydHlCYXI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgZ2V0IHZpc2libGVMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXMoKTogSFRNTEVsZW1lbnRbXSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGVMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBnZXQgdmlzaWJsZUxheW91dEF0b21LZXlzKCk6IHN0cmluZ1tdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZUxheW91dEF0b21LZXlzO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgZ2V0IG1vc3RVcHBlclZpc2libGVMYXlvdXRBdG9tSWQoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbW9zdFVwcGVyVmlzaWJsZUxheW91dEF0b21JZDtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGdldCBhY3RpdmVWaWV3TGF5b3V0QXRvbURvbU5vZGVSZWZlcmVuY2VzKCk6IHsgW2tleTogc3RyaW5nXTogSFRNTEVsZW1lbnQgfSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVZpZXdMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJQcm9wZXJ0eUJhciA9ICgpOiBWTm9kZSA9PiB7XHJcbiAgICAgICAgbGV0IGRpdlByb3BlcnR5QmFyc1N0eWxlcyA9IHtcclxuICAgICAgICAgICAgLy8gVE9ETyBzY3JvbGwgc3luY1xyXG4gICAgICAgICAgICBcImZsZXhcIjogY3VycmVudEFwcC5zdGF0ZS5lZGl0Vmlld01vZGUgPT09IEVkaXRWaWV3TW9kZS5TaWRlYmFyT25seSA/IFwiMSAxIDIwMHB4XCIgOiBgMSAxIDIwMHB4YCwgLy8gcHJvcGVydHkgYmFyIHdpZHRoIG5vdCBpbnZhcmlhbnQgdG8gYnJvd3NlciB6b29tICglLXZhbHVlIHdvdWxkIGJlLCBidXQgZGVwZW5kcyBvbiB2aWV3cG9ydCBzaXplKVxyXG4gICAgICAgICAgICBcImRpc3BsYXlcIjogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgIFwiZmxleC1mbG93XCI6IFwicm93IG5vd3JhcFwiLFxyXG4gICAgICAgICAgICBcImhlaWdodFwiOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgXCJtaW4td2lkdGhcIjogXCIxMDBweFwiLFxyXG4gICAgICAgICAgICBcIndpZHRoXCI6IFwiMjAwcHhcIixcclxuICAgICAgICAgICAgXCJ6LWluZGV4XCI6IFwiMlwiIC8vIFRPRE8gZG9jdW1lbnRcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBwcm9wZXJ0eUJhclN0eWxlcyA9IHtcclxuICAgICAgICAgICAgXCJmbGV4XCI6IGN1cnJlbnRBcHAuc3RhdGUuZWRpdFZpZXdNb2RlID09PSBFZGl0Vmlld01vZGUuU2lkZWJhck9ubHkgPyBcIjEgMSAxcHhcIiA6IGAxIDEgMXB4YCwgLy8gcHJvcGVydHkgYmFyIHdpZHRoIG5vdCBpbnZhcmlhbnQgdG8gYnJvd3NlciB6b29tICglLXZhbHVlIHdvdWxkIGJlLCBidXQgZGVwZW5kcyBvbiB2aWV3cG9ydCBzaXplKVxyXG4gICAgICAgICAgICAvL1wid2lkdGhcIjogY3VycmVudEFwcC5zdGF0ZS5lZGl0Vmlld01vZGUgPT09IEVkaXRWaWV3TW9kZS5TaWRlYmFyT25seSA/IFwiYXV0b1wiIC8vXCIxMDAlXCIgOiBgJHtjdXJyZW50QXBwLmNvbnRyb2xBcmVhV2lkdGhQeH1weGAsXHJcbiAgICAgICAgICAgIC8vXCJkaXNwbGF5XCI6IFwiZmxleFwiLFxyXG4gICAgICAgICAgICAvL1wiZmxleC1mbG93XCI6IFwiY29sdW1uIG5vd3JhcFwiLFxyXG4gICAgICAgICAgICAvL1wib3ZlcmZsb3dcIjogXCJoaWRkZW5cIixcclxuICAgICAgICAgICAgLy9cIm1hcmdpbi10b3BcIjogLypjdXJyZW50QXBwLnN0YXRlLmlzU2hvd1NpZGViYXJPbmx5ID8gVE9ETyovY3VycmVudEFwcC5uYXZpZ2F0aW9uSGVpZ3RoUHggKyBcInB4XCIsIFRPRE8gPT4gbW92ZWQgdG8gbmF2aWdhdGlvbiBlbGVtZW50XHJcbiAgICAgICAgICAgIFwiYm9yZGVyLXJpZ2h0XCI6IHRoaXMucHJvcGVydHlCYXJJbmRleCA8IChjdXJyZW50QXBwLnByb3BlcnR5QmFyQ291bnQgLSAxKSAmJiB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuY3VycmVudFByb3BlcnR5QmFyTW9kZSA9PT0gUHJvcGVydHlCYXJNb2RlLkNhbGlmb3JuaWFWaWV3ID8gXCJzb2xpZCAzcHggYmxhY2tcIiA6IHVuZGVmaW5lZCwgLy8gVE9ETyBwYXR0ZXJuXHJcbiAgICAgICAgICAgIFwid2lkdGhcIjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgIFwiaGVpZ2h0XCI6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICBcImRpc3BsYXlcIjogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgIFwiZmxleC1mbG93XCI6IFwiY29sdW1uIG5vd3JhcFwiXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gPGRpdiBrZXk9e2BwJHt0aGlzLnByb3BlcnR5QmFySW5kZXgudG9TdHJpbmcoKX1gfSBzdHlsZXM9e2RpdlByb3BlcnR5QmFyc1N0eWxlc30+XHJcbiAgICAgICAgICAgIDxkaXYga2V5PVwidjBcIiBzdHlsZXM9e3Byb3BlcnR5QmFyU3R5bGVzfT5cclxuICAgICAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZW5kZXJQcm9wZXJ0eUJhck5hdmlnYXRpb24oKX1cclxuICAgICAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZW5kZXJQcm9wZXJ0eUJhckNvbnRyb2xzKCl9XHJcbiAgICAgICAgICAgICAgICB7dGhpcy5wcm9wZXJ0eUJhckluZGV4ICE9IDAgPyB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZW5kZXJQcm9wZXJ0eUJhclBvcHBlcnNSZW5kZXJPbmNlKCkgOiB1bmRlZmluZWR9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlbmRlclByb3BlcnR5QmFyUG9wcGVyc1JlbmRlck9uY2UgPSAoKTogVk5vZGUgPT4geyAvLyBUT0RPIGp1c3QgcmVuZGVyIG9uY2UuLi5cclxuICAgICAgICByZXR1cm4gPGRpdiBrZXk9XCJrMFwiPlxyXG4gICAgICAgICAgICB7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucmVuZGVyQWRkQ3NzUHJvcGVydHlQb3B1cCgpfVxyXG4gICAgICAgICAgICB7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucmVuZGVyQWxsQ3NzUHJvcGVydGllc1BvcHVwKCl9XHJcbiAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZW5kZXJVcGRhdGVDc3NWYWx1ZVBvcHVwKCl9XHJcbiAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZW5kZXJNYXRjaGluZ1F1YW50dW1zUG9wdXAoKX1cclxuICAgICAgICAgICAge3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnJlbmRlclVwZGF0ZUNzc1F1YW50dW1Qb3B1cCgpfVxyXG4gICAgICAgICAgICB7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucmVuZGVyQWxsQ3NzUHJvcGVydGllc0ZvclF1YW50dW1Qb3B1cCgpfVxyXG4gICAgICAgICAgICB7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaW5zZXJ0TGF5b3V0Um93SW50b1ZpZXdQb3B1cCgpfVxyXG4gICAgICAgICAgICB7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaW5zZXJ0TGF5b3V0QXRvbUludG9Cb3hQb3B1cCgpfVxyXG4gICAgICAgICAgICB7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaW5zZXJ0TGF5b3V0Qm94SW50b0JveFBvcHVwKCl9XHJcbiAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5tb3ZlU3R5bGVBdG9tVG9SZXNwb25zaXZlRGV2aWNlUG9wdXAoKX1cclxuICAgICAgICAgICAgey8qdGhpcy5jdXJyZW50UHJvcGVydHlCYXIubW92ZUxheW91dE1vbGVjdWxlSW50b1BvcHVwKCkqL31cclxuICAgICAgICAgICAgey8qdGhpcy5jdXJyZW50UHJvcGVydHlCYXIubW92ZUxheW91dE1vbGVjdWxlQmVmb3JlUG9wdXAoKSovfVxyXG4gICAgICAgICAgICB7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucmVuZGVyU2VsZWN0SW50ZXJhY3Rpb25UYXJnZXRQb3B1cCgpfVxyXG4gICAgICAgICAgICB7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucmVuZGVyU2VsZWN0SW50ZXJhY3Rpb25UYXJnZXRMYXlvdXRGaWx0ZXJQb3B1cCgpfVxyXG4gICAgICAgICAgICB7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucmVuZGVyU2hhcmVDYWxpZm9ybmlhUHJvamVjdFBvcHVwKCl9XHJcbiAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZW5kZXJDYWxpZm9ybmlhVmlld1NlbGVjdGlvblBvcHVwKCl9XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyUHJvcGVydHlCYXJOYXZpZ2F0aW9uID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICBsZXQgcHJvcGVydHlCYXJOYXZpZ2F0aW9uU3R5bGVzID0ge1xyXG4gICAgICAgICAgICBcIm1hcmdpbi10b3BcIjogLypjdXJyZW50QXBwLnN0YXRlLmlzU2hvd1NpZGViYXJPbmx5ID8gVE9ETyovY3VycmVudEFwcC5uYXZpZ2F0aW9uSGVpZ3RoUHggKyBcInB4XCIsXHJcbiAgICAgICAgICAgIFwiZGlzcGxheVwiOiBgZmxleGAsXHJcbiAgICAgICAgICAgIFwiZmxleC1mbG93XCI6IFwicm93IG5vd3JhcFwiLFxyXG4gICAgICAgICAgICBcImhlaWdodFwiOiBgYXV0b2AsXHJcbiAgICAgICAgICAgIFwid2lkdGhcIjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgIFwiZmxleFwiOiBcIjAgMCBhdXRvXCJcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBoaWRkZW5Nb2RlQnV0dG9uczogbnVtYmVyW10gPSBbXHJcbiAgICAgICAgICAgIFByb3BlcnR5QmFyTW9kZS5Ob25lLFxyXG4gICAgICAgICAgICBQcm9wZXJ0eUJhck1vZGUuQWxsU3R5bGVBdG9tcyxcclxuICAgICAgICAgICAgUHJvcGVydHlCYXJNb2RlLkxheW91dEF0b21zLFxyXG4gICAgICAgICAgICBQcm9wZXJ0eUJhck1vZGUuTGF5b3V0QmFzZSxcclxuICAgICAgICAgICAgUHJvcGVydHlCYXJNb2RlLkxheW91dE1vbGVjdWxlcyxcclxuICAgICAgICAgICAgUHJvcGVydHlCYXJNb2RlLlN0eWxlTW9sZWN1bGVcclxuICAgICAgICBdOyAvLyBUT0RPIHJlbmRlciB3aG9sZSBVSSBzdGF0aWNcclxuICAgICAgICBsZXQgcHJvcGVydHlCYXJNb2RlSWNvblN0cmluZ3M6IHsgW2tleTogbnVtYmVyXTogc3RyaW5nIH0gPSB7fTtcclxuICAgICAgICBwcm9wZXJ0eUJhck1vZGVJY29uU3RyaW5nc1tQcm9wZXJ0eUJhck1vZGUuQWxsQ2FsaWZvcm5pYVZpZXdzXSA9IFwiVlwiO1xyXG4gICAgICAgIHByb3BlcnR5QmFyTW9kZUljb25TdHJpbmdzW1Byb3BlcnR5QmFyTW9kZS5BbGxMYXlvdXRNb2xlY3VsZXNdID0gXCJMXCI7XHJcbiAgICAgICAgcHJvcGVydHlCYXJNb2RlSWNvblN0cmluZ3NbUHJvcGVydHlCYXJNb2RlLkFsbFN0eWxlTW9sZWN1bGVzXSA9IFwiU1wiO1xyXG4gICAgICAgIHByb3BlcnR5QmFyTW9kZUljb25TdHJpbmdzW1Byb3BlcnR5QmFyTW9kZS5BbGxTdHlsZVF1YW50dW1zXSA9IFwiUVwiO1xyXG4gICAgICAgIHByb3BlcnR5QmFyTW9kZUljb25TdHJpbmdzW1Byb3BlcnR5QmFyTW9kZS5DYWxpZm9ybmlhVmlld10gPSBcIjopXCI7XHJcbiAgICAgICAgbGV0IHByb3BlcnR5QmFyTW9kZUJ1dHRvbnM6IChWTm9kZSB8IHVuZGVmaW5lZClbXSA9IGdldEFycmF5Rm9yRW51bShQcm9wZXJ0eUJhck1vZGUpLm1hcCgodHlwZTogc3RyaW5nLCBpbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBtb2RlQnV0dG9uU3R5bGVzID0ge1xyXG4gICAgICAgICAgICAgICAgXCJjb2xvclwiOiBpbmRleCA9PT0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmN1cnJlbnRQcm9wZXJ0eUJhck1vZGUgPyBcInJlZFwiIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjFweFwiLFxyXG4gICAgICAgICAgICAgICAgXCJtYXJnaW4tcmlnaHRcIjogXCI1cHhcIixcclxuICAgICAgICAgICAgICAgIFwibWFyZ2luLWxlZnRcIjogXCI1cHhcIixcclxuICAgICAgICAgICAgICAgIFwiZmxleFwiOiBcIjEgMSAxcHhcIlxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoaGlkZGVuTW9kZUJ1dHRvbnMuZmluZEluZGV4KGVsID0+IGVsID09IGluZGV4KSAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gPGJ1dHRvbiBrZXk9e2luZGV4fSByb2xlPVwiYnV0dG9uXCIgcGlkPXtpbmRleC50b1N0cmluZygpfSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zZXRQcm9wZXJ0eUJhck1vZGV9IHN0eWxlcz17bW9kZUJ1dHRvblN0eWxlc30+e3Byb3BlcnR5QmFyTW9kZUljb25TdHJpbmdzW2luZGV4XSAhPT0gdW5kZWZpbmVkID8gcHJvcGVydHlCYXJNb2RlSWNvblN0cmluZ3NbaW5kZXhdIDogdHlwZX08L2J1dHRvbj4gYXMgVk5vZGU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIDxkaXYga2V5PVwibjBcIiBzdHlsZXM9e3Byb3BlcnR5QmFyTmF2aWdhdGlvblN0eWxlc30+XHJcbiAgICAgICAgICAgIHtwcm9wZXJ0eUJhck1vZGVCdXR0b25zfVxyXG4gICAgICAgICAgICB7dGhpcy5wcm9wZXJ0eUJhckluZGV4ID09IDAgPyA8YnV0dG9uIGtleT1cImFcIiBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5sb2dvdXRQb3B1cENsaWNrSGFuZGxlcn0gc3R5bGVzPXt7IFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsIFwid2lkdGhcIjogXCJhdXRvXCIgfX0+JiM5OTkzOyYjODIzMDs8L2J1dHRvbj4gOiB1bmRlZmluZWR9XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2V0UHJvcGVydHlCYXJNb2RlID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5jdXJyZW50UHJvcGVydHlCYXJNb2RlID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwicGlkXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyUHJvcGVydHlCYXJDb250cm9scyA9ICgpOiBWTm9kZSA9PiB7XHJcbiAgICAgICAgbGV0IGRpdlByb3BlcnR5QmFyQ29udHJvbHNTdHlsZXMgPSB7XHJcbiAgICAgICAgICAgIFwiZmxleFwiOiBcIjEgMSBhdXRvXCIsXHJcbiAgICAgICAgICAgIFwiaGVpZ2h0XCI6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICBcIndpZHRoXCI6IFwiMTAwJVwiXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgcHJvcGVydHlCYXJDb250cm9sc1N0eWxlcyA9IHtcclxuICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgXCJoZWlnaHRcIjogXCIxMDAlXCIsIC8vIFRPRE8gZml4bWVcclxuICAgICAgICAgICAgXCJvdmVyZmxvd1wiOiBcImF1dG9cIlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIDxkaXYga2V5PXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuY3VycmVudFByb3BlcnR5QmFyTW9kZX0gc3R5bGVzPXtkaXZQcm9wZXJ0eUJhckNvbnRyb2xzU3R5bGVzfT5cclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmN1cnJlbnRQcm9wZXJ0eUJhck1vZGUgPT09IFByb3BlcnR5QmFyTW9kZS5BbGxTdHlsZUF0b21zID9cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17UHJvcGVydHlCYXJNb2RlLkFsbFN0eWxlQXRvbXN9IHN0eWxlcz17cHJvcGVydHlCYXJDb250cm9sc1N0eWxlc30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc3R5bGVBdG9tUHJvamVjdG9yLnJlc3VsdHMubWFwKHIgPT4gci5yZW5kZXJNYXF1ZXR0ZSgpKX1cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5jdXJyZW50UHJvcGVydHlCYXJNb2RlID09PSBQcm9wZXJ0eUJhck1vZGUuQWxsU3R5bGVRdWFudHVtcyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXtQcm9wZXJ0eUJhck1vZGUuQWxsU3R5bGVRdWFudHVtc30gc3R5bGVzPXtwcm9wZXJ0eUJhckNvbnRyb2xzU3R5bGVzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZW5kZXJTdHlsZVF1YW50dW1Db250cm9scygpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zdHlsZVF1YW50dW1Qcm9qZWN0b3IucmVzdWx0cy5tYXAociA9PiByLnJlbmRlck1hcXVldHRlKCkpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuY3VycmVudFByb3BlcnR5QmFyTW9kZSA9PT0gUHJvcGVydHlCYXJNb2RlLkFsbFN0eWxlTW9sZWN1bGVzID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXtQcm9wZXJ0eUJhck1vZGUuQWxsU3R5bGVNb2xlY3VsZXN9IHN0eWxlcz17cHJvcGVydHlCYXJDb250cm9sc1N0eWxlc30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zdHlsZU1vbGVjdWxlUHJvamVjdG9yLnJlc3VsdHMubWFwKHIgPT4gci5yZW5kZXJNYXF1ZXR0ZSgpKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAodGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmN1cnJlbnRQcm9wZXJ0eUJhck1vZGUgPT09IFByb3BlcnR5QmFyTW9kZS5TdHlsZU1vbGVjdWxlKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9e1Byb3BlcnR5QmFyTW9kZS5BbGxTdHlsZU1vbGVjdWxlc30gc3R5bGVzPXtwcm9wZXJ0eUJhckNvbnRyb2xzU3R5bGVzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnJlbmRlclN0eWxlTW9sZWN1bGVDb250cm9scyh0aGlzKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5jdXJyZW50UHJvcGVydHlCYXJNb2RlID09PSBQcm9wZXJ0eUJhck1vZGUuTGF5b3V0QXRvbXMgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17UHJvcGVydHlCYXJNb2RlLkxheW91dEF0b21zfSBzdHlsZXM9e3Byb3BlcnR5QmFyQ29udHJvbHNTdHlsZXN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5pbnN0YW5jZWFibGVBdG9tUHJvamVjdG9yLnJlc3VsdHMubWFwKHIgPT4gci5yZW5kZXJNYXF1ZXR0ZSgpKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmN1cnJlbnRQcm9wZXJ0eUJhck1vZGUgPT09IFByb3BlcnR5QmFyTW9kZS5MYXlvdXRNb2xlY3VsZXMgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9e1Byb3BlcnR5QmFyTW9kZS5MYXlvdXRNb2xlY3VsZXN9IHN0eWxlcz17cHJvcGVydHlCYXJDb250cm9sc1N0eWxlc30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5pbnN0YW5jZWFibGVNb2xlY3VsZVByb2plY3Rvci5yZXN1bHRzLm1hcChyID0+IHIucmVuZGVyTWFxdWV0dGUoKSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmN1cnJlbnRQcm9wZXJ0eUJhck1vZGUgPT09IFByb3BlcnR5QmFyTW9kZS5BbGxMYXlvdXRNb2xlY3VsZXMgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXtQcm9wZXJ0eUJhck1vZGUuQWxsTGF5b3V0TW9sZWN1bGVzfSBzdHlsZXM9e3Byb3BlcnR5QmFyQ29udHJvbHNTdHlsZXN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmFsbExheW91dE1vbGVjdWxlc1Byb2plY3Rvci5yZXN1bHRzLm1hcChyID0+IHIucmVuZGVyTWFxdWV0dGUoKSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuY3VycmVudFByb3BlcnR5QmFyTW9kZSA9PT0gUHJvcGVydHlCYXJNb2RlLkxheW91dEJhc2UgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17UHJvcGVydHlCYXJNb2RlLkxheW91dEJhc2V9IHN0eWxlcz17cHJvcGVydHlCYXJDb250cm9sc1N0eWxlc30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucmVuZGVyTGF5b3V0QmFzZUNvbnRyb2xzKCl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5jdXJyZW50UHJvcGVydHlCYXJNb2RlID09PSBQcm9wZXJ0eUJhck1vZGUuQWxsQ2FsaWZvcm5pYVZpZXdzID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXtQcm9wZXJ0eUJhck1vZGUuQWxsQ2FsaWZvcm5pYVZpZXdzfSBzdHlsZXM9e3Byb3BlcnR5QmFyQ29udHJvbHNTdHlsZXN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZW5kZXJDYWxpZm9ybmlhVmlld0NvbnRyb2xzV2hlbkFsbCgpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuYWxsQ2FsaWZvcm5pYVZpZXdzUHJvamVjdG9yLnJlc3VsdHMubWFwKHIgPT4gci5yZW5kZXJNYXF1ZXR0ZSgpKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuY3VycmVudFByb3BlcnR5QmFyTW9kZSA9PT0gUHJvcGVydHlCYXJNb2RlLkNhbGlmb3JuaWFWaWV3ID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17UHJvcGVydHlCYXJNb2RlLkNhbGlmb3JuaWFWaWV3fSBzdHlsZXM9e3Byb3BlcnR5QmFyQ29udHJvbHNTdHlsZXN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucmVuZGVyQ2FsaWZvcm5pYVZpZXdDb250cm9scygpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA8L2Rpdj4gYXMgVk5vZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qcHVibGljIHNjcm9sbFRPRE8gPSAoZXZ0OiBVSUV2ZW50KSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJpbiBzY3JvbGxcIik7XHJcbiAgICAgICAgbGV0IHNjcm9sbGVkRWxlbWVudDogSFRNTEVsZW1lbnQgPSBldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgIC8vIFRPRE8gc2VtaS1jb25zdFxyXG4gICAgICAgIGxldCBzY3JvbGxWZXJ0aWNhbE1pblB4OiBudW1iZXIgPSAwO1xyXG4gICAgICAgIGxldCBzY3JvbGxWZXJ0aWNhbE1heFB4OiBudW1iZXIgPSAyMjI7XHJcbiAgICAgICAgc2Nyb2xsVmVydGljYWxNYXhQeCA9IHNjcm9sbGVkRWxlbWVudC5zY3JvbGxIZWlnaHQgLSBzY3JvbGxlZEVsZW1lbnQuY2xpZW50SGVpZ2h0Oy8vc2Nyb2xsZWRFbGVtZW50LnNjcm9sbEhlaWdodCAtICgoKHNjcm9sbGVkRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCBhcyBIVE1MRWxlbWVudCkubGFzdEVsZW1lbnRDaGlsZCBhcyBIVE1MRWxlbWVudCkuZmlyc3RFbGVtZW50Q2hpbGQgYXMgSFRNTEVsZW1lbnQpLmNsaWVudEhlaWdodDtcclxuICAgICAgICBsZXQgc2Nyb2xsVGFyZ2V0Q3NzVmFsdWVNaW46IG51bWJlciA9IDA7XHJcbiAgICAgICAgbGV0IHNjcm9sbFRhcmdldENzc1ZhbHVlTWF4OiBudW1iZXIgPSAyMjI7XHJcbiAgICAgICAgbGV0IHNjcm9sbERlbHRhU3RhcjogbnVtYmVyID0gc2Nyb2xsVmVydGljYWxNYXhQeCAtIHNjcm9sbFZlcnRpY2FsTWluUHg7XHJcbiAgICAgICAgbGV0IGlzSW52ZXJ0ZWQ6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgICAgIC8vIC0tLVxyXG4gICAgICAgIGlmIChzY3JvbGxlZEVsZW1lbnQuc2Nyb2xsVG9wID4gc2Nyb2xsVmVydGljYWxNaW5QeCB8fCBzY3JvbGxlZEVsZW1lbnQuc2Nyb2xsVG9wIDwgc2Nyb2xsVmVydGljYWxNYXhQeCkgeyAvL1RPRE8gbmVlZCB0byBzYXZlIHN0YXRlIG9mIHByZXZpb3VzIHNjcm9sbCBldmVudCBmb3IgdGhlIGNhc2Ugd2hlbiB0aGUgc2Nyb2xsIGRpc3RhbmNlIGlzIGxhcmdlXHJcbiAgICAgICAgICAgIGxldCBzY3JvbGxEZWx0YTogbnVtYmVyID0gc2Nyb2xsZWRFbGVtZW50LnNjcm9sbFRvcCAtIHNjcm9sbFZlcnRpY2FsTWluUHg7XHJcbiAgICAgICAgICAgIGxldCBzY3JvbGxGcmFjdGlvbjogbnVtYmVyID0gKHNjcm9sbERlbHRhIC8gc2Nyb2xsRGVsdGFTdGFyKTtcclxuICAgICAgICAgICAgaWYgKGlzSW52ZXJ0ZWQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHNjcm9sbEZyYWN0aW9uID0gMS4wIC0gc2Nyb2xsRnJhY3Rpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHNjcm9sbFRhcmdldENzc1ZhbHVlOiBudW1iZXIgPSBzY3JvbGxGcmFjdGlvbiAqIChzY3JvbGxUYXJnZXRDc3NWYWx1ZU1heCAtIHNjcm9sbFRhcmdldENzc1ZhbHVlTWluKSArIHNjcm9sbFRhcmdldENzc1ZhbHVlTWluO1xyXG4gICAgICAgICAgICBsZXQgc2Nyb2xsVGFyZ2V0Q3NzU3RyaW5nOiBzdHJpbmcgPSBgcmdiKCR7c2Nyb2xsVGFyZ2V0Q3NzVmFsdWV9LCR7c2Nyb2xsVGFyZ2V0Q3NzVmFsdWV9LCR7c2Nyb2xsVGFyZ2V0Q3NzVmFsdWV9KWA7XHJcbiAgICAgICAgICAgIHNjcm9sbGVkRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBzY3JvbGxUYXJnZXRDc3NTdHJpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgfTsqL1xyXG5cclxuICAgIC8qcHVibGljIHNjcm9sbFRPRE8gPSAoZXZ0OiBVSUV2ZW50KSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJpbiBzY3JvbGxcIik7XHJcbiAgICAgICAgbGV0IHNjcm9sbGVkRWxlbWVudDogSFRNTEVsZW1lbnQgPSBldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgIC8vIFRPRE8gc2VtaS1jb25zdFxyXG4gICAgICAgIGxldCBzY3JvbGxWZXJ0aWNhbE1pblB4OiBudW1iZXIgPSAwO1xyXG4gICAgICAgIGxldCBzY3JvbGxWZXJ0aWNhbE1heFB4OiBudW1iZXIgPSAyMjI7XHJcbiAgICAgICAgc2Nyb2xsVmVydGljYWxNYXhQeCA9IHNjcm9sbGVkRWxlbWVudC5zY3JvbGxIZWlnaHQgLSBzY3JvbGxlZEVsZW1lbnQuY2xpZW50SGVpZ2h0Oy8vc2Nyb2xsZWRFbGVtZW50LnNjcm9sbEhlaWdodCAtICgoKHNjcm9sbGVkRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCBhcyBIVE1MRWxlbWVudCkubGFzdEVsZW1lbnRDaGlsZCBhcyBIVE1MRWxlbWVudCkuZmlyc3RFbGVtZW50Q2hpbGQgYXMgSFRNTEVsZW1lbnQpLmNsaWVudEhlaWdodDtcclxuICAgICAgICBsZXQgc2Nyb2xsVGFyZ2V0Q3NzVmFsdWVNaW46IG51bWJlciA9IDA7XHJcbiAgICAgICAgbGV0IHNjcm9sbFRhcmdldENzc1ZhbHVlTWF4OiBudW1iZXIgPSA0MDtcclxuICAgICAgICBsZXQgc2Nyb2xsRGVsdGFTdGFyOiBudW1iZXIgPSBzY3JvbGxWZXJ0aWNhbE1heFB4IC0gc2Nyb2xsVmVydGljYWxNaW5QeDtcclxuICAgICAgICBsZXQgaXNJbnZlcnRlZDogYm9vbGVhbiA9IHRydWU7XHJcbiAgICAgICAgLy8gLS0tXHJcbiAgICAgICAgaWYgKHNjcm9sbGVkRWxlbWVudC5zY3JvbGxUb3AgPiBzY3JvbGxWZXJ0aWNhbE1pblB4IHx8IHNjcm9sbGVkRWxlbWVudC5zY3JvbGxUb3AgPCBzY3JvbGxWZXJ0aWNhbE1heFB4KSB7IC8vVE9ETyBuZWVkIHRvIHNhdmUgc3RhdGUgb2YgcHJldmlvdXMgc2Nyb2xsIGV2ZW50IGZvciB0aGUgY2FzZSB3aGVuIHRoZSBzY3JvbGwgZGlzdGFuY2UgaXMgbGFyZ2VcclxuICAgICAgICAgICAgbGV0IHNjcm9sbERlbHRhOiBudW1iZXIgPSBzY3JvbGxlZEVsZW1lbnQuc2Nyb2xsVG9wIC0gc2Nyb2xsVmVydGljYWxNaW5QeDtcclxuICAgICAgICAgICAgbGV0IHNjcm9sbEZyYWN0aW9uOiBudW1iZXIgPSAoc2Nyb2xsRGVsdGEgLyBzY3JvbGxEZWx0YVN0YXIpO1xyXG4gICAgICAgICAgICBpZiAoaXNJbnZlcnRlZCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsRnJhY3Rpb24gPSAxLjAgLSBzY3JvbGxGcmFjdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgc2Nyb2xsVGFyZ2V0Q3NzVmFsdWU6IG51bWJlciA9IHNjcm9sbEZyYWN0aW9uICogKHNjcm9sbFRhcmdldENzc1ZhbHVlTWF4IC0gc2Nyb2xsVGFyZ2V0Q3NzVmFsdWVNaW4pICsgc2Nyb2xsVGFyZ2V0Q3NzVmFsdWVNaW47XHJcbiAgICAgICAgICAgIGxldCBwYWRkaW5nVGFyZ2V0Q3NzU3RyaW5nOiBzdHJpbmcgPSBgJHtzY3JvbGxUYXJnZXRDc3NWYWx1ZX1weGA7XHJcbiAgICAgICAgICAgIHNjcm9sbGVkRWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9IHBhZGRpbmdUYXJnZXRDc3NTdHJpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgfTsqL1xyXG5cclxuICAgIC8qcHJpdmF0ZSBpc0FuaW1hdGlvblJ1bm5pbmc6IGJvb2xlYW4gPSBmYWxzZTsgVE9ETyBjb2RlIHNhbXBsZXMgYW5pbWF0aW9ucyBvbiBzY3JvbGwgcG9zaXRpb24gcmVhY2hpbmcvbGVhdmluZyB0b3BcclxuICAgIHByaXZhdGUgaXNBbmltYXRpb25JblNlY29uZFN0YXRlOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgcHVibGljIHNjcm9sbFRPRE8gPSAoZXZ0OiBVSUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IHNjcm9sbGVkRWxlbWVudDogSFRNTEVsZW1lbnQgPSBldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgIC8vIFRPRE8gc2VtaS1jb25zdFxyXG4gICAgICAgIGxldCBzY3JvbGxWZXJ0aWNhbE1pblB4OiBudW1iZXIgPSAwO1xyXG4gICAgICAgIGxldCBzY3JvbGxWZXJ0aWNhbE1heFB4OiBudW1iZXIgPSAyMjI7XHJcbiAgICAgICAgLy9zY3JvbGxWZXJ0aWNhbE1heFB4ID0gc2Nyb2xsZWRFbGVtZW50LnNjcm9sbEhlaWdodCAtIHNjcm9sbGVkRWxlbWVudC5jbGllbnRIZWlnaHQ7Ly9zY3JvbGxlZEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gKCgoc2Nyb2xsZWRFbGVtZW50LmZpcnN0RWxlbWVudENoaWxkIGFzIEhUTUxFbGVtZW50KS5sYXN0RWxlbWVudENoaWxkIGFzIEhUTUxFbGVtZW50KS5maXJzdEVsZW1lbnRDaGlsZCBhcyBIVE1MRWxlbWVudCkuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIGxldCBzY3JvbGxUYXJnZXRDc3NWYWx1ZU1pbjogbnVtYmVyID0gMDtcclxuICAgICAgICBsZXQgc2Nyb2xsVGFyZ2V0Q3NzVmFsdWVNYXg6IG51bWJlciA9IDQwO1xyXG4gICAgICAgIGxldCBzY3JvbGxEZWx0YVN0YXI6IG51bWJlciA9IHNjcm9sbFZlcnRpY2FsTWF4UHggLSBzY3JvbGxWZXJ0aWNhbE1pblB4O1xyXG4gICAgICAgIGxldCBpc0ludmVydGVkOiBib29sZWFuID0gdHJ1ZTtcclxuICAgICAgICAvLyAtLS1cclxuICAgICAgICAvLyBhbmltYXRpb246IGZvbGQgaW4gd2hlbiBzY3JvbGxpbmcgYXdheSBmcm9tIHRvcFxyXG4gICAgICAgIGxldCBpc0ZpcnN0VHJhbnNpdGlvbjogYm9vbGVhbiA9ICF0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pc0FuaW1hdGlvbkluU2Vjb25kU3RhdGU7XHJcbiAgICAgICAgaWYgKHNjcm9sbGVkRWxlbWVudC5zY3JvbGxUb3AgPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIHRyYW5zaXRpb24gMiA9PiAxXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pc0FuaW1hdGlvbkluU2Vjb25kU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pc0FuaW1hdGlvblJ1bm5pbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2ZWxvY2l0eS5hbmltYXRlKHNjcm9sbGVkRWxlbWVudCwgXCJzdG9wXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmlzQW5pbWF0aW9uUnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgeyAvLyBzY3JvbGxUb3AgPT0gMFxyXG4gICAgICAgICAgICAvLyB0cmFuc2l0aW9uIDEgPT4gMlxyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaXNBbmltYXRpb25JblNlY29uZFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaXNBbmltYXRpb25SdW5uaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVsb2NpdHkuYW5pbWF0ZShzY3JvbGxlZEVsZW1lbnQsIFwic3RvcFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pc0FuaW1hdGlvblJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGR1cmF0aW9uTWF4OiBudW1iZXIgPSAxMDA7XHJcbiAgICAgICAgbGV0IHBhZGRpbmdMZWZ0OiBzdHJpbmcgPSBzY3JvbGxlZEVsZW1lbnQuc3R5bGUubWFyZ2luTGVmdCBhcyBzdHJpbmc7XHJcbiAgICAgICAgbGV0IHBhZGRpbmdMZWZ0UHg6IG51bWJlciA9IHBhcnNlSW50KHBhZGRpbmdMZWZ0LnN1YnN0cmluZygwLCBwYWRkaW5nTGVmdC5sZW5ndGggLSAyKSk7XHJcbiAgICAgICAgaWYgKGlzRmlyc3RUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmlzQW5pbWF0aW9uSW5TZWNvbmRTdGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGxldCBkdXJhdGlvbkRlbHRhID0gKHBhZGRpbmdMZWZ0UHggLSAwKSAvIDQwLjAgKiBkdXJhdGlvbk1heDtcclxuICAgICAgICAgICAgaWYgKGR1cmF0aW9uRGVsdGEgPiAxMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaXNBbmltYXRpb25SdW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZlbG9jaXR5LmFuaW1hdGUoc2Nyb2xsZWRFbGVtZW50LCB7IFwibWFyZ2luLWxlZnRcIjogMCB9LCB7IGR1cmF0aW9uOiBkdXJhdGlvbkRlbHRhLCBlYXNpbmc6IFwiZWFzZS1pblwiLCBjb21wbGV0ZTogKCkgPT4geyB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pc0FuaW1hdGlvblJ1bm5pbmcgPSBmYWxzZTsgfSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNjcm9sbGVkRWxlbWVudC5zdHlsZS5tYXJnaW5MZWZ0ID0gXCIwcHhcIjtcclxuICAgICAgICAgICAgfSAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaXNBbmltYXRpb25JblNlY29uZFN0YXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vZG9tTm9kZS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XHJcbiAgICAgICAgICAgIGxldCBkdXJhdGlvbkRlbHRhID0gKDQwIC0gcGFkZGluZ0xlZnRQeCkgLyA0MC4wICogZHVyYXRpb25NYXg7XHJcbiAgICAgICAgICAgIGlmIChkdXJhdGlvbkRlbHRhID4gMTApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmlzQW5pbWF0aW9uUnVubmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eS5hbmltYXRlKHNjcm9sbGVkRWxlbWVudCwgeyBcIm1hcmdpbi1sZWZ0XCI6IDQwIH0sIHsgZHVyYXRpb246IGR1cmF0aW9uRGVsdGEsIGVhc2luZzogXCJlYXNlLW91dFwiLCBjb21wbGV0ZTogKCkgPT4geyB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pc0FuaW1hdGlvblJ1bm5pbmcgPSBmYWxzZTsgfSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNjcm9sbGVkRWxlbWVudC5zdHlsZS5tYXJnaW5MZWZ0ID0gXCI0MHB4XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9OyovXHJcblxyXG4gICAgcHVibGljIHJlbmRlclN0eWxlTW9sZWN1bGVDb250cm9scyA9IChwcm9wZXJ0eUJhcjogUHJvcGVydHlCYXIpOiBWTm9kZSB8IHVuZGVmaW5lZCA9PiB7XHJcbiAgICAgICAgaWYgKHByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFN0eWxlTW9sZWN1bGVJZCAhPSAwKSB7XHJcbiAgICAgICAgICAgIGxldCBzb3VyY2VTdHlsZU1vbGVjdWxlSWRTdHJpbmc6IHN0cmluZyA9IHByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFN0eWxlTW9sZWN1bGVJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBsZXQgc3R5bGVNb2xlY3VsZTogU3R5bGVNb2xlY3VsZSB8IHVuZGVmaW5lZCA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcy5maW5kKG0gPT4gbS5TdHlsZU1vbGVjdWxlSWQgPT0gcHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3R5bGVNb2xlY3VsZUlkKTsgLy8gVE9ETyBmaW5kIHVzZWQgcmVwZWF0ZWRseSBmb3IgcmVuZGVyIGNvbnRyb2xzXHJcbiAgICAgICAgICAgIGlmIChzdHlsZU1vbGVjdWxlID09PSB1bmRlZmluZWQpIHsgLy8gY2FuIGhhcHBlbiBpZiBzdHlsZSBtb2xlY3VsZSBnb3QgZGVsZXRlZCBpbiB0aGUgbWVhbiB0aW1lIGluIG90aGVyIHByb3BlcnR5IGJhcnNcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIFRPRE8gZG9jdW1lbnRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgaXNDbG9uZWRTdHlsZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBsZXQgY2xvbmVSZWZTdHlsZU1vbGVjdWxlSWRTdHJpbmc6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYgKHN0eWxlTW9sZWN1bGUuQ2xvbmVkRnJvbVN0eWxlSWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgaXNDbG9uZWRTdHlsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjbG9uZVJlZlN0eWxlTW9sZWN1bGVJZFN0cmluZyA9IHN0eWxlTW9sZWN1bGUuQ2xvbmVkRnJvbVN0eWxlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgc3R5bGVkTGF5b3V0QmFzZUlkU3RyaW5nOiBzdHJpbmcgPSBzdHlsZU1vbGVjdWxlLlN0eWxlRm9yTGF5b3V0SWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgbGV0IHByb3BlcnR5QmFyQ29udHJvbHNTdHlsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICBcImhlaWdodFwiOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgICAgICBcImZsZXgtZmxvd1wiOiBcImNvbHVtbiBub3dyYXBcIlxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLy8gVE9ETyBjbG9uZSByZWZlcmVuY2Ugc3R5bGUgc2VsZWN0b3Igc2hvdWxkIGFsd2F5cyBiZSB2aXNpYmxlIChkZXBlbmRzIG9uIGNsb25lT2ZTdHlsZUlkKVxyXG4gICAgICAgICAgICAvLyBUT0RPIHJlZiBzdHlsZS9jbG9uZSBzdHlsZVxyXG4gICAgICAgICAgICByZXR1cm4gPGRpdiBrZXk9e1Byb3BlcnR5QmFyTW9kZS5TdHlsZU1vbGVjdWxlfSBzdHlsZXM9e3Byb3BlcnR5QmFyQ29udHJvbHNTdHlsZXN9PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBrZXk9XCIwXCIgc3R5bGVzPXt7IFwiZmxleFwiOiBcIjAgMCBhdXRvXCIgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgU2VsZWN0ZWQgU3R5bGVNb2xlY3VsZSAje3Byb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFN0eWxlTW9sZWN1bGVJZH1cclxuICAgICAgICAgICAgICAgICAgICB7aXNDbG9uZWRTdHlsZSA/IDxkaXYga2V5PVwiMFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgbWlkPXtjbG9uZVJlZlN0eWxlTW9sZWN1bGVJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuc2VsZWN0U3R5bGVNb2xlY3VsZUNsaWNrSGFuZGxlcn0+cmVmIHN0eWxlICgje2Nsb25lUmVmU3R5bGVNb2xlY3VsZUlkU3RyaW5nfSk8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJiXCIgcm9sZT1cImJ1dHRvblwiIG1pZD17c291cmNlU3R5bGVNb2xlY3VsZUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5jcmVhdGVSZWZlcmVuY2VTdHlsZU1vbGVjdWxlQ2xpY2tIYW5kbGVyfT5tYWtlIHJlZjwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGRpc2FibGVkIGtleT1cImNcIiByb2xlPVwiYnV0dG9uXCIgbWlkPXtzb3VyY2VTdHlsZU1vbGVjdWxlSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLnN5bmNUb1JlZmVyZW5jZVN0eWxlQ2xpY2tIYW5kbGVyfT5zeW5jIHRvIHJlZjwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGRpc2FibGVkIGtleT1cImRcIiByb2xlPVwiYnV0dG9uXCIgbWlkPXtzb3VyY2VTdHlsZU1vbGVjdWxlSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLnN5bmNGcm9tUmVmZXJlbmNlU3R5bGVDbGlja0hhbmRsZXJ9PnN5bmMgZnJvbSByZWY8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gOiBwcm9wZXJ0eUJhci5yZW5kZXJTdHlsZU1vbGVjdWxlUmVmZXJlbmNlU2VsZWN0b3IoKX1cclxuICAgICAgICAgICAgICAgICAgICB7cHJvcGVydHlCYXIucmVuZGVyUmVzcG9uc2l2ZURldmljZVNlbGVjdG9ycygpfVxyXG4gICAgICAgICAgICAgICAgICAgIHtwcm9wZXJ0eUJhci5yZW5kZXJTdGF0ZU1vZGlmaWVyU2VsZWN0b3JzKCl9XHJcbiAgICAgICAgICAgICAgICAgICAge3Byb3BlcnR5QmFyLnJlbmRlclN0eWxlQXRvbUNvbnRyb2xzKCl9XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYga2V5PVwiMVwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIxIDEgMXB4XCIsIFwib3ZlcmZsb3dcIjogXCJzY3JvbGxcIiB9fT5cclxuICAgICAgICAgICAgICAgICAgICB7cHJvcGVydHlCYXIudmlld01vZGVsLnN0eWxlQXRvbVByb2plY3Rvci5yZXN1bHRzLm1hcChyID0+IHIucmVuZGVyTWFxdWV0dGUoKSl9XHJcbiAgICAgICAgICAgICAgICAgICAge3Byb3BlcnR5QmFyLnJlbmRlclN0eWxlTW9sZWN1bGVDaGlsZHJlbihwcm9wZXJ0eUJhcil9XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYga2V5PVwiMlwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIwIDAgYXV0b1wiIH19PlxyXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiBsaWQ9e3N0eWxlZExheW91dEJhc2VJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuc2VsZWN0TGF5b3V0QmFzZUNsaWNrSGFuZGxlcn0+bGF5b3V0ICN7c3R5bGVkTGF5b3V0QmFzZUlkU3RyaW5nfTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc3luY1RvUmVmZXJlbmNlU3R5bGVDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLlN5bmNTdHlsZU1vbGVjdWxlVG9SZWZlcmVuY2VTdHlsZUpzb24ocGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibWlkXCIpKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzeW5jRnJvbVJlZmVyZW5jZVN0eWxlQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5TeW5jU3R5bGVNb2xlY3VsZUZyb21SZWZlcmVuY2VTdHlsZUpzb24ocGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibWlkXCIpKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjcmVhdGVSZWZlcmVuY2VTdHlsZU1vbGVjdWxlQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5TZXRTdHlsZU1vbGVjdWxlQXNSZWZlcmVuY2VTdHlsZUpzb24ocGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibWlkXCIpKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJTdHlsZU1vbGVjdWxlUmVmZXJlbmNlU2VsZWN0b3IgPSAoKTogVk5vZGUgPT4ge1xyXG4gICAgICAgIC8vIFRPRE8gZW5hYmxlIHdoZW4gYmFja2VuZCBmdW5jdGlvbmFsaXR5IGlzIGltcGxlbWVudGVkXHJcbiAgICAgICAgcmV0dXJuIDxkaXYga2V5PVwiLTFcIj5cclxuICAgICAgICAgICAgPHNlbGVjdCBkaXNhYmxlZCBvbmNoYW5nZT17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc3R5bGVNb2xlY3VsZVJlZmVyZW5jZUNoYW5nZWRIYW5kbGVyfT5cclxuICAgICAgICAgICAgICAgIHtjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMubWFwKG1vbCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBleHBlbnNpdmVcclxuICAgICAgICAgICAgICAgICAgICBpZiAobW9sLkNsb25lZEZyb21TdHlsZUlkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIHN0eWxlcyB3aGljaCBhcmUgbm90IHJlZmVyZW5jZSBzdHlsZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0eWxlTW9sZWN1bGVJZFN0cmluZzogc3RyaW5nID0gbW9sLlN0eWxlTW9sZWN1bGVJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2wuU3R5bGVNb2xlY3VsZUlkID09IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFN0eWxlTW9sZWN1bGVJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPG9wdGlvbiBzZWxlY3RlZCBrZXk9e3N0eWxlTW9sZWN1bGVJZFN0cmluZ30gdmFsdWU9e3N0eWxlTW9sZWN1bGVJZFN0cmluZ30+e21vbC5OYW1lfSAje21vbC5TdHlsZU1vbGVjdWxlSWR9PC9vcHRpb24+O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxvcHRpb24ga2V5PXtzdHlsZU1vbGVjdWxlSWRTdHJpbmd9IHZhbHVlPXtzdHlsZU1vbGVjdWxlSWRTdHJpbmd9Pnttb2wuTmFtZX0gI3ttb2wuU3R5bGVNb2xlY3VsZUlkfTwvb3B0aW9uPjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KX1cclxuICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc3R5bGVNb2xlY3VsZVJlZmVyZW5jZUNoYW5nZWRIYW5kbGVyID0gKGV2dDogVUlFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCB0YXJnZXRTZWxlY3QgPSBldnQudGFyZ2V0IGFzIEhUTUxTZWxlY3RFbGVtZW50O1xyXG4gICAgICAgIGxldCBwYXJzZWRTdHlsZU1vbGVjdWxlSWQ6IG51bWJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAodGFyZ2V0U2VsZWN0LnNlbGVjdGVkSW5kZXggPCB0YXJnZXRTZWxlY3QuY2hpbGRFbGVtZW50Q291bnQpIHtcclxuICAgICAgICAgICAgbGV0IHNlbGVjdE9wdGlvbkVsZW1lbnQ6IEhUTUxPcHRpb25FbGVtZW50ID0gdGFyZ2V0U2VsZWN0Lm9wdGlvbnNbdGFyZ2V0U2VsZWN0LnNlbGVjdGVkSW5kZXhdO1xyXG4gICAgICAgICAgICBwYXJzZWRTdHlsZU1vbGVjdWxlSWQgPSBwYXJzZUludChzZWxlY3RPcHRpb25FbGVtZW50LnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhcnNlZFN0eWxlTW9sZWN1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5TZXRTdHlsZU1vbGVjdWxlUmVmZXJlbmNlSnNvbih0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZU1vbGVjdWxlSWQsIHBhcnNlZFN0eWxlTW9sZWN1bGVJZCkuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlbmRlclN0eWxlTW9sZWN1bGVDaGlsZHJlbiA9IChwcm9wZXJ0eUJhcjogUHJvcGVydHlCYXIpOiBWTm9kZSA9PiB7XHJcbiAgICAgICAgbGV0IGNoaWxkTW9sZWN1bGVzOiBTdHlsZU1vbGVjdWxlW10gPSBbXTtcclxuICAgICAgICBpZiAocHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3R5bGVNb2xlY3VsZUlkICE9IDApIHtcclxuICAgICAgICAgICAgY2hpbGRNb2xlY3VsZXMgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmlsdGVyKHMgPT4gcy5DbG9uZWRGcm9tU3R5bGVJZCA9PSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZU1vbGVjdWxlSWQpOyAvLyBUT0RPIGV4cGVuc2l2ZSAvLyBUT0RPIGV2ZXJ5d2hlcmUgd2hlcmUgc29tZXRoaW5nIGxpa2Ugcy5DbG9uZWRGcm9tU3R5bGVJZCBpcyB1c2VkOiByZXNldCB2aWV3IGJlZm9yZSBlbGVtZW50cyBhcmUgZGVsZXRlZC4uIHRoaXMgY2FuIHRocm93IHVuZGVmaW5lZFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gPGRpdiBrZXk9XCItNFwiPiBhZmZlY3RzIHN0eWxlczpcclxuICAgICAgICAgICAge2NoaWxkTW9sZWN1bGVzLm1hcChzID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBzdHlsZU1vbGVjdWxlSWRTdHJpbmc6IHN0cmluZyA9IHMuU3R5bGVNb2xlY3VsZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPGRpdiBrZXk9e3N0eWxlTW9sZWN1bGVJZFN0cmluZ30+XHJcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIG1pZD17c3R5bGVNb2xlY3VsZUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5zZWxlY3RTdHlsZU1vbGVjdWxlQ2xpY2tIYW5kbGVyfT4je3N0eWxlTW9sZWN1bGVJZFN0cmluZ308L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PjtcclxuICAgICAgICAgICAgfSl9XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyQm94VHJlZUZvckNhbGlmb3JuaWFWaWV3ID0gKHByb3BlcnR5QmFyOiBQcm9wZXJ0eUJhcik6IG1hcXVldHRlLk1hcHBpbmc8Q2FsaWZvcm5pYVZpZXcsIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+ID0+IHtcclxuICAgICAgICByZXR1cm4gbWFxdWV0dGUuY3JlYXRlTWFwcGluZzxDYWxpZm9ybmlhVmlldywgYW55PihcclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U2VjdGlvblNvdXJjZUtleShzb3VyY2U6IENhbGlmb3JuaWFWaWV3KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlLkNhbGlmb3JuaWFWaWV3SWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb25UYXJnZXQoc291cmNlOiBDYWxpZm9ybmlhVmlldykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZUNhbGlmb3JuaWFWaWV3SWRTdHJpbmcgPSBzb3VyY2UuQ2FsaWZvcm5pYVZpZXdJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxheW91dFJvd3MgPSBwcm9wZXJ0eUJhci5yZW5kZXJMYXlvdXRSb3dBcnJheShwcm9wZXJ0eUJhcik7XHJcbiAgICAgICAgICAgICAgICBsYXlvdXRSb3dzLm1hcChzb3VyY2UuUGxhY2VkTGF5b3V0Um93cyk7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHNob3cgYm9keStodG1sIHN0eWxlIG1vbGVjdWxlIGluIHBhZ2UgcHJldmlld1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJNYXF1ZXR0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHJlZVZpZXdTdHlsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsZXgtZGlyZWN0aW9uXCI6IFwicm93XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsZXgtd3JhcFwiOiBcIndyYXBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLXJpZ2h0XCI6IFwiLTE1cHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZm9udC1mYW1pbHlcIjogXCJzYW5zLXNlcmlmXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1wid2lkdGhcIjogXCI5MDBweFwiLCAvLyBUT0RPIHdvcmthcm91bmQgZWxlbWVudHMgYnJlYWtpbmcgbGluZS4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJib3JkZXItYm90dG9tXCI6IFwic29saWQsIDFweCwgYmxhY2tcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCJhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImhlaWdodFwiOiBcImF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFkZGluZy1ib3R0b21cIjogXCIxMjNweFwiIC8qVE9ETyBzaXplIG9mIG4qZWxlbWVudCBmb3IgYWRkL2NyZWF0ZSBsYXlvdXQgZWxlbWVudHMgYXQgZW5kLCBjdXJyZW50bHkgMTIwKzMqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZENhbGlmb3JuaWFWaWV3SWQgPT0gc291cmNlLkNhbGlmb3JuaWFWaWV3SWQpID8gPGRpdiBrZXk9e3NvdXJjZUNhbGlmb3JuaWFWaWV3SWRTdHJpbmd9IHN0eWxlcz17dHJlZVZpZXdTdHlsZXN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2xheW91dFJvd3MucmVzdWx0cy5tYXAociA9PiByLnJlbmRlck1hcXVldHRlKCkpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICh1cGRhdGVkU291cmNlOiBDYWxpZm9ybmlhVmlldykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSB1cGRhdGVkU291cmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRSb3dzLm1hcChzb3VyY2UuUGxhY2VkTGF5b3V0Um93cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUNhbGlmb3JuaWFWaWV3SWRTdHJpbmcgPSBzb3VyY2UuQ2FsaWZvcm5pYVZpZXdJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNlY3Rpb25UYXJnZXQodXBkYXRlZFNvdXJjZTogQ2FsaWZvcm5pYVZpZXcsIHRhcmdldDogeyByZW5kZXJNYXF1ZXR0ZSgpOiBhbnksIHVwZGF0ZSh1cGRhdGVkU291cmNlOiBDYWxpZm9ybmlhVmlldyk6IHZvaWQgfSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnVwZGF0ZSh1cGRhdGVkU291cmNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJMYXlvdXRSb3dBcnJheSA9IChwcm9wZXJ0eUJhcjogUHJvcGVydHlCYXIpOiBtYXF1ZXR0ZS5NYXBwaW5nPExheW91dFJvdywgeyByZW5kZXJNYXF1ZXR0ZTogKCkgPT4gbWFxdWV0dGUuVk5vZGUgfT4gPT4geyAvLyBUT0RPIGNvZGUgZHVwbGljYXRpb24gd2l0aCBwYWdlIHByZXZpZXdcclxuICAgICAgICByZXR1cm4gbWFxdWV0dGUuY3JlYXRlTWFwcGluZzxMYXlvdXRSb3csIGFueT4oXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFNlY3Rpb25Tb3VyY2VLZXkoc291cmNlOiBMYXlvdXRSb3cpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2UuTGF5b3V0QmFzZUlkO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVTZWN0aW9uVGFyZ2V0KHNvdXJjZTogTGF5b3V0Um93KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc291cmNlTGF5b3V0Um93SWRTdHJpbmcgPSBzb3VyY2UuTGF5b3V0QmFzZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVuZGVyZWRMYXlvdXRCb3hlcyA9IHByb3BlcnR5QmFyLnJlbmRlckxheW91dEJveEFycmF5KHByb3BlcnR5QmFyKTtcclxuICAgICAgICAgICAgICAgIGxldCB1bnNvcnRlZEJveGVzOiBMYXlvdXRCb3hbXSA9IHNvdXJjZS5BbGxCb3hlc0JlbG93Um93LmZpbHRlcihiID0+IGIuUGxhY2VkQm94SW5Cb3hJZCA9PT0gdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIGxldCBzb3J0ZWRCb3hlczogTGF5b3V0Qm94W10gPSB1bnNvcnRlZEJveGVzLnNvcnQoKGJveEE6IExheW91dEJveCwgYm94QjogTGF5b3V0Qm94KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJveEEuTGF5b3V0U29ydE9yZGVyS2V5IDwgYm94Qi5MYXlvdXRTb3J0T3JkZXJLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChib3hBLkxheW91dFNvcnRPcmRlcktleSA9PSBib3hCLkxheW91dFNvcnRPcmRlcktleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIGJveEEuTGF5b3V0U29ydE9yZGVyS2V5ID4gYm94Qi5MYXlvdXRTb3J0T3JkZXJLZXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlZExheW91dEJveGVzLm1hcChzb3J0ZWRCb3hlcyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVNb2xlY3VsZUlkOiBudW1iZXIgPSAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlTW9sZWN1bGVzLmZpbmQobSA9PiBtLlN0eWxlRm9yTGF5b3V0SWQgPT0gc291cmNlLkxheW91dEJhc2VJZCkgYXMgU3R5bGVNb2xlY3VsZSkuU3R5bGVNb2xlY3VsZUlkOyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlTW9sZWN1bGVJZFN0cmluZzogc3RyaW5nID0gc3R5bGVNb2xlY3VsZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGF5b3V0Um93U3R5bGVDbGFzczogc3RyaW5nID0gYHMke3N0eWxlTW9sZWN1bGVJZFN0cmluZ31gO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJNYXF1ZXR0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHJlZVJvd1N0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxleC1iYXNpc1wiOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1heC13aWR0aFwiOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFkZGluZy1sZWZ0XCI6IFwiMTVweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nLXJpZ2h0XCI6IFwiMTVweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwicmdiKDIyMiwgMjIyLCAyMjIpXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNhcHRpb25TdHlsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsZXgtYmFzaXNcIjogXCJhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiBcInJnYig3OCwgNzgsIDc4KVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nLWxlZnRcIjogXCIxNXB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhZGRpbmctcmlnaHRcIjogXCIxNXB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpblwiOiBcIjBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcInJnYigyMjIsIDIyMiwgMjIyKVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0LWRlY29yYXRpb25cIjogXCJ1bmRlcmxpbmVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGl2QnV0dG9uU3R5bGVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiZmxleFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmbGV4LWRpcmVjdGlvblwiOiBcInJvd1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmbGV4LXdyYXBcIjogXCJub3dyYXBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXCJtYXJnaW4tbGVmdFwiOiBcIi0xNXB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1yaWdodFwiOiBcIi0xNXB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJ1dHRvblN0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZm9udC1zaXplXCI6IFwiMTBweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiBcInJnYig3OCwgNzgsIDc4KVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwicmdiKDIyMiwgMjIyLCAyMjIpXCIsIC8vIFRPRE8gbWFnaWMgc3RyaW5nc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcImF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm91dGxpbmVcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvdXRsaW5lLW9mZnNldFwiOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzUHJlc2VsZWN0ZWRBbnk6IGJvb2xlYW4gPSBjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkICE9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpc1ByZXNlbGVjdGVkQ3VycmVudDogYm9vbGVhbiA9IGlzUHJlc2VsZWN0ZWRBbnkgJiYgY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCA9PSBzb3VyY2UuTGF5b3V0QmFzZUlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYnV0dG9uU3R5bGVzVGFyZ2V0ID0geyAvLyBUT0RPIGFwcGVuZCBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmb250LXNpemVcIjogXCIxMHB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCI6ICFpc1ByZXNlbGVjdGVkQW55IHx8IGlzUHJlc2VsZWN0ZWRDdXJyZW50ID8gXCJyZ2IoMjIyLCAyMjIsIDIyMilcIiA6IFwicmdiKDc4LCA3OCwgNzgpXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogXCJyZ2IoMjIyLCAyMjIsIDIyMilcIiwgLy8gVE9ETyBtYWdpYyBzdHJpbmdzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3V0bGluZVwiOiAhaXNQcmVzZWxlY3RlZEFueSB8fCBpc1ByZXNlbGVjdGVkQ3VycmVudCA/IHVuZGVmaW5lZCA6IFwic29saWQgNHB4IHJnYigyMDAsMCwwKVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvdXRsaW5lLW9mZnNldFwiOiAhaXNQcmVzZWxlY3RlZEFueSB8fCBpc1ByZXNlbGVjdGVkQ3VycmVudCA/IHVuZGVmaW5lZCA6IFwiLTRweFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBidXR0b25TdHlsZXNQcmVzZWxlY3RSb3cgPSB7IC8vIFRPRE8gYXBwZW5kIGFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZvbnQtc2l6ZVwiOiBcIjEwcHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIjogaXNQcmVzZWxlY3RlZEN1cnJlbnQgPyBcInJnYigyMjIsMjIyLDIyMilcIiA6IGlzUHJlc2VsZWN0ZWRBbnkgPyBcInJnYigyMjIsIDIyMiwgMjIyKVwiIDogXCJyZ2IoNzgsIDc4LCA3OClcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBpc1ByZXNlbGVjdGVkQ3VycmVudCA/IFwicmdiKDIwMCwwLDApXCIgOiBcInJnYigyMjIsIDIyMiwgMjIyKVwiLCAvLyBUT0RPIG1hZ2ljIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCJhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsZXhcIjogXCIwIDAgYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvdXRsaW5lXCI6IGlzUHJlc2VsZWN0ZWRDdXJyZW50IHx8IGlzUHJlc2VsZWN0ZWRBbnkgPyB1bmRlZmluZWQgOiBcInNvbGlkIDFweCByZ2IoMjAwLDAsMClcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3V0bGluZS1vZmZzZXRcIjogaXNQcmVzZWxlY3RlZEN1cnJlbnQgfHwgaXNQcmVzZWxlY3RlZEFueSA/IHVuZGVmaW5lZCA6IFwiLTFweFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaXZTdWJCb3hTdHlsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsZXgtYmFzaXNcIjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXgtd2lkdGhcIjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhZGRpbmctbGVmdFwiOiBcIjE1cHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFkZGluZy1yaWdodFwiOiBcIjE1cHhcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPGRpdiBrZXk9e3NvdXJjZUxheW91dFJvd0lkU3RyaW5nfSBzdHlsZXM9e3RyZWVSb3dTdHlsZXN9IGxpZD17c291cmNlTGF5b3V0Um93SWRTdHJpbmd9IG9ubW91c2VlbnRlcj17cHJvcGVydHlCYXIubGF5b3V0QmFzZU1vdXNlRW50ZXJIYW5kbGVyfSBvbm1vdXNlbGVhdmU9e3Byb3BlcnR5QmFyLmxheW91dEJhc2VNb3VzZUxlYXZlSGFuZGxlcn0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT1cIi0yXCIgc3R5bGVzPXtkaXZCdXR0b25TdHlsZXN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGtleT1cIi0xXCIgc3R5bGVzPXtjYXB0aW9uU3R5bGVzfT5ST1c8L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgc3R5bGVzPXtidXR0b25TdHlsZXN9IGxpZD17c291cmNlTGF5b3V0Um93SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmluc2VydExheW91dEJveEludG9Cb3hDbGlja0hhbmRsZXJ9PisoQik8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImJcIiBzdHlsZXM9e2J1dHRvblN0eWxlc30gbGlkPXtzb3VyY2VMYXlvdXRSb3dJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuc2VsZWN0TGF5b3V0QmFzZUNsaWNrSGFuZGxlcn0+JiM4MjMwO3svKmVsbGlwc2lzIFRPRE8gY2hlY2sgaXMgdGhpcyBjb21tZW50IHJlbW92ZWQqL308L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImNcIiBzdHlsZXM9e2J1dHRvblN0eWxlc30gbGlkPXtzb3VyY2VMYXlvdXRSb3dJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuaGlnaGxpZ2h0TGF5b3V0QmFzZUNsaWNrSGFuZGxlcn0+PzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiZFwiIHN0eWxlcz17YnV0dG9uU3R5bGVzfSBtaWQ9e3N0eWxlTW9sZWN1bGVJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuc2VsZWN0U3R5bGVNb2xlY3VsZUNsaWNrSGFuZGxlcn0+UyYjODIzMDs8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImVcIiBzdHlsZXM9e2J1dHRvblN0eWxlc30gbGlkPXtzb3VyY2VMYXlvdXRSb3dJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuc2F2ZUxheW91dE1vbGVjdWxlQ2xpY2tIYW5kbGVyfT4hISE8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aXNQcmVzZWxlY3RlZEN1cnJlbnQgfHwgIWlzUHJlc2VsZWN0ZWRBbnkgPyA8YnV0dG9uIGtleT1cImZcIiBzdHlsZXM9e2J1dHRvblN0eWxlc1ByZXNlbGVjdFJvd30gbGlkPXtzb3VyY2VMYXlvdXRSb3dJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIubW92ZUxheW91dFJvd0JlZm9yZVJvd0NsaWNrSGFuZGxlcn0+TVYoUik8L2J1dHRvbj4gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGRpc2FibGVkIGtleT1cImYwXCIgc3R5bGVzPXtidXR0b25TdHlsZXNQcmVzZWxlY3RSb3d9IGxpZD17c291cmNlTGF5b3V0Um93SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLm1vdmVMYXlvdXRSb3dCZWZvcmVSb3dDbGlja0hhbmRsZXJ9Pk1WKFIpPC9idXR0b24+fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpc1ByZXNlbGVjdGVkQ3VycmVudCB8fCAhaXNQcmVzZWxlY3RlZEFueSA/IDxidXR0b24ga2V5PVwiZ1wiIHN0eWxlcz17YnV0dG9uU3R5bGVzUHJlc2VsZWN0Um93fSBsaWQ9e3NvdXJjZUxheW91dFJvd0lkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5zeW5jTGF5b3V0QmFzZVN0eWxlc0NsaWNrSGFuZGxlcn0+U1QoUik8L2J1dHRvbj4gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGRpc2FibGVkIGtleT1cImcwXCIgc3R5bGVzPXtidXR0b25TdHlsZXNQcmVzZWxlY3RSb3d9IGxpZD17c291cmNlTGF5b3V0Um93SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLnN5bmNMYXlvdXRCYXNlU3R5bGVzQ2xpY2tIYW5kbGVyfT5TVChSKTwvYnV0dG9uPn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aXNQcmVzZWxlY3RlZEFueSAmJiAhaXNQcmVzZWxlY3RlZEN1cnJlbnQgPyA8YnV0dG9uIGtleT1cImhcIiBzdHlsZXM9e2J1dHRvblN0eWxlc1RhcmdldH0gbGlkPXtzb3VyY2VMYXlvdXRSb3dJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuZmluYWxpemVMYXlvdXRSZXF1ZXN0fT4kKEI6Uik8L2J1dHRvbj4gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGRpc2FibGVkIGtleT1cImgwXCIgc3R5bGVzPXtidXR0b25TdHlsZXNUYXJnZXR9IGxpZD17c291cmNlTGF5b3V0Um93SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmZpbmFsaXplTGF5b3V0UmVxdWVzdH0+JChCOlIpPC9idXR0b24+fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHshaXNQcmVzZWxlY3RlZEFueSA/IDxidXR0b24ga2V5PVwiaVwiIHN0eWxlcz17YnV0dG9uU3R5bGVzfSBsaWQ9e3NvdXJjZUxheW91dFJvd0lkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5kZWxldGVMYXlvdXRCYXNlQ2xpY2tIYW5kbGVyfT5YPC9idXR0b24+IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJpMFwiIHN0eWxlcz17YnV0dG9uU3R5bGVzfSBsaWQ9e3NvdXJjZUxheW91dFJvd0lkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5kZWxldGVMYXlvdXRCYXNlQ2xpY2tIYW5kbGVyfT5YPC9idXR0b24+fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHshaXNQcmVzZWxlY3RlZEFueSAmJiBzb3J0ZWRCb3hlcy5sZW5ndGggPiAwID8gPGJ1dHRvbiBrZXk9XCJqXCIgc3R5bGVzPXtidXR0b25TdHlsZXN9IGxpZD17c291cmNlTGF5b3V0Um93SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmRlbGV0ZUJlbG93TGF5b3V0QmFzZUNsaWNrSGFuZGxlcn0+Q0xSPC9idXR0b24+IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJqMFwiIHN0eWxlcz17YnV0dG9uU3R5bGVzfSBsaWQ9e3NvdXJjZUxheW91dFJvd0lkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5kZWxldGVCZWxvd0xheW91dEJhc2VDbGlja0hhbmRsZXJ9PkNMUjwvYnV0dG9uPn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9XCIwXCIgc3R5bGVzPXtkaXZTdWJCb3hTdHlsZXN9PntyZW5kZXJlZExheW91dEJveGVzLnJlc3VsdHMubWFwKHIgPT4gci5yZW5kZXJNYXF1ZXR0ZSgpKX08L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+O1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAodXBkYXRlZFNvdXJjZTogTGF5b3V0Um93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHVwZGF0ZWRTb3VyY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUxheW91dFJvd0lkU3RyaW5nID0gc291cmNlLkxheW91dEJhc2VJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnNvcnRlZEJveGVzID0gc291cmNlLkFsbEJveGVzQmVsb3dSb3cuZmlsdGVyKGIgPT4gYi5QbGFjZWRCb3hJbkJveElkID09PSB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0ZWRCb3hlcyA9IHVuc29ydGVkQm94ZXMuc29ydCgoYm94QTogTGF5b3V0Qm94LCBib3hCOiBMYXlvdXRCb3gpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib3hBLkxheW91dFNvcnRPcmRlcktleSA8IGJveEIuTGF5b3V0U29ydE9yZGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYm94QS5MYXlvdXRTb3J0T3JkZXJLZXkgPT0gYm94Qi5MYXlvdXRTb3J0T3JkZXJLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBib3hBLkxheW91dFNvcnRPcmRlcktleSA+IGJveEIuTGF5b3V0U29ydE9yZGVyS2V5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZExheW91dEJveGVzLm1hcChzb3J0ZWRCb3hlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlTW9sZWN1bGVJZCA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChtID0+IG0uU3R5bGVGb3JMYXlvdXRJZCA9PSBzb3VyY2UuTGF5b3V0QmFzZUlkKSBhcyBTdHlsZU1vbGVjdWxlKS5TdHlsZU1vbGVjdWxlSWQ7IC8vIFRPRE8gZXhwZW5zaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlTW9sZWN1bGVJZFN0cmluZyA9IHN0eWxlTW9sZWN1bGVJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRSb3dTdHlsZUNsYXNzID0gYHMke3N0eWxlTW9sZWN1bGVJZH1gO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNlY3Rpb25UYXJnZXQodXBkYXRlZFNvdXJjZTogTGF5b3V0Um93LCB0YXJnZXQ6IHsgcmVuZGVyTWFxdWV0dGUoKTogYW55LCB1cGRhdGUodXBkYXRlZFNvdXJjZTogTGF5b3V0Um93KTogdm9pZCB9KSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQudXBkYXRlKHVwZGF0ZWRTb3VyY2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSByZW5kZXJMYXlvdXRCb3hBcnJheSA9IChwcm9wZXJ0eUJhcjogUHJvcGVydHlCYXIpOiBtYXF1ZXR0ZS5NYXBwaW5nPExheW91dEJveCwgeyByZW5kZXJNYXF1ZXR0ZTogKCkgPT4gbWFxdWV0dGUuVk5vZGUgfT4gPT4ge1xyXG4gICAgICAgIHJldHVybiBtYXF1ZXR0ZS5jcmVhdGVNYXBwaW5nPExheW91dEJveCwgYW55PihcclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U2VjdGlvblNvdXJjZUtleShzb3VyY2U6IExheW91dEJveCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5MYXlvdXRCYXNlSWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb25UYXJnZXQoc291cmNlOiBMYXlvdXRCb3gpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzb3VyY2VMYXlvdXRCb3hJZFN0cmluZyA9IHNvdXJjZS5MYXlvdXRCYXNlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGxldCByZW5kZXJlZExheW91dEF0b21zID0gcHJvcGVydHlCYXIucmVuZGVyTGF5b3V0QXRvbUFycmF5KHByb3BlcnR5QmFyKTtcclxuICAgICAgICAgICAgICAgIGxldCByZW5kZXJlZExheW91dEJveGVzID0gcHJvcGVydHlCYXIucmVuZGVyTGF5b3V0Qm94QXJyYXkocHJvcGVydHlCYXIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlTW9sZWN1bGVJZDogbnVtYmVyID0gKGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcy5maW5kKG0gPT4gbS5TdHlsZUZvckxheW91dElkID09IHNvdXJjZS5MYXlvdXRCYXNlSWQpIGFzIFN0eWxlTW9sZWN1bGUpLlN0eWxlTW9sZWN1bGVJZDsgLy8gVE9ETyBleHBlbnNpdmVcclxuICAgICAgICAgICAgICAgIGxldCBzdHlsZU1vbGVjdWxlSWRTdHJpbmc6IHN0cmluZyA9IHN0eWxlTW9sZWN1bGVJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxheW91dEJveFN0eWxlQ2xhc3M6IHN0cmluZyA9IGBzJHtzdHlsZU1vbGVjdWxlSWR9YDtcclxuICAgICAgICAgICAgICAgIC8vIC0tLSBvbmx5IHJlbmRlciBtb2RlOiB0cmVlIC0tLVxyXG4gICAgICAgICAgICAgICAgbGV0IGRlZXBuZXNzUGFkZGluZzogc3RyaW5nID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIGxldCBjYWxjdWxhdGVkQmFja2dyb3VuZENvbG9yOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNhbGN1bGF0ZWRDb2xvcjogc3RyaW5nID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIGxldCBjYWxjdWxhdGVkQm9yZGVyQ29sb3I6IHN0cmluZyA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICBsZXQgaGFzU3ViQXRvbXM6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGxldCBpc09kZExldmVsOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAvLyAtLS1cclxuICAgICAgICAgICAgICAgIGRlZXBuZXNzUGFkZGluZyA9IGAkeyhzb3VyY2UuTGV2ZWwgKyAxKSAqIDE1fXB4YDtcclxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRCYWNrZ3JvdW5kQ29sb3IgPSBwcm9wZXJ0eUJhci5jYWxjdWxhdGVCYWNrZ3JvdW5kQ29sb3JGb3JMZXZlbChzb3VyY2UuTGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZENvbG9yID0gcHJvcGVydHlCYXIuY2FsY3VsYXRlQ29sb3JGb3JMZXZlbChzb3VyY2UuTGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZEJvcmRlckNvbG9yID0gYHNvbGlkIDFweCAke3Byb3BlcnR5QmFyLmNhbGN1bGF0ZUJhY2tncm91bmRDb2xvckZvckxldmVsKHNvdXJjZS5MZXZlbCArIDEpfWA7XHJcbiAgICAgICAgICAgICAgICBoYXNTdWJBdG9tcyA9IHNvdXJjZS5QbGFjZWRJbkJveEF0b21zLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgICAgICBpc09kZExldmVsID0gKHNvdXJjZS5MZXZlbCAlIDIpICE9IDA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlck1hcXVldHRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZW5kZXJlZEJveENvbnRlbnQ6IFZOb2RlW10gPSBjdXJyZW50QXBwLnBhZ2VQcmV2aWV3Lm1hcEFuZFJlbmRlckxheW91dEJveENvbnRlbnQoc291cmNlLCBzb3VyY2UuUGxhY2VkSW5Cb3hBdG9tcywgcmVuZGVyZWRMYXlvdXRBdG9tcywgc291cmNlLlBsYWNlZEluQm94Qm94ZXMsIHJlbmRlcmVkTGF5b3V0Qm94ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHJlZUJveFN0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcImZsZXhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxleC1kaXJlY3Rpb25cIjogXCJyb3dcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxleC13cmFwXCI6IFwid3JhcFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cIm1hcmdpbi1sZWZ0XCI6IFwiLTE1cHhcIiwgVE9ETyBzdGFpciBlZmZlY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLXJpZ2h0XCI6IFwiLTE1cHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcInJnYigyMjIsIDIyMiwgMjIyKVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJib3JkZXItYm90dG9tXCI6IGhhc1N1YkF0b21zID8gY2FsY3VsYXRlZEJvcmRlckNvbG9yIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJib3JkZXItbGVmdFwiOiBcInNvbGlkIDFweCBibGFja1wiLC8vIGhhc1N1YkF0b21zID8gY2FsY3VsYXRlZEJvcmRlckNvbG9yIDogdW5kZWZpbmVkIC8vIFRPRE8gb25seSBuZXh0IHRvIGF0b21zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInpvb21cIjogXCIxLjA1XCIgLy8gVE9ETyBjYWxlaWRvc2NvcGUgLyB6b29tIGZhY3RvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYm94Q2FwdGlvblN0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFkZGluZy1sZWZ0XCI6IFwiMTVweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nLXJpZ2h0XCI6IFwiMTVweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcImF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpblwiOiBcIjBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dC1kZWNvcmF0aW9uXCI6IFwidW5kZXJsaW5lXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCI6IGNhbGN1bGF0ZWRDb2xvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBjYWxjdWxhdGVkQmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmb250LXN0cmV0Y2hcIjogaXNPZGRMZXZlbCA/IFwiZXh0cmEtY29uZGVuc2VkXCIgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpdkJ1dHRvblN0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcImZsZXhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxleC1kaXJlY3Rpb25cIjogXCJyb3dcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxleC13cmFwXCI6IFwibm93cmFwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1sZWZ0XCI6IFwiLTE1cHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLXJpZ2h0XCI6IFwiLTE1cHhcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYnV0dG9uU3R5bGVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmb250LXNpemVcIjogXCIxMHB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCI6IGNhbGN1bGF0ZWRDb2xvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBjYWxjdWxhdGVkQmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcImF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm91dGxpbmVcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvdXRsaW5lLW9mZnNldFwiOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJ1dHRvbkRpc2FibGVkU3R5bGVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmb250LXNpemVcIjogXCIxMHB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogXCJyZ2IoMjQyLDI0MiwyNDIpXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCI6IGNhbGN1bGF0ZWRDb2xvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCJhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsZXhcIjogXCIwIDAgYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvdXRsaW5lXCI6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3V0bGluZS1vZmZzZXRcIjogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpc1ByZXNlbGVjdGVkQW55OiBib29sZWFuID0gY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCAhPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXNQcmVzZWxlY3RlZEN1cnJlbnQ6IGJvb2xlYW4gPSBpc1ByZXNlbGVjdGVkQW55ICYmIGN1cnJlbnRBcHAuc3RhdGUucHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQgPT0gc291cmNlLkxheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJ1dHRvblN0eWxlc1RhcmdldCA9IHsgLy8gVE9ETyBhcHBlbmQgYXJyYXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZm9udC1zaXplXCI6IFwiMTBweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiAhaXNQcmVzZWxlY3RlZEFueSB8fCBpc1ByZXNlbGVjdGVkQ3VycmVudCA/IGNhbGN1bGF0ZWRCYWNrZ3JvdW5kQ29sb3IgOiBjYWxjdWxhdGVkQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogY2FsY3VsYXRlZEJhY2tncm91bmRDb2xvciwgLy8gVE9ETyBtYWdpYyBzdHJpbmdzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3V0bGluZVwiOiAhaXNQcmVzZWxlY3RlZEFueSB8fCBpc1ByZXNlbGVjdGVkQ3VycmVudCA/IHVuZGVmaW5lZCA6IFwic29saWQgNHB4IHJnYigyMDAsMCwwKVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvdXRsaW5lLW9mZnNldFwiOiAhaXNQcmVzZWxlY3RlZEFueSB8fCBpc1ByZXNlbGVjdGVkQ3VycmVudCA/IHVuZGVmaW5lZCA6IFwiLTRweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYnV0dG9uU3R5bGVzUHJlc2VsZWN0QW55ID0geyAvLyBUT0RPIGFwcGVuZCBhcnJheSAvLyBUT0RPIGRpZmZlcmVudGlhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZm9udC1zaXplXCI6IFwiMTBweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiBpc1ByZXNlbGVjdGVkQ3VycmVudCA/IGNhbGN1bGF0ZWRCYWNrZ3JvdW5kQ29sb3IgOiBpc1ByZXNlbGVjdGVkQW55ID8gY2FsY3VsYXRlZEJhY2tncm91bmRDb2xvciA6IGNhbGN1bGF0ZWRDb2xvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBpc1ByZXNlbGVjdGVkQ3VycmVudCA/IFwicmdiKDIwMCwwLDApXCIgOiBjYWxjdWxhdGVkQmFja2dyb3VuZENvbG9yLCAvLyBUT0RPIG1hZ2ljIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCJhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsZXhcIjogXCIwIDAgYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvdXRsaW5lXCI6IGlzUHJlc2VsZWN0ZWRDdXJyZW50IHx8IGlzUHJlc2VsZWN0ZWRBbnkgPyB1bmRlZmluZWQgOiBcInNvbGlkIDFweCByZ2IoMjAwLDAsMClcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3V0bGluZS1vZmZzZXRcIjogaXNQcmVzZWxlY3RlZEN1cnJlbnQgfHwgaXNQcmVzZWxlY3RlZEFueSA/IHVuZGVmaW5lZCA6IFwiLTFweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGl2U3ViVHJlZVN0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxleC1iYXNpc1wiOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1heC13aWR0aFwiOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFkZGluZy1sZWZ0XCI6IFwiMTVweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nLXJpZ2h0XCI6IFwiMTVweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IGNhbGN1bGF0ZWRCYWNrZ3JvdW5kQ29sb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBkb2N1bWVudDogd2hvbGUgY2xpZW50IGFwcCByZWxpZXMgb24gZGF0YWJhc2Uga2V5cyBiZWluZyBzdHJpY3RseSBwb3NpdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGNvbmNlcHQrZG8gZXZlcnl3aGVyZTogaW4gdGhpcyBjYXNlIG1hbnkgaHRtbCB0YWdzIGFyZSBzZXQgd2hlbiAxIHdvdWxkIGJlIGVub3VnaCBvbiBwYXJlbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYga2V5PXtzb3VyY2VMYXlvdXRCb3hJZFN0cmluZ30gc3R5bGVzPXt0cmVlQm94U3R5bGVzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYga2V5PVwiMFwiIHN0eWxlcz17ZGl2U3ViVHJlZVN0eWxlc30gbGlkPXtzb3VyY2VMYXlvdXRCb3hJZFN0cmluZ30gb25tb3VzZWVudGVyPXtwcm9wZXJ0eUJhci5sYXlvdXRCYXNlTW91c2VFbnRlckhhbmRsZXJ9IG9ubW91c2VsZWF2ZT17cHJvcGVydHlCYXIubGF5b3V0QmFzZU1vdXNlTGVhdmVIYW5kbGVyfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT1cIi0yXCIgc3R5bGVzPXtkaXZCdXR0b25TdHlsZXN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7PHAga2V5PVwiLTFcIiBzdHlsZXM9e2JveENhcHRpb25TdHlsZXN9PkJPWHshaXNPZGRMZXZlbCA/IFwiIHxcIiA6IHVuZGVmaW5lZH08L3A+fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiBzdHlsZXM9e2J1dHRvblN0eWxlc30gbGlkPXtzb3VyY2VMYXlvdXRCb3hJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuaW5zZXJ0TGF5b3V0QXRvbUludG9Cb3hDbGlja0hhbmRsZXJ9PisoQSk8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJiXCIgc3R5bGVzPXtidXR0b25TdHlsZXN9IGxpZD17c291cmNlTGF5b3V0Qm94SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmluc2VydExheW91dEJveEludG9Cb3hDbGlja0hhbmRsZXJ9PisoQik8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJjXCIgc3R5bGVzPXtidXR0b25TdHlsZXN9IGxpZD17c291cmNlTGF5b3V0Qm94SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLnNlbGVjdExheW91dEJhc2VDbGlja0hhbmRsZXJ9PiYjODIzMDt7LypFbGxpcHNpcyovfTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImRcIiBzdHlsZXM9e2J1dHRvblN0eWxlc30gbGlkPXtzb3VyY2VMYXlvdXRCb3hJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuaGlnaGxpZ2h0TGF5b3V0QmFzZUNsaWNrSGFuZGxlcn0+PzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImVcIiBzdHlsZXM9e2J1dHRvblN0eWxlc30gbWlkPXtzdHlsZU1vbGVjdWxlSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLnNlbGVjdFN0eWxlTW9sZWN1bGVDbGlja0hhbmRsZXJ9PlMmIzgyMzA7ey8qRWxsaXBzaXMqL308L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJmXCIgc3R5bGVzPXtidXR0b25TdHlsZXN9IGxpZD17c291cmNlTGF5b3V0Qm94SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLnNhdmVMYXlvdXRNb2xlY3VsZUNsaWNrSGFuZGxlcn0+ISEhPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpc1ByZXNlbGVjdGVkQ3VycmVudCB8fCAhaXNQcmVzZWxlY3RlZEFueSA/IDxidXR0b24ga2V5PVwiZ1wiIHN0eWxlcz17YnV0dG9uU3R5bGVzUHJlc2VsZWN0QW55fSBsaWQ9e3NvdXJjZUxheW91dEJveElkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5tb3ZlTGF5b3V0Qm94SW50b1Jvd0NsaWNrSGFuZGxlcn0+SU4oUik8L2J1dHRvbj4gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJnMFwiIHN0eWxlcz17YnV0dG9uU3R5bGVzUHJlc2VsZWN0QW55fSBsaWQ9e3NvdXJjZUxheW91dEJveElkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5tb3ZlTGF5b3V0Qm94SW50b1Jvd0NsaWNrSGFuZGxlcn0+SU4oUik8L2J1dHRvbj59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpc1ByZXNlbGVjdGVkQ3VycmVudCB8fCAhaXNQcmVzZWxlY3RlZEFueSA/IDxidXR0b24ga2V5PVwiaFwiIHN0eWxlcz17YnV0dG9uU3R5bGVzUHJlc2VsZWN0QW55fSBsaWQ9e3NvdXJjZUxheW91dEJveElkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5tb3ZlTGF5b3V0Qm94SW50b0JveENsaWNrSGFuZGxlcn0+SU4oQik8L2J1dHRvbj4gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJoMFwiIHN0eWxlcz17YnV0dG9uU3R5bGVzUHJlc2VsZWN0QW55fSBsaWQ9e3NvdXJjZUxheW91dEJveElkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5tb3ZlTGF5b3V0Qm94SW50b0JveENsaWNrSGFuZGxlcn0+SU4oQik8L2J1dHRvbj59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpc1ByZXNlbGVjdGVkQ3VycmVudCB8fCAhaXNQcmVzZWxlY3RlZEFueSA/IDxidXR0b24ga2V5PVwiaVwiIHN0eWxlcz17YnV0dG9uU3R5bGVzUHJlc2VsZWN0QW55fSBsaWQ9e3NvdXJjZUxheW91dEJveElkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5tb3ZlTGF5b3V0Qm94QmVmb3JlQm94Q2xpY2tIYW5kbGVyfT5NVihBOkIpPC9idXR0b24+IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gZGlzYWJsZWQga2V5PVwiaTBcIiBzdHlsZXM9e2J1dHRvblN0eWxlc1ByZXNlbGVjdEFueX0gbGlkPXtzb3VyY2VMYXlvdXRCb3hJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIubW92ZUxheW91dEJveEJlZm9yZUJveENsaWNrSGFuZGxlcn0+TVYoQTpCKTwvYnV0dG9uPn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2lzUHJlc2VsZWN0ZWRDdXJyZW50IHx8ICFpc1ByZXNlbGVjdGVkQW55ID8gPGJ1dHRvbiBrZXk9XCJqXCIgc3R5bGVzPXtidXR0b25TdHlsZXNQcmVzZWxlY3RBbnl9IGxpZD17c291cmNlTGF5b3V0Qm94SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLnN5bmNMYXlvdXRCYXNlU3R5bGVzQ2xpY2tIYW5kbGVyfT5TVChCKTwvYnV0dG9uPiA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGRpc2FibGVkIGtleT1cImowXCIgc3R5bGVzPXtidXR0b25TdHlsZXNQcmVzZWxlY3RBbnl9IGxpZD17c291cmNlTGF5b3V0Qm94SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLnN5bmNMYXlvdXRCYXNlU3R5bGVzQ2xpY2tIYW5kbGVyfT5TVChCKTwvYnV0dG9uPn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2lzUHJlc2VsZWN0ZWRBbnkgJiYgIWlzUHJlc2VsZWN0ZWRDdXJyZW50ID8gPGJ1dHRvbiBrZXk9XCJrXCIgc3R5bGVzPXtidXR0b25TdHlsZXNUYXJnZXR9IGxpZD17c291cmNlTGF5b3V0Qm94SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmZpbmFsaXplTGF5b3V0UmVxdWVzdH0+JChBOkIpPC9idXR0b24+IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gZGlzYWJsZWQga2V5PVwiazBcIiBzdHlsZXM9e2J1dHRvblN0eWxlc1RhcmdldH0gbGlkPXtzb3VyY2VMYXlvdXRCb3hJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuZmluYWxpemVMYXlvdXRSZXF1ZXN0fT4kKEE6Qik8L2J1dHRvbj59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHshaXNQcmVzZWxlY3RlZEFueSA/IDxidXR0b24ga2V5PVwibFwiIHN0eWxlcz17YnV0dG9uU3R5bGVzfSBsaWQ9e3NvdXJjZUxheW91dEJveElkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5kZWxldGVMYXlvdXRCYXNlQ2xpY2tIYW5kbGVyfT5YPC9idXR0b24+IDogXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGRpc2FibGVkIGtleT1cImwwXCIgc3R5bGVzPXtidXR0b25TdHlsZXN9IGxpZD17c291cmNlTGF5b3V0Qm94SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmRlbGV0ZUxheW91dEJhc2VDbGlja0hhbmRsZXJ9Plg8L2J1dHRvbj59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHshaXNQcmVzZWxlY3RlZEFueSAmJiByZW5kZXJlZEJveENvbnRlbnQubGVuZ3RoID4gMCA/IDxidXR0b24ga2V5PVwibVwiIHN0eWxlcz17YnV0dG9uU3R5bGVzfSBsaWQ9e3NvdXJjZUxheW91dEJveElkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5kZWxldGVCZWxvd0xheW91dEJhc2VDbGlja0hhbmRsZXJ9PkNMUjwvYnV0dG9uPiA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGRpc2FibGVkIGtleT1cIm0wXCIgc3R5bGVzPXtidXR0b25TdHlsZXN9IGxpZD17c291cmNlTGF5b3V0Qm94SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmRlbGV0ZUJlbG93TGF5b3V0QmFzZUNsaWNrSGFuZGxlcn0+Q0xSPC9idXR0b24+fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtyZW5kZXJlZEJveENvbnRlbnR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+O1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAodXBkYXRlZFNvdXJjZTogTGF5b3V0Qm94KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHVwZGF0ZWRTb3VyY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUxheW91dEJveElkU3RyaW5nID0gc291cmNlLkxheW91dEJhc2VJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZU1vbGVjdWxlSWQgPSAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlTW9sZWN1bGVzLmZpbmQobSA9PiBtLlN0eWxlRm9yTGF5b3V0SWQgPT0gc291cmNlLkxheW91dEJhc2VJZCkgYXMgU3R5bGVNb2xlY3VsZSkuU3R5bGVNb2xlY3VsZUlkOyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZU1vbGVjdWxlSWRTdHJpbmcgPSBzdHlsZU1vbGVjdWxlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0Qm94U3R5bGVDbGFzcyA9IGBzJHtzdHlsZU1vbGVjdWxlSWR9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVlcG5lc3NQYWRkaW5nID0gYCR7KHNvdXJjZS5MZXZlbCArIDEpICogMTV9cHhgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVkQmFja2dyb3VuZENvbG9yID0gcHJvcGVydHlCYXIuY2FsY3VsYXRlQmFja2dyb3VuZENvbG9yRm9yTGV2ZWwoc291cmNlLkxldmVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlZENvbG9yID0gcHJvcGVydHlCYXIuY2FsY3VsYXRlQ29sb3JGb3JMZXZlbChzb3VyY2UuTGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVkQm9yZGVyQ29sb3IgPSBgc29saWQgMXB4ICR7cHJvcGVydHlCYXIuY2FsY3VsYXRlQmFja2dyb3VuZENvbG9yRm9yTGV2ZWwoc291cmNlLkxldmVsICsgMSl9YDsgLy8gVE9ETyB0ZXN0IGlmIHJlbmRlcmVkIHRvbyBtYW55IHRpbWVzIGJ5IHNldHRpbmcgYnJlYWsgcG9pbnQgaW4gdXBkYXRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNTdWJBdG9tcyA9IHNvdXJjZS5QbGFjZWRJbkJveEF0b21zLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzT2RkTGV2ZWwgPSAoc291cmNlLkxldmVsICUgMikgIT0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVTZWN0aW9uVGFyZ2V0KHVwZGF0ZWRTb3VyY2U6IExheW91dEJveCwgdGFyZ2V0OiB7IHJlbmRlck1hcXVldHRlKCk6IGFueSwgdXBkYXRlKHVwZGF0ZWRTb3VyY2U6IExheW91dEJveCk6IHZvaWQgfSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnVwZGF0ZSh1cGRhdGVkU291cmNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjYWxjdWxhdGVDb2xvckZvckxldmVsID0gKGxldmVsOiBudW1iZXIpOiBzdHJpbmcgPT4geyAvLyBUT0RPIGhhcmRjb2RlZCBwcmVjYWxjdWxhdGVkIHRhYmxlXHJcbiAgICAgICAgbGV2ZWwgPSBsZXZlbCA8IDAgPyAwIDogbGV2ZWw7XHJcbiAgICAgICAgbGV0IGNvbG9yVmFsdWU6IG51bWJlciA9IGxldmVsID4gMiA/IDIyMiA6IDc4ICsgbGV2ZWwgKiAxMjsgLy8gZ3JheSB0b25lIHdpdGggbGltaXQgdG8gd2hpdGVcclxuICAgICAgICByZXR1cm4gYHJnYigke2NvbG9yVmFsdWV9LCR7Y29sb3JWYWx1ZX0sJHtjb2xvclZhbHVlfSlgO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY2FsY3VsYXRlQmFja2dyb3VuZENvbG9yRm9yTGV2ZWwgPSAobGV2ZWw6IG51bWJlcik6IHN0cmluZyA9PiB7XHJcbiAgICAgICAgbGV2ZWwgPSBsZXZlbCA8IDAgPyAwIDogbGV2ZWw7XHJcbiAgICAgICAgbGV0IGNvbG9yVmFsdWU6IG51bWJlciA9IDIwMCAtIGxldmVsICogMjI7XHJcbiAgICAgICAgY29sb3JWYWx1ZSA9IGNvbG9yVmFsdWUgPCAwID8gMCA6IGNvbG9yVmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIGByZ2IoJHtjb2xvclZhbHVlfSwke2NvbG9yVmFsdWV9LCR7Y29sb3JWYWx1ZX0pYDtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSByZW5kZXJMYXlvdXRBdG9tQXJyYXkgPSAocHJvcGVydHlCYXI6IFByb3BlcnR5QmFyKTogbWFxdWV0dGUuTWFwcGluZzxMYXlvdXRBdG9tLCB7IHJlbmRlck1hcXVldHRlOiAoKSA9PiBtYXF1ZXR0ZS5WTm9kZSB9PiA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG1hcXVldHRlLmNyZWF0ZU1hcHBpbmc8TGF5b3V0QXRvbSwgYW55PihcclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U2VjdGlvblNvdXJjZUtleShzb3VyY2U6IExheW91dEF0b20pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2UuTGF5b3V0QmFzZUlkO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVTZWN0aW9uVGFyZ2V0KHNvdXJjZTogTGF5b3V0QXRvbSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZUxheW91dEF0b21JZFN0cmluZyA9IHNvdXJjZS5MYXlvdXRCYXNlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGxldCBzb3VyY2VDb250ZW50QXRvbUlkU3RyaW5nID0gc291cmNlLkhvc3RlZENvbnRlbnRBdG9tLkNvbnRlbnRBdG9tSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGxldCBzdHlsZU1vbGVjdWxlOiBTdHlsZU1vbGVjdWxlID0gKGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcy5maW5kKG0gPT4gbS5TdHlsZUZvckxheW91dElkID09IHNvdXJjZS5MYXlvdXRCYXNlSWQpIGFzIFN0eWxlTW9sZWN1bGUpOyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlTW9sZWN1bGVJZDogbnVtYmVyID0gc3R5bGVNb2xlY3VsZS5TdHlsZU1vbGVjdWxlSWQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVNb2xlY3VsZUlkU3RyaW5nOiBzdHJpbmcgPSBzdHlsZU1vbGVjdWxlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGxldCBsYXlvdXRBdG9tU3R5bGVDbGFzczogc3RyaW5nID0gYHMke3N0eWxlTW9sZWN1bGVJZFN0cmluZ31gOyAvLyBUT0RPIGNyZWF0ZSBhbGwgb2YgdGhlc2UgY29uc3RhbnQgc3RyaW5ncyB3aGVuIHBhcnNpbmcgZGF0YSA9PiBvbmUgaW5zdGFuY2UgaW4gbWVtb3J5ICEhIVxyXG4gICAgICAgICAgICAgICAgLy8gLS0tIG9ubHkgcmVuZGVyIG1vZGU6IHRyZWUgLS0tXHJcbiAgICAgICAgICAgICAgICBsZXQgY2FsY3VsYXRlZFBhZGRpbmdQeDogbnVtYmVyID0gKHByb3BlcnR5QmFyLnZpZXdNb2RlbC5kZWVwZXN0TGV2ZWxBY3RpdmVWaWV3ICsgMSAtIHNvdXJjZS5MZXZlbCkgKiAxNTtcclxuICAgICAgICAgICAgICAgIGxldCBjYWxjdWxhdGVkTWFyZ2luOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNhbGN1bGF0ZWRDb2xvcjogc3RyaW5nID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIGxldCBjYWxjdWxhdGVkQmFja2dyb3VuZENvbG9yOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgLy8gLS0tXHJcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkTWFyZ2luID0gYCR7KHNvdXJjZS5MZXZlbCkgKiAxNSArIDE1fXB4YDtcclxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRDb2xvciA9IHByb3BlcnR5QmFyLmNhbGN1bGF0ZUNvbG9yRm9yTGV2ZWwoc291cmNlLkxldmVsKTtcclxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRCYWNrZ3JvdW5kQ29sb3IgPSBwcm9wZXJ0eUJhci5jYWxjdWxhdGVCYWNrZ3JvdW5kQ29sb3JGb3JMZXZlbChzb3VyY2UuTGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGhvc3RlZENvbnRlbnRBdG9tOiBDb250ZW50QXRvbSA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ29udGVudEF0b21zLmZpbmQoYyA9PiBjLkNvbnRlbnRBdG9tSWQgPT0gc291cmNlLkhvc3RlZENvbnRlbnRBdG9tLkNvbnRlbnRBdG9tSWQpIGFzIENvbnRlbnRBdG9tKTsgLy8gVE9ETyBleHBlbnNpdmUgKDIgY29waWVzIG9mIGNvbnRlbnQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlck1hcXVldHRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpc1JlbmRlcmVkQXRvbVZpc2libGU6IGJvb2xlYW4gPSBjdXJyZW50QXBwLnBhZ2VQcmV2aWV3LnZpc2libGVMYXlvdXRBdG9tS2V5cy5maW5kSW5kZXgoayA9PiBrID09PSBzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmcpICE9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXNSZW5kZXJlZEF0b21Ib3ZlcmVkOiBib29sZWFuID0gY3VycmVudEFwcC5zdGF0ZS5ob3ZlcmVkUGFnZVByZXZpZXdMYXlvdXRCYXNlSWQgPT0gc291cmNlLkxheW91dEJhc2VJZDsgLy8gVE9ETyB3aWdnbGUgZWZmZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gc2FtZSBzdGFpciBlZmZlY3QgcmlnaHQgc2lkZSBtYXJnaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpdkF0b21TdHlsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsZXgtZGlyZWN0aW9uXCI6IFwicm93XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsZXgtd3JhcFwiOiBcIm5vd3JhcFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cIm1hcmdpbi1sZWZ0XCI6IFwiLTE1cHhcIiwgVE9ETyBzdGFpciBlZmZlY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLXJpZ2h0XCI6IFwiLTE1cHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYm9yZGVyLWxlZnRcIjogXCJzb2xpZCAxcHggYmxhY2tcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXRvbUNhcHRpb25TdHlsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRleHQtZGVjb3JhdGlvblwiOiBcInVuZGVybGluZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCJhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1sZWZ0XCI6IFwiMTVweFwiLCAvLyBUT0RPIHN0YWlyIGVmZmVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nLWxlZnRcIjogYCR7KGNhbGN1bGF0ZWRQYWRkaW5nUHggKyAoaXNSZW5kZXJlZEF0b21WaXNpYmxlID8gLTEgOiAwKSkudG9TdHJpbmcoKX1weGAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhZGRpbmctcmlnaHRcIjogXCIxNXB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpblwiOiBcIjBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIjogY2FsY3VsYXRlZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IGNhbGN1bGF0ZWRCYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZvbnQtc2l6ZVwiOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1pbi13aWR0aFwiOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJvcmRlci1sZWZ0XCI6IGlzUmVuZGVyZWRBdG9tSG92ZXJlZCA/IFwic29saWQgM3B4IHJnYigyMDAsMCwwKVwiIDogaXNSZW5kZXJlZEF0b21WaXNpYmxlID8gXCJkYXNoZWQgMXB4IHJnYigyMDAsMCwwKVwiIDogIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5wdXRTdHlsZXMgPSB7IC8vIFRPRE8gaW5wdXQgZGlzYXBwZWFycyB3aGVuIGxheW91dGF0b20gaG9zdGVkIGNvbnRlbnQgYXRvbSB0ZXh0IGlzOiAkXFxsZWZ0LlxccmlnaHRdJFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0LWRlY29yYXRpb25cIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCJhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1sZWZ0XCI6IFwiMTVweFwiLCAvLyBUT0RPIHN0YWlyIGVmZmVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nLWxlZnRcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nLXJpZ2h0XCI6IFwiMTVweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW5cIjogXCIwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCI6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZvbnQtc2l6ZVwiOiBcIjAuOHJlbVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtaW4td2lkdGhcIjogXCIyMDBweFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBidXR0b25TdHlsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZvbnQtc2l6ZVwiOiBcIjEwcHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIjogY2FsY3VsYXRlZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IGNhbGN1bGF0ZWRCYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3V0bGluZVwiOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm91dGxpbmUtb2Zmc2V0XCI6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXNQcmVzZWxlY3RlZEFueTogYm9vbGVhbiA9IGN1cnJlbnRBcHAuc3RhdGUucHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQgIT0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzUHJlc2VsZWN0ZWRDdXJyZW50OiBib29sZWFuID0gaXNQcmVzZWxlY3RlZEFueSAmJiBjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkID09IHNvdXJjZS5MYXlvdXRCYXNlSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBidXR0b25TdHlsZXNUYXJnZXQgPSB7IC8vIFRPRE8gYXBwZW5kIGFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZvbnQtc2l6ZVwiOiBcIjEwcHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIjogIWlzUHJlc2VsZWN0ZWRBbnkgfHwgaXNQcmVzZWxlY3RlZEN1cnJlbnQgPyBjYWxjdWxhdGVkQmFja2dyb3VuZENvbG9yIDogY2FsY3VsYXRlZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IGNhbGN1bGF0ZWRCYWNrZ3JvdW5kQ29sb3IsIC8vIFRPRE8gbWFnaWMgc3RyaW5nc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcImF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm91dGxpbmVcIjogIWlzUHJlc2VsZWN0ZWRBbnkgfHwgaXNQcmVzZWxlY3RlZEN1cnJlbnQgPyB1bmRlZmluZWQgOiBcInNvbGlkIDRweCByZ2IoMjAwLDAsMClcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3V0bGluZS1vZmZzZXRcIjogIWlzUHJlc2VsZWN0ZWRBbnkgfHwgaXNQcmVzZWxlY3RlZEN1cnJlbnQgPyB1bmRlZmluZWQgOiBcIi00cHhcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYnV0dG9uU3R5bGVzUHJlc2VsZWN0QW55ID0geyAvLyBUT0RPIGFwcGVuZCBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmb250LXNpemVcIjogXCIxMHB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCI6IGlzUHJlc2VsZWN0ZWRDdXJyZW50ID8gY2FsY3VsYXRlZEJhY2tncm91bmRDb2xvciA6IGlzUHJlc2VsZWN0ZWRBbnkgPyBjYWxjdWxhdGVkQmFja2dyb3VuZENvbG9yIDogY2FsY3VsYXRlZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IGlzUHJlc2VsZWN0ZWRDdXJyZW50ID8gXCJyZ2IoMjAwLDAsMClcIiA6IGNhbGN1bGF0ZWRCYWNrZ3JvdW5kQ29sb3IsIC8vIFRPRE8gbWFnaWMgc3RyaW5nc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcImF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm91dGxpbmVcIjogaXNQcmVzZWxlY3RlZEN1cnJlbnQgfHwgaXNQcmVzZWxlY3RlZEFueSA/IHVuZGVmaW5lZCA6IFwic29saWQgMXB4IHJnYigyMDAsMCwwKVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvdXRsaW5lLW9mZnNldFwiOiBpc1ByZXNlbGVjdGVkQ3VycmVudCB8fCBpc1ByZXNlbGVjdGVkQW55ID8gdW5kZWZpbmVkIDogXCItMXB4XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRlc2NyaXB0aW9uOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9zdGVkQ29udGVudEF0b20uQ29udGVudEF0b21UeXBlID09PSBDb250ZW50QXRvbVR5cGUuVGV4dCAmJiBob3N0ZWRDb250ZW50QXRvbS5UZXh0Q29udGVudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9IGhvc3RlZENvbnRlbnRBdG9tLlRleHRDb250ZW50Lmxlbmd0aCA+IDIwID8gaG9zdGVkQ29udGVudEF0b20uVGV4dENvbnRlbnQuc3Vic3RyaW5nKDAsIDIwKSArIFwiLi4uXCIgOiBob3N0ZWRDb250ZW50QXRvbS5UZXh0Q29udGVudDsgLy8gVE9ETyBleHBlbnNpdmUgLy8gVE9ETyBlbGxpcHNpcyAvLyBUT0RPIG11bHRpcGxlIHBsYWNlcyAvLyBUT0RPIGNyZWF0ZSB3aGVuIHN0b3JpbmcgaW4gREI/IG9yIHdoZW4gbG9hZGluZyBpbiBjbGllbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChob3N0ZWRDb250ZW50QXRvbS5Db250ZW50QXRvbVR5cGUgPT09IENvbnRlbnRBdG9tVHlwZS5MaW5rICYmIGhvc3RlZENvbnRlbnRBdG9tLlVybCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9IGhvc3RlZENvbnRlbnRBdG9tLlVybC5sZW5ndGggPiAyMCA/IGhvc3RlZENvbnRlbnRBdG9tLlVybC5zdWJzdHJpbmcoMCwgMjApICsgXCIuLi5cIiA6IGhvc3RlZENvbnRlbnRBdG9tLlVybDsgLy8gVE9ETyBleHBlbnNpdmUgLy8gVE9ETyBlbGxpcHNpcyAvLyBUT0RPIG11bHRpcGxlIHBsYWNlcyAvLyBUT0RPIGNyZWF0ZSB3aGVuIHN0b3JpbmcgaW4gREI/IG9yIHdoZW4gbG9hZGluZyBpbiBjbGllbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlbmRlcmVkSW5wdXRGb3JDb250ZW50OiBWTm9kZSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzRWRpdGVkTGF5b3V0QXRvbUlkOiBib29sZWFuID0gc291cmNlLkxheW91dEJhc2VJZCA9PSBwcm9wZXJ0eUJhci52aWV3TW9kZWwuZWRpdGVkTGF5b3V0QXRvbUlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFZGl0ZWRMYXlvdXRBdG9tSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3cgaW5wdXQgZmllbGQgaW5zdGVhZCBvZiByZW5kZXJlZCBhdG9tXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZElucHV0Rm9yQ29udGVudCA9IDxpbnB1dCBrZXk9e2BpbnAke3NvdXJjZUxheW91dEF0b21JZFN0cmluZ31gfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPXtsYXlvdXRBdG9tU3R5bGVDbGFzc31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17cHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDb250ZW50fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uaW5wdXQ9e3Byb3BlcnR5QmFyLmNvbnRlbnRBdG9tSW5wdXRIYW5kbGVyfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uYmx1cj17cHJvcGVydHlCYXIuY29udGVudEF0b21Mb3N0Rm9jdXNIYW5kbGVyfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ua2V5ZG93bj17cHJvcGVydHlCYXIuY29udGVudEF0b21LZXlEb3duSGFuZGxlcn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM9e2lucHV0U3R5bGVzfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyQ3JlYXRlPXtwcm9wZXJ0eUJhci5jb250ZW50QXRvbUFmdGVyQ3JlYXRlSGFuZGxlcn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaWQ9e3NvdXJjZUNvbnRlbnRBdG9tSWRTdHJpbmd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+PC9pbnB1dD4gYXMgVk5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYga2V5PXtzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWQ9e3NvdXJjZUxheW91dEF0b21JZFN0cmluZ31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcz17ZGl2QXRvbVN0eWxlc31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyQ3JlYXRlPXtwcm9wZXJ0eUJhci5sYXlvdXRBdG9tQWZ0ZXJDcmVhdGVIYW5kbGVyfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25tb3VzZWVudGVyPXtwcm9wZXJ0eUJhci5sYXlvdXRCYXNlTW91c2VFbnRlckhhbmRsZXJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbm1vdXNlbGVhdmU9e3Byb3BlcnR5QmFyLmxheW91dEJhc2VNb3VzZUxlYXZlSGFuZGxlcn0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IWlzRWRpdGVkTGF5b3V0QXRvbUlkID8gPHAga2V5PVwiMFwiIHN0eWxlcz17YXRvbUNhcHRpb25TdHlsZXN9IGFpZD17c291cmNlTGF5b3V0QXRvbUlkU3RyaW5nfSBjaWQ9e3NvdXJjZUNvbnRlbnRBdG9tSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmxheW91dEF0b21DbGlja0hhbmRsZXJ9PjxzbWFsbCBrZXk9XCIwXCIgYWlkPXtzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmd9IGNpZD17c291cmNlQ29udGVudEF0b21JZFN0cmluZ30+e2Rlc2NyaXB0aW9ufUFUT008L3NtYWxsPjwvcD4gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkSW5wdXRGb3JDb250ZW50fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgc3R5bGVzPXtidXR0b25TdHlsZXN9IGxpZD17c291cmNlTGF5b3V0QXRvbUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5zZWxlY3RMYXlvdXRCYXNlQ2xpY2tIYW5kbGVyfT4mIzgyMzA7ey8qRWxsaXBzaXMqL308L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYlwiIHN0eWxlcz17YnV0dG9uU3R5bGVzfSBsaWQ9e3NvdXJjZUxheW91dEF0b21JZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuaGlnaGxpZ2h0TGF5b3V0QmFzZUNsaWNrSGFuZGxlcn0+PzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJjXCIgc3R5bGVzPXtidXR0b25TdHlsZXN9IG1pZD17c3R5bGVNb2xlY3VsZUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5zZWxlY3RTdHlsZU1vbGVjdWxlQ2xpY2tIYW5kbGVyfT5TJiM4MjMwO3svKkVsbGlwc2lzKi99PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aXNQcmVzZWxlY3RlZEN1cnJlbnQgfHwgIWlzUHJlc2VsZWN0ZWRBbnkgPyA8YnV0dG9uIGtleT1cImRcIiBzdHlsZXM9e2J1dHRvblN0eWxlc1ByZXNlbGVjdEFueX0gbGlkPXtzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLm1vdmVMYXlvdXRBdG9tSW50b0JveENsaWNrSGFuZGxlcn0+SU48L2J1dHRvbj4gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gZGlzYWJsZWQga2V5PVwiZDBcIiBzdHlsZXM9e2J1dHRvblN0eWxlc1ByZXNlbGVjdEFueX0gbGlkPXtzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLm1vdmVMYXlvdXRBdG9tSW50b0JveENsaWNrSGFuZGxlcn0+SU48L2J1dHRvbj59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aXNQcmVzZWxlY3RlZEN1cnJlbnQgfHwgIWlzUHJlc2VsZWN0ZWRBbnkgPyA8YnV0dG9uIGtleT1cImVcIiBzdHlsZXM9e2J1dHRvblN0eWxlc1ByZXNlbGVjdEFueX0gbGlkPXtzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLm1vdmVMYXlvdXRBdG9tQmVmb3JlQXRvbUNsaWNrSGFuZGxlcn0+TVY8L2J1dHRvbj4gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gZGlzYWJsZWQga2V5PVwiZTBcIiBzdHlsZXM9e2J1dHRvblN0eWxlc1ByZXNlbGVjdEFueX0gbGlkPXtzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLm1vdmVMYXlvdXRBdG9tQmVmb3JlQXRvbUNsaWNrSGFuZGxlcn0+TVY8L2J1dHRvbj59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aXNQcmVzZWxlY3RlZEN1cnJlbnQgfHwgIWlzUHJlc2VsZWN0ZWRBbnkgPyA8YnV0dG9uIGtleT1cImZcIiBzdHlsZXM9e2J1dHRvblN0eWxlc1ByZXNlbGVjdEFueX0gbGlkPXtzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLnN5bmNMYXlvdXRCYXNlU3R5bGVzQ2xpY2tIYW5kbGVyfT5TVChBKTwvYnV0dG9uPiA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJmMFwiIHN0eWxlcz17YnV0dG9uU3R5bGVzUHJlc2VsZWN0QW55fSBsaWQ9e3NvdXJjZUxheW91dEF0b21JZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuc3luY0xheW91dEJhc2VTdHlsZXNDbGlja0hhbmRsZXJ9PlNUKEEpPC9idXR0b24+fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2lzUHJlc2VsZWN0ZWRDdXJyZW50IHx8ICFpc1ByZXNlbGVjdGVkQW55ID8gPGJ1dHRvbiBrZXk9XCJnXCIgc3R5bGVzPXtidXR0b25TdHlsZXNQcmVzZWxlY3RBbnl9IGxpZD17c291cmNlTGF5b3V0QXRvbUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5jcmVhdGVCb3hGb3JBdG9tSW5QbGFjZUNsaWNrSGFuZGxlcn0+KyhCKS5JTjwvYnV0dG9uPiA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJnMFwiIHN0eWxlcz17YnV0dG9uU3R5bGVzUHJlc2VsZWN0QW55fSBsaWQ9e3NvdXJjZUxheW91dEF0b21JZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuY3JlYXRlQm94Rm9yQXRvbUluUGxhY2VDbGlja0hhbmRsZXJ9PisoQikuSU48L2J1dHRvbj59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aXNQcmVzZWxlY3RlZEFueSAmJiAhaXNQcmVzZWxlY3RlZEN1cnJlbnQgPyA8YnV0dG9uIGtleT1cImhcIiBzdHlsZXM9e2J1dHRvblN0eWxlc1RhcmdldH0gbGlkPXtzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmZpbmFsaXplTGF5b3V0UmVxdWVzdH0+JChBOkIpPC9idXR0b24+IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGRpc2FibGVkIGtleT1cImgwXCIgc3R5bGVzPXtidXR0b25TdHlsZXNUYXJnZXR9IGxpZD17c291cmNlTGF5b3V0QXRvbUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5maW5hbGl6ZUxheW91dFJlcXVlc3R9PiQoQTpCKTwvYnV0dG9uPn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHshaXNQcmVzZWxlY3RlZEFueSA/IDxidXR0b24ga2V5PVwiaVwiIHN0eWxlcz17YnV0dG9uU3R5bGVzfSBsaWQ9e3NvdXJjZUxheW91dEF0b21JZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuZGVsZXRlTGF5b3V0QmFzZUNsaWNrSGFuZGxlcn0+WDwvYnV0dG9uPiA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJpMFwiIHN0eWxlcz17YnV0dG9uU3R5bGVzfSBsaWQ9e3NvdXJjZUxheW91dEF0b21JZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuZGVsZXRlTGF5b3V0QmFzZUNsaWNrSGFuZGxlcn0+WDwvYnV0dG9uPn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+O1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAodXBkYXRlZFNvdXJjZTogTGF5b3V0QXRvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSB1cGRhdGVkU291cmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmcgPSBzb3VyY2UuTGF5b3V0QmFzZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUNvbnRlbnRBdG9tSWRTdHJpbmcgPSBzb3VyY2UuSG9zdGVkQ29udGVudEF0b20uQ29udGVudEF0b21JZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZU1vbGVjdWxlID0gKGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcy5maW5kKG0gPT4gbS5TdHlsZUZvckxheW91dElkID09IHNvdXJjZS5MYXlvdXRCYXNlSWQpIGFzIFN0eWxlTW9sZWN1bGUpOyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZU1vbGVjdWxlSWQgPSBzdHlsZU1vbGVjdWxlLlN0eWxlTW9sZWN1bGVJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVNb2xlY3VsZUlkU3RyaW5nID0gc3R5bGVNb2xlY3VsZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEF0b21TdHlsZUNsYXNzID0gYHMke3N0eWxlTW9sZWN1bGVJZH1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVkUGFkZGluZ1B4ID0gKHByb3BlcnR5QmFyLnZpZXdNb2RlbC5kZWVwZXN0TGV2ZWxBY3RpdmVWaWV3IC0gc291cmNlLkxldmVsKSAqIDE1ICsgMTU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRDb2xvciA9IHByb3BlcnR5QmFyLmNhbGN1bGF0ZUNvbG9yRm9yTGV2ZWwoc291cmNlLkxldmVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlZE1hcmdpbiA9IGAkeyhzb3VyY2UuTGV2ZWwpICogMTUgKyAxNX1weGA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRCYWNrZ3JvdW5kQ29sb3IgPSBwcm9wZXJ0eUJhci5jYWxjdWxhdGVCYWNrZ3JvdW5kQ29sb3JGb3JMZXZlbChzb3VyY2UuTGV2ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0ZWRDb250ZW50QXRvbSA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ29udGVudEF0b21zLmZpbmQoYyA9PiBjLkNvbnRlbnRBdG9tSWQgPT0gc291cmNlLkhvc3RlZENvbnRlbnRBdG9tLkNvbnRlbnRBdG9tSWQpIGFzIENvbnRlbnRBdG9tKTsgLy8gVE9ETyBleHBlbnNpdmUgKDIgY29waWVzIG9mIGNvbnRlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlU2VjdGlvblRhcmdldCh1cGRhdGVkU291cmNlOiBMYXlvdXRBdG9tLCB0YXJnZXQ6IHsgcmVuZGVyTWFxdWV0dGUoKTogYW55LCB1cGRhdGUodXBkYXRlZFNvdXJjZTogTGF5b3V0QXRvbSk6IHZvaWQgfSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnVwZGF0ZSh1cGRhdGVkU291cmNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgY29udGVudEF0b21BZnRlckNyZWF0ZUhhbmRsZXIgPSAoZWxlbWVudDogRWxlbWVudCwgcHJvamVjdGlvbk9wdGlvbnM6IG1hcXVldHRlLlByb2plY3Rpb25PcHRpb25zLCB2bm9kZVNlbGVjdG9yOiBzdHJpbmcsIHByb3BlcnRpZXM6IG1hcXVldHRlLlZOb2RlUHJvcGVydGllcywgY2hpbGRyZW46IFZOb2RlW10pID0+IHtcclxuICAgICAgICBsZXQgdGFyZ2V0RWxlbWVudDogSFRNTElucHV0RWxlbWVudCA9IGVsZW1lbnQgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICB0YXJnZXRFbGVtZW50LmZvY3VzKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgbGF5b3V0QmFzZU1vdXNlRW50ZXJIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCB0YXJnZXRFbGVtZW50OiBIVE1MRWxlbWVudCA9IGV2dC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmhvdmVyZWRCb3hUcmVlTGF5b3V0QmFzZUlkID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKHRhcmdldEVsZW1lbnQsIFwibGlkXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIGxheW91dEJhc2VNb3VzZUxlYXZlSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmhvdmVyZWRCb3hUcmVlTGF5b3V0QmFzZUlkID0gMDsgLy8gVE9ETyByZW1lbWJlciB3aGF0IHdhcyBlbnRlcmVkIGJlZm9yZSBhbmQgcmVoaWdobGlnaHRcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBsYXlvdXRBdG9tQWZ0ZXJDcmVhdGVIYW5kbGVyID0gKGVsZW1lbnQ6IEVsZW1lbnQsIHByb2plY3Rpb25PcHRpb25zOiBtYXF1ZXR0ZS5Qcm9qZWN0aW9uT3B0aW9ucywgdm5vZGVTZWxlY3Rvcjogc3RyaW5nLCBwcm9wZXJ0aWVzOiBtYXF1ZXR0ZS5WTm9kZVByb3BlcnRpZXMsIGNoaWxkcmVuOiBWTm9kZVtdKSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXggPT0gMCkge1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0RWxlbWVudDogSFRNTEVsZW1lbnQgPSBlbGVtZW50IGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5fYWN0aXZlVmlld0xheW91dEF0b21Eb21Ob2RlUmVmZXJlbmNlc1twcm9wZXJ0aWVzLmtleSBhcyBzdHJpbmddID0gdGFyZ2V0RWxlbWVudDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgcmVzZXRDb250ZW50QXRvbUVkaXRNb2RlID0gKCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAucGFnZVByZXZpZXcucmVzZXRFcXVhdGlvbk51bWJlcnNXaGVuTW9kaWZ5aW5nKGZhbHNlKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuZWRpdGVkTGF5b3V0QXRvbUlkID0gMDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENvbnRlbnQgPSBcIlwiO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wT3JpZ2luYWxDb250ZW50ID0gXCJcIjtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBjb250ZW50QXRvbUxvc3RGb2N1c0hhbmRsZXIgPSAoZXZ0OiBGb2N1c0V2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudXBkYXRlQ29udGVudEF0b20ocGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwiY2lkXCIpKTtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSB1cGRhdGVDb250ZW50QXRvbSA9IChjb250ZW50QXRvbUlkOiBudW1iZXIpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmVkaXRlZExheW91dEF0b21JZCAhPSAwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENvbnRlbnQgIT09IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wT3JpZ2luYWxDb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDb250ZW50ICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRlbnRBdG9tOiBDb250ZW50QXRvbSA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ29udGVudEF0b21zLmZpbmQoYSA9PiBhLkluc3RhbmNlZE9uTGF5b3V0SWQgPT0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmVkaXRlZExheW91dEF0b21JZCkgYXMgQ29udGVudEF0b20pOyAvLyBUT0RPIGV4cGVuc2l2ZSBidXQgZmVlbHMgYmV0dGVyXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRBdG9tLkNvbnRlbnRBdG9tVHlwZSA9PT0gQ29udGVudEF0b21UeXBlLlRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEF0b20uVGV4dENvbnRlbnQgPSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRlbnRBdG9tLkNvbnRlbnRBdG9tVHlwZSA9PT0gQ29udGVudEF0b21UeXBlLkxpbmspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEF0b20uVXJsID0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDb250ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFJlYWR5U3RhdGUgPSBSZWFkeVN0YXRlLlBlbmRpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLlVwZGF0ZVRleHRDb250ZW50QXRvbUpzb24oY29udGVudEF0b21JZCwgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDb250ZW50KS5kb25lKChkYXRhOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9KS5hbHdheXMoKGRhdGE6IGFueSkgPT4gY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50UmVhZHlTdGF0ZSA9IFJlYWR5U3RhdGUuT2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZyBUT0RPIGRvY3VtZW50ID0+IHVzZSBidXR0b24gdG8gZGVsZXRlIGxheW91dCBhdG9tIGluc3RlYWQsIHNob3dzIGVzY2FwZSBiZWhhdmlvdXIgaW4gY3VycmVudCBpbXBsZW1lbnRhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ29udGVudEF0b21zLmZpbmQoYyA9PiBjLkluc3RhbmNlZE9uTGF5b3V0SWQgPT0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmVkaXRlZExheW91dEF0b21JZCkgYXMgQ29udGVudEF0b20pLlRleHRDb250ZW50ID0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBPcmlnaW5hbENvbnRlbnQ7IC8vIFRPRE8gZXhwZW5zaXZlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIucmVzZXRDb250ZW50QXRvbUVkaXRNb2RlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgY29udGVudEF0b21LZXlEb3duSGFuZGxlciA9IChldnQ6IEtleWJvYXJkRXZlbnQpID0+IHsgLy8gVE9ETyBjb2RlIGR1cGxpY2F0aW9uXHJcbiAgICAgICAgaWYgKGV2dC5rZXlDb2RlID09IDEzIC8qRU5URVIqLykge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgKGV2dC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkuYmx1cigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChldnQua2V5Q29kZSA9PSAyNyAvKkVTQyovKSB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNvbnRlbnRBdG9tcy5maW5kKGMgPT4gYy5JbnN0YW5jZWRPbkxheW91dElkID09IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5lZGl0ZWRMYXlvdXRBdG9tSWQpIGFzIENvbnRlbnRBdG9tKS5UZXh0Q29udGVudCA9IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wT3JpZ2luYWxDb250ZW50OyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZXNldENvbnRlbnRBdG9tRWRpdE1vZGUoKTtcclxuICAgICAgICAgICAgKGV2dC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkuYmx1cigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChldnQua2V5Q29kZSA9PSB1bmRlZmluZWQgLyppbnB1dCBmb2N1cyBsb3N0Ki8pIHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE8gY2xlYW4gd2hpdGVzcGFjZXNcclxuICAgICAgICAvLyBUT0RPIGF1dG9zaXplXHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgY29udGVudEF0b21JbnB1dEhhbmRsZXIgPSAoZXZ0OiBLZXlib2FyZEV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDb250ZW50ID0gKGV2dC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWU7XHJcbiAgICAgICAgKGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5Db250ZW50QXRvbXMuZmluZChjID0+IGMuSW5zdGFuY2VkT25MYXlvdXRJZCA9PSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuZWRpdGVkTGF5b3V0QXRvbUlkKSBhcyBDb250ZW50QXRvbSkuVGV4dENvbnRlbnQgPSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENvbnRlbnQ7IC8vIFRPRE8gZXhwZW5zaXZlIC8vIFRPRE8gYSBuaWNlciB3YXkgd291bGQgYmUgdG8gcHJldmVudCB1cGRhdGUgaW4gcmVuZGVyZWQgcGFnZSBhbmQgdHJpZ2dlciBmb3JtdWxhIHVwZGF0ZTsgZm9ybXVsYSBpcyBkZXN0cm95ZWQgd2hlbiByZW5kZXJlZCBjb250ZW50IGNoYW5nZXNcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBsYXlvdXRBdG9tQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBUT0RPIHRoaXMgaXMgc2V0IGZvciBldmVyeSBjb250ZW50IGF0b20gaW4gcHJldmlldy4uLiBwZXJmb3JtYW5jZT9cclxuICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50UmVhZHlTdGF0ZSAhPT0gUmVhZHlTdGF0ZS5Paykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInBlbmRpbmcuLi5cIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFNlbGVjdGlvbk1vZGUgPT09IFNlbGVjdGlvbk1vZGUuQ29udGVudCkge1xyXG4gICAgICAgICAgICBsZXQgY29udGVudEF0b21JZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwiY2lkXCIpO1xyXG4gICAgICAgICAgICBsZXQgbGF5b3V0QXRvbUlkOiBudW1iZXIgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJhaWRcIik7XHJcbiAgICAgICAgICAgIGxldCBob3N0ZWRDb250ZW50QXRvbTogQ29udGVudEF0b20gPSAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNvbnRlbnRBdG9tcy5maW5kKGMgPT4gYy5Db250ZW50QXRvbUlkID09IGNvbnRlbnRBdG9tSWQpIGFzIENvbnRlbnRBdG9tKTsgLy8gVE9ETyBleHBlbnNpdmUgKDIgY29waWVzIG9mIGNvbnRlbnQpXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ29udGVudCA9IFwiXCI7XHJcbiAgICAgICAgICAgIGlmIChob3N0ZWRDb250ZW50QXRvbS5Db250ZW50QXRvbVR5cGUgPT09IENvbnRlbnRBdG9tVHlwZS5UZXh0KSB7IC8vIFRPRE8gY29kZSBkdXBsaWNhdGlvbiBmb3IgY29udGVudCBzZWxlY3Rpb24gYXQgbXVsdGlwbGUgcGxhY2VzXHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENvbnRlbnQgPSBob3N0ZWRDb250ZW50QXRvbS5UZXh0Q29udGVudCBhcyBzdHJpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaG9zdGVkQ29udGVudEF0b20uQ29udGVudEF0b21UeXBlID09PSBDb250ZW50QXRvbVR5cGUuTGluaykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDb250ZW50ID0gaG9zdGVkQ29udGVudEF0b20uVXJsIGFzIHN0cmluZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcE9yaWdpbmFsQ29udGVudCA9IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ29udGVudDtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmVkaXRlZExheW91dEF0b21JZCA9IGxheW91dEF0b21JZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE9cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJTdGF0ZU1vZGlmaWVyU2VsZWN0b3JzID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICBsZXQgc3RhdGVNb2RpZmllckdyb3VwU3R5bGVzID0ge1xyXG4gICAgICAgICAgICBcImRpc3BsYXlcIjogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgIFwiZmxleC1mbG93XCI6IFwicm93IG5vd3JhcFwiXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgc3RhdGVNb2RpZmllcnM6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgbGV0IHN0eWxlTW9sZWN1bGU6IFN0eWxlTW9sZWN1bGUgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChtID0+IG0uU3R5bGVNb2xlY3VsZUlkID09IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFN0eWxlTW9sZWN1bGVJZCkgYXMgU3R5bGVNb2xlY3VsZTsgLy8gVE9ETyBmaW5kIHVzZWQgcmVwZWF0ZWRseSBmb3IgcmVuZGVyIGNvbnRyb2xzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHlsZU1vbGVjdWxlLk1hcHBlZFN0eWxlQXRvbXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IG1vZGlmaWVyOiBzdHJpbmcgfCB1bmRlZmluZWQgPSBzdHlsZU1vbGVjdWxlLk1hcHBlZFN0eWxlQXRvbXNbaV0uU3RhdGVNb2RpZmllcjtcclxuICAgICAgICAgICAgaWYgKG1vZGlmaWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVyID0gXCJcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RhdGVNb2RpZmllcnMuZmluZEluZGV4KHMgPT4gcyA9PT0gbW9kaWZpZXIpID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcmVuZGVyZWRNb2RpZmllcnM6IFZOb2RlW10gPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlTW9kaWZpZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBtb2RpZmllcjogc3RyaW5nID0gc3RhdGVNb2RpZmllcnNbaV07XHJcbiAgICAgICAgICAgIGxldCBtb2RpZmllckJ1dHRvblN0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgIFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogbW9kaWZpZXIgPT0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3RhdGVNb2RpZmllciA/IFwicmVkXCIgOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmVuZGVyZWRNb2RpZmllcnMucHVzaCg8YnV0dG9uIGtleT17bW9kaWZpZXJ9IHJvbGU9XCJidXR0b25cIiBtaWQ9e21vZGlmaWVyfSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zdGF0ZU1vZGlmaWVyQ2xpY2tIYW5kbGVyfSBzdHlsZXM9e21vZGlmaWVyQnV0dG9uU3R5bGVzfT57bW9kaWZpZXJ9PC9idXR0b24+IGFzIFZOb2RlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiA8ZGl2IGtleT1cIi0yXCIgc3R5bGVzPXtzdGF0ZU1vZGlmaWVyR3JvdXBTdHlsZXN9PlxyXG4gICAgICAgICAgICB7cmVuZGVyZWRNb2RpZmllcnN9XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGVNb2RpZmllckNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgc2VsZWN0ZWRTdGF0ZU1vZGlmaWVyOiBzdHJpbmcgPSBwYXJzZVN0cmluZ0Zyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJtaWRcIik7XHJcbiAgICAgICAgaWYgKHNlbGVjdGVkU3RhdGVNb2RpZmllciA9PT0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3RhdGVNb2RpZmllcikge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdGF0ZU1vZGlmaWVyID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFN0YXRlTW9kaWZpZXIgPSBzZWxlY3RlZFN0YXRlTW9kaWZpZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyUmVzcG9uc2l2ZURldmljZVNlbGVjdG9ycyA9ICgpOiBWTm9kZSA9PiB7XHJcbiAgICAgICAgbGV0IHJlc3BvbnNpdmVHcm91cFN0eWxlcyA9IHtcclxuICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiZmxleFwiLFxyXG4gICAgICAgICAgICBcImZsZXgtZmxvd1wiOiBcInJvdyB3cmFwXCJcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiA8ZGl2IGtleT1cIi0zXCIgc3R5bGVzPXtyZXNwb25zaXZlR3JvdXBTdHlsZXN9PlxyXG4gICAgICAgICAgICB7KGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5SZXNwb25zaXZlRGV2aWNlcyAhPT0gdW5kZWZpbmVkKSA/IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5SZXNwb25zaXZlRGV2aWNlcy5tYXAociA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2l2ZUJ1dHRvblN0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBcImZsZXhcIjogXCIwIDAgYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiByLlJlc3BvbnNpdmVEZXZpY2VJZCA9PSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRSZXNwb25zaXZlRGV2aWNlSWQgPyBcInJlZFwiIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNpdmVEZXZpY2VJZFN0cmluZzogc3RyaW5nID0gci5SZXNwb25zaXZlRGV2aWNlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiA8YnV0dG9uIGtleT17cmVzcG9uc2l2ZURldmljZUlkU3RyaW5nfSByb2xlPVwiYnV0dG9uXCIgcmlkPXtyZXNwb25zaXZlRGV2aWNlSWRTdHJpbmd9IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnNlbGVjdFJlc3BvbnNpdmVEZXZpY2VDbGlja0hhbmRsZXJ9IHN0eWxlcz17cmVzcG9uc2l2ZUJ1dHRvblN0eWxlc30+e3IuTmFtZVNob3J0fTwvYnV0dG9uPiBhcyBWTm9kZTtcclxuICAgICAgICAgICAgfSkgOiB1bmRlZmluZWR9XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2VsZWN0UmVzcG9uc2l2ZURldmljZUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgc2VsZWN0ZWRSZXNwb25zaXZlSWQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcInJpZFwiKTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkUmVzcG9uc2l2ZURldmljZUlkID09IHNlbGVjdGVkUmVzcG9uc2l2ZUlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFJlc3BvbnNpdmVEZXZpY2VJZCA9IGN1cnJlbnRBcHAuc3RhdGUubm9uZVJlc3BvbnNpdmVEZXZpY2VJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFJlc3BvbnNpdmVEZXZpY2VJZCA9IHNlbGVjdGVkUmVzcG9uc2l2ZUlkO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlbmRlclN0eWxlQXRvbUNvbnRyb2xzID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICByZXR1cm4gPGRpdiBrZXk9XCItMVwiPlxyXG4gICAgICAgICAgICA8c2VsZWN0IGtleT1cIjBcIlxyXG4gICAgICAgICAgICAgICAgb25jaGFuZ2U9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnN0eWxlQXRvbVR5cGVDaGFuZ2VkSGFuZGxlcn0+XHJcbiAgICAgICAgICAgICAgICB7Z2V0QXJyYXlGb3JFbnVtKFN0eWxlQXRvbVR5cGUpLm1hcCgodHlwZTogc3RyaW5nLCBpbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzU2VsZWN0ZWQ6IGJvb2xlYW4gPSBpbmRleCA9PT0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3R5bGVBdG9tVHlwZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNTZWxlY3RlZCA/IDxvcHRpb24gc2VsZWN0ZWQga2V5PXtpbmRleH0gdmFsdWU9e2luZGV4LnRvU3RyaW5nKCl9Pnt0eXBlfTwvb3B0aW9uPiA6IDxvcHRpb24ga2V5PXtpbmRleH0gdmFsdWU9e2luZGV4LnRvU3RyaW5nKCl9Pnt0eXBlfTwvb3B0aW9uPjtcclxuICAgICAgICAgICAgICAgIH0pfVxyXG4gICAgICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgICAgICAgPGlucHV0IGtleT1cIi0xXCJcclxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPXtcIm9wdGlvbmFsIDpob3Zlciw6YmVmb3JlLC4uLlwifVxyXG4gICAgICAgICAgICAgICAgdmFsdWU9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wUHNldWRvU2VsZWN0b3J9XHJcbiAgICAgICAgICAgICAgICBvbmlucHV0PXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5wc2V1ZG9TZWxlY3RvcklucHV0SGFuZGxlcn0+XHJcbiAgICAgICAgICAgIDwvaW5wdXQ+XHJcbiAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jcmVhdGVTdHlsZUF0b21Gb3JNb2xlY3VsZUNsaWNrSGFuZGxlcn0+KzwvYnV0dG9uPlxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHBzZXVkb1NlbGVjdG9ySW5wdXRIYW5kbGVyID0gKGV2dDogS2V5Ym9hcmRFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wUHNldWRvU2VsZWN0b3IgPSAoZXZ0LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHN0eWxlQXRvbVR5cGVDaGFuZ2VkSGFuZGxlciA9IChldnQ6IFVJRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgdGFyZ2V0U2VsZWN0ID0gZXZ0LnRhcmdldCBhcyBIVE1MU2VsZWN0RWxlbWVudDtcclxuICAgICAgICBsZXQgcGFyc2VkU3R5bGVBdG9tVHlwZTogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmICh0YXJnZXRTZWxlY3Quc2VsZWN0ZWRJbmRleCA8IHRhcmdldFNlbGVjdC5jaGlsZEVsZW1lbnRDb3VudCkge1xyXG4gICAgICAgICAgICBsZXQgc2VsZWN0T3B0aW9uRWxlbWVudDogSFRNTE9wdGlvbkVsZW1lbnQgPSB0YXJnZXRTZWxlY3Qub3B0aW9uc1t0YXJnZXRTZWxlY3Quc2VsZWN0ZWRJbmRleF07XHJcbiAgICAgICAgICAgIHBhcnNlZFN0eWxlQXRvbVR5cGUgPSBwYXJzZUludChzZWxlY3RPcHRpb25FbGVtZW50LnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhcnNlZFN0eWxlQXRvbVR5cGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZUF0b21UeXBlID0gcGFyc2VkU3R5bGVBdG9tVHlwZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjcmVhdGVTdHlsZUF0b21Gb3JNb2xlY3VsZUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBQc2V1ZG9TZWxlY3RvciAhPT0gXCJcIikge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdGF0ZU1vZGlmaWVyID0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBQc2V1ZG9TZWxlY3RvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLkNyZWF0ZVN0eWxlQXRvbUZvck1vbGVjdWxlSnNvbih0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZU1vbGVjdWxlSWQsIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFN0eWxlQXRvbVR5cGUsIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFJlc3BvbnNpdmVEZXZpY2VJZCwgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3RhdGVNb2RpZmllcikuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wUHNldWRvU2VsZWN0b3IgPSBcIlwiO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyU3R5bGVRdWFudHVtQ29udHJvbHMgPSAoKTogVk5vZGUgPT4ge1xyXG4gICAgICAgIHJldHVybiA8ZGl2IGtleT1cIjBcIj5cclxuICAgICAgICAgICAgPGlucHV0IGtleT1cIi0zXCJcclxuICAgICAgICAgICAgICAgIHZhbHVlPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcFF1YW50dW1OYW1lfVxyXG4gICAgICAgICAgICAgICAgb25pbnB1dD17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucXVhbnR1bU5hbWVJbnB1dEhhbmRsZXJ9PlxyXG4gICAgICAgICAgICA8L2lucHV0PlxyXG4gICAgICAgICAgICA8aW5wdXQga2V5PVwiLTJcIlxyXG4gICAgICAgICAgICAgICAgdmFsdWU9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzUHJvcGVydHlOYW1lfVxyXG4gICAgICAgICAgICAgICAgb25pbnB1dD17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY3NzUHJvcGVydHlOYW1lSW5wdXRIYW5kbGVyfT5cclxuICAgICAgICAgICAgPC9pbnB1dD5cclxuICAgICAgICAgICAgPGlucHV0IGtleT1cIi0xXCJcclxuICAgICAgICAgICAgICAgIHZhbHVlPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1ZhbHVlfVxyXG4gICAgICAgICAgICAgICAgb25pbnB1dD17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY3NzVmFsdWVJbnB1dEhhbmRsZXJ9PlxyXG4gICAgICAgICAgICA8L2lucHV0PlxyXG4gICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY3JlYXRlU3R5bGVRdWFudHVtQ2xpY2tIYW5kbGVyfT4mIzEwMDA0OzwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8YnV0dG9uIGtleT1cImJcIiByb2xlPVwiYnV0dG9uXCIgb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2hvd0FsbENzc1Byb3BlcnRpZXNGb3JRdWFudHVtQ2xpY2tIYW5kbGVyfT4/PC9idXR0b24+XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2hvd0FsbENzc1Byb3BlcnRpZXNGb3JRdWFudHVtQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmRpc3BsYXlQb3B1cChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCBQb3B1cE1vZGUuQWxsQ3NzUHJvcGVydGllc0ZvclF1YW50dW0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY3JlYXRlU3R5bGVRdWFudHVtQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5DcmVhdGVTdHlsZVF1YW50dW1Kc29uKGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5DYWxpZm9ybmlhUHJvamVjdElkLCB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcFF1YW50dW1OYW1lLCB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1Byb3BlcnR5TmFtZSwgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDc3NWYWx1ZSkuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnJlc2V0QWRkUXVhbnR1bVN0YXRlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZXNldEFkZFF1YW50dW1TdGF0ZSA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcFF1YW50dW1OYW1lID0gXCJRdWFudHVtXCI7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDc3NQcm9wZXJ0eU5hbWUgPSBcIlwiO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzVmFsdWUgPSBcIlwiO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcXVhbnR1bU5hbWVJbnB1dEhhbmRsZXIgPSAoZXZ0OiBLZXlib2FyZEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBRdWFudHVtTmFtZSA9IChldnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyU3R5bGVWYWx1ZUFycmF5ID0gKHByb3BlcnR5QmFyOiBQcm9wZXJ0eUJhcik6IG1hcXVldHRlLk1hcHBpbmc8U3R5bGVWYWx1ZSwgeyByZW5kZXJNYXF1ZXR0ZTogKCkgPT4gbWFxdWV0dGUuVk5vZGUgfT4gPT4ge1xyXG4gICAgICAgIHJldHVybiBtYXF1ZXR0ZS5jcmVhdGVNYXBwaW5nPFN0eWxlVmFsdWUsIGFueT4oXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFNlY3Rpb25Tb3VyY2VLZXkoc291cmNlOiBTdHlsZVZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlLlN0eWxlVmFsdWVJZDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlU2VjdGlvblRhcmdldChzb3VyY2U6IFN0eWxlVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzb3VyY2VJZFN0cmluZyA9IHNvdXJjZS5TdHlsZVZhbHVlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGxldCBzdHlsZVZhbHVlQnV0dG9uU3R5bGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCI6IFwiMXJlbVwiXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlVmFsdWVUZXh0U3R5bGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJvdXRsaW5lXCI6IHNvdXJjZS5Dc3NWYWx1ZSA9PT0gXCJcIiA/IFwic29saWQgd2hpdGUgMXB4XCIgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJvdXRsaW5lLW9mZnNldFwiOiBzb3VyY2UuQ3NzVmFsdWUgPT09IFwiXCIgPyBcIi0xcHhcIiA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICBcImZsZXhcIjogXCIwIDAgYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCJhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW5cIjogXCIwXCJcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlck1hcXVldHRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17c291cmNlSWRTdHJpbmd9IGV4aXRBbmltYXRpb249e3Byb3BlcnR5QmFyLnN0eWxlRWxlbWVudEV4aXRBbmltYXRpb259IHN0eWxlcz17eyBcImRpc3BsYXlcIjpcImZsZXhcIiwgXCJmbGV4LWZsb3dcIjogXCJyb3cgbm93cmFwXCJ9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIHN0eWxlcz17c3R5bGVWYWx1ZVRleHRTdHlsZX0+e3NvdXJjZS5Dc3NQcm9wZXJ0eX06IHtzb3VyY2UuQ3NzVmFsdWV9PC9wPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIHZpZD17c291cmNlSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmRlbGV0ZVN0eWxlVmFsdWVDbGlja0hhbmRsZXJ9IHN0eWxlcz17c3R5bGVWYWx1ZUJ1dHRvblN0eWxlfT5YPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImJcIiByb2xlPVwiYnV0dG9uXCIgYWlkPXtzb3VyY2UuU3R5bGVBdG9tSWQudG9TdHJpbmcoKX0gdmlkPXtzb3VyY2VJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIudXBkYXRlQ3NzVmFsdWVDbGlja0hhbmRsZXJ9IHN0eWxlcz17c3R5bGVWYWx1ZUJ1dHRvblN0eWxlfT5FZGl0PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKHVwZGF0ZWRTb3VyY2U6IFN0eWxlVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gdXBkYXRlZFNvdXJjZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlSWRTdHJpbmcgPSBzb3VyY2UuU3R5bGVWYWx1ZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlU2VjdGlvblRhcmdldCh1cGRhdGVkU291cmNlOiBTdHlsZVZhbHVlLCB0YXJnZXQ6IHsgcmVuZGVyTWFxdWV0dGUoKTogYW55LCB1cGRhdGUodXBkYXRlZFNvdXJjZTogU3R5bGVWYWx1ZSk6IHZvaWQgfSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnVwZGF0ZSh1cGRhdGVkU291cmNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJTdHlsZVF1YW50dW1BcnJheUZvclN0eWxlQXRvbSA9ICgpOiBtYXF1ZXR0ZS5NYXBwaW5nPFN0eWxlUXVhbnR1bSwgeyByZW5kZXJNYXF1ZXR0ZTogKCkgPT4gbWFxdWV0dGUuVk5vZGUgfT4gPT4ge1xyXG4gICAgICAgIHJldHVybiBtYXF1ZXR0ZS5jcmVhdGVNYXBwaW5nPFN0eWxlUXVhbnR1bSwgYW55PihcclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U2VjdGlvblNvdXJjZUtleShzb3VyY2U6IFN0eWxlUXVhbnR1bSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5TdHlsZVF1YW50dW1JZDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlU2VjdGlvblRhcmdldChzb3VyY2U6IFN0eWxlUXVhbnR1bSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZUlkU3RyaW5nID0gc291cmNlLlN0eWxlUXVhbnR1bUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlck1hcXVldHRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17c291cmNlSWRTdHJpbmd9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgc3R5bGVzPXt7XCJtYXJnaW5cIjogXCIwXCJ9fT57c291cmNlLk5hbWV9OiB7c291cmNlLkNzc1Byb3BlcnR5fSAoe3NvdXJjZS5Dc3NWYWx1ZX0pPC9wPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gYXMgVk5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICh1cGRhdGVkU291cmNlOiBTdHlsZVF1YW50dW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gdXBkYXRlZFNvdXJjZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlSWRTdHJpbmcgPSBzb3VyY2UuU3R5bGVRdWFudHVtSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVTZWN0aW9uVGFyZ2V0KHVwZGF0ZWRTb3VyY2U6IFN0eWxlUXVhbnR1bSwgdGFyZ2V0OiB7IHJlbmRlck1hcXVldHRlKCk6IGFueSwgdXBkYXRlKHVwZGF0ZWRTb3VyY2U6IFN0eWxlUXVhbnR1bSk6IHZvaWQgfSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnVwZGF0ZSh1cGRhdGVkU291cmNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJTdHlsZUF0b21BcnJheSA9IChwcm9wZXJ0eUJhcjogUHJvcGVydHlCYXIpOiBtYXF1ZXR0ZS5NYXBwaW5nPFN0eWxlQXRvbSwgeyByZW5kZXJNYXF1ZXR0ZTogKCkgPT4gbWFxdWV0dGUuVk5vZGUgfT4gPT4ge1xyXG4gICAgICAgIHJldHVybiBtYXF1ZXR0ZS5jcmVhdGVNYXBwaW5nPFN0eWxlQXRvbSwgYW55PihcclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U2VjdGlvblNvdXJjZUtleShzb3VyY2U6IFN0eWxlQXRvbSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5TdHlsZUF0b21JZDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlU2VjdGlvblRhcmdldChzb3VyY2U6IFN0eWxlQXRvbSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlQXRvbUlkU3RyaW5nID0gc291cmNlLlN0eWxlQXRvbUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgYXBwbGllZFZhbHVlc01hcCA9IHByb3BlcnR5QmFyLnJlbmRlclN0eWxlVmFsdWVBcnJheShwcm9wZXJ0eUJhcik7XHJcbiAgICAgICAgICAgICAgICBsZXQgYXBwbGllZFF1YW50dW1zTWFwID0gcHJvcGVydHlCYXIucmVuZGVyU3R5bGVRdWFudHVtQXJyYXlGb3JTdHlsZUF0b20oKTtcclxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuQXBwbGllZFZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBwbGllZFZhbHVlc01hcC5tYXAoc291cmNlLkFwcGxpZWRWYWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBwbGllZFZhbHVlc01hcC5tYXAoW10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5NYXBwZWRRdWFudHVtcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBwbGllZFF1YW50dW1zTWFwLm1hcChzb3VyY2UuTWFwcGVkUXVhbnR1bXMubWFwKHFtID0+IHFtLlN0eWxlUXVhbnR1bSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBwbGllZFF1YW50dW1zTWFwLm1hcChbXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlck1hcXVldHRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpc0Rpc3BsYXlTdHlsZUF0b206IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlCYXIudmlld01vZGVsLmN1cnJlbnRQcm9wZXJ0eUJhck1vZGUgPT09IFByb3BlcnR5QmFyTW9kZS5TdHlsZU1vbGVjdWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3R5bGVNb2xlY3VsZTogU3R5bGVNb2xlY3VsZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcy5maW5kKG0gPT4gbS5TdHlsZU1vbGVjdWxlSWQgPT0gcHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3R5bGVNb2xlY3VsZUlkKSBhcyBTdHlsZU1vbGVjdWxlOy8vIFRPRE8gc2xvdyB2ZXJ5IGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldE1hcHBpbmdJbmRleDogbnVtYmVyID0gc3R5bGVNb2xlY3VsZS5NYXBwZWRTdHlsZUF0b21zLmZpbmRJbmRleChtID0+IG0uUmVzcG9uc2l2ZURldmljZUlkID09IHByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFJlc3BvbnNpdmVEZXZpY2VJZCAmJiBtLlN0eWxlTW9sZWN1bGVBdG9tTWFwcGluZ0lkID09IHNvdXJjZS5NYXBwZWRUb01vbGVjdWxlSWQgJiYgKChtLlN0YXRlTW9kaWZpZXIgPT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdGF0ZU1vZGlmaWVyID09PSBcIlwiKSB8fCAobS5TdGF0ZU1vZGlmaWVyID09PSBwcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdGF0ZU1vZGlmaWVyKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNEaXNwbGF5U3R5bGVBdG9tID0gdGFyZ2V0TWFwcGluZ0luZGV4ICE9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaXZTdHlsZUF0b21TdHlsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogIWlzRGlzcGxheVN0eWxlQXRvbSA/IFwibm9uZVwiIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCI6IFwiYXV0b1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17c3R5bGVBdG9tSWRTdHJpbmd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0QW5pbWF0aW9uPXtwcm9wZXJ0eUJhci5zdHlsZUVsZW1lbnRFeGl0QW5pbWF0aW9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzPXtkaXZTdHlsZUF0b21TdHlsZXN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAga2V5PVwiMFwiIHN0eWxlcz17eyBcIm1hcmdpblwiOiBcIjBcIiB9fT4oI3tzdHlsZUF0b21JZFN0cmluZ30pe3NvdXJjZS5OYW1lfTo8L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7YXBwbGllZFZhbHVlc01hcC5yZXN1bHRzLm1hcChyID0+IHIucmVuZGVyTWFxdWV0dGUoKSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgYWlkPXtzdHlsZUF0b21JZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuY3JlYXRlQ3NzUHJvcGVydHlGb3JBdG9tQ2xpY2tIYW5kbGVyfT4rPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImJcIiByb2xlPVwiYnV0dG9uXCIgYWlkPXtzdHlsZUF0b21JZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIubW92ZVN0eWxlQXRvbVBvcHVwQ2xpY2tIYW5kbGVyfT49PjwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3NvdXJjZS5Jc0RlbGV0YWJsZSA/IDxidXR0b24ga2V5PVwiYjBcIiByb2xlPVwiYnV0dG9uXCIgYWlkPXtzdHlsZUF0b21JZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuZGVsZXRlU3R5bGVBdG9tQ2xpY2tIYW5kbGVyfT5YPC9idXR0b24+IDogPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJiMVwiIHJvbGU9XCJidXR0b25cIiBhaWQ9e3N0eWxlQXRvbUlkU3RyaW5nfT5YPC9idXR0b24+fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3NvdXJjZS5NYXBwZWRRdWFudHVtcy5sZW5ndGggPiAwID8gPHAga2V5PVwiLTFcIj5xdWFudHVtczo8L3A+IDogdW5kZWZpbmVkfSB7YXBwbGllZFF1YW50dW1zTWFwLnJlc3VsdHMubWFwKHIgPT4gci5yZW5kZXJNYXF1ZXR0ZSgpKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+O1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAodXBkYXRlZFNvdXJjZTogU3R5bGVBdG9tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHVwZGF0ZWRTb3VyY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZWRWYWx1ZXNNYXAubWFwKHVwZGF0ZWRTb3VyY2UuQXBwbGllZFZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpZWRRdWFudHVtc01hcC5tYXAodXBkYXRlZFNvdXJjZS5NYXBwZWRRdWFudHVtcy5tYXAocW0gPT4gcW0uU3R5bGVRdWFudHVtKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlU2VjdGlvblRhcmdldCh1cGRhdGVkU291cmNlOiBTdHlsZUF0b20sIHRhcmdldDogeyByZW5kZXJNYXF1ZXR0ZSgpOiBhbnksIHVwZGF0ZSh1cGRhdGVkU291cmNlOiBTdHlsZUF0b20pOiB2b2lkIH0pIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC51cGRhdGUodXBkYXRlZFNvdXJjZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgbW92ZVN0eWxlQXRvbVBvcHVwQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFN0eWxlQXRvbUlkRm9yUG9wdXAgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJhaWRcIik7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZGlzcGxheVBvcHVwKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsIFBvcHVwTW9kZS5Nb3ZlU3R5bGVBdG9tKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNyZWF0ZUNzc1Byb3BlcnR5Rm9yQXRvbUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZUF0b21JZCA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImFpZFwiKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5kaXNwbGF5UG9wdXAoZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgUG9wdXBNb2RlLkFkZENzc1Byb3BlcnR5KTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5kaXNwbGF5UG9wdXAoZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgUG9wdXBNb2RlLkFsbENzc1Byb3BlcnRpZXMpOyAvLyBUT0RPIHJlbmRlciBmaXJzdCBwb3B1cCwgdGhlbiB1c2UgcmVuZGVyZCBxdWVzdGlvbiBtYXJrIGJ1dHRvbiBhcyB0YXJnZXQgKGludGVybWVkaWF0ZSBwb3B1cCBkb20pXHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBkZWxldGVTdHlsZUF0b21DbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLkRlbGV0ZVN0eWxlQXRvbUpzb24ocGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwiYWlkXCIpKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBwdWJsaWMgdXBkYXRlQ3NzVmFsdWVDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IHN0eWxlVmFsdWVJZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwidmlkXCIpO1xyXG4gICAgICAgIGxldCBzdHlsZUF0b21JZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwiYWlkXCIpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFN0eWxlVmFsdWVJZCA9IHN0eWxlVmFsdWVJZDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZUF0b21JZCA9IHN0eWxlQXRvbUlkO1xyXG4gICAgICAgIGxldCB0YXJnZXRTdHlsZVZhbHVlOiBTdHlsZVZhbHVlID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlVmFsdWVzLmZpbmQodmFsID0+IHZhbC5TdHlsZVZhbHVlSWQgPT0gc3R5bGVWYWx1ZUlkKSBhcyBTdHlsZVZhbHVlO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzVmFsdWUgPSB0YXJnZXRTdHlsZVZhbHVlLkNzc1ZhbHVlO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzUHJvcGVydHlOYW1lID0gdGFyZ2V0U3R5bGVWYWx1ZS5Dc3NQcm9wZXJ0eTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5kaXNwbGF5UG9wdXAoZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgUG9wdXBNb2RlLlVwZGF0ZUNzc1ZhbHVlKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGRlbGV0ZVN0eWxlVmFsdWVDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLkRlbGV0ZVN0eWxlVmFsdWVKc29uKHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcInZpZFwiKSkuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyQWRkQ3NzUHJvcGVydHlQb3B1cCA9ICgpOiBWTm9kZSA9PiB7XHJcbiAgICAgICAgbGV0IGlzUG9wdXBWaXNpYmxlOiBib29sZWFuID0gdGhpcy52aWV3TW9kZWwuY3VycmVudFBvcHVwTW9kZSA9PT0gUG9wdXBNb2RlLkFkZENzc1Byb3BlcnR5IHx8IHRoaXMudmlld01vZGVsLmN1cnJlbnRQb3B1cE1vZGUgPT09IFBvcHVwTW9kZS5BbGxDc3NQcm9wZXJ0aWVzO1xyXG4gICAgICAgIHJldHVybiA8ZGl2IGlkPXtgJHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5wcm9wZXJ0eUJhckluZGV4fVBvcHVwTW9kZSR7UG9wdXBNb2RlW1BvcHVwTW9kZS5BZGRDc3NQcm9wZXJ0eV19YH0gc3R5bGVzPXt7IFwiZGlzcGxheVwiOiBpc1BvcHVwVmlzaWJsZSA/IFwiYmxvY2tcIiA6IFwibm9uZVwiLCBcInotaW5kZXhcIiA6IFwiMzFcIiwgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVcIiwgXCJib3JkZXJcIjogXCJzb2xpZCBibGFjayAxcHhcIiB9fT5cclxuICAgICAgICAgICAgPGRpdiBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IFwiZmxleFwiLCBcImZsZXgtZmxvd1wiOiBcInJvdyBub3dyYXBcIiwgXCJtaW4td2lkdGhcIjogXCIyNTBweFwiIH19PlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIxIDAgMTAlXCIsIFwid2lkdGhcIjogXCIxMCVcIiwgXCJtaW4td2lkdGhcIjogXCIxMCVcIiB9fSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zYXZlQ3NzUHJvcGVydHlGb3JBdG9tQ2xpY2tIYW5kbGVyfT4mIzEwMDA0OzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJiXCIgcm9sZT1cImJ1dHRvblwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIxIDAgMTAlXCIsIFwid2lkdGhcIjogXCIxMCVcIiwgXCJtaW4td2lkdGhcIjogXCIxMCVcIiB9fSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jYW5jZWxBZGRDc3NQcm9wZXJ0eUZvckF0b21DbGlja0hhbmRsZXJ9Png8L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICA8aW5wdXQga2V5PVwiLTFcIlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1Byb3BlcnR5TmFtZX1cclxuICAgICAgICAgICAgICAgICAgICBvbmlucHV0PXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jc3NQcm9wZXJ0eU5hbWVJbnB1dEhhbmRsZXJ9PlxyXG4gICAgICAgICAgICAgICAgPC9pbnB1dD5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zaG93QWxsQ3NzUHJvcGVydGllc0NsaWNrSGFuZGxlcn0+PzwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj4gYXMgVk5vZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJBbGxDc3NQcm9wZXJ0aWVzRm9yUXVhbnR1bVBvcHVwID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICBsZXQgaXNQb3B1cFZpc2libGU6IGJvb2xlYW4gPSB0aGlzLnZpZXdNb2RlbC5jdXJyZW50UG9wdXBNb2RlID09PSBQb3B1cE1vZGUuQWxsQ3NzUHJvcGVydGllc0ZvclF1YW50dW07XHJcbiAgICAgICAgcmV0dXJuIDxkaXYgaWQ9e2Ake3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXh9UG9wdXBNb2RlJHtQb3B1cE1vZGVbUG9wdXBNb2RlLkFsbENzc1Byb3BlcnRpZXNGb3JRdWFudHVtXX1gfSBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IGlzUG9wdXBWaXNpYmxlID8gXCJibG9ja1wiIDogXCJub25lXCIsIFwiei1pbmRleFwiIDogXCIzMVwiIC8qVE9ETyBkb2N1bWVudCovLCBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLCBcImJvcmRlclwiOiBcInNvbGlkIGJsYWNrIDFweFwiLCBcImhlaWdodFwiOiBcIjMwMHB4XCIsIFwib3ZlcmZsb3dcIjogXCJzY3JvbGxcIiB9fT5cclxuICAgICAgICAgICAgPGRpdiBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IFwiZmxleFwiLCBcImZsZXgtZmxvd1wiOiBcInJvdyBub3dyYXBcIiwgXCJtaW4td2lkdGhcIjogXCIyNTBweFwiIH19PlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIxIDAgMTAlXCIsIFwid2lkdGhcIjogXCIxMCVcIiwgXCJtaW4td2lkdGhcIjogXCIxMCVcIiB9fSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jYW5jZWxVcGRhdGVDc3NQcm9wZXJ0eUZvclF1YW50dW1DbGlja0hhbmRsZXJ9Png8L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIHtjdXJyZW50QXBwLmNsaWVudERhdGEuQWxsQ3NzUHJvcGVydGllcy5tYXAoKHByb3A6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYga2V5PXtwcm9wfT5cclxuICAgICAgICAgICAgICAgICAgICB7cHJvcH08YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgY2lkPXtwcm9wfSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zZXRTZWxlY3RlZENzc1Byb3BlcnR5Rm9yUXVhbnR1bUNsaWNrSGFuZGxlcn0+JiMxMDAwNDs8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PjtcclxuICAgICAgICAgICAgfSl9XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2V0U2VsZWN0ZWRDc3NQcm9wZXJ0eUZvclF1YW50dW1DbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDc3NQcm9wZXJ0eU5hbWUgPSBwYXJzZVN0cmluZ0Zyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJjaWRcIik7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2xvc2VQb3B1cCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY2FuY2VsVXBkYXRlQ3NzUHJvcGVydHlGb3JRdWFudHVtQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmNsb3NlUG9wdXAoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGluc2VydExheW91dFJvd0ludG9WaWV3UG9wdXAgPSAoKTogVk5vZGUgPT4ge1xyXG4gICAgICAgIGxldCBpc1BvcHVwVmlzaWJsZTogYm9vbGVhbiA9IHRoaXMudmlld01vZGVsLmN1cnJlbnRQb3B1cE1vZGUgPT09IFBvcHVwTW9kZS5JbnNlcnRMYXlvdXRSb3dJbnRvVmlldztcclxuICAgICAgICBsZXQgaW5zdGFuY2VhYmxlTGF5b3V0Um93czogTGF5b3V0Um93W10gPSBbXTtcclxuICAgICAgICBpZiAoaXNQb3B1cFZpc2libGUpIHsgLy8gVE9ETyB3aWxsIGJyZWFrIHdoZW4gZGF0YSBpcyBub3Qgc3VwcGxpZWRcclxuICAgICAgICAgICAgbGV0IGluc3RhbmNlYWJsZVJvd3NWaWV3OiBDYWxpZm9ybmlhVmlldyA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5DYWxpZm9ybmlhVmlld3MuZmluZCh2aWV3ID0+IHZpZXcuSXNJbnRlcm5hbCAmJiB2aWV3Lk5hbWUgPT09IFwiW0ludGVybmFsXSBJbnN0YW5jZWFibGUgTGF5b3V0IFJvd3NcIikgYXMgQ2FsaWZvcm5pYVZpZXc7IC8vIFRPRE8gbWFnaWMgc3RyaW5nID0+IGNvbnN0IGV4cG9ydFxyXG4gICAgICAgICAgICBpbnN0YW5jZWFibGVMYXlvdXRSb3dzLnB1c2goLi4uaW5zdGFuY2VhYmxlUm93c1ZpZXcuUGxhY2VkTGF5b3V0Um93cyk7XHJcblxyXG4gICAgICAgICAgICBsZXQgdXNlckluc3RhbmNlYWJsZVJvd3NWaWV3OiBDYWxpZm9ybmlhVmlldyA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5DYWxpZm9ybmlhVmlld3MuZmluZCh2aWV3ID0+IHZpZXcuSXNJbnRlcm5hbCAmJiB2aWV3Lk5hbWUgPT09IFwiW0ludGVybmFsXSBVc2VyIExheW91dCBNb2xlY3VsZXNcIikgYXMgQ2FsaWZvcm5pYVZpZXc7IC8vIFRPRE8gbWFnaWMgc3RyaW5nID0+IGNvbnN0IGV4cG9ydFxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHVzZXJJbnN0YW5jZWFibGVSb3dzVmlldy5QbGFjZWRMYXlvdXRSb3dzLmxlbmd0aDsgaSsrKSB7IC8vIHNraXAgYm94IGhvbGRlclxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VhYmxlTGF5b3V0Um93cy5wdXNoKHVzZXJJbnN0YW5jZWFibGVSb3dzVmlldy5QbGFjZWRMYXlvdXRSb3dzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gPGRpdiBpZD17YCR7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucHJvcGVydHlCYXJJbmRleH1Qb3B1cE1vZGUke1BvcHVwTW9kZVtQb3B1cE1vZGUuSW5zZXJ0TGF5b3V0Um93SW50b1ZpZXddfWB9IHN0eWxlcz17eyBcImRpc3BsYXlcIjogaXNQb3B1cFZpc2libGUgPyBcImJsb2NrXCIgOiBcIm5vbmVcIiwgXCJ6LWluZGV4XCIgOiBcIjMxXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsIFwiYm9yZGVyXCI6IFwic29saWQgYmxhY2sgMXB4XCIsIFwiaGVpZ2h0XCI6IFwiMzAwcHhcIiwgXCJvdmVyZmxvd1wiOiBcInNjcm9sbFwiIH19PlxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlcz17eyBcImRpc3BsYXlcIjogXCJmbGV4XCIsIFwiZmxleC1mbG93XCI6IFwicm93IG5vd3JhcFwiLCBcIm1pbi13aWR0aFwiOiBcIjI1MHB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgc3R5bGVzPXt7IFwiZmxleFwiOiBcIjEgMCAxMCVcIiwgXCJ3aWR0aFwiOiBcIjEwJVwiLCBcIm1pbi13aWR0aFwiOiBcIjEwJVwiIH19IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmNhbmNlbEluc2VydExheW91dFJvd0ludG9WaWV3Q2xpY2tIYW5kbGVyfT54PC9idXR0b24+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICB7aW5zdGFuY2VhYmxlTGF5b3V0Um93cy5tYXAoKHByb3A6IExheW91dFJvdykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYga2V5PXtwcm9wLkxheW91dEJhc2VJZH0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBzdHlsZXM9e3sgXCJ3aWR0aFwiOiBcImF1dG9cIiwgXCJtYXJnaW5cIjogXCIwXCIgfX0ga2V5PVwiYVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpZD17cHJvcC5MYXlvdXRCYXNlSWQudG9TdHJpbmcoKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaW5zZXJ0U2VsZWN0ZWRMYXlvdXRSb3dJbnRvVmlld0NsaWNrSGFuZGxlcn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25tb3VzZWVudGVyPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pbnNlcnRSb3dTaG93UHJldmlld0hhbmRsZXJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ubW91c2VsZWF2ZT17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaW5zZXJ0Um93SGlkZVByZXZpZXdIYW5kbGVyfT4mIzEwMDA0O1xyXG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDxwIGtleT1cIjBcIiBzdHlsZXM9e3sgXCItd2Via2l0LXVzZXItc2VsZWN0XCI6IFwibm9uZVwiLCBcIndpZHRoXCI6IFwiYXV0b1wiLCBcIm1hcmdpblwiOiBcIjBcIiwgXCJmbG9hdFwiOiBcImxlZnRcIiB9fSBsaWQ9e3Byb3AuTGF5b3V0QmFzZUlkLnRvU3RyaW5nKCl9IG9udG91Y2hzdGFydD17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaW5zZXJ0Um93U2hvd1ByZXZpZXdIYW5kbGVyfSBvbnRvdWNoZW5kPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pbnNlcnRSb3dIaWRlUHJldmlld0hhbmRsZXJ9Pntwcm9wLkxheW91dEJhc2VJZH08L3A+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj47XHJcbiAgICAgICAgICAgIH0pfVxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGluc2VydFNlbGVjdGVkTGF5b3V0Um93SW50b1ZpZXdDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IGxheW91dElkOiBudW1iZXIgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJsaWRcIik7XHJcbiAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLkNyZWF0ZUxheW91dFJvd0ZvclZpZXdKc29uKHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZENhbGlmb3JuaWFWaWV3SWQsIGxheW91dElkKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5sYXN0Q29tbWFuZCA9IENhbGlmb3JuaWFFdmVudC5DcmVhdGVMYXlvdXRSb3dGb3JWaWV3O1xyXG4gICAgICAgIGN1cnJlbnRBcHAuc3RhdGUubGFzdENhbGlmb3JuaWFFdmVudERhdGEgPSBbdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkQ2FsaWZvcm5pYVZpZXdJZCwgbGF5b3V0SWRdO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmNsb3NlUG9wdXAoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNhbmNlbEluc2VydExheW91dFJvd0ludG9WaWV3Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmNsb3NlUG9wdXAoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGluc2VydExheW91dEF0b21JbnRvQm94UG9wdXAgPSAoKTogVk5vZGUgPT4ge1xyXG4gICAgICAgIGxldCBpc1BvcHVwVmlzaWJsZTogYm9vbGVhbiA9IHRoaXMudmlld01vZGVsLmN1cnJlbnRQb3B1cE1vZGUgPT09IFBvcHVwTW9kZS5JbnNlcnRMYXlvdXRBdG9tSW50b0JveDtcclxuICAgICAgICBsZXQgaW5zdGFuY2VhYmxlTGF5b3V0QXRvbXM6IExheW91dEF0b21bXSA9IFtdO1xyXG4gICAgICAgIGlmIChpc1BvcHVwVmlzaWJsZSkgeyAvLyBUT0RPIHdpbGwgYnJlYWsgd2hlbiBkYXRhIGlzIG5vdCBzdXBwbGllZFxyXG4gICAgICAgICAgICBsZXQgaW5zdGFuY2VhYmxlQXRvbXNWaWV3OiBDYWxpZm9ybmlhVmlldyA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5DYWxpZm9ybmlhVmlld3MuZmluZCh2aWV3ID0+IHZpZXcuSXNJbnRlcm5hbCAmJiB2aWV3Lk5hbWUgPT09IFwiW0ludGVybmFsXSBJbnN0YW5jZWFibGUgTGF5b3V0IEF0b21zXCIpIGFzIENhbGlmb3JuaWFWaWV3OyAvLyBUT0RPIG1hZ2ljIHN0cmluZyA9PiBjb25zdCBleHBvcnRcclxuICAgICAgICAgICAgbGV0IGF0b21Db250YWluZXJCb3g6IExheW91dEJveCA9IGluc3RhbmNlYWJsZUF0b21zVmlldy5QbGFjZWRMYXlvdXRSb3dzWzBdLkFsbEJveGVzQmVsb3dSb3cuZmluZChiID0+IGIuUGxhY2VkSW5Cb3hBdG9tcy5sZW5ndGggPiAwKSBhcyBMYXlvdXRCb3g7XHJcbiAgICAgICAgICAgIGluc3RhbmNlYWJsZUxheW91dEF0b21zLnB1c2goLi4uYXRvbUNvbnRhaW5lckJveC5QbGFjZWRJbkJveEF0b21zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDxkaXYgaWQ9e2Ake3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXh9UG9wdXBNb2RlJHtQb3B1cE1vZGVbUG9wdXBNb2RlLkluc2VydExheW91dEF0b21JbnRvQm94XX1gfSBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IGlzUG9wdXBWaXNpYmxlID8gXCJibG9ja1wiIDogXCJub25lXCIsIFwiei1pbmRleFwiIDogXCIzMVwiLCBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLCBcImJvcmRlclwiOiBcInNvbGlkIGJsYWNrIDFweFwiLCBcImhlaWdodFwiOiBcIjMwMHB4XCIsIFwib3ZlcmZsb3dcIjogXCJzY3JvbGxcIiB9fT5cclxuICAgICAgICAgICAgPGRpdiBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IFwiZmxleFwiLCBcImZsZXgtZmxvd1wiOiBcInJvdyBub3dyYXBcIiwgXCJtaW4td2lkdGhcIjogXCIyNTBweFwiIH19PlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIxIDAgMTAlXCIsIFwid2lkdGhcIjogXCIxMCVcIiwgXCJtaW4td2lkdGhcIjogXCIxMCVcIiB9fSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jYW5jZWxJbnNlcnRMYXlvdXRBdG9tSW50b0JveENsaWNrSGFuZGxlcn0+eDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAge2luc3RhbmNlYWJsZUxheW91dEF0b21zLm1hcCgocHJvcDogTGF5b3V0QXRvbSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRleHRQcmV2aWV3OiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3AuSG9zdGVkQ29udGVudEF0b20uQ29udGVudEF0b21UeXBlID09PSBDb250ZW50QXRvbVR5cGUuVGV4dCkgeyAvLyBUT0RPIGNvZGUgZHVwbGljYXRpb24gZm9yIGNvbnRlbnQgc2VsZWN0aW9uIGF0IG11bHRpcGxlIHBsYWNlc1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRQcmV2aWV3ID0gcHJvcC5Ib3N0ZWRDb250ZW50QXRvbS5UZXh0Q29udGVudCBhcyBzdHJpbmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wLkhvc3RlZENvbnRlbnRBdG9tLkNvbnRlbnRBdG9tVHlwZSA9PT0gQ29udGVudEF0b21UeXBlLkxpbmspIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0UHJldmlldyA9IHByb3AuSG9zdGVkQ29udGVudEF0b20uVXJsIGFzIHN0cmluZztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPGRpdiBrZXk9e3Byb3AuTGF5b3V0QmFzZUlkfT5cclxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHN0eWxlcz17eyBcIndpZHRoXCI6IFwiYXV0b1wiLCBcIm1hcmdpblwiOiBcIjBcIiB9fSBrZXk9XCJhXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlkPXtwcm9wLkxheW91dEJhc2VJZC50b1N0cmluZygpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pbnNlcnRTZWxlY3RlZExheW91dEF0b21JbnRvQm94Q2xpY2tIYW5kbGVyfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbm1vdXNlZW50ZXI9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmluc2VydEF0b21TaG93UHJldmlld0hhbmRsZXJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ubW91c2VsZWF2ZT17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaW5zZXJ0QXRvbUhpZGVQcmV2aWV3SGFuZGxlcn0+JiMxMDAwNDtcclxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICA8cCBrZXk9XCIwXCIgc3R5bGVzPXt7IFwiLXdlYmtpdC11c2VyLXNlbGVjdFwiOiBcIm5vbmVcIiwgXCJ3aWR0aFwiOiBcImF1dG9cIiwgXCJtYXJnaW5cIjogXCIwXCIsIFwiZmxvYXRcIjogXCJsZWZ0XCIgfX0gbGlkPXtwcm9wLkxheW91dEJhc2VJZC50b1N0cmluZygpfSBvbnRvdWNoc3RhcnQ9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmluc2VydEF0b21TaG93UHJldmlld0hhbmRsZXJ9IG9udG91Y2hlbmQ9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmluc2VydEF0b21IaWRlUHJldmlld0hhbmRsZXJ9Pntwcm9wLkxheW91dEJhc2VJZH0ge3RleHRQcmV2aWV3fTwvcD5cclxuICAgICAgICAgICAgICAgIDwvZGl2PjtcclxuICAgICAgICAgICAgfSl9XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgaW5zZXJ0U2VsZWN0ZWRMYXlvdXRBdG9tSW50b0JveENsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgdGFyZ2V0Qm94SWQ6IG51bWJlciA9IGN1cnJlbnRBcHAuc3RhdGUuc2VsZWN0ZWRMYXlvdXRCYXNlSWQ7XHJcbiAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLkNyZWF0ZUxheW91dEF0b21Gb3JCb3hKc29uKHRhcmdldEJveElkLCBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJsaWRcIikpLmRvbmUoZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAucHJvamVjdG9yLnJlbmRlck5vdygpOyAvLyBUT0RPXHJcbiAgICAgICAgICAgIGxldCB1cGRhdGVkU3ViQXRvbXM6IExheW91dEF0b21bXSA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuTGF5b3V0TW9sZWN1bGVzLmZpbmQobCA9PiBsLkxheW91dEJhc2VJZCA9PSB0YXJnZXRCb3hJZCkgYXMgTGF5b3V0Qm94KS5QbGFjZWRJbkJveEF0b21zO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuZWRpdGVkTGF5b3V0QXRvbUlkID0gdXBkYXRlZFN1YkF0b21zW3VwZGF0ZWRTdWJBdG9tcy5sZW5ndGggLSAxXS5MYXlvdXRCYXNlSWQ7IC8vIFRPRE8ganVzdCBndWVzc2luZywgc2F2ZSBhbGwgZXhpc3RpbmcgYW5kIGNvbXBhcmUgdG8gYWxsIG5ldyBmb3Igc2FmZSB2YXJpYW50XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2xvc2VQb3B1cCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY2FuY2VsSW5zZXJ0TGF5b3V0QXRvbUludG9Cb3hDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2xvc2VQb3B1cCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgZGlzcGxheVBvcHVwID0gKHRhcmdldFBvc2l0aW9uOiBIVE1MRWxlbWVudCwgcG9wdXBNb2RlOiBQb3B1cE1vZGUpID0+IHtcclxuICAgICAgICAvKmlmIChDYWxpZm9ybmlhQXBwLkNhbGlmb3JuaWFBcHBJbnN0YW5jZS5zdGF0ZS5jdXJyZW50UG9wdXBNb2RlICE9PSBQb3B1cE1vZGUuTm9uZSkgeyBUT0RPXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9Ki9cclxuICAgICAgICBsZXQgcG9wdXBFbGVtZW50OiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xyXG4gICAgICAgIHBvcHVwRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGAke3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXh9UG9wdXBNb2RlJHtQb3B1cE1vZGVbcG9wdXBNb2RlXX1gKSBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICBpZiAocG9wdXBFbGVtZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmN1cnJlbnRQb3B1cE1vZGUgPSBwb3B1cE1vZGU7XHJcbiAgICAgICAgICAgIHZhciBkaXNwbGF5UG9wdXAgPSBuZXcgcG9wcGVyanMuZGVmYXVsdCh0YXJnZXRQb3NpdGlvbiwgcG9wdXBFbGVtZW50LCB7XHJcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20tZW5kJyxcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVyczoge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qZmxpcDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWhhdmlvcjogWydsZWZ0JywgJ2JvdHRvbScsICd0b3AnXVxyXG4gICAgICAgICAgICAgICAgICAgIH0sKi9cclxuICAgICAgICAgICAgICAgICAgICBwcmV2ZW50T3ZlcmZsb3c6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm91bmRhcmllc0VsZW1lbnQ6IGRvY3VtZW50LmJvZHksXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vZG9jdW1lbnQuYm9keS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInJnYigyNDUsIDI0NSwgMjQ1KVwiOyBUT0RPXHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAucHJvamVjdG9yLnJlbmRlck5vdygpOyAvLyByZXF1aXJlZCB0byB1cGRhdGUgcG9wdXAgcG9zaXRpb24gdG8gYmUgY29udGFpbmVkIGJ5IGJvdW5kYXJpZXMgZWxlbWVudFxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNsb3NlUG9wdXAgPSAoKSA9PiB7XHJcbiAgICAgICAgLy9kb2N1bWVudC5ib2R5LnN0eWxlLmJhY2tncm91bmQgPSBcIndoaXRlXCI7IFRPRE9cclxuICAgICAgICB0aGlzLnZpZXdNb2RlbC5jdXJyZW50UG9wdXBNb2RlID0gUG9wdXBNb2RlLk5vbmU7XHJcbiAgICAgICAgdGhpcy52aWV3TW9kZWwuY3VycmVudFNlY29uZGFyeVBvcHVwTW9kZSA9IFBvcHVwU2Vjb25kYXJ5TW9kZS5Ob25lO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgaW5zZXJ0TGF5b3V0Qm94SW50b0JveFBvcHVwID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICBsZXQgaXNQb3B1cFZpc2libGU6IGJvb2xlYW4gPSB0aGlzLnZpZXdNb2RlbC5jdXJyZW50UG9wdXBNb2RlID09PSBQb3B1cE1vZGUuU2VsZWN0Qm94O1xyXG4gICAgICAgIGxldCBpbnN0YW5jZWFibGVMYXlvdXRCb3hlczogTGF5b3V0Qm94W10gPSBbXTtcclxuICAgICAgICBpZiAoaXNQb3B1cFZpc2libGUpIHsgLy8gVE9ETyB3aWxsIGJyZWFrIHdoZW4gZGF0YSBpcyBub3Qgc3VwcGxpZWRcclxuICAgICAgICAgICAgbGV0IGluc3RhbmNlYWJsZVJvd3NWaWV3OiBDYWxpZm9ybmlhVmlldyA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5DYWxpZm9ybmlhVmlld3MuZmluZCh2aWV3ID0+IHZpZXcuSXNJbnRlcm5hbCAmJiB2aWV3Lk5hbWUgPT09IFwiW0ludGVybmFsXSBJbnN0YW5jZWFibGUgTGF5b3V0IFJvd3NcIikgYXMgQ2FsaWZvcm5pYVZpZXc7IC8vIFRPRE8gbWFnaWMgc3RyaW5nID0+IGNvbnN0IGV4cG9ydFxyXG4gICAgICAgICAgICBsZXQgYWxsQm94ZXM6IExheW91dEJveFtdID0gaW5zdGFuY2VhYmxlUm93c1ZpZXcuUGxhY2VkTGF5b3V0Um93c1swXS5BbGxCb3hlc0JlbG93Um93O1xyXG4gICAgICAgICAgICBsZXQgZmlyc3RTdWJCb3g6IExheW91dEJveCA9IGFsbEJveGVzLmZpbmQoYiA9PiBiLlBsYWNlZEJveEluQm94SWQgPT09IHVuZGVmaW5lZCkgYXMgTGF5b3V0Qm94O1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0Qm94OiBMYXlvdXRCb3ggPSBhbGxCb3hlcy5maW5kKGIgPT4gYi5QbGFjZWRCb3hJbkJveElkID09IGZpcnN0U3ViQm94LkxheW91dEJhc2VJZCkgYXMgTGF5b3V0Qm94O1xyXG4gICAgICAgICAgICBpbnN0YW5jZWFibGVMYXlvdXRCb3hlcy5wdXNoKHRhcmdldEJveCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgdXNlckluc3RhbmNlYWJsZVZpZXc6IENhbGlmb3JuaWFWaWV3ID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFWaWV3cy5maW5kKHZpZXcgPT4gdmlldy5Jc0ludGVybmFsICYmIHZpZXcuTmFtZSA9PT0gXCJbSW50ZXJuYWxdIFVzZXIgTGF5b3V0IE1vbGVjdWxlc1wiKSBhcyBDYWxpZm9ybmlhVmlldzsgLy8gVE9ETyBtYWdpYyBzdHJpbmcgPT4gY29uc3QgZXhwb3J0XHJcbiAgICAgICAgICAgIGxldCB1c2VyQm94ZXM6IExheW91dEJveFtdID0gdXNlckluc3RhbmNlYWJsZVZpZXcuUGxhY2VkTGF5b3V0Um93c1swXS5BbGxCb3hlc0JlbG93Um93LmZpbHRlcihiID0+IGIuUGxhY2VkQm94SW5Cb3hJZCA9PT0gdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgaW5zdGFuY2VhYmxlTGF5b3V0Qm94ZXMucHVzaCguLi51c2VyQm94ZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gPGRpdiBpZD17YCR7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucHJvcGVydHlCYXJJbmRleH1Qb3B1cE1vZGUke1BvcHVwTW9kZVtQb3B1cE1vZGUuU2VsZWN0Qm94XX1gfSBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IGlzUG9wdXBWaXNpYmxlID8gXCJibG9ja1wiIDogXCJub25lXCIsIFwiei1pbmRleFwiIDogXCIzMVwiLCBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLCBcImJvcmRlclwiOiBcInNvbGlkIGJsYWNrIDFweFwiLCBcImhlaWdodFwiOiBcIjMwMHB4XCIsIFwib3ZlcmZsb3dcIjogXCJzY3JvbGxcIiB9fT5cclxuICAgICAgICAgICAgPGRpdiBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IFwiZmxleFwiLCBcImZsZXgtZmxvd1wiOiBcInJvdyBub3dyYXBcIiwgXCJtaW4td2lkdGhcIjogXCIyNTBweFwiIH19PlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIxIDAgMTAlXCIsIFwid2lkdGhcIjogXCIxMCVcIiwgXCJtaW4td2lkdGhcIjogXCIxMCVcIiB9fSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jYW5jZWxJbnNlcnRMYXlvdXRCb3hJbnRvQm94Q2xpY2tIYW5kbGVyfT54PC9idXR0b24+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICB7aW5zdGFuY2VhYmxlTGF5b3V0Qm94ZXMubWFwKChwcm9wOiBMYXlvdXRCb3gpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17cHJvcC5MYXlvdXRCYXNlSWR9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gc3R5bGVzPXt7IFwid2lkdGhcIjogXCJhdXRvXCIsIFwibWFyZ2luXCI6IFwiMFwiIH19XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleT1cImFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlkPXtwcm9wLkxheW91dEJhc2VJZC50b1N0cmluZygpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pbnNlcnRTZWxlY3RlZExheW91dEJveEludG9Cb3hPclJvd0NsaWNrSGFuZGxlcn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25tb3VzZWVudGVyPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pbnNlcnRCb3hTaG93UHJldmlld0hhbmRsZXJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ubW91c2VsZWF2ZT17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaW5zZXJ0Qm94SGlkZVByZXZpZXdIYW5kbGVyfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgJiMxMDAwNDtcclxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICA8cCBrZXk9XCIwXCIgc3R5bGVzPXt7IFwiLXdlYmtpdC11c2VyLXNlbGVjdFwiOiBcIm5vbmVcIiwgXCJ3aWR0aFwiOiBcImF1dG9cIiwgXCJtYXJnaW5cIjogXCIwXCIsIFwiZmxvYXRcIjogXCJsZWZ0XCIgfX0gbGlkPXtwcm9wLkxheW91dEJhc2VJZC50b1N0cmluZygpfSBvbnRvdWNoc3RhcnQ9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmluc2VydEJveFNob3dQcmV2aWV3SGFuZGxlcn0gb250b3VjaGVuZD17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaW5zZXJ0Qm94SGlkZVByZXZpZXdIYW5kbGVyfT57cHJvcC5MYXlvdXRCYXNlSWR9PC9wPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+O1xyXG4gICAgICAgICAgICB9KX1cclxuICAgICAgICA8L2Rpdj4gYXMgVk5vZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgaW5zZXJ0Um93U2hvd1ByZXZpZXdIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpID0+IHsgLy8gVE9ETyBjb2RlIGR1cGxpY2F0aW9uXHJcbiAgICAgICAgbGV0IHRhcmdldEVsZW1lbnQ6IEhUTUxFbGVtZW50ID0gZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICBsZXQgaG92ZXJlZExheW91dElkOiBudW1iZXIgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUodGFyZ2V0RWxlbWVudCwgXCJsaWRcIik7XHJcbiAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5ob3ZlcmVkSW5zZXJ0TGF5b3V0QmFzZUlkID0gaG92ZXJlZExheW91dElkO1xyXG4gICAgICAgIGxldCB0ZW1wUm93OiBMYXlvdXRSb3cgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuTGF5b3V0TW9sZWN1bGVzLmZpbmQobCA9PiBsLkxheW91dEJhc2VJZCA9PSBob3ZlcmVkTGF5b3V0SWQpIGFzIExheW91dFJvdztcclxuICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmJhY2t1cFNvcnRPcmRlciA9IHRlbXBSb3cuTGF5b3V0U29ydE9yZGVyS2V5O1xyXG4gICAgICAgIHRlbXBSb3cuTGF5b3V0U29ydE9yZGVyS2V5ID0gVkVSWV9ISUdIX1ZBTFVFOyAvLyBUT0RPIHZlcnkgaGlnaCB2YWx1ZVxyXG4gICAgICAgIGxldCBjYWxpZm9ybmlhVmlldzogQ2FsaWZvcm5pYVZpZXcgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ2FsaWZvcm5pYVZpZXdzLmZpbmQodiA9PiB2LkNhbGlmb3JuaWFWaWV3SWQgPT0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkQ2FsaWZvcm5pYVZpZXdJZCkgYXMgQ2FsaWZvcm5pYVZpZXc7XHJcbiAgICAgICAgY2FsaWZvcm5pYVZpZXcuUGxhY2VkTGF5b3V0Um93cy5wdXNoKHRlbXBSb3cpO1xyXG4gICAgICAgIGN1cnJlbnRBcHAucm91dGVyLnNldEFjdGl2ZUNhbGlmb3JuaWFWaWV3KGNhbGlmb3JuaWFWaWV3KTtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBpbnNlcnRSb3dIaWRlUHJldmlld0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkgPT4geyAvLyBUT0RPIGNvZGUgZHVwbGljYXRpb25cclxuICAgICAgICBsZXQgY2FsaWZvcm5pYVZpZXc6IENhbGlmb3JuaWFWaWV3ID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFWaWV3cy5maW5kKHYgPT4gdi5DYWxpZm9ybmlhVmlld0lkID09IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZENhbGlmb3JuaWFWaWV3SWQpIGFzIENhbGlmb3JuaWFWaWV3O1xyXG4gICAgICAgIGxldCB0ZW1wUm93SW5kZXg6IG51bWJlciA9IGNhbGlmb3JuaWFWaWV3LlBsYWNlZExheW91dFJvd3MuZmluZEluZGV4KHIgPT4gci5MYXlvdXRCYXNlSWQgPT0gY3VycmVudEFwcC5zdGF0ZS5ob3ZlcmVkSW5zZXJ0TGF5b3V0QmFzZUlkKTtcclxuICAgICAgICBpZiAodGVtcFJvd0luZGV4ICE9IC0xKSB7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wUm93OiBMYXlvdXRSb3cgPSBjYWxpZm9ybmlhVmlldy5QbGFjZWRMYXlvdXRSb3dzLnNwbGljZSh0ZW1wUm93SW5kZXgsIDEpWzBdO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5iYWNrdXBTb3J0T3JkZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGVtcFJvdy5MYXlvdXRTb3J0T3JkZXJLZXkgPSBjdXJyZW50QXBwLnN0YXRlLmJhY2t1cFNvcnRPcmRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmJhY2t1cFNvcnRPcmRlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5ob3ZlcmVkSW5zZXJ0TGF5b3V0QmFzZUlkID0gMDtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5yb3V0ZXIuc2V0QWN0aXZlQ2FsaWZvcm5pYVZpZXcoY2FsaWZvcm5pYVZpZXcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBpbnNlcnRCb3hTaG93UHJldmlld0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkgPT4geyAvLyBUT0RPIGNvZGUgZHVwbGljYXRpb25cclxuICAgICAgICAvLyBUT0RPIHRlc3QgLyBjaGVjayBpcyBpdCBuZWNlc3NhcnkgdG8gYWRkIHN1YmJveCByZWZlcmVuY2VzIHRvIHBhcmVudFJvdz0+YWxsQm94ZXNCZWxvd1JvdyBmb3IgdGhpcyB0ZW1wb3JhcnkgdXBkYXRlP1xyXG4gICAgICAgIGxldCB0YXJnZXRFbGVtZW50OiBIVE1MRWxlbWVudCA9IGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgbGV0IGhvdmVyZWRMYXlvdXRJZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKHRhcmdldEVsZW1lbnQsIFwibGlkXCIpO1xyXG4gICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuaG92ZXJlZEluc2VydExheW91dEJhc2VJZCA9IGhvdmVyZWRMYXlvdXRJZDtcclxuICAgICAgICBsZXQgdGVtcEJveDogTGF5b3V0Qm94ID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkxheW91dE1vbGVjdWxlcy5maW5kKGwgPT4gbC5MYXlvdXRCYXNlSWQgPT0gaG92ZXJlZExheW91dElkKSBhcyBMYXlvdXRCb3g7XHJcbiAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5iYWNrdXBTb3J0T3JkZXIgPSB0ZW1wQm94LkxheW91dFNvcnRPcmRlcktleTtcclxuICAgICAgICB0ZW1wQm94LkxheW91dFNvcnRPcmRlcktleSA9IFZFUllfSElHSF9WQUxVRTsgLy8gVE9ETyB2ZXJ5IGhpZ2ggdmFsdWVcclxuICAgICAgICBsZXQgc2VsZWN0ZWRCb3hPclJvdzogTGF5b3V0QmFzZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5MYXlvdXRNb2xlY3VsZXMuZmluZChsID0+IGwuTGF5b3V0QmFzZUlkID09IGN1cnJlbnRBcHAuc3RhdGUuc2VsZWN0ZWRMYXlvdXRCYXNlSWQpIGFzIExheW91dEJhc2U7XHJcbiAgICAgICAgaWYgKHNlbGVjdGVkQm94T3JSb3cuTGF5b3V0VHlwZSA9PT0gTGF5b3V0VHlwZS5Cb3gpIHtcclxuICAgICAgICAgICAgKHNlbGVjdGVkQm94T3JSb3cgYXMgTGF5b3V0Qm94KS5QbGFjZWRJbkJveEJveGVzLnB1c2godGVtcEJveCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdGVkQm94T3JSb3cuTGF5b3V0VHlwZSA9PT0gTGF5b3V0VHlwZS5Sb3cpIHtcclxuICAgICAgICAgICAgKHNlbGVjdGVkQm94T3JSb3cgYXMgTGF5b3V0Um93KS5BbGxCb3hlc0JlbG93Um93LnB1c2godGVtcEJveCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIGluc2VydEJveEhpZGVQcmV2aWV3SGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSA9PiB7IC8vIFRPRE8gY29kZSBkdXBsaWNhdGlvblxyXG4gICAgICAgIGxldCBzZWxlY3RlZEJveE9yUm93OiBMYXlvdXRCYXNlID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkxheW91dE1vbGVjdWxlcy5maW5kKGwgPT4gbC5MYXlvdXRCYXNlSWQgPT0gY3VycmVudEFwcC5zdGF0ZS5zZWxlY3RlZExheW91dEJhc2VJZCkgYXMgTGF5b3V0QmFzZTtcclxuICAgICAgICBpZiAoc2VsZWN0ZWRCb3hPclJvdy5MYXlvdXRUeXBlID09PSBMYXlvdXRUeXBlLkJveCkge1xyXG4gICAgICAgICAgICBsZXQgbGF5b3V0Qm94OiBMYXlvdXRCb3ggPSBzZWxlY3RlZEJveE9yUm93IGFzIExheW91dEJveDtcclxuICAgICAgICAgICAgbGV0IHRlbXBCb3hJbmRleDogbnVtYmVyID0gbGF5b3V0Qm94LlBsYWNlZEluQm94Qm94ZXMuZmluZEluZGV4KGIgPT4gYi5MYXlvdXRCYXNlSWQgPT0gY3VycmVudEFwcC5zdGF0ZS5ob3ZlcmVkSW5zZXJ0TGF5b3V0QmFzZUlkKTtcclxuICAgICAgICAgICAgaWYgKHRlbXBCb3hJbmRleCAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRlbXBCb3g6IExheW91dEJveCA9IGxheW91dEJveC5QbGFjZWRJbkJveEJveGVzLnNwbGljZSh0ZW1wQm94SW5kZXgsIDEpWzBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUuYmFja3VwU29ydE9yZGVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wQm94LkxheW91dFNvcnRPcmRlcktleSA9IGN1cnJlbnRBcHAuc3RhdGUuYmFja3VwU29ydE9yZGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5iYWNrdXBTb3J0T3JkZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmhvdmVyZWRJbnNlcnRMYXlvdXRCYXNlSWQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdGVkQm94T3JSb3cuTGF5b3V0VHlwZSA9PT0gTGF5b3V0VHlwZS5Sb3cpIHtcclxuICAgICAgICAgICAgbGV0IGxheW91dFJvdzogTGF5b3V0Um93ID0gc2VsZWN0ZWRCb3hPclJvdyBhcyBMYXlvdXRSb3c7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wQm94SW5kZXg6IG51bWJlciA9IGxheW91dFJvdy5BbGxCb3hlc0JlbG93Um93LmZpbmRJbmRleChiID0+IGIuTGF5b3V0QmFzZUlkID09IGN1cnJlbnRBcHAuc3RhdGUuaG92ZXJlZEluc2VydExheW91dEJhc2VJZCk7XHJcbiAgICAgICAgICAgIGlmICh0ZW1wQm94SW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGxldCB0ZW1wQm94OiBMYXlvdXRCb3ggPSBsYXlvdXRSb3cuQWxsQm94ZXNCZWxvd1Jvdy5zcGxpY2UodGVtcEJveEluZGV4LCAxKVswXTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLmJhY2t1cFNvcnRPcmRlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcEJveC5MYXlvdXRTb3J0T3JkZXJLZXkgPSBjdXJyZW50QXBwLnN0YXRlLmJhY2t1cFNvcnRPcmRlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuYmFja3VwU29ydE9yZGVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5ob3ZlcmVkSW5zZXJ0TGF5b3V0QmFzZUlkID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBpbnNlcnRBdG9tU2hvd1ByZXZpZXdIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQpID0+IHsgLy8gVE9ETyBjb2RlIGR1cGxpY2F0aW9uXHJcbiAgICAgICAgLy8gVE9ETyBldmVyeXdoZXJlIG1ha2UgdXNlIG9mIGludDggYW5kIGZpeCBlbnVtL2Jvb2wgdG8gaW50MzIgZGVmYXVsdCBjb2VyY2lvbnNcclxuICAgICAgICBsZXQgdGFyZ2V0RWxlbWVudDogSFRNTEVsZW1lbnQgPSBldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgIGxldCBob3ZlcmVkTGF5b3V0SWQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZSh0YXJnZXRFbGVtZW50LCBcImxpZFwiKTtcclxuICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmhvdmVyZWRJbnNlcnRMYXlvdXRCYXNlSWQgPSBob3ZlcmVkTGF5b3V0SWQ7XHJcbiAgICAgICAgbGV0IHRlbXBBdG9tOiBMYXlvdXRBdG9tID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkxheW91dE1vbGVjdWxlcy5maW5kKGwgPT4gbC5MYXlvdXRCYXNlSWQgPT0gaG92ZXJlZExheW91dElkKSBhcyBMYXlvdXRBdG9tO1xyXG4gICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuYmFja3VwU29ydE9yZGVyID0gdGVtcEF0b20uTGF5b3V0U29ydE9yZGVyS2V5O1xyXG4gICAgICAgIHRlbXBBdG9tLkxheW91dFNvcnRPcmRlcktleSA9IFZFUllfSElHSF9WQUxVRTsgLy8gVE9ETyB2ZXJ5IGhpZ2ggdmFsdWVcclxuICAgICAgICBsZXQgbGF5b3V0Qm94OiBMYXlvdXRCb3ggPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuTGF5b3V0TW9sZWN1bGVzLmZpbmQobCA9PiBsLkxheW91dEJhc2VJZCA9PSBjdXJyZW50QXBwLnN0YXRlLnNlbGVjdGVkTGF5b3V0QmFzZUlkKSBhcyBMYXlvdXRCb3g7XHJcbiAgICAgICAgbGF5b3V0Qm94LlBsYWNlZEluQm94QXRvbXMucHVzaCh0ZW1wQXRvbSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgaW5zZXJ0QXRvbUhpZGVQcmV2aWV3SGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSA9PiB7IC8vIFRPRE8gY29kZSBkdXBsaWNhdGlvblxyXG4gICAgICAgIGxldCBsYXlvdXRCb3g6IExheW91dEJveCA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5MYXlvdXRNb2xlY3VsZXMuZmluZChsID0+IGwuTGF5b3V0QmFzZUlkID09IGN1cnJlbnRBcHAuc3RhdGUuc2VsZWN0ZWRMYXlvdXRCYXNlSWQpIGFzIExheW91dEJveDtcclxuICAgICAgICBsZXQgdGVtcEF0b21JbmRleDogbnVtYmVyID0gbGF5b3V0Qm94LlBsYWNlZEluQm94QXRvbXMuZmluZEluZGV4KGEgPT4gYS5MYXlvdXRCYXNlSWQgPT0gY3VycmVudEFwcC5zdGF0ZS5ob3ZlcmVkSW5zZXJ0TGF5b3V0QmFzZUlkKTtcclxuICAgICAgICBpZiAodGVtcEF0b21JbmRleCAhPSAtMSkge1xyXG4gICAgICAgICAgICBsZXQgdGVtcEF0b206IExheW91dEF0b20gPSBsYXlvdXRCb3guUGxhY2VkSW5Cb3hBdG9tcy5zcGxpY2UodGVtcEF0b21JbmRleCwgMSlbMF07XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLmJhY2t1cFNvcnRPcmRlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wQXRvbS5MYXlvdXRTb3J0T3JkZXJLZXkgPSBjdXJyZW50QXBwLnN0YXRlLmJhY2t1cFNvcnRPcmRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmJhY2t1cFNvcnRPcmRlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5ob3ZlcmVkSW5zZXJ0TGF5b3V0QmFzZUlkID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBpbnNlcnRTZWxlY3RlZExheW91dEJveEludG9Cb3hPclJvd0NsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAvLyBUT0RPIGRvY3VtZW50IHBvcHVwIGlzIHJldXNlZFxyXG4gICAgICAgIGlmICh0aGlzLnZpZXdNb2RlbC5jdXJyZW50U2Vjb25kYXJ5UG9wdXBNb2RlID09PSBQb3B1cFNlY29uZGFyeU1vZGUuU2VsZWN0Qm94SW50b0JveCkge1xyXG4gICAgICAgICAgICBsZXQgbGF5b3V0SWQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImxpZFwiKTtcclxuICAgICAgICAgICAgbGV0IHRhcmdldExheW91dElkOiBudW1iZXIgPSBjdXJyZW50QXBwLnN0YXRlLnNlbGVjdGVkTGF5b3V0QmFzZUlkO1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuQ3JlYXRlTGF5b3V0Qm94Rm9yQm94T3JSb3dKc29uKHRhcmdldExheW91dElkLCBsYXlvdXRJZCkuZG9uZShkYXRhID0+IHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGZvY3VzIGxhc3QgYXRvbSBpZiBvbmUgd2FzIGNyZWF0ZWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUubGFzdENvbW1hbmQgPSBDYWxpZm9ybmlhRXZlbnQuQ3JlYXRlTGF5b3V0Qm94Rm9yQm94T3JSb3c7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUubGFzdENhbGlmb3JuaWFFdmVudERhdGEgPSBbY3VycmVudEFwcC5zdGF0ZS5zZWxlY3RlZExheW91dEJhc2VJZCwgbGF5b3V0SWRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnZpZXdNb2RlbC5jdXJyZW50U2Vjb25kYXJ5UG9wdXBNb2RlID09PSBQb3B1cFNlY29uZGFyeU1vZGUuU2VsZWN0Qm94SW50b0JveEF0b21JblBsYWNlKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5DcmVhdGVMYXlvdXRCb3hGb3JBdG9tSW5QbGFjZUpzb24oY3VycmVudEFwcC5zdGF0ZS5zZWxlY3RlZExheW91dEJhc2VJZCwgcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibGlkXCIpKS5kb25lKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKTtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gZm9jdXMgbGFzdCBhdG9tIGlmIG9uZSB3YXMgY3JlYXRlZFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICB9ICAgICAgICBcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jbG9zZVBvcHVwKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjYW5jZWxJbnNlcnRMYXlvdXRCb3hJbnRvQm94Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmNsb3NlUG9wdXAoKTtcclxuICAgIH07XHJcblxyXG4gICAgLypwdWJsaWMgbW92ZUxheW91dE1vbGVjdWxlSW50b1BvcHVwID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICBsZXQgdGhpc1BvcHVwTW9kZTogUG9wdXBNb2RlID0gUG9wdXBNb2RlLk1vdmVMYXlvdXRNb2xlY3VsZUludG9MYXlvdXRNb2xlY3VsZTtcclxuICAgICAgICBsZXQgaXNQb3B1cFZpc2libGU6IGJvb2xlYW4gPSB0aGlzLnZpZXdNb2RlbC5jdXJyZW50UG9wdXBNb2RlID09PSB0aGlzUG9wdXBNb2RlO1xyXG4gICAgICAgIGxldCBpc0RhdGFMb2FkZWQ6IGJvb2xlYW4gPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QgIT09IHVuZGVmaW5lZCAmJiBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuUmVzcG9uc2l2ZURldmljZXMgIT09IHVuZGVmaW5lZDsgLy8gVE9ETyBjb2RlIGR1cGxpY2F0aW9uIC8gc3RhdGVcclxuICAgICAgICByZXR1cm4gPGRpdiBpZD17YCR7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucHJvcGVydHlCYXJJbmRleH1Qb3B1cE1vZGUke1BvcHVwTW9kZVt0aGlzUG9wdXBNb2RlXX1gfSBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IGlzUG9wdXBWaXNpYmxlID8gXCJibG9ja1wiIDogXCJub25lXCIsIFwiei1pbmRleFwiIDogXCIzMVwiLCBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLCBcImJvcmRlclwiOiBcInNvbGlkIGJsYWNrIDFweFwiIH19PlxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlcz17eyBcImRpc3BsYXlcIjogXCJmbGV4XCIsIFwiZmxleC1mbG93XCI6IFwicm93IG5vd3JhcFwiLCBcIm1pbi13aWR0aFwiOiBcIjI1MHB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgc3R5bGVzPXt7IFwiZmxleFwiOiBcIjEgMCAxMCVcIiwgXCJ3aWR0aFwiOiBcIjEwJVwiLCBcIm1pbi13aWR0aFwiOiBcIjEwJVwiIH19IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmNhbmNlbExheW91dE1vbGVjdWxlSW50b0NsaWNrSGFuZGxlcn0+eDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAge2lzRGF0YUxvYWRlZCA/IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5MYXlvdXRNb2xlY3VsZXMubWFwKChsYXlvdXRNb2xlY3VsZTogTGF5b3V0QmFzZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxheW91dE1vbGVjdWxlLkxheW91dFR5cGUgPT09IExheW91dFR5cGUuQXRvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgbGF5b3V0QmFzZUlkU3RyaW5nOiBzdHJpbmcgPSBsYXlvdXRNb2xlY3VsZS5MYXlvdXRCYXNlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGxldCBzb3VyY2VTdHlsZU1vbGVjdWxlSWRTdHJpbmcgPSAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlTW9sZWN1bGVzLmZpbmQobSA9PiBtLlN0eWxlRm9yTGF5b3V0SWQgPT0gbGF5b3V0TW9sZWN1bGUuTGF5b3V0QmFzZUlkKSBhcyBTdHlsZU1vbGVjdWxlKS5TdHlsZU1vbGVjdWxlSWQudG9TdHJpbmcoKTsgLy8gVE9ETyBleHBlbnNpdmVcclxuICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17bGF5b3V0QmFzZUlkU3RyaW5nfT5cclxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiBsaWQ9e2xheW91dEJhc2VJZFN0cmluZ30gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIubW92ZUxheW91dE1vbGVjdWxlSW50b0xheW91dE1vbGVjdWxlQ2xpY2tIYW5kbGVyfT4je2xheW91dEJhc2VJZFN0cmluZ30ge0xheW91dFR5cGVbbGF5b3V0TW9sZWN1bGUuTGF5b3V0VHlwZV19IHN0eWxlICN7c291cmNlU3R5bGVNb2xlY3VsZUlkU3RyaW5nfTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIH0pIDogdW5kZWZpbmVkfVxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIHB1YmxpYyBtb3ZlTGF5b3V0TW9sZWN1bGVJbnRvTGF5b3V0TW9sZWN1bGVDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLk1vdmVMYXlvdXRNb2xlY3VsZUludG9MYXlvdXRNb2xlY3VsZUpzb24oY3VycmVudEFwcC5zdGF0ZS5zZWxlY3RlZExheW91dEJhc2VJZCwgcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibGlkXCIpKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2xvc2VQb3B1cCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY2FuY2VsTGF5b3V0TW9sZWN1bGVJbnRvQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmNsb3NlUG9wdXAoKTtcclxuICAgIH07Ki9cclxuXHJcbiAgICBwdWJsaWMgbW92ZUxheW91dE1vbGVjdWxlSW50b0xheW91dE1vbGVjdWxlID0gKCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5Nb3ZlTGF5b3V0TW9sZWN1bGVJbnRvTGF5b3V0TW9sZWN1bGVKc29uKGN1cnJlbnRBcHAuc3RhdGUucHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQsIGN1cnJlbnRBcHAuc3RhdGUuc2VsZWN0ZWRMYXlvdXRCYXNlSWQpLmRvbmUoZGF0YSA9PiBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jbG9zZVBvcHVwKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qcHVibGljIG1vdmVMYXlvdXRNb2xlY3VsZUJlZm9yZVBvcHVwID0gKCk6IFZOb2RlID0+IHsgVE9ETyB1bnVzZWRcclxuICAgICAgICBsZXQgdGhpc1BvcHVwTW9kZTogUG9wdXBNb2RlID0gUG9wdXBNb2RlLk1vdmVMYXlvdXRNb2xlY3VsZUJlZm9yZUxheW91dE1vbGVjdWxlO1xyXG4gICAgICAgIGxldCBpc1BvcHVwVmlzaWJsZTogYm9vbGVhbiA9IHRoaXMudmlld01vZGVsLmN1cnJlbnRQb3B1cE1vZGUgPT09IHRoaXNQb3B1cE1vZGU7XHJcbiAgICAgICAgbGV0IGlzRGF0YUxvYWRlZDogYm9vbGVhbiA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdCAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5SZXNwb25zaXZlRGV2aWNlcyAhPT0gdW5kZWZpbmVkOyAvLyBUT0RPIGNvZGUgZHVwbGljYXRpb24gLyBzdGF0ZVxyXG4gICAgICAgIHJldHVybiA8ZGl2IGlkPXtgJHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5wcm9wZXJ0eUJhckluZGV4fVBvcHVwTW9kZSR7UG9wdXBNb2RlW3RoaXNQb3B1cE1vZGVdfWB9IHN0eWxlcz17eyBcImRpc3BsYXlcIjogaXNQb3B1cFZpc2libGUgPyBcImJsb2NrXCIgOiBcIm5vbmVcIiwgXCJ6LWluZGV4XCIgOiBcIjMxXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsIFwiYm9yZGVyXCI6IFwic29saWQgYmxhY2sgMXB4XCIgfX0+XHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGVzPXt7IFwiZGlzcGxheVwiOiBcImZsZXhcIiwgXCJmbGV4LWZsb3dcIjogXCJyb3cgbm93cmFwXCIsIFwibWluLXdpZHRoXCI6IFwiMjUwcHhcIiB9fT5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMSAwIDEwJVwiLCBcIndpZHRoXCI6IFwiMTAlXCIsIFwibWluLXdpZHRoXCI6IFwiMTAlXCIgfX0gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2FuY2VsTGF5b3V0TW9sZWN1bGVCZWZvcmVDbGlja0hhbmRsZXJ9Png8L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIHtpc0RhdGFMb2FkZWQgPyBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuTGF5b3V0TW9sZWN1bGVzLm1hcCgobGF5b3V0TW9sZWN1bGU6IExheW91dEJhc2UpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBsYXlvdXRCYXNlSWRTdHJpbmc6IHN0cmluZyA9IGxheW91dE1vbGVjdWxlLkxheW91dEJhc2VJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZVN0eWxlTW9sZWN1bGVJZFN0cmluZyA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChtID0+IG0uU3R5bGVGb3JMYXlvdXRJZCA9PSBsYXlvdXRNb2xlY3VsZS5MYXlvdXRCYXNlSWQpIGFzIFN0eWxlTW9sZWN1bGUpLlN0eWxlTW9sZWN1bGVJZC50b1N0cmluZygpOyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYga2V5PXtsYXlvdXRCYXNlSWRTdHJpbmd9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIGxpZD17bGF5b3V0QmFzZUlkU3RyaW5nfSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5tb3ZlTGF5b3V0TW9sZWN1bGVCZWZvcmVMYXlvdXRNb2xlY3VsZUNsaWNrSGFuZGxlcn0+I3tsYXlvdXRCYXNlSWRTdHJpbmd9IHtMYXlvdXRUeXBlW2xheW91dE1vbGVjdWxlLkxheW91dFR5cGVdfSBzdHlsZSAje3NvdXJjZVN0eWxlTW9sZWN1bGVJZFN0cmluZ308L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICB9KSA6IHVuZGVmaW5lZH1cclxuICAgICAgICA8L2Rpdj4gYXMgVk5vZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBtb3ZlTGF5b3V0TW9sZWN1bGVCZWZvcmVMYXlvdXRNb2xlY3VsZUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuTW92ZUxheW91dE1vbGVjdWxlTmV4dFRvTGF5b3V0TW9sZWN1bGVKc29uKGN1cnJlbnRBcHAuc3RhdGUuc2VsZWN0ZWRMYXlvdXRCYXNlSWQsIHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImxpZFwiKSwgdHJ1ZSkuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmNsb3NlUG9wdXAoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNhbmNlbExheW91dE1vbGVjdWxlQmVmb3JlQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmNsb3NlUG9wdXAoKTtcclxuICAgIH07Ki9cclxuXHJcbiAgICBwdWJsaWMgbW92ZUxheW91dE1vbGVjdWxlQmVmb3JlTGF5b3V0TW9sZWN1bGUgPSAoKSA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLk1vdmVMYXlvdXRNb2xlY3VsZU5leHRUb0xheW91dE1vbGVjdWxlSnNvbihjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkLCBjdXJyZW50QXBwLnN0YXRlLnNlbGVjdGVkTGF5b3V0QmFzZUlkLCB0cnVlKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2xvc2VQb3B1cCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc3luY0xheW91dE1vbGVjdWxlU3R5bGVzSW1pdGF0aW5nUmVmZXJlbmNlTGF5b3V0ID0gKCkgPT4ge1xyXG4gICAgICAgIC8vIFRPRE8gZXZlcnl3aGVyZSBjaGVja3MgbW92ZS9kdXBsaWNhdGUgdG8gY2xpZW50XHJcbiAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLlN5bmNMYXlvdXRTdHlsZXNJbWl0YXRpbmdSZWZlcmVuY2VMYXlvdXRKc29uKGN1cnJlbnRBcHAuc3RhdGUuc2VsZWN0ZWRMYXlvdXRCYXNlSWQsIGN1cnJlbnRBcHAuc3RhdGUucHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQpLmRvbmUoZGF0YSA9PiBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpKTsgLy8gVE9ETyBjb25jZXB0OiB0YXJnZXQvcHJlc2VsZWN0IG9yZGVyIGNoYW5nZXNcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jbG9zZVBvcHVwKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBtb3ZlU3R5bGVBdG9tVG9SZXNwb25zaXZlRGV2aWNlUG9wdXAgPSAoKTogVk5vZGUgPT4ge1xyXG4gICAgICAgIGxldCB0aGlzUG9wdXBNb2RlOiBQb3B1cE1vZGUgPSBQb3B1cE1vZGUuTW92ZVN0eWxlQXRvbTtcclxuICAgICAgICBsZXQgaXNQb3B1cFZpc2libGU6IGJvb2xlYW4gPSB0aGlzLnZpZXdNb2RlbC5jdXJyZW50UG9wdXBNb2RlID09PSB0aGlzUG9wdXBNb2RlO1xyXG4gICAgICAgIGxldCBpc0RhdGFMb2FkZWQ6IGJvb2xlYW4gPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QgIT09IHVuZGVmaW5lZCAmJiBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuUmVzcG9uc2l2ZURldmljZXMgIT09IHVuZGVmaW5lZDsgLy8gVE9ETyBjb2RlIGR1cGxpY2F0aW9uIC8gc3RhdGVcclxuICAgICAgICByZXR1cm4gPGRpdiBpZD17YCR7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucHJvcGVydHlCYXJJbmRleH1Qb3B1cE1vZGUke1BvcHVwTW9kZVt0aGlzUG9wdXBNb2RlXX1gfSBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IGlzUG9wdXBWaXNpYmxlID8gXCJibG9ja1wiIDogXCJub25lXCIsIFwiei1pbmRleFwiIDogXCIzMVwiLCBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLCBcImJvcmRlclwiOiBcInNvbGlkIGJsYWNrIDFweFwiIH19PlxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlcz17eyBcImRpc3BsYXlcIjogXCJmbGV4XCIsIFwiZmxleC1mbG93XCI6IFwicm93IG5vd3JhcFwiLCBcIm1pbi13aWR0aFwiOiBcIjI1MHB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgc3R5bGVzPXt7IFwiZmxleFwiOiBcIjEgMCAxMCVcIiwgXCJ3aWR0aFwiOiBcIjEwJVwiLCBcIm1pbi13aWR0aFwiOiBcIjEwJVwiIH19IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmNhbmNlbE1vdmVTdHlsZUF0b21DbGlja0hhbmRsZXJ9Png8L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIHtpc0RhdGFMb2FkZWQgPyBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuUmVzcG9uc2l2ZURldmljZXMubWFwKChyZXNwb25zaXZlRGV2aWNlOiBSZXNwb25zaXZlRGV2aWNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2l2ZURldmljZUlkU3RyaW5nOiBzdHJpbmcgPSByZXNwb25zaXZlRGV2aWNlLlJlc3BvbnNpdmVEZXZpY2VJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGlzU2VsZWN0ZWRSZXNwb25zaXZlRGV2aWNlSW5Qcm9wZXJ0eUJhcjogYm9vbGVhbiA9IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFJlc3BvbnNpdmVEZXZpY2VJZCA9PSByZXNwb25zaXZlRGV2aWNlLlJlc3BvbnNpdmVEZXZpY2VJZDtcclxuICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17cmVzcG9uc2l2ZURldmljZUlkU3RyaW5nfT5cclxuICAgICAgICAgICAgICAgICAgICB7IWlzU2VsZWN0ZWRSZXNwb25zaXZlRGV2aWNlSW5Qcm9wZXJ0eUJhciA/IDxidXR0b24ga2V5PVwiYVwiIHJpZD17cmVzcG9uc2l2ZURldmljZUlkU3RyaW5nfSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5tb3ZlU3R5bGVBdG9tVG9SZXNwb25zaXZlRGV2aWNlQ2xpY2tIYW5kbGVyfT57cmVzcG9uc2l2ZURldmljZS5OYW1lU2hvcnR9PC9idXR0b24+IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJhMFwiIHJpZD17cmVzcG9uc2l2ZURldmljZUlkU3RyaW5nfSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5tb3ZlU3R5bGVBdG9tVG9SZXNwb25zaXZlRGV2aWNlQ2xpY2tIYW5kbGVyfT57cmVzcG9uc2l2ZURldmljZS5OYW1lU2hvcnR9PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIH0pIDogdW5kZWZpbmVkfVxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIG1vdmVTdHlsZUF0b21Ub1Jlc3BvbnNpdmVEZXZpY2VDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IHRhcmdldFJlc3BvbnNpdmVEZXZpY2VJZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwicmlkXCIpO1xyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5Nb3ZlU3R5bGVBdG9tVG9SZXNwb25zaXZlRGV2aWNlSnNvbih0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZUF0b21JZEZvclBvcHVwLCB0YXJnZXRSZXNwb25zaXZlRGV2aWNlSWQpLmRvbmUoZGF0YSA9PiB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFJlc3BvbnNpdmVEZXZpY2VJZCA9IHRhcmdldFJlc3BvbnNpdmVEZXZpY2VJZDtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZUF0b21JZEZvclBvcHVwID0gMDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jbG9zZVBvcHVwKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjYW5jZWxNb3ZlU3R5bGVBdG9tQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFN0eWxlQXRvbUlkRm9yUG9wdXAgPSAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmNsb3NlUG9wdXAoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlbmRlckFsbENzc1Byb3BlcnRpZXNQb3B1cCA9ICgpOiBWTm9kZSA9PiB7XHJcbiAgICAgICAgbGV0IGlzUG9wdXBWaXNpYmxlOiBib29sZWFuID0gdGhpcy52aWV3TW9kZWwuY3VycmVudFBvcHVwTW9kZSA9PT0gUG9wdXBNb2RlLkFsbENzc1Byb3BlcnRpZXM7XHJcbiAgICAgICAgcmV0dXJuIDxkaXYgaWQ9e2Ake3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXh9UG9wdXBNb2RlJHtQb3B1cE1vZGVbUG9wdXBNb2RlLkFsbENzc1Byb3BlcnRpZXNdfWB9IHN0eWxlcz17eyBcImRpc3BsYXlcIjogaXNQb3B1cFZpc2libGUgPyBcImJsb2NrXCIgOiBcIm5vbmVcIiwgXCJ6LWluZGV4XCIgOiBcIjMxXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsIFwiYm9yZGVyXCI6IFwic29saWQgYmxhY2sgMXB4XCIsIFwiaGVpZ2h0XCI6IFwiMzAwcHhcIiwgXCJvdmVyZmxvd1wiOiBcInNjcm9sbFwiIH19PlxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlcz17eyBcImRpc3BsYXlcIjogXCJmbGV4XCIsIFwiZmxleC1mbG93XCI6IFwicm93IG5vd3JhcFwiLCBcIm1pbi13aWR0aFwiOiBcIjI1MHB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgc3R5bGVzPXt7IFwiZmxleFwiOiBcIjEgMCAxMCVcIiwgXCJ3aWR0aFwiOiBcIjEwJVwiLCBcIm1pbi13aWR0aFwiOiBcIjEwJVwiIH19IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmNhbmNlbFVwZGF0ZUNzc1Byb3BlcnR5bGlja0hhbmRsZXJ9Png8L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIHtjdXJyZW50QXBwLmNsaWVudERhdGEuQWxsQ3NzUHJvcGVydGllcy5tYXAoKHByb3A6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGlzUHJvcGVydHlVbm1hcHBlZDogYm9vbGVhbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBsZXQgaXNQcm9wZXJ0eVZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZUF0b21JZCAhPSAwICYmIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdCAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlQXRvbXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRBdG9tOiBTdHlsZUF0b20gfCB1bmRlZmluZWQgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVBdG9tcy5maW5kKHMgPT4gcy5TdHlsZUF0b21JZCA9PSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZUF0b21JZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEF0b20gIT09IHVuZGVmaW5lZCAmJiB0YXJnZXRBdG9tLkFwcGxpZWRWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1Byb3BlcnR5VmlzaWJsZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5TdHlsZUF0b21Dc3NQcm9wZXJ0eU1hcHBpbmdbU3R5bGVBdG9tVHlwZVt0YXJnZXRBdG9tLlN0eWxlQXRvbVR5cGVdXS5maW5kSW5kZXgocCA9PiBwID09PSBwcm9wKSAhPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcm9wZXJ0eVVubWFwcGVkID0gdGFyZ2V0QXRvbS5BcHBsaWVkVmFsdWVzLmZpbmRJbmRleCh2ID0+IHYuQ3NzUHJvcGVydHkgPT09IHByb3ApID09IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBpc1Byb3BlcnR5VmlzaWJsZSA/IDxkaXYga2V5PXtwcm9wfT5cclxuICAgICAgICAgICAgICAgICAgICB7cHJvcH17IGlzUHJvcGVydHlVbm1hcHBlZCA/IDxidXR0b24ga2V5PVwiYTBcIiByb2xlPVwiYnV0dG9uXCIgY2lkPXtwcm9wfSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zZXRTZWxlY3RlZENzc1Byb3BlcnR5Q2xpY2tIYW5kbGVyfT4mIzEwMDA0OzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDxidXR0b24gZGlzYWJsZWQga2V5PVwiYTFcIiByb2xlPVwiYnV0dG9uXCIgY2lkPXtwcm9wfSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zZXRTZWxlY3RlZENzc1Byb3BlcnR5Q2xpY2tIYW5kbGVyfT4mIzEwMDA0OzwvYnV0dG9uPn1cclxuICAgICAgICAgICAgICAgIDwvZGl2PiA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfSl9XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY2FuY2VsVXBkYXRlQ3NzUHJvcGVydHlsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLnZpZXdNb2RlbC5jdXJyZW50UG9wdXBNb2RlID0gUG9wdXBNb2RlLkFkZENzc1Byb3BlcnR5O1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2hvd0FsbENzc1Byb3BlcnRpZXNDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZGlzcGxheVBvcHVwKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsIFBvcHVwTW9kZS5BbGxDc3NQcm9wZXJ0aWVzKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNldFNlbGVjdGVkQ3NzUHJvcGVydHlDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDc3NQcm9wZXJ0eU5hbWUgPSBwYXJzZVN0cmluZ0Zyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJjaWRcIik7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2F2ZUNzc1Byb3BlcnR5Rm9yQXRvbSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2F2ZUNzc1Byb3BlcnR5Rm9yQXRvbUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zYXZlQ3NzUHJvcGVydHlGb3JBdG9tKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgc2F2ZUNzc1Byb3BlcnR5Rm9yQXRvbSA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuQ3JlYXRlU3R5bGVWYWx1ZUZvckF0b21Kc29uKHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFN0eWxlQXRvbUlkLCB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1Byb3BlcnR5TmFtZSkuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnJlc2V0VGVtcENzc1Byb3BlcnR5U3RhdGUoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNhbmNlbEFkZENzc1Byb3BlcnR5Rm9yQXRvbUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZXNldFRlbXBDc3NQcm9wZXJ0eVN0YXRlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZXNldFRlbXBDc3NQcm9wZXJ0eVN0YXRlID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzUHJvcGVydHlOYW1lID0gXCJcIjtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1ZhbHVlID0gXCJcIjtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZUF0b21JZCA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3R5bGVWYWx1ZUlkID0gMDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZVF1YW50dW1JZCA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2xvc2VQb3B1cCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY3NzUHJvcGVydHlOYW1lSW5wdXRIYW5kbGVyID0gKGV2dDogS2V5Ym9hcmRFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzUHJvcGVydHlOYW1lID0gKGV2dC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJVcGRhdGVDc3NWYWx1ZVBvcHVwID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICBsZXQgaXNQb3B1cFZpc2libGU6IGJvb2xlYW4gPSB0aGlzLnZpZXdNb2RlbC5jdXJyZW50UG9wdXBNb2RlID09PSBQb3B1cE1vZGUuVXBkYXRlQ3NzVmFsdWUgfHwgdGhpcy52aWV3TW9kZWwuY3VycmVudFBvcHVwTW9kZSA9PT0gUG9wdXBNb2RlLk1hdGNoaW5nUXVhbnR1bXM7XHJcbiAgICAgICAgcmV0dXJuIDxkaXYgaWQ9e2Ake3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXh9UG9wdXBNb2RlJHtQb3B1cE1vZGVbUG9wdXBNb2RlLlVwZGF0ZUNzc1ZhbHVlXX1gfSBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IGlzUG9wdXBWaXNpYmxlID8gXCJibG9ja1wiIDogXCJub25lXCIsIFwiei1pbmRleFwiIDogXCIzMVwiLCBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLCBcImJvcmRlclwiOiBcInNvbGlkIGJsYWNrIDFweFwiIH19PlxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlcz17eyBcImRpc3BsYXlcIjogXCJmbGV4XCIsIFwiZmxleC1mbG93XCI6IFwicm93IG5vd3JhcFwiLCBcIm1pbi13aWR0aFwiOiBcIjI1MHB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgc3R5bGVzPXt7IFwiZmxleFwiOiBcIjEgMCAxMCVcIiwgXCJ3aWR0aFwiOiBcIjEwJVwiLCBcIm1pbi13aWR0aFwiOiBcIjEwJVwiIH19IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnNhdmVVcGRhdGVkQ3NzVmFsdWVDbGlja0hhbmRsZXJ9PiYjMTAwMDQ7PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImJcIiByb2xlPVwiYnV0dG9uXCIgc3R5bGVzPXt7IFwiZmxleFwiOiBcIjEgMCAxMCVcIiwgXCJ3aWR0aFwiOiBcIjEwJVwiLCBcIm1pbi13aWR0aFwiOiBcIjEwJVwiIH19IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmNhbmNlbFVwZGF0ZUNzc1ZhbHVlQ2xpY2tIYW5kbGVyfT54PC9idXR0b24+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPGlucHV0IGtleT1cIi0xXCJcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDc3NWYWx1ZX1cclxuICAgICAgICAgICAgICAgICAgICBvbmlucHV0PXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jc3NWYWx1ZUlucHV0SGFuZGxlcn0+XHJcbiAgICAgICAgICAgICAgICA8L2lucHV0PlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnNob3dNYXRjaGluZ1F1YW50dW1zQ2xpY2tIYW5kbGVyfT4/PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImJcIiByb2xlPVwiYnV0dG9uXCIgb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2V0VGVtcENzc1RvWmVyb0NsaWNrSGFuZGxlcn0+MDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJjXCIgcm9sZT1cImJ1dHRvblwiIG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnNldFRlbXBDc3NUb05vbmVDbGlja0hhbmRsZXJ9Pm5vbmU8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiZFwiIHJvbGU9XCJidXR0b25cIiBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zZXRUZW1wQ3NzVG9OdWxsQ2xpY2tIYW5kbGVyfT5udWxsPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImVcIiByb2xlPVwiYnV0dG9uXCIgb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2V0VGVtcENzc1RvQXV0b0NsaWNrSGFuZGxlcn0+YXV0bzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAge3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5sYXN0VXNlZFRlbXBDc3NWYWx1ZSAhPT0gXCJcIiA/IDxidXR0b24ga2V5PVwiZVwiIHJvbGU9XCJidXR0b25cIiBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zZXRUZW1wQ3NzQXBwZW5kTGFzdFVzZWRDbGlja0hhbmRsZXJ9Pit7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmxhc3RVc2VkVGVtcENzc1ZhbHVlLmxlbmd0aCA+IDEwID8gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmxhc3RVc2VkVGVtcENzc1ZhbHVlLnN1YnN0cmluZygwLCAxMCkgKyBcIi4uLlwiIDogdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmxhc3RVc2VkVGVtcENzc1ZhbHVlfTwvYnV0dG9uPiA6IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2V0VGVtcENzc1RvWmVyb0NsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1ZhbHVlID0gXCIwXCI7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzZXRUZW1wQ3NzVG9OdWxsQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzVmFsdWUgPSBcIm51bGxcIjtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNldFRlbXBDc3NUb05vbmVDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDc3NWYWx1ZSA9IFwibm9uZVwiO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2V0VGVtcENzc1RvQXV0b0NsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1ZhbHVlID0gXCJhdXRvXCI7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzZXRUZW1wQ3NzQXBwZW5kTGFzdFVzZWRDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDc3NWYWx1ZSA9IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzVmFsdWUgKyB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwubGFzdFVzZWRUZW1wQ3NzVmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJVcGRhdGVDc3NRdWFudHVtUG9wdXAgPSAoKTogVk5vZGUgPT4ge1xyXG4gICAgICAgIGxldCBpc1BvcHVwVmlzaWJsZTogYm9vbGVhbiA9IHRoaXMudmlld01vZGVsLmN1cnJlbnRQb3B1cE1vZGUgPT09IFBvcHVwTW9kZS5VcGRhdGVDc3NRdWFudHVtO1xyXG4gICAgICAgIHJldHVybiA8ZGl2IGlkPXtgJHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5wcm9wZXJ0eUJhckluZGV4fVBvcHVwTW9kZSR7UG9wdXBNb2RlW1BvcHVwTW9kZS5VcGRhdGVDc3NRdWFudHVtXX1gfSBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IGlzUG9wdXBWaXNpYmxlID8gXCJibG9ja1wiIDogXCJub25lXCIsIFwiei1pbmRleFwiIDogXCIzMVwiLCBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLCBcImJvcmRlclwiOiBcInNvbGlkIGJsYWNrIDFweFwiIH19PlxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlcz17eyBcImRpc3BsYXlcIjogXCJmbGV4XCIsIFwiZmxleC1mbG93XCI6IFwicm93IG5vd3JhcFwiLCBcIm1pbi13aWR0aFwiOiBcIjI1MHB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgc3R5bGVzPXt7IFwiZmxleFwiOiBcIjEgMCAxMCVcIiwgXCJ3aWR0aFwiOiBcIjEwJVwiLCBcIm1pbi13aWR0aFwiOiBcIjEwJVwiIH19IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnNhdmVVcGRhdGVkQ3NzUXVhbnR1bUNsaWNrSGFuZGxlcn0+JiMxMDAwNDs8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYlwiIHJvbGU9XCJidXR0b25cIiBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMSAwIDEwJVwiLCBcIndpZHRoXCI6IFwiMTAlXCIsIFwibWluLXdpZHRoXCI6IFwiMTAlXCIgfX0gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2FuY2VsVXBkYXRlQ3NzUXVhbnR1bUNsaWNrSGFuZGxlcn0+eDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxpbnB1dCBrZXk9XCItMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzVmFsdWV9XHJcbiAgICAgICAgICAgICAgICAgICAgb25pbnB1dD17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY3NzVmFsdWVJbnB1dEhhbmRsZXJ9PlxyXG4gICAgICAgICAgICAgICAgPC9pbnB1dD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2hvd01hdGNoaW5nUXVhbnR1bXNDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZGlzcGxheVBvcHVwKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsIFBvcHVwTW9kZS5NYXRjaGluZ1F1YW50dW1zKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNhdmVVcGRhdGVkQ3NzUXVhbnR1bUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuVXBkYXRlU3R5bGVRdWFudHVtSnNvbih0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZVF1YW50dW1JZCwgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDc3NWYWx1ZSkuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5sYXN0VXNlZFRlbXBDc3NWYWx1ZSA9IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzVmFsdWU7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIucmVzZXRUZW1wQ3NzUHJvcGVydHlTdGF0ZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY2FuY2VsVXBkYXRlQ3NzUXVhbnR1bUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZXNldFRlbXBDc3NQcm9wZXJ0eVN0YXRlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzYXZlVXBkYXRlZENzc1ZhbHVlQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5VcGRhdGVTdHlsZVZhbHVlSnNvbih0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZVZhbHVlSWQsIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzVmFsdWUpLmRvbmUoZGF0YSA9PiBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwubGFzdFVzZWRUZW1wQ3NzVmFsdWUgPSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1ZhbHVlO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnJlc2V0VGVtcENzc1Byb3BlcnR5U3RhdGUoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNhbmNlbFVwZGF0ZUNzc1ZhbHVlQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnJlc2V0VGVtcENzc1Byb3BlcnR5U3RhdGUoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNzc1ZhbHVlSW5wdXRIYW5kbGVyID0gKGV2dDogS2V5Ym9hcmRFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzVmFsdWUgPSAoZXZ0LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNzc1ZhbHVlRm9ySW50ZXJhY3Rpb25JbnB1dEhhbmRsZXIgPSAoZXZ0OiBLZXlib2FyZEV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDc3NWYWx1ZUZvckludGVyYWN0aW9uID0gKGV2dC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJTZWxlY3RJbnRlcmFjdGlvblRhcmdldFBvcHVwID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICBsZXQgaXNQb3B1cFZpc2libGU6IGJvb2xlYW4gPSB0aGlzLnZpZXdNb2RlbC5jdXJyZW50UG9wdXBNb2RlID09PSBQb3B1cE1vZGUuU2VsZWN0SW50ZXJhY3Rpb25UYXJnZXQ7XHJcbiAgICAgICAgbGV0IHJlbmRlcmVkT3B0aW9uczogVk5vZGVbXSA9IFtdO1xyXG4gICAgICAgIGlmIChpc1BvcHVwVmlzaWJsZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuTGF5b3V0TW9sZWN1bGVzLm1hcChtID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBsYXlvdXRCYXNlSWRTdHJpbmc6IHN0cmluZyA9IG0uTGF5b3V0QmFzZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlZE9wdGlvbnMucHVzaCg8ZGl2IGtleT17bGF5b3V0QmFzZUlkU3RyaW5nfSBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMCAwIDEwMCVcIiwgXCJ3aWR0aFwiOiBcIjEwMCVcIiwgXCJtaW4td2lkdGhcIjogXCIxMDAlXCIgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0ICN7bGF5b3V0QmFzZUlkU3RyaW5nfSA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgYmlkPXtsYXlvdXRCYXNlSWRTdHJpbmd9IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnNlbGVjdExheW91dEJhc2VGb3JJbnRlcmFjdGlvblRhcmdldENsaWNrSGFuZGxlcn0+JiMxMDAwNDs8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PiBhcyBWTm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gPGRpdiBpZD17YCR7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucHJvcGVydHlCYXJJbmRleH1Qb3B1cE1vZGUke1BvcHVwTW9kZVtQb3B1cE1vZGUuU2VsZWN0SW50ZXJhY3Rpb25UYXJnZXRdfWB9IHN0eWxlcz17eyBcImRpc3BsYXlcIjogaXNQb3B1cFZpc2libGUgPyBcImJsb2NrXCIgOiBcIm5vbmVcIiwgXCJ6LWluZGV4XCIgOiBcIjMxXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsIFwiYm9yZGVyXCI6IFwic29saWQgYmxhY2sgMXB4XCIgfX0+XHJcbiAgICAgICAgICAgIDxkaXYga2V5PVwiMFwiIHN0eWxlcz17eyBcImRpc3BsYXlcIjogXCJmbGV4XCIsIFwiZmxleC1mbG93XCI6IFwicm93IG5vd3JhcFwiLCBcIm1pbi13aWR0aFwiOiBcIjI1MHB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgc3R5bGVzPXt7IFwiZmxleFwiOiBcIjEgMCAxMCVcIiwgXCJ3aWR0aFwiOiBcIjEwJVwiLCBcIm1pbi13aWR0aFwiOiBcIjEwJVwiIH19IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmNhbmNlbFNlbGVjdEludGVyYWN0aW9uVGFyZ2V0Q2xpY2tIYW5kbGVyfT54PC9idXR0b24+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGtleT1cIjFcIiBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IFwiZmxleFwiLCBcImZsZXgtZmxvd1wiOiBcInJvdyB3cmFwXCIgfX0+XHJcbiAgICAgICAgICAgICAgICB7cmVuZGVyZWRPcHRpb25zfVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj4gYXMgVk5vZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzZWxlY3RMYXlvdXRCYXNlRm9ySW50ZXJhY3Rpb25UYXJnZXRDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkTGF5b3V0QmFzZUlkRm9yRmlsdGVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwiYmlkXCIpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmRpc3BsYXlQb3B1cChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCBQb3B1cE1vZGUuU2VsZWN0SW50ZXJhY3Rpb25UYXJnZXRMYXlvdXRGaWx0ZXIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY2FuY2VsU2VsZWN0SW50ZXJhY3Rpb25UYXJnZXRDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2xvc2VQb3B1cCgpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZExheW91dEJhc2VJZEZvckZpbHRlciA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkTGF5b3V0U3R5bGVJbnRlcmFjdGlvbiA9IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJTZWxlY3RJbnRlcmFjdGlvblRhcmdldExheW91dEZpbHRlclBvcHVwID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICBsZXQgaXNQb3B1cFZpc2libGU6IGJvb2xlYW4gPSB0aGlzLnZpZXdNb2RlbC5jdXJyZW50UG9wdXBNb2RlID09PSBQb3B1cE1vZGUuU2VsZWN0SW50ZXJhY3Rpb25UYXJnZXRMYXlvdXRGaWx0ZXI7XHJcbiAgICAgICAgbGV0IHJlbmRlcmVkT3B0aW9uczogVk5vZGVbXSA9IFtdO1xyXG4gICAgICAgIGlmIChpc1BvcHVwVmlzaWJsZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVWYWx1ZXMubWFwKHYgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlQXRvbTogU3R5bGVBdG9tID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlQXRvbXMuZmluZChhID0+IGEuQXBwbGllZFZhbHVlcy5maW5kSW5kZXgobWFwID0+IG1hcC5TdHlsZVZhbHVlSWQgPT0gdi5TdHlsZVZhbHVlSWQpICE9IC0xKSBhcyBTdHlsZUF0b207IC8vIFRPRE8gZXhwZW5zaXZlXHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVNb2xlY3VsZTogU3R5bGVNb2xlY3VsZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcy5maW5kKG0gPT4gbS5NYXBwZWRTdHlsZUF0b21zLmZpbmRJbmRleChtYXAgPT4gbWFwLlN0eWxlTW9sZWN1bGVBdG9tTWFwcGluZ0lkID09IHN0eWxlQXRvbS5NYXBwZWRUb01vbGVjdWxlSWQpICE9IC0xKSBhcyBTdHlsZU1vbGVjdWxlOyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlTW9sZWN1bGUuU3R5bGVGb3JMYXlvdXRJZCA9PSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRMYXlvdXRCYXNlSWRGb3JGaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3R5bGVWYWx1ZUlkU3RyaW5nOiBzdHJpbmcgPSB2LlN0eWxlVmFsdWVJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkT3B0aW9ucy5wdXNoKDxkaXYga2V5PXtzdHlsZVZhbHVlSWRTdHJpbmd9IHN0eWxlcz17eyBcImZsZXhcIjogXCIwIDAgMTAwJVwiLCBcIndpZHRoXCI6IFwiMTAwJVwiLCBcIm1pbi13aWR0aFwiOiBcIjEwMCVcIiB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgI3tzdHlsZVZhbHVlSWRTdHJpbmd9OiB7di5Dc3NQcm9wZXJ0eX06e3YuQ3NzVmFsdWV9IDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiB2aWQ9e3N0eWxlVmFsdWVJZFN0cmluZ30gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2VsZWN0U3R5bGVWYWx1ZUZvckludGVyYWN0aW9uVGFyZ2V0Q2xpY2tIYW5kbGVyfT4mIzEwMDA0OzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PiBhcyBWTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gPGRpdiBpZD17YCR7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucHJvcGVydHlCYXJJbmRleH1Qb3B1cE1vZGUke1BvcHVwTW9kZVtQb3B1cE1vZGUuU2VsZWN0SW50ZXJhY3Rpb25UYXJnZXRMYXlvdXRGaWx0ZXJdfWB9IHN0eWxlcz17eyBcImRpc3BsYXlcIjogaXNQb3B1cFZpc2libGUgPyBcImJsb2NrXCIgOiBcIm5vbmVcIiwgXCJ6LWluZGV4XCIgOiBcIjMxXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsIFwiYm9yZGVyXCI6IFwic29saWQgYmxhY2sgMXB4XCIgfX0+XHJcbiAgICAgICAgICAgIDxkaXYga2V5PVwiMFwiIHN0eWxlcz17eyBcImRpc3BsYXlcIjogXCJmbGV4XCIsIFwiZmxleC1mbG93XCI6IFwicm93IG5vd3JhcFwiLCBcIm1pbi13aWR0aFwiOiBcIjI1MHB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgc3R5bGVzPXt7IFwiZmxleFwiOiBcIjEgMCAxMCVcIiwgXCJ3aWR0aFwiOiBcIjEwJVwiLCBcIm1pbi13aWR0aFwiOiBcIjEwJVwiIH19IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmNhbmNlbFNlbGVjdFN0eWxlVmFsdWVGb3JJbnRlcmFjdGlvblRhcmdldENsaWNrSGFuZGxlcn0+eDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBrZXk9XCIxXCIgc3R5bGVzPXt7IFwiZGlzcGxheVwiOiBcImZsZXhcIiwgXCJmbGV4LWZsb3dcIjogXCJyb3cgd3JhcFwiIH19PlxyXG4gICAgICAgICAgICAgICAge3JlbmRlcmVkT3B0aW9uc31cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2VsZWN0U3R5bGVWYWx1ZUZvckludGVyYWN0aW9uVGFyZ2V0Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmNsb3NlUG9wdXAoKTtcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuQ3JlYXRlU3R5bGVWYWx1ZUludGVyYWN0aW9uSnNvbih0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRMYXlvdXRTdHlsZUludGVyYWN0aW9uLCBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJ2aWRcIiksIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzVmFsdWVGb3JJbnRlcmFjdGlvbikuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY2FuY2VsU2VsZWN0U3R5bGVWYWx1ZUZvckludGVyYWN0aW9uVGFyZ2V0Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmNsb3NlUG9wdXAoKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRMYXlvdXRCYXNlSWRGb3JGaWx0ZXIgPSAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZExheW91dFN0eWxlSW50ZXJhY3Rpb24gPSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyTWF0Y2hpbmdRdWFudHVtc1BvcHVwID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICBsZXQgaXNQb3B1cFZpc2libGU6IGJvb2xlYW4gPSB0aGlzLnZpZXdNb2RlbC5jdXJyZW50UG9wdXBNb2RlID09PSBQb3B1cE1vZGUuTWF0Y2hpbmdRdWFudHVtcztcclxuICAgICAgICBsZXQgcmVuZGVyZWRPcHRpb25zOiBWTm9kZVtdID0gW107XHJcbiAgICAgICAgaWYgKGlzUG9wdXBWaXNpYmxlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZVF1YW50dW1zLm1hcChxdWFudHVtID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBpc01hdGNoaW5nUHJvcGVydHk6IGJvb2xlYW4gPSBxdWFudHVtLkNzc1Byb3BlcnR5ID09PSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1Byb3BlcnR5TmFtZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc01hdGNoaW5nUHJvcGVydHkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZE9wdGlvbnMucHVzaCg8ZGl2IGtleT17cXVhbnR1bS5TdHlsZVF1YW50dW1JZH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtxdWFudHVtLk5hbWV9ID0ge3F1YW50dW0uQ3NzVmFsdWV9IDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiBxaWQ9e3F1YW50dW0uU3R5bGVRdWFudHVtSWQudG9TdHJpbmcoKX0gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2V0UXVhbnR1bU9uQXRvbUNsaWNrSGFuZGxlcn0+JiMxMDAwNDs8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gYXMgVk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHJlbmRlcmVkT3B0aW9ucy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZWRPcHRpb25zLnB1c2goPGRpdiBrZXk9XCIwXCI+Tm8gcXVhbnR1bXMgYXZhaWxhYmxlLjwvZGl2PiBhcyBWTm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDxkaXYgaWQ9e2Ake3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXh9UG9wdXBNb2RlJHtQb3B1cE1vZGVbUG9wdXBNb2RlLk1hdGNoaW5nUXVhbnR1bXNdfWB9IHN0eWxlcz17eyBcImRpc3BsYXlcIjogaXNQb3B1cFZpc2libGUgPyBcImJsb2NrXCIgOiBcIm5vbmVcIiwgXCJ6LWluZGV4XCIgOiBcIjMxXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsIFwiYm9yZGVyXCI6IFwic29saWQgYmxhY2sgMXB4XCIsIFwiaGVpZ2h0XCI6IFwiMzAwcHhcIiwgXCJvdmVyZmxvd1wiOiBcInNjcm9sbFwiIH19PlxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlcz17eyBcImRpc3BsYXlcIjogXCJmbGV4XCIsIFwiZmxleC1mbG93XCI6IFwicm93IG5vd3JhcFwiLCBcIm1pbi13aWR0aFwiOiBcIjI1MHB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgc3R5bGVzPXt7IFwiZmxleFwiOiBcIjEgMCAxMCVcIiwgXCJ3aWR0aFwiOiBcIjEwJVwiLCBcIm1pbi13aWR0aFwiOiBcIjEwJVwiIH19IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmNhbmNlbFNlbGVjdE1hdGNoaW5nQ3NzUXVhbnR1bUNsaWNrSGFuZGxlcn0+eDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAge3JlbmRlcmVkT3B0aW9uc31cclxuICAgICAgICA8L2Rpdj4gYXMgVk5vZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjYW5jZWxTZWxlY3RNYXRjaGluZ0Nzc1F1YW50dW1DbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy52aWV3TW9kZWwuY3VycmVudFBvcHVwTW9kZSA9IFBvcHVwTW9kZS5VcGRhdGVDc3NWYWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNldFF1YW50dW1PbkF0b21DbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IHF1YW50dW1JZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwicWlkXCIpO1xyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5BcHBseVN0eWxlUXVhbnR1bVRvQXRvbUpzb24odGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3R5bGVBdG9tSWQsIHF1YW50dW1JZCkuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnJlc2V0VGVtcENzc1Byb3BlcnR5U3RhdGUoKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwubGFzdFVzZWRUZW1wQ3NzVmFsdWUgPSAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlUXVhbnR1bXMuZmluZChxID0+IHEuU3R5bGVRdWFudHVtSWQgPT0gcXVhbnR1bUlkKSBhcyBTdHlsZVF1YW50dW0pLkNzc1ZhbHVlOyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyU3R5bGVNb2xlY3VsZUFycmF5ID0gKHByb3BlcnR5QmFyOiBQcm9wZXJ0eUJhcik6IG1hcXVldHRlLk1hcHBpbmc8U3R5bGVNb2xlY3VsZSwgeyByZW5kZXJNYXF1ZXR0ZTogKCkgPT4gbWFxdWV0dGUuVk5vZGUgfT4gPT4ge1xyXG4gICAgICAgIHJldHVybiBtYXF1ZXR0ZS5jcmVhdGVNYXBwaW5nPFN0eWxlTW9sZWN1bGUsIGFueT4oXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFNlY3Rpb25Tb3VyY2VLZXkoc291cmNlOiBTdHlsZU1vbGVjdWxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlLlN0eWxlTW9sZWN1bGVJZDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlU2VjdGlvblRhcmdldChzb3VyY2U6IFN0eWxlTW9sZWN1bGUpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzb3VyY2VTdHlsZU1vbGVjdWxlSWRTdHJpbmcgPSBzb3VyY2UuU3R5bGVNb2xlY3VsZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlck1hcXVldHRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17c291cmNlU3R5bGVNb2xlY3VsZUlkU3RyaW5nfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdEFuaW1hdGlvbj17cHJvcGVydHlCYXIuc3R5bGVFbGVtZW50RXhpdEFuaW1hdGlvbn0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cD4oI3tzb3VyY2VTdHlsZU1vbGVjdWxlSWRTdHJpbmd9KXtzb3VyY2UuTmFtZX08L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgbWlkPXtzb3VyY2VTdHlsZU1vbGVjdWxlSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLnNlbGVjdFN0eWxlTW9sZWN1bGVDbGlja0hhbmRsZXJ9PkVkaXQ8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+O1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAodXBkYXRlZFNvdXJjZTogU3R5bGVNb2xlY3VsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VTdHlsZU1vbGVjdWxlSWRTdHJpbmcgPSB1cGRhdGVkU291cmNlLlN0eWxlTW9sZWN1bGVJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSB1cGRhdGVkU291cmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNlY3Rpb25UYXJnZXQodXBkYXRlZFNvdXJjZTogU3R5bGVNb2xlY3VsZSwgdGFyZ2V0OiB7IHJlbmRlck1hcXVldHRlKCk6IGFueSwgdXBkYXRlKHVwZGF0ZWRTb3VyY2U6IFN0eWxlTW9sZWN1bGUpOiB2b2lkIH0pIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC51cGRhdGUodXBkYXRlZFNvdXJjZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2VsZWN0U3R5bGVNb2xlY3VsZUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLm5leHRFeGNlcHRMYXN0UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3R5bGVNb2xlY3VsZUlkID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibWlkXCIpO1xyXG4gICAgICAgIHRoaXMubmV4dEV4Y2VwdExhc3RQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdGF0ZU1vZGlmaWVyID0gXCJcIjsgLy8gVE9ETyByZXNldCBzdGF0ZSBvbmx5IHdoZW4gbm90IGF2YWlsYWJsZSBpbiBuZXcgc2VsZWN0ZWQgbW9sZWN1bGVcclxuICAgICAgICB0aGlzLm5leHRFeGNlcHRMYXN0UHJvcGVydHlCYXIudmlld01vZGVsLmN1cnJlbnRQcm9wZXJ0eUJhck1vZGUgPSBQcm9wZXJ0eUJhck1vZGUuU3R5bGVNb2xlY3VsZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGhpZ2hsaWdodExheW91dEJhc2VDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IHRhcmdldExheW91dEJhc2VJZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibGlkXCIpO1xyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLmhpZ2hsaWdodGVkTGF5b3V0QmFzZUlkICE9IHRhcmdldExheW91dEJhc2VJZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmhpZ2hsaWdodGVkTGF5b3V0QmFzZUlkID0gdGFyZ2V0TGF5b3V0QmFzZUlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5oaWdobGlnaHRlZExheW91dEJhc2VJZCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyU3R5bGVRdWFudHVtQXJyYXkgPSAocHJvcGVydHlCYXI6IFByb3BlcnR5QmFyKTogbWFxdWV0dGUuTWFwcGluZzxTdHlsZVF1YW50dW0sIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+ID0+IHtcclxuICAgICAgICByZXR1cm4gbWFxdWV0dGUuY3JlYXRlTWFwcGluZzxTdHlsZVF1YW50dW0sIGFueT4oXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFNlY3Rpb25Tb3VyY2VLZXkoc291cmNlOiBTdHlsZVF1YW50dW0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2UuU3R5bGVRdWFudHVtSWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb25UYXJnZXQoc291cmNlOiBTdHlsZVF1YW50dW0pIHtcclxuICAgICAgICAgICAgICAgIGxldCBzb3VyY2VJZFN0cmluZyA9IHNvdXJjZS5TdHlsZVF1YW50dW1JZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJNYXF1ZXR0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPGRpdiBrZXk9e3NvdXJjZUlkU3RyaW5nfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdEFuaW1hdGlvbj17cHJvcGVydHlCYXIuc3R5bGVFbGVtZW50RXhpdEFuaW1hdGlvbn0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBrZXk9XCIwXCIgc3R5bGVzPXt7XCJtYXJnaW5cIjpcIjBcIn19Pigje3NvdXJjZUlkU3RyaW5nfSl7c291cmNlLk5hbWV9OiB7c291cmNlLkNzc1Byb3BlcnR5fSA9PiB7c291cmNlLkNzc1ZhbHVlfTwvcD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiBxaWQ9e3NvdXJjZUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5kdXBsaWNhdGVTdHlsZVF1YW50dW1DbGlja0hhbmRsZXJ9PkREPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c291cmNlLklzRGVsZXRhYmxlID8gPGJ1dHRvbiBrZXk9XCJiMFwiIHJvbGU9XCJidXR0b25cIiBxaWQ9e3NvdXJjZUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5kZWxldGVTdHlsZVF1YW50dW1DbGlja0hhbmRsZXJ9Plg8L2J1dHRvbj4gOiA8YnV0dG9uIGRpc2FibGVkIGtleT1cImIxXCIgcm9sZT1cImJ1dHRvblwiPlg8L2J1dHRvbj59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImNcIiByb2xlPVwiYnV0dG9uXCIgcWlkPXtzb3VyY2VJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIudXBkYXRlQ3NzUXVhbnR1bUNsaWNrSGFuZGxlcn0+RWRpdDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj47XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICh1cGRhdGVkU291cmNlOiBTdHlsZVF1YW50dW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlSWRTdHJpbmcgPSB1cGRhdGVkU291cmNlLlN0eWxlUXVhbnR1bUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHVwZGF0ZWRTb3VyY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlU2VjdGlvblRhcmdldCh1cGRhdGVkU291cmNlOiBTdHlsZVF1YW50dW0sIHRhcmdldDogeyByZW5kZXJNYXF1ZXR0ZSgpOiBhbnksIHVwZGF0ZSh1cGRhdGVkU291cmNlOiBTdHlsZVF1YW50dW0pOiB2b2lkIH0pIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC51cGRhdGUodXBkYXRlZFNvdXJjZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgdXBkYXRlQ3NzUXVhbnR1bUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgc3R5bGVRdWFudHVtSWQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcInFpZFwiKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZVF1YW50dW1JZCA9IHN0eWxlUXVhbnR1bUlkO1xyXG4gICAgICAgIGxldCB0YXJnZXRTdHlsZVF1YW50dW06IFN0eWxlUXVhbnR1bSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZVF1YW50dW1zLmZpbmQodmFsID0+IHZhbC5TdHlsZVF1YW50dW1JZCA9PSBzdHlsZVF1YW50dW1JZCkgYXMgU3R5bGVRdWFudHVtO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzVmFsdWUgPSB0YXJnZXRTdHlsZVF1YW50dW0uQ3NzVmFsdWU7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZGlzcGxheVBvcHVwKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsIFBvcHVwTW9kZS5VcGRhdGVDc3NRdWFudHVtKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGRlbGV0ZVN0eWxlUXVhbnR1bUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuRGVsZXRlU3R5bGVRdWFudHVtSnNvbihwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJxaWRcIikpLmRvbmUoZGF0YSA9PiBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGR1cGxpY2F0ZVN0eWxlUXVhbnR1bUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuRHVwbGljYXRlU3R5bGVRdWFudHVtSnNvbihwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJxaWRcIikpLmRvbmUoZGF0YSA9PiBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHN0eWxlRWxlbWVudEV4aXRBbmltYXRpb24gPSAoZG9tTm9kZTogSFRNTEVsZW1lbnQsIHJlbW92ZUVsZW1lbnQ6ICgpID0+IHZvaWQsIHByb3BlcnRpZXM/OiBtYXF1ZXR0ZS5WTm9kZVByb3BlcnRpZXMpID0+IHtcclxuICAgICAgICBkb21Ob2RlLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcclxuICAgICAgICB2ZWxvY2l0eS5hbmltYXRlKGRvbU5vZGUsIHsgb3BhY2l0eTogMC41LCBoZWlnaHQ6IDAgfSwgeyBkdXJhdGlvbjogMTAwLCBlYXNpbmc6IFwiZWFzZS1vdXRcIiwgY29tcGxldGU6IHJlbW92ZUVsZW1lbnQgfSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBwdWJsaWMgcmVuZGVyTGF5b3V0TW9sZWN1bGVBcnJheSA9IChwcm9wZXJ0eUJhcjogUHJvcGVydHlCYXIpOiBtYXF1ZXR0ZS5NYXBwaW5nPExheW91dEJhc2UsIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+ID0+IHtcclxuICAgICAgICByZXR1cm4gbWFxdWV0dGUuY3JlYXRlTWFwcGluZzxMYXlvdXRCYXNlLCBhbnk+KFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRTZWN0aW9uU291cmNlS2V5KHNvdXJjZTogTGF5b3V0QmFzZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEga2V5IHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGVhY2ggaXRlbSBpbiB0aGUgZGF0YVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5MYXlvdXRCYXNlSWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb25UYXJnZXQoc291cmNlOiBMYXlvdXRCYXNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIHRhcmdldCBiYXNlZCBvbiB0aGUgc291cmNlIFxyXG4gICAgICAgICAgICAgICAgLy8gKHRoZSBzYW1lIGZ1bmN0aW9uIHRoYXQgeW91IHVzZSBpbiBBcnJheS5tYXApXHJcbiAgICAgICAgICAgICAgICBsZXQgc291cmNlTGF5b3V0QmFzZUlkU3RyaW5nID0gc291cmNlLkxheW91dEJhc2VJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZVN0eWxlTW9sZWN1bGVJZFN0cmluZyA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChtID0+IG0uU3R5bGVGb3JMYXlvdXRJZCA9PSBzb3VyY2UuTGF5b3V0QmFzZUlkKSBhcyBTdHlsZU1vbGVjdWxlKS5TdHlsZU1vbGVjdWxlSWQudG9TdHJpbmcoKTsgLy8gVE9ETyBleHBlbnNpdmVcclxuICAgICAgICAgICAgICAgIGxldCBsYXlvdXRDb250cm9sQnV0dG9uU3R5bGVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLXJpZ2h0XCI6IFwiNXB4XCJcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlck1hcXVldHRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZXNjcmlwdGlvbjogc3RyaW5nIHwgdW5kZWZpbmVkID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5MYXlvdXRUeXBlID09PSBMYXlvdXRUeXBlLkF0b20pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzb3VyY2VMYXlvdXRBdG9tOiBMYXlvdXRBdG9tID0gKHNvdXJjZSBhcyBMYXlvdXRBdG9tKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0Q29udGVudFN0cmluZzogc3RyaW5nID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VMYXlvdXRBdG9tLkhvc3RlZENvbnRlbnRBdG9tLkNvbnRlbnRBdG9tVHlwZSA9PT0gQ29udGVudEF0b21UeXBlLlRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Q29udGVudFN0cmluZyA9IHNvdXJjZUxheW91dEF0b20uSG9zdGVkQ29udGVudEF0b20uVGV4dENvbnRlbnQgYXMgc3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc291cmNlTGF5b3V0QXRvbS5Ib3N0ZWRDb250ZW50QXRvbS5Db250ZW50QXRvbVR5cGUgPT09IENvbnRlbnRBdG9tVHlwZS5MaW5rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENvbnRlbnRTdHJpbmcgPSBzb3VyY2VMYXlvdXRBdG9tLkhvc3RlZENvbnRlbnRBdG9tLlVybCBhcyBzdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9IHRleHRDb250ZW50U3RyaW5nLmxlbmd0aCA+IDIwID8gdGV4dENvbnRlbnRTdHJpbmcuc3Vic3RyaW5nKDAsIDIwKSArIFwiLi4uXCIgOiB0ZXh0Q29udGVudFN0cmluZzsgLy8gVE9ETyBleHBlbnNpdmUgLy8gVE9ETyBlbGxpcHNpcyAvLyBUT0RPIG11bHRpcGxlIHBsYWNlcyAvLyBUT0RPIGNyZWF0ZSB3aGVuIHN0b3JpbmcgaW4gREI/IG9yIHdoZW4gbG9hZGluZyBpbiBjbGllbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uICs9IGAgaW4gYm94ICMkeyhzb3VyY2UgYXMgTGF5b3V0QXRvbSkuUGxhY2VkQXRvbUluQm94SWR9YFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gaGlkZSBsYXlvdXQgbW9sZWN1bGVzLCB3aGVyZSBzdHlsZSBtb2xlY3VsZSBpcyBpbnRlcm5hbCBzdHlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPGRpdiBrZXk9e3NvdXJjZUxheW91dEJhc2VJZFN0cmluZ30+IHtMYXlvdXRUeXBlW3NvdXJjZS5MYXlvdXRUeXBlXS50b1N0cmluZygpfSAje3NvdXJjZUxheW91dEJhc2VJZFN0cmluZ30ge2Rlc2NyaXB0aW9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIGxpZD17c291cmNlTGF5b3V0QmFzZUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5zZWxlY3RMYXlvdXRCYXNlQ2xpY2tIYW5kbGVyfSBzdHlsZXM9e2xheW91dENvbnRyb2xCdXR0b25TdHlsZXN9Pj88L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYlwiIHJvbGU9XCJidXR0b25cIiBtaWQ9e3NvdXJjZVN0eWxlTW9sZWN1bGVJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuc2VsZWN0U3R5bGVNb2xlY3VsZUNsaWNrSGFuZGxlcn0gc3R5bGVzPXtsYXlvdXRDb250cm9sQnV0dG9uU3R5bGVzfT5TPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImNcIiByb2xlPVwiYnV0dG9uXCIgbGlkPXtzb3VyY2VMYXlvdXRCYXNlSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmRlbGV0ZUxheW91dEJhc2VDbGlja0hhbmRsZXJ9IHN0eWxlcz17bGF5b3V0Q29udHJvbEJ1dHRvblN0eWxlc30+WDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj47XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICh1cGRhdGVkU291cmNlOiBMYXlvdXRCYXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHVwZGF0ZWRTb3VyY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUxheW91dEJhc2VJZFN0cmluZyA9IHNvdXJjZS5MYXlvdXRCYXNlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNvdXJjZVN0eWxlTW9sZWN1bGVJZFN0cmluZyA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChtID0+IG0uU3R5bGVGb3JMYXlvdXRJZCA9PSBzb3VyY2UuTGF5b3V0QmFzZUlkKSBhcyBTdHlsZU1vbGVjdWxlKS5TdHlsZU1vbGVjdWxlSWQudG9TdHJpbmcoKTsgLy8gVE9ETyBleHBlbnNpdmVcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVTZWN0aW9uVGFyZ2V0KHVwZGF0ZWRTb3VyY2U6IExheW91dEJhc2UsIHRhcmdldDogeyByZW5kZXJNYXF1ZXR0ZSgpOiBhbnksIHVwZGF0ZSh1cGRhdGVkU291cmNlOiBMYXlvdXRCYXNlKTogdm9pZCB9KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIHVwZGF0ZSB0aGUgY29tcG9uZW50IHdpdGggdGhlIHVwZGF0ZWQgaXRlbVxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnVwZGF0ZSh1cGRhdGVkU291cmNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJDYWxpZm9ybmlhVmlld0FycmF5ID0gKHByb3BlcnR5QmFyOiBQcm9wZXJ0eUJhcik6IG1hcXVldHRlLk1hcHBpbmc8Q2FsaWZvcm5pYVZpZXcsIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+ID0+IHtcclxuICAgICAgICByZXR1cm4gbWFxdWV0dGUuY3JlYXRlTWFwcGluZzxDYWxpZm9ybmlhVmlldywgYW55PihcclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U2VjdGlvblNvdXJjZUtleShzb3VyY2U6IENhbGlmb3JuaWFWaWV3KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBrZXkgdG8gdW5pcXVlbHkgaWRlbnRpZnkgZWFjaCBpdGVtIGluIHRoZSBkYXRhXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlLkNhbGlmb3JuaWFWaWV3SWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb25UYXJnZXQoc291cmNlOiBDYWxpZm9ybmlhVmlldykge1xyXG4gICAgICAgICAgICAgICAgLy8gZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSB0YXJnZXQgYmFzZWQgb24gdGhlIHNvdXJjZSBcclxuICAgICAgICAgICAgICAgIC8vICh0aGUgc2FtZSBmdW5jdGlvbiB0aGF0IHlvdSB1c2UgaW4gQXJyYXkubWFwKVxyXG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZUNhbGlmb3JuaWFWaWV3SWRTdHJpbmcgPSBzb3VyY2UuQ2FsaWZvcm5pYVZpZXdJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJNYXF1ZXR0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXNEZWxldGVCdXR0b25FbmFibGVkOiBib29sZWFuID0gc291cmNlLlBsYWNlZExheW91dFJvd3MubGVuZ3RoID09IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17c291cmNlQ2FsaWZvcm5pYVZpZXdJZFN0cmluZ30+e3NvdXJjZS5OYW1lfSBWaWV3ICN7c291cmNlQ2FsaWZvcm5pYVZpZXdJZFN0cmluZ31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiB2aWQ9e3NvdXJjZUNhbGlmb3JuaWFWaWV3SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLnNlbGVjdENhbGlmb3JuaWFWaWV3Q2xpY2tIYW5kbGVyfT46KTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyghc291cmNlLklzSW50ZXJuYWwgJiYgc291cmNlLkNhbGlmb3JuaWFWaWV3SWQgIT0gY3VycmVudEFwcC5wYWdlUHJldmlldy52aWV3TW9kZWwuYWN0aXZlQ2FsaWZvcm5pYVZpZXdJZCkgPyA8YnV0dG9uIGtleT1cImJcIiByb2xlPVwiYnV0dG9uXCIgdmlkPXtzb3VyY2VDYWxpZm9ybmlhVmlld0lkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5hY3RpdmF0ZUNhbGlmb3JuaWFWaWV3Q2xpY2tIYW5kbGVyfT4mIzEwMDA0OzwvYnV0dG9uPiA6IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge3NvdXJjZS5Jc0ludGVybmFsID8gXCJpbnRlcm5hbFwiIDogdW5kZWZpbmVkfSB7c291cmNlLk5hbWV9IGhvc3RlZCBieSB7c291cmNlLkhvc3RlZEJ5TGF5b3V0TWFwcGluZ3MubGVuZ3RofSBsYXlvdXRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImNcIiByb2xlPVwiYnV0dG9uXCIgbWlkPXtzb3VyY2UuU3BlY2lhbFN0eWxlVmlld1N0eWxlTW9sZWN1bGVJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuc2VsZWN0U3R5bGVNb2xlY3VsZUNsaWNrSGFuZGxlcn0+c3R5bGUgI3tzb3VyY2UuU3BlY2lhbFN0eWxlVmlld1N0eWxlTW9sZWN1bGVJZFN0cmluZ308L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiZFwiIHJvbGU9XCJidXR0b25cIiBtaWQ9e3NvdXJjZS5TcGVjaWFsU3R5bGVCb2R5U3R5bGVNb2xlY3VsZUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5zZWxlY3RTdHlsZU1vbGVjdWxlQ2xpY2tIYW5kbGVyfT5ib2R5IHN0eWxlICN7c291cmNlLlNwZWNpYWxTdHlsZUJvZHlTdHlsZU1vbGVjdWxlSWRTdHJpbmd9PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImVcIiByb2xlPVwiYnV0dG9uXCIgbWlkPXtzb3VyY2UuU3BlY2lhbFN0eWxlSHRtbFN0eWxlTW9sZWN1bGVJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuc2VsZWN0U3R5bGVNb2xlY3VsZUNsaWNrSGFuZGxlcn0+SFRNTCBzdHlsZSAje3NvdXJjZS5TcGVjaWFsU3R5bGVIdG1sU3R5bGVNb2xlY3VsZUlkU3RyaW5nfTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2lzRGVsZXRlQnV0dG9uRW5hYmxlZCA/IDxidXR0b24ga2V5PVwiZlwiIHJvbGU9XCJidXR0b25cIiB2aWQ9e3NvdXJjZUNhbGlmb3JuaWFWaWV3SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmRlbGV0ZUNhbGlmb3JuaWFWaWV3Q2xpY2tIYW5kbGVyfT5YPC9idXR0b24+IDogPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJjMFwiIHJvbGU9XCJidXR0b25cIiBvbmNsaWNrPXtwcm9wZXJ0eUJhci5kZWxldGVDYWxpZm9ybmlhVmlld0NsaWNrSGFuZGxlcn0+WDwvYnV0dG9uPn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+O1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAodXBkYXRlZFNvdXJjZTogQ2FsaWZvcm5pYVZpZXcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gdXBkYXRlZFNvdXJjZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQ2FsaWZvcm5pYVZpZXdJZFN0cmluZyA9IHNvdXJjZS5DYWxpZm9ybmlhVmlld0lkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlU2VjdGlvblRhcmdldCh1cGRhdGVkU291cmNlOiBDYWxpZm9ybmlhVmlldywgdGFyZ2V0OiB7IHJlbmRlck1hcXVldHRlKCk6IGFueSwgdXBkYXRlKHVwZGF0ZWRTb3VyY2U6IENhbGlmb3JuaWFWaWV3KTogdm9pZCB9KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIHVwZGF0ZSB0aGUgY29tcG9uZW50IHdpdGggdGhlIHVwZGF0ZWQgaXRlbVxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnVwZGF0ZSh1cGRhdGVkU291cmNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBsb2dvdXRQb3B1cENsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5kaXNwbGF5UG9wdXAoZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgUG9wdXBNb2RlLlNoYXJlQ2FsaWZvcm5pYVByb2plY3QpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyU2hhcmVDYWxpZm9ybmlhUHJvamVjdFBvcHVwID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICAvLyBUT0RPIG11bHRpbGFuZ3VhZ2Ugd2hlcmUgdGV4dCBzdHJpbmdzIGFyZSBldmVyeXdoZXJlXHJcbiAgICAgICAgbGV0IGlzUG9wdXBWaXNpYmxlOiBib29sZWFuID0gdGhpcy52aWV3TW9kZWwuY3VycmVudFBvcHVwTW9kZSA9PT0gUG9wdXBNb2RlLlNoYXJlQ2FsaWZvcm5pYVByb2plY3Q7IC8vIFRPRE8gc2hvcnRlbiBpZHMgZXZlcnl3aGVyZVxyXG4gICAgICAgIHJldHVybiA8ZGl2IGlkPXtgJHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5wcm9wZXJ0eUJhckluZGV4fVBvcHVwTW9kZSR7UG9wdXBNb2RlW1BvcHVwTW9kZS5TaGFyZUNhbGlmb3JuaWFQcm9qZWN0XX1gfSBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IGlzUG9wdXBWaXNpYmxlID8gXCJibG9ja1wiIDogXCJub25lXCIsIFwiei1pbmRleFwiIDogXCIzMVwiLCBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLCBcImJvcmRlclwiOiBcInNvbGlkIGJsYWNrIDFweFwiIH19PlxyXG4gICAgICAgICAgICA8ZGl2IGtleT1cIjBcIiBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IFwiZmxleFwiLCBcImZsZXgtZmxvd1wiOiBcInJvdyBub3dyYXBcIiwgXCJtaW4td2lkdGhcIjogXCIyNTBweFwiIH19PlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJiXCIgc3R5bGVzPXt7IFwiZmxleFwiOiBcIjEgMCAxMCVcIiwgXCJ3aWR0aFwiOiBcIjEwJVwiLCBcIm1pbi13aWR0aFwiOiBcIjEwJVwiIH19IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmNhbmNlbFNoYXJlQ2FsaWZvcm5pYVByb2plY3RDbGlja0hhbmRsZXJ9Png8L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYga2V5PVwiMVwiIHN0eWxlcz17eyBcImRpc3BsYXlcIjogXCJmbGV4XCIsIFwiZmxleC1mbG93XCI6IFwicm93IHdyYXBcIiB9fT5cclxuICAgICAgICAgICAgICAgIDxwIGtleT1cImFcIiBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMCAwIDEwMCVcIiwgXCJ3aWR0aFwiOiBcIjEwMCVcIiwgXCJtaW4td2lkdGhcIjogXCIxMDAlXCIgfX0+e2N1cnJlbnRBcHAuY2xpZW50RGF0YS5VcmxUb1JlYWRPbmx5fTwvcD5cclxuICAgICAgICAgICAgICAgIHsvKiBUT0RPIDxwIGtleT1cImJcIj57Y3VycmVudEFwcC5jbGllbnREYXRhLlVybFRvUmVhZEFuZEVkaXR9PC9wPiovfVxyXG4gICAgICAgICAgICAgICAgQm9va21hcmshIENsZWFyIGJyb3dzZXIgaGlzdG9yeSFcclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiY1wiIHR5cGU9XCJidXR0b25cIiBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5sb2dvdXRDbGlja0hhbmRsZXJ9IHN0eWxlcz17eyBcImZsZXhcIjogXCIwIDAgMTAlXCIsIFwid2lkdGhcIjogXCIxMCVcIiwgXCJtaW4td2lkdGhcIjogXCIxMCVcIiB9fT4mIzEyODI3NDs8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiZFwiIHR5cGU9XCJidXR0b25cIiBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci50b2t5b0NsaWNrSGFuZGxlcn0gc3R5bGVzPXt7IFwiZmxleFwiOiBcIjAgMCAxMCVcIiwgXCJ3aWR0aFwiOiBcIjEwJVwiLCBcIm1pbi13aWR0aFwiOiBcIjEwJVwiIH19PlRPS1lPPC9idXR0b24+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHRva3lvQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24od2luZG93LmxvY2F0aW9uLm9yaWdpbiArIFwiL3Rva3lvL1wiKTsgLy8gVE9ETyBoYXJkY29kZWQgbGlua1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY2FuY2VsU2hhcmVDYWxpZm9ybmlhUHJvamVjdENsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jbG9zZVBvcHVwKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBsb2dvdXRDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLkxvZ291dEFjdGlvbigpLmRvbmUoKHJlc3BvbnNlOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgXCIvY2FsaWZvcm5pYS9cIik7IC8vIFRPRE8gaGFyZGNvZGVkIGxpbmtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGFjdGl2YXRlQ2FsaWZvcm5pYVZpZXdDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IGNhbGlmb3JuaWFWaWV3SWQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcInZpZFwiKTtcclxuICAgICAgICBsZXQgdXNlclBhZ2VzOiBDYWxpZm9ybmlhVmlld1tdID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFWaWV3cy5maWx0ZXIodmlldyA9PiAhdmlldy5Jc0ludGVybmFsKTtcclxuICAgICAgICBsZXQgYWN0aXZlVmlldzogQ2FsaWZvcm5pYVZpZXcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IGFjdGl2ZVBhZ2VJbmRleDogbnVtYmVyID0gdXNlclBhZ2VzLmZpbmRJbmRleCh2ID0+IHYuQ2FsaWZvcm5pYVZpZXdJZCA9PSBjYWxpZm9ybmlhVmlld0lkKTtcclxuICAgICAgICBpZiAoYWN0aXZlUGFnZUluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgYWN0aXZlVmlldyA9IHVzZXJQYWdlc1thY3RpdmVQYWdlSW5kZXhdO1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnJvdXRlci5zZXRBY3RpdmVDYWxpZm9ybmlhVmlldyhhY3RpdmVWaWV3KTtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5wYWdlUHJldmlldy5yZXNldEVxdWF0aW9uTnVtYmVyc1doZW5Nb2RpZnlpbmcodHJ1ZSk7IC8vIFRPRE8gdGVzdFxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2V0U2VsZWN0ZWRDYWxpZm9ybmlhVmlldyhhY3RpdmVWaWV3LCB0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuY3VycmVudFByb3BlcnR5QmFyTW9kZSA9IFByb3BlcnR5QmFyTW9kZS5DYWxpZm9ybmlhVmlldzsgLy8gVE9ETyBldmVyeXdoZXJlOiB0aGlzLnZpZU1vZGVsIG9yIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNlbGVjdExheW91dEJhc2VDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IGxheW91dEJhc2VJZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibGlkXCIpOyAvLyBUT0RPIGV2ZXJ5d2hlcmU6IHVzZSBiYWNrZW5kIHZhbHVlIGluc3RlYWQgb2YgcGFyc2luZyB3aGVyZSBwb3NzaWJsZSA9PiBzYXZlcyBtdWx0aXBsZSBzdHJpbmdzXHJcbiAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5zZWxlY3RlZExheW91dEJhc2VJZCA9IGxheW91dEJhc2VJZDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuY3VycmVudFByb3BlcnR5QmFyTW9kZSA9IFByb3BlcnR5QmFyTW9kZS5MYXlvdXRCYXNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2VsZWN0Q2FsaWZvcm5pYVZpZXdDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IGNhbGlmb3JuaWFWaWV3SWQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcInZpZFwiKTtcclxuICAgICAgICBsZXQgdXNlclBhZ2VzOiBDYWxpZm9ybmlhVmlld1tdID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFWaWV3cy5maWx0ZXIodmlldyA9PiAhdmlldy5Jc0ludGVybmFsKTtcclxuICAgICAgICBsZXQgYWN0aXZlVmlldzogQ2FsaWZvcm5pYVZpZXcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IGFjdGl2ZVBhZ2VJbmRleDogbnVtYmVyID0gdXNlclBhZ2VzLmZpbmRJbmRleCh2ID0+IHYuQ2FsaWZvcm5pYVZpZXdJZCA9PSBjYWxpZm9ybmlhVmlld0lkKTtcclxuICAgICAgICBpZiAoYWN0aXZlUGFnZUluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgYWN0aXZlVmlldyA9IHVzZXJQYWdlc1thY3RpdmVQYWdlSW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UHJvcGVydHlCYXIucHJvcGVydHlCYXJJbmRleCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnJvdXRlci5zZXRBY3RpdmVDYWxpZm9ybmlhVmlldyhhY3RpdmVWaWV3KTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucGFnZVByZXZpZXcucmVzZXRFcXVhdGlvbk51bWJlcnNXaGVuTW9kaWZ5aW5nKHRydWUpOyAvLyBUT0RPIHRlc3RcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5pc1N5bmNlZFdpdGhCb3hUcmVlVG9UaGVMZWZ0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNldFNlbGVjdGVkQ2FsaWZvcm5pYVZpZXcoYWN0aXZlVmlldywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5jdXJyZW50UHJvcGVydHlCYXJNb2RlID0gUHJvcGVydHlCYXJNb2RlLkNhbGlmb3JuaWFWaWV3O1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgZGVsZXRlTGF5b3V0QmFzZUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCAhPSAwKSB7IC8vIFRPRE8gZG9jdW1lbnQgLy8gVE9ETyBkaXNhYmxlIGJ1dHRvblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuc2VsZWN0ZWRMYXlvdXRCYXNlSWQgPSAwO1xyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5EZWxldGVMYXlvdXRKc29uKHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImxpZFwiKSwgZmFsc2UpLmRvbmUoZGF0YSA9PiBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGRlbGV0ZUJlbG93TGF5b3V0QmFzZUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCAhPSAwKSB7IC8vIFRPRE8gZG9jdW1lbnQgLy8gVE9ETyBkaXNhYmxlIGJ1dHRvblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuc2VsZWN0ZWRMYXlvdXRCYXNlSWQgPSAwO1xyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5EZWxldGVMYXlvdXRKc29uKHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImxpZFwiKSwgdHJ1ZSkuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyTGF5b3V0QmFzZUNvbnRyb2xzID0gKCk6IFZOb2RlIHwgdW5kZWZpbmVkID0+IHtcclxuICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5zZWxlY3RlZExheW91dEJhc2VJZCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBzZWxlY3RlZExheW91dEJhc2U6IExheW91dEJhc2UgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuTGF5b3V0TW9sZWN1bGVzLmZpbmQobCA9PiBsLkxheW91dEJhc2VJZCA9PSBjdXJyZW50QXBwLnN0YXRlLnNlbGVjdGVkTGF5b3V0QmFzZUlkKSBhcyBMYXlvdXRCYXNlO1xyXG4gICAgICAgIGxldCBsYXlvdXRCYXNlSWRTdHJpbmc6IHN0cmluZyA9IHNlbGVjdGVkTGF5b3V0QmFzZS5MYXlvdXRCYXNlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICBsZXQgc291cmNlU3R5bGVNb2xlY3VsZUlkU3RyaW5nOiBzdHJpbmcgPSAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlTW9sZWN1bGVzLmZpbmQobSA9PiBtLlN0eWxlRm9yTGF5b3V0SWQgPT0gc2VsZWN0ZWRMYXlvdXRCYXNlLkxheW91dEJhc2VJZCkgYXMgU3R5bGVNb2xlY3VsZSkuU3R5bGVNb2xlY3VsZUlkLnRvU3RyaW5nKCk7IC8vIFRPRE8gZXhwZW5zaXZlXHJcbiAgICAgICAgaWYgKHNlbGVjdGVkTGF5b3V0QmFzZS5MYXlvdXRUeXBlID09PSBMYXlvdXRUeXBlLkF0b20pIHtcclxuICAgICAgICAgICAgbGV0IHNlbGVjdGVkTGF5b3V0QXRvbTogTGF5b3V0QXRvbSA9IHNlbGVjdGVkTGF5b3V0QmFzZSBhcyBMYXlvdXRBdG9tO1xyXG4gICAgICAgICAgICBsZXQgaXNQaWN0dXJlQ29udGVudDogYm9vbGVhbiA9IHNlbGVjdGVkTGF5b3V0QXRvbS5Ib3N0ZWRDb250ZW50QXRvbS5Db250ZW50QXRvbVR5cGUgPT09IENvbnRlbnRBdG9tVHlwZS5QaWN0dXJlO1xyXG4gICAgICAgICAgICBsZXQgcGljdHVyZUNvbnRlbnRJZFN0cmluZzogc3RyaW5nIHwgdW5kZWZpbmVkID0gaXNQaWN0dXJlQ29udGVudCA/IHNlbGVjdGVkTGF5b3V0QXRvbS5Ib3N0ZWRDb250ZW50QXRvbS5QaWN0dXJlQ29udGVudC5QaWN0dXJlQ29udGVudElkLnRvU3RyaW5nKCkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17TGF5b3V0VHlwZS5BdG9tfT4gQXRvbTpcclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiBtaWQ9e3NvdXJjZVN0eWxlTW9sZWN1bGVJZFN0cmluZ30gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2VsZWN0U3R5bGVNb2xlY3VsZUNsaWNrSGFuZGxlcn0+c3R5bGUgI3tzb3VyY2VTdHlsZU1vbGVjdWxlSWRTdHJpbmd9PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImJcIiByb2xlPVwiYnV0dG9uXCIgbGlkPXtsYXlvdXRCYXNlSWRTdHJpbmd9IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmRlbGV0ZUxheW91dEJhc2VDbGlja0hhbmRsZXJ9Plg8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiY1wiIHJvbGU9XCJidXR0b25cIiBhaWQ9e2xheW91dEJhc2VJZFN0cmluZ30gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY3JlYXRlTGF5b3V0U3R5bGVJbnRlcmFjdGlvbn0+KyBJbnRlcmFjdGlvbjwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAge3NlbGVjdGVkTGF5b3V0QXRvbS5MYXlvdXRTdHlsZUludGVyYWN0aW9ucy5tYXAoaW50ZXJhY3Rpb24gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbklkU3RyaW5nOiBzdHJpbmcgPSBpbnRlcmFjdGlvbi5MYXlvdXRTdHlsZUludGVyYWN0aW9uSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gPGRpdiBrZXk9e2BpJHtpbnRlcmFjdGlvbklkU3RyaW5nfWB9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cCBrZXk9XCIwXCI+SW50ZXJhY3Rpb24gI3tpbnRlcmFjdGlvbi5MYXlvdXRTdHlsZUludGVyYWN0aW9uSWR9PC9wPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQga2V5PVwiMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDc3NWYWx1ZUZvckludGVyYWN0aW9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25pbnB1dD17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY3NzVmFsdWVGb3JJbnRlcmFjdGlvbklucHV0SGFuZGxlcn0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvaW5wdXQ+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1ZhbHVlRm9ySW50ZXJhY3Rpb24gIT09IFwiXCIgPyA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgbGlkPXtpbnRlcmFjdGlvbklkU3RyaW5nfSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zZWxlY3RJbnRlcmFjdGlvblRhcmdldENsaWNrSGFuZGxlcn0+PzwvYnV0dG9uPiA6IDxidXR0b24gZGlzYWJsZWQga2V5PVwiYTBcIiByb2xlPVwiYnV0dG9uXCIgbGlkPXtpbnRlcmFjdGlvbklkU3RyaW5nfSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zZWxlY3RJbnRlcmFjdGlvblRhcmdldENsaWNrSGFuZGxlcn0+PzwvYnV0dG9uPn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJiXCIgcm9sZT1cImJ1dHRvblwiIGxpZD17aW50ZXJhY3Rpb25JZFN0cmluZ30gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZGVsZXRlTGF5b3V0U3R5bGVJbnRlcmFjdGlvbkNsaWNrSGFuZGxlcn0+WDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7aW50ZXJhY3Rpb24uU3R5bGVWYWx1ZUludGVyYWN0aW9ucy5tYXAobWFwID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtYXBwaW5nSWRTdHJpbmc6IHN0cmluZyA9IG1hcC5TdHlsZVZhbHVlSW50ZXJhY3Rpb25NYXBwaW5nSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17bWFwcGluZ0lkU3RyaW5nfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBrZXk9XCIwXCI+I3ttYXBwaW5nSWRTdHJpbmd9OiB7bWFwLkNzc1ZhbHVlfTwvcD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgdmlkPXttYXAuU3R5bGVWYWx1ZUlkLnRvU3RyaW5nKCl9IGxpZD17aW50ZXJhY3Rpb25JZFN0cmluZ30gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZGVsZXRlU3R5bGVWYWx1ZUludGVyYWN0aW9uQ2xpY2tIYW5kbGVyfT5YPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSl9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICB9KX1cclxuICAgICAgICAgICAgICAgIDxmb3JtIGtleT1cIjBcIiBhY3Rpb249XCJVcGxvYWRGaWxlc1wiIG1ldGhvZD1cInBvc3RcIiBlbmN0eXBlPVwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxwIGtleT1cIjBcIj5waWN0dXJlIGlkICN7cGljdHVyZUNvbnRlbnRJZFN0cmluZ308L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IG11bHRpcGxlIGtleT1cIjFcIiB0eXBlPVwiZmlsZVwiIG5hbWU9XCJmb3JtRmlsZXNcIiBvbmNoYW5nZT17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIudXBsb2FkRmlsZUNoYW5nZUhhbmRsZXJ9PjwvaW5wdXQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIHBpZD17cGljdHVyZUNvbnRlbnRJZFN0cmluZ30gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIudXBsb2FkRmlsZUNsaWNrSGFuZGxlcn0+Li4uPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8L2Zvcm0+XHJcbiAgICAgICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0ZWRMYXlvdXRCYXNlLkxheW91dFR5cGUgPT09IExheW91dFR5cGUuQm94KSB7XHJcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZExheW91dEJveDogTGF5b3V0Qm94ID0gc2VsZWN0ZWRMYXlvdXRCYXNlIGFzIExheW91dEJveDtcclxuICAgICAgICAgICAgbGV0IHNwZWNpYWxMYXlvdXRCb3hUeXBlU2VsZWN0b3JzOiBWTm9kZVtdID0gW107XHJcbiAgICAgICAgICAgIGdldEFycmF5Rm9yRW51bShTcGVjaWFsTGF5b3V0Qm94VHlwZSkubWFwKCh0eXBlOiBzdHJpbmcsIGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBpc0xheW91dEJveFR5cGU6IGJvb2xlYW4gPSBpbmRleCA9PSBzZWxlY3RlZExheW91dEJveC5TcGVjaWFsTGF5b3V0Qm94VHlwZTtcclxuICAgICAgICAgICAgICAgIGxldCBsYXlvdXRCb3hUeXBlU3RyaW5nOiBzdHJpbmcgPSBpbmRleC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgc3BlY2lhbExheW91dEJveFR5cGVTZWxlY3RvcnMucHVzaChpc0xheW91dEJveFR5cGUgPyA8b3B0aW9uIHNlbGVjdGVkIGtleT17bGF5b3V0Qm94VHlwZVN0cmluZ30gdmFsdWU9e2xheW91dEJveFR5cGVTdHJpbmd9Pnt0eXBlfTwvb3B0aW9uPiBhcyBWTm9kZSA6IDxvcHRpb24ga2V5PXtsYXlvdXRCb3hUeXBlU3RyaW5nfSB2YWx1ZT17bGF5b3V0Qm94VHlwZVN0cmluZ30+e3R5cGV9PC9vcHRpb24+IGFzIFZOb2RlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17TGF5b3V0VHlwZS5Cb3h9PiBCb3g6XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgbWlkPXtzb3VyY2VTdHlsZU1vbGVjdWxlSWRTdHJpbmd9IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnNlbGVjdFN0eWxlTW9sZWN1bGVDbGlja0hhbmRsZXJ9PnN0eWxlICN7c291cmNlU3R5bGVNb2xlY3VsZUlkU3RyaW5nfTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJiXCIgcm9sZT1cImJ1dHRvblwiIG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmNyZWF0ZVZpZXdGb3JCb3hDbGlja0hhbmRsZXJ9PkNyZWF0ZSBWaWV3PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImNcIiByb2xlPVwiYnV0dG9uXCIgbGlkPXtsYXlvdXRCYXNlSWRTdHJpbmd9IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmRlbGV0ZUxheW91dEJhc2VDbGlja0hhbmRsZXJ9Plg8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDxzZWxlY3Qga2V5PVwiMFwiIGJpZD17bGF5b3V0QmFzZUlkU3RyaW5nfVxyXG4gICAgICAgICAgICAgICAgICAgIG9uY2hhbmdlPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zcGVjaWFsTGF5b3V0Qm94VHlwZUNoYW5nZWRIYW5kbGVyfT5cclxuICAgICAgICAgICAgICAgICAgICB7c3BlY2lhbExheW91dEJveFR5cGVTZWxlY3RvcnN9XHJcbiAgICAgICAgICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzZWxlY3RlZExheW91dEJhc2UuTGF5b3V0VHlwZSA9PT0gTGF5b3V0VHlwZS5Sb3cpIHtcclxuICAgICAgICAgICAgbGV0IHNlbGVjdGVkTGF5b3V0Um93OiBMYXlvdXRSb3cgPSBzZWxlY3RlZExheW91dEJhc2UgYXMgTGF5b3V0Um93O1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudEJveENvdW50OiBudW1iZXIgPSBzZWxlY3RlZExheW91dFJvdy5BbGxCb3hlc0JlbG93Um93LmZpbHRlcihiID0+IGIuUGxhY2VkQm94SW5Cb3hJZCA9PT0gdW5kZWZpbmVkKS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGxldCBib3hDb3VudFNlbGVjdG9yczogVk5vZGVbXSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAxMjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaXNTZWxlY3RlZDogYm9vbGVhbiA9IGkgPT0gY3VycmVudEJveENvdW50O1xyXG4gICAgICAgICAgICAgICAgbGV0IGJveENvdW50U3RyaW5nOiBzdHJpbmcgPSBpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm94Q291bnRTZWxlY3RvcnMucHVzaChpc1NlbGVjdGVkID8gPG9wdGlvbiBkaXNhYmxlZCBzZWxlY3RlZCBrZXk9e2JveENvdW50U3RyaW5nfSB2YWx1ZT17Ym94Q291bnRTdHJpbmd9Pntib3hDb3VudFN0cmluZ308L29wdGlvbj4gYXMgVk5vZGUgOiA8b3B0aW9uIGRpc2FibGVkIGtleT17Ym94Q291bnRTdHJpbmd9IHZhbHVlPXtib3hDb3VudFN0cmluZ30+e2JveENvdW50U3RyaW5nfTwvb3B0aW9uPiBhcyBWTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBib3hDb3VudFNlbGVjdG9ycy5wdXNoKGlzU2VsZWN0ZWQgPyA8b3B0aW9uIHNlbGVjdGVkIGtleT17Ym94Q291bnRTdHJpbmd9IHZhbHVlPXtib3hDb3VudFN0cmluZ30+e2JveENvdW50U3RyaW5nfTwvb3B0aW9uPiBhcyBWTm9kZSA6IDxvcHRpb24ga2V5PXtib3hDb3VudFN0cmluZ30gdmFsdWU9e2JveENvdW50U3RyaW5nfT57Ym94Q291bnRTdHJpbmd9PC9vcHRpb24+IGFzIFZOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gPGRpdiBrZXk9e0xheW91dFR5cGUuUm93fT4gUm93OlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIG1pZD17c291cmNlU3R5bGVNb2xlY3VsZUlkU3RyaW5nfSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zZWxlY3RTdHlsZU1vbGVjdWxlQ2xpY2tIYW5kbGVyfT5zdHlsZSAje3NvdXJjZVN0eWxlTW9sZWN1bGVJZFN0cmluZ308L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYlwiIHJvbGU9XCJidXR0b25cIiBsaWQ9e2xheW91dEJhc2VJZFN0cmluZ30gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZGVsZXRlTGF5b3V0QmFzZUNsaWNrSGFuZGxlcn0+WDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPHNlbGVjdCBrZXk9XCJjXCIgcmlkPXtsYXlvdXRCYXNlSWRTdHJpbmd9XHJcbiAgICAgICAgICAgICAgICAgICAgb25jaGFuZ2U9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmJveENvdW50SW5Sb3dDaGFuZ2VkSGFuZGxlcn0+XHJcbiAgICAgICAgICAgICAgICAgICAge2JveENvdW50U2VsZWN0b3JzfVxyXG4gICAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyB1cGxvYWRGaWxlQ2hhbmdlSGFuZGxlciA9IChldnQ6IEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgICAgbGV0IGZpbGVTZWxlY3RvcjogSFRNTElucHV0RWxlbWVudCA9IGV2dC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBpZiAoZmlsZVNlbGVjdG9yLmZpbGVzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxldCBmaWxlQXJyYXk6IEZpbGVbXSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCBpbiBmaWxlU2VsZWN0b3IuZmlsZXMpIHtcclxuICAgICAgICAgICAgICAgIGxldCBmaWxlOiBGaWxlID0gZmlsZVNlbGVjdG9yLmZpbGVzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIGZpbGVBcnJheS5wdXNoKGZpbGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZmlsZSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZmlsZVJlYWRlcjogRmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgICAgICAgICBmaWxlUmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZW5kXCIsIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmZpbGVQcm9jZXNzaW5nTG9hZEVuZEhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgLy9maWxlUmVhZGVyLnJlYWRBc1RleHQobmV3IEJsb2IoW2ZpbGVdKSwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmlsZVNlbGVjdG9yLmZpbGVzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImVtcHR5XCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vY3VycmVudEFwcC5jb250cm9sbGVyLlVwbG9hZEZpbGVzQWN0aW9uKGZpbGVBcnJheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInVuZGVmaW5lZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBmaWxlUHJvY2Vzc2luZ0xvYWRFbmRIYW5kbGVyID0gKGV2dDogUHJvZ3Jlc3NFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGV2dC50b3RhbCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coKGV2dC50YXJnZXQgYXMgRmlsZVJlYWRlcikucmVzdWx0KTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHVwbG9hZEZpbGVDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgbGV0IHRhcmdldEZvcm06IEhUTUxGb3JtRWxlbWVudCA9IChldnQudGFyZ2V0IGFzIEhUTUxCdXR0b25FbGVtZW50KS5mb3JtIGFzIEhUTUxGb3JtRWxlbWVudDtcclxuICAgICAgICBjb25zb2xlLmxvZyhcInVwbG9hZCBkaWFsb2cgVE9ET1wiKTtcclxuICAgICAgICBqUXVlcnkuYWpheCh0YXJnZXRGb3JtLmFjdGlvbiwge1xyXG4gICAgICAgICAgICBtZXRob2Q6IHRhcmdldEZvcm0ubWV0aG9kLFxyXG4gICAgICAgICAgICBjb250ZW50VHlwZTogXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIsXHJcbiAgICAgICAgICAgIGRhdGE6ICQodGFyZ2V0Rm9ybSkuc2VyaWFsaXplKClcclxuICAgICAgICB9IGFzIEpRdWVyeUFqYXhTZXR0aW5ncyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzZWxlY3RJbnRlcmFjdGlvblRhcmdldENsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRMYXlvdXRTdHlsZUludGVyYWN0aW9uID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibGlkXCIpOyAvLyBUT0RPIGhhY2tcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5kaXNwbGF5UG9wdXAoZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgUG9wdXBNb2RlLlNlbGVjdEludGVyYWN0aW9uVGFyZ2V0KTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGRlbGV0ZVN0eWxlVmFsdWVJbnRlcmFjdGlvbkNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuRGVsZXRlU3R5bGVWYWx1ZUludGVyYWN0aW9uSnNvbihwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJsaWRcIiksIHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcInZpZFwiKSkuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcHVibGljIGRlbGV0ZUxheW91dFN0eWxlSW50ZXJhY3Rpb25DbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLkRlbGV0ZUxheW91dFN0eWxlSW50ZXJhY3Rpb25Kc29uKHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImxpZFwiKSkuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY3JlYXRlTGF5b3V0U3R5bGVJbnRlcmFjdGlvbiA9IChldnQ6IE1vdXNlRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuQ3JlYXRlTGF5b3V0U3R5bGVJbnRlcmFjdGlvbkZvckxheW91dEF0b21Kc29uKHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImFpZFwiKSkuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc3BlY2lhbExheW91dEJveFR5cGVDaGFuZ2VkSGFuZGxlciA9IChldnQ6IFVJRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgdGFyZ2V0U2VsZWN0ID0gZXZ0LnRhcmdldCBhcyBIVE1MU2VsZWN0RWxlbWVudDtcclxuICAgICAgICBsZXQgc2VsZWN0ZWRTcGVjaWFsTGF5b3V0Qm94VHlwZTogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmICh0YXJnZXRTZWxlY3Quc2VsZWN0ZWRJbmRleCA8IHRhcmdldFNlbGVjdC5jaGlsZEVsZW1lbnRDb3VudCkge1xyXG4gICAgICAgICAgICBsZXQgc2VsZWN0T3B0aW9uRWxlbWVudDogSFRNTE9wdGlvbkVsZW1lbnQgPSB0YXJnZXRTZWxlY3Qub3B0aW9uc1t0YXJnZXRTZWxlY3Quc2VsZWN0ZWRJbmRleF07XHJcbiAgICAgICAgICAgIHNlbGVjdGVkU3BlY2lhbExheW91dEJveFR5cGUgPSBwYXJzZUludChzZWxlY3RPcHRpb25FbGVtZW50LnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNlbGVjdGVkU3BlY2lhbExheW91dEJveFR5cGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuU2V0U3BlY2lhbExheW91dEJveFR5cGVKc29uKHBhcnNlSW50RnJvbUF0dHJpYnV0ZSh0YXJnZXRTZWxlY3QsIFwiYmlkXCIpLCBzZWxlY3RlZFNwZWNpYWxMYXlvdXRCb3hUeXBlKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgYm94Q291bnRJblJvd0NoYW5nZWRIYW5kbGVyID0gKGV2dDogVUlFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCB0YXJnZXRTZWxlY3QgPSBldnQudGFyZ2V0IGFzIEhUTUxTZWxlY3RFbGVtZW50O1xyXG4gICAgICAgIGxldCBwYXJzZWRCb3hDb3VudDogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmICh0YXJnZXRTZWxlY3Quc2VsZWN0ZWRJbmRleCA8IHRhcmdldFNlbGVjdC5jaGlsZEVsZW1lbnRDb3VudCkge1xyXG4gICAgICAgICAgICBsZXQgc2VsZWN0T3B0aW9uRWxlbWVudDogSFRNTE9wdGlvbkVsZW1lbnQgPSB0YXJnZXRTZWxlY3Qub3B0aW9uc1t0YXJnZXRTZWxlY3Quc2VsZWN0ZWRJbmRleF07XHJcbiAgICAgICAgICAgIHBhcnNlZEJveENvdW50ID0gcGFyc2VJbnQoc2VsZWN0T3B0aW9uRWxlbWVudC52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXJzZWRCb3hDb3VudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5TZXRMYXlvdXRCb3hDb3VudEZvclJvd09yQm94SnNvbihwYXJzZUludEZyb21BdHRyaWJ1dGUodGFyZ2V0U2VsZWN0LCBcInJpZFwiKSwgY3VycmVudEFwcC5zdGF0ZS5uZXdCb3hTdHlsZU1vbGVjdWxlSWQsIHBhcnNlZEJveENvdW50LCBmYWxzZSkuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGZpbmFsaXplTGF5b3V0UmVxdWVzdCA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAvLyBUT0RPIGRpZmZlcmVudGlhdGUgbW9kZVxyXG4gICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuc2VsZWN0ZWRMYXlvdXRCYXNlSWQgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJsaWRcIik7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFRyYW5zYWN0aW9uTW9kZSA9PT0gVHJhbnNhY3Rpb25Nb2RlLk1vdmVMYXlvdXRNb2xlY3VsZUludG9MYXlvdXRNb2xlY3VsZSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5tb3ZlTGF5b3V0TW9sZWN1bGVJbnRvTGF5b3V0TW9sZWN1bGUoKTtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFRyYW5zYWN0aW9uTW9kZSA9PT0gVHJhbnNhY3Rpb25Nb2RlLk1vdmVMYXlvdXRNb2xlY3VsZUJlZm9yZUxheW91dE1vbGVjdWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLm1vdmVMYXlvdXRNb2xlY3VsZUJlZm9yZUxheW91dE1vbGVjdWxlKCk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUucHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjdXJyZW50QXBwLnN0YXRlLmN1cnJlbnRUcmFuc2FjdGlvbk1vZGUgPT09IFRyYW5zYWN0aW9uTW9kZS5TeW5jTGF5b3V0U3R5bGVzSW1pdGF0aW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnN5bmNMYXlvdXRNb2xlY3VsZVN0eWxlc0ltaXRhdGluZ1JlZmVyZW5jZUxheW91dCgpOyAvLyBUT0RPIGRvY3VtZW50IG9yIHJld29yayBzdGlja3kgcHJlc2VsZWN0aW9uXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkID0gMDtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgbW92ZUxheW91dEJveEludG9Sb3dDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IGxheW91dEJhc2VJZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibGlkXCIpO1xyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkICE9IGxheW91dEJhc2VJZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkID0gbGF5b3V0QmFzZUlkO1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmN1cnJlbnRUcmFuc2FjdGlvbk1vZGUgPSBUcmFuc2FjdGlvbk1vZGUuTW92ZUxheW91dE1vbGVjdWxlSW50b0xheW91dE1vbGVjdWxlO1xyXG4gICAgICAgICAgICAvL3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmRpc3BsYXlQb3B1cChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCBQb3B1cE1vZGUuTW92ZUxheW91dE1vbGVjdWxlSW50b0xheW91dE1vbGVjdWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUucHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIG1vdmVMYXlvdXRCb3hJbnRvQm94Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCBsYXlvdXRCYXNlSWQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImxpZFwiKTtcclxuICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCAhPSBsYXlvdXRCYXNlSWQpIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCA9IGxheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25Nb2RlID0gVHJhbnNhY3Rpb25Nb2RlLk1vdmVMYXlvdXRNb2xlY3VsZUludG9MYXlvdXRNb2xlY3VsZTtcclxuICAgICAgICAgICAgLy90aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5kaXNwbGF5UG9wdXAoZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgUG9wdXBNb2RlLk1vdmVMYXlvdXRNb2xlY3VsZUludG9MYXlvdXRNb2xlY3VsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBtb3ZlTGF5b3V0Qm94QmVmb3JlQm94Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCBsYXlvdXRCYXNlSWQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImxpZFwiKTtcclxuICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCAhPSBsYXlvdXRCYXNlSWQpIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCA9IGxheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25Nb2RlID0gVHJhbnNhY3Rpb25Nb2RlLk1vdmVMYXlvdXRNb2xlY3VsZUJlZm9yZUxheW91dE1vbGVjdWxlO1xyXG4gICAgICAgICAgICAvL3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmRpc3BsYXlQb3B1cChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCBQb3B1cE1vZGUuTW92ZUxheW91dE1vbGVjdWxlQmVmb3JlTGF5b3V0TW9sZWN1bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgbW92ZUxheW91dFJvd0JlZm9yZVJvd0NsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgbGF5b3V0QmFzZUlkOiBudW1iZXIgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJsaWRcIik7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUucHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQgIT0gbGF5b3V0QmFzZUlkKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUucHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQgPSBsYXlvdXRCYXNlSWQ7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFRyYW5zYWN0aW9uTW9kZSA9IFRyYW5zYWN0aW9uTW9kZS5Nb3ZlTGF5b3V0TW9sZWN1bGVCZWZvcmVMYXlvdXRNb2xlY3VsZTtcclxuICAgICAgICAgICAgLy90aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5kaXNwbGF5UG9wdXAoZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgUG9wdXBNb2RlLk1vdmVMYXlvdXRNb2xlY3VsZUJlZm9yZUxheW91dE1vbGVjdWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUucHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHN5bmNMYXlvdXRCYXNlU3R5bGVzQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCBsYXlvdXRCYXNlSWQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImxpZFwiKTtcclxuICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCAhPSBsYXlvdXRCYXNlSWQpIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCA9IGxheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25Nb2RlID0gVHJhbnNhY3Rpb25Nb2RlLlN5bmNMYXlvdXRTdHlsZXNJbWl0YXRpbmc7XHJcbiAgICAgICAgICAgIC8vdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZGlzcGxheVBvcHVwKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsIFBvcHVwTW9kZS5VTkRFRklORUQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgbW92ZUxheW91dEF0b21JbnRvQm94Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCBsYXlvdXRCYXNlSWQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImxpZFwiKTtcclxuICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCAhPSBsYXlvdXRCYXNlSWQpIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCA9IGxheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25Nb2RlID0gVHJhbnNhY3Rpb25Nb2RlLk1vdmVMYXlvdXRNb2xlY3VsZUludG9MYXlvdXRNb2xlY3VsZTtcclxuICAgICAgICAgICAgLy90aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5kaXNwbGF5UG9wdXAoZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgUG9wdXBNb2RlLk1vdmVMYXlvdXRNb2xlY3VsZUludG9MYXlvdXRNb2xlY3VsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjcmVhdGVCb3hGb3JBdG9tSW5QbGFjZUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLnN0YXRlLnNlbGVjdGVkTGF5b3V0QmFzZUlkID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibGlkXCIpO1xyXG4gICAgICAgIC8vIFRPRE8gZG9jdW1lbnQ6IGZvcmVpZ24gcG9wdXAgaXMgdXNlZCwgY29udHJvbGxlciByZXF1ZXN0IGRpZmZlcmVudGlhdGlvbiBieSBzdGF0ZVxyXG4gICAgICAgIHRoaXMudmlld01vZGVsLmN1cnJlbnRTZWNvbmRhcnlQb3B1cE1vZGUgPSBQb3B1cFNlY29uZGFyeU1vZGUuU2VsZWN0Qm94SW50b0JveEF0b21JblBsYWNlO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmRpc3BsYXlQb3B1cChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCBQb3B1cE1vZGUuU2VsZWN0Qm94KTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIG1vdmVMYXlvdXRBdG9tQmVmb3JlQXRvbUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgbGF5b3V0QmFzZUlkOiBudW1iZXIgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJsaWRcIik7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUucHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQgIT0gbGF5b3V0QmFzZUlkKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUucHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQgPSBsYXlvdXRCYXNlSWQ7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFRyYW5zYWN0aW9uTW9kZSA9IFRyYW5zYWN0aW9uTW9kZS5Nb3ZlTGF5b3V0TW9sZWN1bGVCZWZvcmVMYXlvdXRNb2xlY3VsZTtcclxuICAgICAgICAgICAgLy90aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5kaXNwbGF5UG9wdXAoZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgUG9wdXBNb2RlLk1vdmVMYXlvdXRNb2xlY3VsZUJlZm9yZUxheW91dE1vbGVjdWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUucHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIG1vdmVMYXlvdXRBdG9tQmVmb3JlQm94Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCBsYXlvdXRCYXNlSWQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImxpZFwiKTtcclxuICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCAhPSBsYXlvdXRCYXNlSWQpIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCA9IGxheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25Nb2RlID0gVHJhbnNhY3Rpb25Nb2RlLk1vdmVMYXlvdXRNb2xlY3VsZUJlZm9yZUxheW91dE1vbGVjdWxlO1xyXG4gICAgICAgICAgICAvL3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmRpc3BsYXlQb3B1cChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCBQb3B1cE1vZGUuTW92ZUxheW91dE1vbGVjdWxlQmVmb3JlTGF5b3V0TW9sZWN1bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2F2ZUxheW91dE1vbGVjdWxlQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5TZXRMYXlvdXRSb3dPckJveEFzSW5zdGFuY2VhYmxlSnNvbihjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ2FsaWZvcm5pYVByb2plY3RJZCwgcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibGlkXCIpKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjcmVhdGVWaWV3Rm9yQm94Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVE9ET1wiKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGluc2VydExheW91dEF0b21JbnRvQm94Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuc2VsZWN0ZWRMYXlvdXRCYXNlSWQgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJsaWRcIik7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZGlzcGxheVBvcHVwKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsIFBvcHVwTW9kZS5JbnNlcnRMYXlvdXRBdG9tSW50b0JveCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBpbnNlcnRMYXlvdXRCb3hJbnRvQm94Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuc2VsZWN0ZWRMYXlvdXRCYXNlSWQgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJsaWRcIik7XHJcbiAgICAgICAgdGhpcy52aWV3TW9kZWwuY3VycmVudFNlY29uZGFyeVBvcHVwTW9kZSA9IFBvcHVwU2Vjb25kYXJ5TW9kZS5TZWxlY3RCb3hJbnRvQm94O1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmRpc3BsYXlQb3B1cChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCBQb3B1cE1vZGUuU2VsZWN0Qm94KTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlbmRlckNhbGlmb3JuaWFWaWV3Q29udHJvbHNXaGVuQWxsID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICBsZXQgaXNBZGRCdXR0b25FbmFibGVkOiBib29sZWFuID0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDYWxpZm9ybmlhVmlld05hbWUgIT09IFwiXCI7XHJcbiAgICAgICAgcmV0dXJuIDxkaXYga2V5PVwiLTFcIj5cclxuICAgICAgICAgICAgPGlucHV0IGtleT1cIjBcIlxyXG4gICAgICAgICAgICAgICAgdmFsdWU9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ2FsaWZvcm5pYVZpZXdOYW1lfVxyXG4gICAgICAgICAgICAgICAgb25pbnB1dD17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2FsaWZvcm5pYVZpZXdOYW1lSW5wdXRIYW5kbGVyfT5cclxuICAgICAgICAgICAgPC9pbnB1dD5cclxuICAgICAgICAgICAge2lzQWRkQnV0dG9uRW5hYmxlZCA/IDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jcmVhdGVDYWxpZm9ybmlhVmlld0NsaWNrSGFuZGxlcn0+JiMxMDAwNDs8L2J1dHRvbj4gOiA8YnV0dG9uIGRpc2FibGVkIGtleT1cImEwXCIgcm9sZT1cImJ1dHRvblwiIG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmNyZWF0ZUNhbGlmb3JuaWFWaWV3Q2xpY2tIYW5kbGVyfT4mIzEwMDA0OzwvYnV0dG9uPn1cclxuICAgICAgICAgICAge2lzQWRkQnV0dG9uRW5hYmxlZCA/IDxidXR0b24ga2V5PVwiYlwiIHJvbGU9XCJidXR0b25cIiBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jcmVhdGVDYWxpZm9ybmlhVmlld0Zyb21SZWZlcmVuY2VDbGlja0hhbmRsZXJ9PngyPC9idXR0b24+IDogPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJiMFwiIHJvbGU9XCJidXR0b25cIiBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jcmVhdGVDYWxpZm9ybmlhVmlld0Zyb21SZWZlcmVuY2VDbGlja0hhbmRsZXJ9PngyPC9idXR0b24+fVxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNyZWF0ZUNhbGlmb3JuaWFWaWV3RnJvbVJlZmVyZW5jZUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5kaXNwbGF5UG9wdXAoZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgUG9wdXBNb2RlLkNhbGlmb3JuaWFWaWV3U2VsZWN0aW9uKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNyZWF0ZUNhbGlmb3JuaWFWaWV3Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5DcmVhdGVDYWxpZm9ybmlhVmlld0pzb24oY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFQcm9qZWN0SWQsIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ2FsaWZvcm5pYVZpZXdOYW1lKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDYWxpZm9ybmlhVmlld05hbWUgPSBcIlwiO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcHVibGljIGNhbGlmb3JuaWFWaWV3TmFtZUlucHV0SGFuZGxlciA9IChldnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENhbGlmb3JuaWFWaWV3TmFtZSA9IChldnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyQ2FsaWZvcm5pYVZpZXdTZWxlY3Rpb25Qb3B1cCA9ICgpOiBWTm9kZSA9PiB7XHJcbiAgICAgICAgbGV0IGlzUG9wdXBWaXNpYmxlOiBib29sZWFuID0gdGhpcy52aWV3TW9kZWwuY3VycmVudFBvcHVwTW9kZSA9PT0gUG9wdXBNb2RlLkNhbGlmb3JuaWFWaWV3U2VsZWN0aW9uOyAvLyBUT0RPIHNob3J0ZW4gaWRzIGV2ZXJ5d2hlcmVcclxuICAgICAgICBsZXQgcmVuZGVyZWRPcHRpb25zOiBWTm9kZVtdID0gW107XHJcbiAgICAgICAgaWYgKGlzUG9wdXBWaXNpYmxlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5DYWxpZm9ybmlhVmlld3MuZmlsdGVyKG0gPT4gIW0uSXNJbnRlcm5hbCkubWFwKG0gPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNhbGlmb3JuaWFWaWV3SWRTdHJpbmc6IHN0cmluZyA9IG0uQ2FsaWZvcm5pYVZpZXdJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZWRPcHRpb25zLnB1c2goPGRpdiBrZXk9e2NhbGlmb3JuaWFWaWV3SWRTdHJpbmd9IHN0eWxlcz17eyBcImZsZXhcIjogXCIwIDAgMTAwJVwiLCBcIndpZHRoXCI6IFwiMTAwJVwiLCBcIm1pbi13aWR0aFwiOiBcIjEwMCVcIiB9fT5cclxuICAgICAgICAgICAgICAgICAgICB2aWV3ICN7Y2FsaWZvcm5pYVZpZXdJZFN0cmluZ306IHttLk5hbWV9IDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiB2aWQ9e2NhbGlmb3JuaWFWaWV3SWRTdHJpbmd9IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnNlbGVjdENhbGlmb3JuaWFWaWV3SW5Qb3B1cENsaWNrSGFuZGxlcn0+JiMxMDAwNDs8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PiBhcyBWTm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gPGRpdiBpZD17YCR7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucHJvcGVydHlCYXJJbmRleH1Qb3B1cE1vZGUke1BvcHVwTW9kZVtQb3B1cE1vZGUuQ2FsaWZvcm5pYVZpZXdTZWxlY3Rpb25dfWB9IHN0eWxlcz17eyBcImRpc3BsYXlcIjogaXNQb3B1cFZpc2libGUgPyBcImJsb2NrXCIgOiBcIm5vbmVcIiwgXCJ6LWluZGV4XCI6IFwiMzFcIiwgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVcIiwgXCJib3JkZXJcIjogXCJzb2xpZCBibGFjayAxcHhcIiB9fT5cclxuICAgICAgICAgICAgPGRpdiBrZXk9XCIwXCIgc3R5bGVzPXt7IFwiZGlzcGxheVwiOiBcImZsZXhcIiwgXCJmbGV4LWZsb3dcIjogXCJyb3cgbm93cmFwXCIsIFwibWluLXdpZHRoXCI6IFwiMjUwcHhcIiB9fT5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYlwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIxIDAgMTAlXCIsIFwid2lkdGhcIjogXCIxMCVcIiwgXCJtaW4td2lkdGhcIjogXCIxMCVcIiB9fSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jYW5jZWxTZWxlY3RDYWxpZm9ybmlhVmlld1BvcHVwQ2xpY2tIYW5kbGVyfT54PC9idXR0b24+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGtleT1cIjFcIiBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IFwiZmxleFwiLCBcImZsZXgtZmxvd1wiOiBcInJvdyB3cmFwXCIgfX0+XHJcbiAgICAgICAgICAgICAgICB7cmVuZGVyZWRPcHRpb25zfVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj4gYXMgVk5vZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzZWxlY3RDYWxpZm9ybmlhVmlld0luUG9wdXBDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLkNyZWF0ZUNhbGlmb3JuaWFWaWV3RnJvbVJlZmVyZW5jZVZpZXdKc29uKGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5DYWxpZm9ybmlhUHJvamVjdElkLCB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENhbGlmb3JuaWFWaWV3TmFtZSwgcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwidmlkXCIpKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDYWxpZm9ybmlhVmlld05hbWUgPSBcIlwiO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmNsb3NlUG9wdXAoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNhbmNlbFNlbGVjdENhbGlmb3JuaWFWaWV3UG9wdXBDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2xvc2VQb3B1cCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyQ2FsaWZvcm5pYVZpZXdDb250cm9scyA9ICgpOiBWTm9kZSB8IHVuZGVmaW5lZCA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZENhbGlmb3JuaWFWaWV3SWQgPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgc2VsZWN0ZWRDYWxpZm9ybmlhVmlldzogQ2FsaWZvcm5pYVZpZXcgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ2FsaWZvcm5pYVZpZXdzLmZpbmQodiA9PiB2LkNhbGlmb3JuaWFWaWV3SWQgPT0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkQ2FsaWZvcm5pYVZpZXdJZCkgYXMgQ2FsaWZvcm5pYVZpZXc7IC8vIFRPRE8gcG90ZW50aWFsbHkgc2xvd1xyXG4gICAgICAgIGxldCBjYWxpZm9ybmlhVmlld0lkU3RyaW5nOiBzdHJpbmcgPSBzZWxlY3RlZENhbGlmb3JuaWFWaWV3LkNhbGlmb3JuaWFWaWV3SWQudG9TdHJpbmcoKTtcclxuICAgICAgICBsZXQgdmlld0NvbnRyb2xzQnV0dG9uSG9sZGVyU3R5bGVzID0ge1xyXG4gICAgICAgICAgICBcImZsZXhcIjogXCIwIDAgYXV0b1wiLFxyXG4gICAgICAgICAgICBcImhlaWdodFwiOiBcImF1dG9cIlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHZpZXdDb250cm9sc0JveFRyZWVIb2xkZXJTdHlsZXMgPSB7XHJcbiAgICAgICAgICAgIC8qVE9ETyBuZWVkIHNldCBhbGwgZGl2IHN0eWxlcyB3aWR0aC9oZWlnaHQgaW4gdGhpcyBib3ggdG8gZWl0aGVyIHVuZGVmaW5lZCBvciB2YWx1ZSAvLyBUT0RPIGRvIGV2ZXJ5d2hlcmUhISovXHJcbiAgICAgICAgICAgIFwiZmxleFwiOiBcIjEgMSAxcHhcIixcclxuICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgXCJoZWlnaHRcIjogXCJhdXRvXCIsXHJcbiAgICAgICAgICAgIFwib3ZlcmZsb3dcIjogXCJzY3JvbGxcIlxyXG4gICAgICAgIH07Ly8gVE9ETyBhcHBsaWVkIGF0IG1hbnkgcGxhY2VzOiBjb2RlIHNlbnNlIGZvciB1c2FnZSBvZiBib3hUcmVlUHJvamVjdG9yIHNob3VsZCBiZSBjb3VwbGVkIHdpdGggcmVuZGVyQm94VHJlZSByb3V0aW5lXHJcbiAgICAgICAgbGV0IGlzU3luY1dpdGhQcmV2aWV3QWN0aXZlOiBib29sZWFuID0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIucHJvcGVydHlCYXJJbmRleCA9PSAwO1xyXG4gICAgICAgIGxldCBpc1N5bmNXaXRoTGVmdEFjdGl2ZTogYm9vbGVhbiA9IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXggIT0gMDtcclxuICAgICAgICBsZXQgaXNEcmF3SGVscGVyTGluZXNBY3RpdmU6IGJvb2xlYW4gPSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5wcm9wZXJ0eUJhckluZGV4ID09IDA7XHJcbiAgICAgICAgbGV0IHN5bmNXaXRoTGVmdEJveFRyZWVCdXR0b25TdHlsZXMgPSB7XHJcbiAgICAgICAgICAgIFwib3V0bGluZVwiOiAhaXNTeW5jV2l0aExlZnRBY3RpdmUgPyB1bmRlZmluZWQgOiB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuaXNTeW5jZWRXaXRoQm94VHJlZVRvVGhlTGVmdCA/IFwic29saWQgMXB4IHJnYigyMDAsMCwwKVwiIDogXCJzb2xpZCAxcHggcmdiKDAsMjQyLDApXCIsXHJcbiAgICAgICAgICAgIFwib3V0bGluZS1vZmZzZXRcIjogIWlzU3luY1dpdGhMZWZ0QWN0aXZlID8gdW5kZWZpbmVkIDogXCItMXB4XCJcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBzeW5jV2l0aFByZXZpZXdCdXR0b25TdHlsZXMgPSB7XHJcbiAgICAgICAgICAgIFwib3V0bGluZVwiOiAhaXNTeW5jV2l0aFByZXZpZXdBY3RpdmUgPyB1bmRlZmluZWQgOiB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuaXNTeW5jZWRXaXRoUGFnZVByZXZpZXcgPyBcInNvbGlkIDFweCByZ2IoMjAwLDAsMClcIiA6IFwic29saWQgMXB4IHJnYigwLDI0MiwwKVwiLFxyXG4gICAgICAgICAgICBcIm91dGxpbmUtb2Zmc2V0XCI6ICFpc1N5bmNXaXRoUHJldmlld0FjdGl2ZSA/IHVuZGVmaW5lZCA6IFwiLTFweFwiXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgZHJhd0hlbHBlckxpbmVzQnV0dG9uU3R5bGVzID0ge1xyXG4gICAgICAgICAgICBcIm91dGxpbmVcIjogIWlzRHJhd0hlbHBlckxpbmVzQWN0aXZlID8gdW5kZWZpbmVkIDogY3VycmVudEFwcC5zdGF0ZS5pc0RyYXdIZWxwZXJMaW5lcyA/IFwic29saWQgMXB4IHJnYigyMDAsMCwwKVwiIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBcIm91dGxpbmUtb2Zmc2V0XCI6ICFpc0RyYXdIZWxwZXJMaW5lc0FjdGl2ZSA/IHVuZGVmaW5lZCA6IFwiLTFweFwiXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gPGRpdiBzdHlsZXM9e3sgXCJ3aWR0aFwiOiBcIjEwMCVcIiwgXCJoZWlnaHRcIjogXCIxMDAlXCIsIFwiZGlzcGxheVwiOiBcImZsZXhcIiwgXCJmbGV4LWZsb3dcIjogXCJjb2x1bW4gbm93cmFwXCIgfX0+IFZpZXcgI3tjYWxpZm9ybmlhVmlld0lkU3RyaW5nfVxyXG4gICAgICAgICAgICA8ZGl2IGtleT1cIjBcIiBzdHlsZXM9e3ZpZXdDb250cm9sc0J1dHRvbkhvbGRlclN0eWxlc30+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pbnNlcnRMYXlvdXRSb3dJbnRvVmlld0NsaWNrSGFuZGxlcn0+KyhSKTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJiXCIgbWlkPXtzZWxlY3RlZENhbGlmb3JuaWFWaWV3LlNwZWNpYWxTdHlsZVZpZXdTdHlsZU1vbGVjdWxlSWRTdHJpbmd9IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnNlbGVjdFN0eWxlTW9sZWN1bGVDbGlja0hhbmRsZXJ9PnN0eWxlICN7c2VsZWN0ZWRDYWxpZm9ybmlhVmlldy5TcGVjaWFsU3R5bGVWaWV3U3R5bGVNb2xlY3VsZUlkU3RyaW5nfTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJjXCIgbWlkPXtzZWxlY3RlZENhbGlmb3JuaWFWaWV3LlNwZWNpYWxTdHlsZUJvZHlTdHlsZU1vbGVjdWxlSWRTdHJpbmd9IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnNlbGVjdFN0eWxlTW9sZWN1bGVDbGlja0hhbmRsZXJ9PmJvZHkgc3R5bGUgI3tzZWxlY3RlZENhbGlmb3JuaWFWaWV3LlNwZWNpYWxTdHlsZUJvZHlTdHlsZU1vbGVjdWxlSWRTdHJpbmd9PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImRcIiBtaWQ9e3NlbGVjdGVkQ2FsaWZvcm5pYVZpZXcuU3BlY2lhbFN0eWxlSHRtbFN0eWxlTW9sZWN1bGVJZFN0cmluZ30gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2VsZWN0U3R5bGVNb2xlY3VsZUNsaWNrSGFuZGxlcn0+SFRNTCBzdHlsZSAje3NlbGVjdGVkQ2FsaWZvcm5pYVZpZXcuU3BlY2lhbFN0eWxlSHRtbFN0eWxlTW9sZWN1bGVJZFN0cmluZ308L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiZVwiIG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnJlc2V0UHJlc2VsZWN0ZWRMYXlvdXRDbGlja0hhbmRsZXJ9Pm88L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIHtpc0RyYXdIZWxwZXJMaW5lc0FjdGl2ZSA/IDxidXR0b24ga2V5PVwiZlwiIG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmRyYXdIZWxwZXJMaW5lc0NsaWNrSGFuZGxlcn0gc3R5bGVzPXtkcmF3SGVscGVyTGluZXNCdXR0b25TdHlsZXN9PlxcLVxcPC9idXR0b24+IDogPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJmMFwiIG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmRyYXdIZWxwZXJMaW5lc0NsaWNrSGFuZGxlcn0gc3R5bGVzPXtkcmF3SGVscGVyTGluZXNCdXR0b25TdHlsZXN9PlxcLVxcPC9idXR0b24+fVxyXG4gICAgICAgICAgICAgICAge2lzU3luY1dpdGhQcmV2aWV3QWN0aXZlID8gPGJ1dHRvbiBrZXk9XCJnXCIgb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc3luY1dpdGhQYWdlUHJldmlld0NsaWNrSGFuZGxlcn0gc3R5bGVzPXtzeW5jV2l0aFByZXZpZXdCdXR0b25TdHlsZXN9Pi09LTwvYnV0dG9uPiA6IDxidXR0b24gZGlzYWJsZWQga2V5PVwiZzBcIiBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zeW5jV2l0aFBhZ2VQcmV2aWV3Q2xpY2tIYW5kbGVyfSBzdHlsZXM9e3N5bmNXaXRoUHJldmlld0J1dHRvblN0eWxlc30+LT0tPC9idXR0b24+fVxyXG4gICAgICAgICAgICAgICAge2lzU3luY1dpdGhMZWZ0QWN0aXZlID8gPGJ1dHRvbiBrZXk9XCJoXCIgb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc3luY1dpdGhMZWZ0UHJvcGVydHlCYXJDbGlja0hhbmRsZXJ9IHN0eWxlcz17c3luY1dpdGhMZWZ0Qm94VHJlZUJ1dHRvblN0eWxlc30+PT08L2J1dHRvbj4gOiA8YnV0dG9uIGRpc2FibGVkIGtleT1cImgwXCIgb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc3luY1dpdGhMZWZ0UHJvcGVydHlCYXJDbGlja0hhbmRsZXJ9IHN0eWxlcz17c3luY1dpdGhMZWZ0Qm94VHJlZUJ1dHRvblN0eWxlc30+PT08L2J1dHRvbj59XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGtleT1cIjFcIlxyXG4gICAgICAgICAgICAgICAgc3R5bGVzPXt2aWV3Q29udHJvbHNCb3hUcmVlSG9sZGVyU3R5bGVzfVxyXG4gICAgICAgICAgICAgICAgb25zY3JvbGw9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmJveFRyZWVTY3JvbGxIYW5kbGVyfVxyXG4gICAgICAgICAgICAgICAgYWZ0ZXJDcmVhdGU9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmJveFRyZWVBZnRlckNyZWF0ZUhhbmRsZXJ9PlxyXG4gICAgICAgICAgICAgICAge3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5ib3hUcmVlUHJvamVjdG9yLnJlc3VsdHMubWFwKHIgPT4gci5yZW5kZXJNYXF1ZXR0ZSgpKX1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIGJveFRyZWVTY3JvbGxIYW5kbGVyID0gKGV2dDogVUlFdmVudCkgPT4ge1xyXG4gICAgICAgIC8vIFRPRE8gaW5zdGVhZDogcmVuZGVyIGluIHNhbWUgZGl2IHRvIHN5bmNocm9uaXplIHNjcm9sbFxyXG4gICAgICAgIC8vIFRPRE8gZml4IGJ1ZyA9PiBiYWQgaGFuZGxpbmcgd2hlbiB1c2luZyBzY3JvbGwgYmFycyBpbiBlZGdlLi4uXHJcbiAgICAgICAgLy8gVE9ETyBrYWxlaWRvc2NvcGUgZWZmZWN0IHNlbGVjdGlvbiAvIGJveHRyZWUgZGlzcGxheSByYW5nZVxyXG4gICAgICAgIC8vIFRPRE8gdGVzdCBjYXNlOiBzaG93IDQgYm94IHRyZWVzICMxLSM0LCBtb3ZlICMyLCBzeW5jIHRvIGxlZnQgKCMxIHJlYWRzIGZyb20gIzIpLCBtb3ZlICM0LCBzeW5jIHRvIGxlZnQgKCMzIHJlYWRzIGZyb20gIzQpLCB0aGVuIGFjdGl2YXRlIHN5bmMgdG8gbGVmdCBpbiAjMyA9PiBhbGwgbW92ZW1lbnRzIHNob3VsZCBiZSBzeW5jZWRcclxuICAgICAgICAvLyAtLS0gc3luYyBzY3JvbGwgd2l0aCBvdGhlciBwcm9wZXJ0eSBiYXJzIC0tLVxyXG4gICAgICAgIGxldCBjdXJyZW50UHJvcGVydHlCYXJJbmRleDogbnVtYmVyID0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIucHJvcGVydHlCYXJJbmRleDtcclxuICAgICAgICBsZXQgY3VycmVudFNjcm9sbERvbTogSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQgPSBjdXJyZW50QXBwLnByb3BlcnR5QmFyQm94VHJlZURvbVJlZmVyZW5jZXNbY3VycmVudFByb3BlcnR5QmFySW5kZXhdIGFzIEhUTUxEaXZFbGVtZW50IC8qVE9ETyBjYXN0IHVuc2FmZSovO1xyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLnZpc2libGVQcm9wZXJ0eUJhck1heENvdW50ID4gMSAmJiBjdXJyZW50QXBwLnByb3BlcnR5QmFyQm94VHJlZVNjcm9sbEhhbmRsZWRbY3VycmVudFByb3BlcnR5QmFySW5kZXhdID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnByb3BlcnR5QmFyQm94VHJlZVNjcm9sbEhhbmRsZWRbY3VycmVudFByb3BlcnR5QmFySW5kZXhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIm9uc2Nyb2xsIGZvciBwcm9wZXJ0eSBiYXIgI1wiICsgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIucHJvcGVydHlCYXJJbmRleCArIFwiIHRvXCIgKyAoZXZ0LnRhcmdldCBhcyBIVE1MRGl2RWxlbWVudCkuc2Nyb2xsVG9wICsgXCIgZnJvbSBtYXggaGVpZ2h0XCIgKyAoZXZ0LnRhcmdldCBhcyBIVE1MRGl2RWxlbWVudCkuc2Nyb2xsSGVpZ2h0ICsgXCIsIGRpZmY6IFwiICsgKChldnQudGFyZ2V0IGFzIEhUTUxEaXZFbGVtZW50KS5zY3JvbGxIZWlnaHQgLSAoZXZ0LnRhcmdldCBhcyBIVE1MRGl2RWxlbWVudCkuc2Nyb2xsVG9wKS50b1N0cmluZygpICsgXCIsIGV4cGVjdGVkIGF0IG1heCBzY3JvbGw6IFwiICsgKGV2dC50YXJnZXQgYXMgSFRNTERpdkVsZW1lbnQpLmNsaWVudEhlaWdodCk7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50Vmlld01vZGVsOiBQcm9wZXJ0eUJhclZNID0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudFNjcm9sbERvbSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHByb2dyZXNzaW5nUHJvcGVydHlCYXJJbmRleDogbnVtYmVyID0gY3VycmVudFByb3BlcnR5QmFySW5kZXg7XHJcbiAgICAgICAgICAgIC8vIHN5bmMgd2l0aCBsZWZ0ICsgcHJvZ3Jlc3Npb24gdG8gbGVmdFxyXG4gICAgICAgICAgICBsZXQgaXNLZWVwR29pbmdMZWZ0OiBib29sZWFuID0gY3VycmVudFByb3BlcnR5QmFySW5kZXggPiAwO1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudEl0ZXJhdGlvbjogbnVtYmVyID0gMDtcclxuICAgICAgICAgICAgbGV0IG1heEl0ZXJhdGlvbjogbnVtYmVyID0gY3VycmVudFByb3BlcnR5QmFySW5kZXggLSAxO1xyXG4gICAgICAgICAgICB3aGlsZSAoaXNLZWVwR29pbmdMZWZ0ID09PSB0cnVlICYmIHByb2dyZXNzaW5nUHJvcGVydHlCYXJJbmRleCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QXBwLnByb3BlcnR5QmFyVk1zW3Byb2dyZXNzaW5nUHJvcGVydHlCYXJJbmRleF0uaXNTeW5jZWRXaXRoQm94VHJlZVRvVGhlTGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRTY3JvbGxEb206IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkID0gY3VycmVudEFwcC5wcm9wZXJ0eUJhckJveFRyZWVEb21SZWZlcmVuY2VzW3Byb2dyZXNzaW5nUHJvcGVydHlCYXJJbmRleCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJMRUZUOiBjdXJyZW50OiBcIiArIGN1cnJlbnRTY3JvbGxEb20uc2Nyb2xsVG9wICsgXCIsIHByZXY6IFwiICsgKHRhcmdldFNjcm9sbERvbSBhcyBIVE1MRGl2RWxlbWVudCkuc2Nyb2xsVG9wKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0U2Nyb2xsRG9tICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0U2Nyb2xsRG9tLnNjcm9sbFRvcCAhPSBjdXJyZW50U2Nyb2xsRG9tLnNjcm9sbFRvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnByb3BlcnR5QmFyQm94VHJlZVNjcm9sbEhhbmRsZWRbcHJvZ3Jlc3NpbmdQcm9wZXJ0eUJhckluZGV4IC0gMV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRTY3JvbGxEb20uc2Nyb2xsVG9wID0gY3VycmVudFNjcm9sbERvbS5zY3JvbGxUb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNLZWVwR29pbmdMZWZ0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEl0ZXJhdGlvbiA+IG1heEl0ZXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByb2dyZXNzaW5nUHJvcGVydHlCYXJJbmRleC0tO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEl0ZXJhdGlvbisrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHN5bmMgd2l0aCByaWdodCArIHByb2dyZXNzaW9uIHRvIHJpZ2h0XHJcbiAgICAgICAgICAgIHByb2dyZXNzaW5nUHJvcGVydHlCYXJJbmRleCA9IGN1cnJlbnRQcm9wZXJ0eUJhckluZGV4ICsgMTtcclxuICAgICAgICAgICAgbGV0IGlzS2VlcEdvaW5nUmlnaHQ6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgICAgICAgICBjdXJyZW50SXRlcmF0aW9uID0gMDtcclxuICAgICAgICAgICAgbWF4SXRlcmF0aW9uID0gKGN1cnJlbnRBcHAuc3RhdGUudmlzaWJsZVByb3BlcnR5QmFyTWF4Q291bnQgLSAxKSAtIGN1cnJlbnRQcm9wZXJ0eUJhckluZGV4O1xyXG4gICAgICAgICAgICB3aGlsZSAoaXNLZWVwR29pbmdSaWdodCA9PT0gdHJ1ZSAmJiBwcm9ncmVzc2luZ1Byb3BlcnR5QmFySW5kZXggPCBjdXJyZW50QXBwLnN0YXRlLnZpc2libGVQcm9wZXJ0eUJhck1heENvdW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEFwcC5wcm9wZXJ0eUJhclZNc1twcm9ncmVzc2luZ1Byb3BlcnR5QmFySW5kZXhdLmlzU3luY2VkV2l0aEJveFRyZWVUb1RoZUxlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0U2Nyb2xsRG9tOiBIVE1MRGl2RWxlbWVudCB8IHVuZGVmaW5lZCA9IGN1cnJlbnRBcHAucHJvcGVydHlCYXJCb3hUcmVlRG9tUmVmZXJlbmNlc1twcm9ncmVzc2luZ1Byb3BlcnR5QmFySW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJSSUdIVDogY3VycmVudDogXCIgKyBjdXJyZW50U2Nyb2xsRG9tLnNjcm9sbFRvcCArIFwiLCBwcmV2OiBcIiArICh0YXJnZXRTY3JvbGxEb20gYXMgSFRNTERpdkVsZW1lbnQpLnNjcm9sbFRvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldFNjcm9sbERvbSAhPT0gdW5kZWZpbmVkICYmIHRhcmdldFNjcm9sbERvbS5zY3JvbGxUb3AgIT0gY3VycmVudFNjcm9sbERvbS5zY3JvbGxUb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5wcm9wZXJ0eUJhckJveFRyZWVTY3JvbGxIYW5kbGVkW3Byb2dyZXNzaW5nUHJvcGVydHlCYXJJbmRleF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRTY3JvbGxEb20uc2Nyb2xsVG9wID0gY3VycmVudFNjcm9sbERvbS5zY3JvbGxUb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNLZWVwR29pbmdSaWdodCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJdGVyYXRpb24gPiBtYXhJdGVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzc2luZ1Byb3BlcnR5QmFySW5kZXgrKztcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRJdGVyYXRpb24rKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwib25zY3JvbGwgZW5kIGZvciBwcm9wZXJ0eSBiYXIgI1wiICsgY3VycmVudFByb3BlcnR5QmFySW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50QXBwLnN0YXRlLnZpc2libGVQcm9wZXJ0eUJhck1heENvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucHJvcGVydHlCYXJCb3hUcmVlU2Nyb2xsSGFuZGxlZFtpXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIC0tLSBzeW5jIHZpc2libGUgZWxlbWVudHMgLS0tXHJcbiAgICAgICAgaWYgKGN1cnJlbnRQcm9wZXJ0eUJhckluZGV4ID09IDAgJiYgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmlzU3luY2VkV2l0aFBhZ2VQcmV2aWV3KSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gY2FsbGVkIHRvbyBvZnRlbiBUT0RPIGluaXRpYWwgcmVuZGVyXHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB2aXNpYmxlIGxheW91dCBhdG9tIGRvbSBub2RlIHJlZmVyZW5jZXNcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuX3Zpc2libGVMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuX3Zpc2libGVMYXlvdXRBdG9tS2V5cyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5fbW9zdFVwcGVyVmlzaWJsZUxheW91dEF0b21JZCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBwcm9jZXNzZWRFbGVtZW50Q291bnQ6IG51bWJlciA9IDA7XHJcbiAgICAgICAgICAgIGxldCBtb3N0VXBwZXJWaXNpYmxlSW5kZXg6IG51bWJlciA9IC0xO1xyXG4gICAgICAgICAgICBsZXQgbW9zdFVwcGVyVmlzaWJsZUxheW91dEF0b21JZDogbnVtYmVyID0gMDtcclxuICAgICAgICAgICAgbGV0IG1vc3RVcHBlclZpc2libGVEZWx0YVRvcExlZnQ6IG51bWJlciA9IGN1cnJlbnRTY3JvbGxEb20uY2xpZW50SGVpZ2h0ICsgMTsgLy8gb3RoZXJ3aXNlIGVsZW1lbnQgaXMgYmVsb3cgdmlzaWJsZSBhcmVhXHJcbiAgICAgICAgICAgIGxldCBzdGF0aWNPZmZzZXRQeDogbnVtYmVyID0gY3VycmVudFNjcm9sbERvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7IC8vIFRPRE8gZXZlcnl3aGVyZTogcGl4ZWwgYWxpYXNpbmcgYXJlIG1heWJlIGJlY2F1c2UgY29tcGFyaW5nIG5vdCBudW1lcmljYWxseSwgYnV0IHN0cmljdGx5IChlcHMpXHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50U2Nyb2xsVG9wOiBudW1iZXIgPSBjdXJyZW50U2Nyb2xsRG9tLnNjcm9sbFRvcDtcclxuICAgICAgICAgICAgbGV0IG1pblhQcmV2aWV3OiBudW1iZXIgPSAwOyAvLyAwIGJhc2VkIGZvciB0b3AgbGVmdCBjb3JuZXIgaW4gdmlld3BvcnQvcGFnZXByZXZpZXdcclxuICAgICAgICAgICAgbGV0IG1heFhQcmV2aWV3OiBudW1iZXIgPSBjdXJyZW50U2Nyb2xsRG9tLmNsaWVudEhlaWdodDtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInNjcm9sbGVkIGJveHRyZWUgdG9cIiArIGN1cnJlbnRTY3JvbGxUb3AgKyBcIiBhdCBjbGllbnQgaGVpZ2h0IFwiICsgcGFnZVByZXZpZXdIb2xkZXIuY2xpZW50SGVpZ2h0ICsgXCIgZnJvbSBtYXggaGVpZ2h0XCIgKyBwYWdlUHJldmlld0hvbGRlci5zY3JvbGxIZWlnaHQgICsgXCIgbWluWCBcIiArIG1pblhQcmV2aWV3ICsgXCIgbWF4WFwiICsgbWF4WFByZXZpZXcpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBlbGVtZW50S2V5IGluIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLl9hY3RpdmVWaWV3TGF5b3V0QXRvbURvbU5vZGVSZWZlcmVuY2VzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIG9yZGVyIGFsbCBsYXlvdXQgZWxlbWVudHMgYW5kIHByb2Nlc3Mgb25seSBzcGVjaWZpYyByYW5nZSBvciBtb3ZlIHByb2Nlc3NpbmcgcmFuZ2Ugd2l0aCBzY3JvbGxcclxuICAgICAgICAgICAgICAgIGxldCBkb21Ob2RlOiBIVE1MRWxlbWVudCA9IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLl9hY3RpdmVWaWV3TGF5b3V0QXRvbURvbU5vZGVSZWZlcmVuY2VzW2VsZW1lbnRLZXldO1xyXG4gICAgICAgICAgICAgICAgbGV0IGlzRG9tTm9kZVZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJwcm9jZXNzaW5nIGVsZW1lbnQ6IGNsaWVudFRvcCBcIiArIGRvbU5vZGUuY2xpZW50SGVpZ2h0ICsgXCIsIG9mZnNldFRvcCBcIiArIGRvbU5vZGUub2Zmc2V0VG9wKTtcclxuICAgICAgICAgICAgICAgIGxldCBib3VuZGluZ1JlY3RFbGVtZW50OiBDbGllbnRSZWN0ID0gZG9tTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgICAgIC8vbGV0IGZpcnN0Q2xpZW50UmVjdEVsZW1lbnQ6IENsaWVudFJlY3QgPSBkb21Ob2RlLmdldENsaWVudFJlY3RzKClbMF07XHJcbiAgICAgICAgICAgICAgICBsZXQgbWluWEVsZW1lbnREZWx0YVRvcExlZnQ6IG51bWJlciA9IGJvdW5kaW5nUmVjdEVsZW1lbnQudG9wIC0gc3RhdGljT2Zmc2V0UHg7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWF4WEVsZW1lbnREZWx0YUJvdHRvbUxlZnQ6IG51bWJlciA9IGN1cnJlbnRTY3JvbGxEb20uY2xpZW50SGVpZ2h0IC0gKGJvdW5kaW5nUmVjdEVsZW1lbnQudG9wIC0gc3RhdGljT2Zmc2V0UHggKyBjdXJyZW50U2Nyb2xsVG9wICsgYm91bmRpbmdSZWN0RWxlbWVudC5oZWlnaHQpICsgY3VycmVudFNjcm9sbFRvcDtcclxuICAgICAgICAgICAgICAgIGlmIChib3VuZGluZ1JlY3RFbGVtZW50LmhlaWdodCA+IDApIHsgLy8gaGVpZ2h0IGNhbiBiZSAwID0+IGludmlzaWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5YRWxlbWVudERlbHRhVG9wTGVmdCA+PSAwLjAgJiYgbWluWEVsZW1lbnREZWx0YVRvcExlZnQgPD0gY3VycmVudFNjcm9sbERvbS5jbGllbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEb21Ob2RlVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1heFhFbGVtZW50RGVsdGFCb3R0b21MZWZ0ID49IDAuMCAmJiBtYXhYRWxlbWVudERlbHRhQm90dG9tTGVmdCA8PSBjdXJyZW50U2Nyb2xsRG9tLmNsaWVudEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RvbU5vZGVWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWluWEVsZW1lbnREZWx0YVRvcExlZnQgPD0gMC4wICYmIG1heFhFbGVtZW50RGVsdGFCb3R0b21MZWZ0IDw9IDAuMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RvbU5vZGVWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiZWxlbWVudDogYm91bmRpbmcgcmVjdCB0b3AgXCIgKyBib3VuZGluZ1JlY3RFbGVtZW50LnRvcCArIFwiLCByZWN0IGJvdHRvbSBcIiArIGJvdW5kaW5nUmVjdEVsZW1lbnQuYm90dG9tICsgXCIsIG1pblhFbGVtZW50RGVsdGFUb3BMZWZ0OiBcIiArIG1pblhFbGVtZW50RGVsdGFUb3BMZWZ0ICsgXCIsIG1heFhFbGVtZW50RGVsdGFCb3R0b21MZWZ0OiBcIiArIG1heFhFbGVtZW50RGVsdGFCb3R0b21MZWZ0KTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0RvbU5vZGVWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuX3Zpc2libGVMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXMucHVzaChkb21Ob2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5fdmlzaWJsZUxheW91dEF0b21LZXlzLnB1c2goZWxlbWVudEtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInZpc2libGUgZWxlbWVudDogZmlyc3QgY2xpZW50IHJlY3QgdG9wIFwiICsgZmlyc3RDbGllbnRSZWN0RWxlbWVudC50b3AgKyBcIiwgcmVjdCBib3R0b20gXCIgKyBmaXJzdENsaWVudFJlY3RFbGVtZW50LmJvdHRvbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pblhFbGVtZW50RGVsdGFUb3BMZWZ0IDwgbW9zdFVwcGVyVmlzaWJsZURlbHRhVG9wTGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3N0VXBwZXJWaXNpYmxlRGVsdGFUb3BMZWZ0ID0gbWluWEVsZW1lbnREZWx0YVRvcExlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vc3RVcHBlclZpc2libGVJbmRleCA9IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLl92aXNpYmxlTGF5b3V0QXRvbUtleXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3N0VXBwZXJWaXNpYmxlTGF5b3V0QXRvbUlkID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGRvbU5vZGUsIFwibGlkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByb2Nlc3NlZEVsZW1lbnRDb3VudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtb3N0VXBwZXJWaXNpYmxlTGF5b3V0QXRvbUlkICE9IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLl9tb3N0VXBwZXJWaXNpYmxlTGF5b3V0QXRvbUlkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5fbW9zdFVwcGVyVmlzaWJsZUxheW91dEF0b21JZCA9IG1vc3RVcHBlclZpc2libGVMYXlvdXRBdG9tSWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAobW9zdFVwcGVyVmlzaWJsZUxheW91dEF0b21JZCAhPSAwICYmIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5pc1N5bmNlZFdpdGhQYWdlUHJldmlldykge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucGFnZVByZXZpZXcuc3luY1Njcm9sbFBvc2l0aW9uRnJvbUJveFRyZWUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiYm94VHJlZSBzY3JvbGw6IHByb2Nlc3NlZCBcIiArIHByb2Nlc3NlZEVsZW1lbnRDb3VudCArIFwiIG9iamVjdCBwb3NpdGlvbnMsIHZpc2libGU6IFwiICsgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuX3Zpc2libGVMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXMubGVuZ3RoLnRvU3RyaW5nKCkgKyBcIiBtb3N0IHVwcGVyIHZpc2libGUgaW5kZXg6IFwiICsgbW9zdFVwcGVyVmlzaWJsZUluZGV4ICsgXCIgbW9zdCB1cHBlciB2aXNpYmxlIGxheW91dCBpZDogXCIgKyB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5fbW9zdFVwcGVyVmlzaWJsZUxheW91dEF0b21JZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc3luY1Njcm9sbFBvc2l0aW9uRnJvbVBhZ2VQcmV2aWV3ID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuaXNTeW5jZWRXaXRoUGFnZVByZXZpZXcpIHtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRQcm9wZXJ0eUJhckluZGV4OiBudW1iZXIgPSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5wcm9wZXJ0eUJhckluZGV4O1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudFNjcm9sbERvbTogSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQgPSBjdXJyZW50QXBwLnByb3BlcnR5QmFyQm94VHJlZURvbVJlZmVyZW5jZXNbY3VycmVudFByb3BlcnR5QmFySW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudFNjcm9sbERvbSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3RhdGljT2Zmc2V0UHg6IG51bWJlciA9IGN1cnJlbnRTY3JvbGxEb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xyXG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldExheW91dEF0b21JZDogbnVtYmVyID0gY3VycmVudEFwcC5wYWdlUHJldmlldy5tb3N0VXBwZXJWaXNpYmxlTGF5b3V0QXRvbUlkO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0cmVlIGZyb20gcHJldmlldyBmb3IgdGFyZ2V0IGxheW91dCAjXCIgKyB0YXJnZXRMYXlvdXRBdG9tSWQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGRvbU5vZGVPZlRhcmdldExheW91dDogSFRNTEVsZW1lbnQgfCB1bmRlZmluZWQgPSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5fdmlzaWJsZUxheW91dEF0b21Eb21Ob2RlUmVmZXJlbmNlcy5maW5kKHIgPT4gcGFyc2VJbnRGcm9tQXR0cmlidXRlKHIsIFwibGlkXCIgLypUT0RPIHVzZSBkaWN0Ki8pID09IHRhcmdldExheW91dEF0b21JZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9tTm9kZU9mVGFyZ2V0TGF5b3V0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb21Ob2RlT2ZUYXJnZXRMYXlvdXQgPSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5fYWN0aXZlVmlld0xheW91dEF0b21Eb21Ob2RlUmVmZXJlbmNlc1t0YXJnZXRMYXlvdXRBdG9tSWRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRvbU5vZGVPZlRhcmdldExheW91dCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjcm9sbERvbS5zY3JvbGxUb3AgPSBjdXJyZW50U2Nyb2xsRG9tLnNjcm9sbFRvcCArIChkb21Ob2RlT2ZUYXJnZXRMYXlvdXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gc3RhdGljT2Zmc2V0UHgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyB0ZXN0IHdoZW4gdGhpcyBoYXBwZW5zIGFuZCBmaXhcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBib3hUcmVlQWZ0ZXJDcmVhdGVIYW5kbGVyID0gKGVsZW1lbnQ6IEVsZW1lbnQsIHByb2plY3Rpb25PcHRpb25zOiBtYXF1ZXR0ZS5Qcm9qZWN0aW9uT3B0aW9ucywgdm5vZGVTZWxlY3Rvcjogc3RyaW5nLCBwcm9wZXJ0aWVzOiBtYXF1ZXR0ZS5WTm9kZVByb3BlcnRpZXMsIGNoaWxkcmVuOiBWTm9kZVtdKSA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5wcm9wZXJ0eUJhckJveFRyZWVEb21SZWZlcmVuY2VzW3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXhdID0gZWxlbWVudCBhcyBIVE1MRGl2RWxlbWVudDtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGRlbGV0ZUNhbGlmb3JuaWFWaWV3Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCBkZWxldGVDYWxpZm9ybmlhVmlld0lkOiBudW1iZXIgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJ2aWRcIik7XHJcbiAgICAgICAgLy8gVE9ETyBhbHNvIG5lZWQgdG8gY2xlYXIgc3R1ZmYgdGhhdCBpcyBjb25uZWN0ZWQgdG8gdmlldy4uIHNlbGVjdGVkIHNwZWNpYWwgc3R5bGUgZXRjLlxyXG4gICAgICAgIGN1cnJlbnRBcHAucm91dGVyLmNsZWFyQ2FsaWZvcm5pYVByb3BlcnR5QmFycyhmYWxzZSwgZGVsZXRlQ2FsaWZvcm5pYVZpZXdJZCk7XHJcbiAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLkRlbGV0ZUNhbGlmb3JuaWFWaWV3SnNvbihkZWxldGVDYWxpZm9ybmlhVmlld0lkKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBpbnNlcnRMYXlvdXRSb3dJbnRvVmlld0NsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5kaXNwbGF5UG9wdXAoZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgUG9wdXBNb2RlLkluc2VydExheW91dFJvd0ludG9WaWV3KTtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSByZXNldFByZXNlbGVjdGVkTGF5b3V0Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAuc3RhdGUucHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQgPSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIGRyYXdIZWxwZXJMaW5lc0NsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAvLyBUT0RPIHNtb290aCBsaW5lIHVwZGF0ZSB3aGVuIHNjcm9sbGluZzogdXNlIGNzcyB0cmFuc2Zvcm0gdG8gY2hhbmdlIHN0YXJ0L2VuZCBub2RlIGRlcGVuZGVudCBvbiBzY3JvbGxlZCBkaXN0YW5jZSt3aW5kb3dcclxuICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmlzRHJhd0hlbHBlckxpbmVzID0gIWN1cnJlbnRBcHAuc3RhdGUuaXNEcmF3SGVscGVyTGluZXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgc3luY1dpdGhQYWdlUHJldmlld0NsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAvLyBvbmx5IGZvciB0aGUgZmlyc3QgcHJvcGVydHkgYmFyLCB0b2dnbGUgLy8gVE9ETyBkb2N1bWVudFxyXG4gICAgICAgIGxldCBjdXJyZW50UHJvcGVydHlCYXJJbmRleDogbnVtYmVyID0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIucHJvcGVydHlCYXJJbmRleDtcclxuICAgICAgICBsZXQgY3VycmVudFZpZXdNb2RlbDogUHJvcGVydHlCYXJWTSA9IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbDtcclxuICAgICAgICBpZiAoY3VycmVudFByb3BlcnR5QmFySW5kZXggPT0gMCkge1xyXG4gICAgICAgICAgICBjdXJyZW50Vmlld01vZGVsLmlzU3luY2VkV2l0aFBhZ2VQcmV2aWV3ID0gIWN1cnJlbnRWaWV3TW9kZWwuaXNTeW5jZWRXaXRoUGFnZVByZXZpZXc7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Vmlld01vZGVsLmlzU3luY2VkV2l0aFBhZ2VQcmV2aWV3KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsIHN5bmMgc2Nyb2xsIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudEJveFRyZWVEb21SZWZlcmVuY2U6IEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkID0gY3VycmVudEFwcC5wcm9wZXJ0eUJhckJveFRyZWVEb21SZWZlcmVuY2VzW2N1cnJlbnRQcm9wZXJ0eUJhckluZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Qm94VHJlZURvbVJlZmVyZW5jZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRCb3hUcmVlRG9tUmVmZXJlbmNlLnNjcm9sbFRvcCA8PSAxLjAvKnB4Ki8pIHsvLyBUT0RPIGRvY3VtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN5bmMgYm94dHJlZSBzY3JvbGwgb3JpZ2luYXRpbmcgaW4gcGFnZXByZXZpZXdcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc3luY1Njcm9sbFBvc2l0aW9uRnJvbVBhZ2VQcmV2aWV3KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzeW5jIHBhZ2VwcmV2aWV3IHNjcm9sbCBvcmlnaW5hdGluZyBpbiBib3h0cmVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucGFnZVByZXZpZXcuc3luY1Njcm9sbFBvc2l0aW9uRnJvbUJveFRyZWUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgc3luY1dpdGhMZWZ0UHJvcGVydHlCYXJDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgLy8gZGVmYXVsdCB3aGVuIHByb3BlcnR5IGJhciBpbW1lZGlhdGVseSB0byB0aGUgbGVmdCBkaXNwbGF5cyBlcXVpdmFsZW50IGJveCB0cmVlOiB0b2dnbGUgc3luYyAvLyBUT0RPIGRvY3VtZW50XHJcbiAgICAgICAgLy8gVE9ETyBpbnN0ZWFkOiByZW5kZXIgaW4gc2FtZSBkaXYgdG8gc3luY2hyb25pemUgc2Nyb2xsXHJcbiAgICAgICAgbGV0IGN1cnJlbnRQcm9wZXJ0eUJhckluZGV4OiBudW1iZXIgPSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5wcm9wZXJ0eUJhckluZGV4O1xyXG4gICAgICAgIGxldCBjdXJyZW50Vmlld01vZGVsOiBQcm9wZXJ0eUJhclZNID0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsO1xyXG4gICAgICAgIGlmIChjdXJyZW50UHJvcGVydHlCYXJJbmRleCAhPSAwXHJcbiAgICAgICAgICAgICYmIGN1cnJlbnRBcHAucHJvcGVydHlCYXJWTXNbY3VycmVudFByb3BlcnR5QmFySW5kZXggLSAxXS5jdXJyZW50UHJvcGVydHlCYXJNb2RlID09PSBQcm9wZXJ0eUJhck1vZGUuQ2FsaWZvcm5pYVZpZXdcclxuICAgICAgICAgICAgJiYgY3VycmVudEFwcC5wcm9wZXJ0eUJhclZNc1tjdXJyZW50UHJvcGVydHlCYXJJbmRleCAtIDFdLnNlbGVjdGVkQ2FsaWZvcm5pYVZpZXdJZCA9PSBjdXJyZW50Vmlld01vZGVsLnNlbGVjdGVkQ2FsaWZvcm5pYVZpZXdJZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50Vmlld01vZGVsLmlzU3luY2VkV2l0aEJveFRyZWVUb1RoZUxlZnQgPSAhY3VycmVudFZpZXdNb2RlbC5pc1N5bmNlZFdpdGhCb3hUcmVlVG9UaGVMZWZ0O1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudFZpZXdNb2RlbC5pc1N5bmNlZFdpdGhCb3hUcmVlVG9UaGVMZWZ0ID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsIHN5bmMgc2Nyb2xsIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudEJveFRyZWVEb21SZWZlcmVuY2U6IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkID0gY3VycmVudEFwcC5wcm9wZXJ0eUJhckJveFRyZWVEb21SZWZlcmVuY2VzW2N1cnJlbnRQcm9wZXJ0eUJhckluZGV4XTtcclxuICAgICAgICAgICAgICAgIGxldCBvdGhlckJveFRyZWVEb21SZWZlcmVuY2U6IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkID0gY3VycmVudEFwcC5wcm9wZXJ0eUJhckJveFRyZWVEb21SZWZlcmVuY2VzW2N1cnJlbnRQcm9wZXJ0eUJhckluZGV4IC0gMV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEJveFRyZWVEb21SZWZlcmVuY2UgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICYmIG90aGVyQm94VHJlZURvbVJlZmVyZW5jZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJCb3hUcmVlRG9tUmVmZXJlbmNlLnNjcm9sbFRvcCA9IGN1cnJlbnRCb3hUcmVlRG9tUmVmZXJlbmNlLnNjcm9sbFRvcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Vmlld01vZGVsLmlzU3luY2VkV2l0aEJveFRyZWVUb1RoZUxlZnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3VycmVudFZpZXdNb2RlbC5pc1N5bmNlZFdpdGhCb3hUcmVlVG9UaGVMZWZ0ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL01vZGVscy9Qcm9wZXJ0eUJhci50c3giLCIvKiEgVmVsb2NpdHlKUy5vcmcgKDEuNS4wKS4gKEMpIDIwMTQgSnVsaWFuIFNoYXBpcm8uIE1JVCBAbGljZW5zZTogZW4ud2lraXBlZGlhLm9yZy93aWtpL01JVF9MaWNlbnNlICovXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqXG4gVmVsb2NpdHkgalF1ZXJ5IFNoaW1cbiAqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKiEgVmVsb2NpdHlKUy5vcmcgalF1ZXJ5IFNoaW0gKDEuMC4xKS4gKEMpIDIwMTQgVGhlIGpRdWVyeSBGb3VuZGF0aW9uLiBNSVQgQGxpY2Vuc2U6IGVuLndpa2lwZWRpYS5vcmcvd2lraS9NSVRfTGljZW5zZS4gKi9cblxuLyogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBqUXVlcnkgZnVuY3Rpb25zIHRoYXQgVmVsb2NpdHkgcmVsaWVzIG9uLCB0aGVyZWJ5IHJlbW92aW5nIFZlbG9jaXR5J3MgZGVwZW5kZW5jeSBvbiBhIGZ1bGwgY29weSBvZiBqUXVlcnksIGFuZCBhbGxvd2luZyBpdCB0byB3b3JrIGluIGFueSBlbnZpcm9ubWVudC4gKi9cbi8qIFRoZXNlIHNoaW1tZWQgZnVuY3Rpb25zIGFyZSBvbmx5IHVzZWQgaWYgalF1ZXJ5IGlzbid0IHByZXNlbnQuIElmIGJvdGggdGhpcyBzaGltIGFuZCBqUXVlcnkgYXJlIGxvYWRlZCwgVmVsb2NpdHkgZGVmYXVsdHMgdG8galF1ZXJ5IHByb3Blci4gKi9cbi8qIEJyb3dzZXIgc3VwcG9ydDogVXNpbmcgdGhpcyBzaGltIGluc3RlYWQgb2YgalF1ZXJ5IHByb3BlciByZW1vdmVzIHN1cHBvcnQgZm9yIElFOC4gKi9cblxuKGZ1bmN0aW9uKHdpbmRvdykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0LyoqKioqKioqKioqKioqKlxuXHQgU2V0dXBcblx0ICoqKioqKioqKioqKioqKi9cblxuXHQvKiBJZiBqUXVlcnkgaXMgYWxyZWFkeSBsb2FkZWQsIHRoZXJlJ3Mgbm8gcG9pbnQgaW4gbG9hZGluZyB0aGlzIHNoaW0uICovXG5cdGlmICh3aW5kb3cualF1ZXJ5KSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0LyogalF1ZXJ5IGJhc2UuICovXG5cdHZhciAkID0gZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQpIHtcblx0XHRyZXR1cm4gbmV3ICQuZm4uaW5pdChzZWxlY3RvciwgY29udGV4dCk7XG5cdH07XG5cblx0LyoqKioqKioqKioqKioqKioqKioqXG5cdCBQcml2YXRlIE1ldGhvZHNcblx0ICoqKioqKioqKioqKioqKioqKioqL1xuXG5cdC8qIGpRdWVyeSAqL1xuXHQkLmlzV2luZG93ID0gZnVuY3Rpb24ob2JqKSB7XG5cdFx0LyoganNoaW50IGVxZXFlcTogZmFsc2UgKi9cblx0XHRyZXR1cm4gb2JqICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fTtcblxuXHQvKiBqUXVlcnkgKi9cblx0JC50eXBlID0gZnVuY3Rpb24ob2JqKSB7XG5cdFx0aWYgKCFvYmopIHtcblx0XHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHRcdH1cblxuXHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0XHRcdGNsYXNzMnR5cGVbdG9TdHJpbmcuY2FsbChvYmopXSB8fCBcIm9iamVjdFwiIDpcblx0XHRcdFx0dHlwZW9mIG9iajtcblx0fTtcblxuXHQvKiBqUXVlcnkgKi9cblx0JC5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcblx0XHRyZXR1cm4gJC50eXBlKG9iaikgPT09IFwiYXJyYXlcIjtcblx0fTtcblxuXHQvKiBqUXVlcnkgKi9cblx0ZnVuY3Rpb24gaXNBcnJheWxpa2Uob2JqKSB7XG5cdFx0dmFyIGxlbmd0aCA9IG9iai5sZW5ndGgsXG5cdFx0XHRcdHR5cGUgPSAkLnR5cGUob2JqKTtcblxuXHRcdGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIgfHwgJC5pc1dpbmRvdyhvYmopKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKG9iai5ub2RlVHlwZSA9PT0gMSAmJiBsZW5ndGgpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8IHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAobGVuZ3RoIC0gMSkgaW4gb2JqO1xuXHR9XG5cblx0LyoqKioqKioqKioqKioqKlxuXHQgJCBNZXRob2RzXG5cdCAqKioqKioqKioqKioqKiovXG5cblx0LyogalF1ZXJ5OiBTdXBwb3J0IHJlbW92ZWQgZm9yIElFPDkuICovXG5cdCQuaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuXHRcdHZhciBrZXk7XG5cblx0XHRpZiAoIW9iaiB8fCAkLnR5cGUob2JqKSAhPT0gXCJvYmplY3RcIiB8fCBvYmoubm9kZVR5cGUgfHwgJC5pc1dpbmRvdyhvYmopKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dHJ5IHtcblx0XHRcdGlmIChvYmouY29uc3RydWN0b3IgJiZcblx0XHRcdFx0XHQhaGFzT3duLmNhbGwob2JqLCBcImNvbnN0cnVjdG9yXCIpICYmXG5cdFx0XHRcdFx0IWhhc093bi5jYWxsKG9iai5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwiaXNQcm90b3R5cGVPZlwiKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIG9iaikge1xuXHRcdH1cblxuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCB8fCBoYXNPd24uY2FsbChvYmosIGtleSk7XG5cdH07XG5cblx0LyogalF1ZXJ5ICovXG5cdCQuZWFjaCA9IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2ssIGFyZ3MpIHtcblx0XHR2YXIgdmFsdWUsXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoLFxuXHRcdFx0XHRpc0FycmF5ID0gaXNBcnJheWxpa2Uob2JqKTtcblxuXHRcdGlmIChhcmdzKSB7XG5cdFx0XHRpZiAoaXNBcnJheSkge1xuXHRcdFx0XHRmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5hcHBseShvYmpbaV0sIGFyZ3MpO1xuXG5cdFx0XHRcdFx0aWYgKHZhbHVlID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKGkgaW4gb2JqKSB7XG5cdFx0XHRcdFx0aWYgKCFvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrLmFwcGx5KG9ialtpXSwgYXJncyk7XG5cblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoaXNBcnJheSkge1xuXHRcdFx0XHRmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5jYWxsKG9ialtpXSwgaSwgb2JqW2ldKTtcblxuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yIChpIGluIG9iaikge1xuXHRcdFx0XHRcdGlmICghb2JqLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5jYWxsKG9ialtpXSwgaSwgb2JqW2ldKTtcblxuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH07XG5cblx0LyogQ3VzdG9tICovXG5cdCQuZGF0YSA9IGZ1bmN0aW9uKG5vZGUsIGtleSwgdmFsdWUpIHtcblx0XHQvKiAkLmdldERhdGEoKSAqL1xuXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR2YXIgZ2V0SWQgPSBub2RlWyQuZXhwYW5kb10sXG5cdFx0XHRcdFx0c3RvcmUgPSBnZXRJZCAmJiBjYWNoZVtnZXRJZF07XG5cblx0XHRcdGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gc3RvcmU7XG5cdFx0XHR9IGVsc2UgaWYgKHN0b3JlKSB7XG5cdFx0XHRcdGlmIChrZXkgaW4gc3RvcmUpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RvcmVba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0LyogJC5zZXREYXRhKCkgKi9cblx0XHR9IGVsc2UgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR2YXIgc2V0SWQgPSBub2RlWyQuZXhwYW5kb10gfHwgKG5vZGVbJC5leHBhbmRvXSA9ICsrJC51dWlkKTtcblxuXHRcdFx0Y2FjaGVbc2V0SWRdID0gY2FjaGVbc2V0SWRdIHx8IHt9O1xuXHRcdFx0Y2FjaGVbc2V0SWRdW2tleV0gPSB2YWx1ZTtcblxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0fTtcblxuXHQvKiBDdXN0b20gKi9cblx0JC5yZW1vdmVEYXRhID0gZnVuY3Rpb24obm9kZSwga2V5cykge1xuXHRcdHZhciBpZCA9IG5vZGVbJC5leHBhbmRvXSxcblx0XHRcdFx0c3RvcmUgPSBpZCAmJiBjYWNoZVtpZF07XG5cblx0XHRpZiAoc3RvcmUpIHtcblx0XHRcdC8vIENsZWFudXAgdGhlIGVudGlyZSBzdG9yZSBpZiBubyBrZXlzIGFyZSBwcm92aWRlZC5cblx0XHRcdGlmICgha2V5cykge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbaWRdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JC5lYWNoKGtleXMsIGZ1bmN0aW9uKF8sIGtleSkge1xuXHRcdFx0XHRcdGRlbGV0ZSBzdG9yZVtrZXldO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyogalF1ZXJ5ICovXG5cdCQuZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNyYywgY29weUlzQXJyYXksIGNvcHksIG5hbWUsIG9wdGlvbnMsIGNsb25lLFxuXHRcdFx0XHR0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXG5cdFx0XHRcdGkgPSAxLFxuXHRcdFx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdFx0XHRkZWVwID0gZmFsc2U7XG5cblx0XHRpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIpIHtcblx0XHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHRcdHRhcmdldCA9IGFyZ3VtZW50c1tpXSB8fCB7fTtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAkLnR5cGUodGFyZ2V0KSAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR0YXJnZXQgPSB7fTtcblx0XHR9XG5cblx0XHRpZiAoaSA9PT0gbGVuZ3RoKSB7XG5cdFx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdFx0aS0tO1xuXHRcdH1cblxuXHRcdGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICgob3B0aW9ucyA9IGFyZ3VtZW50c1tpXSkpIHtcblx0XHRcdFx0Zm9yIChuYW1lIGluIG9wdGlvbnMpIHtcblx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzcmMgPSB0YXJnZXRbbmFtZV07XG5cdFx0XHRcdFx0Y29weSA9IG9wdGlvbnNbbmFtZV07XG5cblx0XHRcdFx0XHRpZiAodGFyZ2V0ID09PSBjb3B5KSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZGVlcCAmJiBjb3B5ICYmICgkLmlzUGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0gJC5pc0FycmF5KGNvcHkpKSkpIHtcblx0XHRcdFx0XHRcdGlmIChjb3B5SXNBcnJheSkge1xuXHRcdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiAkLmlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiAkLmlzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0YXJnZXRbbmFtZV0gPSAkLmV4dGVuZChkZWVwLCBjbG9uZSwgY29weSk7XG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGNvcHkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W25hbWVdID0gY29weTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9O1xuXG5cdC8qIGpRdWVyeSAxLjQuMyAqL1xuXHQkLnF1ZXVlID0gZnVuY3Rpb24oZWxlbSwgdHlwZSwgZGF0YSkge1xuXHRcdGZ1bmN0aW9uICRtYWtlQXJyYXkoYXJyLCByZXN1bHRzKSB7XG5cdFx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdFx0aWYgKGFycikge1xuXHRcdFx0XHRpZiAoaXNBcnJheWxpa2UoT2JqZWN0KGFycikpKSB7XG5cdFx0XHRcdFx0LyogJC5tZXJnZSAqL1xuXHRcdFx0XHRcdChmdW5jdGlvbihmaXJzdCwgc2Vjb25kKSB7XG5cdFx0XHRcdFx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcdFx0aiA9IDAsXG5cdFx0XHRcdFx0XHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdFx0XHRcdFx0d2hpbGUgKGogPCBsZW4pIHtcblx0XHRcdFx0XHRcdFx0Zmlyc3RbaSsrXSA9IHNlY29uZFtqKytdO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAobGVuICE9PSBsZW4pIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKHNlY29uZFtqXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zmlyc3RbaSsrXSA9IHNlY29uZFtqKytdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRcdFx0XHRcdHJldHVybiBmaXJzdDtcblx0XHRcdFx0XHR9KShyZXQsIHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgPyBbYXJyXSA6IGFycik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0W10ucHVzaC5jYWxsKHJldCwgYXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdGlmICghZWxlbSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHR5cGUgPSAodHlwZSB8fCBcImZ4XCIpICsgXCJxdWV1ZVwiO1xuXG5cdFx0dmFyIHEgPSAkLmRhdGEoZWxlbSwgdHlwZSk7XG5cblx0XHRpZiAoIWRhdGEpIHtcblx0XHRcdHJldHVybiBxIHx8IFtdO1xuXHRcdH1cblxuXHRcdGlmICghcSB8fCAkLmlzQXJyYXkoZGF0YSkpIHtcblx0XHRcdHEgPSAkLmRhdGEoZWxlbSwgdHlwZSwgJG1ha2VBcnJheShkYXRhKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHEucHVzaChkYXRhKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcTtcblx0fTtcblxuXHQvKiBqUXVlcnkgMS40LjMgKi9cblx0JC5kZXF1ZXVlID0gZnVuY3Rpb24oZWxlbXMsIHR5cGUpIHtcblx0XHQvKiBDdXN0b206IEVtYmVkIGVsZW1lbnQgaXRlcmF0aW9uLiAqL1xuXHRcdCQuZWFjaChlbGVtcy5ub2RlVHlwZSA/IFtlbGVtc10gOiBlbGVtcywgZnVuY3Rpb24oaSwgZWxlbSkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0XHR2YXIgcXVldWUgPSAkLnF1ZXVlKGVsZW0sIHR5cGUpLFxuXHRcdFx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblxuXHRcdFx0aWYgKGZuID09PSBcImlucHJvZ3Jlc3NcIikge1xuXHRcdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChmbikge1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gXCJmeFwiKSB7XG5cdFx0XHRcdFx0cXVldWUudW5zaGlmdChcImlucHJvZ3Jlc3NcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmbi5jYWxsKGVsZW0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdCQuZGVxdWV1ZShlbGVtLCB0eXBlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG5cblx0LyoqKioqKioqKioqKioqKioqKlxuXHQgJC5mbiBNZXRob2RzXG5cdCAqKioqKioqKioqKioqKioqKiovXG5cblx0LyogalF1ZXJ5ICovXG5cdCQuZm4gPSAkLnByb3RvdHlwZSA9IHtcblx0XHRpbml0OiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdFx0LyogSnVzdCByZXR1cm4gdGhlIGVsZW1lbnQgd3JhcHBlZCBpbnNpZGUgYW4gYXJyYXk7IGRvbid0IHByb2NlZWQgd2l0aCB0aGUgYWN0dWFsIGpRdWVyeSBub2RlIHdyYXBwaW5nIHByb2Nlc3MuICovXG5cdFx0XHRpZiAoc2VsZWN0b3Iubm9kZVR5cGUpIHtcblx0XHRcdFx0dGhpc1swXSA9IHNlbGVjdG9yO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTm90IGEgRE9NIG5vZGUuXCIpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0b2Zmc2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdC8qIGpRdWVyeSBhbHRlcmVkIGNvZGU6IERyb3BwZWQgZGlzY29ubmVjdGVkIERPTSBub2RlIGNoZWNraW5nLiAqL1xuXHRcdFx0dmFyIGJveCA9IHRoaXNbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID8gdGhpc1swXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHt0b3A6IDAsIGxlZnQ6IDB9O1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0b3A6IGJveC50b3AgKyAod2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LnNjcm9sbFRvcCB8fCAwKSAtIChkb2N1bWVudC5jbGllbnRUb3AgfHwgMCksXG5cdFx0XHRcdGxlZnQ6IGJveC5sZWZ0ICsgKHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5zY3JvbGxMZWZ0IHx8IDApIC0gKGRvY3VtZW50LmNsaWVudExlZnQgfHwgMClcblx0XHRcdH07XG5cdFx0fSxcblx0XHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHQvKiBqUXVlcnkgKi9cblx0XHRcdGZ1bmN0aW9uIG9mZnNldFBhcmVudEZuKGVsZW0pIHtcblx0XHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHRcdHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgKG9mZnNldFBhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcImh0bWxcIiAmJiBvZmZzZXRQYXJlbnQuc3R5bGUgJiYgb2Zmc2V0UGFyZW50LnN0eWxlLnBvc2l0aW9uLnRvTG93ZXJDYXNlKCkgPT09IFwic3RhdGljXCIpKSB7XG5cdFx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Lm9mZnNldFBhcmVudDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnQ7XG5cdFx0XHR9XG5cblx0XHRcdC8qIFplcHRvICovXG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbMF0sXG5cdFx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50Rm4oZWxlbSksXG5cdFx0XHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKSxcblx0XHRcdFx0XHRwYXJlbnRPZmZzZXQgPSAvXig/OmJvZHl8aHRtbCkkL2kudGVzdChvZmZzZXRQYXJlbnQubm9kZU5hbWUpID8ge3RvcDogMCwgbGVmdDogMH0gOiAkKG9mZnNldFBhcmVudCkub2Zmc2V0KCk7XG5cblx0XHRcdG9mZnNldC50b3AgLT0gcGFyc2VGbG9hdChlbGVtLnN0eWxlLm1hcmdpblRvcCkgfHwgMDtcblx0XHRcdG9mZnNldC5sZWZ0IC09IHBhcnNlRmxvYXQoZWxlbS5zdHlsZS5tYXJnaW5MZWZ0KSB8fCAwO1xuXG5cdFx0XHRpZiAob2Zmc2V0UGFyZW50LnN0eWxlKSB7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0gcGFyc2VGbG9hdChvZmZzZXRQYXJlbnQuc3R5bGUuYm9yZGVyVG9wV2lkdGgpIHx8IDA7XG5cdFx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IHBhcnNlRmxvYXQob2Zmc2V0UGFyZW50LnN0eWxlLmJvcmRlckxlZnRXaWR0aCkgfHwgMDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCxcblx0XHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdFxuXHRcdFx0fTtcblx0XHR9XG5cdH07XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKipcblx0IFByaXZhdGUgVmFyaWFibGVzXG5cdCAqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdC8qIEZvciAkLmRhdGEoKSAqL1xuXHR2YXIgY2FjaGUgPSB7fTtcblx0JC5leHBhbmRvID0gXCJ2ZWxvY2l0eVwiICsgKG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcblx0JC51dWlkID0gMDtcblxuXHQvKiBGb3IgJC5xdWV1ZSgpICovXG5cdHZhciBjbGFzczJ0eXBlID0ge30sXG5cdFx0XHRoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5LFxuXHRcdFx0dG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG5cdHZhciB0eXBlcyA9IFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvclwiLnNwbGl0KFwiIFwiKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuXHRcdGNsYXNzMnR5cGVbXCJbb2JqZWN0IFwiICsgdHlwZXNbaV0gKyBcIl1cIl0gPSB0eXBlc1tpXS50b0xvd2VyQ2FzZSgpO1xuXHR9XG5cblx0LyogTWFrZXMgJChub2RlKSBwb3NzaWJsZSwgd2l0aG91dCBoYXZpbmcgdG8gY2FsbCBpbml0LiAqL1xuXHQkLmZuLmluaXQucHJvdG90eXBlID0gJC5mbjtcblxuXHQvKiBHbG9iYWxpemUgVmVsb2NpdHkgb250byB0aGUgd2luZG93LCBhbmQgYXNzaWduIGl0cyBVdGlsaXRpZXMgcHJvcGVydHkuICovXG5cdHdpbmRvdy5WZWxvY2l0eSA9IHtVdGlsaXRpZXM6ICR9O1xufSkod2luZG93KTtcblxuLyoqKioqKioqKioqKioqKioqKlxuIFZlbG9jaXR5LmpzXG4gKioqKioqKioqKioqKioqKioqL1xuXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0LyogQ29tbW9uSlMgbW9kdWxlLiAqL1xuXHRpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0XHQvKiBBTUQgbW9kdWxlLiAqL1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0ZGVmaW5lKGZhY3RvcnkpO1xuXHRcdC8qIEJyb3dzZXIgZ2xvYmFscy4gKi9cblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCk7XG5cdH1cbn0oZnVuY3Rpb24oKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRyZXR1cm4gZnVuY3Rpb24oZ2xvYmFsLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcblxuXHRcdC8qKioqKioqKioqKioqKipcblx0XHQgU3VtbWFyeVxuXHRcdCAqKioqKioqKioqKioqKiovXG5cblx0XHQvKlxuXHRcdCAtIENTUzogQ1NTIHN0YWNrIHRoYXQgd29ya3MgaW5kZXBlbmRlbnRseSBmcm9tIHRoZSByZXN0IG9mIFZlbG9jaXR5LlxuXHRcdCAtIGFuaW1hdGUoKTogQ29yZSBhbmltYXRpb24gbWV0aG9kIHRoYXQgaXRlcmF0ZXMgb3ZlciB0aGUgdGFyZ2V0ZWQgZWxlbWVudHMgYW5kIHF1ZXVlcyB0aGUgaW5jb21pbmcgY2FsbCBvbnRvIGVhY2ggZWxlbWVudCBpbmRpdmlkdWFsbHkuXG5cdFx0IC0gUHJlLVF1ZXVlaW5nOiBQcmVwYXJlIHRoZSBlbGVtZW50IGZvciBhbmltYXRpb24gYnkgaW5zdGFudGlhdGluZyBpdHMgZGF0YSBjYWNoZSBhbmQgcHJvY2Vzc2luZyB0aGUgY2FsbCdzIG9wdGlvbnMuXG5cdFx0IC0gUXVldWVpbmc6IFRoZSBsb2dpYyB0aGF0IHJ1bnMgb25jZSB0aGUgY2FsbCBoYXMgcmVhY2hlZCBpdHMgcG9pbnQgb2YgZXhlY3V0aW9uIGluIHRoZSBlbGVtZW50J3MgJC5xdWV1ZSgpIHN0YWNrLlxuXHRcdCBNb3N0IGxvZ2ljIGlzIHBsYWNlZCBoZXJlIHRvIGF2b2lkIHJpc2tpbmcgaXQgYmVjb21pbmcgc3RhbGUgKGlmIHRoZSBlbGVtZW50J3MgcHJvcGVydGllcyBoYXZlIGNoYW5nZWQpLlxuXHRcdCAtIFB1c2hpbmc6IENvbnNvbGlkYXRpb24gb2YgdGhlIHR3ZWVuIGRhdGEgZm9sbG93ZWQgYnkgaXRzIHB1c2ggb250byB0aGUgZ2xvYmFsIGluLXByb2dyZXNzIGNhbGxzIGNvbnRhaW5lci5cblx0XHQgLSB0aWNrKCk6IFRoZSBzaW5nbGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGxvb3AgcmVzcG9uc2libGUgZm9yIHR3ZWVuaW5nIGFsbCBpbi1wcm9ncmVzcyBjYWxscy5cblx0XHQgLSBjb21wbGV0ZUNhbGwoKTogSGFuZGxlcyB0aGUgY2xlYW51cCBwcm9jZXNzIGZvciBlYWNoIFZlbG9jaXR5IGNhbGwuXG5cdFx0ICovXG5cblx0XHQvKioqKioqKioqKioqKioqKioqKioqXG5cdFx0IEhlbHBlciBGdW5jdGlvbnNcblx0XHQgKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0LyogSUUgZGV0ZWN0aW9uLiBHaXN0OiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qdWxpYW5zaGFwaXJvLzkwOTg2MDkgKi9cblx0XHR2YXIgSUUgPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSB7XG5cdFx0XHRcdHJldHVybiBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gNzsgaSA+IDQ7IGktLSkge1xuXHRcdFx0XHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG5cdFx0XHRcdFx0ZGl2LmlubmVySFRNTCA9IFwiPCEtLVtpZiBJRSBcIiArIGkgKyBcIl0+PHNwYW4+PC9zcGFuPjwhW2VuZGlmXS0tPlwiO1xuXG5cdFx0XHRcdFx0aWYgKGRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNwYW5cIikubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRkaXYgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9KSgpO1xuXG5cdFx0LyogckFGIHNoaW0uIEdpc3Q6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2p1bGlhbnNoYXBpcm8vOTQ5NzUxMyAqL1xuXHRcdHZhciByQUZTaGltID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRpbWVMYXN0ID0gMDtcblxuXHRcdFx0cmV0dXJuIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0XHR2YXIgdGltZUN1cnJlbnQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpLFxuXHRcdFx0XHRcdFx0dGltZURlbHRhO1xuXG5cdFx0XHRcdC8qIER5bmFtaWNhbGx5IHNldCBkZWxheSBvbiBhIHBlci10aWNrIGJhc2lzIHRvIG1hdGNoIDYwZnBzLiAqL1xuXHRcdFx0XHQvKiBUZWNobmlxdWUgYnkgRXJpayBNb2xsZXIuIE1JVCBsaWNlbnNlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsaXJpc2gvMTU3OTY3MSAqL1xuXHRcdFx0XHR0aW1lRGVsdGEgPSBNYXRoLm1heCgwLCAxNiAtICh0aW1lQ3VycmVudCAtIHRpbWVMYXN0KSk7XG5cdFx0XHRcdHRpbWVMYXN0ID0gdGltZUN1cnJlbnQgKyB0aW1lRGVsdGE7XG5cblx0XHRcdFx0cmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sodGltZUN1cnJlbnQgKyB0aW1lRGVsdGEpO1xuXHRcdFx0XHR9LCB0aW1lRGVsdGEpO1xuXHRcdFx0fTtcblx0XHR9KSgpO1xuXG5cdFx0dmFyIHBlcmZvcm1hbmNlID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHBlcmYgPSB3aW5kb3cucGVyZm9ybWFuY2UgfHwge307XG5cblx0XHRcdGlmICh0eXBlb2YgcGVyZi5ub3cgIT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0XHR2YXIgbm93T2Zmc2V0ID0gcGVyZi50aW1pbmcgJiYgcGVyZi50aW1pbmcubmF2aWdhdGlvblN0YXJ0ID8gcGVyZi50aW1pbmcubmF2aWdhdGlvblN0YXJ0IDogKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuXHRcdFx0XHRwZXJmLm5vdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gbm93T2Zmc2V0O1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBlcmY7XG5cdFx0fSkoKTtcblxuXHRcdC8qIEFycmF5IGNvbXBhY3RpbmcuIENvcHlyaWdodCBMby1EYXNoLiBNSVQgTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvTElDRU5TRS50eHQgKi9cblx0XHRmdW5jdGlvbiBjb21wYWN0U3BhcnNlQXJyYXkoYXJyYXkpIHtcblx0XHRcdHZhciBpbmRleCA9IC0xLFxuXHRcdFx0XHRcdGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcblx0XHRcdFx0XHRyZXN1bHQgPSBbXTtcblxuXHRcdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG5cdFx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFNoaW0gZm9yIFwiZml4aW5nXCIgSUUncyBsYWNrIG9mIHN1cHBvcnQgKElFIDwgOSkgZm9yIGFwcGx5aW5nIHNsaWNlXG5cdFx0ICogb24gaG9zdCBvYmplY3RzIGxpa2UgTmFtZWROb2RlTWFwLCBOb2RlTGlzdCwgYW5kIEhUTUxDb2xsZWN0aW9uXG5cdFx0ICogKHRlY2huaWNhbGx5LCBzaW5jZSBob3N0IG9iamVjdHMgaGF2ZSBiZWVuIGltcGxlbWVudGF0aW9uLWRlcGVuZGVudCxcblx0XHQgKiBhdCBsZWFzdCBiZWZvcmUgRVMyMDE1LCBJRSBoYXNuJ3QgbmVlZGVkIHRvIHdvcmsgdGhpcyB3YXkpLlxuXHRcdCAqIEFsc28gd29ya3Mgb24gc3RyaW5ncywgZml4ZXMgSUUgPCA5IHRvIGFsbG93IGFuIGV4cGxpY2l0IHVuZGVmaW5lZFxuXHRcdCAqIGZvciB0aGUgMm5kIGFyZ3VtZW50IChhcyBpbiBGaXJlZm94KSwgYW5kIHByZXZlbnRzIGVycm9ycyB3aGVuXG5cdFx0ICogY2FsbGVkIG9uIG90aGVyIERPTSBvYmplY3RzLlxuXHRcdCAqL1xuXHRcdHZhciBfc2xpY2UgPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIENhbid0IGJlIHVzZWQgd2l0aCBET00gZWxlbWVudHMgaW4gSUUgPCA5XG5cdFx0XHRcdHNsaWNlLmNhbGwoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcblx0XHRcdFx0cmV0dXJuIHNsaWNlO1xuXHRcdFx0fSBjYXRjaCAoZSkgeyAvLyBGYWlscyBpbiBJRSA8IDlcblxuXHRcdFx0XHQvLyBUaGlzIHdpbGwgd29yayBmb3IgZ2VudWluZSBhcnJheXMsIGFycmF5LWxpa2Ugb2JqZWN0cywgXG5cdFx0XHRcdC8vIE5hbWVkTm9kZU1hcCAoYXR0cmlidXRlcywgZW50aXRpZXMsIG5vdGF0aW9ucyksXG5cdFx0XHRcdC8vIE5vZGVMaXN0IChlLmcuLCBnZXRFbGVtZW50c0J5VGFnTmFtZSksIEhUTUxDb2xsZWN0aW9uIChlLmcuLCBjaGlsZE5vZGVzKSxcblx0XHRcdFx0Ly8gYW5kIHdpbGwgbm90IGZhaWwgb24gb3RoZXIgRE9NIG9iamVjdHMgKGFzIGRvIERPTSBlbGVtZW50cyBpbiBJRSA8IDkpXG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG5cdFx0XHRcdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBiZWdpbiAhPT0gXCJudW1iZXJcIikge1xuXHRcdFx0XHRcdFx0YmVnaW4gPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBJRSA8IDkgZ2V0cyB1bmhhcHB5IHdpdGggYW4gdW5kZWZpbmVkIGVuZCBhcmd1bWVudFxuXHRcdFx0XHRcdGlmICh0eXBlb2YgZW5kICE9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0XHRlbmQgPSBsZW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIEZvciBuYXRpdmUgQXJyYXkgb2JqZWN0cywgd2UgdXNlIHRoZSBuYXRpdmUgc2xpY2UgZnVuY3Rpb25cblx0XHRcdFx0XHRpZiAodGhpcy5zbGljZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwodGhpcywgYmVnaW4sIGVuZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIEZvciBhcnJheSBsaWtlIG9iamVjdCB3ZSBoYW5kbGUgaXQgb3Vyc2VsdmVzLlxuXHRcdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdFx0XHRjbG9uZWQgPSBbXSxcblx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIG5lZ2F0aXZlIHZhbHVlIGZvciBcImJlZ2luXCJcblx0XHRcdFx0XHRcdFx0c3RhcnQgPSAoYmVnaW4gPj0gMCkgPyBiZWdpbiA6IE1hdGgubWF4KDAsIGxlbiArIGJlZ2luKSxcblx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIG5lZ2F0aXZlIHZhbHVlIGZvciBcImVuZFwiXG5cdFx0XHRcdFx0XHRcdHVwVG8gPSBlbmQgPCAwID8gbGVuICsgZW5kIDogTWF0aC5taW4oZW5kLCBsZW4pLFxuXHRcdFx0XHRcdFx0XHQvLyBBY3R1YWwgZXhwZWN0ZWQgc2l6ZSBvZiB0aGUgc2xpY2Vcblx0XHRcdFx0XHRcdFx0c2l6ZSA9IHVwVG8gLSBzdGFydDtcblxuXHRcdFx0XHRcdGlmIChzaXplID4gMCkge1xuXHRcdFx0XHRcdFx0Y2xvbmVkID0gbmV3IEFycmF5KHNpemUpO1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMuY2hhckF0KSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRjbG9uZWRbaV0gPSB0aGlzLmNoYXJBdChzdGFydCArIGkpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2xvbmVkW2ldID0gdGhpc1tzdGFydCArIGldO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBjbG9uZWQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fSkoKTtcblxuXHRcdC8qIC5pbmRleE9mIGRvZXNuJ3QgZXhpc3QgaW4gSUU8OSAqL1xuXHRcdHZhciBfaW5BcnJheSA9IChmdW5jdGlvbigpIHtcblx0XHRcdGlmIChBcnJheS5wcm90b3R5cGUuaW5jbHVkZXMpIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGFyciwgdmFsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGFyci5pbmNsdWRlcyh2YWwpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbihhcnIsIHZhbCkge1xuXHRcdFx0XHRcdHJldHVybiBhcnIuaW5kZXhPZih2YWwpID49IDA7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oYXJyLCB2YWwpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoYXJyW2ldID09PSB2YWwpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pO1xuXG5cdFx0ZnVuY3Rpb24gc2FuaXRpemVFbGVtZW50cyhlbGVtZW50cykge1xuXHRcdFx0LyogVW53cmFwIGpRdWVyeS9aZXB0byBvYmplY3RzLiAqL1xuXHRcdFx0aWYgKFR5cGUuaXNXcmFwcGVkKGVsZW1lbnRzKSkge1xuXHRcdFx0XHRlbGVtZW50cyA9IF9zbGljZS5jYWxsKGVsZW1lbnRzKTtcblx0XHRcdFx0LyogV3JhcCBhIHNpbmdsZSBlbGVtZW50IGluIGFuIGFycmF5IHNvIHRoYXQgJC5lYWNoKCkgY2FuIGl0ZXJhdGUgd2l0aCB0aGUgZWxlbWVudCBpbnN0ZWFkIG9mIGl0cyBub2RlJ3MgY2hpbGRyZW4uICovXG5cdFx0XHR9IGVsc2UgaWYgKFR5cGUuaXNOb2RlKGVsZW1lbnRzKSkge1xuXHRcdFx0XHRlbGVtZW50cyA9IFtlbGVtZW50c107XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtZW50cztcblx0XHR9XG5cblx0XHR2YXIgVHlwZSA9IHtcblx0XHRcdGlzTnVtYmVyOiBmdW5jdGlvbih2YXJpYWJsZSkge1xuXHRcdFx0XHRyZXR1cm4gKHR5cGVvZiB2YXJpYWJsZSA9PT0gXCJudW1iZXJcIik7XG5cdFx0XHR9LFxuXHRcdFx0aXNTdHJpbmc6IGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG5cdFx0XHRcdHJldHVybiAodHlwZW9mIHZhcmlhYmxlID09PSBcInN0cmluZ1wiKTtcblx0XHRcdH0sXG5cdFx0XHRpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG5cdFx0XHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFyaWFibGUpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG5cdFx0XHR9LFxuXHRcdFx0aXNGdW5jdGlvbjogZnVuY3Rpb24odmFyaWFibGUpIHtcblx0XHRcdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YXJpYWJsZSkgPT09IFwiW29iamVjdCBGdW5jdGlvbl1cIjtcblx0XHRcdH0sXG5cdFx0XHRpc05vZGU6IGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG5cdFx0XHRcdHJldHVybiB2YXJpYWJsZSAmJiB2YXJpYWJsZS5ub2RlVHlwZTtcblx0XHRcdH0sXG5cdFx0XHQvKiBEZXRlcm1pbmUgaWYgdmFyaWFibGUgaXMgYW4gYXJyYXktbGlrZSB3cmFwcGVkIGpRdWVyeSwgWmVwdG8gb3Igc2ltaWxhciBlbGVtZW50LCBvciBldmVuIGEgTm9kZUxpc3QgZXRjLiAqL1xuXHRcdFx0LyogTk9URTogSFRNTEZvcm1FbGVtZW50cyBhbHNvIGhhdmUgYSBsZW5ndGguICovXG5cdFx0XHRpc1dyYXBwZWQ6IGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG5cdFx0XHRcdHJldHVybiB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0JiYgdmFyaWFibGUgIT09IHdpbmRvd1xuXHRcdFx0XHRcdFx0JiYgVHlwZS5pc051bWJlcih2YXJpYWJsZS5sZW5ndGgpXG5cdFx0XHRcdFx0XHQmJiAhVHlwZS5pc1N0cmluZyh2YXJpYWJsZSlcblx0XHRcdFx0XHRcdCYmICFUeXBlLmlzRnVuY3Rpb24odmFyaWFibGUpXG5cdFx0XHRcdFx0XHQmJiAhVHlwZS5pc05vZGUodmFyaWFibGUpXG5cdFx0XHRcdFx0XHQmJiAodmFyaWFibGUubGVuZ3RoID09PSAwIHx8IFR5cGUuaXNOb2RlKHZhcmlhYmxlWzBdKSk7XG5cdFx0XHR9LFxuXHRcdFx0aXNTVkc6IGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG5cdFx0XHRcdHJldHVybiB3aW5kb3cuU1ZHRWxlbWVudCAmJiAodmFyaWFibGUgaW5zdGFuY2VvZiB3aW5kb3cuU1ZHRWxlbWVudCk7XG5cdFx0XHR9LFxuXHRcdFx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24odmFyaWFibGUpIHtcblx0XHRcdFx0Zm9yICh2YXIgbmFtZSBpbiB2YXJpYWJsZSkge1xuXHRcdFx0XHRcdGlmICh2YXJpYWJsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKioqKioqKioqKioqKioqKipcblx0XHQgRGVwZW5kZW5jaWVzXG5cdFx0ICoqKioqKioqKioqKioqKioqL1xuXG5cdFx0dmFyICQsXG5cdFx0XHRcdGlzSlF1ZXJ5ID0gZmFsc2U7XG5cblx0XHRpZiAoZ2xvYmFsLmZuICYmIGdsb2JhbC5mbi5qcXVlcnkpIHtcblx0XHRcdCQgPSBnbG9iYWw7XG5cdFx0XHRpc0pRdWVyeSA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdCQgPSB3aW5kb3cuVmVsb2NpdHkuVXRpbGl0aWVzO1xuXHRcdH1cblxuXHRcdGlmIChJRSA8PSA4ICYmICFpc0pRdWVyeSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVmVsb2NpdHk6IElFOCBhbmQgYmVsb3cgcmVxdWlyZSBqUXVlcnkgdG8gYmUgbG9hZGVkIGJlZm9yZSBWZWxvY2l0eS5cIik7XG5cdFx0fSBlbHNlIGlmIChJRSA8PSA3KSB7XG5cdFx0XHQvKiBSZXZlcnQgdG8galF1ZXJ5J3MgJC5hbmltYXRlKCksIGFuZCBsb3NlIFZlbG9jaXR5J3MgZXh0cmEgZmVhdHVyZXMuICovXG5cdFx0XHRqUXVlcnkuZm4udmVsb2NpdHkgPSBqUXVlcnkuZm4uYW5pbWF0ZTtcblxuXHRcdFx0LyogTm93IHRoYXQgJC5mbi52ZWxvY2l0eSBpcyBhbGlhc2VkLCBhYm9ydCB0aGlzIFZlbG9jaXR5IGRlY2xhcmF0aW9uLiAqL1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8qKioqKioqKioqKioqKioqKlxuXHRcdCBDb25zdGFudHNcblx0XHQgKioqKioqKioqKioqKioqKiovXG5cblx0XHR2YXIgRFVSQVRJT05fREVGQVVMVCA9IDQwMCxcblx0XHRcdFx0RUFTSU5HX0RFRkFVTFQgPSBcInN3aW5nXCI7XG5cblx0XHQvKioqKioqKioqKioqKlxuXHRcdCBTdGF0ZVxuXHRcdCAqKioqKioqKioqKioqL1xuXG5cdFx0dmFyIFZlbG9jaXR5ID0ge1xuXHRcdFx0LyogQ29udGFpbmVyIGZvciBwYWdlLXdpZGUgVmVsb2NpdHkgc3RhdGUgZGF0YS4gKi9cblx0XHRcdFN0YXRlOiB7XG5cdFx0XHRcdC8qIERldGVjdCBtb2JpbGUgZGV2aWNlcyB0byBkZXRlcm1pbmUgaWYgbW9iaWxlSEEgc2hvdWxkIGJlIHR1cm5lZCBvbi4gKi9cblx0XHRcdFx0aXNNb2JpbGU6IC9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCksXG5cdFx0XHRcdC8qIFRoZSBtb2JpbGVIQSBvcHRpb24ncyBiZWhhdmlvciBjaGFuZ2VzIG9uIG9sZGVyIEFuZHJvaWQgZGV2aWNlcyAoR2luZ2VyYnJlYWQsIHZlcnNpb25zIDIuMy4zLTIuMy43KS4gKi9cblx0XHRcdFx0aXNBbmRyb2lkOiAvQW5kcm9pZC9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpLFxuXHRcdFx0XHRpc0dpbmdlcmJyZWFkOiAvQW5kcm9pZCAyXFwuM1xcLlszLTddL2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCksXG5cdFx0XHRcdGlzQ2hyb21lOiB3aW5kb3cuY2hyb21lLFxuXHRcdFx0XHRpc0ZpcmVmb3g6IC9GaXJlZm94L2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCksXG5cdFx0XHRcdC8qIENyZWF0ZSBhIGNhY2hlZCBlbGVtZW50IGZvciByZS11c2Ugd2hlbiBjaGVja2luZyBmb3IgQ1NTIHByb3BlcnR5IHByZWZpeGVzLiAqL1xuXHRcdFx0XHRwcmVmaXhFbGVtZW50OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuXHRcdFx0XHQvKiBDYWNoZSBldmVyeSBwcmVmaXggbWF0Y2ggdG8gYXZvaWQgcmVwZWF0aW5nIGxvb2t1cHMuICovXG5cdFx0XHRcdHByZWZpeE1hdGNoZXM6IHt9LFxuXHRcdFx0XHQvKiBDYWNoZSB0aGUgYW5jaG9yIHVzZWQgZm9yIGFuaW1hdGluZyB3aW5kb3cgc2Nyb2xsaW5nLiAqL1xuXHRcdFx0XHRzY3JvbGxBbmNob3I6IG51bGwsXG5cdFx0XHRcdC8qIENhY2hlIHRoZSBicm93c2VyLXNwZWNpZmljIHByb3BlcnR5IG5hbWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgc2Nyb2xsIGFuY2hvci4gKi9cblx0XHRcdFx0c2Nyb2xsUHJvcGVydHlMZWZ0OiBudWxsLFxuXHRcdFx0XHRzY3JvbGxQcm9wZXJ0eVRvcDogbnVsbCxcblx0XHRcdFx0LyogS2VlcCB0cmFjayBvZiB3aGV0aGVyIG91ciBSQUYgdGljayBpcyBydW5uaW5nLiAqL1xuXHRcdFx0XHRpc1RpY2tpbmc6IGZhbHNlLFxuXHRcdFx0XHQvKiBDb250YWluZXIgZm9yIGV2ZXJ5IGluLXByb2dyZXNzIGNhbGwgdG8gVmVsb2NpdHkuICovXG5cdFx0XHRcdGNhbGxzOiBbXSxcblx0XHRcdFx0ZGVsYXllZEVsZW1lbnRzOiB7XG5cdFx0XHRcdFx0Y291bnQ6IDBcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8qIFZlbG9jaXR5J3MgY3VzdG9tIENTUyBzdGFjay4gTWFkZSBnbG9iYWwgZm9yIHVuaXQgdGVzdGluZy4gKi9cblx0XHRcdENTUzogey8qIERlZmluZWQgYmVsb3cuICovfSxcblx0XHRcdC8qIEEgc2hpbSBvZiB0aGUgalF1ZXJ5IHV0aWxpdHkgZnVuY3Rpb25zIHVzZWQgYnkgVmVsb2NpdHkgLS0gcHJvdmlkZWQgYnkgVmVsb2NpdHkncyBvcHRpb25hbCBqUXVlcnkgc2hpbS4gKi9cblx0XHRcdFV0aWxpdGllczogJCxcblx0XHRcdC8qIENvbnRhaW5lciBmb3IgdGhlIHVzZXIncyBjdXN0b20gYW5pbWF0aW9uIHJlZGlyZWN0cyB0aGF0IGFyZSByZWZlcmVuY2VkIGJ5IG5hbWUgaW4gcGxhY2Ugb2YgdGhlIHByb3BlcnRpZXMgbWFwIGFyZ3VtZW50LiAqL1xuXHRcdFx0UmVkaXJlY3RzOiB7LyogTWFudWFsbHkgcmVnaXN0ZXJlZCBieSB0aGUgdXNlci4gKi99LFxuXHRcdFx0RWFzaW5nczogey8qIERlZmluZWQgYmVsb3cuICovfSxcblx0XHRcdC8qIEF0dGVtcHQgdG8gdXNlIEVTNiBQcm9taXNlcyBieSBkZWZhdWx0LiBVc2VycyBjYW4gb3ZlcnJpZGUgdGhpcyB3aXRoIGEgdGhpcmQtcGFydHkgcHJvbWlzZXMgbGlicmFyeS4gKi9cblx0XHRcdFByb21pc2U6IHdpbmRvdy5Qcm9taXNlLFxuXHRcdFx0LyogVmVsb2NpdHkgb3B0aW9uIGRlZmF1bHRzLCB3aGljaCBjYW4gYmUgb3ZlcnJpZGVuIGJ5IHRoZSB1c2VyLiAqL1xuXHRcdFx0ZGVmYXVsdHM6IHtcblx0XHRcdFx0cXVldWU6IFwiXCIsXG5cdFx0XHRcdGR1cmF0aW9uOiBEVVJBVElPTl9ERUZBVUxULFxuXHRcdFx0XHRlYXNpbmc6IEVBU0lOR19ERUZBVUxULFxuXHRcdFx0XHRiZWdpbjogdW5kZWZpbmVkLFxuXHRcdFx0XHRjb21wbGV0ZTogdW5kZWZpbmVkLFxuXHRcdFx0XHRwcm9ncmVzczogdW5kZWZpbmVkLFxuXHRcdFx0XHRkaXNwbGF5OiB1bmRlZmluZWQsXG5cdFx0XHRcdHZpc2liaWxpdHk6IHVuZGVmaW5lZCxcblx0XHRcdFx0bG9vcDogZmFsc2UsXG5cdFx0XHRcdGRlbGF5OiBmYWxzZSxcblx0XHRcdFx0bW9iaWxlSEE6IHRydWUsXG5cdFx0XHRcdC8qIEFkdmFuY2VkOiBTZXQgdG8gZmFsc2UgdG8gcHJldmVudCBwcm9wZXJ0eSB2YWx1ZXMgZnJvbSBiZWluZyBjYWNoZWQgYmV0d2VlbiBjb25zZWN1dGl2ZSBWZWxvY2l0eS1pbml0aWF0ZWQgY2hhaW4gY2FsbHMuICovXG5cdFx0XHRcdF9jYWNoZVZhbHVlczogdHJ1ZSxcblx0XHRcdFx0LyogQWR2YW5jZWQ6IFNldCB0byBmYWxzZSBpZiB0aGUgcHJvbWlzZSBzaG91bGQgYWx3YXlzIHJlc29sdmUgb24gZW1wdHkgZWxlbWVudCBsaXN0cy4gKi9cblx0XHRcdFx0cHJvbWlzZVJlamVjdEVtcHR5OiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0LyogQSBkZXNpZ24gZ29hbCBvZiBWZWxvY2l0eSBpcyB0byBjYWNoZSBkYXRhIHdoZXJldmVyIHBvc3NpYmxlIGluIG9yZGVyIHRvIGF2b2lkIERPTSByZXF1ZXJ5aW5nLiBBY2NvcmRpbmdseSwgZWFjaCBlbGVtZW50IGhhcyBhIGRhdGEgY2FjaGUuICovXG5cdFx0XHRpbml0OiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRcdCQuZGF0YShlbGVtZW50LCBcInZlbG9jaXR5XCIsIHtcblx0XHRcdFx0XHQvKiBTdG9yZSB3aGV0aGVyIHRoaXMgaXMgYW4gU1ZHIGVsZW1lbnQsIHNpbmNlIGl0cyBwcm9wZXJ0aWVzIGFyZSByZXRyaWV2ZWQgYW5kIHVwZGF0ZWQgZGlmZmVyZW50bHkgdGhhbiBzdGFuZGFyZCBIVE1MIGVsZW1lbnRzLiAqL1xuXHRcdFx0XHRcdGlzU1ZHOiBUeXBlLmlzU1ZHKGVsZW1lbnQpLFxuXHRcdFx0XHRcdC8qIEtlZXAgdHJhY2sgb2Ygd2hldGhlciB0aGUgZWxlbWVudCBpcyBjdXJyZW50bHkgYmVpbmcgYW5pbWF0ZWQgYnkgVmVsb2NpdHkuXG5cdFx0XHRcdFx0IFRoaXMgaXMgdXNlZCB0byBlbnN1cmUgdGhhdCBwcm9wZXJ0eSB2YWx1ZXMgYXJlIG5vdCB0cmFuc2ZlcnJlZCBiZXR3ZWVuIG5vbi1jb25zZWN1dGl2ZSAoc3RhbGUpIGNhbGxzLiAqL1xuXHRcdFx0XHRcdGlzQW5pbWF0aW5nOiBmYWxzZSxcblx0XHRcdFx0XHQvKiBBIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCdzIGxpdmUgY29tcHV0ZWRTdHlsZSBvYmplY3QuIExlYXJuIG1vcmUgaGVyZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL3dpbmRvdy5nZXRDb21wdXRlZFN0eWxlICovXG5cdFx0XHRcdFx0Y29tcHV0ZWRTdHlsZTogbnVsbCxcblx0XHRcdFx0XHQvKiBUd2VlbiBkYXRhIGlzIGNhY2hlZCBmb3IgZWFjaCBhbmltYXRpb24gb24gdGhlIGVsZW1lbnQgc28gdGhhdCBkYXRhIGNhbiBiZSBwYXNzZWQgYWNyb3NzIGNhbGxzIC0tXG5cdFx0XHRcdFx0IGluIHBhcnRpY3VsYXIsIGVuZCB2YWx1ZXMgYXJlIHVzZWQgYXMgc3Vic2VxdWVudCBzdGFydCB2YWx1ZXMgaW4gY29uc2VjdXRpdmUgVmVsb2NpdHkgY2FsbHMuICovXG5cdFx0XHRcdFx0dHdlZW5zQ29udGFpbmVyOiBudWxsLFxuXHRcdFx0XHRcdC8qIFRoZSBmdWxsIHJvb3QgcHJvcGVydHkgdmFsdWVzIG9mIGVhY2ggQ1NTIGhvb2sgYmVpbmcgYW5pbWF0ZWQgb24gdGhpcyBlbGVtZW50IGFyZSBjYWNoZWQgc28gdGhhdDpcblx0XHRcdFx0XHQgMSkgQ29uY3VycmVudGx5LWFuaW1hdGluZyBob29rcyBzaGFyaW5nIHRoZSBzYW1lIHJvb3QgY2FuIGhhdmUgdGhlaXIgcm9vdCB2YWx1ZXMnIG1lcmdlZCBpbnRvIG9uZSB3aGlsZSB0d2VlbmluZy5cblx0XHRcdFx0XHQgMikgUG9zdC1ob29rLWluamVjdGlvbiByb290IHZhbHVlcyBjYW4gYmUgdHJhbnNmZXJyZWQgb3ZlciB0byBjb25zZWN1dGl2ZWx5IGNoYWluZWQgVmVsb2NpdHkgY2FsbHMgYXMgc3RhcnRpbmcgcm9vdCB2YWx1ZXMuICovXG5cdFx0XHRcdFx0cm9vdFByb3BlcnR5VmFsdWVDYWNoZToge30sXG5cdFx0XHRcdFx0LyogQSBjYWNoZSBmb3IgdHJhbnNmb3JtIHVwZGF0ZXMsIHdoaWNoIG11c3QgYmUgbWFudWFsbHkgZmx1c2hlZCB2aWEgQ1NTLmZsdXNoVHJhbnNmb3JtQ2FjaGUoKS4gKi9cblx0XHRcdFx0XHR0cmFuc2Zvcm1DYWNoZToge31cblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdFx0LyogQSBwYXJhbGxlbCB0byBqUXVlcnkncyAkLmNzcygpLCB1c2VkIGZvciBnZXR0aW5nL3NldHRpbmcgVmVsb2NpdHkncyBob29rZWQgQ1NTIHByb3BlcnRpZXMuICovXG5cdFx0XHRob29rOiBudWxsLCAvKiBEZWZpbmVkIGJlbG93LiAqL1xuXHRcdFx0LyogVmVsb2NpdHktd2lkZSBhbmltYXRpb24gdGltZSByZW1hcHBpbmcgZm9yIHRlc3RpbmcgcHVycG9zZXMuICovXG5cdFx0XHRtb2NrOiBmYWxzZSxcblx0XHRcdHZlcnNpb246IHttYWpvcjogMSwgbWlub3I6IDUsIHBhdGNoOiAxfSxcblx0XHRcdC8qIFNldCB0byAxIG9yIDIgKG1vc3QgdmVyYm9zZSkgdG8gb3V0cHV0IGRlYnVnIGluZm8gdG8gY29uc29sZS4gKi9cblx0XHRcdGRlYnVnOiBmYWxzZSxcblx0XHRcdC8qIFVzZSByQUYgaGlnaCByZXNvbHV0aW9uIHRpbWVzdGFtcCB3aGVuIGF2YWlsYWJsZSAqL1xuXHRcdFx0dGltZXN0YW1wOiB0cnVlLFxuXHRcdFx0LyogUGF1c2UgYWxsIGFuaW1hdGlvbnMgKi9cblx0XHRcdHBhdXNlQWxsOiBmdW5jdGlvbihxdWV1ZU5hbWUpIHtcblx0XHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuXHRcdFx0XHQkLmVhY2goVmVsb2NpdHkuU3RhdGUuY2FsbHMsIGZ1bmN0aW9uKGksIGFjdGl2ZUNhbGwpIHtcblxuXHRcdFx0XHRcdGlmIChhY3RpdmVDYWxsKSB7XG5cblx0XHRcdFx0XHRcdC8qIElmIHdlIGhhdmUgYSBxdWV1ZU5hbWUgYW5kIHRoaXMgY2FsbCBpcyBub3Qgb24gdGhhdCBxdWV1ZSwgc2tpcCAqL1xuXHRcdFx0XHRcdFx0aWYgKHF1ZXVlTmFtZSAhPT0gdW5kZWZpbmVkICYmICgoYWN0aXZlQ2FsbFsyXS5xdWV1ZSAhPT0gcXVldWVOYW1lKSB8fCAoYWN0aXZlQ2FsbFsyXS5xdWV1ZSA9PT0gZmFsc2UpKSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyogU2V0IGNhbGwgdG8gcGF1c2VkICovXG5cdFx0XHRcdFx0XHRhY3RpdmVDYWxsWzVdID0ge1xuXHRcdFx0XHRcdFx0XHRyZXN1bWU6IGZhbHNlXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0LyogUGF1c2UgdGltZXJzIG9uIGFueSBjdXJyZW50bHkgZGVsYXllZCBjYWxscyAqL1xuXHRcdFx0XHQkLmVhY2goVmVsb2NpdHkuU3RhdGUuZGVsYXllZEVsZW1lbnRzLCBmdW5jdGlvbihrLCBlbGVtZW50KSB7XG5cdFx0XHRcdFx0aWYgKCFlbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhdXNlRGVsYXlPbkVsZW1lbnQoZWxlbWVudCwgY3VycmVudFRpbWUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHQvKiBSZXN1bWUgYWxsIGFuaW1hdGlvbnMgKi9cblx0XHRcdHJlc3VtZUFsbDogZnVuY3Rpb24ocXVldWVOYW1lKSB7XG5cdFx0XHRcdHZhciBjdXJyZW50VGltZSA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cblx0XHRcdFx0JC5lYWNoKFZlbG9jaXR5LlN0YXRlLmNhbGxzLCBmdW5jdGlvbihpLCBhY3RpdmVDYWxsKSB7XG5cblx0XHRcdFx0XHRpZiAoYWN0aXZlQ2FsbCkge1xuXG5cdFx0XHRcdFx0XHQvKiBJZiB3ZSBoYXZlIGEgcXVldWVOYW1lIGFuZCB0aGlzIGNhbGwgaXMgbm90IG9uIHRoYXQgcXVldWUsIHNraXAgKi9cblx0XHRcdFx0XHRcdGlmIChxdWV1ZU5hbWUgIT09IHVuZGVmaW5lZCAmJiAoKGFjdGl2ZUNhbGxbMl0ucXVldWUgIT09IHF1ZXVlTmFtZSkgfHwgKGFjdGl2ZUNhbGxbMl0ucXVldWUgPT09IGZhbHNlKSkpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIFNldCBjYWxsIHRvIHJlc3VtZWQgaWYgaXQgd2FzIHBhdXNlZCAqL1xuXHRcdFx0XHRcdFx0aWYgKGFjdGl2ZUNhbGxbNV0pIHtcblx0XHRcdFx0XHRcdFx0YWN0aXZlQ2FsbFs1XS5yZXN1bWUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdC8qIFJlc3VtZSB0aW1lcnMgb24gYW55IGN1cnJlbnRseSBkZWxheWVkIGNhbGxzICovXG5cdFx0XHRcdCQuZWFjaChWZWxvY2l0eS5TdGF0ZS5kZWxheWVkRWxlbWVudHMsIGZ1bmN0aW9uKGssIGVsZW1lbnQpIHtcblx0XHRcdFx0XHRpZiAoIWVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdW1lRGVsYXlPbkVsZW1lbnQoZWxlbWVudCwgY3VycmVudFRpbWUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyogUmV0cmlldmUgdGhlIGFwcHJvcHJpYXRlIHNjcm9sbCBhbmNob3IgYW5kIHByb3BlcnR5IG5hbWUgZm9yIHRoZSBicm93c2VyOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93LnNjcm9sbFkgKi9cblx0XHRpZiAod2luZG93LnBhZ2VZT2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFZlbG9jaXR5LlN0YXRlLnNjcm9sbEFuY2hvciA9IHdpbmRvdztcblx0XHRcdFZlbG9jaXR5LlN0YXRlLnNjcm9sbFByb3BlcnR5TGVmdCA9IFwicGFnZVhPZmZzZXRcIjtcblx0XHRcdFZlbG9jaXR5LlN0YXRlLnNjcm9sbFByb3BlcnR5VG9wID0gXCJwYWdlWU9mZnNldFwiO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRWZWxvY2l0eS5TdGF0ZS5zY3JvbGxBbmNob3IgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlIHx8IGRvY3VtZW50LmJvZHk7XG5cdFx0XHRWZWxvY2l0eS5TdGF0ZS5zY3JvbGxQcm9wZXJ0eUxlZnQgPSBcInNjcm9sbExlZnRcIjtcblx0XHRcdFZlbG9jaXR5LlN0YXRlLnNjcm9sbFByb3BlcnR5VG9wID0gXCJzY3JvbGxUb3BcIjtcblx0XHR9XG5cblx0XHQvKiBTaG9ydGhhbmQgYWxpYXMgZm9yIGpRdWVyeSdzICQuZGF0YSgpIHV0aWxpdHkuICovXG5cdFx0ZnVuY3Rpb24gRGF0YShlbGVtZW50KSB7XG5cdFx0XHQvKiBIYXJkY29kZSBhIHJlZmVyZW5jZSB0byB0aGUgcGx1Z2luIG5hbWUuICovXG5cdFx0XHR2YXIgcmVzcG9uc2UgPSAkLmRhdGEoZWxlbWVudCwgXCJ2ZWxvY2l0eVwiKTtcblxuXHRcdFx0LyogalF1ZXJ5IDw9MS40LjIgcmV0dXJucyBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkIHdoZW4gbm8gbWF0Y2ggaXMgZm91bmQuIFdlIG5vcm1hbGl6ZSB0aGlzIGJlaGF2aW9yLiAqL1xuXHRcdFx0cmV0dXJuIHJlc3BvbnNlID09PSBudWxsID8gdW5kZWZpbmVkIDogcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0LyoqKioqKioqKioqKioqXG5cdFx0IERlbGF5IFRpbWVyXG5cdFx0ICoqKioqKioqKioqKioqL1xuXG5cdFx0ZnVuY3Rpb24gcGF1c2VEZWxheU9uRWxlbWVudChlbGVtZW50LCBjdXJyZW50VGltZSkge1xuXHRcdFx0LyogQ2hlY2sgZm9yIGFueSBkZWxheSB0aW1lcnMsIGFuZCBwYXVzZSB0aGUgc2V0IHRpbWVvdXRzICh3aGlsZSBwcmVzZXJ2aW5nIHRpbWUgZGF0YSlcblx0XHRcdCB0byBiZSByZXN1bWVkIHdoZW4gdGhlIFwicmVzdW1lXCIgY29tbWFuZCBpcyBpc3N1ZWQgKi9cblx0XHRcdHZhciBkYXRhID0gRGF0YShlbGVtZW50KTtcblx0XHRcdGlmIChkYXRhICYmIGRhdGEuZGVsYXlUaW1lciAmJiAhZGF0YS5kZWxheVBhdXNlZCkge1xuXHRcdFx0XHRkYXRhLmRlbGF5UmVtYWluaW5nID0gZGF0YS5kZWxheSAtIGN1cnJlbnRUaW1lICsgZGF0YS5kZWxheUJlZ2luO1xuXHRcdFx0XHRkYXRhLmRlbGF5UGF1c2VkID0gdHJ1ZTtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KGRhdGEuZGVsYXlUaW1lci5zZXRUaW1lb3V0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXN1bWVEZWxheU9uRWxlbWVudChlbGVtZW50LCBjdXJyZW50VGltZSkge1xuXHRcdFx0LyogQ2hlY2sgZm9yIGFueSBwYXVzZWQgdGltZXJzIGFuZCByZXN1bWUgKi9cblx0XHRcdHZhciBkYXRhID0gRGF0YShlbGVtZW50KTtcblx0XHRcdGlmIChkYXRhICYmIGRhdGEuZGVsYXlUaW1lciAmJiBkYXRhLmRlbGF5UGF1c2VkKSB7XG5cdFx0XHRcdC8qIElmIHRoZSBlbGVtZW50IHdhcyBtaWQtZGVsYXksIHJlIGluaXRpYXRlIHRoZSB0aW1lb3V0IHdpdGggdGhlIHJlbWFpbmluZyBkZWxheSAqL1xuXHRcdFx0XHRkYXRhLmRlbGF5UGF1c2VkID0gZmFsc2U7XG5cdFx0XHRcdGRhdGEuZGVsYXlUaW1lci5zZXRUaW1lb3V0ID0gc2V0VGltZW91dChkYXRhLmRlbGF5VGltZXIubmV4dCwgZGF0YS5kZWxheVJlbWFpbmluZyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cblxuXHRcdC8qKioqKioqKioqKioqKlxuXHRcdCBFYXNpbmdcblx0XHQgKioqKioqKioqKioqKiovXG5cblx0XHQvKiBTdGVwIGVhc2luZyBnZW5lcmF0b3IuICovXG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVTdGVwKHN0ZXBzKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24ocCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5yb3VuZChwICogc3RlcHMpICogKDEgLyBzdGVwcyk7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8qIEJlemllciBjdXJ2ZSBmdW5jdGlvbiBnZW5lcmF0b3IuIENvcHlyaWdodCBHYWV0YW4gUmVuYXVkZWF1LiBNSVQgTGljZW5zZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NSVRfTGljZW5zZSAqL1xuXHRcdGZ1bmN0aW9uIGdlbmVyYXRlQmV6aWVyKG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuXHRcdFx0dmFyIE5FV1RPTl9JVEVSQVRJT05TID0gNCxcblx0XHRcdFx0XHRORVdUT05fTUlOX1NMT1BFID0gMC4wMDEsXG5cdFx0XHRcdFx0U1VCRElWSVNJT05fUFJFQ0lTSU9OID0gMC4wMDAwMDAxLFxuXHRcdFx0XHRcdFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TID0gMTAsXG5cdFx0XHRcdFx0a1NwbGluZVRhYmxlU2l6ZSA9IDExLFxuXHRcdFx0XHRcdGtTYW1wbGVTdGVwU2l6ZSA9IDEuMCAvIChrU3BsaW5lVGFibGVTaXplIC0gMS4wKSxcblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPSBcIkZsb2F0MzJBcnJheVwiIGluIHdpbmRvdztcblxuXHRcdFx0LyogTXVzdCBjb250YWluIGZvdXIgYXJndW1lbnRzLiAqL1xuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDQpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBBcmd1bWVudHMgbXVzdCBiZSBudW1iZXJzLiAqL1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBhcmd1bWVudHNbaV0gIT09IFwibnVtYmVyXCIgfHwgaXNOYU4oYXJndW1lbnRzW2ldKSB8fCAhaXNGaW5pdGUoYXJndW1lbnRzW2ldKSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvKiBYIHZhbHVlcyBtdXN0IGJlIGluIHRoZSBbMCwgMV0gcmFuZ2UuICovXG5cdFx0XHRtWDEgPSBNYXRoLm1pbihtWDEsIDEpO1xuXHRcdFx0bVgyID0gTWF0aC5taW4obVgyLCAxKTtcblx0XHRcdG1YMSA9IE1hdGgubWF4KG1YMSwgMCk7XG5cdFx0XHRtWDIgPSBNYXRoLm1heChtWDIsIDApO1xuXG5cdFx0XHR2YXIgbVNhbXBsZVZhbHVlcyA9IGZsb2F0MzJBcnJheVN1cHBvcnRlZCA/IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSkgOiBuZXcgQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG5cblx0XHRcdGZ1bmN0aW9uIEEoYUExLCBhQTIpIHtcblx0XHRcdFx0cmV0dXJuIDEuMCAtIDMuMCAqIGFBMiArIDMuMCAqIGFBMTtcblx0XHRcdH1cblx0XHRcdGZ1bmN0aW9uIEIoYUExLCBhQTIpIHtcblx0XHRcdFx0cmV0dXJuIDMuMCAqIGFBMiAtIDYuMCAqIGFBMTtcblx0XHRcdH1cblx0XHRcdGZ1bmN0aW9uIEMoYUExKSB7XG5cdFx0XHRcdHJldHVybiAzLjAgKiBhQTE7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNhbGNCZXppZXIoYVQsIGFBMSwgYUEyKSB7XG5cdFx0XHRcdHJldHVybiAoKEEoYUExLCBhQTIpICogYVQgKyBCKGFBMSwgYUEyKSkgKiBhVCArIEMoYUExKSkgKiBhVDtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZ2V0U2xvcGUoYVQsIGFBMSwgYUEyKSB7XG5cdFx0XHRcdHJldHVybiAzLjAgKiBBKGFBMSwgYUEyKSAqIGFUICogYVQgKyAyLjAgKiBCKGFBMSwgYUEyKSAqIGFUICsgQyhhQTEpO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgYUd1ZXNzVCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IE5FV1RPTl9JVEVSQVRJT05TOyArK2kpIHtcblx0XHRcdFx0XHR2YXIgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuXG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRTbG9wZSA9PT0gMC4wKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gYUd1ZXNzVDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xuXHRcdFx0XHRcdGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gYUd1ZXNzVDtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY2FsY1NhbXBsZVZhbHVlcygpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrU3BsaW5lVGFibGVTaXplOyArK2kpIHtcblx0XHRcdFx0XHRtU2FtcGxlVmFsdWVzW2ldID0gY2FsY0JlemllcihpICoga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlKGFYLCBhQSwgYUIpIHtcblx0XHRcdFx0dmFyIGN1cnJlbnRYLCBjdXJyZW50VCwgaSA9IDA7XG5cblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyLjA7XG5cdFx0XHRcdFx0Y3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcblx0XHRcdFx0XHRpZiAoY3VycmVudFggPiAwLjApIHtcblx0XHRcdFx0XHRcdGFCID0gY3VycmVudFQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGFBID0gY3VycmVudFQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBTVUJESVZJU0lPTl9QUkVDSVNJT04gJiYgKytpIDwgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMpO1xuXG5cdFx0XHRcdHJldHVybiBjdXJyZW50VDtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZ2V0VEZvclgoYVgpIHtcblx0XHRcdFx0dmFyIGludGVydmFsU3RhcnQgPSAwLjAsXG5cdFx0XHRcdFx0XHRjdXJyZW50U2FtcGxlID0gMSxcblx0XHRcdFx0XHRcdGxhc3RTYW1wbGUgPSBrU3BsaW5lVGFibGVTaXplIC0gMTtcblxuXHRcdFx0XHRmb3IgKDsgY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcblx0XHRcdFx0XHRpbnRlcnZhbFN0YXJ0ICs9IGtTYW1wbGVTdGVwU2l6ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC0tY3VycmVudFNhbXBsZTtcblxuXHRcdFx0XHR2YXIgZGlzdCA9IChhWCAtIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pIC8gKG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSksXG5cdFx0XHRcdFx0XHRndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIGtTYW1wbGVTdGVwU2l6ZSxcblx0XHRcdFx0XHRcdGluaXRpYWxTbG9wZSA9IGdldFNsb3BlKGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuXG5cdFx0XHRcdGlmIChpbml0aWFsU2xvcGUgPj0gTkVXVE9OX01JTl9TTE9QRSkge1xuXHRcdFx0XHRcdHJldHVybiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgZ3Vlc3NGb3JUKTtcblx0XHRcdFx0fSBlbHNlIGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkge1xuXHRcdFx0XHRcdHJldHVybiBndWVzc0ZvclQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIF9wcmVjb21wdXRlZCA9IGZhbHNlO1xuXG5cdFx0XHRmdW5jdGlvbiBwcmVjb21wdXRlKCkge1xuXHRcdFx0XHRfcHJlY29tcHV0ZWQgPSB0cnVlO1xuXHRcdFx0XHRpZiAobVgxICE9PSBtWTEgfHwgbVgyICE9PSBtWTIpIHtcblx0XHRcdFx0XHRjYWxjU2FtcGxlVmFsdWVzKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIGYgPSBmdW5jdGlvbihhWCkge1xuXHRcdFx0XHRpZiAoIV9wcmVjb21wdXRlZCkge1xuXHRcdFx0XHRcdHByZWNvbXB1dGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHtcblx0XHRcdFx0XHRyZXR1cm4gYVg7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGFYID09PSAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGFYID09PSAxKSB7XG5cdFx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gY2FsY0JlemllcihnZXRURm9yWChhWCksIG1ZMSwgbVkyKTtcblx0XHRcdH07XG5cblx0XHRcdGYuZ2V0Q29udHJvbFBvaW50cyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gW3t4OiBtWDEsIHk6IG1ZMX0sIHt4OiBtWDIsIHk6IG1ZMn1dO1xuXHRcdFx0fTtcblxuXHRcdFx0dmFyIHN0ciA9IFwiZ2VuZXJhdGVCZXppZXIoXCIgKyBbbVgxLCBtWTEsIG1YMiwgbVkyXSArIFwiKVwiO1xuXHRcdFx0Zi50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gc3RyO1xuXHRcdFx0fTtcblxuXHRcdFx0cmV0dXJuIGY7XG5cdFx0fVxuXG5cdFx0LyogUnVuZ2UtS3V0dGEgc3ByaW5nIHBoeXNpY3MgZnVuY3Rpb24gZ2VuZXJhdG9yLiBBZGFwdGVkIGZyb20gRnJhbWVyLmpzLCBjb3B5cmlnaHQgS29lbiBCb2suIE1JVCBMaWNlbnNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01JVF9MaWNlbnNlICovXG5cdFx0LyogR2l2ZW4gYSB0ZW5zaW9uLCBmcmljdGlvbiwgYW5kIGR1cmF0aW9uLCBhIHNpbXVsYXRpb24gYXQgNjBGUFMgd2lsbCBmaXJzdCBydW4gd2l0aG91dCBhIGRlZmluZWQgZHVyYXRpb24gaW4gb3JkZXIgdG8gY2FsY3VsYXRlIHRoZSBmdWxsIHBhdGguIEEgc2Vjb25kIHBhc3Ncblx0XHQgdGhlbiBhZGp1c3RzIHRoZSB0aW1lIGRlbHRhIC0tIHVzaW5nIHRoZSByZWxhdGlvbiBiZXR3ZWVuIGFjdHVhbCB0aW1lIGFuZCBkdXJhdGlvbiAtLSB0byBjYWxjdWxhdGUgdGhlIHBhdGggZm9yIHRoZSBkdXJhdGlvbi1jb25zdHJhaW5lZCBhbmltYXRpb24uICovXG5cdFx0dmFyIGdlbmVyYXRlU3ByaW5nUks0ID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0ZnVuY3Rpb24gc3ByaW5nQWNjZWxlcmF0aW9uRm9yU3RhdGUoc3RhdGUpIHtcblx0XHRcdFx0cmV0dXJuICgtc3RhdGUudGVuc2lvbiAqIHN0YXRlLngpIC0gKHN0YXRlLmZyaWN0aW9uICogc3RhdGUudik7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShpbml0aWFsU3RhdGUsIGR0LCBkZXJpdmF0aXZlKSB7XG5cdFx0XHRcdHZhciBzdGF0ZSA9IHtcblx0XHRcdFx0XHR4OiBpbml0aWFsU3RhdGUueCArIGRlcml2YXRpdmUuZHggKiBkdCxcblx0XHRcdFx0XHR2OiBpbml0aWFsU3RhdGUudiArIGRlcml2YXRpdmUuZHYgKiBkdCxcblx0XHRcdFx0XHR0ZW5zaW9uOiBpbml0aWFsU3RhdGUudGVuc2lvbixcblx0XHRcdFx0XHRmcmljdGlvbjogaW5pdGlhbFN0YXRlLmZyaWN0aW9uXG5cdFx0XHRcdH07XG5cblx0XHRcdFx0cmV0dXJuIHtkeDogc3RhdGUudiwgZHY6IHNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlKHN0YXRlKX07XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHNwcmluZ0ludGVncmF0ZVN0YXRlKHN0YXRlLCBkdCkge1xuXHRcdFx0XHR2YXIgYSA9IHtcblx0XHRcdFx0XHRkeDogc3RhdGUudixcblx0XHRcdFx0XHRkdjogc3ByaW5nQWNjZWxlcmF0aW9uRm9yU3RhdGUoc3RhdGUpXG5cdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRiID0gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKHN0YXRlLCBkdCAqIDAuNSwgYSksXG5cdFx0XHRcdFx0XHRjID0gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKHN0YXRlLCBkdCAqIDAuNSwgYiksXG5cdFx0XHRcdFx0XHRkID0gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKHN0YXRlLCBkdCwgYyksXG5cdFx0XHRcdFx0XHRkeGR0ID0gMS4wIC8gNi4wICogKGEuZHggKyAyLjAgKiAoYi5keCArIGMuZHgpICsgZC5keCksXG5cdFx0XHRcdFx0XHRkdmR0ID0gMS4wIC8gNi4wICogKGEuZHYgKyAyLjAgKiAoYi5kdiArIGMuZHYpICsgZC5kdik7XG5cblx0XHRcdFx0c3RhdGUueCA9IHN0YXRlLnggKyBkeGR0ICogZHQ7XG5cdFx0XHRcdHN0YXRlLnYgPSBzdGF0ZS52ICsgZHZkdCAqIGR0O1xuXG5cdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHNwcmluZ1JLNEZhY3RvcnkodGVuc2lvbiwgZnJpY3Rpb24sIGR1cmF0aW9uKSB7XG5cblx0XHRcdFx0dmFyIGluaXRTdGF0ZSA9IHtcblx0XHRcdFx0XHR4OiAtMSxcblx0XHRcdFx0XHR2OiAwLFxuXHRcdFx0XHRcdHRlbnNpb246IG51bGwsXG5cdFx0XHRcdFx0ZnJpY3Rpb246IG51bGxcblx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdHBhdGggPSBbMF0sXG5cdFx0XHRcdFx0XHR0aW1lX2xhcHNlZCA9IDAsXG5cdFx0XHRcdFx0XHR0b2xlcmFuY2UgPSAxIC8gMTAwMDAsXG5cdFx0XHRcdFx0XHREVCA9IDE2IC8gMTAwMCxcblx0XHRcdFx0XHRcdGhhdmVfZHVyYXRpb24sIGR0LCBsYXN0X3N0YXRlO1xuXG5cdFx0XHRcdHRlbnNpb24gPSBwYXJzZUZsb2F0KHRlbnNpb24pIHx8IDUwMDtcblx0XHRcdFx0ZnJpY3Rpb24gPSBwYXJzZUZsb2F0KGZyaWN0aW9uKSB8fCAyMDtcblx0XHRcdFx0ZHVyYXRpb24gPSBkdXJhdGlvbiB8fCBudWxsO1xuXG5cdFx0XHRcdGluaXRTdGF0ZS50ZW5zaW9uID0gdGVuc2lvbjtcblx0XHRcdFx0aW5pdFN0YXRlLmZyaWN0aW9uID0gZnJpY3Rpb247XG5cblx0XHRcdFx0aGF2ZV9kdXJhdGlvbiA9IGR1cmF0aW9uICE9PSBudWxsO1xuXG5cdFx0XHRcdC8qIENhbGN1bGF0ZSB0aGUgYWN0dWFsIHRpbWUgaXQgdGFrZXMgZm9yIHRoaXMgYW5pbWF0aW9uIHRvIGNvbXBsZXRlIHdpdGggdGhlIHByb3ZpZGVkIGNvbmRpdGlvbnMuICovXG5cdFx0XHRcdGlmIChoYXZlX2R1cmF0aW9uKSB7XG5cdFx0XHRcdFx0LyogUnVuIHRoZSBzaW11bGF0aW9uIHdpdGhvdXQgYSBkdXJhdGlvbi4gKi9cblx0XHRcdFx0XHR0aW1lX2xhcHNlZCA9IHNwcmluZ1JLNEZhY3RvcnkodGVuc2lvbiwgZnJpY3Rpb24pO1xuXHRcdFx0XHRcdC8qIENvbXB1dGUgdGhlIGFkanVzdGVkIHRpbWUgZGVsdGEuICovXG5cdFx0XHRcdFx0ZHQgPSB0aW1lX2xhcHNlZCAvIGR1cmF0aW9uICogRFQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZHQgPSBEVDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdFx0LyogTmV4dC9zdGVwIGZ1bmN0aW9uIC4qL1xuXHRcdFx0XHRcdGxhc3Rfc3RhdGUgPSBzcHJpbmdJbnRlZ3JhdGVTdGF0ZShsYXN0X3N0YXRlIHx8IGluaXRTdGF0ZSwgZHQpO1xuXHRcdFx0XHRcdC8qIFN0b3JlIHRoZSBwb3NpdGlvbi4gKi9cblx0XHRcdFx0XHRwYXRoLnB1c2goMSArIGxhc3Rfc3RhdGUueCk7XG5cdFx0XHRcdFx0dGltZV9sYXBzZWQgKz0gMTY7XG5cdFx0XHRcdFx0LyogSWYgdGhlIGNoYW5nZSB0aHJlc2hvbGQgaXMgcmVhY2hlZCwgYnJlYWsuICovXG5cdFx0XHRcdFx0aWYgKCEoTWF0aC5hYnMobGFzdF9zdGF0ZS54KSA+IHRvbGVyYW5jZSAmJiBNYXRoLmFicyhsYXN0X3N0YXRlLnYpID4gdG9sZXJhbmNlKSkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyogSWYgZHVyYXRpb24gaXMgbm90IGRlZmluZWQsIHJldHVybiB0aGUgYWN0dWFsIHRpbWUgcmVxdWlyZWQgZm9yIGNvbXBsZXRpbmcgdGhpcyBhbmltYXRpb24uIE90aGVyd2lzZSwgcmV0dXJuIGEgY2xvc3VyZSB0aGF0IGhvbGRzIHRoZVxuXHRcdFx0XHQgY29tcHV0ZWQgcGF0aCBhbmQgcmV0dXJucyBhIHNuYXBzaG90IG9mIHRoZSBwb3NpdGlvbiBhY2NvcmRpbmcgdG8gYSBnaXZlbiBwZXJjZW50Q29tcGxldGUuICovXG5cdFx0XHRcdHJldHVybiAhaGF2ZV9kdXJhdGlvbiA/IHRpbWVfbGFwc2VkIDogZnVuY3Rpb24ocGVyY2VudENvbXBsZXRlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdGhbIChwZXJjZW50Q29tcGxldGUgKiAocGF0aC5sZW5ndGggLSAxKSkgfCAwIF07XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdH0oKSk7XG5cblx0XHQvKiBqUXVlcnkgZWFzaW5ncy4gKi9cblx0XHRWZWxvY2l0eS5FYXNpbmdzID0ge1xuXHRcdFx0bGluZWFyOiBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiBwO1xuXHRcdFx0fSxcblx0XHRcdHN3aW5nOiBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyhwICogTWF0aC5QSSkgLyAyO1xuXHRcdFx0fSxcblx0XHRcdC8qIEJvbnVzIFwic3ByaW5nXCIgZWFzaW5nLCB3aGljaCBpcyBhIGxlc3MgZXhhZ2dlcmF0ZWQgdmVyc2lvbiBvZiBlYXNlSW5PdXRFbGFzdGljLiAqL1xuXHRcdFx0c3ByaW5nOiBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiAxIC0gKE1hdGguY29zKHAgKiA0LjUgKiBNYXRoLlBJKSAqIE1hdGguZXhwKC1wICogNikpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKiBDU1MzIGFuZCBSb2JlcnQgUGVubmVyIGVhc2luZ3MuICovXG5cdFx0JC5lYWNoKFxuXHRcdFx0XHRbXG5cdFx0XHRcdFx0W1wiZWFzZVwiLCBbMC4yNSwgMC4xLCAwLjI1LCAxLjBdXSxcblx0XHRcdFx0XHRbXCJlYXNlLWluXCIsIFswLjQyLCAwLjAsIDEuMDAsIDEuMF1dLFxuXHRcdFx0XHRcdFtcImVhc2Utb3V0XCIsIFswLjAwLCAwLjAsIDAuNTgsIDEuMF1dLFxuXHRcdFx0XHRcdFtcImVhc2UtaW4tb3V0XCIsIFswLjQyLCAwLjAsIDAuNTgsIDEuMF1dLFxuXHRcdFx0XHRcdFtcImVhc2VJblNpbmVcIiwgWzAuNDcsIDAsIDAuNzQ1LCAwLjcxNV1dLFxuXHRcdFx0XHRcdFtcImVhc2VPdXRTaW5lXCIsIFswLjM5LCAwLjU3NSwgMC41NjUsIDFdXSxcblx0XHRcdFx0XHRbXCJlYXNlSW5PdXRTaW5lXCIsIFswLjQ0NSwgMC4wNSwgMC41NSwgMC45NV1dLFxuXHRcdFx0XHRcdFtcImVhc2VJblF1YWRcIiwgWzAuNTUsIDAuMDg1LCAwLjY4LCAwLjUzXV0sXG5cdFx0XHRcdFx0W1wiZWFzZU91dFF1YWRcIiwgWzAuMjUsIDAuNDYsIDAuNDUsIDAuOTRdXSxcblx0XHRcdFx0XHRbXCJlYXNlSW5PdXRRdWFkXCIsIFswLjQ1NSwgMC4wMywgMC41MTUsIDAuOTU1XV0sXG5cdFx0XHRcdFx0W1wiZWFzZUluQ3ViaWNcIiwgWzAuNTUsIDAuMDU1LCAwLjY3NSwgMC4xOV1dLFxuXHRcdFx0XHRcdFtcImVhc2VPdXRDdWJpY1wiLCBbMC4yMTUsIDAuNjEsIDAuMzU1LCAxXV0sXG5cdFx0XHRcdFx0W1wiZWFzZUluT3V0Q3ViaWNcIiwgWzAuNjQ1LCAwLjA0NSwgMC4zNTUsIDFdXSxcblx0XHRcdFx0XHRbXCJlYXNlSW5RdWFydFwiLCBbMC44OTUsIDAuMDMsIDAuNjg1LCAwLjIyXV0sXG5cdFx0XHRcdFx0W1wiZWFzZU91dFF1YXJ0XCIsIFswLjE2NSwgMC44NCwgMC40NCwgMV1dLFxuXHRcdFx0XHRcdFtcImVhc2VJbk91dFF1YXJ0XCIsIFswLjc3LCAwLCAwLjE3NSwgMV1dLFxuXHRcdFx0XHRcdFtcImVhc2VJblF1aW50XCIsIFswLjc1NSwgMC4wNSwgMC44NTUsIDAuMDZdXSxcblx0XHRcdFx0XHRbXCJlYXNlT3V0UXVpbnRcIiwgWzAuMjMsIDEsIDAuMzIsIDFdXSxcblx0XHRcdFx0XHRbXCJlYXNlSW5PdXRRdWludFwiLCBbMC44NiwgMCwgMC4wNywgMV1dLFxuXHRcdFx0XHRcdFtcImVhc2VJbkV4cG9cIiwgWzAuOTUsIDAuMDUsIDAuNzk1LCAwLjAzNV1dLFxuXHRcdFx0XHRcdFtcImVhc2VPdXRFeHBvXCIsIFswLjE5LCAxLCAwLjIyLCAxXV0sXG5cdFx0XHRcdFx0W1wiZWFzZUluT3V0RXhwb1wiLCBbMSwgMCwgMCwgMV1dLFxuXHRcdFx0XHRcdFtcImVhc2VJbkNpcmNcIiwgWzAuNiwgMC4wNCwgMC45OCwgMC4zMzVdXSxcblx0XHRcdFx0XHRbXCJlYXNlT3V0Q2lyY1wiLCBbMC4wNzUsIDAuODIsIDAuMTY1LCAxXV0sXG5cdFx0XHRcdFx0W1wiZWFzZUluT3V0Q2lyY1wiLCBbMC43ODUsIDAuMTM1LCAwLjE1LCAwLjg2XV1cblx0XHRcdFx0XSwgZnVuY3Rpb24oaSwgZWFzaW5nQXJyYXkpIHtcblx0XHRcdFZlbG9jaXR5LkVhc2luZ3NbZWFzaW5nQXJyYXlbMF1dID0gZ2VuZXJhdGVCZXppZXIuYXBwbHkobnVsbCwgZWFzaW5nQXJyYXlbMV0pO1xuXHRcdH0pO1xuXG5cdFx0LyogRGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSBlYXNpbmcgdHlwZSBnaXZlbiBhbiBlYXNpbmcgaW5wdXQuICovXG5cdFx0ZnVuY3Rpb24gZ2V0RWFzaW5nKHZhbHVlLCBkdXJhdGlvbikge1xuXHRcdFx0dmFyIGVhc2luZyA9IHZhbHVlO1xuXG5cdFx0XHQvKiBUaGUgZWFzaW5nIG9wdGlvbiBjYW4gZWl0aGVyIGJlIGEgc3RyaW5nIHRoYXQgcmVmZXJlbmNlcyBhIHByZS1yZWdpc3RlcmVkIGVhc2luZyxcblx0XHRcdCBvciBpdCBjYW4gYmUgYSB0d28tL2ZvdXItaXRlbSBhcnJheSBvZiBpbnRlZ2VycyB0byBiZSBjb252ZXJ0ZWQgaW50byBhIGJlemllci9zcHJpbmcgZnVuY3Rpb24uICovXG5cdFx0XHRpZiAoVHlwZS5pc1N0cmluZyh2YWx1ZSkpIHtcblx0XHRcdFx0LyogRW5zdXJlIHRoYXQgdGhlIGVhc2luZyBoYXMgYmVlbiBhc3NpZ25lZCB0byBqUXVlcnkncyBWZWxvY2l0eS5FYXNpbmdzIG9iamVjdC4gKi9cblx0XHRcdFx0aWYgKCFWZWxvY2l0eS5FYXNpbmdzW3ZhbHVlXSkge1xuXHRcdFx0XHRcdGVhc2luZyA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKFR5cGUuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdGVhc2luZyA9IGdlbmVyYXRlU3RlcC5hcHBseShudWxsLCB2YWx1ZSk7XG5cdFx0XHR9IGVsc2UgaWYgKFR5cGUuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAyKSB7XG5cdFx0XHRcdC8qIHNwcmluZ1JLNCBtdXN0IGJlIHBhc3NlZCB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24uICovXG5cdFx0XHRcdC8qIE5vdGU6IElmIHRoZSBzcHJpbmdSSzQgYXJyYXkgY29udGFpbnMgbm9uLW51bWJlcnMsIGdlbmVyYXRlU3ByaW5nUks0KCkgcmV0dXJucyBhbiBlYXNpbmdcblx0XHRcdFx0IGZ1bmN0aW9uIGdlbmVyYXRlZCB3aXRoIGRlZmF1bHQgdGVuc2lvbiBhbmQgZnJpY3Rpb24gdmFsdWVzLiAqL1xuXHRcdFx0XHRlYXNpbmcgPSBnZW5lcmF0ZVNwcmluZ1JLNC5hcHBseShudWxsLCB2YWx1ZS5jb25jYXQoW2R1cmF0aW9uXSkpO1xuXHRcdFx0fSBlbHNlIGlmIChUeXBlLmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gNCkge1xuXHRcdFx0XHQvKiBOb3RlOiBJZiB0aGUgYmV6aWVyIGFycmF5IGNvbnRhaW5zIG5vbi1udW1iZXJzLCBnZW5lcmF0ZUJlemllcigpIHJldHVybnMgZmFsc2UuICovXG5cdFx0XHRcdGVhc2luZyA9IGdlbmVyYXRlQmV6aWVyLmFwcGx5KG51bGwsIHZhbHVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVhc2luZyA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBSZXZlcnQgdG8gdGhlIFZlbG9jaXR5LXdpZGUgZGVmYXVsdCBlYXNpbmcgdHlwZSwgb3IgZmFsbCBiYWNrIHRvIFwic3dpbmdcIiAod2hpY2ggaXMgYWxzbyBqUXVlcnkncyBkZWZhdWx0KVxuXHRcdFx0IGlmIHRoZSBWZWxvY2l0eS13aWRlIGRlZmF1bHQgaGFzIGJlZW4gaW5jb3JyZWN0bHkgbW9kaWZpZWQuICovXG5cdFx0XHRpZiAoZWFzaW5nID09PSBmYWxzZSkge1xuXHRcdFx0XHRpZiAoVmVsb2NpdHkuRWFzaW5nc1tWZWxvY2l0eS5kZWZhdWx0cy5lYXNpbmddKSB7XG5cdFx0XHRcdFx0ZWFzaW5nID0gVmVsb2NpdHkuZGVmYXVsdHMuZWFzaW5nO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVhc2luZyA9IEVBU0lOR19ERUZBVUxUO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlYXNpbmc7XG5cdFx0fVxuXG5cdFx0LyoqKioqKioqKioqKioqKioqXG5cdFx0IENTUyBTdGFja1xuXHRcdCAqKioqKioqKioqKioqKioqKi9cblxuXHRcdC8qIFRoZSBDU1Mgb2JqZWN0IGlzIGEgaGlnaGx5IGNvbmRlbnNlZCBhbmQgcGVyZm9ybWFudCBDU1Mgc3RhY2sgdGhhdCBmdWxseSByZXBsYWNlcyBqUXVlcnkncy5cblx0XHQgSXQgaGFuZGxlcyB0aGUgdmFsaWRhdGlvbiwgZ2V0dGluZywgYW5kIHNldHRpbmcgb2YgYm90aCBzdGFuZGFyZCBDU1MgcHJvcGVydGllcyBhbmQgQ1NTIHByb3BlcnR5IGhvb2tzLiAqL1xuXHRcdC8qIE5vdGU6IEEgXCJDU1NcIiBzaG9ydGhhbmQgaXMgYWxpYXNlZCBzbyB0aGF0IG91ciBjb2RlIGlzIGVhc2llciB0byByZWFkLiAqL1xuXHRcdHZhciBDU1MgPSBWZWxvY2l0eS5DU1MgPSB7XG5cdFx0XHQvKioqKioqKioqKioqKlxuXHRcdFx0IFJlZ0V4XG5cdFx0XHQgKioqKioqKioqKioqKi9cblxuXHRcdFx0UmVnRXg6IHtcblx0XHRcdFx0aXNIZXg6IC9eIyhbQS1mXFxkXXszfSl7MSwyfSQvaSxcblx0XHRcdFx0LyogVW53cmFwIGEgcHJvcGVydHkgdmFsdWUncyBzdXJyb3VuZGluZyB0ZXh0LCBlLmcuIFwicmdiYSg0LCAzLCAyLCAxKVwiID09PiBcIjQsIDMsIDIsIDFcIiBhbmQgXCJyZWN0KDRweCAzcHggMnB4IDFweClcIiA9PT4gXCI0cHggM3B4IDJweCAxcHhcIi4gKi9cblx0XHRcdFx0dmFsdWVVbndyYXA6IC9eW0Etel0rXFwoKC4qKVxcKSQvaSxcblx0XHRcdFx0d3JhcHBlZFZhbHVlQWxyZWFkeUV4dHJhY3RlZDogL1swLTkuXSsgWzAtOS5dKyBbMC05Ll0rKCBbMC05Ll0rKT8vLFxuXHRcdFx0XHQvKiBTcGxpdCBhIG11bHRpLXZhbHVlIHByb3BlcnR5IGludG8gYW4gYXJyYXkgb2Ygc3VidmFsdWVzLCBlLmcuIFwicmdiYSg0LCAzLCAyLCAxKSA0cHggM3B4IDJweCAxcHhcIiA9PT4gWyBcInJnYmEoNCwgMywgMiwgMSlcIiwgXCI0cHhcIiwgXCIzcHhcIiwgXCIycHhcIiwgXCIxcHhcIiBdLiAqL1xuXHRcdFx0XHR2YWx1ZVNwbGl0OiAvKFtBLXpdK1xcKC4rXFwpKXwoKFtBLXowLTkjLS5dKz8pKD89XFxzfCQpKS9pZ1xuXHRcdFx0fSxcblx0XHRcdC8qKioqKioqKioqKipcblx0XHRcdCBMaXN0c1xuXHRcdFx0ICoqKioqKioqKioqKi9cblxuXHRcdFx0TGlzdHM6IHtcblx0XHRcdFx0Y29sb3JzOiBbXCJmaWxsXCIsIFwic3Ryb2tlXCIsIFwic3RvcENvbG9yXCIsIFwiY29sb3JcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgXCJib3JkZXJDb2xvclwiLCBcImJvcmRlclRvcENvbG9yXCIsIFwiYm9yZGVyUmlnaHRDb2xvclwiLCBcImJvcmRlckJvdHRvbUNvbG9yXCIsIFwiYm9yZGVyTGVmdENvbG9yXCIsIFwib3V0bGluZUNvbG9yXCJdLFxuXHRcdFx0XHR0cmFuc2Zvcm1zQmFzZTogW1widHJhbnNsYXRlWFwiLCBcInRyYW5zbGF0ZVlcIiwgXCJzY2FsZVwiLCBcInNjYWxlWFwiLCBcInNjYWxlWVwiLCBcInNrZXdYXCIsIFwic2tld1lcIiwgXCJyb3RhdGVaXCJdLFxuXHRcdFx0XHR0cmFuc2Zvcm1zM0Q6IFtcInRyYW5zZm9ybVBlcnNwZWN0aXZlXCIsIFwidHJhbnNsYXRlWlwiLCBcInNjYWxlWlwiLCBcInJvdGF0ZVhcIiwgXCJyb3RhdGVZXCJdLFxuXHRcdFx0XHR1bml0czogW1xuXHRcdFx0XHRcdFwiJVwiLCAvLyByZWxhdGl2ZVxuXHRcdFx0XHRcdFwiZW1cIiwgXCJleFwiLCBcImNoXCIsIFwicmVtXCIsIC8vIGZvbnQgcmVsYXRpdmVcblx0XHRcdFx0XHRcInZ3XCIsIFwidmhcIiwgXCJ2bWluXCIsIFwidm1heFwiLCAvLyB2aWV3cG9ydCByZWxhdGl2ZVxuXHRcdFx0XHRcdFwiY21cIiwgXCJtbVwiLCBcIlFcIiwgXCJpblwiLCBcInBjXCIsIFwicHRcIiwgXCJweFwiLCAvLyBhYnNvbHV0ZSBsZW5ndGhzXG5cdFx0XHRcdFx0XCJkZWdcIiwgXCJncmFkXCIsIFwicmFkXCIsIFwidHVyblwiLCAvLyBhbmdsZXNcblx0XHRcdFx0XHRcInNcIiwgXCJtc1wiIC8vIHRpbWVcblx0XHRcdFx0XSxcblx0XHRcdFx0Y29sb3JOYW1lczoge1xuXHRcdFx0XHRcdFwiYWxpY2VibHVlXCI6IFwiMjQwLDI0OCwyNTVcIixcblx0XHRcdFx0XHRcImFudGlxdWV3aGl0ZVwiOiBcIjI1MCwyMzUsMjE1XCIsXG5cdFx0XHRcdFx0XCJhcXVhbWFyaW5lXCI6IFwiMTI3LDI1NSwyMTJcIixcblx0XHRcdFx0XHRcImFxdWFcIjogXCIwLDI1NSwyNTVcIixcblx0XHRcdFx0XHRcImF6dXJlXCI6IFwiMjQwLDI1NSwyNTVcIixcblx0XHRcdFx0XHRcImJlaWdlXCI6IFwiMjQ1LDI0NSwyMjBcIixcblx0XHRcdFx0XHRcImJpc3F1ZVwiOiBcIjI1NSwyMjgsMTk2XCIsXG5cdFx0XHRcdFx0XCJibGFja1wiOiBcIjAsMCwwXCIsXG5cdFx0XHRcdFx0XCJibGFuY2hlZGFsbW9uZFwiOiBcIjI1NSwyMzUsMjA1XCIsXG5cdFx0XHRcdFx0XCJibHVldmlvbGV0XCI6IFwiMTM4LDQzLDIyNlwiLFxuXHRcdFx0XHRcdFwiYmx1ZVwiOiBcIjAsMCwyNTVcIixcblx0XHRcdFx0XHRcImJyb3duXCI6IFwiMTY1LDQyLDQyXCIsXG5cdFx0XHRcdFx0XCJidXJseXdvb2RcIjogXCIyMjIsMTg0LDEzNVwiLFxuXHRcdFx0XHRcdFwiY2FkZXRibHVlXCI6IFwiOTUsMTU4LDE2MFwiLFxuXHRcdFx0XHRcdFwiY2hhcnRyZXVzZVwiOiBcIjEyNywyNTUsMFwiLFxuXHRcdFx0XHRcdFwiY2hvY29sYXRlXCI6IFwiMjEwLDEwNSwzMFwiLFxuXHRcdFx0XHRcdFwiY29yYWxcIjogXCIyNTUsMTI3LDgwXCIsXG5cdFx0XHRcdFx0XCJjb3JuZmxvd2VyYmx1ZVwiOiBcIjEwMCwxNDksMjM3XCIsXG5cdFx0XHRcdFx0XCJjb3Juc2lsa1wiOiBcIjI1NSwyNDgsMjIwXCIsXG5cdFx0XHRcdFx0XCJjcmltc29uXCI6IFwiMjIwLDIwLDYwXCIsXG5cdFx0XHRcdFx0XCJjeWFuXCI6IFwiMCwyNTUsMjU1XCIsXG5cdFx0XHRcdFx0XCJkYXJrYmx1ZVwiOiBcIjAsMCwxMzlcIixcblx0XHRcdFx0XHRcImRhcmtjeWFuXCI6IFwiMCwxMzksMTM5XCIsXG5cdFx0XHRcdFx0XCJkYXJrZ29sZGVucm9kXCI6IFwiMTg0LDEzNCwxMVwiLFxuXHRcdFx0XHRcdFwiZGFya2dyYXlcIjogXCIxNjksMTY5LDE2OVwiLFxuXHRcdFx0XHRcdFwiZGFya2dyZXlcIjogXCIxNjksMTY5LDE2OVwiLFxuXHRcdFx0XHRcdFwiZGFya2dyZWVuXCI6IFwiMCwxMDAsMFwiLFxuXHRcdFx0XHRcdFwiZGFya2toYWtpXCI6IFwiMTg5LDE4MywxMDdcIixcblx0XHRcdFx0XHRcImRhcmttYWdlbnRhXCI6IFwiMTM5LDAsMTM5XCIsXG5cdFx0XHRcdFx0XCJkYXJrb2xpdmVncmVlblwiOiBcIjg1LDEwNyw0N1wiLFxuXHRcdFx0XHRcdFwiZGFya29yYW5nZVwiOiBcIjI1NSwxNDAsMFwiLFxuXHRcdFx0XHRcdFwiZGFya29yY2hpZFwiOiBcIjE1Myw1MCwyMDRcIixcblx0XHRcdFx0XHRcImRhcmtyZWRcIjogXCIxMzksMCwwXCIsXG5cdFx0XHRcdFx0XCJkYXJrc2FsbW9uXCI6IFwiMjMzLDE1MCwxMjJcIixcblx0XHRcdFx0XHRcImRhcmtzZWFncmVlblwiOiBcIjE0MywxODgsMTQzXCIsXG5cdFx0XHRcdFx0XCJkYXJrc2xhdGVibHVlXCI6IFwiNzIsNjEsMTM5XCIsXG5cdFx0XHRcdFx0XCJkYXJrc2xhdGVncmF5XCI6IFwiNDcsNzksNzlcIixcblx0XHRcdFx0XHRcImRhcmt0dXJxdW9pc2VcIjogXCIwLDIwNiwyMDlcIixcblx0XHRcdFx0XHRcImRhcmt2aW9sZXRcIjogXCIxNDgsMCwyMTFcIixcblx0XHRcdFx0XHRcImRlZXBwaW5rXCI6IFwiMjU1LDIwLDE0N1wiLFxuXHRcdFx0XHRcdFwiZGVlcHNreWJsdWVcIjogXCIwLDE5MSwyNTVcIixcblx0XHRcdFx0XHRcImRpbWdyYXlcIjogXCIxMDUsMTA1LDEwNVwiLFxuXHRcdFx0XHRcdFwiZGltZ3JleVwiOiBcIjEwNSwxMDUsMTA1XCIsXG5cdFx0XHRcdFx0XCJkb2RnZXJibHVlXCI6IFwiMzAsMTQ0LDI1NVwiLFxuXHRcdFx0XHRcdFwiZmlyZWJyaWNrXCI6IFwiMTc4LDM0LDM0XCIsXG5cdFx0XHRcdFx0XCJmbG9yYWx3aGl0ZVwiOiBcIjI1NSwyNTAsMjQwXCIsXG5cdFx0XHRcdFx0XCJmb3Jlc3RncmVlblwiOiBcIjM0LDEzOSwzNFwiLFxuXHRcdFx0XHRcdFwiZnVjaHNpYVwiOiBcIjI1NSwwLDI1NVwiLFxuXHRcdFx0XHRcdFwiZ2FpbnNib3JvXCI6IFwiMjIwLDIyMCwyMjBcIixcblx0XHRcdFx0XHRcImdob3N0d2hpdGVcIjogXCIyNDgsMjQ4LDI1NVwiLFxuXHRcdFx0XHRcdFwiZ29sZFwiOiBcIjI1NSwyMTUsMFwiLFxuXHRcdFx0XHRcdFwiZ29sZGVucm9kXCI6IFwiMjE4LDE2NSwzMlwiLFxuXHRcdFx0XHRcdFwiZ3JheVwiOiBcIjEyOCwxMjgsMTI4XCIsXG5cdFx0XHRcdFx0XCJncmV5XCI6IFwiMTI4LDEyOCwxMjhcIixcblx0XHRcdFx0XHRcImdyZWVueWVsbG93XCI6IFwiMTczLDI1NSw0N1wiLFxuXHRcdFx0XHRcdFwiZ3JlZW5cIjogXCIwLDEyOCwwXCIsXG5cdFx0XHRcdFx0XCJob25leWRld1wiOiBcIjI0MCwyNTUsMjQwXCIsXG5cdFx0XHRcdFx0XCJob3RwaW5rXCI6IFwiMjU1LDEwNSwxODBcIixcblx0XHRcdFx0XHRcImluZGlhbnJlZFwiOiBcIjIwNSw5Miw5MlwiLFxuXHRcdFx0XHRcdFwiaW5kaWdvXCI6IFwiNzUsMCwxMzBcIixcblx0XHRcdFx0XHRcIml2b3J5XCI6IFwiMjU1LDI1NSwyNDBcIixcblx0XHRcdFx0XHRcImtoYWtpXCI6IFwiMjQwLDIzMCwxNDBcIixcblx0XHRcdFx0XHRcImxhdmVuZGVyYmx1c2hcIjogXCIyNTUsMjQwLDI0NVwiLFxuXHRcdFx0XHRcdFwibGF2ZW5kZXJcIjogXCIyMzAsMjMwLDI1MFwiLFxuXHRcdFx0XHRcdFwibGF3bmdyZWVuXCI6IFwiMTI0LDI1MiwwXCIsXG5cdFx0XHRcdFx0XCJsZW1vbmNoaWZmb25cIjogXCIyNTUsMjUwLDIwNVwiLFxuXHRcdFx0XHRcdFwibGlnaHRibHVlXCI6IFwiMTczLDIxNiwyMzBcIixcblx0XHRcdFx0XHRcImxpZ2h0Y29yYWxcIjogXCIyNDAsMTI4LDEyOFwiLFxuXHRcdFx0XHRcdFwibGlnaHRjeWFuXCI6IFwiMjI0LDI1NSwyNTVcIixcblx0XHRcdFx0XHRcImxpZ2h0Z29sZGVucm9keWVsbG93XCI6IFwiMjUwLDI1MCwyMTBcIixcblx0XHRcdFx0XHRcImxpZ2h0Z3JheVwiOiBcIjIxMSwyMTEsMjExXCIsXG5cdFx0XHRcdFx0XCJsaWdodGdyZXlcIjogXCIyMTEsMjExLDIxMVwiLFxuXHRcdFx0XHRcdFwibGlnaHRncmVlblwiOiBcIjE0NCwyMzgsMTQ0XCIsXG5cdFx0XHRcdFx0XCJsaWdodHBpbmtcIjogXCIyNTUsMTgyLDE5M1wiLFxuXHRcdFx0XHRcdFwibGlnaHRzYWxtb25cIjogXCIyNTUsMTYwLDEyMlwiLFxuXHRcdFx0XHRcdFwibGlnaHRzZWFncmVlblwiOiBcIjMyLDE3OCwxNzBcIixcblx0XHRcdFx0XHRcImxpZ2h0c2t5Ymx1ZVwiOiBcIjEzNSwyMDYsMjUwXCIsXG5cdFx0XHRcdFx0XCJsaWdodHNsYXRlZ3JheVwiOiBcIjExOSwxMzYsMTUzXCIsXG5cdFx0XHRcdFx0XCJsaWdodHN0ZWVsYmx1ZVwiOiBcIjE3NiwxOTYsMjIyXCIsXG5cdFx0XHRcdFx0XCJsaWdodHllbGxvd1wiOiBcIjI1NSwyNTUsMjI0XCIsXG5cdFx0XHRcdFx0XCJsaW1lZ3JlZW5cIjogXCI1MCwyMDUsNTBcIixcblx0XHRcdFx0XHRcImxpbWVcIjogXCIwLDI1NSwwXCIsXG5cdFx0XHRcdFx0XCJsaW5lblwiOiBcIjI1MCwyNDAsMjMwXCIsXG5cdFx0XHRcdFx0XCJtYWdlbnRhXCI6IFwiMjU1LDAsMjU1XCIsXG5cdFx0XHRcdFx0XCJtYXJvb25cIjogXCIxMjgsMCwwXCIsXG5cdFx0XHRcdFx0XCJtZWRpdW1hcXVhbWFyaW5lXCI6IFwiMTAyLDIwNSwxNzBcIixcblx0XHRcdFx0XHRcIm1lZGl1bWJsdWVcIjogXCIwLDAsMjA1XCIsXG5cdFx0XHRcdFx0XCJtZWRpdW1vcmNoaWRcIjogXCIxODYsODUsMjExXCIsXG5cdFx0XHRcdFx0XCJtZWRpdW1wdXJwbGVcIjogXCIxNDcsMTEyLDIxOVwiLFxuXHRcdFx0XHRcdFwibWVkaXVtc2VhZ3JlZW5cIjogXCI2MCwxNzksMTEzXCIsXG5cdFx0XHRcdFx0XCJtZWRpdW1zbGF0ZWJsdWVcIjogXCIxMjMsMTA0LDIzOFwiLFxuXHRcdFx0XHRcdFwibWVkaXVtc3ByaW5nZ3JlZW5cIjogXCIwLDI1MCwxNTRcIixcblx0XHRcdFx0XHRcIm1lZGl1bXR1cnF1b2lzZVwiOiBcIjcyLDIwOSwyMDRcIixcblx0XHRcdFx0XHRcIm1lZGl1bXZpb2xldHJlZFwiOiBcIjE5OSwyMSwxMzNcIixcblx0XHRcdFx0XHRcIm1pZG5pZ2h0Ymx1ZVwiOiBcIjI1LDI1LDExMlwiLFxuXHRcdFx0XHRcdFwibWludGNyZWFtXCI6IFwiMjQ1LDI1NSwyNTBcIixcblx0XHRcdFx0XHRcIm1pc3R5cm9zZVwiOiBcIjI1NSwyMjgsMjI1XCIsXG5cdFx0XHRcdFx0XCJtb2NjYXNpblwiOiBcIjI1NSwyMjgsMTgxXCIsXG5cdFx0XHRcdFx0XCJuYXZham93aGl0ZVwiOiBcIjI1NSwyMjIsMTczXCIsXG5cdFx0XHRcdFx0XCJuYXZ5XCI6IFwiMCwwLDEyOFwiLFxuXHRcdFx0XHRcdFwib2xkbGFjZVwiOiBcIjI1MywyNDUsMjMwXCIsXG5cdFx0XHRcdFx0XCJvbGl2ZWRyYWJcIjogXCIxMDcsMTQyLDM1XCIsXG5cdFx0XHRcdFx0XCJvbGl2ZVwiOiBcIjEyOCwxMjgsMFwiLFxuXHRcdFx0XHRcdFwib3JhbmdlcmVkXCI6IFwiMjU1LDY5LDBcIixcblx0XHRcdFx0XHRcIm9yYW5nZVwiOiBcIjI1NSwxNjUsMFwiLFxuXHRcdFx0XHRcdFwib3JjaGlkXCI6IFwiMjE4LDExMiwyMTRcIixcblx0XHRcdFx0XHRcInBhbGVnb2xkZW5yb2RcIjogXCIyMzgsMjMyLDE3MFwiLFxuXHRcdFx0XHRcdFwicGFsZWdyZWVuXCI6IFwiMTUyLDI1MSwxNTJcIixcblx0XHRcdFx0XHRcInBhbGV0dXJxdW9pc2VcIjogXCIxNzUsMjM4LDIzOFwiLFxuXHRcdFx0XHRcdFwicGFsZXZpb2xldHJlZFwiOiBcIjIxOSwxMTIsMTQ3XCIsXG5cdFx0XHRcdFx0XCJwYXBheWF3aGlwXCI6IFwiMjU1LDIzOSwyMTNcIixcblx0XHRcdFx0XHRcInBlYWNocHVmZlwiOiBcIjI1NSwyMTgsMTg1XCIsXG5cdFx0XHRcdFx0XCJwZXJ1XCI6IFwiMjA1LDEzMyw2M1wiLFxuXHRcdFx0XHRcdFwicGlua1wiOiBcIjI1NSwxOTIsMjAzXCIsXG5cdFx0XHRcdFx0XCJwbHVtXCI6IFwiMjIxLDE2MCwyMjFcIixcblx0XHRcdFx0XHRcInBvd2RlcmJsdWVcIjogXCIxNzYsMjI0LDIzMFwiLFxuXHRcdFx0XHRcdFwicHVycGxlXCI6IFwiMTI4LDAsMTI4XCIsXG5cdFx0XHRcdFx0XCJyZWRcIjogXCIyNTUsMCwwXCIsXG5cdFx0XHRcdFx0XCJyb3N5YnJvd25cIjogXCIxODgsMTQzLDE0M1wiLFxuXHRcdFx0XHRcdFwicm95YWxibHVlXCI6IFwiNjUsMTA1LDIyNVwiLFxuXHRcdFx0XHRcdFwic2FkZGxlYnJvd25cIjogXCIxMzksNjksMTlcIixcblx0XHRcdFx0XHRcInNhbG1vblwiOiBcIjI1MCwxMjgsMTE0XCIsXG5cdFx0XHRcdFx0XCJzYW5keWJyb3duXCI6IFwiMjQ0LDE2NCw5NlwiLFxuXHRcdFx0XHRcdFwic2VhZ3JlZW5cIjogXCI0NiwxMzksODdcIixcblx0XHRcdFx0XHRcInNlYXNoZWxsXCI6IFwiMjU1LDI0NSwyMzhcIixcblx0XHRcdFx0XHRcInNpZW5uYVwiOiBcIjE2MCw4Miw0NVwiLFxuXHRcdFx0XHRcdFwic2lsdmVyXCI6IFwiMTkyLDE5MiwxOTJcIixcblx0XHRcdFx0XHRcInNreWJsdWVcIjogXCIxMzUsMjA2LDIzNVwiLFxuXHRcdFx0XHRcdFwic2xhdGVibHVlXCI6IFwiMTA2LDkwLDIwNVwiLFxuXHRcdFx0XHRcdFwic2xhdGVncmF5XCI6IFwiMTEyLDEyOCwxNDRcIixcblx0XHRcdFx0XHRcInNub3dcIjogXCIyNTUsMjUwLDI1MFwiLFxuXHRcdFx0XHRcdFwic3ByaW5nZ3JlZW5cIjogXCIwLDI1NSwxMjdcIixcblx0XHRcdFx0XHRcInN0ZWVsYmx1ZVwiOiBcIjcwLDEzMCwxODBcIixcblx0XHRcdFx0XHRcInRhblwiOiBcIjIxMCwxODAsMTQwXCIsXG5cdFx0XHRcdFx0XCJ0ZWFsXCI6IFwiMCwxMjgsMTI4XCIsXG5cdFx0XHRcdFx0XCJ0aGlzdGxlXCI6IFwiMjE2LDE5MSwyMTZcIixcblx0XHRcdFx0XHRcInRvbWF0b1wiOiBcIjI1NSw5OSw3MVwiLFxuXHRcdFx0XHRcdFwidHVycXVvaXNlXCI6IFwiNjQsMjI0LDIwOFwiLFxuXHRcdFx0XHRcdFwidmlvbGV0XCI6IFwiMjM4LDEzMCwyMzhcIixcblx0XHRcdFx0XHRcIndoZWF0XCI6IFwiMjQ1LDIyMiwxNzlcIixcblx0XHRcdFx0XHRcIndoaXRlc21va2VcIjogXCIyNDUsMjQ1LDI0NVwiLFxuXHRcdFx0XHRcdFwid2hpdGVcIjogXCIyNTUsMjU1LDI1NVwiLFxuXHRcdFx0XHRcdFwieWVsbG93Z3JlZW5cIjogXCIxNTQsMjA1LDUwXCIsXG5cdFx0XHRcdFx0XCJ5ZWxsb3dcIjogXCIyNTUsMjU1LDBcIlxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0LyoqKioqKioqKioqKlxuXHRcdFx0IEhvb2tzXG5cdFx0XHQgKioqKioqKioqKioqL1xuXG5cdFx0XHQvKiBIb29rcyBhbGxvdyBhIHN1YnByb3BlcnR5IChlLmcuIFwiYm94U2hhZG93Qmx1clwiKSBvZiBhIGNvbXBvdW5kLXZhbHVlIENTUyBwcm9wZXJ0eVxuXHRcdFx0IChlLmcuIFwiYm94U2hhZG93OiBYIFkgQmx1ciBTcHJlYWQgQ29sb3JcIikgdG8gYmUgYW5pbWF0ZWQgYXMgaWYgaXQgd2VyZSBhIGRpc2NyZXRlIHByb3BlcnR5LiAqL1xuXHRcdFx0LyogTm90ZTogQmV5b25kIGVuYWJsaW5nIGZpbmUtZ3JhaW5lZCBwcm9wZXJ0eSBhbmltYXRpb24sIGhvb2tpbmcgaXMgbmVjZXNzYXJ5IHNpbmNlIFZlbG9jaXR5IG9ubHlcblx0XHRcdCB0d2VlbnMgcHJvcGVydGllcyB3aXRoIHNpbmdsZSBudW1lcmljIHZhbHVlczsgdW5saWtlIENTUyB0cmFuc2l0aW9ucywgVmVsb2NpdHkgZG9lcyBub3QgaW50ZXJwb2xhdGUgY29tcG91bmQtdmFsdWVzLiAqL1xuXHRcdFx0SG9va3M6IHtcblx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdCBSZWdpc3RyYXRpb25cblx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdC8qIFRlbXBsYXRlcyBhcmUgYSBjb25jaXNlIHdheSBvZiBpbmRpY2F0aW5nIHdoaWNoIHN1YnByb3BlcnRpZXMgbXVzdCBiZSBpbmRpdmlkdWFsbHkgcmVnaXN0ZXJlZCBmb3IgZWFjaCBjb21wb3VuZC12YWx1ZSBDU1MgcHJvcGVydHkuICovXG5cdFx0XHRcdC8qIEVhY2ggdGVtcGxhdGUgY29uc2lzdHMgb2YgdGhlIGNvbXBvdW5kLXZhbHVlJ3MgYmFzZSBuYW1lLCBpdHMgY29uc3RpdHVlbnQgc3VicHJvcGVydHkgbmFtZXMsIGFuZCB0aG9zZSBzdWJwcm9wZXJ0aWVzJyBkZWZhdWx0IHZhbHVlcy4gKi9cblx0XHRcdFx0dGVtcGxhdGVzOiB7XG5cdFx0XHRcdFx0XCJ0ZXh0U2hhZG93XCI6IFtcIkNvbG9yIFggWSBCbHVyXCIsIFwiYmxhY2sgMHB4IDBweCAwcHhcIl0sXG5cdFx0XHRcdFx0XCJib3hTaGFkb3dcIjogW1wiQ29sb3IgWCBZIEJsdXIgU3ByZWFkXCIsIFwiYmxhY2sgMHB4IDBweCAwcHggMHB4XCJdLFxuXHRcdFx0XHRcdFwiY2xpcFwiOiBbXCJUb3AgUmlnaHQgQm90dG9tIExlZnRcIiwgXCIwcHggMHB4IDBweCAwcHhcIl0sXG5cdFx0XHRcdFx0XCJiYWNrZ3JvdW5kUG9zaXRpb25cIjogW1wiWCBZXCIsIFwiMCUgMCVcIl0sXG5cdFx0XHRcdFx0XCJ0cmFuc2Zvcm1PcmlnaW5cIjogW1wiWCBZIFpcIiwgXCI1MCUgNTAlIDBweFwiXSxcblx0XHRcdFx0XHRcInBlcnNwZWN0aXZlT3JpZ2luXCI6IFtcIlggWVwiLCBcIjUwJSA1MCVcIl1cblx0XHRcdFx0fSxcblx0XHRcdFx0LyogQSBcInJlZ2lzdGVyZWRcIiBob29rIGlzIG9uZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCBmcm9tIGl0cyB0ZW1wbGF0ZSBmb3JtIGludG8gYSBsaXZlLFxuXHRcdFx0XHQgdHdlZW5hYmxlIHByb3BlcnR5LiBJdCBjb250YWlucyBkYXRhIHRvIGFzc29jaWF0ZSBpdCB3aXRoIGl0cyByb290IHByb3BlcnR5LiAqL1xuXHRcdFx0XHRyZWdpc3RlcmVkOiB7XG5cdFx0XHRcdFx0LyogTm90ZTogQSByZWdpc3RlcmVkIGhvb2sgbG9va3MgbGlrZSB0aGlzID09PiB0ZXh0U2hhZG93Qmx1cjogWyBcInRleHRTaGFkb3dcIiwgMyBdLFxuXHRcdFx0XHRcdCB3aGljaCBjb25zaXN0cyBvZiB0aGUgc3VicHJvcGVydHkncyBuYW1lLCB0aGUgYXNzb2NpYXRlZCByb290IHByb3BlcnR5J3MgbmFtZSxcblx0XHRcdFx0XHQgYW5kIHRoZSBzdWJwcm9wZXJ0eSdzIHBvc2l0aW9uIGluIHRoZSByb290J3MgdmFsdWUuICovXG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8qIENvbnZlcnQgdGhlIHRlbXBsYXRlcyBpbnRvIGluZGl2aWR1YWwgaG9va3MgdGhlbiBhcHBlbmQgdGhlbSB0byB0aGUgcmVnaXN0ZXJlZCBvYmplY3QgYWJvdmUuICovXG5cdFx0XHRcdHJlZ2lzdGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvKiBDb2xvciBob29rcyByZWdpc3RyYXRpb246IENvbG9ycyBhcmUgZGVmYXVsdGVkIHRvIHdoaXRlIC0tIGFzIG9wcG9zZWQgdG8gYmxhY2sgLS0gc2luY2UgY29sb3JzIHRoYXQgYXJlXG5cdFx0XHRcdFx0IGN1cnJlbnRseSBzZXQgdG8gXCJ0cmFuc3BhcmVudFwiIGRlZmF1bHQgdG8gdGhlaXIgcmVzcGVjdGl2ZSB0ZW1wbGF0ZSBiZWxvdyB3aGVuIGNvbG9yLWFuaW1hdGVkLFxuXHRcdFx0XHRcdCBhbmQgd2hpdGUgaXMgdHlwaWNhbGx5IGEgY2xvc2VyIG1hdGNoIHRvIHRyYW5zcGFyZW50IHRoYW4gYmxhY2sgaXMuIEFuIGV4Y2VwdGlvbiBpcyBtYWRlIGZvciB0ZXh0IChcImNvbG9yXCIpLFxuXHRcdFx0XHRcdCB3aGljaCBpcyBhbG1vc3QgYWx3YXlzIHNldCBjbG9zZXIgdG8gYmxhY2sgdGhhbiB3aGl0ZS4gKi9cblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IENTUy5MaXN0cy5jb2xvcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHZhciByZ2JDb21wb25lbnRzID0gKENTUy5MaXN0cy5jb2xvcnNbaV0gPT09IFwiY29sb3JcIikgPyBcIjAgMCAwIDFcIiA6IFwiMjU1IDI1NSAyNTUgMVwiO1xuXHRcdFx0XHRcdFx0Q1NTLkhvb2tzLnRlbXBsYXRlc1tDU1MuTGlzdHMuY29sb3JzW2ldXSA9IFtcIlJlZCBHcmVlbiBCbHVlIEFscGhhXCIsIHJnYkNvbXBvbmVudHNdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciByb290UHJvcGVydHksXG5cdFx0XHRcdFx0XHRcdGhvb2tUZW1wbGF0ZSxcblx0XHRcdFx0XHRcdFx0aG9va05hbWVzO1xuXG5cdFx0XHRcdFx0LyogSW4gSUUsIGNvbG9yIHZhbHVlcyBpbnNpZGUgY29tcG91bmQtdmFsdWUgcHJvcGVydGllcyBhcmUgcG9zaXRpb25lZCBhdCB0aGUgZW5kIHRoZSB2YWx1ZSBpbnN0ZWFkIG9mIGF0IHRoZSBiZWdpbm5pbmcuXG5cdFx0XHRcdFx0IFRodXMsIHdlIHJlLWFycmFuZ2UgdGhlIHRlbXBsYXRlcyBhY2NvcmRpbmdseS4gKi9cblx0XHRcdFx0XHRpZiAoSUUpIHtcblx0XHRcdFx0XHRcdGZvciAocm9vdFByb3BlcnR5IGluIENTUy5Ib29rcy50ZW1wbGF0ZXMpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFDU1MuSG9va3MudGVtcGxhdGVzLmhhc093blByb3BlcnR5KHJvb3RQcm9wZXJ0eSkpIHtcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRob29rVGVtcGxhdGUgPSBDU1MuSG9va3MudGVtcGxhdGVzW3Jvb3RQcm9wZXJ0eV07XG5cdFx0XHRcdFx0XHRcdGhvb2tOYW1lcyA9IGhvb2tUZW1wbGF0ZVswXS5zcGxpdChcIiBcIik7XG5cblx0XHRcdFx0XHRcdFx0dmFyIGRlZmF1bHRWYWx1ZXMgPSBob29rVGVtcGxhdGVbMV0ubWF0Y2goQ1NTLlJlZ0V4LnZhbHVlU3BsaXQpO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChob29rTmFtZXNbMF0gPT09IFwiQ29sb3JcIikge1xuXHRcdFx0XHRcdFx0XHRcdC8qIFJlcG9zaXRpb24gYm90aCB0aGUgaG9vaydzIG5hbWUgYW5kIGl0cyBkZWZhdWx0IHZhbHVlIHRvIHRoZSBlbmQgb2YgdGhlaXIgcmVzcGVjdGl2ZSBzdHJpbmdzLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGhvb2tOYW1lcy5wdXNoKGhvb2tOYW1lcy5zaGlmdCgpKTtcblx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0VmFsdWVzLnB1c2goZGVmYXVsdFZhbHVlcy5zaGlmdCgpKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8qIFJlcGxhY2UgdGhlIGV4aXN0aW5nIHRlbXBsYXRlIGZvciB0aGUgaG9vaydzIHJvb3QgcHJvcGVydHkuICovXG5cdFx0XHRcdFx0XHRcdFx0Q1NTLkhvb2tzLnRlbXBsYXRlc1tyb290UHJvcGVydHldID0gW2hvb2tOYW1lcy5qb2luKFwiIFwiKSwgZGVmYXVsdFZhbHVlcy5qb2luKFwiIFwiKV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBIb29rIHJlZ2lzdHJhdGlvbi4gKi9cblx0XHRcdFx0XHRmb3IgKHJvb3RQcm9wZXJ0eSBpbiBDU1MuSG9va3MudGVtcGxhdGVzKSB7XG5cdFx0XHRcdFx0XHRpZiAoIUNTUy5Ib29rcy50ZW1wbGF0ZXMuaGFzT3duUHJvcGVydHkocm9vdFByb3BlcnR5KSkge1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGhvb2tUZW1wbGF0ZSA9IENTUy5Ib29rcy50ZW1wbGF0ZXNbcm9vdFByb3BlcnR5XTtcblx0XHRcdFx0XHRcdGhvb2tOYW1lcyA9IGhvb2tUZW1wbGF0ZVswXS5zcGxpdChcIiBcIik7XG5cblx0XHRcdFx0XHRcdGZvciAodmFyIGogaW4gaG9va05hbWVzKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghaG9va05hbWVzLmhhc093blByb3BlcnR5KGopKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dmFyIGZ1bGxIb29rTmFtZSA9IHJvb3RQcm9wZXJ0eSArIGhvb2tOYW1lc1tqXSxcblx0XHRcdFx0XHRcdFx0XHRcdGhvb2tQb3NpdGlvbiA9IGo7XG5cblx0XHRcdFx0XHRcdFx0LyogRm9yIGVhY2ggaG9vaywgcmVnaXN0ZXIgaXRzIGZ1bGwgbmFtZSAoZS5nLiB0ZXh0U2hhZG93Qmx1cikgd2l0aCBpdHMgcm9vdCBwcm9wZXJ0eSAoZS5nLiB0ZXh0U2hhZG93KVxuXHRcdFx0XHRcdFx0XHQgYW5kIHRoZSBob29rJ3MgcG9zaXRpb24gaW4gaXRzIHRlbXBsYXRlJ3MgZGVmYXVsdCB2YWx1ZSBzdHJpbmcuICovXG5cdFx0XHRcdFx0XHRcdENTUy5Ib29rcy5yZWdpc3RlcmVkW2Z1bGxIb29rTmFtZV0gPSBbcm9vdFByb3BlcnR5LCBob29rUG9zaXRpb25dO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdCBJbmplY3Rpb24gYW5kIEV4dHJhY3Rpb25cblx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdC8qIExvb2sgdXAgdGhlIHJvb3QgcHJvcGVydHkgYXNzb2NpYXRlZCB3aXRoIHRoZSBob29rIChlLmcuIHJldHVybiBcInRleHRTaGFkb3dcIiBmb3IgXCJ0ZXh0U2hhZG93Qmx1clwiKS4gKi9cblx0XHRcdFx0LyogU2luY2UgYSBob29rIGNhbm5vdCBiZSBzZXQgZGlyZWN0bHkgKHRoZSBicm93c2VyIHdvbid0IHJlY29nbml6ZSBpdCksIHN0eWxlIHVwZGF0aW5nIGZvciBob29rcyBpcyByb3V0ZWQgdGhyb3VnaCB0aGUgaG9vaydzIHJvb3QgcHJvcGVydHkuICovXG5cdFx0XHRcdGdldFJvb3Q6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG5cdFx0XHRcdFx0dmFyIGhvb2tEYXRhID0gQ1NTLkhvb2tzLnJlZ2lzdGVyZWRbcHJvcGVydHldO1xuXG5cdFx0XHRcdFx0aWYgKGhvb2tEYXRhKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaG9va0RhdGFbMF07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8qIElmIHRoZXJlIHdhcyBubyBob29rIG1hdGNoLCByZXR1cm4gdGhlIHByb3BlcnR5IG5hbWUgdW50b3VjaGVkLiAqL1xuXHRcdFx0XHRcdFx0cmV0dXJuIHByb3BlcnR5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0Z2V0VW5pdDogZnVuY3Rpb24oc3RyLCBzdGFydCkge1xuXHRcdFx0XHRcdHZhciB1bml0ID0gKHN0ci5zdWJzdHIoc3RhcnQgfHwgMCwgNSkubWF0Y2goL15bYS16JV0rLykgfHwgW10pWzBdIHx8IFwiXCI7XG5cblx0XHRcdFx0XHRpZiAodW5pdCAmJiBfaW5BcnJheShDU1MuTGlzdHMudW5pdHMsIHVuaXQpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdW5pdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZpeENvbG9yczogZnVuY3Rpb24oc3RyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8ocmdiYT9cXChcXHMqKT8oXFxiW2Etel0rXFxiKS9nLCBmdW5jdGlvbigkMCwgJDEsICQyKSB7XG5cdFx0XHRcdFx0XHRpZiAoQ1NTLkxpc3RzLmNvbG9yTmFtZXMuaGFzT3duUHJvcGVydHkoJDIpKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiAoJDEgPyAkMSA6IFwicmdiYShcIikgKyBDU1MuTGlzdHMuY29sb3JOYW1lc1skMl0gKyAoJDEgPyBcIlwiIDogXCIsMSlcIik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gJDEgKyAkMjtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0LyogQ29udmVydCBhbnkgcm9vdFByb3BlcnR5VmFsdWUsIG51bGwgb3Igb3RoZXJ3aXNlLCBpbnRvIGEgc3BhY2UtZGVsaW1pdGVkIGxpc3Qgb2YgaG9vayB2YWx1ZXMgc28gdGhhdFxuXHRcdFx0XHQgdGhlIHRhcmdldGVkIGhvb2sgY2FuIGJlIGluamVjdGVkIG9yIGV4dHJhY3RlZCBhdCBpdHMgc3RhbmRhcmQgcG9zaXRpb24uICovXG5cdFx0XHRcdGNsZWFuUm9vdFByb3BlcnR5VmFsdWU6IGZ1bmN0aW9uKHJvb3RQcm9wZXJ0eSwgcm9vdFByb3BlcnR5VmFsdWUpIHtcblx0XHRcdFx0XHQvKiBJZiB0aGUgcm9vdFByb3BlcnR5VmFsdWUgaXMgd3JhcHBlZCB3aXRoIFwicmdiKClcIiwgXCJjbGlwKClcIiwgZXRjLiwgcmVtb3ZlIHRoZSB3cmFwcGluZyB0byBub3JtYWxpemUgdGhlIHZhbHVlIGJlZm9yZSBtYW5pcHVsYXRpb24uICovXG5cdFx0XHRcdFx0aWYgKENTUy5SZWdFeC52YWx1ZVVud3JhcC50ZXN0KHJvb3RQcm9wZXJ0eVZhbHVlKSkge1xuXHRcdFx0XHRcdFx0cm9vdFByb3BlcnR5VmFsdWUgPSByb290UHJvcGVydHlWYWx1ZS5tYXRjaChDU1MuUmVnRXgudmFsdWVVbndyYXApWzFdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIElmIHJvb3RQcm9wZXJ0eVZhbHVlIGlzIGEgQ1NTIG51bGwtdmFsdWUgKGZyb20gd2hpY2ggdGhlcmUncyBpbmhlcmVudGx5IG5vIGhvb2sgdmFsdWUgdG8gZXh0cmFjdCksXG5cdFx0XHRcdFx0IGRlZmF1bHQgdG8gdGhlIHJvb3QncyBkZWZhdWx0IHZhbHVlIGFzIGRlZmluZWQgaW4gQ1NTLkhvb2tzLnRlbXBsYXRlcy4gKi9cblx0XHRcdFx0XHQvKiBOb3RlOiBDU1MgbnVsbC12YWx1ZXMgaW5jbHVkZSBcIm5vbmVcIiwgXCJhdXRvXCIsIGFuZCBcInRyYW5zcGFyZW50XCIuIFRoZXkgbXVzdCBiZSBjb252ZXJ0ZWQgaW50byB0aGVpclxuXHRcdFx0XHRcdCB6ZXJvLXZhbHVlcyAoZS5nLiB0ZXh0U2hhZG93OiBcIm5vbmVcIiA9PT4gdGV4dFNoYWRvdzogXCIwcHggMHB4IDBweCBibGFja1wiKSBmb3IgaG9vayBtYW5pcHVsYXRpb24gdG8gcHJvY2VlZC4gKi9cblx0XHRcdFx0XHRpZiAoQ1NTLlZhbHVlcy5pc0NTU051bGxWYWx1ZShyb290UHJvcGVydHlWYWx1ZSkpIHtcblx0XHRcdFx0XHRcdHJvb3RQcm9wZXJ0eVZhbHVlID0gQ1NTLkhvb2tzLnRlbXBsYXRlc1tyb290UHJvcGVydHldWzFdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiByb290UHJvcGVydHlWYWx1ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0LyogRXh0cmFjdGVkIHRoZSBob29rJ3MgdmFsdWUgZnJvbSBpdHMgcm9vdCBwcm9wZXJ0eSdzIHZhbHVlLiBUaGlzIGlzIHVzZWQgdG8gZ2V0IHRoZSBzdGFydGluZyB2YWx1ZSBvZiBhbiBhbmltYXRpbmcgaG9vay4gKi9cblx0XHRcdFx0ZXh0cmFjdFZhbHVlOiBmdW5jdGlvbihmdWxsSG9va05hbWUsIHJvb3RQcm9wZXJ0eVZhbHVlKSB7XG5cdFx0XHRcdFx0dmFyIGhvb2tEYXRhID0gQ1NTLkhvb2tzLnJlZ2lzdGVyZWRbZnVsbEhvb2tOYW1lXTtcblxuXHRcdFx0XHRcdGlmIChob29rRGF0YSkge1xuXHRcdFx0XHRcdFx0dmFyIGhvb2tSb290ID0gaG9va0RhdGFbMF0sXG5cdFx0XHRcdFx0XHRcdFx0aG9va1Bvc2l0aW9uID0gaG9va0RhdGFbMV07XG5cblx0XHRcdFx0XHRcdHJvb3RQcm9wZXJ0eVZhbHVlID0gQ1NTLkhvb2tzLmNsZWFuUm9vdFByb3BlcnR5VmFsdWUoaG9va1Jvb3QsIHJvb3RQcm9wZXJ0eVZhbHVlKTtcblxuXHRcdFx0XHRcdFx0LyogU3BsaXQgcm9vdFByb3BlcnR5VmFsdWUgaW50byBpdHMgY29uc3RpdHVlbnQgaG9vayB2YWx1ZXMgdGhlbiBncmFiIHRoZSBkZXNpcmVkIGhvb2sgYXQgaXRzIHN0YW5kYXJkIHBvc2l0aW9uLiAqL1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJvb3RQcm9wZXJ0eVZhbHVlLnRvU3RyaW5nKCkubWF0Y2goQ1NTLlJlZ0V4LnZhbHVlU3BsaXQpW2hvb2tQb3NpdGlvbl07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8qIElmIHRoZSBwcm92aWRlZCBmdWxsSG9va05hbWUgaXNuJ3QgYSByZWdpc3RlcmVkIGhvb2ssIHJldHVybiB0aGUgcm9vdFByb3BlcnR5VmFsdWUgdGhhdCB3YXMgcGFzc2VkIGluLiAqL1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJvb3RQcm9wZXJ0eVZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0LyogSW5qZWN0IHRoZSBob29rJ3MgdmFsdWUgaW50byBpdHMgcm9vdCBwcm9wZXJ0eSdzIHZhbHVlLiBUaGlzIGlzIHVzZWQgdG8gcGllY2UgYmFjayB0b2dldGhlciB0aGUgcm9vdCBwcm9wZXJ0eVxuXHRcdFx0XHQgb25jZSBWZWxvY2l0eSBoYXMgdXBkYXRlZCBvbmUgb2YgaXRzIGluZGl2aWR1YWxseSBob29rZWQgdmFsdWVzIHRocm91Z2ggdHdlZW5pbmcuICovXG5cdFx0XHRcdGluamVjdFZhbHVlOiBmdW5jdGlvbihmdWxsSG9va05hbWUsIGhvb2tWYWx1ZSwgcm9vdFByb3BlcnR5VmFsdWUpIHtcblx0XHRcdFx0XHR2YXIgaG9va0RhdGEgPSBDU1MuSG9va3MucmVnaXN0ZXJlZFtmdWxsSG9va05hbWVdO1xuXG5cdFx0XHRcdFx0aWYgKGhvb2tEYXRhKSB7XG5cdFx0XHRcdFx0XHR2YXIgaG9va1Jvb3QgPSBob29rRGF0YVswXSxcblx0XHRcdFx0XHRcdFx0XHRob29rUG9zaXRpb24gPSBob29rRGF0YVsxXSxcblx0XHRcdFx0XHRcdFx0XHRyb290UHJvcGVydHlWYWx1ZVBhcnRzLFxuXHRcdFx0XHRcdFx0XHRcdHJvb3RQcm9wZXJ0eVZhbHVlVXBkYXRlZDtcblxuXHRcdFx0XHRcdFx0cm9vdFByb3BlcnR5VmFsdWUgPSBDU1MuSG9va3MuY2xlYW5Sb290UHJvcGVydHlWYWx1ZShob29rUm9vdCwgcm9vdFByb3BlcnR5VmFsdWUpO1xuXG5cdFx0XHRcdFx0XHQvKiBTcGxpdCByb290UHJvcGVydHlWYWx1ZSBpbnRvIGl0cyBpbmRpdmlkdWFsIGhvb2sgdmFsdWVzLCByZXBsYWNlIHRoZSB0YXJnZXRlZCB2YWx1ZSB3aXRoIGhvb2tWYWx1ZSxcblx0XHRcdFx0XHRcdCB0aGVuIHJlY29uc3RydWN0IHRoZSByb290UHJvcGVydHlWYWx1ZSBzdHJpbmcuICovXG5cdFx0XHRcdFx0XHRyb290UHJvcGVydHlWYWx1ZVBhcnRzID0gcm9vdFByb3BlcnR5VmFsdWUudG9TdHJpbmcoKS5tYXRjaChDU1MuUmVnRXgudmFsdWVTcGxpdCk7XG5cdFx0XHRcdFx0XHRyb290UHJvcGVydHlWYWx1ZVBhcnRzW2hvb2tQb3NpdGlvbl0gPSBob29rVmFsdWU7XG5cdFx0XHRcdFx0XHRyb290UHJvcGVydHlWYWx1ZVVwZGF0ZWQgPSByb290UHJvcGVydHlWYWx1ZVBhcnRzLmpvaW4oXCIgXCIpO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gcm9vdFByb3BlcnR5VmFsdWVVcGRhdGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvKiBJZiB0aGUgcHJvdmlkZWQgZnVsbEhvb2tOYW1lIGlzbid0IGEgcmVnaXN0ZXJlZCBob29rLCByZXR1cm4gdGhlIHJvb3RQcm9wZXJ0eVZhbHVlIHRoYXQgd2FzIHBhc3NlZCBpbi4gKi9cblx0XHRcdFx0XHRcdHJldHVybiByb290UHJvcGVydHlWYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0IE5vcm1hbGl6YXRpb25zXG5cdFx0XHQgKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0LyogTm9ybWFsaXphdGlvbnMgc3RhbmRhcmRpemUgQ1NTIHByb3BlcnR5IG1hbmlwdWxhdGlvbiBieSBwb2xseWZpbGxpbmcgYnJvd3Nlci1zcGVjaWZpYyBpbXBsZW1lbnRhdGlvbnMgKGUuZy4gb3BhY2l0eSlcblx0XHRcdCBhbmQgcmVmb3JtYXR0aW5nIHNwZWNpYWwgcHJvcGVydGllcyAoZS5nLiBjbGlwLCByZ2JhKSB0byBsb29rIGxpa2Ugc3RhbmRhcmQgb25lcy4gKi9cblx0XHRcdE5vcm1hbGl6YXRpb25zOiB7XG5cdFx0XHRcdC8qIE5vcm1hbGl6YXRpb25zIGFyZSBwYXNzZWQgYSBub3JtYWxpemF0aW9uIHRhcmdldCAoZWl0aGVyIHRoZSBwcm9wZXJ0eSdzIG5hbWUsIGl0cyBleHRyYWN0ZWQgdmFsdWUsIG9yIGl0cyBpbmplY3RlZCB2YWx1ZSksXG5cdFx0XHRcdCB0aGUgdGFyZ2V0ZWQgZWxlbWVudCAod2hpY2ggbWF5IG5lZWQgdG8gYmUgcXVlcmllZCksIGFuZCB0aGUgdGFyZ2V0ZWQgcHJvcGVydHkgdmFsdWUuICovXG5cdFx0XHRcdHJlZ2lzdGVyZWQ6IHtcblx0XHRcdFx0XHRjbGlwOiBmdW5jdGlvbih0eXBlLCBlbGVtZW50LCBwcm9wZXJ0eVZhbHVlKSB7XG5cdFx0XHRcdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0XHRcdFx0Y2FzZSBcIm5hbWVcIjpcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJjbGlwXCI7XG5cdFx0XHRcdFx0XHRcdFx0LyogQ2xpcCBuZWVkcyB0byBiZSB1bndyYXBwZWQgYW5kIHN0cmlwcGVkIG9mIGl0cyBjb21tYXMgZHVyaW5nIGV4dHJhY3Rpb24uICovXG5cdFx0XHRcdFx0XHRcdGNhc2UgXCJleHRyYWN0XCI6XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGV4dHJhY3RlZDtcblxuXHRcdFx0XHRcdFx0XHRcdC8qIElmIFZlbG9jaXR5IGFsc28gZXh0cmFjdGVkIHRoaXMgdmFsdWUsIHNraXAgZXh0cmFjdGlvbi4gKi9cblx0XHRcdFx0XHRcdFx0XHRpZiAoQ1NTLlJlZ0V4LndyYXBwZWRWYWx1ZUFscmVhZHlFeHRyYWN0ZWQudGVzdChwcm9wZXJ0eVZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXh0cmFjdGVkID0gcHJvcGVydHlWYWx1ZTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0LyogUmVtb3ZlIHRoZSBcInJlY3QoKVwiIHdyYXBwZXIuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRleHRyYWN0ZWQgPSBwcm9wZXJ0eVZhbHVlLnRvU3RyaW5nKCkubWF0Y2goQ1NTLlJlZ0V4LnZhbHVlVW53cmFwKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0LyogU3RyaXAgb2ZmIGNvbW1hcy4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdGV4dHJhY3RlZCA9IGV4dHJhY3RlZCA/IGV4dHJhY3RlZFsxXS5yZXBsYWNlKC8sKFxccyspPy9nLCBcIiBcIikgOiBwcm9wZXJ0eVZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBleHRyYWN0ZWQ7XG5cdFx0XHRcdFx0XHRcdFx0LyogQ2xpcCBuZWVkcyB0byBiZSByZS13cmFwcGVkIGR1cmluZyBpbmplY3Rpb24uICovXG5cdFx0XHRcdFx0XHRcdGNhc2UgXCJpbmplY3RcIjpcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJyZWN0KFwiICsgcHJvcGVydHlWYWx1ZSArIFwiKVwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0Ymx1cjogZnVuY3Rpb24odHlwZSwgZWxlbWVudCwgcHJvcGVydHlWYWx1ZSkge1xuXHRcdFx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgXCJuYW1lXCI6XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIFZlbG9jaXR5LlN0YXRlLmlzRmlyZWZveCA/IFwiZmlsdGVyXCIgOiBcIi13ZWJraXQtZmlsdGVyXCI7XG5cdFx0XHRcdFx0XHRcdGNhc2UgXCJleHRyYWN0XCI6XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGV4dHJhY3RlZCA9IHBhcnNlRmxvYXQocHJvcGVydHlWYWx1ZSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvKiBJZiBleHRyYWN0ZWQgaXMgTmFOLCBtZWFuaW5nIHRoZSB2YWx1ZSBpc24ndCBhbHJlYWR5IGV4dHJhY3RlZC4gKi9cblx0XHRcdFx0XHRcdFx0XHRpZiAoIShleHRyYWN0ZWQgfHwgZXh0cmFjdGVkID09PSAwKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGJsdXJDb21wb25lbnQgPSBwcm9wZXJ0eVZhbHVlLnRvU3RyaW5nKCkubWF0Y2goL2JsdXJcXCgoWzAtOV0rW0Etel0rKVxcKS9pKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0LyogSWYgdGhlIGZpbHRlciBzdHJpbmcgaGFkIGEgYmx1ciBjb21wb25lbnQsIHJldHVybiBqdXN0IHRoZSBibHVyIHZhbHVlIGFuZCB1bml0IHR5cGUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoYmx1ckNvbXBvbmVudCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRleHRyYWN0ZWQgPSBibHVyQ29tcG9uZW50WzFdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBJZiB0aGUgY29tcG9uZW50IGRvZXNuJ3QgZXhpc3QsIGRlZmF1bHQgYmx1ciB0byAwLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZXh0cmFjdGVkID0gMDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZXh0cmFjdGVkO1xuXHRcdFx0XHRcdFx0XHRcdC8qIEJsdXIgbmVlZHMgdG8gYmUgcmUtd3JhcHBlZCBkdXJpbmcgaW5qZWN0aW9uLiAqL1xuXHRcdFx0XHRcdFx0XHRjYXNlIFwiaW5qZWN0XCI6XG5cdFx0XHRcdFx0XHRcdFx0LyogRm9yIHRoZSBibHVyIGVmZmVjdCB0byBiZSBmdWxseSBkZS1hcHBsaWVkLCBpdCBuZWVkcyB0byBiZSBzZXQgdG8gXCJub25lXCIgaW5zdGVhZCBvZiAwLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmICghcGFyc2VGbG9hdChwcm9wZXJ0eVZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIFwibm9uZVwiO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJibHVyKFwiICsgcHJvcGVydHlWYWx1ZSArIFwiKVwiO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdC8qIDw9SUU4IGRvIG5vdCBzdXBwb3J0IHRoZSBzdGFuZGFyZCBvcGFjaXR5IHByb3BlcnR5LiBUaGV5IHVzZSBmaWx0ZXI6YWxwaGEob3BhY2l0eT1JTlQpIGluc3RlYWQuICovXG5cdFx0XHRcdFx0b3BhY2l0eTogZnVuY3Rpb24odHlwZSwgZWxlbWVudCwgcHJvcGVydHlWYWx1ZSkge1xuXHRcdFx0XHRcdFx0aWYgKElFIDw9IDgpIHtcblx0XHRcdFx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBcIm5hbWVcIjpcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBcImZpbHRlclwiO1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJleHRyYWN0XCI6XG5cdFx0XHRcdFx0XHRcdFx0XHQvKiA8PUlFOCByZXR1cm4gYSBcImZpbHRlclwiIHZhbHVlIG9mIFwiYWxwaGEob3BhY2l0eT1cXGR7MSwzfSlcIi5cblx0XHRcdFx0XHRcdFx0XHRcdCBFeHRyYWN0IHRoZSB2YWx1ZSBhbmQgY29udmVydCBpdCB0byBhIGRlY2ltYWwgdmFsdWUgdG8gbWF0Y2ggdGhlIHN0YW5kYXJkIENTUyBvcGFjaXR5IHByb3BlcnR5J3MgZm9ybWF0dGluZy4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdHZhciBleHRyYWN0ZWQgPSBwcm9wZXJ0eVZhbHVlLnRvU3RyaW5nKCkubWF0Y2goL2FscGhhXFwob3BhY2l0eT0oLiopXFwpL2kpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoZXh0cmFjdGVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIENvbnZlcnQgdG8gZGVjaW1hbCB2YWx1ZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcGVydHlWYWx1ZSA9IGV4dHJhY3RlZFsxXSAvIDEwMDtcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIFdoZW4gZXh0cmFjdGluZyBvcGFjaXR5LCBkZWZhdWx0IHRvIDEgc2luY2UgYSBudWxsIHZhbHVlIG1lYW5zIG9wYWNpdHkgaGFzbid0IGJlZW4gc2V0LiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eVZhbHVlID0gMTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHByb3BlcnR5VmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBcImluamVjdFwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0LyogT3BhY2lmaWVkIGVsZW1lbnRzIGFyZSByZXF1aXJlZCB0byBoYXZlIHRoZWlyIHpvb20gcHJvcGVydHkgc2V0IHRvIGEgbm9uLXplcm8gdmFsdWUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRlbGVtZW50LnN0eWxlLnpvb20gPSAxO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBTZXR0aW5nIHRoZSBmaWx0ZXIgcHJvcGVydHkgb24gZWxlbWVudHMgd2l0aCBjZXJ0YWluIGZvbnQgcHJvcGVydHkgY29tYmluYXRpb25zIGNhbiByZXN1bHQgaW4gYVxuXHRcdFx0XHRcdFx0XHRcdFx0IGhpZ2hseSB1bmFwcGVhbGluZyB1bHRyYS1ib2xkaW5nIGVmZmVjdC4gVGhlcmUncyBubyB3YXkgdG8gcmVtZWR5IHRoaXMgdGhyb3VnaG91dCBhIHR3ZWVuLCBidXQgZHJvcHBpbmcgdGhlXG5cdFx0XHRcdFx0XHRcdFx0XHQgdmFsdWUgYWx0b2dldGhlciAod2hlbiBvcGFjaXR5IGhpdHMgMSkgYXQgbGVhc3RzIGVuc3VyZXMgdGhhdCB0aGUgZ2xpdGNoIGlzIGdvbmUgcG9zdC10d2VlbmluZy4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChwYXJzZUZsb2F0KHByb3BlcnR5VmFsdWUpID49IDEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBBcyBwZXIgdGhlIGZpbHRlciBwcm9wZXJ0eSdzIHNwZWMsIGNvbnZlcnQgdGhlIGRlY2ltYWwgdmFsdWUgdG8gYSB3aG9sZSBudW1iZXIgYW5kIHdyYXAgdGhlIHZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJhbHBoYShvcGFjaXR5PVwiICsgcGFyc2VJbnQocGFyc2VGbG9hdChwcm9wZXJ0eVZhbHVlKSAqIDEwMCwgMTApICsgXCIpXCI7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0LyogV2l0aCBhbGwgb3RoZXIgYnJvd3NlcnMsIG5vcm1hbGl6YXRpb24gaXMgbm90IHJlcXVpcmVkOyByZXR1cm4gdGhlIHNhbWUgdmFsdWVzIHRoYXQgd2VyZSBwYXNzZWQgaW4uICovXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHRjYXNlIFwibmFtZVwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIFwib3BhY2l0eVwiO1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJleHRyYWN0XCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcHJvcGVydHlWYWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRjYXNlIFwiaW5qZWN0XCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcHJvcGVydHlWYWx1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdCBCYXRjaGVkIFJlZ2lzdHJhdGlvbnNcblx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdC8qIE5vdGU6IEJhdGNoZWQgbm9ybWFsaXphdGlvbnMgZXh0ZW5kIHRoZSBDU1MuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZCBvYmplY3QuICovXG5cdFx0XHRcdHJlZ2lzdGVyOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdCBUcmFuc2Zvcm1zXG5cdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0LyogVHJhbnNmb3JtcyBhcmUgdGhlIHN1YnByb3BlcnRpZXMgY29udGFpbmVkIGJ5IHRoZSBDU1MgXCJ0cmFuc2Zvcm1cIiBwcm9wZXJ0eS4gVHJhbnNmb3JtcyBtdXN0IHVuZGVyZ28gbm9ybWFsaXphdGlvblxuXHRcdFx0XHRcdCBzbyB0aGF0IHRoZXkgY2FuIGJlIHJlZmVyZW5jZWQgaW4gYSBwcm9wZXJ0aWVzIG1hcCBieSB0aGVpciBpbmRpdmlkdWFsIG5hbWVzLiAqL1xuXHRcdFx0XHRcdC8qIE5vdGU6IFdoZW4gdHJhbnNmb3JtcyBhcmUgXCJzZXRcIiwgdGhleSBhcmUgYWN0dWFsbHkgYXNzaWduZWQgdG8gYSBwZXItZWxlbWVudCB0cmFuc2Zvcm1DYWNoZS4gV2hlbiBhbGwgdHJhbnNmb3JtXG5cdFx0XHRcdFx0IHNldHRpbmcgaXMgY29tcGxldGUgY29tcGxldGUsIENTUy5mbHVzaFRyYW5zZm9ybUNhY2hlKCkgbXVzdCBiZSBtYW51YWxseSBjYWxsZWQgdG8gZmx1c2ggdGhlIHZhbHVlcyB0byB0aGUgRE9NLlxuXHRcdFx0XHRcdCBUcmFuc2Zvcm0gc2V0dGluZyBpcyBiYXRjaGVkIGluIHRoaXMgd2F5IHRvIGltcHJvdmUgcGVyZm9ybWFuY2U6IHRoZSB0cmFuc2Zvcm0gc3R5bGUgb25seSBuZWVkcyB0byBiZSB1cGRhdGVkXG5cdFx0XHRcdFx0IG9uY2Ugd2hlbiBtdWx0aXBsZSB0cmFuc2Zvcm0gc3VicHJvcGVydGllcyBhcmUgYmVpbmcgYW5pbWF0ZWQgc2ltdWx0YW5lb3VzbHkuICovXG5cdFx0XHRcdFx0LyogTm90ZTogSUU5IGFuZCBBbmRyb2lkIEdpbmdlcmJyZWFkIGhhdmUgc3VwcG9ydCBmb3IgMkQgLS0gYnV0IG5vdCAzRCAtLSB0cmFuc2Zvcm1zLiBTaW5jZSBhbmltYXRpbmcgdW5zdXBwb3J0ZWRcblx0XHRcdFx0XHQgdHJhbnNmb3JtIHByb3BlcnRpZXMgcmVzdWx0cyBpbiB0aGUgYnJvd3NlciBpZ25vcmluZyB0aGUgKmVudGlyZSogdHJhbnNmb3JtIHN0cmluZywgd2UgcHJldmVudCB0aGVzZSAzRCB2YWx1ZXNcblx0XHRcdFx0XHQgZnJvbSBiZWluZyBub3JtYWxpemVkIGZvciB0aGVzZSBicm93c2VycyBzbyB0aGF0IHR3ZWVuaW5nIHNraXBzIHRoZXNlIHByb3BlcnRpZXMgYWx0b2dldGhlclxuXHRcdFx0XHRcdCAoc2luY2UgaXQgd2lsbCBpZ25vcmUgdGhlbSBhcyBiZWluZyB1bnN1cHBvcnRlZCBieSB0aGUgYnJvd3Nlci4pICovXG5cdFx0XHRcdFx0aWYgKCghSUUgfHwgSUUgPiA5KSAmJiAhVmVsb2NpdHkuU3RhdGUuaXNHaW5nZXJicmVhZCkge1xuXHRcdFx0XHRcdFx0LyogTm90ZTogU2luY2UgdGhlIHN0YW5kYWxvbmUgQ1NTIFwicGVyc3BlY3RpdmVcIiBwcm9wZXJ0eSBhbmQgdGhlIENTUyB0cmFuc2Zvcm0gXCJwZXJzcGVjdGl2ZVwiIHN1YnByb3BlcnR5XG5cdFx0XHRcdFx0XHQgc2hhcmUgdGhlIHNhbWUgbmFtZSwgdGhlIGxhdHRlciBpcyBnaXZlbiBhIHVuaXF1ZSB0b2tlbiB3aXRoaW4gVmVsb2NpdHk6IFwidHJhbnNmb3JtUGVyc3BlY3RpdmVcIi4gKi9cblx0XHRcdFx0XHRcdENTUy5MaXN0cy50cmFuc2Zvcm1zQmFzZSA9IENTUy5MaXN0cy50cmFuc2Zvcm1zQmFzZS5jb25jYXQoQ1NTLkxpc3RzLnRyYW5zZm9ybXMzRCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBDU1MuTGlzdHMudHJhbnNmb3Jtc0Jhc2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdC8qIFdyYXAgdGhlIGR5bmFtaWNhbGx5IGdlbmVyYXRlZCBub3JtYWxpemF0aW9uIGZ1bmN0aW9uIGluIGEgbmV3IHNjb3BlIHNvIHRoYXQgdHJhbnNmb3JtTmFtZSdzIHZhbHVlIGlzXG5cdFx0XHRcdFx0XHQgcGFpcmVkIHdpdGggaXRzIHJlc3BlY3RpdmUgZnVuY3Rpb24uIChPdGhlcndpc2UsIGFsbCBmdW5jdGlvbnMgd291bGQgdGFrZSB0aGUgZmluYWwgZm9yIGxvb3AncyB0cmFuc2Zvcm1OYW1lLikgKi9cblx0XHRcdFx0XHRcdChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRyYW5zZm9ybU5hbWUgPSBDU1MuTGlzdHMudHJhbnNmb3Jtc0Jhc2VbaV07XG5cblx0XHRcdFx0XHRcdFx0Q1NTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbdHJhbnNmb3JtTmFtZV0gPSBmdW5jdGlvbih0eXBlLCBlbGVtZW50LCBwcm9wZXJ0eVZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBUaGUgbm9ybWFsaXplZCBwcm9wZXJ0eSBuYW1lIGlzIHRoZSBwYXJlbnQgXCJ0cmFuc2Zvcm1cIiBwcm9wZXJ0eSAtLSB0aGUgcHJvcGVydHkgdGhhdCBpcyBhY3R1YWxseSBzZXQgaW4gQ1NTLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBcIm5hbWVcIjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIFwidHJhbnNmb3JtXCI7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIFRyYW5zZm9ybSB2YWx1ZXMgYXJlIGNhY2hlZCBvbnRvIGEgcGVyLWVsZW1lbnQgdHJhbnNmb3JtQ2FjaGUgb2JqZWN0LiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBcImV4dHJhY3RcIjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogSWYgdGhpcyB0cmFuc2Zvcm0gaGFzIHlldCB0byBiZSBhc3NpZ25lZCBhIHZhbHVlLCByZXR1cm4gaXRzIG51bGwgdmFsdWUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChEYXRhKGVsZW1lbnQpID09PSB1bmRlZmluZWQgfHwgRGF0YShlbGVtZW50KS50cmFuc2Zvcm1DYWNoZVt0cmFuc2Zvcm1OYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyogU2NhbGUgQ1NTLkxpc3RzLnRyYW5zZm9ybXNCYXNlIGRlZmF1bHQgdG8gMSB3aGVyZWFzIGFsbCBvdGhlciB0cmFuc2Zvcm0gcHJvcGVydGllcyBkZWZhdWx0IHRvIDAuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIC9ec2NhbGUvaS50ZXN0KHRyYW5zZm9ybU5hbWUpID8gMSA6IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyogV2hlbiB0cmFuc2Zvcm0gdmFsdWVzIGFyZSBzZXQsIHRoZXkgYXJlIHdyYXBwZWQgaW4gcGFyZW50aGVzZXMgYXMgcGVyIHRoZSBDU1Mgc3BlYy5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgVGh1cywgd2hlbiBleHRyYWN0aW5nIHRoZWlyIHZhbHVlcyAoZm9yIHR3ZWVuIGNhbGN1bGF0aW9ucyksIHdlIHN0cmlwIG9mZiB0aGUgcGFyZW50aGVzZXMuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIERhdGEoZWxlbWVudCkudHJhbnNmb3JtQ2FjaGVbdHJhbnNmb3JtTmFtZV0ucmVwbGFjZSgvWygpXS9nLCBcIlwiKTtcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJpbmplY3RcIjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIGludmFsaWQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBJZiBhbiBpbmRpdmlkdWFsIHRyYW5zZm9ybSBwcm9wZXJ0eSBjb250YWlucyBhbiB1bnN1cHBvcnRlZCB1bml0IHR5cGUsIHRoZSBicm93c2VyIGlnbm9yZXMgdGhlICplbnRpcmUqIHRyYW5zZm9ybSBwcm9wZXJ0eS5cblx0XHRcdFx0XHRcdFx0XHRcdFx0IFRodXMsIHByb3RlY3QgdXNlcnMgZnJvbSB0aGVtc2VsdmVzIGJ5IHNraXBwaW5nIHNldHRpbmcgZm9yIHRyYW5zZm9ybSB2YWx1ZXMgc3VwcGxpZWQgd2l0aCBpbnZhbGlkIHVuaXQgdHlwZXMuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIFN3aXRjaCBvbiB0aGUgYmFzZSB0cmFuc2Zvcm0gdHlwZTsgaWdub3JlIHRoZSBheGlzIGJ5IHJlbW92aW5nIHRoZSBsYXN0IGxldHRlciBmcm9tIHRoZSB0cmFuc2Zvcm0ncyBuYW1lLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzd2l0Y2ggKHRyYW5zZm9ybU5hbWUuc3Vic3RyKDAsIHRyYW5zZm9ybU5hbWUubGVuZ3RoIC0gMSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBXaGl0ZWxpc3QgdW5pdCB0eXBlcyBmb3IgZWFjaCB0cmFuc2Zvcm0uICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBcInRyYW5zbGF0ZVwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aW52YWxpZCA9ICEvKCV8cHh8ZW18cmVtfHZ3fHZofFxcZCkkL2kudGVzdChwcm9wZXJ0eVZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyogU2luY2UgYW4gYXhpcy1mcmVlIFwic2NhbGVcIiBwcm9wZXJ0eSBpcyBzdXBwb3J0ZWQgYXMgd2VsbCwgYSBsaXR0bGUgaGFjayBpcyB1c2VkIGhlcmUgdG8gZGV0ZWN0IGl0IGJ5IGNob3BwaW5nIG9mZiBpdHMgbGFzdCBsZXR0ZXIuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBcInNjYWxcIjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFwic2NhbGVcIjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIENocm9tZSBvbiBBbmRyb2lkIGhhcyBhIGJ1ZyBpbiB3aGljaCBzY2FsZWQgZWxlbWVudHMgYmx1ciBpZiB0aGVpciBpbml0aWFsIHNjYWxlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgdmFsdWUgaXMgYmVsb3cgMSAod2hpY2ggY2FuIGhhcHBlbiB3aXRoIGZvcmNlZmVlZGluZykuIFRodXMsIHdlIGRldGVjdCBhIHlldC11bnNldCBzY2FsZSBwcm9wZXJ0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0IGFuZCBlbnN1cmUgdGhhdCBpdHMgZmlyc3QgdmFsdWUgaXMgYWx3YXlzIDEuIE1vcmUgaW5mbzogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDQxNzg5MC9jc3MzLWFuaW1hdGlvbnMtd2l0aC10cmFuc2Zvcm0tY2F1c2VzLWJsdXJyZWQtZWxlbWVudHMtb24td2Via2l0LzEwNDE3OTYyIzEwNDE3OTYyICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoVmVsb2NpdHkuU3RhdGUuaXNBbmRyb2lkICYmIERhdGEoZWxlbWVudCkudHJhbnNmb3JtQ2FjaGVbdHJhbnNmb3JtTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0eVZhbHVlIDwgMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eVZhbHVlID0gMTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aW52YWxpZCA9ICEvKFxcZCkkL2kudGVzdChwcm9wZXJ0eVZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJza2V3XCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpbnZhbGlkID0gIS8oZGVnfFxcZCkkL2kudGVzdChwcm9wZXJ0eVZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJyb3RhdGVcIjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGludmFsaWQgPSAhLyhkZWd8XFxkKSQvaS50ZXN0KHByb3BlcnR5VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIWludmFsaWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBBcyBwZXIgdGhlIENTUyBzcGVjLCB3cmFwIHRoZSB2YWx1ZSBpbiBwYXJlbnRoZXNlcy4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHREYXRhKGVsZW1lbnQpLnRyYW5zZm9ybUNhY2hlW3RyYW5zZm9ybU5hbWVdID0gXCIoXCIgKyBwcm9wZXJ0eVZhbHVlICsgXCIpXCI7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBBbHRob3VnaCB0aGUgdmFsdWUgaXMgc2V0IG9uIHRoZSB0cmFuc2Zvcm1DYWNoZSBvYmplY3QsIHJldHVybiB0aGUgbmV3bHktdXBkYXRlZCB2YWx1ZSBmb3IgdGhlIGNhbGxpbmcgY29kZSB0byBwcm9jZXNzIGFzIG5vcm1hbC4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIERhdGEoZWxlbWVudCkudHJhbnNmb3JtQ2FjaGVbdHJhbnNmb3JtTmFtZV07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fSkoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKioqKioqKioqKioqKlxuXHRcdFx0XHRcdCBDb2xvcnNcblx0XHRcdFx0XHQgKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdC8qIFNpbmNlIFZlbG9jaXR5IG9ubHkgYW5pbWF0ZXMgYSBzaW5nbGUgbnVtZXJpYyB2YWx1ZSBwZXIgcHJvcGVydHksIGNvbG9yIGFuaW1hdGlvbiBpcyBhY2hpZXZlZCBieSBob29raW5nIHRoZSBpbmRpdmlkdWFsIFJHQkEgY29tcG9uZW50cyBvZiBDU1MgY29sb3IgcHJvcGVydGllcy5cblx0XHRcdFx0XHQgQWNjb3JkaW5nbHksIGNvbG9yIHZhbHVlcyBtdXN0IGJlIG5vcm1hbGl6ZWQgKGUuZy4gXCIjZmYwMDAwXCIsIFwicmVkXCIsIGFuZCBcInJnYigyNTUsIDAsIDApXCIgPT0+IFwiMjU1IDAgMCAxXCIpIHNvIHRoYXQgdGhlaXIgY29tcG9uZW50cyBjYW4gYmUgaW5qZWN0ZWQvZXh0cmFjdGVkIGJ5IENTUy5Ib29rcyBsb2dpYy4gKi9cblx0XHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IENTUy5MaXN0cy5jb2xvcnMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdC8qIFdyYXAgdGhlIGR5bmFtaWNhbGx5IGdlbmVyYXRlZCBub3JtYWxpemF0aW9uIGZ1bmN0aW9uIGluIGEgbmV3IHNjb3BlIHNvIHRoYXQgY29sb3JOYW1lJ3MgdmFsdWUgaXMgcGFpcmVkIHdpdGggaXRzIHJlc3BlY3RpdmUgZnVuY3Rpb24uXG5cdFx0XHRcdFx0XHQgKE90aGVyd2lzZSwgYWxsIGZ1bmN0aW9ucyB3b3VsZCB0YWtlIHRoZSBmaW5hbCBmb3IgbG9vcCdzIGNvbG9yTmFtZS4pICovXG5cdFx0XHRcdFx0XHQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBjb2xvck5hbWUgPSBDU1MuTGlzdHMuY29sb3JzW2pdO1xuXG5cdFx0XHRcdFx0XHRcdC8qIE5vdGU6IEluIElFPD04LCB3aGljaCBzdXBwb3J0IHJnYiBidXQgbm90IHJnYmEsIGNvbG9yIHByb3BlcnRpZXMgYXJlIHJldmVydGVkIHRvIHJnYiBieSBzdHJpcHBpbmcgb2ZmIHRoZSBhbHBoYSBjb21wb25lbnQuICovXG5cdFx0XHRcdFx0XHRcdENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW2NvbG9yTmFtZV0gPSBmdW5jdGlvbih0eXBlLCBlbGVtZW50LCBwcm9wZXJ0eVZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFwibmFtZVwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gY29sb3JOYW1lO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBDb252ZXJ0IGFsbCBjb2xvciB2YWx1ZXMgaW50byB0aGUgcmdiIGZvcm1hdC4gKE9sZCBJRSBjYW4gcmV0dXJuIGhleCB2YWx1ZXMgYW5kIGNvbG9yIG5hbWVzIGluc3RlYWQgb2YgcmdiL3JnYmEuKSAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBcImV4dHJhY3RcIjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIGV4dHJhY3RlZDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBJZiB0aGUgY29sb3IgaXMgYWxyZWFkeSBpbiBpdHMgaG9va2FibGUgZm9ybSAoZS5nLiBcIjI1NSAyNTUgMjU1IDFcIikgZHVlIHRvIGhhdmluZyBiZWVuIHByZXZpb3VzbHkgZXh0cmFjdGVkLCBza2lwIGV4dHJhY3Rpb24uICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChDU1MuUmVnRXgud3JhcHBlZFZhbHVlQWxyZWFkeUV4dHJhY3RlZC50ZXN0KHByb3BlcnR5VmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZXh0cmFjdGVkID0gcHJvcGVydHlWYWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgY29udmVydGVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb2xvck5hbWVzID0ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJsYWNrOiBcInJnYigwLCAwLCAwKVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJsdWU6IFwicmdiKDAsIDAsIDI1NSlcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRncmF5OiBcInJnYigxMjgsIDEyOCwgMTI4KVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGdyZWVuOiBcInJnYigwLCAxMjgsIDApXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVkOiBcInJnYigyNTUsIDAsIDApXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0d2hpdGU6IFwicmdiKDI1NSwgMjU1LCAyNTUpXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIENvbnZlcnQgY29sb3IgbmFtZXMgdG8gcmdiLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICgvXltBLXpdKyQvaS50ZXN0KHByb3BlcnR5VmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoY29sb3JOYW1lc1twcm9wZXJ0eVZhbHVlXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlZCA9IGNvbG9yTmFtZXNbcHJvcGVydHlWYWx1ZV07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBJZiBhbiB1bm1hdGNoZWQgY29sb3IgbmFtZSBpcyBwcm92aWRlZCwgZGVmYXVsdCB0byBibGFjay4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29udmVydGVkID0gY29sb3JOYW1lcy5ibGFjaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIENvbnZlcnQgaGV4IHZhbHVlcyB0byByZ2IuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChDU1MuUmVnRXguaXNIZXgudGVzdChwcm9wZXJ0eVZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29udmVydGVkID0gXCJyZ2IoXCIgKyBDU1MuVmFsdWVzLmhleFRvUmdiKHByb3BlcnR5VmFsdWUpLmpvaW4oXCIgXCIpICsgXCIpXCI7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBJZiB0aGUgcHJvdmlkZWQgY29sb3IgZG9lc24ndCBtYXRjaCBhbnkgb2YgdGhlIGFjY2VwdGVkIGNvbG9yIGZvcm1hdHMsIGRlZmF1bHQgdG8gYmxhY2suICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICghKC9ecmdiYT9cXCgvaS50ZXN0KHByb3BlcnR5VmFsdWUpKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29udmVydGVkID0gY29sb3JOYW1lcy5ibGFjaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBSZW1vdmUgdGhlIHN1cnJvdW5kaW5nIFwicmdiL3JnYmEoKVwiIHN0cmluZyB0aGVuIHJlcGxhY2UgY29tbWFzIHdpdGggc3BhY2VzIGFuZCBzdHJpcFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCByZXBlYXRlZCBzcGFjZXMgKGluIGNhc2UgdGhlIHZhbHVlIGluY2x1ZGVkIHNwYWNlcyB0byBiZWdpbiB3aXRoKS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRleHRyYWN0ZWQgPSAoY29udmVydGVkIHx8IHByb3BlcnR5VmFsdWUpLnRvU3RyaW5nKCkubWF0Y2goQ1NTLlJlZ0V4LnZhbHVlVW53cmFwKVsxXS5yZXBsYWNlKC8sKFxccyspPy9nLCBcIiBcIik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBTbyBsb25nIGFzIHRoaXMgaXNuJ3QgPD1JRTgsIGFkZCBhIGZvdXJ0aCAoYWxwaGEpIGNvbXBvbmVudCBpZiBpdCdzIG1pc3NpbmcgYW5kIGRlZmF1bHQgaXQgdG8gMSAodmlzaWJsZSkuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICgoIUlFIHx8IElFID4gOCkgJiYgZXh0cmFjdGVkLnNwbGl0KFwiIFwiKS5sZW5ndGggPT09IDMpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRleHRyYWN0ZWQgKz0gXCIgMVwiO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGV4dHJhY3RlZDtcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJpbmplY3RcIjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogSWYgd2UgaGF2ZSBhIHBhdHRlcm4gdGhlbiBpdCBtaWdodCBhbHJlYWR5IGhhdmUgdGhlIHJpZ2h0IHZhbHVlcyAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoL15yZ2IvLnRlc3QocHJvcGVydHlWYWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcHJvcGVydHlWYWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIElmIHRoaXMgaXMgSUU8PTggYW5kIGFuIGFscGhhIGNvbXBvbmVudCBleGlzdHMsIHN0cmlwIGl0IG9mZi4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKElFIDw9IDgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAocHJvcGVydHlWYWx1ZS5zcGxpdChcIiBcIikubGVuZ3RoID09PSA0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eVZhbHVlID0gcHJvcGVydHlWYWx1ZS5zcGxpdCgvXFxzKy8pLnNsaWNlKDAsIDMpLmpvaW4oXCIgXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBPdGhlcndpc2UsIGFkZCBhIGZvdXJ0aCAoYWxwaGEpIGNvbXBvbmVudCBpZiBpdCdzIG1pc3NpbmcgYW5kIGRlZmF1bHQgaXQgdG8gMSAodmlzaWJsZSkuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAocHJvcGVydHlWYWx1ZS5zcGxpdChcIiBcIikubGVuZ3RoID09PSAzKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcGVydHlWYWx1ZSArPSBcIiAxXCI7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBSZS1pbnNlcnQgdGhlIGJyb3dzZXItYXBwcm9wcmlhdGUgd3JhcHBlcihcInJnYi9yZ2JhKClcIiksIGluc2VydCBjb21tYXMsIGFuZCBzdHJpcCBvZmYgZGVjaW1hbCB1bml0c1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQgb24gYWxsIHZhbHVlcyBidXQgdGhlIGZvdXJ0aCAoUiwgRywgYW5kIEIgb25seSBhY2NlcHQgd2hvbGUgbnVtYmVycykuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiAoSUUgPD0gOCA/IFwicmdiXCIgOiBcInJnYmFcIikgKyBcIihcIiArIHByb3BlcnR5VmFsdWUucmVwbGFjZSgvXFxzKy9nLCBcIixcIikucmVwbGFjZSgvXFwuKFxcZCkrKD89LCkvZywgXCJcIikgKyBcIilcIjtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9KSgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qKioqKioqKioqKioqKlxuXHRcdFx0XHRcdCBEaW1lbnNpb25zXG5cdFx0XHRcdFx0ICoqKioqKioqKioqKioqL1xuXHRcdFx0XHRcdGZ1bmN0aW9uIGF1Z21lbnREaW1lbnNpb24obmFtZSwgZWxlbWVudCwgd2FudElubmVyKSB7XG5cdFx0XHRcdFx0XHR2YXIgaXNCb3JkZXJCb3ggPSBDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcImJveFNpemluZ1wiKS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoaXNCb3JkZXJCb3ggPT09ICh3YW50SW5uZXIgfHwgZmFsc2UpKSB7XG5cdFx0XHRcdFx0XHRcdC8qIGluIGJveC1zaXppbmcgbW9kZSwgdGhlIENTUyB3aWR0aCAvIGhlaWdodCBhY2Nlc3NvcnMgYWxyZWFkeSBnaXZlIHRoZSBvdXRlcldpZHRoIC8gb3V0ZXJIZWlnaHQuICovXG5cdFx0XHRcdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRhdWdtZW50ID0gMCxcblx0XHRcdFx0XHRcdFx0XHRcdHNpZGVzID0gbmFtZSA9PT0gXCJ3aWR0aFwiID8gW1wiTGVmdFwiLCBcIlJpZ2h0XCJdIDogW1wiVG9wXCIsIFwiQm90dG9tXCJdLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZmllbGRzID0gW1wicGFkZGluZ1wiICsgc2lkZXNbMF0sIFwicGFkZGluZ1wiICsgc2lkZXNbMV0sIFwiYm9yZGVyXCIgKyBzaWRlc1swXSArIFwiV2lkdGhcIiwgXCJib3JkZXJcIiArIHNpZGVzWzFdICsgXCJXaWR0aFwiXTtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBwYXJzZUZsb2F0KENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIGZpZWxkc1tpXSkpO1xuXHRcdFx0XHRcdFx0XHRcdGlmICghaXNOYU4odmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhdWdtZW50ICs9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gd2FudElubmVyID8gLWF1Z21lbnQgOiBhdWdtZW50O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZ1bmN0aW9uIGdldERpbWVuc2lvbihuYW1lLCB3YW50SW5uZXIpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbih0eXBlLCBlbGVtZW50LCBwcm9wZXJ0eVZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJuYW1lXCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbmFtZTtcblx0XHRcdFx0XHRcdFx0XHRjYXNlIFwiZXh0cmFjdFwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhcnNlRmxvYXQocHJvcGVydHlWYWx1ZSkgKyBhdWdtZW50RGltZW5zaW9uKG5hbWUsIGVsZW1lbnQsIHdhbnRJbm5lcik7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBcImluamVjdFwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIChwYXJzZUZsb2F0KHByb3BlcnR5VmFsdWUpIC0gYXVnbWVudERpbWVuc2lvbihuYW1lLCBlbGVtZW50LCB3YW50SW5uZXIpKSArIFwicHhcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Q1NTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWQuaW5uZXJXaWR0aCA9IGdldERpbWVuc2lvbihcIndpZHRoXCIsIHRydWUpO1xuXHRcdFx0XHRcdENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkLmlubmVySGVpZ2h0ID0gZ2V0RGltZW5zaW9uKFwiaGVpZ2h0XCIsIHRydWUpO1xuXHRcdFx0XHRcdENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkLm91dGVyV2lkdGggPSBnZXREaW1lbnNpb24oXCJ3aWR0aFwiKTtcblx0XHRcdFx0XHRDU1MuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZC5vdXRlckhlaWdodCA9IGdldERpbWVuc2lvbihcImhlaWdodFwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdCBDU1MgUHJvcGVydHkgTmFtZXNcblx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdE5hbWVzOiB7XG5cdFx0XHRcdC8qIENhbWVsY2FzZSBhIHByb3BlcnR5IG5hbWUgaW50byBpdHMgSmF2YVNjcmlwdCBub3RhdGlvbiAoZS5nLiBcImJhY2tncm91bmQtY29sb3JcIiA9PT4gXCJiYWNrZ3JvdW5kQ29sb3JcIikuXG5cdFx0XHRcdCBDYW1lbGNhc2luZyBpcyB1c2VkIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0eSBuYW1lcyBiZXR3ZWVuIGFuZCBhY3Jvc3MgY2FsbHMuICovXG5cdFx0XHRcdGNhbWVsQ2FzZTogZnVuY3Rpb24ocHJvcGVydHkpIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvcGVydHkucmVwbGFjZSgvLShcXHcpL2csIGZ1bmN0aW9uKG1hdGNoLCBzdWJNYXRjaCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHN1Yk1hdGNoLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8qIEZvciBTVkcgZWxlbWVudHMsIHNvbWUgcHJvcGVydGllcyAobmFtZWx5LCBkaW1lbnNpb25hbCBvbmVzKSBhcmUgR0VUL1NFVCB2aWEgdGhlIGVsZW1lbnQncyBIVE1MIGF0dHJpYnV0ZXMgKGluc3RlYWQgb2YgdmlhIENTUyBzdHlsZXMpLiAqL1xuXHRcdFx0XHRTVkdBdHRyaWJ1dGU6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG5cdFx0XHRcdFx0dmFyIFNWR0F0dHJpYnV0ZXMgPSBcIndpZHRofGhlaWdodHx4fHl8Y3h8Y3l8cnxyeHxyeXx4MXx4Mnx5MXx5MlwiO1xuXG5cdFx0XHRcdFx0LyogQ2VydGFpbiBicm93c2VycyByZXF1aXJlIGFuIFNWRyB0cmFuc2Zvcm0gdG8gYmUgYXBwbGllZCBhcyBhbiBhdHRyaWJ1dGUuIChPdGhlcndpc2UsIGFwcGxpY2F0aW9uIHZpYSBDU1MgaXMgcHJlZmVyYWJsZSBkdWUgdG8gM0Qgc3VwcG9ydC4pICovXG5cdFx0XHRcdFx0aWYgKElFIHx8IChWZWxvY2l0eS5TdGF0ZS5pc0FuZHJvaWQgJiYgIVZlbG9jaXR5LlN0YXRlLmlzQ2hyb21lKSkge1xuXHRcdFx0XHRcdFx0U1ZHQXR0cmlidXRlcyArPSBcInx0cmFuc2Zvcm1cIjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFJlZ0V4cChcIl4oXCIgKyBTVkdBdHRyaWJ1dGVzICsgXCIpJFwiLCBcImlcIikudGVzdChwcm9wZXJ0eSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8qIERldGVybWluZSB3aGV0aGVyIGEgcHJvcGVydHkgc2hvdWxkIGJlIHNldCB3aXRoIGEgdmVuZG9yIHByZWZpeC4gKi9cblx0XHRcdFx0LyogSWYgYSBwcmVmaXhlZCB2ZXJzaW9uIG9mIHRoZSBwcm9wZXJ0eSBleGlzdHMsIHJldHVybiBpdC4gT3RoZXJ3aXNlLCByZXR1cm4gdGhlIG9yaWdpbmFsIHByb3BlcnR5IG5hbWUuXG5cdFx0XHRcdCBJZiB0aGUgcHJvcGVydHkgaXMgbm90IGF0IGFsbCBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIsIHJldHVybiBhIGZhbHNlIGZsYWcuICovXG5cdFx0XHRcdHByZWZpeENoZWNrOiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuXHRcdFx0XHRcdC8qIElmIHRoaXMgcHJvcGVydHkgaGFzIGFscmVhZHkgYmVlbiBjaGVja2VkLCByZXR1cm4gdGhlIGNhY2hlZCB2YWx1ZS4gKi9cblx0XHRcdFx0XHRpZiAoVmVsb2NpdHkuU3RhdGUucHJlZml4TWF0Y2hlc1twcm9wZXJ0eV0pIHtcblx0XHRcdFx0XHRcdHJldHVybiBbVmVsb2NpdHkuU3RhdGUucHJlZml4TWF0Y2hlc1twcm9wZXJ0eV0sIHRydWVdO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2YXIgdmVuZG9ycyA9IFtcIlwiLCBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIsIFwiT1wiXTtcblxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIHZlbmRvcnNMZW5ndGggPSB2ZW5kb3JzLmxlbmd0aDsgaSA8IHZlbmRvcnNMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHR2YXIgcHJvcGVydHlQcmVmaXhlZDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoaSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5UHJlZml4ZWQgPSBwcm9wZXJ0eTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHQvKiBDYXBpdGFsaXplIHRoZSBmaXJzdCBsZXR0ZXIgb2YgdGhlIHByb3BlcnR5IHRvIGNvbmZvcm0gdG8gSmF2YVNjcmlwdCB2ZW5kb3IgcHJlZml4IG5vdGF0aW9uIChlLmcuIHdlYmtpdEZpbHRlcikuICovXG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydHlQcmVmaXhlZCA9IHZlbmRvcnNbaV0gKyBwcm9wZXJ0eS5yZXBsYWNlKC9eXFx3LywgZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBtYXRjaC50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0LyogQ2hlY2sgaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhpcyBwcm9wZXJ0eSBhcyBwcmVmaXhlZC4gKi9cblx0XHRcdFx0XHRcdFx0aWYgKFR5cGUuaXNTdHJpbmcoVmVsb2NpdHkuU3RhdGUucHJlZml4RWxlbWVudC5zdHlsZVtwcm9wZXJ0eVByZWZpeGVkXSkpIHtcblx0XHRcdFx0XHRcdFx0XHQvKiBDYWNoZSB0aGUgbWF0Y2guICovXG5cdFx0XHRcdFx0XHRcdFx0VmVsb2NpdHkuU3RhdGUucHJlZml4TWF0Y2hlc1twcm9wZXJ0eV0gPSBwcm9wZXJ0eVByZWZpeGVkO1xuXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIFtwcm9wZXJ0eVByZWZpeGVkLCB0cnVlXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBJZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhpcyBwcm9wZXJ0eSBpbiBhbnkgZm9ybSwgaW5jbHVkZSBhIGZhbHNlIGZsYWcgc28gdGhhdCB0aGUgY2FsbGVyIGNhbiBkZWNpZGUgaG93IHRvIHByb2NlZWQuICovXG5cdFx0XHRcdFx0XHRyZXR1cm4gW3Byb3BlcnR5LCBmYWxzZV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0IENTUyBQcm9wZXJ0eSBWYWx1ZXNcblx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFZhbHVlczoge1xuXHRcdFx0XHQvKiBIZXggdG8gUkdCIGNvbnZlcnNpb24uIENvcHlyaWdodCBUaW0gRG93bjogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NjIzODM4L3JnYi10by1oZXgtYW5kLWhleC10by1yZ2IgKi9cblx0XHRcdFx0aGV4VG9SZ2I6IGZ1bmN0aW9uKGhleCkge1xuXHRcdFx0XHRcdHZhciBzaG9ydGZvcm1SZWdleCA9IC9eIz8oW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkkL2ksXG5cdFx0XHRcdFx0XHRcdGxvbmdmb3JtUmVnZXggPSAvXiM/KFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pJC9pLFxuXHRcdFx0XHRcdFx0XHRyZ2JQYXJ0cztcblxuXHRcdFx0XHRcdGhleCA9IGhleC5yZXBsYWNlKHNob3J0Zm9ybVJlZ2V4LCBmdW5jdGlvbihtLCByLCBnLCBiKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gciArIHIgKyBnICsgZyArIGIgKyBiO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0cmdiUGFydHMgPSBsb25nZm9ybVJlZ2V4LmV4ZWMoaGV4KTtcblxuXHRcdFx0XHRcdHJldHVybiByZ2JQYXJ0cyA/IFtwYXJzZUludChyZ2JQYXJ0c1sxXSwgMTYpLCBwYXJzZUludChyZ2JQYXJ0c1syXSwgMTYpLCBwYXJzZUludChyZ2JQYXJ0c1szXSwgMTYpXSA6IFswLCAwLCAwXTtcblx0XHRcdFx0fSxcblx0XHRcdFx0aXNDU1NOdWxsVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdFx0LyogVGhlIGJyb3dzZXIgZGVmYXVsdHMgQ1NTIHZhbHVlcyB0aGF0IGhhdmUgbm90IGJlZW4gc2V0IHRvIGVpdGhlciAwIG9yIG9uZSBvZiBzZXZlcmFsIHBvc3NpYmxlIG51bGwtdmFsdWUgc3RyaW5ncy5cblx0XHRcdFx0XHQgVGh1cywgd2UgY2hlY2sgZm9yIGJvdGggZmFsc2luZXNzIGFuZCB0aGVzZSBzcGVjaWFsIHN0cmluZ3MuICovXG5cdFx0XHRcdFx0LyogTnVsbC12YWx1ZSBjaGVja2luZyBpcyBwZXJmb3JtZWQgdG8gZGVmYXVsdCB0aGUgc3BlY2lhbCBzdHJpbmdzIHRvIDAgKGZvciB0aGUgc2FrZSBvZiB0d2VlbmluZykgb3IgdGhlaXIgaG9va1xuXHRcdFx0XHRcdCB0ZW1wbGF0ZXMgYXMgZGVmaW5lZCBhcyBDU1MuSG9va3MgKGZvciB0aGUgc2FrZSBvZiBob29rIGluamVjdGlvbi9leHRyYWN0aW9uKS4gKi9cblx0XHRcdFx0XHQvKiBOb3RlOiBDaHJvbWUgcmV0dXJucyBcInJnYmEoMCwgMCwgMCwgMClcIiBmb3IgYW4gdW5kZWZpbmVkIGNvbG9yIHdoZXJlYXMgSUUgcmV0dXJucyBcInRyYW5zcGFyZW50XCIuICovXG5cdFx0XHRcdFx0cmV0dXJuICghdmFsdWUgfHwgL14obm9uZXxhdXRvfHRyYW5zcGFyZW50fChyZ2JhXFwoMCwgPzAsID8wLCA/MFxcKSkpJC9pLnRlc3QodmFsdWUpKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0LyogUmV0cmlldmUgYSBwcm9wZXJ0eSdzIGRlZmF1bHQgdW5pdCB0eXBlLiBVc2VkIGZvciBhc3NpZ25pbmcgYSB1bml0IHR5cGUgd2hlbiBvbmUgaXMgbm90IHN1cHBsaWVkIGJ5IHRoZSB1c2VyLiAqL1xuXHRcdFx0XHRnZXRVbml0VHlwZTogZnVuY3Rpb24ocHJvcGVydHkpIHtcblx0XHRcdFx0XHRpZiAoL14ocm90YXRlfHNrZXcpL2kudGVzdChwcm9wZXJ0eSkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBcImRlZ1wiO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoLyheKHNjYWxlfHNjYWxlWHxzY2FsZVl8c2NhbGVafGFscGhhfGZsZXhHcm93fGZsZXhIZWlnaHR8ekluZGV4fGZvbnRXZWlnaHQpJCl8KChvcGFjaXR5fHJlZHxncmVlbnxibHVlfGFscGhhKSQpL2kudGVzdChwcm9wZXJ0eSkpIHtcblx0XHRcdFx0XHRcdC8qIFRoZSBhYm92ZSBwcm9wZXJ0aWVzIGFyZSB1bml0bGVzcy4gKi9cblx0XHRcdFx0XHRcdHJldHVybiBcIlwiO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvKiBEZWZhdWx0IHRvIHB4IGZvciBhbGwgb3RoZXIgcHJvcGVydGllcy4gKi9cblx0XHRcdFx0XHRcdHJldHVybiBcInB4XCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKiBIVE1MIGVsZW1lbnRzIGRlZmF1bHQgdG8gYW4gYXNzb2NpYXRlZCBkaXNwbGF5IHR5cGUgd2hlbiB0aGV5J3JlIG5vdCBzZXQgdG8gZGlzcGxheTpub25lLiAqL1xuXHRcdFx0XHQvKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgZm9yIGNvcnJlY3RseSBzZXR0aW5nIHRoZSBub24tXCJub25lXCIgZGlzcGxheSB2YWx1ZSBpbiBjZXJ0YWluIFZlbG9jaXR5IHJlZGlyZWN0cywgc3VjaCBhcyBmYWRlSW4vT3V0LiAqL1xuXHRcdFx0XHRnZXREaXNwbGF5VHlwZTogZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0XHRcdHZhciB0YWdOYW1lID0gZWxlbWVudCAmJiBlbGVtZW50LnRhZ05hbWUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRcdFx0aWYgKC9eKGJ8YmlnfGl8c21hbGx8dHR8YWJicnxhY3JvbnltfGNpdGV8Y29kZXxkZm58ZW18a2JkfHN0cm9uZ3xzYW1wfHZhcnxhfGJkb3xicnxpbWd8bWFwfG9iamVjdHxxfHNjcmlwdHxzcGFufHN1YnxzdXB8YnV0dG9ufGlucHV0fGxhYmVsfHNlbGVjdHx0ZXh0YXJlYSkkL2kudGVzdCh0YWdOYW1lKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFwiaW5saW5lXCI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICgvXihsaSkkL2kudGVzdCh0YWdOYW1lKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFwibGlzdC1pdGVtXCI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICgvXih0cikkL2kudGVzdCh0YWdOYW1lKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFwidGFibGUtcm93XCI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICgvXih0YWJsZSkkL2kudGVzdCh0YWdOYW1lKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFwidGFibGVcIjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKC9eKHRib2R5KSQvaS50ZXN0KHRhZ05hbWUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gXCJ0YWJsZS1yb3ctZ3JvdXBcIjtcblx0XHRcdFx0XHRcdC8qIERlZmF1bHQgdG8gXCJibG9ja1wiIHdoZW4gbm8gbWF0Y2ggaXMgZm91bmQuICovXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVybiBcImJsb2NrXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKiBUaGUgY2xhc3MgYWRkL3JlbW92ZSBmdW5jdGlvbnMgYXJlIHVzZWQgdG8gdGVtcG9yYXJpbHkgYXBwbHkgYSBcInZlbG9jaXR5LWFuaW1hdGluZ1wiIGNsYXNzIHRvIGVsZW1lbnRzIHdoaWxlIHRoZXkncmUgYW5pbWF0aW5nLiAqL1xuXHRcdFx0XHRhZGRDbGFzczogZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NOYW1lKSB7XG5cdFx0XHRcdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoVHlwZS5pc1N0cmluZyhlbGVtZW50LmNsYXNzTmFtZSkpIHtcblx0XHRcdFx0XHRcdFx0Ly8gRWxlbWVudC5jbGFzc05hbWUgaXMgYXJvdW5kIDE1JSBmYXN0ZXIgdGhlbiBzZXQvZ2V0QXR0cmlidXRlXG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQuY2xhc3NOYW1lICs9IChlbGVtZW50LmNsYXNzTmFtZS5sZW5ndGggPyBcIiBcIiA6IFwiXCIpICsgY2xhc3NOYW1lO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gV29yayBhcm91bmQgZm9yIElFIHN0cmljdCBtb2RlIGFuaW1hdGluZyBTVkcgLSBhbmQgYW55dGhpbmcgZWxzZSB0aGF0IGRvZXNuJ3QgYmVoYXZlIGNvcnJlY3RseSAtIHRoZSBzYW1lIHdheSBqUXVlcnkgZG9lcyBpdFxuXHRcdFx0XHRcdFx0XHR2YXIgY3VycmVudENsYXNzID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoSUUgPD0gNyA/IFwiY2xhc3NOYW1lXCIgOiBcImNsYXNzXCIpIHx8IFwiXCI7XG5cblx0XHRcdFx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBjdXJyZW50Q2xhc3MgKyAoY3VycmVudENsYXNzID8gXCIgXCIgOiBcIlwiKSArIGNsYXNzTmFtZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZW1vdmVDbGFzczogZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NOYW1lKSB7XG5cdFx0XHRcdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoVHlwZS5pc1N0cmluZyhlbGVtZW50LmNsYXNzTmFtZSkpIHtcblx0XHRcdFx0XHRcdFx0Ly8gRWxlbWVudC5jbGFzc05hbWUgaXMgYXJvdW5kIDE1JSBmYXN0ZXIgdGhlbiBzZXQvZ2V0QXR0cmlidXRlXG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IE5lZWQgc29tZSBqc3BlcmYgdGVzdHMgb24gcGVyZm9ybWFuY2UgLSBjYW4gd2UgZ2V0IHJpZCBvZiB0aGUgcmVnZXggYW5kIG1heWJlIHVzZSBzcGxpdCAvIGFycmF5IG1hbmlwdWxhdGlvbj9cblx0XHRcdFx0XHRcdFx0ZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS50b1N0cmluZygpLnJlcGxhY2UobmV3IFJlZ0V4cChcIihefFxcXFxzKVwiICsgY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5qb2luKFwifFwiKSArIFwiKFxcXFxzfCQpXCIsIFwiZ2lcIiksIFwiIFwiKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFdvcmsgYXJvdW5kIGZvciBJRSBzdHJpY3QgbW9kZSBhbmltYXRpbmcgU1ZHIC0gYW5kIGFueXRoaW5nIGVsc2UgdGhhdCBkb2Vzbid0IGJlaGF2ZSBjb3JyZWN0bHkgLSB0aGUgc2FtZSB3YXkgalF1ZXJ5IGRvZXMgaXRcblx0XHRcdFx0XHRcdFx0dmFyIGN1cnJlbnRDbGFzcyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKElFIDw9IDcgPyBcImNsYXNzTmFtZVwiIDogXCJjbGFzc1wiKSB8fCBcIlwiO1xuXG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgY3VycmVudENsYXNzLnJlcGxhY2UobmV3IFJlZ0V4cChcIihefFxccylcIiArIGNsYXNzTmFtZS5zcGxpdChcIiBcIikuam9pbihcInxcIikgKyBcIihcXHN8JClcIiwgXCJnaVwiKSwgXCIgXCIpKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0IFN0eWxlIEdldHRpbmcgJiBTZXR0aW5nXG5cdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0LyogVGhlIHNpbmd1bGFyIGdldFByb3BlcnR5VmFsdWUsIHdoaWNoIHJvdXRlcyB0aGUgbG9naWMgZm9yIGFsbCBub3JtYWxpemF0aW9ucywgaG9va3MsIGFuZCBzdGFuZGFyZCBDU1MgcHJvcGVydGllcy4gKi9cblx0XHRcdGdldFByb3BlcnR5VmFsdWU6IGZ1bmN0aW9uKGVsZW1lbnQsIHByb3BlcnR5LCByb290UHJvcGVydHlWYWx1ZSwgZm9yY2VTdHlsZUxvb2t1cCkge1xuXHRcdFx0XHQvKiBHZXQgYW4gZWxlbWVudCdzIGNvbXB1dGVkIHByb3BlcnR5IHZhbHVlLiAqL1xuXHRcdFx0XHQvKiBOb3RlOiBSZXRyaWV2aW5nIHRoZSB2YWx1ZSBvZiBhIENTUyBwcm9wZXJ0eSBjYW5ub3Qgc2ltcGx5IGJlIHBlcmZvcm1lZCBieSBjaGVja2luZyBhbiBlbGVtZW50J3Ncblx0XHRcdFx0IHN0eWxlIGF0dHJpYnV0ZSAod2hpY2ggb25seSByZWZsZWN0cyB1c2VyLWRlZmluZWQgdmFsdWVzKS4gSW5zdGVhZCwgdGhlIGJyb3dzZXIgbXVzdCBiZSBxdWVyaWVkIGZvciBhIHByb3BlcnR5J3Ncblx0XHRcdFx0ICpjb21wdXRlZCogdmFsdWUuIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGdldENvbXB1dGVkU3R5bGUgaGVyZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL3dpbmRvdy5nZXRDb21wdXRlZFN0eWxlICovXG5cdFx0XHRcdGZ1bmN0aW9uIGNvbXB1dGVQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIHByb3BlcnR5KSB7XG5cdFx0XHRcdFx0LyogV2hlbiBib3gtc2l6aW5nIGlzbid0IHNldCB0byBib3JkZXItYm94LCBoZWlnaHQgYW5kIHdpZHRoIHN0eWxlIHZhbHVlcyBhcmUgaW5jb3JyZWN0bHkgY29tcHV0ZWQgd2hlbiBhblxuXHRcdFx0XHRcdCBlbGVtZW50J3Mgc2Nyb2xsYmFycyBhcmUgdmlzaWJsZSAod2hpY2ggZXhwYW5kcyB0aGUgZWxlbWVudCdzIGRpbWVuc2lvbnMpLiBUaHVzLCB3ZSBkZWZlciB0byB0aGUgbW9yZSBhY2N1cmF0ZVxuXHRcdFx0XHRcdCBvZmZzZXRIZWlnaHQvV2lkdGggcHJvcGVydHksIHdoaWNoIGluY2x1ZGVzIHRoZSB0b3RhbCBkaW1lbnNpb25zIGZvciBpbnRlcmlvciwgYm9yZGVyLCBwYWRkaW5nLCBhbmQgc2Nyb2xsYmFyLlxuXHRcdFx0XHRcdCBXZSBzdWJ0cmFjdCBib3JkZXIgYW5kIHBhZGRpbmcgdG8gZ2V0IHRoZSBzdW0gb2YgaW50ZXJpb3IgKyBzY3JvbGxiYXIuICovXG5cdFx0XHRcdFx0dmFyIGNvbXB1dGVkVmFsdWUgPSAwO1xuXG5cdFx0XHRcdFx0LyogSUU8PTggZG9lc24ndCBzdXBwb3J0IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlLCB0aHVzIHdlIGRlZmVyIHRvIGpRdWVyeSwgd2hpY2ggaGFzIGFuIGV4dGVuc2l2ZSBhcnJheVxuXHRcdFx0XHRcdCBvZiBoYWNrcyB0byBhY2N1cmF0ZWx5IHJldHJpZXZlIElFOCBwcm9wZXJ0eSB2YWx1ZXMuIFJlLWltcGxlbWVudGluZyB0aGF0IGxvZ2ljIGhlcmUgaXMgbm90IHdvcnRoIGJsb2F0aW5nIHRoZVxuXHRcdFx0XHRcdCBjb2RlYmFzZSBmb3IgYSBkeWluZyBicm93c2VyLiBUaGUgcGVyZm9ybWFuY2UgcmVwZXJjdXNzaW9ucyBvZiB1c2luZyBqUXVlcnkgaGVyZSBhcmUgbWluaW1hbCBzaW5jZVxuXHRcdFx0XHRcdCBWZWxvY2l0eSBpcyBvcHRpbWl6ZWQgdG8gcmFyZWx5IChhbmQgc29tZXRpbWVzIG5ldmVyKSBxdWVyeSB0aGUgRE9NLiBGdXJ0aGVyLCB0aGUgJC5jc3MoKSBjb2RlcGF0aCBpc24ndCB0aGF0IHNsb3cuICovXG5cdFx0XHRcdFx0aWYgKElFIDw9IDgpIHtcblx0XHRcdFx0XHRcdGNvbXB1dGVkVmFsdWUgPSAkLmNzcyhlbGVtZW50LCBwcm9wZXJ0eSk7IC8qIEdFVCAqL1xuXHRcdFx0XHRcdFx0LyogQWxsIG90aGVyIGJyb3dzZXJzIHN1cHBvcnQgZ2V0Q29tcHV0ZWRTdHlsZS4gVGhlIHJldHVybmVkIGxpdmUgb2JqZWN0IHJlZmVyZW5jZSBpcyBjYWNoZWQgb250byBpdHNcblx0XHRcdFx0XHRcdCBhc3NvY2lhdGVkIGVsZW1lbnQgc28gdGhhdCBpdCBkb2VzIG5vdCBuZWVkIHRvIGJlIHJlZmV0Y2hlZCB1cG9uIGV2ZXJ5IEdFVC4gKi9cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0LyogQnJvd3NlcnMgZG8gbm90IHJldHVybiBoZWlnaHQgYW5kIHdpZHRoIHZhbHVlcyBmb3IgZWxlbWVudHMgdGhhdCBhcmUgc2V0IHRvIGRpc3BsYXk6XCJub25lXCIuIFRodXMsIHdlIHRlbXBvcmFyaWx5XG5cdFx0XHRcdFx0XHQgdG9nZ2xlIGRpc3BsYXkgdG8gdGhlIGVsZW1lbnQgdHlwZSdzIGRlZmF1bHQgdmFsdWUuICovXG5cdFx0XHRcdFx0XHR2YXIgdG9nZ2xlRGlzcGxheSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHRpZiAoL14od2lkdGh8aGVpZ2h0KSQvLnRlc3QocHJvcGVydHkpICYmIENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwiZGlzcGxheVwiKSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHR0b2dnbGVEaXNwbGF5ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0Q1NTLnNldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJkaXNwbGF5XCIsIENTUy5WYWx1ZXMuZ2V0RGlzcGxheVR5cGUoZWxlbWVudCkpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgcmV2ZXJ0RGlzcGxheSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRpZiAodG9nZ2xlRGlzcGxheSkge1xuXHRcdFx0XHRcdFx0XHRcdENTUy5zZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdGlmICghZm9yY2VTdHlsZUxvb2t1cCkge1xuXHRcdFx0XHRcdFx0XHRpZiAocHJvcGVydHkgPT09IFwiaGVpZ2h0XCIgJiYgQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJib3hTaXppbmdcIikudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpICE9PSBcImJvcmRlci1ib3hcIikge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBjb250ZW50Qm94SGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgLSAocGFyc2VGbG9hdChDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcImJvcmRlclRvcFdpZHRoXCIpKSB8fCAwKSAtIChwYXJzZUZsb2F0KENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwiYm9yZGVyQm90dG9tV2lkdGhcIikpIHx8IDApIC0gKHBhcnNlRmxvYXQoQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJwYWRkaW5nVG9wXCIpKSB8fCAwKSAtIChwYXJzZUZsb2F0KENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwicGFkZGluZ0JvdHRvbVwiKSkgfHwgMCk7XG5cdFx0XHRcdFx0XHRcdFx0cmV2ZXJ0RGlzcGxheSgpO1xuXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGNvbnRlbnRCb3hIZWlnaHQ7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAocHJvcGVydHkgPT09IFwid2lkdGhcIiAmJiBDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcImJveFNpemluZ1wiKS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgIT09IFwiYm9yZGVyLWJveFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGNvbnRlbnRCb3hXaWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggLSAocGFyc2VGbG9hdChDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcImJvcmRlckxlZnRXaWR0aFwiKSkgfHwgMCkgLSAocGFyc2VGbG9hdChDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcImJvcmRlclJpZ2h0V2lkdGhcIikpIHx8IDApIC0gKHBhcnNlRmxvYXQoQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJwYWRkaW5nTGVmdFwiKSkgfHwgMCkgLSAocGFyc2VGbG9hdChDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcInBhZGRpbmdSaWdodFwiKSkgfHwgMCk7XG5cdFx0XHRcdFx0XHRcdFx0cmV2ZXJ0RGlzcGxheSgpO1xuXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGNvbnRlbnRCb3hXaWR0aDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgY29tcHV0ZWRTdHlsZTtcblxuXHRcdFx0XHRcdFx0LyogRm9yIGVsZW1lbnRzIHRoYXQgVmVsb2NpdHkgaGFzbid0IGJlZW4gY2FsbGVkIG9uIGRpcmVjdGx5IChlLmcuIHdoZW4gVmVsb2NpdHkgcXVlcmllcyB0aGUgRE9NIG9uIGJlaGFsZlxuXHRcdFx0XHRcdFx0IG9mIGEgcGFyZW50IG9mIGFuIGVsZW1lbnQgaXRzIGFuaW1hdGluZyksIHBlcmZvcm0gYSBkaXJlY3QgZ2V0Q29tcHV0ZWRTdHlsZSBsb29rdXAgc2luY2UgdGhlIG9iamVjdCBpc24ndCBjYWNoZWQuICovXG5cdFx0XHRcdFx0XHRpZiAoRGF0YShlbGVtZW50KSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTsgLyogR0VUICovXG5cdFx0XHRcdFx0XHRcdC8qIElmIHRoZSBjb21wdXRlZFN0eWxlIG9iamVjdCBoYXMgeWV0IHRvIGJlIGNhY2hlZCwgZG8gc28gbm93LiAqL1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICghRGF0YShlbGVtZW50KS5jb21wdXRlZFN0eWxlKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXB1dGVkU3R5bGUgPSBEYXRhKGVsZW1lbnQpLmNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTsgLyogR0VUICovXG5cdFx0XHRcdFx0XHRcdC8qIElmIGNvbXB1dGVkU3R5bGUgaXMgY2FjaGVkLCB1c2UgaXQuICovXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjb21wdXRlZFN0eWxlID0gRGF0YShlbGVtZW50KS5jb21wdXRlZFN0eWxlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBJRSBhbmQgRmlyZWZveCBkbyBub3QgcmV0dXJuIGEgdmFsdWUgZm9yIHRoZSBnZW5lcmljIGJvcmRlckNvbG9yIC0tIHRoZXkgb25seSByZXR1cm4gaW5kaXZpZHVhbCB2YWx1ZXMgZm9yIGVhY2ggYm9yZGVyIHNpZGUncyBjb2xvci5cblx0XHRcdFx0XHRcdCBBbHNvLCBpbiBhbGwgYnJvd3NlcnMsIHdoZW4gYm9yZGVyIGNvbG9ycyBhcmVuJ3QgYWxsIHRoZSBzYW1lLCBhIGNvbXBvdW5kIHZhbHVlIGlzIHJldHVybmVkIHRoYXQgVmVsb2NpdHkgaXNuJ3Qgc2V0dXAgdG8gcGFyc2UuXG5cdFx0XHRcdFx0XHQgU28sIGFzIGEgcG9seWZpbGwgZm9yIHF1ZXJ5aW5nIGluZGl2aWR1YWwgYm9yZGVyIHNpZGUgY29sb3JzLCB3ZSBqdXN0IHJldHVybiB0aGUgdG9wIGJvcmRlcidzIGNvbG9yIGFuZCBhbmltYXRlIGFsbCBib3JkZXJzIGZyb20gdGhhdCB2YWx1ZS4gKi9cblx0XHRcdFx0XHRcdGlmIChwcm9wZXJ0eSA9PT0gXCJib3JkZXJDb2xvclwiKSB7XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5ID0gXCJib3JkZXJUb3BDb2xvclwiO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBJRTkgaGFzIGEgYnVnIGluIHdoaWNoIHRoZSBcImZpbHRlclwiIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgZnJvbSBjb21wdXRlZFN0eWxlIHVzaW5nIHRoZSBnZXRQcm9wZXJ0eVZhbHVlIG1ldGhvZFxuXHRcdFx0XHRcdFx0IGluc3RlYWQgb2YgYSBkaXJlY3QgcHJvcGVydHkgbG9va3VwLiBUaGUgZ2V0UHJvcGVydHlWYWx1ZSBtZXRob2QgaXMgc2xvd2VyIHRoYW4gYSBkaXJlY3QgbG9va3VwLCB3aGljaCBpcyB3aHkgd2UgYXZvaWQgaXQgYnkgZGVmYXVsdC4gKi9cblx0XHRcdFx0XHRcdGlmIChJRSA9PT0gOSAmJiBwcm9wZXJ0eSA9PT0gXCJmaWx0ZXJcIikge1xuXHRcdFx0XHRcdFx0XHRjb21wdXRlZFZhbHVlID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTsgLyogR0VUICovXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjb21wdXRlZFZhbHVlID0gY29tcHV0ZWRTdHlsZVtwcm9wZXJ0eV07XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIEZhbGwgYmFjayB0byB0aGUgcHJvcGVydHkncyBzdHlsZSB2YWx1ZSAoaWYgZGVmaW5lZCkgd2hlbiBjb21wdXRlZFZhbHVlIHJldHVybnMgbm90aGluZyxcblx0XHRcdFx0XHRcdCB3aGljaCBjYW4gaGFwcGVuIHdoZW4gdGhlIGVsZW1lbnQgaGFzbid0IGJlZW4gcGFpbnRlZC4gKi9cblx0XHRcdFx0XHRcdGlmIChjb21wdXRlZFZhbHVlID09PSBcIlwiIHx8IGNvbXB1dGVkVmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0Y29tcHV0ZWRWYWx1ZSA9IGVsZW1lbnQuc3R5bGVbcHJvcGVydHldO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXZlcnREaXNwbGF5KCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogRm9yIHRvcCwgcmlnaHQsIGJvdHRvbSwgYW5kIGxlZnQgKFRSQkwpIHZhbHVlcyB0aGF0IGFyZSBzZXQgdG8gXCJhdXRvXCIgb24gZWxlbWVudHMgb2YgXCJmaXhlZFwiIG9yIFwiYWJzb2x1dGVcIiBwb3NpdGlvbixcblx0XHRcdFx0XHQgZGVmZXIgdG8galF1ZXJ5IGZvciBjb252ZXJ0aW5nIFwiYXV0b1wiIHRvIGEgbnVtZXJpYyB2YWx1ZS4gKEZvciBlbGVtZW50cyB3aXRoIGEgXCJzdGF0aWNcIiBvciBcInJlbGF0aXZlXCIgcG9zaXRpb24sIFwiYXV0b1wiIGhhcyB0aGUgc2FtZVxuXHRcdFx0XHRcdCBlZmZlY3QgYXMgYmVpbmcgc2V0IHRvIDAsIHNvIG5vIGNvbnZlcnNpb24gaXMgbmVjZXNzYXJ5LikgKi9cblx0XHRcdFx0XHQvKiBBbiBleGFtcGxlIG9mIHdoeSBudW1lcmljIGNvbnZlcnNpb24gaXMgbmVjZXNzYXJ5OiBXaGVuIGFuIGVsZW1lbnQgd2l0aCBcInBvc2l0aW9uOmFic29sdXRlXCIgaGFzIGFuIHVudG91Y2hlZCBcImxlZnRcIlxuXHRcdFx0XHRcdCBwcm9wZXJ0eSwgd2hpY2ggcmV2ZXJ0cyB0byBcImF1dG9cIiwgbGVmdCdzIHZhbHVlIGlzIDAgcmVsYXRpdmUgdG8gaXRzIHBhcmVudCBlbGVtZW50LCBidXQgaXMgb2Z0ZW4gbm9uLXplcm8gcmVsYXRpdmVcblx0XHRcdFx0XHQgdG8gaXRzICpjb250YWluaW5nKiAobm90IHBhcmVudCkgZWxlbWVudCwgd2hpY2ggaXMgdGhlIG5lYXJlc3QgXCJwb3NpdGlvbjpyZWxhdGl2ZVwiIGFuY2VzdG9yIG9yIHRoZSB2aWV3cG9ydCAoYW5kIGFsd2F5cyB0aGUgdmlld3BvcnQgaW4gdGhlIGNhc2Ugb2YgXCJwb3NpdGlvbjpmaXhlZFwiKS4gKi9cblx0XHRcdFx0XHRpZiAoY29tcHV0ZWRWYWx1ZSA9PT0gXCJhdXRvXCIgJiYgL14odG9wfHJpZ2h0fGJvdHRvbXxsZWZ0KSQvaS50ZXN0KHByb3BlcnR5KSkge1xuXHRcdFx0XHRcdFx0dmFyIHBvc2l0aW9uID0gY29tcHV0ZVByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJwb3NpdGlvblwiKTsgLyogR0VUICovXG5cblx0XHRcdFx0XHRcdC8qIEZvciBhYnNvbHV0ZSBwb3NpdGlvbmluZywgalF1ZXJ5J3MgJC5wb3NpdGlvbigpIG9ubHkgcmV0dXJucyB2YWx1ZXMgZm9yIHRvcCBhbmQgbGVmdDtcblx0XHRcdFx0XHRcdCByaWdodCBhbmQgYm90dG9tIHdpbGwgaGF2ZSB0aGVpciBcImF1dG9cIiB2YWx1ZSByZXZlcnRlZCB0byAwLiAqL1xuXHRcdFx0XHRcdFx0LyogTm90ZTogQSBqUXVlcnkgb2JqZWN0IG11c3QgYmUgY3JlYXRlZCBoZXJlIHNpbmNlIGpRdWVyeSBkb2Vzbid0IGhhdmUgYSBsb3ctbGV2ZWwgYWxpYXMgZm9yICQucG9zaXRpb24oKS5cblx0XHRcdFx0XHRcdCBOb3QgYSBiaWcgZGVhbCBzaW5jZSB3ZSdyZSBjdXJyZW50bHkgaW4gYSBHRVQgYmF0Y2ggYW55d2F5LiAqL1xuXHRcdFx0XHRcdFx0aWYgKHBvc2l0aW9uID09PSBcImZpeGVkXCIgfHwgKHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgJiYgL3RvcHxsZWZ0L2kudGVzdChwcm9wZXJ0eSkpKSB7XG5cdFx0XHRcdFx0XHRcdC8qIE5vdGU6IGpRdWVyeSBzdHJpcHMgdGhlIHBpeGVsIHVuaXQgZnJvbSBpdHMgcmV0dXJuZWQgdmFsdWVzOyB3ZSByZS1hZGQgaXQgaGVyZSB0byBjb25mb3JtIHdpdGggY29tcHV0ZVByb3BlcnR5VmFsdWUncyBiZWhhdmlvci4gKi9cblx0XHRcdFx0XHRcdFx0Y29tcHV0ZWRWYWx1ZSA9ICQoZWxlbWVudCkucG9zaXRpb24oKVtwcm9wZXJ0eV0gKyBcInB4XCI7IC8qIEdFVCAqL1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBjb21wdXRlZFZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHByb3BlcnR5VmFsdWU7XG5cblx0XHRcdFx0LyogSWYgdGhpcyBpcyBhIGhvb2tlZCBwcm9wZXJ0eSAoZS5nLiBcImNsaXBMZWZ0XCIgaW5zdGVhZCBvZiB0aGUgcm9vdCBwcm9wZXJ0eSBvZiBcImNsaXBcIiksXG5cdFx0XHRcdCBleHRyYWN0IHRoZSBob29rJ3MgdmFsdWUgZnJvbSBhIG5vcm1hbGl6ZWQgcm9vdFByb3BlcnR5VmFsdWUgdXNpbmcgQ1NTLkhvb2tzLmV4dHJhY3RWYWx1ZSgpLiAqL1xuXHRcdFx0XHRpZiAoQ1NTLkhvb2tzLnJlZ2lzdGVyZWRbcHJvcGVydHldKSB7XG5cdFx0XHRcdFx0dmFyIGhvb2sgPSBwcm9wZXJ0eSxcblx0XHRcdFx0XHRcdFx0aG9va1Jvb3QgPSBDU1MuSG9va3MuZ2V0Um9vdChob29rKTtcblxuXHRcdFx0XHRcdC8qIElmIGEgY2FjaGVkIHJvb3RQcm9wZXJ0eVZhbHVlIHdhc24ndCBwYXNzZWQgaW4gKHdoaWNoIFZlbG9jaXR5IGFsd2F5cyBhdHRlbXB0cyB0byBkbyBpbiBvcmRlciB0byBhdm9pZCByZXF1ZXJ5aW5nIHRoZSBET00pLFxuXHRcdFx0XHRcdCBxdWVyeSB0aGUgRE9NIGZvciB0aGUgcm9vdCBwcm9wZXJ0eSdzIHZhbHVlLiAqL1xuXHRcdFx0XHRcdGlmIChyb290UHJvcGVydHlWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHQvKiBTaW5jZSB0aGUgYnJvd3NlciBpcyBub3cgYmVpbmcgZGlyZWN0bHkgcXVlcmllZCwgdXNlIHRoZSBvZmZpY2lhbCBwb3N0LXByZWZpeGluZyBwcm9wZXJ0eSBuYW1lIGZvciB0aGlzIGxvb2t1cC4gKi9cblx0XHRcdFx0XHRcdHJvb3RQcm9wZXJ0eVZhbHVlID0gQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgQ1NTLk5hbWVzLnByZWZpeENoZWNrKGhvb2tSb290KVswXSk7IC8qIEdFVCAqL1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIElmIHRoaXMgcm9vdCBoYXMgYSBub3JtYWxpemF0aW9uIHJlZ2lzdGVyZWQsIHBlZm9ybSB0aGUgYXNzb2NpYXRlZCBub3JtYWxpemF0aW9uIGV4dHJhY3Rpb24uICovXG5cdFx0XHRcdFx0aWYgKENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW2hvb2tSb290XSkge1xuXHRcdFx0XHRcdFx0cm9vdFByb3BlcnR5VmFsdWUgPSBDU1MuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtob29rUm9vdF0oXCJleHRyYWN0XCIsIGVsZW1lbnQsIHJvb3RQcm9wZXJ0eVZhbHVlKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBFeHRyYWN0IHRoZSBob29rJ3MgdmFsdWUuICovXG5cdFx0XHRcdFx0cHJvcGVydHlWYWx1ZSA9IENTUy5Ib29rcy5leHRyYWN0VmFsdWUoaG9vaywgcm9vdFByb3BlcnR5VmFsdWUpO1xuXG5cdFx0XHRcdFx0LyogSWYgdGhpcyBpcyBhIG5vcm1hbGl6ZWQgcHJvcGVydHkgKGUuZy4gXCJvcGFjaXR5XCIgYmVjb21lcyBcImZpbHRlclwiIGluIDw9SUU4KSBvciBcInRyYW5zbGF0ZVhcIiBiZWNvbWVzIFwidHJhbnNmb3JtXCIpLFxuXHRcdFx0XHRcdCBub3JtYWxpemUgdGhlIHByb3BlcnR5J3MgbmFtZSBhbmQgdmFsdWUsIGFuZCBoYW5kbGUgdGhlIHNwZWNpYWwgY2FzZSBvZiB0cmFuc2Zvcm1zLiAqL1xuXHRcdFx0XHRcdC8qIE5vdGU6IE5vcm1hbGl6aW5nIGEgcHJvcGVydHkgaXMgbXV0dWFsbHkgZXhjbHVzaXZlIGZyb20gaG9va2luZyBhIHByb3BlcnR5IHNpbmNlIGhvb2stZXh0cmFjdGVkIHZhbHVlcyBhcmUgc3RyaWN0bHlcblx0XHRcdFx0XHQgbnVtZXJpY2FsIGFuZCB0aGVyZWZvcmUgZG8gbm90IHJlcXVpcmUgbm9ybWFsaXphdGlvbiBleHRyYWN0aW9uLiAqL1xuXHRcdFx0XHR9IGVsc2UgaWYgKENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW3Byb3BlcnR5XSkge1xuXHRcdFx0XHRcdHZhciBub3JtYWxpemVkUHJvcGVydHlOYW1lLFxuXHRcdFx0XHRcdFx0XHRub3JtYWxpemVkUHJvcGVydHlWYWx1ZTtcblxuXHRcdFx0XHRcdG5vcm1hbGl6ZWRQcm9wZXJ0eU5hbWUgPSBDU1MuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtwcm9wZXJ0eV0oXCJuYW1lXCIsIGVsZW1lbnQpO1xuXG5cdFx0XHRcdFx0LyogVHJhbnNmb3JtIHZhbHVlcyBhcmUgY2FsY3VsYXRlZCB2aWEgbm9ybWFsaXphdGlvbiBleHRyYWN0aW9uIChzZWUgYmVsb3cpLCB3aGljaCBjaGVja3MgYWdhaW5zdCB0aGUgZWxlbWVudCdzIHRyYW5zZm9ybUNhY2hlLlxuXHRcdFx0XHRcdCBBdCBubyBwb2ludCBkbyB0cmFuc2Zvcm0gR0VUcyBldmVyIGFjdHVhbGx5IHF1ZXJ5IHRoZSBET007IGluaXRpYWwgc3R5bGVzaGVldCB2YWx1ZXMgYXJlIG5ldmVyIHByb2Nlc3NlZC5cblx0XHRcdFx0XHQgVGhpcyBpcyBiZWNhdXNlIHBhcnNpbmcgM0QgdHJhbnNmb3JtIG1hdHJpY2VzIGlzIG5vdCBhbHdheXMgYWNjdXJhdGUgYW5kIHdvdWxkIGJsb2F0IG91ciBjb2RlYmFzZTtcblx0XHRcdFx0XHQgdGh1cywgbm9ybWFsaXphdGlvbiBleHRyYWN0aW9uIGRlZmF1bHRzIGluaXRpYWwgdHJhbnNmb3JtIHZhbHVlcyB0byB0aGVpciB6ZXJvLXZhbHVlcyAoZS5nLiAxIGZvciBzY2FsZVggYW5kIDAgZm9yIHRyYW5zbGF0ZVgpLiAqL1xuXHRcdFx0XHRcdGlmIChub3JtYWxpemVkUHJvcGVydHlOYW1lICE9PSBcInRyYW5zZm9ybVwiKSB7XG5cdFx0XHRcdFx0XHRub3JtYWxpemVkUHJvcGVydHlWYWx1ZSA9IGNvbXB1dGVQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIENTUy5OYW1lcy5wcmVmaXhDaGVjayhub3JtYWxpemVkUHJvcGVydHlOYW1lKVswXSk7IC8qIEdFVCAqL1xuXG5cdFx0XHRcdFx0XHQvKiBJZiB0aGUgdmFsdWUgaXMgYSBDU1MgbnVsbC12YWx1ZSBhbmQgdGhpcyBwcm9wZXJ0eSBoYXMgYSBob29rIHRlbXBsYXRlLCB1c2UgdGhhdCB6ZXJvLXZhbHVlIHRlbXBsYXRlIHNvIHRoYXQgaG9va3MgY2FuIGJlIGV4dHJhY3RlZCBmcm9tIGl0LiAqL1xuXHRcdFx0XHRcdFx0aWYgKENTUy5WYWx1ZXMuaXNDU1NOdWxsVmFsdWUobm9ybWFsaXplZFByb3BlcnR5VmFsdWUpICYmIENTUy5Ib29rcy50ZW1wbGF0ZXNbcHJvcGVydHldKSB7XG5cdFx0XHRcdFx0XHRcdG5vcm1hbGl6ZWRQcm9wZXJ0eVZhbHVlID0gQ1NTLkhvb2tzLnRlbXBsYXRlc1twcm9wZXJ0eV1bMV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cHJvcGVydHlWYWx1ZSA9IENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW3Byb3BlcnR5XShcImV4dHJhY3RcIiwgZWxlbWVudCwgbm9ybWFsaXplZFByb3BlcnR5VmFsdWUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyogSWYgYSAobnVtZXJpYykgdmFsdWUgd2Fzbid0IHByb2R1Y2VkIHZpYSBob29rIGV4dHJhY3Rpb24gb3Igbm9ybWFsaXphdGlvbiwgcXVlcnkgdGhlIERPTS4gKi9cblx0XHRcdFx0aWYgKCEvXltcXGQtXS8udGVzdChwcm9wZXJ0eVZhbHVlKSkge1xuXHRcdFx0XHRcdC8qIEZvciBTVkcgZWxlbWVudHMsIGRpbWVuc2lvbmFsIHByb3BlcnRpZXMgKHdoaWNoIFNWR0F0dHJpYnV0ZSgpIGRldGVjdHMpIGFyZSB0d2VlbmVkIHZpYVxuXHRcdFx0XHRcdCB0aGVpciBIVE1MIGF0dHJpYnV0ZSB2YWx1ZXMgaW5zdGVhZCBvZiB0aGVpciBDU1Mgc3R5bGUgdmFsdWVzLiAqL1xuXHRcdFx0XHRcdHZhciBkYXRhID0gRGF0YShlbGVtZW50KTtcblxuXHRcdFx0XHRcdGlmIChkYXRhICYmIGRhdGEuaXNTVkcgJiYgQ1NTLk5hbWVzLlNWR0F0dHJpYnV0ZShwcm9wZXJ0eSkpIHtcblx0XHRcdFx0XHRcdC8qIFNpbmNlIHRoZSBoZWlnaHQvd2lkdGggYXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIHNldCBtYW51YWxseSwgdGhleSBkb24ndCByZWZsZWN0IGNvbXB1dGVkIHZhbHVlcy5cblx0XHRcdFx0XHRcdCBUaHVzLCB3ZSB1c2UgdXNlIGdldEJCb3goKSB0byBlbnN1cmUgd2UgYWx3YXlzIGdldCB2YWx1ZXMgZm9yIGVsZW1lbnRzIHdpdGggdW5kZWZpbmVkIGhlaWdodC93aWR0aCBhdHRyaWJ1dGVzLiAqL1xuXHRcdFx0XHRcdFx0aWYgKC9eKGhlaWdodHx3aWR0aCkkL2kudGVzdChwcm9wZXJ0eSkpIHtcblx0XHRcdFx0XHRcdFx0LyogRmlyZWZveCB0aHJvd3MgYW4gZXJyb3IgaWYgLmdldEJCb3goKSBpcyBjYWxsZWQgb24gYW4gU1ZHIHRoYXQgaXNuJ3QgYXR0YWNoZWQgdG8gdGhlIERPTS4gKi9cblx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eVZhbHVlID0gZWxlbWVudC5nZXRCQm94KClbcHJvcGVydHldO1xuXHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5VmFsdWUgPSAwO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdC8qIE90aGVyd2lzZSwgYWNjZXNzIHRoZSBhdHRyaWJ1dGUgdmFsdWUgZGlyZWN0bHkuICovXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eVZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUocHJvcGVydHkpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eVZhbHVlID0gY29tcHV0ZVByb3BlcnR5VmFsdWUoZWxlbWVudCwgQ1NTLk5hbWVzLnByZWZpeENoZWNrKHByb3BlcnR5KVswXSk7IC8qIEdFVCAqL1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qIFNpbmNlIHByb3BlcnR5IGxvb2t1cHMgYXJlIGZvciBhbmltYXRpb24gcHVycG9zZXMgKHdoaWNoIGVudGFpbHMgY29tcHV0aW5nIHRoZSBudW1lcmljIGRlbHRhIGJldHdlZW4gc3RhcnQgYW5kIGVuZCB2YWx1ZXMpLFxuXHRcdFx0XHQgY29udmVydCBDU1MgbnVsbC12YWx1ZXMgdG8gYW4gaW50ZWdlciBvZiB2YWx1ZSAwLiAqL1xuXHRcdFx0XHRpZiAoQ1NTLlZhbHVlcy5pc0NTU051bGxWYWx1ZShwcm9wZXJ0eVZhbHVlKSkge1xuXHRcdFx0XHRcdHByb3BlcnR5VmFsdWUgPSAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFZlbG9jaXR5LmRlYnVnID49IDIpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIkdldCBcIiArIHByb3BlcnR5ICsgXCI6IFwiICsgcHJvcGVydHlWYWx1ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gcHJvcGVydHlWYWx1ZTtcblx0XHRcdH0sXG5cdFx0XHQvKiBUaGUgc2luZ3VsYXIgc2V0UHJvcGVydHlWYWx1ZSwgd2hpY2ggcm91dGVzIHRoZSBsb2dpYyBmb3IgYWxsIG5vcm1hbGl6YXRpb25zLCBob29rcywgYW5kIHN0YW5kYXJkIENTUyBwcm9wZXJ0aWVzLiAqL1xuXHRcdFx0c2V0UHJvcGVydHlWYWx1ZTogZnVuY3Rpb24oZWxlbWVudCwgcHJvcGVydHksIHByb3BlcnR5VmFsdWUsIHJvb3RQcm9wZXJ0eVZhbHVlLCBzY3JvbGxEYXRhKSB7XG5cdFx0XHRcdHZhciBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eTtcblxuXHRcdFx0XHQvKiBJbiBvcmRlciB0byBiZSBzdWJqZWN0ZWQgdG8gY2FsbCBvcHRpb25zIGFuZCBlbGVtZW50IHF1ZXVlaW5nLCBzY3JvbGwgYW5pbWF0aW9uIGlzIHJvdXRlZCB0aHJvdWdoIFZlbG9jaXR5IGFzIGlmIGl0IHdlcmUgYSBzdGFuZGFyZCBDU1MgcHJvcGVydHkuICovXG5cdFx0XHRcdGlmIChwcm9wZXJ0eSA9PT0gXCJzY3JvbGxcIikge1xuXHRcdFx0XHRcdC8qIElmIGEgY29udGFpbmVyIG9wdGlvbiBpcyBwcmVzZW50LCBzY3JvbGwgdGhlIGNvbnRhaW5lciBpbnN0ZWFkIG9mIHRoZSBicm93c2VyIHdpbmRvdy4gKi9cblx0XHRcdFx0XHRpZiAoc2Nyb2xsRGF0YS5jb250YWluZXIpIHtcblx0XHRcdFx0XHRcdHNjcm9sbERhdGEuY29udGFpbmVyW1wic2Nyb2xsXCIgKyBzY3JvbGxEYXRhLmRpcmVjdGlvbl0gPSBwcm9wZXJ0eVZhbHVlO1xuXHRcdFx0XHRcdFx0LyogT3RoZXJ3aXNlLCBWZWxvY2l0eSBkZWZhdWx0cyB0byBzY3JvbGxpbmcgdGhlIGJyb3dzZXIgd2luZG93LiAqL1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoc2Nyb2xsRGF0YS5kaXJlY3Rpb24gPT09IFwiTGVmdFwiKSB7XG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zY3JvbGxUbyhwcm9wZXJ0eVZhbHVlLCBzY3JvbGxEYXRhLmFsdGVybmF0ZVZhbHVlKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zY3JvbGxUbyhzY3JvbGxEYXRhLmFsdGVybmF0ZVZhbHVlLCBwcm9wZXJ0eVZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0LyogVHJhbnNmb3JtcyAodHJhbnNsYXRlWCwgcm90YXRlWiwgZXRjLikgYXJlIGFwcGxpZWQgdG8gYSBwZXItZWxlbWVudCB0cmFuc2Zvcm1DYWNoZSBvYmplY3QsIHdoaWNoIGlzIG1hbnVhbGx5IGZsdXNoZWQgdmlhIGZsdXNoVHJhbnNmb3JtQ2FjaGUoKS5cblx0XHRcdFx0XHQgVGh1cywgZm9yIG5vdywgd2UgbWVyZWx5IGNhY2hlIHRyYW5zZm9ybXMgYmVpbmcgU0VULiAqL1xuXHRcdFx0XHRcdGlmIChDU1MuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtwcm9wZXJ0eV0gJiYgQ1NTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbcHJvcGVydHldKFwibmFtZVwiLCBlbGVtZW50KSA9PT0gXCJ0cmFuc2Zvcm1cIikge1xuXHRcdFx0XHRcdFx0LyogUGVyZm9ybSBhIG5vcm1hbGl6YXRpb24gaW5qZWN0aW9uLiAqL1xuXHRcdFx0XHRcdFx0LyogTm90ZTogVGhlIG5vcm1hbGl6YXRpb24gbG9naWMgaGFuZGxlcyB0aGUgdHJhbnNmb3JtQ2FjaGUgdXBkYXRpbmcuICovXG5cdFx0XHRcdFx0XHRDU1MuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtwcm9wZXJ0eV0oXCJpbmplY3RcIiwgZWxlbWVudCwgcHJvcGVydHlWYWx1ZSk7XG5cblx0XHRcdFx0XHRcdHByb3BlcnR5TmFtZSA9IFwidHJhbnNmb3JtXCI7XG5cdFx0XHRcdFx0XHRwcm9wZXJ0eVZhbHVlID0gRGF0YShlbGVtZW50KS50cmFuc2Zvcm1DYWNoZVtwcm9wZXJ0eV07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8qIEluamVjdCBob29rcy4gKi9cblx0XHRcdFx0XHRcdGlmIChDU1MuSG9va3MucmVnaXN0ZXJlZFtwcm9wZXJ0eV0pIHtcblx0XHRcdFx0XHRcdFx0dmFyIGhvb2tOYW1lID0gcHJvcGVydHksXG5cdFx0XHRcdFx0XHRcdFx0XHRob29rUm9vdCA9IENTUy5Ib29rcy5nZXRSb290KHByb3BlcnR5KTtcblxuXHRcdFx0XHRcdFx0XHQvKiBJZiBhIGNhY2hlZCByb290UHJvcGVydHlWYWx1ZSB3YXMgbm90IHByb3ZpZGVkLCBxdWVyeSB0aGUgRE9NIGZvciB0aGUgaG9va1Jvb3QncyBjdXJyZW50IHZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHRyb290UHJvcGVydHlWYWx1ZSA9IHJvb3RQcm9wZXJ0eVZhbHVlIHx8IENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIGhvb2tSb290KTsgLyogR0VUICovXG5cblx0XHRcdFx0XHRcdFx0cHJvcGVydHlWYWx1ZSA9IENTUy5Ib29rcy5pbmplY3RWYWx1ZShob29rTmFtZSwgcHJvcGVydHlWYWx1ZSwgcm9vdFByb3BlcnR5VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eSA9IGhvb2tSb290O1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBOb3JtYWxpemUgbmFtZXMgYW5kIHZhbHVlcy4gKi9cblx0XHRcdFx0XHRcdGlmIChDU1MuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtwcm9wZXJ0eV0pIHtcblx0XHRcdFx0XHRcdFx0cHJvcGVydHlWYWx1ZSA9IENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW3Byb3BlcnR5XShcImluamVjdFwiLCBlbGVtZW50LCBwcm9wZXJ0eVZhbHVlKTtcblx0XHRcdFx0XHRcdFx0cHJvcGVydHkgPSBDU1MuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtwcm9wZXJ0eV0oXCJuYW1lXCIsIGVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBBc3NpZ24gdGhlIGFwcHJvcHJpYXRlIHZlbmRvciBwcmVmaXggYmVmb3JlIHBlcmZvcm1pbmcgYW4gb2ZmaWNpYWwgc3R5bGUgdXBkYXRlLiAqL1xuXHRcdFx0XHRcdFx0cHJvcGVydHlOYW1lID0gQ1NTLk5hbWVzLnByZWZpeENoZWNrKHByb3BlcnR5KVswXTtcblxuXHRcdFx0XHRcdFx0LyogQSB0cnkvY2F0Y2ggaXMgdXNlZCBmb3IgSUU8PTgsIHdoaWNoIHRocm93cyBhbiBlcnJvciB3aGVuIFwiaW52YWxpZFwiIENTUyB2YWx1ZXMgYXJlIHNldCwgZS5nLiBhIG5lZ2F0aXZlIHdpZHRoLlxuXHRcdFx0XHRcdFx0IFRyeS9jYXRjaCBpcyBhdm9pZGVkIGZvciBvdGhlciBicm93c2VycyBzaW5jZSBpdCBpbmN1cnMgYSBwZXJmb3JtYW5jZSBvdmVyaGVhZC4gKi9cblx0XHRcdFx0XHRcdGlmIChJRSA8PSA4KSB7XG5cdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0ZWxlbWVudC5zdHlsZVtwcm9wZXJ0eU5hbWVdID0gcHJvcGVydHlWYWx1ZTtcblx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoVmVsb2NpdHkuZGVidWcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFtcIiArIHByb3BlcnR5VmFsdWUgKyBcIl0gZm9yIFtcIiArIHByb3BlcnR5TmFtZSArIFwiXVwiKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0LyogU1ZHIGVsZW1lbnRzIGhhdmUgdGhlaXIgZGltZW5zaW9uYWwgcHJvcGVydGllcyAod2lkdGgsIGhlaWdodCwgeCwgeSwgY3gsIGV0Yy4pIGFwcGxpZWQgZGlyZWN0bHkgYXMgYXR0cmlidXRlcyBpbnN0ZWFkIG9mIGFzIHN0eWxlcy4gKi9cblx0XHRcdFx0XHRcdFx0LyogTm90ZTogSUU4IGRvZXMgbm90IHN1cHBvcnQgU1ZHIGVsZW1lbnRzLCBzbyBpdCdzIG9rYXkgdGhhdCB3ZSBza2lwIGl0IGZvciBTVkcgYW5pbWF0aW9uLiAqL1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dmFyIGRhdGEgPSBEYXRhKGVsZW1lbnQpO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChkYXRhICYmIGRhdGEuaXNTVkcgJiYgQ1NTLk5hbWVzLlNWR0F0dHJpYnV0ZShwcm9wZXJ0eSkpIHtcblx0XHRcdFx0XHRcdFx0XHQvKiBOb3RlOiBGb3IgU1ZHIGF0dHJpYnV0ZXMsIHZlbmRvci1wcmVmaXhlZCBwcm9wZXJ0eSBuYW1lcyBhcmUgbmV2ZXIgdXNlZC4gKi9cblx0XHRcdFx0XHRcdFx0XHQvKiBOb3RlOiBOb3QgYWxsIENTUyBwcm9wZXJ0aWVzIGNhbiBiZSBhbmltYXRlZCB2aWEgYXR0cmlidXRlcywgYnV0IHRoZSBicm93c2VyIHdvbid0IHRocm93IGFuIGVycm9yIGZvciB1bnN1cHBvcnRlZCBwcm9wZXJ0aWVzLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKHByb3BlcnR5LCBwcm9wZXJ0eVZhbHVlKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRlbGVtZW50LnN0eWxlW3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0eVZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChWZWxvY2l0eS5kZWJ1ZyA+PSAyKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiU2V0IFwiICsgcHJvcGVydHkgKyBcIiAoXCIgKyBwcm9wZXJ0eU5hbWUgKyBcIik6IFwiICsgcHJvcGVydHlWYWx1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyogUmV0dXJuIHRoZSBub3JtYWxpemVkIHByb3BlcnR5IG5hbWUgYW5kIHZhbHVlIGluIGNhc2UgdGhlIGNhbGxlciB3YW50cyB0byBrbm93IGhvdyB0aGVzZSB2YWx1ZXMgd2VyZSBtb2RpZmllZCBiZWZvcmUgYmVpbmcgYXBwbGllZCB0byB0aGUgRE9NLiAqL1xuXHRcdFx0XHRyZXR1cm4gW3Byb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZV07XG5cdFx0XHR9LFxuXHRcdFx0LyogVG8gaW5jcmVhc2UgcGVyZm9ybWFuY2UgYnkgYmF0Y2hpbmcgdHJhbnNmb3JtIHVwZGF0ZXMgaW50byBhIHNpbmdsZSBTRVQsIHRyYW5zZm9ybXMgYXJlIG5vdCBkaXJlY3RseSBhcHBsaWVkIHRvIGFuIGVsZW1lbnQgdW50aWwgZmx1c2hUcmFuc2Zvcm1DYWNoZSgpIGlzIGNhbGxlZC4gKi9cblx0XHRcdC8qIE5vdGU6IFZlbG9jaXR5IGFwcGxpZXMgdHJhbnNmb3JtIHByb3BlcnRpZXMgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IGFyZSBjaHJvbm9naWNhbGx5IGludHJvZHVjZWQgdG8gdGhlIGVsZW1lbnQncyBDU1Mgc3R5bGVzLiAqL1xuXHRcdFx0Zmx1c2hUcmFuc2Zvcm1DYWNoZTogZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0XHR2YXIgdHJhbnNmb3JtU3RyaW5nID0gXCJcIixcblx0XHRcdFx0XHRcdGRhdGEgPSBEYXRhKGVsZW1lbnQpO1xuXG5cdFx0XHRcdC8qIENlcnRhaW4gYnJvd3NlcnMgcmVxdWlyZSB0aGF0IFNWRyB0cmFuc2Zvcm1zIGJlIGFwcGxpZWQgYXMgYW4gYXR0cmlidXRlLiBIb3dldmVyLCB0aGUgU1ZHIHRyYW5zZm9ybSBhdHRyaWJ1dGUgdGFrZXMgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIENTUydzIHRyYW5zZm9ybSBzdHJpbmdcblx0XHRcdFx0ICh1bml0cyBhcmUgZHJvcHBlZCBhbmQsIGV4Y2VwdCBmb3Igc2tld1gvWSwgc3VicHJvcGVydGllcyBhcmUgbWVyZ2VkIGludG8gdGhlaXIgbWFzdGVyIHByb3BlcnR5IC0tIGUuZy4gc2NhbGVYIGFuZCBzY2FsZVkgYXJlIG1lcmdlZCBpbnRvIHNjYWxlKFggWSkuICovXG5cdFx0XHRcdGlmICgoSUUgfHwgKFZlbG9jaXR5LlN0YXRlLmlzQW5kcm9pZCAmJiAhVmVsb2NpdHkuU3RhdGUuaXNDaHJvbWUpKSAmJiBkYXRhICYmIGRhdGEuaXNTVkcpIHtcblx0XHRcdFx0XHQvKiBTaW5jZSB0cmFuc2Zvcm0gdmFsdWVzIGFyZSBzdG9yZWQgaW4gdGhlaXIgcGFyZW50aGVzZXMtd3JhcHBlZCBmb3JtLCB3ZSB1c2UgYSBoZWxwZXIgZnVuY3Rpb24gdG8gc3RyaXAgb3V0IHRoZWlyIG51bWVyaWMgdmFsdWVzLlxuXHRcdFx0XHRcdCBGdXJ0aGVyLCBTVkcgdHJhbnNmb3JtIHByb3BlcnRpZXMgb25seSB0YWtlIHVuaXRsZXNzIChyZXByZXNlbnRpbmcgcGl4ZWxzKSB2YWx1ZXMsIHNvIGl0J3Mgb2theSB0aGF0IHBhcnNlRmxvYXQoKSBzdHJpcHMgdGhlIHVuaXQgc3VmZml4ZWQgdG8gdGhlIGZsb2F0IHZhbHVlLiAqL1xuXHRcdFx0XHRcdHZhciBnZXRUcmFuc2Zvcm1GbG9hdCA9IGZ1bmN0aW9uKHRyYW5zZm9ybVByb3BlcnR5KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcGFyc2VGbG9hdChDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCB0cmFuc2Zvcm1Qcm9wZXJ0eSkpO1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHQvKiBDcmVhdGUgYW4gb2JqZWN0IHRvIG9yZ2FuaXplIGFsbCB0aGUgdHJhbnNmb3JtcyB0aGF0IHdlJ2xsIGFwcGx5IHRvIHRoZSBTVkcgZWxlbWVudC4gVG8ga2VlcCB0aGUgbG9naWMgc2ltcGxlLFxuXHRcdFx0XHRcdCB3ZSBwcm9jZXNzICphbGwqIHRyYW5zZm9ybSBwcm9wZXJ0aWVzIC0tIGV2ZW4gdGhvc2UgdGhhdCBtYXkgbm90IGJlIGV4cGxpY2l0bHkgYXBwbGllZCAoc2luY2UgdGhleSBkZWZhdWx0IHRvIHRoZWlyIHplcm8tdmFsdWVzIGFueXdheSkuICovXG5cdFx0XHRcdFx0dmFyIFNWR1RyYW5zZm9ybXMgPSB7XG5cdFx0XHRcdFx0XHR0cmFuc2xhdGU6IFtnZXRUcmFuc2Zvcm1GbG9hdChcInRyYW5zbGF0ZVhcIiksIGdldFRyYW5zZm9ybUZsb2F0KFwidHJhbnNsYXRlWVwiKV0sXG5cdFx0XHRcdFx0XHRza2V3WDogW2dldFRyYW5zZm9ybUZsb2F0KFwic2tld1hcIildLCBza2V3WTogW2dldFRyYW5zZm9ybUZsb2F0KFwic2tld1lcIildLFxuXHRcdFx0XHRcdFx0LyogSWYgdGhlIHNjYWxlIHByb3BlcnR5IGlzIHNldCAobm9uLTEpLCB1c2UgdGhhdCB2YWx1ZSBmb3IgdGhlIHNjYWxlWCBhbmQgc2NhbGVZIHZhbHVlc1xuXHRcdFx0XHRcdFx0ICh0aGlzIGJlaGF2aW9yIG1pbWljcyB0aGUgcmVzdWx0IG9mIGFuaW1hdGluZyBhbGwgdGhlc2UgcHJvcGVydGllcyBhdCBvbmNlIG9uIEhUTUwgZWxlbWVudHMpLiAqL1xuXHRcdFx0XHRcdFx0c2NhbGU6IGdldFRyYW5zZm9ybUZsb2F0KFwic2NhbGVcIikgIT09IDEgPyBbZ2V0VHJhbnNmb3JtRmxvYXQoXCJzY2FsZVwiKSwgZ2V0VHJhbnNmb3JtRmxvYXQoXCJzY2FsZVwiKV0gOiBbZ2V0VHJhbnNmb3JtRmxvYXQoXCJzY2FsZVhcIiksIGdldFRyYW5zZm9ybUZsb2F0KFwic2NhbGVZXCIpXSxcblx0XHRcdFx0XHRcdC8qIE5vdGU6IFNWRydzIHJvdGF0ZSB0cmFuc2Zvcm0gdGFrZXMgdGhyZWUgdmFsdWVzOiByb3RhdGlvbiBkZWdyZWVzIGZvbGxvd2VkIGJ5IHRoZSBYIGFuZCBZIHZhbHVlc1xuXHRcdFx0XHRcdFx0IGRlZmluaW5nIHRoZSByb3RhdGlvbidzIG9yaWdpbiBwb2ludC4gV2UgaWdub3JlIHRoZSBvcmlnaW4gdmFsdWVzIChkZWZhdWx0IHRoZW0gdG8gMCkuICovXG5cdFx0XHRcdFx0XHRyb3RhdGU6IFtnZXRUcmFuc2Zvcm1GbG9hdChcInJvdGF0ZVpcIiksIDAsIDBdXG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdC8qIEl0ZXJhdGUgdGhyb3VnaCB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMgaW4gdGhlIHVzZXItZGVmaW5lZCBwcm9wZXJ0eSBtYXAgb3JkZXIuXG5cdFx0XHRcdFx0IChUaGlzIG1pbWljcyB0aGUgYmVoYXZpb3Igb2Ygbm9uLVNWRyB0cmFuc2Zvcm0gYW5pbWF0aW9uLikgKi9cblx0XHRcdFx0XHQkLmVhY2goRGF0YShlbGVtZW50KS50cmFuc2Zvcm1DYWNoZSwgZnVuY3Rpb24odHJhbnNmb3JtTmFtZSkge1xuXHRcdFx0XHRcdFx0LyogRXhjZXB0IGZvciB3aXRoIHNrZXdYL1ksIHJldmVydCB0aGUgYXhpcy1zcGVjaWZpYyB0cmFuc2Zvcm0gc3VicHJvcGVydGllcyB0byB0aGVpciBheGlzLWZyZWUgbWFzdGVyXG5cdFx0XHRcdFx0XHQgcHJvcGVydGllcyBzbyB0aGF0IHRoZXkgbWF0Y2ggdXAgd2l0aCBTVkcncyBhY2NlcHRlZCB0cmFuc2Zvcm0gcHJvcGVydGllcy4gKi9cblx0XHRcdFx0XHRcdGlmICgvXnRyYW5zbGF0ZS9pLnRlc3QodHJhbnNmb3JtTmFtZSkpIHtcblx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtTmFtZSA9IFwidHJhbnNsYXRlXCI7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKC9ec2NhbGUvaS50ZXN0KHRyYW5zZm9ybU5hbWUpKSB7XG5cdFx0XHRcdFx0XHRcdHRyYW5zZm9ybU5hbWUgPSBcInNjYWxlXCI7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKC9ecm90YXRlL2kudGVzdCh0cmFuc2Zvcm1OYW1lKSkge1xuXHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm1OYW1lID0gXCJyb3RhdGVcIjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyogQ2hlY2sgdGhhdCB3ZSBoYXZlbid0IHlldCBkZWxldGVkIHRoZSBwcm9wZXJ0eSBmcm9tIHRoZSBTVkdUcmFuc2Zvcm1zIGNvbnRhaW5lci4gKi9cblx0XHRcdFx0XHRcdGlmIChTVkdUcmFuc2Zvcm1zW3RyYW5zZm9ybU5hbWVdKSB7XG5cdFx0XHRcdFx0XHRcdC8qIEFwcGVuZCB0aGUgdHJhbnNmb3JtIHByb3BlcnR5IGluIHRoZSBTVkctc3VwcG9ydGVkIHRyYW5zZm9ybSBmb3JtYXQuIEFzIHBlciB0aGUgc3BlYywgc3Vycm91bmQgdGhlIHNwYWNlLWRlbGltaXRlZCB2YWx1ZXMgaW4gcGFyZW50aGVzZXMuICovXG5cdFx0XHRcdFx0XHRcdHRyYW5zZm9ybVN0cmluZyArPSB0cmFuc2Zvcm1OYW1lICsgXCIoXCIgKyBTVkdUcmFuc2Zvcm1zW3RyYW5zZm9ybU5hbWVdLmpvaW4oXCIgXCIpICsgXCIpXCIgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0XHQvKiBBZnRlciBwcm9jZXNzaW5nIGFuIFNWRyB0cmFuc2Zvcm0gcHJvcGVydHksIGRlbGV0ZSBpdCBmcm9tIHRoZSBTVkdUcmFuc2Zvcm1zIGNvbnRhaW5lciBzbyB3ZSBkb24ndFxuXHRcdFx0XHRcdFx0XHQgcmUtaW5zZXJ0IHRoZSBzYW1lIG1hc3RlciBwcm9wZXJ0eSBpZiB3ZSBlbmNvdW50ZXIgYW5vdGhlciBvbmUgb2YgaXRzIGF4aXMtc3BlY2lmaWMgcHJvcGVydGllcy4gKi9cblx0XHRcdFx0XHRcdFx0ZGVsZXRlIFNWR1RyYW5zZm9ybXNbdHJhbnNmb3JtTmFtZV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIHRyYW5zZm9ybVZhbHVlLFxuXHRcdFx0XHRcdFx0XHRwZXJzcGVjdGl2ZTtcblxuXHRcdFx0XHRcdC8qIFRyYW5zZm9ybSBwcm9wZXJ0aWVzIGFyZSBzdG9yZWQgYXMgbWVtYmVycyBvZiB0aGUgdHJhbnNmb3JtQ2FjaGUgb2JqZWN0LiBDb25jYXRlbmF0ZSBhbGwgdGhlIG1lbWJlcnMgaW50byBhIHN0cmluZy4gKi9cblx0XHRcdFx0XHQkLmVhY2goRGF0YShlbGVtZW50KS50cmFuc2Zvcm1DYWNoZSwgZnVuY3Rpb24odHJhbnNmb3JtTmFtZSkge1xuXHRcdFx0XHRcdFx0dHJhbnNmb3JtVmFsdWUgPSBEYXRhKGVsZW1lbnQpLnRyYW5zZm9ybUNhY2hlW3RyYW5zZm9ybU5hbWVdO1xuXG5cdFx0XHRcdFx0XHQvKiBUcmFuc2Zvcm0ncyBwZXJzcGVjdGl2ZSBzdWJwcm9wZXJ0eSBtdXN0IGJlIHNldCBmaXJzdCBpbiBvcmRlciB0byB0YWtlIGVmZmVjdC4gU3RvcmUgaXQgdGVtcG9yYXJpbHkuICovXG5cdFx0XHRcdFx0XHRpZiAodHJhbnNmb3JtTmFtZSA9PT0gXCJ0cmFuc2Zvcm1QZXJzcGVjdGl2ZVwiKSB7XG5cdFx0XHRcdFx0XHRcdHBlcnNwZWN0aXZlID0gdHJhbnNmb3JtVmFsdWU7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBJRTkgb25seSBzdXBwb3J0cyBvbmUgcm90YXRpb24gdHlwZSwgcm90YXRlWiwgd2hpY2ggaXQgcmVmZXJzIHRvIGFzIFwicm90YXRlXCIuICovXG5cdFx0XHRcdFx0XHRpZiAoSUUgPT09IDkgJiYgdHJhbnNmb3JtTmFtZSA9PT0gXCJyb3RhdGVaXCIpIHtcblx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtTmFtZSA9IFwicm90YXRlXCI7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRyYW5zZm9ybVN0cmluZyArPSB0cmFuc2Zvcm1OYW1lICsgdHJhbnNmb3JtVmFsdWUgKyBcIiBcIjtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdC8qIElmIHByZXNlbnQsIHNldCB0aGUgcGVyc3BlY3RpdmUgc3VicHJvcGVydHkgZmlyc3QuICovXG5cdFx0XHRcdFx0aWYgKHBlcnNwZWN0aXZlKSB7XG5cdFx0XHRcdFx0XHR0cmFuc2Zvcm1TdHJpbmcgPSBcInBlcnNwZWN0aXZlXCIgKyBwZXJzcGVjdGl2ZSArIFwiIFwiICsgdHJhbnNmb3JtU3RyaW5nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdENTUy5zZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybVN0cmluZyk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qIFJlZ2lzdGVyIGhvb2tzIGFuZCBub3JtYWxpemF0aW9ucy4gKi9cblx0XHRDU1MuSG9va3MucmVnaXN0ZXIoKTtcblx0XHRDU1MuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXIoKTtcblxuXHRcdC8qIEFsbG93IGhvb2sgc2V0dGluZyBpbiB0aGUgc2FtZSBmYXNoaW9uIGFzIGpRdWVyeSdzICQuY3NzKCkuICovXG5cdFx0VmVsb2NpdHkuaG9vayA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBhcmcyLCBhcmczKSB7XG5cdFx0XHR2YXIgdmFsdWU7XG5cblx0XHRcdGVsZW1lbnRzID0gc2FuaXRpemVFbGVtZW50cyhlbGVtZW50cyk7XG5cblx0XHRcdCQuZWFjaChlbGVtZW50cywgZnVuY3Rpb24oaSwgZWxlbWVudCkge1xuXHRcdFx0XHQvKiBJbml0aWFsaXplIFZlbG9jaXR5J3MgcGVyLWVsZW1lbnQgZGF0YSBjYWNoZSBpZiB0aGlzIGVsZW1lbnQgaGFzbid0IHByZXZpb3VzbHkgYmVlbiBhbmltYXRlZC4gKi9cblx0XHRcdFx0aWYgKERhdGEoZWxlbWVudCkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFZlbG9jaXR5LmluaXQoZWxlbWVudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBHZXQgcHJvcGVydHkgdmFsdWUuIElmIGFuIGVsZW1lbnQgc2V0IHdhcyBwYXNzZWQgaW4sIG9ubHkgcmV0dXJuIHRoZSB2YWx1ZSBmb3IgdGhlIGZpcnN0IGVsZW1lbnQuICovXG5cdFx0XHRcdGlmIChhcmczID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBhcmcyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0LyogU2V0IHByb3BlcnR5IHZhbHVlLiAqL1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8qIHNQViByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBub3JtYWxpemVkIHByb3BlcnR5TmFtZS9wcm9wZXJ0eVZhbHVlIHBhaXIgdXNlZCB0byB1cGRhdGUgdGhlIERPTS4gKi9cblx0XHRcdFx0XHR2YXIgYWRqdXN0ZWRTZXQgPSBDU1Muc2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBhcmcyLCBhcmczKTtcblxuXHRcdFx0XHRcdC8qIFRyYW5zZm9ybSBwcm9wZXJ0aWVzIGRvbid0IGF1dG9tYXRpY2FsbHkgc2V0LiBUaGV5IGhhdmUgdG8gYmUgZmx1c2hlZCB0byB0aGUgRE9NLiAqL1xuXHRcdFx0XHRcdGlmIChhZGp1c3RlZFNldFswXSA9PT0gXCJ0cmFuc2Zvcm1cIikge1xuXHRcdFx0XHRcdFx0VmVsb2NpdHkuQ1NTLmZsdXNoVHJhbnNmb3JtQ2FjaGUoZWxlbWVudCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFsdWUgPSBhZGp1c3RlZFNldDtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9O1xuXG5cdFx0LyoqKioqKioqKioqKioqKioqXG5cdFx0IEFuaW1hdGlvblxuXHRcdCAqKioqKioqKioqKioqKioqKi9cblxuXHRcdHZhciBhbmltYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb3B0cztcblxuXHRcdFx0LyoqKioqKioqKioqKioqKioqKlxuXHRcdFx0IENhbGwgQ2hhaW5cblx0XHRcdCAqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdC8qIExvZ2ljIGZvciBkZXRlcm1pbmluZyB3aGF0IHRvIHJldHVybiB0byB0aGUgY2FsbCBzdGFjayB3aGVuIGV4aXRpbmcgb3V0IG9mIFZlbG9jaXR5LiAqL1xuXHRcdFx0ZnVuY3Rpb24gZ2V0Q2hhaW4oKSB7XG5cdFx0XHRcdC8qIElmIHdlIGFyZSB1c2luZyB0aGUgdXRpbGl0eSBmdW5jdGlvbiwgYXR0ZW1wdCB0byByZXR1cm4gdGhpcyBjYWxsJ3MgcHJvbWlzZS4gSWYgbm8gcHJvbWlzZSBsaWJyYXJ5IHdhcyBkZXRlY3RlZCxcblx0XHRcdFx0IGRlZmF1bHQgdG8gbnVsbCBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGUgdGFyZ2V0ZWQgZWxlbWVudHMgc28gdGhhdCB1dGlsaXR5IGZ1bmN0aW9uJ3MgcmV0dXJuIHZhbHVlIGlzIHN0YW5kYXJkaXplZC4gKi9cblx0XHRcdFx0aWYgKGlzVXRpbGl0eSkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9taXNlRGF0YS5wcm9taXNlIHx8IG51bGw7XG5cdFx0XHRcdFx0LyogT3RoZXJ3aXNlLCBpZiB3ZSdyZSB1c2luZyAkLmZuLCByZXR1cm4gdGhlIGpRdWVyeS0vWmVwdG8td3JhcHBlZCBlbGVtZW50IHNldC4gKi9cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbWVudHNXcmFwcGVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHQgQXJndW1lbnRzIEFzc2lnbm1lbnRcblx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHQvKiBUbyBhbGxvdyBmb3IgZXhwcmVzc2l2ZSBDb2ZmZWVTY3JpcHQgY29kZSwgVmVsb2NpdHkgc3VwcG9ydHMgYW4gYWx0ZXJuYXRpdmUgc3ludGF4IGluIHdoaWNoIFwiZWxlbWVudHNcIiAob3IgXCJlXCIpLCBcInByb3BlcnRpZXNcIiAob3IgXCJwXCIpLCBhbmQgXCJvcHRpb25zXCIgKG9yIFwib1wiKVxuXHRcdFx0IG9iamVjdHMgYXJlIGRlZmluZWQgb24gYSBjb250YWluZXIgb2JqZWN0IHRoYXQncyBwYXNzZWQgaW4gYXMgVmVsb2NpdHkncyBzb2xlIGFyZ3VtZW50LiAqL1xuXHRcdFx0LyogTm90ZTogU29tZSBicm93c2VycyBhdXRvbWF0aWNhbGx5IHBvcHVsYXRlIGFyZ3VtZW50cyB3aXRoIGEgXCJwcm9wZXJ0aWVzXCIgb2JqZWN0LiBXZSBkZXRlY3QgaXQgYnkgY2hlY2tpbmcgZm9yIGl0cyBkZWZhdWx0IFwibmFtZXNcIiBwcm9wZXJ0eS4gKi9cblx0XHRcdHZhciBzeW50YWN0aWNTdWdhciA9IChhcmd1bWVudHNbMF0gJiYgKGFyZ3VtZW50c1swXS5wIHx8ICgoJC5pc1BsYWluT2JqZWN0KGFyZ3VtZW50c1swXS5wcm9wZXJ0aWVzKSAmJiAhYXJndW1lbnRzWzBdLnByb3BlcnRpZXMubmFtZXMpIHx8IFR5cGUuaXNTdHJpbmcoYXJndW1lbnRzWzBdLnByb3BlcnRpZXMpKSkpLFxuXHRcdFx0XHRcdC8qIFdoZXRoZXIgVmVsb2NpdHkgd2FzIGNhbGxlZCB2aWEgdGhlIHV0aWxpdHkgZnVuY3Rpb24gKGFzIG9wcG9zZWQgdG8gb24gYSBqUXVlcnkvWmVwdG8gb2JqZWN0KS4gKi9cblx0XHRcdFx0XHRpc1V0aWxpdHksXG5cdFx0XHRcdFx0LyogV2hlbiBWZWxvY2l0eSBpcyBjYWxsZWQgdmlhIHRoZSB1dGlsaXR5IGZ1bmN0aW9uICgkLlZlbG9jaXR5KCkvVmVsb2NpdHkoKSksIGVsZW1lbnRzIGFyZSBleHBsaWNpdGx5XG5cdFx0XHRcdFx0IHBhc3NlZCBpbiBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyLiBUaHVzLCBhcmd1bWVudCBwb3NpdGlvbmluZyB2YXJpZXMuIFdlIG5vcm1hbGl6ZSB0aGVtIGhlcmUuICovXG5cdFx0XHRcdFx0ZWxlbWVudHNXcmFwcGVkLFxuXHRcdFx0XHRcdGFyZ3VtZW50SW5kZXg7XG5cblx0XHRcdHZhciBlbGVtZW50cyxcblx0XHRcdFx0XHRwcm9wZXJ0aWVzTWFwLFxuXHRcdFx0XHRcdG9wdGlvbnM7XG5cblx0XHRcdC8qIERldGVjdCBqUXVlcnkvWmVwdG8gZWxlbWVudHMgYmVpbmcgYW5pbWF0ZWQgdmlhIHRoZSAkLmZuIG1ldGhvZC4gKi9cblx0XHRcdGlmIChUeXBlLmlzV3JhcHBlZCh0aGlzKSkge1xuXHRcdFx0XHRpc1V0aWxpdHkgPSBmYWxzZTtcblxuXHRcdFx0XHRhcmd1bWVudEluZGV4ID0gMDtcblx0XHRcdFx0ZWxlbWVudHMgPSB0aGlzO1xuXHRcdFx0XHRlbGVtZW50c1dyYXBwZWQgPSB0aGlzO1xuXHRcdFx0XHQvKiBPdGhlcndpc2UsIHJhdyBlbGVtZW50cyBhcmUgYmVpbmcgYW5pbWF0ZWQgdmlhIHRoZSB1dGlsaXR5IGZ1bmN0aW9uLiAqL1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aXNVdGlsaXR5ID0gdHJ1ZTtcblxuXHRcdFx0XHRhcmd1bWVudEluZGV4ID0gMTtcblx0XHRcdFx0ZWxlbWVudHMgPSBzeW50YWN0aWNTdWdhciA/IChhcmd1bWVudHNbMF0uZWxlbWVudHMgfHwgYXJndW1lbnRzWzBdLmUpIDogYXJndW1lbnRzWzBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvKioqKioqKioqKioqKioqXG5cdFx0XHQgUHJvbWlzZXNcblx0XHRcdCAqKioqKioqKioqKioqKiovXG5cblx0XHRcdHZhciBwcm9taXNlRGF0YSA9IHtcblx0XHRcdFx0cHJvbWlzZTogbnVsbCxcblx0XHRcdFx0cmVzb2x2ZXI6IG51bGwsXG5cdFx0XHRcdHJlamVjdGVyOiBudWxsXG5cdFx0XHR9O1xuXG5cdFx0XHQvKiBJZiB0aGlzIGNhbGwgd2FzIG1hZGUgdmlhIHRoZSB1dGlsaXR5IGZ1bmN0aW9uICh3aGljaCBpcyB0aGUgZGVmYXVsdCBtZXRob2Qgb2YgaW52b2NhdGlvbiB3aGVuIGpRdWVyeS9aZXB0byBhcmUgbm90IGJlaW5nIHVzZWQpLCBhbmQgaWZcblx0XHRcdCBwcm9taXNlIHN1cHBvcnQgd2FzIGRldGVjdGVkLCBjcmVhdGUgYSBwcm9taXNlIG9iamVjdCBmb3IgdGhpcyBjYWxsIGFuZCBzdG9yZSByZWZlcmVuY2VzIHRvIGl0cyByZXNvbHZlciBhbmQgcmVqZWN0ZXIgbWV0aG9kcy4gVGhlIHJlc29sdmVcblx0XHRcdCBtZXRob2QgaXMgdXNlZCB3aGVuIGEgY2FsbCBjb21wbGV0ZXMgbmF0dXJhbGx5IG9yIGlzIHByZW1hdHVyZWx5IHN0b3BwZWQgYnkgdGhlIHVzZXIuIEluIGJvdGggY2FzZXMsIGNvbXBsZXRlQ2FsbCgpIGhhbmRsZXMgdGhlIGFzc29jaWF0ZWRcblx0XHRcdCBjYWxsIGNsZWFudXAgYW5kIHByb21pc2UgcmVzb2x2aW5nIGxvZ2ljLiBUaGUgcmVqZWN0IG1ldGhvZCBpcyB1c2VkIHdoZW4gYW4gaW52YWxpZCBzZXQgb2YgYXJndW1lbnRzIGlzIHBhc3NlZCBpbnRvIGEgVmVsb2NpdHkgY2FsbC4gKi9cblx0XHRcdC8qIE5vdGU6IFZlbG9jaXR5IGVtcGxveXMgYSBjYWxsLWJhc2VkIHF1ZXVlaW5nIGFyY2hpdGVjdHVyZSwgd2hpY2ggbWVhbnMgdGhhdCBzdG9wcGluZyBhbiBhbmltYXRpbmcgZWxlbWVudCBhY3R1YWxseSBzdG9wcyB0aGUgZnVsbCBjYWxsIHRoYXRcblx0XHRcdCB0cmlnZ2VyZWQgaXQgLS0gbm90IHRoYXQgb25lIGVsZW1lbnQgZXhjbHVzaXZlbHkuIFNpbWlsYXJseSwgdGhlcmUgaXMgb25lIHByb21pc2UgcGVyIGNhbGwsIGFuZCBhbGwgZWxlbWVudHMgdGFyZ2V0ZWQgYnkgYSBWZWxvY2l0eSBjYWxsIGFyZVxuXHRcdFx0IGdyb3VwZWQgdG9nZXRoZXIgZm9yIHRoZSBwdXJwb3NlcyBvZiByZXNvbHZpbmcgYW5kIHJlamVjdGluZyBhIHByb21pc2UuICovXG5cdFx0XHRpZiAoaXNVdGlsaXR5ICYmIFZlbG9jaXR5LlByb21pc2UpIHtcblx0XHRcdFx0cHJvbWlzZURhdGEucHJvbWlzZSA9IG5ldyBWZWxvY2l0eS5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0XHRcdHByb21pc2VEYXRhLnJlc29sdmVyID0gcmVzb2x2ZTtcblx0XHRcdFx0XHRwcm9taXNlRGF0YS5yZWplY3RlciA9IHJlamVjdDtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzeW50YWN0aWNTdWdhcikge1xuXHRcdFx0XHRwcm9wZXJ0aWVzTWFwID0gYXJndW1lbnRzWzBdLnByb3BlcnRpZXMgfHwgYXJndW1lbnRzWzBdLnA7XG5cdFx0XHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbMF0ub3B0aW9ucyB8fCBhcmd1bWVudHNbMF0ubztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHByb3BlcnRpZXNNYXAgPSBhcmd1bWVudHNbYXJndW1lbnRJbmRleF07XG5cdFx0XHRcdG9wdGlvbnMgPSBhcmd1bWVudHNbYXJndW1lbnRJbmRleCArIDFdO1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtZW50cyA9IHNhbml0aXplRWxlbWVudHMoZWxlbWVudHMpO1xuXG5cdFx0XHRpZiAoIWVsZW1lbnRzKSB7XG5cdFx0XHRcdGlmIChwcm9taXNlRGF0YS5wcm9taXNlKSB7XG5cdFx0XHRcdFx0aWYgKCFwcm9wZXJ0aWVzTWFwIHx8ICFvcHRpb25zIHx8IG9wdGlvbnMucHJvbWlzZVJlamVjdEVtcHR5ICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0cHJvbWlzZURhdGEucmVqZWN0ZXIoKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHJvbWlzZURhdGEucmVzb2x2ZXIoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBUaGUgbGVuZ3RoIG9mIHRoZSBlbGVtZW50IHNldCAoaW4gdGhlIGZvcm0gb2YgYSBub2RlTGlzdCBvciBhbiBhcnJheSBvZiBlbGVtZW50cykgaXMgZGVmYXVsdGVkIHRvIDEgaW4gY2FzZSBhXG5cdFx0XHQgc2luZ2xlIHJhdyBET00gZWxlbWVudCBpcyBwYXNzZWQgaW4gKHdoaWNoIGRvZXNuJ3QgY29udGFpbiBhIGxlbmd0aCBwcm9wZXJ0eSkuICovXG5cdFx0XHR2YXIgZWxlbWVudHNMZW5ndGggPSBlbGVtZW50cy5sZW5ndGgsXG5cdFx0XHRcdFx0ZWxlbWVudHNJbmRleCA9IDA7XG5cblx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdCBBcmd1bWVudCBPdmVybG9hZGluZ1xuXHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0LyogU3VwcG9ydCBpcyBpbmNsdWRlZCBmb3IgalF1ZXJ5J3MgYXJndW1lbnQgb3ZlcmxvYWRpbmc6ICQuYW5pbWF0ZShwcm9wZXJ0eU1hcCBbLCBkdXJhdGlvbl0gWywgZWFzaW5nXSBbLCBjb21wbGV0ZV0pLlxuXHRcdFx0IE92ZXJsb2FkaW5nIGlzIGRldGVjdGVkIGJ5IGNoZWNraW5nIGZvciB0aGUgYWJzZW5jZSBvZiBhbiBvYmplY3QgYmVpbmcgcGFzc2VkIGludG8gb3B0aW9ucy4gKi9cblx0XHRcdC8qIE5vdGU6IFRoZSBzdG9wL2ZpbmlzaC9wYXVzZS9yZXN1bWUgYWN0aW9ucyBkbyBub3QgYWNjZXB0IGFuaW1hdGlvbiBvcHRpb25zLCBhbmQgYXJlIHRoZXJlZm9yZSBleGNsdWRlZCBmcm9tIHRoaXMgY2hlY2suICovXG5cdFx0XHRpZiAoIS9eKHN0b3B8ZmluaXNofGZpbmlzaEFsbHxwYXVzZXxyZXN1bWUpJC9pLnRlc3QocHJvcGVydGllc01hcCkgJiYgISQuaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuXHRcdFx0XHQvKiBUaGUgdXRpbGl0eSBmdW5jdGlvbiBzaGlmdHMgYWxsIGFyZ3VtZW50cyBvbmUgcG9zaXRpb24gdG8gdGhlIHJpZ2h0LCBzbyB3ZSBhZGp1c3QgZm9yIHRoYXQgb2Zmc2V0LiAqL1xuXHRcdFx0XHR2YXIgc3RhcnRpbmdBcmd1bWVudFBvc2l0aW9uID0gYXJndW1lbnRJbmRleCArIDE7XG5cblx0XHRcdFx0b3B0aW9ucyA9IHt9O1xuXG5cdFx0XHRcdC8qIEl0ZXJhdGUgdGhyb3VnaCBhbGwgb3B0aW9ucyBhcmd1bWVudHMgKi9cblx0XHRcdFx0Zm9yICh2YXIgaSA9IHN0YXJ0aW5nQXJndW1lbnRQb3NpdGlvbjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdC8qIFRyZWF0IGEgbnVtYmVyIGFzIGEgZHVyYXRpb24uIFBhcnNlIGl0IG91dC4gKi9cblx0XHRcdFx0XHQvKiBOb3RlOiBUaGUgZm9sbG93aW5nIFJlZ0V4IHdpbGwgcmV0dXJuIHRydWUgaWYgcGFzc2VkIGFuIGFycmF5IHdpdGggYSBudW1iZXIgYXMgaXRzIGZpcnN0IGl0ZW0uXG5cdFx0XHRcdFx0IFRodXMsIGFycmF5cyBhcmUgc2tpcHBlZCBmcm9tIHRoaXMgY2hlY2suICovXG5cdFx0XHRcdFx0aWYgKCFUeXBlLmlzQXJyYXkoYXJndW1lbnRzW2ldKSAmJiAoL14oZmFzdHxub3JtYWx8c2xvdykkL2kudGVzdChhcmd1bWVudHNbaV0pIHx8IC9eXFxkLy50ZXN0KGFyZ3VtZW50c1tpXSkpKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25zLmR1cmF0aW9uID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRcdFx0LyogVHJlYXQgc3RyaW5ncyBhbmQgYXJyYXlzIGFzIGVhc2luZ3MuICovXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChUeXBlLmlzU3RyaW5nKGFyZ3VtZW50c1tpXSkgfHwgVHlwZS5pc0FycmF5KGFyZ3VtZW50c1tpXSkpIHtcblx0XHRcdFx0XHRcdG9wdGlvbnMuZWFzaW5nID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRcdFx0LyogVHJlYXQgYSBmdW5jdGlvbiBhcyBhIGNvbXBsZXRlIGNhbGxiYWNrLiAqL1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoVHlwZS5pc0Z1bmN0aW9uKGFyZ3VtZW50c1tpXSkpIHtcblx0XHRcdFx0XHRcdG9wdGlvbnMuY29tcGxldGUgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8qKioqKioqKioqKioqKioqKioqKipcblx0XHRcdCBBY3Rpb24gRGV0ZWN0aW9uXG5cdFx0XHQgKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHQvKiBWZWxvY2l0eSdzIGJlaGF2aW9yIGlzIGNhdGVnb3JpemVkIGludG8gXCJhY3Rpb25zXCI6IEVsZW1lbnRzIGNhbiBlaXRoZXIgYmUgc3BlY2lhbGx5IHNjcm9sbGVkIGludG8gdmlldyxcblx0XHRcdCBvciB0aGV5IGNhbiBiZSBzdGFydGVkLCBzdG9wcGVkLCBwYXVzZWQsIHJlc3VtZWQsIG9yIHJldmVyc2VkIC4gSWYgYSBsaXRlcmFsIG9yIHJlZmVyZW5jZWQgcHJvcGVydGllcyBtYXAgaXMgcGFzc2VkIGluIGFzIFZlbG9jaXR5J3Ncblx0XHRcdCBmaXJzdCBhcmd1bWVudCwgdGhlIGFzc29jaWF0ZWQgYWN0aW9uIGlzIFwic3RhcnRcIi4gQWx0ZXJuYXRpdmVseSwgXCJzY3JvbGxcIiwgXCJyZXZlcnNlXCIsIFwicGF1c2VcIiwgXCJyZXN1bWVcIiBvciBcInN0b3BcIiBjYW4gYmUgcGFzc2VkIGluIFxuXHRcdFx0IGluc3RlYWQgb2YgYSBwcm9wZXJ0aWVzIG1hcC4gKi9cblx0XHRcdHZhciBhY3Rpb247XG5cblx0XHRcdHN3aXRjaCAocHJvcGVydGllc01hcCkge1xuXHRcdFx0XHRjYXNlIFwic2Nyb2xsXCI6XG5cdFx0XHRcdFx0YWN0aW9uID0gXCJzY3JvbGxcIjtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFwicmV2ZXJzZVwiOlxuXHRcdFx0XHRcdGFjdGlvbiA9IFwicmV2ZXJzZVwiO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgXCJwYXVzZVwiOlxuXG5cdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHQgQWN0aW9uOiBQYXVzZVxuXHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuXHRcdFx0XHRcdC8qIEhhbmRsZSBkZWxheSB0aW1lcnMgKi9cblx0XHRcdFx0XHQkLmVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGksIGVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdHBhdXNlRGVsYXlPbkVsZW1lbnQoZWxlbWVudCwgY3VycmVudFRpbWUpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0LyogUGF1c2UgYW5kIFJlc3VtZSBhcmUgY2FsbC13aWRlIChub3Qgb24gYSBwZXIgZWxlbWVudCBiYXNpcykuIFRodXMsIGNhbGxpbmcgcGF1c2Ugb3IgcmVzdW1lIG9uIGEgXG5cdFx0XHRcdFx0IHNpbmdsZSBlbGVtZW50IHdpbGwgY2F1c2UgYW55IGNhbGxzIHRoYXQgY29udGFpbnQgdHdlZW5zIGZvciB0aGF0IGVsZW1lbnQgdG8gYmUgcGF1c2VkL3Jlc3VtZWRcblx0XHRcdFx0XHQgYXMgd2VsbC4gKi9cblxuXHRcdFx0XHRcdC8qIEl0ZXJhdGUgdGhyb3VnaCBhbGwgY2FsbHMgYW5kIHBhdXNlIGFueSB0aGF0IGNvbnRhaW4gYW55IG9mIG91ciBlbGVtZW50cyAqL1xuXHRcdFx0XHRcdCQuZWFjaChWZWxvY2l0eS5TdGF0ZS5jYWxscywgZnVuY3Rpb24oaSwgYWN0aXZlQ2FsbCkge1xuXG5cdFx0XHRcdFx0XHR2YXIgZm91bmQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdC8qIEluYWN0aXZlIGNhbGxzIGFyZSBzZXQgdG8gZmFsc2UgYnkgdGhlIGxvZ2ljIGluc2lkZSBjb21wbGV0ZUNhbGwoKS4gU2tpcCB0aGVtLiAqL1xuXHRcdFx0XHRcdFx0aWYgKGFjdGl2ZUNhbGwpIHtcblx0XHRcdFx0XHRcdFx0LyogSXRlcmF0ZSB0aHJvdWdoIHRoZSBhY3RpdmUgY2FsbCdzIHRhcmdldGVkIGVsZW1lbnRzLiAqL1xuXHRcdFx0XHRcdFx0XHQkLmVhY2goYWN0aXZlQ2FsbFsxXSwgZnVuY3Rpb24oaywgYWN0aXZlRWxlbWVudCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBxdWV1ZU5hbWUgPSAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSA/IFwiXCIgOiBvcHRpb25zO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHF1ZXVlTmFtZSAhPT0gdHJ1ZSAmJiAoYWN0aXZlQ2FsbFsyXS5xdWV1ZSAhPT0gcXVldWVOYW1lKSAmJiAhKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiBhY3RpdmVDYWxsWzJdLnF1ZXVlID09PSBmYWxzZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdC8qIEl0ZXJhdGUgdGhyb3VnaCB0aGUgY2FsbHMgdGFyZ2V0ZWQgYnkgdGhlIHN0b3AgY29tbWFuZC4gKi9cblx0XHRcdFx0XHRcdFx0XHQkLmVhY2goZWxlbWVudHMsIGZ1bmN0aW9uKGwsIGVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8qIENoZWNrIHRoYXQgdGhpcyBjYWxsIHdhcyBhcHBsaWVkIHRvIHRoZSB0YXJnZXQgZWxlbWVudC4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChlbGVtZW50ID09PSBhY3RpdmVFbGVtZW50KSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogU2V0IGNhbGwgdG8gcGF1c2VkICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFjdGl2ZUNhbGxbNV0gPSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzdW1lOiBmYWxzZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIE9uY2Ugd2UgbWF0Y2ggYW4gZWxlbWVudCwgd2UgY2FuIGJvdW5jZSBvdXQgdG8gdGhlIG5leHQgY2FsbCBlbnRpcmVseSAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0XHRcdC8qIFByb2NlZWQgdG8gY2hlY2sgbmV4dCBjYWxsIGlmIHdlIGhhdmUgYWxyZWFkeSBtYXRjaGVkICovXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGZvdW5kKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0LyogU2luY2UgcGF1c2UgY3JlYXRlcyBubyBuZXcgdHdlZW5zLCBleGl0IG91dCBvZiBWZWxvY2l0eS4gKi9cblx0XHRcdFx0XHRyZXR1cm4gZ2V0Q2hhaW4oKTtcblxuXHRcdFx0XHRjYXNlIFwicmVzdW1lXCI6XG5cblx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdCBBY3Rpb246IFJlc3VtZVxuXHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0LyogSGFuZGxlIGRlbGF5IHRpbWVycyAqL1xuXHRcdFx0XHRcdCQuZWFjaChlbGVtZW50cywgZnVuY3Rpb24oaSwgZWxlbWVudCkge1xuXHRcdFx0XHRcdFx0cmVzdW1lRGVsYXlPbkVsZW1lbnQoZWxlbWVudCwgY3VycmVudFRpbWUpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0LyogUGF1c2UgYW5kIFJlc3VtZSBhcmUgY2FsbC13aWRlIChub3Qgb24gYSBwZXIgZWxlbW50IGJhc2lzKS4gVGh1cywgY2FsbGluZyBwYXVzZSBvciByZXN1bWUgb24gYSBcblx0XHRcdFx0XHQgc2luZ2xlIGVsZW1lbnQgd2lsbCBjYXVzZSBhbnkgY2FsbHMgdGhhdCBjb250YWludCB0d2VlbnMgZm9yIHRoYXQgZWxlbWVudCB0byBiZSBwYXVzZWQvcmVzdW1lZFxuXHRcdFx0XHRcdCBhcyB3ZWxsLiAqL1xuXG5cdFx0XHRcdFx0LyogSXRlcmF0ZSB0aHJvdWdoIGFsbCBjYWxscyBhbmQgcGF1c2UgYW55IHRoYXQgY29udGFpbiBhbnkgb2Ygb3VyIGVsZW1lbnRzICovXG5cdFx0XHRcdFx0JC5lYWNoKFZlbG9jaXR5LlN0YXRlLmNhbGxzLCBmdW5jdGlvbihpLCBhY3RpdmVDYWxsKSB7XG5cdFx0XHRcdFx0XHR2YXIgZm91bmQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdC8qIEluYWN0aXZlIGNhbGxzIGFyZSBzZXQgdG8gZmFsc2UgYnkgdGhlIGxvZ2ljIGluc2lkZSBjb21wbGV0ZUNhbGwoKS4gU2tpcCB0aGVtLiAqL1xuXHRcdFx0XHRcdFx0aWYgKGFjdGl2ZUNhbGwpIHtcblx0XHRcdFx0XHRcdFx0LyogSXRlcmF0ZSB0aHJvdWdoIHRoZSBhY3RpdmUgY2FsbCdzIHRhcmdldGVkIGVsZW1lbnRzLiAqL1xuXHRcdFx0XHRcdFx0XHQkLmVhY2goYWN0aXZlQ2FsbFsxXSwgZnVuY3Rpb24oaywgYWN0aXZlRWxlbWVudCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBxdWV1ZU5hbWUgPSAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSA/IFwiXCIgOiBvcHRpb25zO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHF1ZXVlTmFtZSAhPT0gdHJ1ZSAmJiAoYWN0aXZlQ2FsbFsyXS5xdWV1ZSAhPT0gcXVldWVOYW1lKSAmJiAhKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiBhY3RpdmVDYWxsWzJdLnF1ZXVlID09PSBmYWxzZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdC8qIFNraXAgYW55IGNhbGxzIHRoYXQgaGF2ZSBuZXZlciBiZWVuIHBhdXNlZCAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmICghYWN0aXZlQ2FsbFs1XSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0LyogSXRlcmF0ZSB0aHJvdWdoIHRoZSBjYWxscyB0YXJnZXRlZCBieSB0aGUgc3RvcCBjb21tYW5kLiAqL1xuXHRcdFx0XHRcdFx0XHRcdCQuZWFjaChlbGVtZW50cywgZnVuY3Rpb24obCwgZWxlbWVudCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0LyogQ2hlY2sgdGhhdCB0aGlzIGNhbGwgd2FzIGFwcGxpZWQgdG8gdGhlIHRhcmdldCBlbGVtZW50LiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGVsZW1lbnQgPT09IGFjdGl2ZUVsZW1lbnQpIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBGbGFnIGEgcGF1c2Ugb2JqZWN0IHRvIGJlIHJlc3VtZWQsIHdoaWNoIHdpbGwgb2NjdXIgZHVyaW5nIHRoZSBuZXh0IHRpY2suIEluXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCBhZGRpdGlvbiwgdGhlIHBhdXNlIG9iamVjdCB3aWxsIGF0IHRoYXQgdGltZSBiZSBkZWxldGVkICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFjdGl2ZUNhbGxbNV0ucmVzdW1lID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBPbmNlIHdlIG1hdGNoIGFuIGVsZW1lbnQsIHdlIGNhbiBib3VuY2Ugb3V0IHRvIHRoZSBuZXh0IGNhbGwgZW50aXJlbHkgKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm91bmQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvKiBQcm9jZWVkIHRvIGNoZWNrIG5leHQgY2FsbCBpZiB3ZSBoYXZlIGFscmVhZHkgbWF0Y2hlZCAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmIChmb3VuZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdC8qIFNpbmNlIHJlc3VtZSBjcmVhdGVzIG5vIG5ldyB0d2VlbnMsIGV4aXQgb3V0IG9mIFZlbG9jaXR5LiAqL1xuXHRcdFx0XHRcdHJldHVybiBnZXRDaGFpbigpO1xuXG5cdFx0XHRcdGNhc2UgXCJmaW5pc2hcIjpcblx0XHRcdFx0Y2FzZSBcImZpbmlzaEFsbFwiOlxuXHRcdFx0XHRjYXNlIFwic3RvcFwiOlxuXHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0IEFjdGlvbjogU3RvcFxuXHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0LyogQ2xlYXIgdGhlIGN1cnJlbnRseS1hY3RpdmUgZGVsYXkgb24gZWFjaCB0YXJnZXRlZCBlbGVtZW50LiAqL1xuXHRcdFx0XHRcdCQuZWFjaChlbGVtZW50cywgZnVuY3Rpb24oaSwgZWxlbWVudCkge1xuXHRcdFx0XHRcdFx0aWYgKERhdGEoZWxlbWVudCkgJiYgRGF0YShlbGVtZW50KS5kZWxheVRpbWVyKSB7XG5cdFx0XHRcdFx0XHRcdC8qIFN0b3AgdGhlIHRpbWVyIGZyb20gdHJpZ2dlcmluZyBpdHMgY2FjaGVkIG5leHQoKSBmdW5jdGlvbi4gKi9cblx0XHRcdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KERhdGEoZWxlbWVudCkuZGVsYXlUaW1lci5zZXRUaW1lb3V0KTtcblxuXHRcdFx0XHRcdFx0XHQvKiBNYW51YWxseSBjYWxsIHRoZSBuZXh0KCkgZnVuY3Rpb24gc28gdGhhdCB0aGUgc3Vic2VxdWVudCBxdWV1ZSBpdGVtcyBjYW4gcHJvZ3Jlc3MuICovXG5cdFx0XHRcdFx0XHRcdGlmIChEYXRhKGVsZW1lbnQpLmRlbGF5VGltZXIubmV4dCkge1xuXHRcdFx0XHRcdFx0XHRcdERhdGEoZWxlbWVudCkuZGVsYXlUaW1lci5uZXh0KCk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRkZWxldGUgRGF0YShlbGVtZW50KS5kZWxheVRpbWVyO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBJZiB3ZSB3YW50IHRvIGZpbmlzaCBldmVyeXRoaW5nIGluIHRoZSBxdWV1ZSwgd2UgaGF2ZSB0byBpdGVyYXRlIHRocm91Z2ggaXRcblx0XHRcdFx0XHRcdCBhbmQgY2FsbCBlYWNoIGZ1bmN0aW9uLiBUaGlzIHdpbGwgbWFrZSB0aGVtIGFjdGl2ZSBjYWxscyBiZWxvdywgd2hpY2ggd2lsbFxuXHRcdFx0XHRcdFx0IGNhdXNlIHRoZW0gdG8gYmUgYXBwbGllZCB2aWEgdGhlIGR1cmF0aW9uIHNldHRpbmcuICovXG5cdFx0XHRcdFx0XHRpZiAocHJvcGVydGllc01hcCA9PT0gXCJmaW5pc2hBbGxcIiAmJiAob3B0aW9ucyA9PT0gdHJ1ZSB8fCBUeXBlLmlzU3RyaW5nKG9wdGlvbnMpKSkge1xuXHRcdFx0XHRcdFx0XHQvKiBJdGVyYXRlIHRocm91Z2ggdGhlIGl0ZW1zIGluIHRoZSBlbGVtZW50J3MgcXVldWUuICovXG5cdFx0XHRcdFx0XHRcdCQuZWFjaCgkLnF1ZXVlKGVsZW1lbnQsIFR5cGUuaXNTdHJpbmcob3B0aW9ucykgPyBvcHRpb25zIDogXCJcIiksIGZ1bmN0aW9uKF8sIGl0ZW0pIHtcblx0XHRcdFx0XHRcdFx0XHQvKiBUaGUgcXVldWUgYXJyYXkgY2FuIGNvbnRhaW4gYW4gXCJpbnByb2dyZXNzXCIgc3RyaW5nLCB3aGljaCB3ZSBza2lwLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmIChUeXBlLmlzRnVuY3Rpb24oaXRlbSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGl0ZW0oKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRcdC8qIENsZWFyaW5nIHRoZSAkLnF1ZXVlKCkgYXJyYXkgaXMgYWNoaWV2ZWQgYnkgcmVzZXR0aW5nIGl0IHRvIFtdLiAqL1xuXHRcdFx0XHRcdFx0XHQkLnF1ZXVlKGVsZW1lbnQsIFR5cGUuaXNTdHJpbmcob3B0aW9ucykgPyBvcHRpb25zIDogXCJcIiwgW10pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0dmFyIGNhbGxzVG9TdG9wID0gW107XG5cblx0XHRcdFx0XHQvKiBXaGVuIHRoZSBzdG9wIGFjdGlvbiBpcyB0cmlnZ2VyZWQsIHRoZSBlbGVtZW50cycgY3VycmVudGx5IGFjdGl2ZSBjYWxsIGlzIGltbWVkaWF0ZWx5IHN0b3BwZWQuIFRoZSBhY3RpdmUgY2FsbCBtaWdodCBoYXZlXG5cdFx0XHRcdFx0IGJlZW4gYXBwbGllZCB0byBtdWx0aXBsZSBlbGVtZW50cywgaW4gd2hpY2ggY2FzZSBhbGwgb2YgdGhlIGNhbGwncyBlbGVtZW50cyB3aWxsIGJlIHN0b3BwZWQuIFdoZW4gYW4gZWxlbWVudFxuXHRcdFx0XHRcdCBpcyBzdG9wcGVkLCB0aGUgbmV4dCBpdGVtIGluIGl0cyBhbmltYXRpb24gcXVldWUgaXMgaW1tZWRpYXRlbHkgdHJpZ2dlcmVkLiAqL1xuXHRcdFx0XHRcdC8qIEFuIGFkZGl0aW9uYWwgYXJndW1lbnQgbWF5IGJlIHBhc3NlZCBpbiB0byBjbGVhciBhbiBlbGVtZW50J3MgcmVtYWluaW5nIHF1ZXVlZCBjYWxscy4gRWl0aGVyIHRydWUgKHdoaWNoIGRlZmF1bHRzIHRvIHRoZSBcImZ4XCIgcXVldWUpXG5cdFx0XHRcdFx0IG9yIGEgY3VzdG9tIHF1ZXVlIHN0cmluZyBjYW4gYmUgcGFzc2VkIGluLiAqL1xuXHRcdFx0XHRcdC8qIE5vdGU6IFRoZSBzdG9wIGNvbW1hbmQgcnVucyBwcmlvciB0byBWZWxvY2l0eSdzIFF1ZXVlaW5nIHBoYXNlIHNpbmNlIGl0cyBiZWhhdmlvciBpcyBpbnRlbmRlZCB0byB0YWtlIGVmZmVjdCAqaW1tZWRpYXRlbHkqLFxuXHRcdFx0XHRcdCByZWdhcmRsZXNzIG9mIHRoZSBlbGVtZW50J3MgY3VycmVudCBxdWV1ZSBzdGF0ZS4gKi9cblxuXHRcdFx0XHRcdC8qIEl0ZXJhdGUgdGhyb3VnaCBldmVyeSBhY3RpdmUgY2FsbC4gKi9cblx0XHRcdFx0XHQkLmVhY2goVmVsb2NpdHkuU3RhdGUuY2FsbHMsIGZ1bmN0aW9uKGksIGFjdGl2ZUNhbGwpIHtcblx0XHRcdFx0XHRcdC8qIEluYWN0aXZlIGNhbGxzIGFyZSBzZXQgdG8gZmFsc2UgYnkgdGhlIGxvZ2ljIGluc2lkZSBjb21wbGV0ZUNhbGwoKS4gU2tpcCB0aGVtLiAqL1xuXHRcdFx0XHRcdFx0aWYgKGFjdGl2ZUNhbGwpIHtcblx0XHRcdFx0XHRcdFx0LyogSXRlcmF0ZSB0aHJvdWdoIHRoZSBhY3RpdmUgY2FsbCdzIHRhcmdldGVkIGVsZW1lbnRzLiAqL1xuXHRcdFx0XHRcdFx0XHQkLmVhY2goYWN0aXZlQ2FsbFsxXSwgZnVuY3Rpb24oaywgYWN0aXZlRWxlbWVudCkge1xuXHRcdFx0XHRcdFx0XHRcdC8qIElmIHRydWUgd2FzIHBhc3NlZCBpbiBhcyBhIHNlY29uZGFyeSBhcmd1bWVudCwgY2xlYXIgYWJzb2x1dGVseSBhbGwgY2FsbHMgb24gdGhpcyBlbGVtZW50LiBPdGhlcndpc2UsIG9ubHlcblx0XHRcdFx0XHRcdFx0XHQgY2xlYXIgY2FsbHMgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWxldmFudCBxdWV1ZS4gKi9cblx0XHRcdFx0XHRcdFx0XHQvKiBDYWxsIHN0b3BwaW5nIGxvZ2ljIHdvcmtzIGFzIGZvbGxvd3M6XG5cdFx0XHRcdFx0XHRcdFx0IC0gb3B0aW9ucyA9PT0gdHJ1ZSAtLT4gc3RvcCBjdXJyZW50IGRlZmF1bHQgcXVldWUgY2FsbHMgKGFuZCBxdWV1ZTpmYWxzZSBjYWxscyksIGluY2x1ZGluZyByZW1haW5pbmcgcXVldWVkIG9uZXMuXG5cdFx0XHRcdFx0XHRcdFx0IC0gb3B0aW9ucyA9PT0gdW5kZWZpbmVkIC0tPiBzdG9wIGN1cnJlbnQgcXVldWU6XCJcIiBjYWxsIGFuZCBhbGwgcXVldWU6ZmFsc2UgY2FsbHMuXG5cdFx0XHRcdFx0XHRcdFx0IC0gb3B0aW9ucyA9PT0gZmFsc2UgLS0+IHN0b3Agb25seSBxdWV1ZTpmYWxzZSBjYWxscy5cblx0XHRcdFx0XHRcdFx0XHQgLSBvcHRpb25zID09PSBcImN1c3RvbVwiIC0tPiBzdG9wIGN1cnJlbnQgcXVldWU6XCJjdXN0b21cIiBjYWxsLCBpbmNsdWRpbmcgcmVtYWluaW5nIHF1ZXVlZCBvbmVzICh0aGVyZSBpcyBubyBmdW5jdGlvbmFsaXR5IHRvIG9ubHkgY2xlYXIgdGhlIGN1cnJlbnRseS1ydW5uaW5nIHF1ZXVlOlwiY3VzdG9tXCIgY2FsbCkuICovXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHF1ZXVlTmFtZSA9IChvcHRpb25zID09PSB1bmRlZmluZWQpID8gXCJcIiA6IG9wdGlvbnM7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAocXVldWVOYW1lICE9PSB0cnVlICYmIChhY3RpdmVDYWxsWzJdLnF1ZXVlICE9PSBxdWV1ZU5hbWUpICYmICEob3B0aW9ucyA9PT0gdW5kZWZpbmVkICYmIGFjdGl2ZUNhbGxbMl0ucXVldWUgPT09IGZhbHNlKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0LyogSXRlcmF0ZSB0aHJvdWdoIHRoZSBjYWxscyB0YXJnZXRlZCBieSB0aGUgc3RvcCBjb21tYW5kLiAqL1xuXHRcdFx0XHRcdFx0XHRcdCQuZWFjaChlbGVtZW50cywgZnVuY3Rpb24obCwgZWxlbWVudCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0LyogQ2hlY2sgdGhhdCB0aGlzIGNhbGwgd2FzIGFwcGxpZWQgdG8gdGhlIHRhcmdldCBlbGVtZW50LiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGVsZW1lbnQgPT09IGFjdGl2ZUVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogT3B0aW9uYWxseSBjbGVhciB0aGUgcmVtYWluaW5nIHF1ZXVlZCBjYWxscy4gSWYgd2UncmUgZG9pbmcgXCJmaW5pc2hBbGxcIiB0aGlzIHdvbid0IGZpbmQgYW55dGhpbmcsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCBkdWUgdG8gdGhlIHF1ZXVlLWNsZWFyaW5nIGFib3ZlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAob3B0aW9ucyA9PT0gdHJ1ZSB8fCBUeXBlLmlzU3RyaW5nKG9wdGlvbnMpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyogSXRlcmF0ZSB0aHJvdWdoIHRoZSBpdGVtcyBpbiB0aGUgZWxlbWVudCdzIHF1ZXVlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCQuZWFjaCgkLnF1ZXVlKGVsZW1lbnQsIFR5cGUuaXNTdHJpbmcob3B0aW9ucykgPyBvcHRpb25zIDogXCJcIiksIGZ1bmN0aW9uKF8sIGl0ZW0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIFRoZSBxdWV1ZSBhcnJheSBjYW4gY29udGFpbiBhbiBcImlucHJvZ3Jlc3NcIiBzdHJpbmcsIHdoaWNoIHdlIHNraXAuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoVHlwZS5pc0Z1bmN0aW9uKGl0ZW0pKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIFBhc3MgdGhlIGl0ZW0ncyBjYWxsYmFjayBhIGZsYWcgaW5kaWNhdGluZyB0aGF0IHdlIHdhbnQgdG8gYWJvcnQgZnJvbSB0aGUgcXVldWUgY2FsbC5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0IChTcGVjaWZpY2FsbHksIHRoZSBxdWV1ZSB3aWxsIHJlc29sdmUgdGhlIGNhbGwncyBhc3NvY2lhdGVkIHByb21pc2UgdGhlbiBhYm9ydC4pICAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpdGVtKG51bGwsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyogQ2xlYXJpbmcgdGhlICQucXVldWUoKSBhcnJheSBpcyBhY2hpZXZlZCBieSByZXNldHRpbmcgaXQgdG8gW10uICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0JC5xdWV1ZShlbGVtZW50LCBUeXBlLmlzU3RyaW5nKG9wdGlvbnMpID8gb3B0aW9ucyA6IFwiXCIsIFtdKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChwcm9wZXJ0aWVzTWFwID09PSBcInN0b3BcIikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIFNpbmNlIFwicmV2ZXJzZVwiIHVzZXMgY2FjaGVkIHN0YXJ0IHZhbHVlcyAodGhlIHByZXZpb3VzIGNhbGwncyBlbmRWYWx1ZXMpLCB0aGVzZSB2YWx1ZXMgbXVzdCBiZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCBjaGFuZ2VkIHRvIHJlZmxlY3QgdGhlIGZpbmFsIHZhbHVlIHRoYXQgdGhlIGVsZW1lbnRzIHdlcmUgYWN0dWFsbHkgdHdlZW5lZCB0by4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBOb3RlOiBJZiBvbmx5IHF1ZXVlOmZhbHNlIGFuaW1hdGlvbnMgYXJlIGN1cnJlbnRseSBydW5uaW5nIG9uIGFuIGVsZW1lbnQsIGl0IHdvbid0IGhhdmUgYSB0d2VlbnNDb250YWluZXJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgb2JqZWN0LiBBbHNvLCBxdWV1ZTpmYWxzZSBhbmltYXRpb25zIGNhbid0IGJlIHJldmVyc2VkLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBkYXRhID0gRGF0YShlbGVtZW50KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoZGF0YSAmJiBkYXRhLnR3ZWVuc0NvbnRhaW5lciAmJiBxdWV1ZU5hbWUgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQkLmVhY2goZGF0YS50d2VlbnNDb250YWluZXIsIGZ1bmN0aW9uKG0sIGFjdGl2ZVR3ZWVuKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFjdGl2ZVR3ZWVuLmVuZFZhbHVlID0gYWN0aXZlVHdlZW4uY3VycmVudFZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FsbHNUb1N0b3AucHVzaChpKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwcm9wZXJ0aWVzTWFwID09PSBcImZpbmlzaFwiIHx8IHByb3BlcnRpZXNNYXAgPT09IFwiZmluaXNoQWxsXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBUbyBnZXQgYWN0aXZlIHR3ZWVucyB0byBmaW5pc2ggaW1tZWRpYXRlbHksIHdlIGZvcmNlZnVsbHkgc2hvcnRlbiB0aGVpciBkdXJhdGlvbnMgdG8gMW1zIHNvIHRoYXRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgdGhleSBmaW5pc2ggdXBvbiB0aGUgbmV4dCByQWYgdGljayB0aGVuIHByb2NlZWQgd2l0aCBub3JtYWwgY2FsbCBjb21wbGV0aW9uIGxvZ2ljLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFjdGl2ZUNhbGxbMl0uZHVyYXRpb24gPSAxO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0LyogUHJlbWF0dXJlbHkgY2FsbCBjb21wbGV0ZUNhbGwoKSBvbiBlYWNoIG1hdGNoZWQgYWN0aXZlIGNhbGwuIFBhc3MgYW4gYWRkaXRpb25hbCBmbGFnIGZvciBcInN0b3BcIiB0byBpbmRpY2F0ZVxuXHRcdFx0XHRcdCB0aGF0IHRoZSBjb21wbGV0ZSBjYWxsYmFjayBhbmQgZGlzcGxheTpub25lIHNldHRpbmcgc2hvdWxkIGJlIHNraXBwZWQgc2luY2Ugd2UncmUgY29tcGxldGluZyBwcmVtYXR1cmVseS4gKi9cblx0XHRcdFx0XHRpZiAocHJvcGVydGllc01hcCA9PT0gXCJzdG9wXCIpIHtcblx0XHRcdFx0XHRcdCQuZWFjaChjYWxsc1RvU3RvcCwgZnVuY3Rpb24oaSwgaikge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZUNhbGwoaiwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0aWYgKHByb21pc2VEYXRhLnByb21pc2UpIHtcblx0XHRcdFx0XHRcdFx0LyogSW1tZWRpYXRlbHkgcmVzb2x2ZSB0aGUgcHJvbWlzZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBzdG9wIGNhbGwgc2luY2Ugc3RvcCBydW5zIHN5bmNocm9ub3VzbHkuICovXG5cdFx0XHRcdFx0XHRcdHByb21pc2VEYXRhLnJlc29sdmVyKGVsZW1lbnRzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBTaW5jZSB3ZSdyZSBzdG9wcGluZywgYW5kIG5vdCBwcm9jZWVkaW5nIHdpdGggcXVldWVpbmcsIGV4aXQgb3V0IG9mIFZlbG9jaXR5LiAqL1xuXHRcdFx0XHRcdHJldHVybiBnZXRDaGFpbigpO1xuXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0LyogVHJlYXQgYSBub24tZW1wdHkgcGxhaW4gb2JqZWN0IGFzIGEgbGl0ZXJhbCBwcm9wZXJ0aWVzIG1hcC4gKi9cblx0XHRcdFx0XHRpZiAoJC5pc1BsYWluT2JqZWN0KHByb3BlcnRpZXNNYXApICYmICFUeXBlLmlzRW1wdHlPYmplY3QocHJvcGVydGllc01hcCkpIHtcblx0XHRcdFx0XHRcdGFjdGlvbiA9IFwic3RhcnRcIjtcblxuXHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdCBSZWRpcmVjdHNcblx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHQvKiBDaGVjayBpZiBhIHN0cmluZyBtYXRjaGVzIGEgcmVnaXN0ZXJlZCByZWRpcmVjdCAoc2VlIFJlZGlyZWN0cyBhYm92ZSkuICovXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChUeXBlLmlzU3RyaW5nKHByb3BlcnRpZXNNYXApICYmIFZlbG9jaXR5LlJlZGlyZWN0c1twcm9wZXJ0aWVzTWFwXSkge1xuXHRcdFx0XHRcdFx0b3B0cyA9ICQuZXh0ZW5kKHt9LCBvcHRpb25zKTtcblxuXHRcdFx0XHRcdFx0dmFyIGR1cmF0aW9uT3JpZ2luYWwgPSBvcHRzLmR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0XHRcdGRlbGF5T3JpZ2luYWwgPSBvcHRzLmRlbGF5IHx8IDA7XG5cblx0XHRcdFx0XHRcdC8qIElmIHRoZSBiYWNrd2FyZHMgb3B0aW9uIHdhcyBwYXNzZWQgaW4sIHJldmVyc2UgdGhlIGVsZW1lbnQgc2V0IHNvIHRoYXQgZWxlbWVudHMgYW5pbWF0ZSBmcm9tIHRoZSBsYXN0IHRvIHRoZSBmaXJzdC4gKi9cblx0XHRcdFx0XHRcdGlmIChvcHRzLmJhY2t3YXJkcyA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50cyA9ICQuZXh0ZW5kKHRydWUsIFtdLCBlbGVtZW50cykucmV2ZXJzZSgpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBJbmRpdmlkdWFsbHkgdHJpZ2dlciB0aGUgcmVkaXJlY3QgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgc2V0IHRvIHByZXZlbnQgdXNlcnMgZnJvbSBoYXZpbmcgdG8gaGFuZGxlIGl0ZXJhdGlvbiBsb2dpYyBpbiB0aGVpciByZWRpcmVjdC4gKi9cblx0XHRcdFx0XHRcdCQuZWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudEluZGV4LCBlbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdC8qIElmIHRoZSBzdGFnZ2VyIG9wdGlvbiB3YXMgcGFzc2VkIGluLCBzdWNjZXNzaXZlbHkgZGVsYXkgZWFjaCBlbGVtZW50IGJ5IHRoZSBzdGFnZ2VyIHZhbHVlIChpbiBtcykuIFJldGFpbiB0aGUgb3JpZ2luYWwgZGVsYXkgdmFsdWUuICovXG5cdFx0XHRcdFx0XHRcdGlmIChwYXJzZUZsb2F0KG9wdHMuc3RhZ2dlcikpIHtcblx0XHRcdFx0XHRcdFx0XHRvcHRzLmRlbGF5ID0gZGVsYXlPcmlnaW5hbCArIChwYXJzZUZsb2F0KG9wdHMuc3RhZ2dlcikgKiBlbGVtZW50SW5kZXgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKFR5cGUuaXNGdW5jdGlvbihvcHRzLnN0YWdnZXIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0b3B0cy5kZWxheSA9IGRlbGF5T3JpZ2luYWwgKyBvcHRzLnN0YWdnZXIuY2FsbChlbGVtZW50LCBlbGVtZW50SW5kZXgsIGVsZW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8qIElmIHRoZSBkcmFnIG9wdGlvbiB3YXMgcGFzc2VkIGluLCBzdWNjZXNzaXZlbHkgaW5jcmVhc2UvZGVjcmVhc2UgKGRlcGVuZGluZyBvbiB0aGUgcHJlc2Vuc2Ugb2Ygb3B0cy5iYWNrd2FyZHMpXG5cdFx0XHRcdFx0XHRcdCB0aGUgZHVyYXRpb24gb2YgZWFjaCBlbGVtZW50J3MgYW5pbWF0aW9uLCB1c2luZyBmbG9vcnMgdG8gcHJldmVudCBwcm9kdWNpbmcgdmVyeSBzaG9ydCBkdXJhdGlvbnMuICovXG5cdFx0XHRcdFx0XHRcdGlmIChvcHRzLmRyYWcpIHtcblx0XHRcdFx0XHRcdFx0XHQvKiBEZWZhdWx0IHRoZSBkdXJhdGlvbiBvZiBVSSBwYWNrIGVmZmVjdHMgKGNhbGxvdXRzIGFuZCB0cmFuc2l0aW9ucykgdG8gMTAwMG1zIGluc3RlYWQgb2YgdGhlIHVzdWFsIGRlZmF1bHQgZHVyYXRpb24gb2YgNDAwbXMuICovXG5cdFx0XHRcdFx0XHRcdFx0b3B0cy5kdXJhdGlvbiA9IHBhcnNlRmxvYXQoZHVyYXRpb25PcmlnaW5hbCkgfHwgKC9eKGNhbGxvdXR8dHJhbnNpdGlvbikvLnRlc3QocHJvcGVydGllc01hcCkgPyAxMDAwIDogRFVSQVRJT05fREVGQVVMVCk7XG5cblx0XHRcdFx0XHRcdFx0XHQvKiBGb3IgZWFjaCBlbGVtZW50LCB0YWtlIHRoZSBncmVhdGVyIGR1cmF0aW9uIG9mOiBBKSBhbmltYXRpb24gY29tcGxldGlvbiBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBvcmlnaW5hbCBkdXJhdGlvbixcblx0XHRcdFx0XHRcdFx0XHQgQikgNzUlIG9mIHRoZSBvcmlnaW5hbCBkdXJhdGlvbiwgb3IgQykgYSAyMDBtcyBmYWxsYmFjayAoaW4gY2FzZSBkdXJhdGlvbiBpcyBhbHJlYWR5IHNldCB0byBhIGxvdyB2YWx1ZSkuXG5cdFx0XHRcdFx0XHRcdFx0IFRoZSBlbmQgcmVzdWx0IGlzIGEgYmFzZWxpbmUgb2YgNzUlIG9mIHRoZSByZWRpcmVjdCdzIGR1cmF0aW9uIHRoYXQgaW5jcmVhc2VzL2RlY3JlYXNlcyBhcyB0aGUgZW5kIG9mIHRoZSBlbGVtZW50IHNldCBpcyBhcHByb2FjaGVkLiAqL1xuXHRcdFx0XHRcdFx0XHRcdG9wdHMuZHVyYXRpb24gPSBNYXRoLm1heChvcHRzLmR1cmF0aW9uICogKG9wdHMuYmFja3dhcmRzID8gMSAtIGVsZW1lbnRJbmRleCAvIGVsZW1lbnRzTGVuZ3RoIDogKGVsZW1lbnRJbmRleCArIDEpIC8gZWxlbWVudHNMZW5ndGgpLCBvcHRzLmR1cmF0aW9uICogMC43NSwgMjAwKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8qIFBhc3MgaW4gdGhlIGNhbGwncyBvcHRzIG9iamVjdCBzbyB0aGF0IHRoZSByZWRpcmVjdCBjYW4gb3B0aW9uYWxseSBleHRlbmQgaXQuIEl0IGRlZmF1bHRzIHRvIGFuIGVtcHR5IG9iamVjdCBpbnN0ZWFkIG9mIG51bGwgdG9cblx0XHRcdFx0XHRcdFx0IHJlZHVjZSB0aGUgb3B0cyBjaGVja2luZyBsb2dpYyByZXF1aXJlZCBpbnNpZGUgdGhlIHJlZGlyZWN0LiAqL1xuXHRcdFx0XHRcdFx0XHRWZWxvY2l0eS5SZWRpcmVjdHNbcHJvcGVydGllc01hcF0uY2FsbChlbGVtZW50LCBlbGVtZW50LCBvcHRzIHx8IHt9LCBlbGVtZW50SW5kZXgsIGVsZW1lbnRzTGVuZ3RoLCBlbGVtZW50cywgcHJvbWlzZURhdGEucHJvbWlzZSA/IHByb21pc2VEYXRhIDogdW5kZWZpbmVkKTtcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHQvKiBTaW5jZSB0aGUgYW5pbWF0aW9uIGxvZ2ljIHJlc2lkZXMgd2l0aGluIHRoZSByZWRpcmVjdCdzIG93biBjb2RlLCBhYm9ydCB0aGUgcmVtYWluZGVyIG9mIHRoaXMgY2FsbC5cblx0XHRcdFx0XHRcdCAoVGhlIHBlcmZvcm1hbmNlIG92ZXJoZWFkIHVwIHRvIHRoaXMgcG9pbnQgaXMgdmlydHVhbGx5IG5vbi1leGlzdGFudC4pICovXG5cdFx0XHRcdFx0XHQvKiBOb3RlOiBUaGUgalF1ZXJ5IGNhbGwgY2hhaW4gaXMga2VwdCBpbnRhY3QgYnkgcmV0dXJuaW5nIHRoZSBjb21wbGV0ZSBlbGVtZW50IHNldC4gKi9cblx0XHRcdFx0XHRcdHJldHVybiBnZXRDaGFpbigpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2YXIgYWJvcnRFcnJvciA9IFwiVmVsb2NpdHk6IEZpcnN0IGFyZ3VtZW50IChcIiArIHByb3BlcnRpZXNNYXAgKyBcIikgd2FzIG5vdCBhIHByb3BlcnR5IG1hcCwgYSBrbm93biBhY3Rpb24sIG9yIGEgcmVnaXN0ZXJlZCByZWRpcmVjdC4gQWJvcnRpbmcuXCI7XG5cblx0XHRcdFx0XHRcdGlmIChwcm9taXNlRGF0YS5wcm9taXNlKSB7XG5cdFx0XHRcdFx0XHRcdHByb21pc2VEYXRhLnJlamVjdGVyKG5ldyBFcnJvcihhYm9ydEVycm9yKSk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHdpbmRvdy5jb25zb2xlKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKGFib3J0RXJyb3IpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXR1cm4gZ2V0Q2hhaW4oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0IENhbGwtV2lkZSBWYXJpYWJsZXNcblx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0LyogQSBjb250YWluZXIgZm9yIENTUyB1bml0IGNvbnZlcnNpb24gcmF0aW9zIChlLmcuICUsIHJlbSwgYW5kIGVtID09PiBweCkgdGhhdCBpcyB1c2VkIHRvIGNhY2hlIHJhdGlvcyBhY3Jvc3MgYWxsIGVsZW1lbnRzXG5cdFx0XHQgYmVpbmcgYW5pbWF0ZWQgaW4gYSBzaW5nbGUgVmVsb2NpdHkgY2FsbC4gQ2FsY3VsYXRpbmcgdW5pdCByYXRpb3MgbmVjZXNzaXRhdGVzIERPTSBxdWVyeWluZyBhbmQgdXBkYXRpbmcsIGFuZCBpcyB0aGVyZWZvcmVcblx0XHRcdCBhdm9pZGVkICh2aWEgY2FjaGluZykgd2hlcmV2ZXIgcG9zc2libGUuIFRoaXMgY29udGFpbmVyIGlzIGNhbGwtd2lkZSBpbnN0ZWFkIG9mIHBhZ2Utd2lkZSB0byBhdm9pZCB0aGUgcmlzayBvZiB1c2luZyBzdGFsZVxuXHRcdFx0IGNvbnZlcnNpb24gbWV0cmljcyBhY3Jvc3MgVmVsb2NpdHkgYW5pbWF0aW9ucyB0aGF0IGFyZSBub3QgaW1tZWRpYXRlbHkgY29uc2VjdXRpdmVseSBjaGFpbmVkLiAqL1xuXHRcdFx0dmFyIGNhbGxVbml0Q29udmVyc2lvbkRhdGEgPSB7XG5cdFx0XHRcdGxhc3RQYXJlbnQ6IG51bGwsXG5cdFx0XHRcdGxhc3RQb3NpdGlvbjogbnVsbCxcblx0XHRcdFx0bGFzdEZvbnRTaXplOiBudWxsLFxuXHRcdFx0XHRsYXN0UGVyY2VudFRvUHhXaWR0aDogbnVsbCxcblx0XHRcdFx0bGFzdFBlcmNlbnRUb1B4SGVpZ2h0OiBudWxsLFxuXHRcdFx0XHRsYXN0RW1Ub1B4OiBudWxsLFxuXHRcdFx0XHRyZW1Ub1B4OiBudWxsLFxuXHRcdFx0XHR2d1RvUHg6IG51bGwsXG5cdFx0XHRcdHZoVG9QeDogbnVsbFxuXHRcdFx0fTtcblxuXHRcdFx0LyogQSBjb250YWluZXIgZm9yIGFsbCB0aGUgZW5zdWluZyB0d2VlbiBkYXRhIGFuZCBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjYWxsLiBUaGlzIGNvbnRhaW5lciBnZXRzIHB1c2hlZCB0byB0aGUgcGFnZS13aWRlXG5cdFx0XHQgVmVsb2NpdHkuU3RhdGUuY2FsbHMgYXJyYXkgdGhhdCBpcyBwcm9jZXNzZWQgZHVyaW5nIGFuaW1hdGlvbiB0aWNraW5nLiAqL1xuXHRcdFx0dmFyIGNhbGwgPSBbXTtcblxuXHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0IEVsZW1lbnQgUHJvY2Vzc2luZ1xuXHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0LyogRWxlbWVudCBwcm9jZXNzaW5nIGNvbnNpc3RzIG9mIHRocmVlIHBhcnRzIC0tIGRhdGEgcHJvY2Vzc2luZyB0aGF0IGNhbm5vdCBnbyBzdGFsZSBhbmQgZGF0YSBwcm9jZXNzaW5nIHRoYXQgKmNhbiogZ28gc3RhbGUgKGkuZS4gdGhpcmQtcGFydHkgc3R5bGUgbW9kaWZpY2F0aW9ucyk6XG5cdFx0XHQgMSkgUHJlLVF1ZXVlaW5nOiBFbGVtZW50LXdpZGUgdmFyaWFibGVzLCBpbmNsdWRpbmcgdGhlIGVsZW1lbnQncyBkYXRhIHN0b3JhZ2UsIGFyZSBpbnN0YW50aWF0ZWQuIENhbGwgb3B0aW9ucyBhcmUgcHJlcGFyZWQuIElmIHRyaWdnZXJlZCwgdGhlIFN0b3AgYWN0aW9uIGlzIGV4ZWN1dGVkLlxuXHRcdFx0IDIpIFF1ZXVlaW5nOiBUaGUgbG9naWMgdGhhdCBydW5zIG9uY2UgdGhpcyBjYWxsIGhhcyByZWFjaGVkIGl0cyBwb2ludCBvZiBleGVjdXRpb24gaW4gdGhlIGVsZW1lbnQncyAkLnF1ZXVlKCkgc3RhY2suIE1vc3QgbG9naWMgaXMgcGxhY2VkIGhlcmUgdG8gYXZvaWQgcmlza2luZyBpdCBiZWNvbWluZyBzdGFsZS5cblx0XHRcdCAzKSBQdXNoaW5nOiBDb25zb2xpZGF0aW9uIG9mIHRoZSB0d2VlbiBkYXRhIGZvbGxvd2VkIGJ5IGl0cyBwdXNoIG9udG8gdGhlIGdsb2JhbCBpbi1wcm9ncmVzcyBjYWxscyBjb250YWluZXIuXG5cdFx0XHQgYGVsZW1lbnRBcnJheUluZGV4YCBhbGxvd3MgcGFzc2luZyBpbmRleCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgb3JpZ2luYWwgYXJyYXkgdG8gdmFsdWUgZnVuY3Rpb25zLlxuXHRcdFx0IElmIGBlbGVtZW50c0luZGV4YCB3ZXJlIHVzZWQgaW5zdGVhZCB0aGUgaW5kZXggd291bGQgYmUgZGV0ZXJtaW5lZCBieSB0aGUgZWxlbWVudHMnIHBlci1lbGVtZW50IHF1ZXVlLlxuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBlbGVtZW50QXJyYXlJbmRleCkge1xuXG5cdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdCBQYXJ0IEk6IFByZS1RdWV1ZWluZ1xuXHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdCBFbGVtZW50LVdpZGUgVmFyaWFibGVzXG5cdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0dmFyIC8qIFRoZSBydW50aW1lIG9wdHMgb2JqZWN0IGlzIHRoZSBleHRlbnNpb24gb2YgdGhlIGN1cnJlbnQgY2FsbCdzIG9wdGlvbnMgYW5kIFZlbG9jaXR5J3MgcGFnZS13aWRlIG9wdGlvbiBkZWZhdWx0cy4gKi9cblx0XHRcdFx0XHRcdG9wdHMgPSAkLmV4dGVuZCh7fSwgVmVsb2NpdHkuZGVmYXVsdHMsIG9wdGlvbnMpLFxuXHRcdFx0XHRcdFx0LyogQSBjb250YWluZXIgZm9yIHRoZSBwcm9jZXNzZWQgZGF0YSBhc3NvY2lhdGVkIHdpdGggZWFjaCBwcm9wZXJ0eSBpbiB0aGUgcHJvcGVydHlNYXAuXG5cdFx0XHRcdFx0XHQgKEVhY2ggcHJvcGVydHkgaW4gdGhlIG1hcCBwcm9kdWNlcyBpdHMgb3duIFwidHdlZW5cIi4pICovXG5cdFx0XHRcdFx0XHR0d2VlbnNDb250YWluZXIgPSB7fSxcblx0XHRcdFx0XHRcdGVsZW1lbnRVbml0Q29udmVyc2lvbkRhdGE7XG5cblx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHQgRWxlbWVudCBJbml0XG5cdFx0XHRcdCAqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0aWYgKERhdGEoZWxlbWVudCkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFZlbG9jaXR5LmluaXQoZWxlbWVudCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdCBPcHRpb246IERlbGF5XG5cdFx0XHRcdCAqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0LyogU2luY2UgcXVldWU6ZmFsc2UgZG9lc24ndCByZXNwZWN0IHRoZSBpdGVtJ3MgZXhpc3RpbmcgcXVldWUsIHdlIGF2b2lkIGluamVjdGluZyBpdHMgZGVsYXkgaGVyZSAoaXQncyBzZXQgbGF0ZXIgb24pLiAqL1xuXHRcdFx0XHQvKiBOb3RlOiBWZWxvY2l0eSByb2xscyBpdHMgb3duIGRlbGF5IGZ1bmN0aW9uIHNpbmNlIGpRdWVyeSBkb2Vzbid0IGhhdmUgYSB1dGlsaXR5IGFsaWFzIGZvciAkLmZuLmRlbGF5KClcblx0XHRcdFx0IChhbmQgdGh1cyByZXF1aXJlcyBqUXVlcnkgZWxlbWVudCBjcmVhdGlvbiwgd2hpY2ggd2UgYXZvaWQgc2luY2UgaXRzIG92ZXJoZWFkIGluY2x1ZGVzIERPTSBxdWVyeWluZykuICovXG5cdFx0XHRcdGlmIChwYXJzZUZsb2F0KG9wdHMuZGVsYXkpICYmIG9wdHMucXVldWUgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0JC5xdWV1ZShlbGVtZW50LCBvcHRzLnF1ZXVlLCBmdW5jdGlvbihuZXh0LCBjbGVhclF1ZXVlKSB7XG5cdFx0XHRcdFx0XHRpZiAoY2xlYXJRdWV1ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHQvKiBEbyBub3QgY29udGludWUgd2l0aCBhbmltYXRpb24gcXVldWVpbmcuICovXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBUaGlzIGlzIGEgZmxhZyB1c2VkIHRvIGluZGljYXRlIHRvIHRoZSB1cGNvbWluZyBjb21wbGV0ZUNhbGwoKSBmdW5jdGlvbiB0aGF0IHRoaXMgcXVldWUgZW50cnkgd2FzIGluaXRpYXRlZCBieSBWZWxvY2l0eS4gU2VlIGNvbXBsZXRlQ2FsbCgpIGZvciBmdXJ0aGVyIGRldGFpbHMuICovXG5cdFx0XHRcdFx0XHRWZWxvY2l0eS52ZWxvY2l0eVF1ZXVlRW50cnlGbGFnID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0LyogVGhlIGVuc3VpbmcgcXVldWUgaXRlbSAod2hpY2ggaXMgYXNzaWduZWQgdG8gdGhlIFwibmV4dFwiIGFyZ3VtZW50IHRoYXQgJC5xdWV1ZSgpIGF1dG9tYXRpY2FsbHkgcGFzc2VzIGluKSB3aWxsIGJlIHRyaWdnZXJlZCBhZnRlciBhIHNldFRpbWVvdXQgZGVsYXkuXG5cdFx0XHRcdFx0XHQgVGhlIHNldFRpbWVvdXQgaXMgc3RvcmVkIHNvIHRoYXQgaXQgY2FuIGJlIHN1YmplY3RlZCB0byBjbGVhclRpbWVvdXQoKSBpZiB0aGlzIGFuaW1hdGlvbiBpcyBwcmVtYXR1cmVseSBzdG9wcGVkIHZpYSBWZWxvY2l0eSdzIFwic3RvcFwiIGNvbW1hbmQsIGFuZFxuXHRcdFx0XHRcdFx0IGRlbGF5QmVnaW4vZGVsYXlUaW1lIGlzIHVzZWQgdG8gZW5zdXJlIHdlIGNhbiBcInBhdXNlXCIgYW5kIFwicmVzdW1lXCIgYSB0d2VlbiB0aGF0IGlzIHN0aWxsIG1pZC1kZWxheS4gKi9cblxuXHRcdFx0XHRcdFx0LyogVGVtcG9yYXJpbHkgc3RvcmUgZGVsYXllZCBlbGVtZW50cyB0byBmYWNpbGl0ZSBhY2Nlc3MgZm9yIGdsb2JhbCBwYXVzZS9yZXN1bWUgKi9cblx0XHRcdFx0XHRcdHZhciBjYWxsSW5kZXggPSBWZWxvY2l0eS5TdGF0ZS5kZWxheWVkRWxlbWVudHMuY291bnQrKztcblx0XHRcdFx0XHRcdFZlbG9jaXR5LlN0YXRlLmRlbGF5ZWRFbGVtZW50c1tjYWxsSW5kZXhdID0gZWxlbWVudDtcblxuXHRcdFx0XHRcdFx0dmFyIGRlbGF5Q29tcGxldGUgPSAoZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdC8qIENsZWFyIHRoZSB0ZW1wb3JhcnkgZWxlbWVudCAqL1xuXHRcdFx0XHRcdFx0XHRcdFZlbG9jaXR5LlN0YXRlLmRlbGF5ZWRFbGVtZW50c1tpbmRleF0gPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0XHRcdC8qIEZpbmFsbHksIGlzc3VlIHRoZSBjYWxsICovXG5cdFx0XHRcdFx0XHRcdFx0bmV4dCgpO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fSkoY2FsbEluZGV4KTtcblxuXG5cdFx0XHRcdFx0XHREYXRhKGVsZW1lbnQpLmRlbGF5QmVnaW4gPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHRcdFx0XHRcdFx0RGF0YShlbGVtZW50KS5kZWxheSA9IHBhcnNlRmxvYXQob3B0cy5kZWxheSk7XG5cdFx0XHRcdFx0XHREYXRhKGVsZW1lbnQpLmRlbGF5VGltZXIgPSB7XG5cdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQ6IHNldFRpbWVvdXQobmV4dCwgcGFyc2VGbG9hdChvcHRzLmRlbGF5KSksXG5cdFx0XHRcdFx0XHRcdG5leHQ6IGRlbGF5Q29tcGxldGVcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdCBPcHRpb246IER1cmF0aW9uXG5cdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0LyogU3VwcG9ydCBmb3IgalF1ZXJ5J3MgbmFtZWQgZHVyYXRpb25zLiAqL1xuXHRcdFx0XHRzd2l0Y2ggKG9wdHMuZHVyYXRpb24udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0XHRcdFx0Y2FzZSBcImZhc3RcIjpcblx0XHRcdFx0XHRcdG9wdHMuZHVyYXRpb24gPSAyMDA7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgXCJub3JtYWxcIjpcblx0XHRcdFx0XHRcdG9wdHMuZHVyYXRpb24gPSBEVVJBVElPTl9ERUZBVUxUO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlIFwic2xvd1wiOlxuXHRcdFx0XHRcdFx0b3B0cy5kdXJhdGlvbiA9IDYwMDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdC8qIFJlbW92ZSB0aGUgcG90ZW50aWFsIFwibXNcIiBzdWZmaXggYW5kIGRlZmF1bHQgdG8gMSBpZiB0aGUgdXNlciBpcyBhdHRlbXB0aW5nIHRvIHNldCBhIGR1cmF0aW9uIG9mIDAgKGluIG9yZGVyIHRvIHByb2R1Y2UgYW4gaW1tZWRpYXRlIHN0eWxlIGNoYW5nZSkuICovXG5cdFx0XHRcdFx0XHRvcHRzLmR1cmF0aW9uID0gcGFyc2VGbG9hdChvcHRzLmR1cmF0aW9uKSB8fCAxO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHQgR2xvYmFsIE9wdGlvbjogTW9ja1xuXHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdGlmIChWZWxvY2l0eS5tb2NrICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdC8qIEluIG1vY2sgbW9kZSwgYWxsIGFuaW1hdGlvbnMgYXJlIGZvcmNlZCB0byAxbXMgc28gdGhhdCB0aGV5IG9jY3VyIGltbWVkaWF0ZWx5IHVwb24gdGhlIG5leHQgckFGIHRpY2suXG5cdFx0XHRcdFx0IEFsdGVybmF0aXZlbHksIGEgbXVsdGlwbGllciBjYW4gYmUgcGFzc2VkIGluIHRvIHRpbWUgcmVtYXAgYWxsIGRlbGF5cyBhbmQgZHVyYXRpb25zLiAqL1xuXHRcdFx0XHRcdGlmIChWZWxvY2l0eS5tb2NrID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRvcHRzLmR1cmF0aW9uID0gb3B0cy5kZWxheSA9IDE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG9wdHMuZHVyYXRpb24gKj0gcGFyc2VGbG9hdChWZWxvY2l0eS5tb2NrKSB8fCAxO1xuXHRcdFx0XHRcdFx0b3B0cy5kZWxheSAqPSBwYXJzZUZsb2F0KFZlbG9jaXR5Lm1vY2spIHx8IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IE9wdGlvbjogRWFzaW5nXG5cdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdG9wdHMuZWFzaW5nID0gZ2V0RWFzaW5nKG9wdHMuZWFzaW5nLCBvcHRzLmR1cmF0aW9uKTtcblxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHQgT3B0aW9uOiBDYWxsYmFja3Ncblx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0LyogQ2FsbGJhY2tzIG11c3QgZnVuY3Rpb25zLiBPdGhlcndpc2UsIGRlZmF1bHQgdG8gbnVsbC4gKi9cblx0XHRcdFx0aWYgKG9wdHMuYmVnaW4gJiYgIVR5cGUuaXNGdW5jdGlvbihvcHRzLmJlZ2luKSkge1xuXHRcdFx0XHRcdG9wdHMuYmVnaW4gPSBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG9wdHMucHJvZ3Jlc3MgJiYgIVR5cGUuaXNGdW5jdGlvbihvcHRzLnByb2dyZXNzKSkge1xuXHRcdFx0XHRcdG9wdHMucHJvZ3Jlc3MgPSBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG9wdHMuY29tcGxldGUgJiYgIVR5cGUuaXNGdW5jdGlvbihvcHRzLmNvbXBsZXRlKSkge1xuXHRcdFx0XHRcdG9wdHMuY29tcGxldGUgPSBudWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHQgT3B0aW9uOiBEaXNwbGF5ICYgVmlzaWJpbGl0eVxuXHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdC8qIFJlZmVyIHRvIFZlbG9jaXR5J3MgZG9jdW1lbnRhdGlvbiAoVmVsb2NpdHlKUy5vcmcvI2Rpc3BsYXlBbmRWaXNpYmlsaXR5KSBmb3IgYSBkZXNjcmlwdGlvbiBvZiB0aGUgZGlzcGxheSBhbmQgdmlzaWJpbGl0eSBvcHRpb25zJyBiZWhhdmlvci4gKi9cblx0XHRcdFx0LyogTm90ZTogV2Ugc3RyaWN0bHkgY2hlY2sgZm9yIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGZhbHNpbmVzcyBiZWNhdXNlIGRpc3BsYXkgYWNjZXB0cyBhbiBlbXB0eSBzdHJpbmcgdmFsdWUuICovXG5cdFx0XHRcdGlmIChvcHRzLmRpc3BsYXkgIT09IHVuZGVmaW5lZCAmJiBvcHRzLmRpc3BsYXkgIT09IG51bGwpIHtcblx0XHRcdFx0XHRvcHRzLmRpc3BsYXkgPSBvcHRzLmRpc3BsYXkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRcdFx0LyogVXNlcnMgY2FuIHBhc3MgaW4gYSBzcGVjaWFsIFwiYXV0b1wiIHZhbHVlIHRvIGluc3RydWN0IFZlbG9jaXR5IHRvIHNldCB0aGUgZWxlbWVudCB0byBpdHMgZGVmYXVsdCBkaXNwbGF5IHZhbHVlLiAqL1xuXHRcdFx0XHRcdGlmIChvcHRzLmRpc3BsYXkgPT09IFwiYXV0b1wiKSB7XG5cdFx0XHRcdFx0XHRvcHRzLmRpc3BsYXkgPSBWZWxvY2l0eS5DU1MuVmFsdWVzLmdldERpc3BsYXlUeXBlKGVsZW1lbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChvcHRzLnZpc2liaWxpdHkgIT09IHVuZGVmaW5lZCAmJiBvcHRzLnZpc2liaWxpdHkgIT09IG51bGwpIHtcblx0XHRcdFx0XHRvcHRzLnZpc2liaWxpdHkgPSBvcHRzLnZpc2liaWxpdHkudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IE9wdGlvbjogbW9iaWxlSEFcblx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0LyogV2hlbiBzZXQgdG8gdHJ1ZSwgYW5kIGlmIHRoaXMgaXMgYSBtb2JpbGUgZGV2aWNlLCBtb2JpbGVIQSBhdXRvbWF0aWNhbGx5IGVuYWJsZXMgaGFyZHdhcmUgYWNjZWxlcmF0aW9uICh2aWEgYSBudWxsIHRyYW5zZm9ybSBoYWNrKVxuXHRcdFx0XHQgb24gYW5pbWF0aW5nIGVsZW1lbnRzLiBIQSBpcyByZW1vdmVkIGZyb20gdGhlIGVsZW1lbnQgYXQgdGhlIGNvbXBsZXRpb24gb2YgaXRzIGFuaW1hdGlvbi4gKi9cblx0XHRcdFx0LyogTm90ZTogQW5kcm9pZCBHaW5nZXJicmVhZCBkb2Vzbid0IHN1cHBvcnQgSEEuIElmIGEgbnVsbCB0cmFuc2Zvcm0gaGFjayAobW9iaWxlSEEpIGlzIGluIGZhY3Qgc2V0LCBpdCB3aWxsIHByZXZlbnQgb3RoZXIgdHJhbmZvcm0gc3VicHJvcGVydGllcyBmcm9tIHRha2luZyBlZmZlY3QuICovXG5cdFx0XHRcdC8qIE5vdGU6IFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IHRoZSB1c2Ugb2YgbW9iaWxlSEEgaW4gVmVsb2NpdHkncyBkb2N1bWVudGF0aW9uOiBWZWxvY2l0eUpTLm9yZy8jbW9iaWxlSEEuICovXG5cdFx0XHRcdG9wdHMubW9iaWxlSEEgPSAob3B0cy5tb2JpbGVIQSAmJiBWZWxvY2l0eS5TdGF0ZS5pc01vYmlsZSAmJiAhVmVsb2NpdHkuU3RhdGUuaXNHaW5nZXJicmVhZCk7XG5cblx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdCBQYXJ0IElJOiBRdWV1ZWluZ1xuXHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0LyogV2hlbiBhIHNldCBvZiBlbGVtZW50cyBpcyB0YXJnZXRlZCBieSBhIFZlbG9jaXR5IGNhbGwsIHRoZSBzZXQgaXMgYnJva2VuIHVwIGFuZCBlYWNoIGVsZW1lbnQgaGFzIHRoZSBjdXJyZW50IFZlbG9jaXR5IGNhbGwgaW5kaXZpZHVhbGx5IHF1ZXVlZCBvbnRvIGl0LlxuXHRcdFx0XHQgSW4gdGhpcyB3YXksIGVhY2ggZWxlbWVudCdzIGV4aXN0aW5nIHF1ZXVlIGlzIHJlc3BlY3RlZDsgc29tZSBlbGVtZW50cyBtYXkgYWxyZWFkeSBiZSBhbmltYXRpbmcgYW5kIGFjY29yZGluZ2x5IHNob3VsZCBub3QgaGF2ZSB0aGlzIGN1cnJlbnQgVmVsb2NpdHkgY2FsbCB0cmlnZ2VyZWQgaW1tZWRpYXRlbHkuICovXG5cdFx0XHRcdC8qIEluIGVhY2ggcXVldWUsIHR3ZWVuIGRhdGEgaXMgcHJvY2Vzc2VkIGZvciBlYWNoIGFuaW1hdGluZyBwcm9wZXJ0eSB0aGVuIHB1c2hlZCBvbnRvIHRoZSBjYWxsLXdpZGUgY2FsbHMgYXJyYXkuIFdoZW4gdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgc2V0IGhhcyBoYWQgaXRzIHR3ZWVucyBwcm9jZXNzZWQsXG5cdFx0XHRcdCB0aGUgY2FsbCBhcnJheSBpcyBwdXNoZWQgdG8gVmVsb2NpdHkuU3RhdGUuY2FsbHMgZm9yIGxpdmUgcHJvY2Vzc2luZyBieSB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRpY2suICovXG5cdFx0XHRcdGZ1bmN0aW9uIGJ1aWxkUXVldWUobmV4dCkge1xuXHRcdFx0XHRcdHZhciBkYXRhLCBsYXN0VHdlZW5zQ29udGFpbmVyO1xuXG5cdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHQgT3B0aW9uOiBCZWdpblxuXHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0LyogVGhlIGJlZ2luIGNhbGxiYWNrIGlzIGZpcmVkIG9uY2UgcGVyIGNhbGwgLS0gbm90IG9uY2UgcGVyIGVsZW1lbmV0IC0tIGFuZCBpcyBwYXNzZWQgdGhlIGZ1bGwgcmF3IERPTSBlbGVtZW50IHNldCBhcyBib3RoIGl0cyBjb250ZXh0IGFuZCBpdHMgZmlyc3QgYXJndW1lbnQuICovXG5cdFx0XHRcdFx0aWYgKG9wdHMuYmVnaW4gJiYgZWxlbWVudHNJbmRleCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0LyogV2UgdGhyb3cgY2FsbGJhY2tzIGluIGEgc2V0VGltZW91dCBzbyB0aGF0IHRocm93biBlcnJvcnMgZG9uJ3QgaGFsdCB0aGUgZXhlY3V0aW9uIG9mIFZlbG9jaXR5IGl0c2VsZi4gKi9cblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdG9wdHMuYmVnaW4uY2FsbChlbGVtZW50cywgZWxlbWVudHMpO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR0aHJvdyBlcnJvcjtcblx0XHRcdFx0XHRcdFx0fSwgMSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0IFR3ZWVuIERhdGEgQ29uc3RydWN0aW9uIChmb3IgU2Nyb2xsKVxuXHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdC8qIE5vdGU6IEluIG9yZGVyIHRvIGJlIHN1YmplY3RlZCB0byBjaGFpbmluZyBhbmQgYW5pbWF0aW9uIG9wdGlvbnMsIHNjcm9sbCdzIHR3ZWVuaW5nIGlzIHJvdXRlZCB0aHJvdWdoIFZlbG9jaXR5IGFzIGlmIGl0IHdlcmUgYSBzdGFuZGFyZCBDU1MgcHJvcGVydHkgYW5pbWF0aW9uLiAqL1xuXHRcdFx0XHRcdGlmIChhY3Rpb24gPT09IFwic2Nyb2xsXCIpIHtcblx0XHRcdFx0XHRcdC8qIFRoZSBzY3JvbGwgYWN0aW9uIHVuaXF1ZWx5IHRha2VzIGFuIG9wdGlvbmFsIFwib2Zmc2V0XCIgb3B0aW9uIC0tIHNwZWNpZmllZCBpbiBwaXhlbHMgLS0gdGhhdCBvZmZzZXRzIHRoZSB0YXJnZXRlZCBzY3JvbGwgcG9zaXRpb24uICovXG5cdFx0XHRcdFx0XHR2YXIgc2Nyb2xsRGlyZWN0aW9uID0gKC9eeCQvaS50ZXN0KG9wdHMuYXhpcykgPyBcIkxlZnRcIiA6IFwiVG9wXCIpLFxuXHRcdFx0XHRcdFx0XHRcdHNjcm9sbE9mZnNldCA9IHBhcnNlRmxvYXQob3B0cy5vZmZzZXQpIHx8IDAsXG5cdFx0XHRcdFx0XHRcdFx0c2Nyb2xsUG9zaXRpb25DdXJyZW50LFxuXHRcdFx0XHRcdFx0XHRcdHNjcm9sbFBvc2l0aW9uQ3VycmVudEFsdGVybmF0ZSxcblx0XHRcdFx0XHRcdFx0XHRzY3JvbGxQb3NpdGlvbkVuZDtcblxuXHRcdFx0XHRcdFx0LyogU2Nyb2xsIGFsc28gdW5pcXVlbHkgdGFrZXMgYW4gb3B0aW9uYWwgXCJjb250YWluZXJcIiBvcHRpb24sIHdoaWNoIGluZGljYXRlcyB0aGUgcGFyZW50IGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgc2Nyb2xsZWQgLS1cblx0XHRcdFx0XHRcdCBhcyBvcHBvc2VkIHRvIHRoZSBicm93c2VyIHdpbmRvdyBpdHNlbGYuIFRoaXMgaXMgdXNlZnVsIGZvciBzY3JvbGxpbmcgdG93YXJkIGFuIGVsZW1lbnQgdGhhdCdzIGluc2lkZSBhbiBvdmVyZmxvd2luZyBwYXJlbnQgZWxlbWVudC4gKi9cblx0XHRcdFx0XHRcdGlmIChvcHRzLmNvbnRhaW5lcikge1xuXHRcdFx0XHRcdFx0XHQvKiBFbnN1cmUgdGhhdCBlaXRoZXIgYSBqUXVlcnkgb2JqZWN0IG9yIGEgcmF3IERPTSBlbGVtZW50IHdhcyBwYXNzZWQgaW4uICovXG5cdFx0XHRcdFx0XHRcdGlmIChUeXBlLmlzV3JhcHBlZChvcHRzLmNvbnRhaW5lcikgfHwgVHlwZS5pc05vZGUob3B0cy5jb250YWluZXIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0LyogRXh0cmFjdCB0aGUgcmF3IERPTSBlbGVtZW50IGZyb20gdGhlIGpRdWVyeSB3cmFwcGVyLiAqL1xuXHRcdFx0XHRcdFx0XHRcdG9wdHMuY29udGFpbmVyID0gb3B0cy5jb250YWluZXJbMF0gfHwgb3B0cy5jb250YWluZXI7XG5cdFx0XHRcdFx0XHRcdFx0LyogTm90ZTogVW5saWtlIG90aGVyIHByb3BlcnRpZXMgaW4gVmVsb2NpdHksIHRoZSBicm93c2VyJ3Mgc2Nyb2xsIHBvc2l0aW9uIGlzIG5ldmVyIGNhY2hlZCBzaW5jZSBpdCBzbyBmcmVxdWVudGx5IGNoYW5nZXNcblx0XHRcdFx0XHRcdFx0XHQgKGR1ZSB0byB0aGUgdXNlcidzIG5hdHVyYWwgaW50ZXJhY3Rpb24gd2l0aCB0aGUgcGFnZSkuICovXG5cdFx0XHRcdFx0XHRcdFx0c2Nyb2xsUG9zaXRpb25DdXJyZW50ID0gb3B0cy5jb250YWluZXJbXCJzY3JvbGxcIiArIHNjcm9sbERpcmVjdGlvbl07IC8qIEdFVCAqL1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogJC5wb3NpdGlvbigpIHZhbHVlcyBhcmUgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lcidzIGN1cnJlbnRseSB2aWV3YWJsZSBhcmVhICh3aXRob3V0IHRha2luZyBpbnRvIGFjY291bnQgdGhlIGNvbnRhaW5lcidzIHRydWUgZGltZW5zaW9uc1xuXHRcdFx0XHRcdFx0XHRcdCAtLSBzYXksIGZvciBleGFtcGxlLCBpZiB0aGUgY29udGFpbmVyIHdhcyBub3Qgb3ZlcmZsb3dpbmcpLiBUaHVzLCB0aGUgc2Nyb2xsIGVuZCB2YWx1ZSBpcyB0aGUgc3VtIG9mIHRoZSBjaGlsZCBlbGVtZW50J3MgcG9zaXRpb24gKmFuZCpcblx0XHRcdFx0XHRcdFx0XHQgdGhlIHNjcm9sbCBjb250YWluZXIncyBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbi4gKi9cblx0XHRcdFx0XHRcdFx0XHRzY3JvbGxQb3NpdGlvbkVuZCA9IChzY3JvbGxQb3NpdGlvbkN1cnJlbnQgKyAkKGVsZW1lbnQpLnBvc2l0aW9uKClbc2Nyb2xsRGlyZWN0aW9uLnRvTG93ZXJDYXNlKCldKSArIHNjcm9sbE9mZnNldDsgLyogR0VUICovXG5cdFx0XHRcdFx0XHRcdFx0LyogSWYgYSB2YWx1ZSBvdGhlciB0aGFuIGEgalF1ZXJ5IG9iamVjdCBvciBhIHJhdyBET00gZWxlbWVudCB3YXMgcGFzc2VkIGluLCBkZWZhdWx0IHRvIG51bGwgc28gdGhhdCB0aGlzIG9wdGlvbiBpcyBpZ25vcmVkLiAqL1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdG9wdHMuY29udGFpbmVyID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0LyogSWYgdGhlIHdpbmRvdyBpdHNlbGYgaXMgYmVpbmcgc2Nyb2xsZWQgLS0gbm90IGEgY29udGFpbmluZyBlbGVtZW50IC0tIHBlcmZvcm0gYSBsaXZlIHNjcm9sbCBwb3NpdGlvbiBsb29rdXAgdXNpbmdcblx0XHRcdFx0XHRcdFx0IHRoZSBhcHByb3ByaWF0ZSBjYWNoZWQgcHJvcGVydHkgbmFtZXMgKHdoaWNoIGRpZmZlciBiYXNlZCBvbiBicm93c2VyIHR5cGUpLiAqL1xuXHRcdFx0XHRcdFx0XHRzY3JvbGxQb3NpdGlvbkN1cnJlbnQgPSBWZWxvY2l0eS5TdGF0ZS5zY3JvbGxBbmNob3JbVmVsb2NpdHkuU3RhdGVbXCJzY3JvbGxQcm9wZXJ0eVwiICsgc2Nyb2xsRGlyZWN0aW9uXV07IC8qIEdFVCAqL1xuXHRcdFx0XHRcdFx0XHQvKiBXaGVuIHNjcm9sbGluZyB0aGUgYnJvd3NlciB3aW5kb3csIGNhY2hlIHRoZSBhbHRlcm5hdGUgYXhpcydzIGN1cnJlbnQgdmFsdWUgc2luY2Ugd2luZG93LnNjcm9sbFRvKCkgZG9lc24ndCBsZXQgdXMgY2hhbmdlIG9ubHkgb25lIHZhbHVlIGF0IGEgdGltZS4gKi9cblx0XHRcdFx0XHRcdFx0c2Nyb2xsUG9zaXRpb25DdXJyZW50QWx0ZXJuYXRlID0gVmVsb2NpdHkuU3RhdGUuc2Nyb2xsQW5jaG9yW1ZlbG9jaXR5LlN0YXRlW1wic2Nyb2xsUHJvcGVydHlcIiArIChzY3JvbGxEaXJlY3Rpb24gPT09IFwiTGVmdFwiID8gXCJUb3BcIiA6IFwiTGVmdFwiKV1dOyAvKiBHRVQgKi9cblxuXHRcdFx0XHRcdFx0XHQvKiBVbmxpa2UgJC5wb3NpdGlvbigpLCAkLm9mZnNldCgpIHZhbHVlcyBhcmUgcmVsYXRpdmUgdG8gdGhlIGJyb3dzZXIgd2luZG93J3MgdHJ1ZSBkaW1lbnNpb25zIC0tIG5vdCBtZXJlbHkgaXRzIGN1cnJlbnRseSB2aWV3YWJsZSBhcmVhIC0tXG5cdFx0XHRcdFx0XHRcdCBhbmQgdGhlcmVmb3JlIGVuZCB2YWx1ZXMgZG8gbm90IG5lZWQgdG8gYmUgY29tcG91bmRlZCBvbnRvIGN1cnJlbnQgdmFsdWVzLiAqL1xuXHRcdFx0XHRcdFx0XHRzY3JvbGxQb3NpdGlvbkVuZCA9ICQoZWxlbWVudCkub2Zmc2V0KClbc2Nyb2xsRGlyZWN0aW9uLnRvTG93ZXJDYXNlKCldICsgc2Nyb2xsT2Zmc2V0OyAvKiBHRVQgKi9cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyogU2luY2UgdGhlcmUncyBvbmx5IG9uZSBmb3JtYXQgdGhhdCBzY3JvbGwncyBhc3NvY2lhdGVkIHR3ZWVuc0NvbnRhaW5lciBjYW4gdGFrZSwgd2UgY3JlYXRlIGl0IG1hbnVhbGx5LiAqL1xuXHRcdFx0XHRcdFx0dHdlZW5zQ29udGFpbmVyID0ge1xuXHRcdFx0XHRcdFx0XHRzY3JvbGw6IHtcblx0XHRcdFx0XHRcdFx0XHRyb290UHJvcGVydHlWYWx1ZTogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnRWYWx1ZTogc2Nyb2xsUG9zaXRpb25DdXJyZW50LFxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRWYWx1ZTogc2Nyb2xsUG9zaXRpb25DdXJyZW50LFxuXHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlOiBzY3JvbGxQb3NpdGlvbkVuZCxcblx0XHRcdFx0XHRcdFx0XHR1bml0VHlwZTogXCJcIixcblx0XHRcdFx0XHRcdFx0XHRlYXNpbmc6IG9wdHMuZWFzaW5nLFxuXHRcdFx0XHRcdFx0XHRcdHNjcm9sbERhdGE6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnRhaW5lcjogb3B0cy5jb250YWluZXIsXG5cdFx0XHRcdFx0XHRcdFx0XHRkaXJlY3Rpb246IHNjcm9sbERpcmVjdGlvbixcblx0XHRcdFx0XHRcdFx0XHRcdGFsdGVybmF0ZVZhbHVlOiBzY3JvbGxQb3NpdGlvbkN1cnJlbnRBbHRlcm5hdGVcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQ6IGVsZW1lbnRcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdGlmIChWZWxvY2l0eS5kZWJ1Zykge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcInR3ZWVuc0NvbnRhaW5lciAoc2Nyb2xsKTogXCIsIHR3ZWVuc0NvbnRhaW5lci5zY3JvbGwsIGVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0XHQgVHdlZW4gRGF0YSBDb25zdHJ1Y3Rpb24gKGZvciBSZXZlcnNlKVxuXHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdFx0LyogUmV2ZXJzZSBhY3RzIGxpa2UgYSBcInN0YXJ0XCIgYWN0aW9uIGluIHRoYXQgYSBwcm9wZXJ0eSBtYXAgaXMgYW5pbWF0ZWQgdG93YXJkLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzXG5cdFx0XHRcdFx0XHQgdGhhdCB0aGUgcHJvcGVydHkgbWFwIHVzZWQgZm9yIHJldmVyc2UgaXMgdGhlIGludmVyc2Ugb2YgdGhlIG1hcCB1c2VkIGluIHRoZSBwcmV2aW91cyBjYWxsLiBUaHVzLCB3ZSBtYW5pcHVsYXRlXG5cdFx0XHRcdFx0XHQgdGhlIHByZXZpb3VzIGNhbGwgdG8gY29uc3RydWN0IG91ciBuZXcgbWFwOiB1c2UgdGhlIHByZXZpb3VzIG1hcCdzIGVuZCB2YWx1ZXMgYXMgb3VyIG5ldyBtYXAncyBzdGFydCB2YWx1ZXMuIENvcHkgb3ZlciBhbGwgb3RoZXIgZGF0YS4gKi9cblx0XHRcdFx0XHRcdC8qIE5vdGU6IFJldmVyc2UgY2FuIGJlIGRpcmVjdGx5IGNhbGxlZCB2aWEgdGhlIFwicmV2ZXJzZVwiIHBhcmFtZXRlciwgb3IgaXQgY2FuIGJlIGluZGlyZWN0bHkgdHJpZ2dlcmVkIHZpYSB0aGUgbG9vcCBvcHRpb24uIChMb29wcyBhcmUgY29tcG9zZWQgb2YgbXVsdGlwbGUgcmV2ZXJzZXMuKSAqL1xuXHRcdFx0XHRcdFx0LyogTm90ZTogUmV2ZXJzZSBjYWxscyBkbyBub3QgbmVlZCB0byBiZSBjb25zZWN1dGl2ZWx5IGNoYWluZWQgb250byBhIGN1cnJlbnRseS1hbmltYXRpbmcgZWxlbWVudCBpbiBvcmRlciB0byBvcGVyYXRlIG9uIGNhY2hlZCB2YWx1ZXM7XG5cdFx0XHRcdFx0XHQgdGhlcmUgaXMgbm8gaGFybSB0byByZXZlcnNlIGJlaW5nIGNhbGxlZCBvbiBhIHBvdGVudGlhbGx5IHN0YWxlIGRhdGEgY2FjaGUgc2luY2UgcmV2ZXJzZSdzIGJlaGF2aW9yIGlzIHNpbXBseSBkZWZpbmVkXG5cdFx0XHRcdFx0XHQgYXMgcmV2ZXJ0aW5nIHRvIHRoZSBlbGVtZW50J3MgdmFsdWVzIGFzIHRoZXkgd2VyZSBwcmlvciB0byB0aGUgcHJldmlvdXMgKlZlbG9jaXR5KiBjYWxsLiAqL1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYWN0aW9uID09PSBcInJldmVyc2VcIikge1xuXHRcdFx0XHRcdFx0ZGF0YSA9IERhdGEoZWxlbWVudCk7XG5cblx0XHRcdFx0XHRcdC8qIEFib3J0IGlmIHRoZXJlIGlzIG5vIHByaW9yIGFuaW1hdGlvbiBkYXRhIHRvIHJldmVyc2UgdG8uICovXG5cdFx0XHRcdFx0XHRpZiAoIWRhdGEpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoIWRhdGEudHdlZW5zQ29udGFpbmVyKSB7XG5cdFx0XHRcdFx0XHRcdC8qIERlcXVldWUgdGhlIGVsZW1lbnQgc28gdGhhdCB0aGlzIHF1ZXVlIGVudHJ5IHJlbGVhc2VzIGl0c2VsZiBpbW1lZGlhdGVseSwgYWxsb3dpbmcgc3Vic2VxdWVudCBxdWV1ZSBlbnRyaWVzIHRvIHJ1bi4gKi9cblx0XHRcdFx0XHRcdFx0JC5kZXF1ZXVlKGVsZW1lbnQsIG9wdHMucXVldWUpO1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdFx0IE9wdGlvbnMgUGFyc2luZ1xuXHRcdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdC8qIElmIHRoZSBlbGVtZW50IHdhcyBoaWRkZW4gdmlhIHRoZSBkaXNwbGF5IG9wdGlvbiBpbiB0aGUgcHJldmlvdXMgY2FsbCxcblx0XHRcdFx0XHRcdFx0IHJldmVydCBkaXNwbGF5IHRvIFwiYXV0b1wiIHByaW9yIHRvIHJldmVyc2FsIHNvIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBhZ2Fpbi4gKi9cblx0XHRcdFx0XHRcdFx0aWYgKGRhdGEub3B0cy5kaXNwbGF5ID09PSBcIm5vbmVcIikge1xuXHRcdFx0XHRcdFx0XHRcdGRhdGEub3B0cy5kaXNwbGF5ID0gXCJhdXRvXCI7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoZGF0YS5vcHRzLnZpc2liaWxpdHkgPT09IFwiaGlkZGVuXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRkYXRhLm9wdHMudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0LyogSWYgdGhlIGxvb3Agb3B0aW9uIHdhcyBzZXQgaW4gdGhlIHByZXZpb3VzIGNhbGwsIGRpc2FibGUgaXQgc28gdGhhdCBcInJldmVyc2VcIiBjYWxscyBhcmVuJ3QgcmVjdXJzaXZlbHkgZ2VuZXJhdGVkLlxuXHRcdFx0XHRcdFx0XHQgRnVydGhlciwgcmVtb3ZlIHRoZSBwcmV2aW91cyBjYWxsJ3MgY2FsbGJhY2sgb3B0aW9uczsgdHlwaWNhbGx5LCB1c2VycyBkbyBub3Qgd2FudCB0aGVzZSB0byBiZSByZWZpcmVkLiAqL1xuXHRcdFx0XHRcdFx0XHRkYXRhLm9wdHMubG9vcCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRkYXRhLm9wdHMuYmVnaW4gPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRkYXRhLm9wdHMuY29tcGxldGUgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdC8qIFNpbmNlIHdlJ3JlIGV4dGVuZGluZyBhbiBvcHRzIG9iamVjdCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gZXh0ZW5kZWQgd2l0aCB0aGUgZGVmYXVsdHMgb3B0aW9ucyBvYmplY3QsXG5cdFx0XHRcdFx0XHRcdCB3ZSByZW1vdmUgbm9uLWV4cGxpY2l0bHktZGVmaW5lZCBwcm9wZXJ0aWVzIHRoYXQgYXJlIGF1dG8tYXNzaWduZWQgdmFsdWVzLiAqL1xuXHRcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuZWFzaW5nKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIG9wdHMuZWFzaW5nO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmR1cmF0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIG9wdHMuZHVyYXRpb247XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvKiBUaGUgb3B0cyBvYmplY3QgdXNlZCBmb3IgcmV2ZXJzYWwgaXMgYW4gZXh0ZW5zaW9uIG9mIHRoZSBvcHRpb25zIG9iamVjdCBvcHRpb25hbGx5IHBhc3NlZCBpbnRvIHRoaXNcblx0XHRcdFx0XHRcdFx0IHJldmVyc2UgY2FsbCBwbHVzIHRoZSBvcHRpb25zIHVzZWQgaW4gdGhlIHByZXZpb3VzIFZlbG9jaXR5IGNhbGwuICovXG5cdFx0XHRcdFx0XHRcdG9wdHMgPSAkLmV4dGVuZCh7fSwgZGF0YS5vcHRzLCBvcHRzKTtcblxuXHRcdFx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHQgVHdlZW5zIENvbnRhaW5lciBSZWNvbnN0cnVjdGlvblxuXHRcdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdFx0XHQvKiBDcmVhdGUgYSBkZWVweSBjb3B5IChpbmRpY2F0ZWQgdmlhIHRoZSB0cnVlIGZsYWcpIG9mIHRoZSBwcmV2aW91cyBjYWxsJ3MgdHdlZW5zQ29udGFpbmVyLiAqL1xuXHRcdFx0XHRcdFx0XHRsYXN0VHdlZW5zQ29udGFpbmVyID0gJC5leHRlbmQodHJ1ZSwge30sIGRhdGEgPyBkYXRhLnR3ZWVuc0NvbnRhaW5lciA6IG51bGwpO1xuXG5cdFx0XHRcdFx0XHRcdC8qIE1hbmlwdWxhdGUgdGhlIHByZXZpb3VzIHR3ZWVuc0NvbnRhaW5lciBieSByZXBsYWNpbmcgaXRzIGVuZCB2YWx1ZXMgYW5kIGN1cnJlbnRWYWx1ZXMgd2l0aCBpdHMgc3RhcnQgdmFsdWVzLiAqL1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBsYXN0VHdlZW4gaW4gbGFzdFR3ZWVuc0NvbnRhaW5lcikge1xuXHRcdFx0XHRcdFx0XHRcdC8qIEluIGFkZGl0aW9uIHRvIHR3ZWVuIGRhdGEsIHR3ZWVuc0NvbnRhaW5lcnMgY29udGFpbiBhbiBlbGVtZW50IHByb3BlcnR5IHRoYXQgd2UgaWdub3JlIGhlcmUuICovXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGxhc3RUd2VlbnNDb250YWluZXIuaGFzT3duUHJvcGVydHkobGFzdFR3ZWVuKSAmJiBsYXN0VHdlZW4gIT09IFwiZWxlbWVudFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgbGFzdFN0YXJ0VmFsdWUgPSBsYXN0VHdlZW5zQ29udGFpbmVyW2xhc3RUd2Vlbl0uc3RhcnRWYWx1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0bGFzdFR3ZWVuc0NvbnRhaW5lcltsYXN0VHdlZW5dLnN0YXJ0VmFsdWUgPSBsYXN0VHdlZW5zQ29udGFpbmVyW2xhc3RUd2Vlbl0uY3VycmVudFZhbHVlID0gbGFzdFR3ZWVuc0NvbnRhaW5lcltsYXN0VHdlZW5dLmVuZFZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0bGFzdFR3ZWVuc0NvbnRhaW5lcltsYXN0VHdlZW5dLmVuZFZhbHVlID0gbGFzdFN0YXJ0VmFsdWU7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8qIEVhc2luZyBpcyB0aGUgb25seSBvcHRpb24gdGhhdCBlbWJlZHMgaW50byB0aGUgaW5kaXZpZHVhbCB0d2VlbiBkYXRhIChzaW5jZSBpdCBjYW4gYmUgZGVmaW5lZCBvbiBhIHBlci1wcm9wZXJ0eSBiYXNpcykuXG5cdFx0XHRcdFx0XHRcdFx0XHQgQWNjb3JkaW5nbHksIGV2ZXJ5IHByb3BlcnR5J3MgZWFzaW5nIHZhbHVlIG11c3QgYmUgdXBkYXRlZCB3aGVuIGFuIG9wdGlvbnMgb2JqZWN0IGlzIHBhc3NlZCBpbiB3aXRoIGEgcmV2ZXJzZSBjYWxsLlxuXHRcdFx0XHRcdFx0XHRcdFx0IFRoZSBzaWRlIGVmZmVjdCBvZiB0aGlzIGV4dGVuc2liaWxpdHkgaXMgdGhhdCBhbGwgcGVyLXByb3BlcnR5IGVhc2luZyB2YWx1ZXMgYXJlIGZvcmNlZnVsbHkgcmVzZXQgdG8gdGhlIG5ldyB2YWx1ZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdGlmICghVHlwZS5pc0VtcHR5T2JqZWN0KG9wdGlvbnMpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGxhc3RUd2VlbnNDb250YWluZXJbbGFzdFR3ZWVuXS5lYXNpbmcgPSBvcHRzLmVhc2luZztcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKFZlbG9jaXR5LmRlYnVnKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwicmV2ZXJzZSB0d2VlbnNDb250YWluZXIgKFwiICsgbGFzdFR3ZWVuICsgXCIpOiBcIiArIEpTT04uc3RyaW5naWZ5KGxhc3RUd2VlbnNDb250YWluZXJbbGFzdFR3ZWVuXSksIGVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdHR3ZWVuc0NvbnRhaW5lciA9IGxhc3RUd2VlbnNDb250YWluZXI7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0IFR3ZWVuIERhdGEgQ29uc3RydWN0aW9uIChmb3IgU3RhcnQpXG5cdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHR9IGVsc2UgaWYgKGFjdGlvbiA9PT0gXCJzdGFydFwiKSB7XG5cblx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0XHQgVmFsdWUgVHJhbnNmZXJyaW5nXG5cdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdFx0LyogSWYgdGhpcyBxdWV1ZSBlbnRyeSBmb2xsb3dzIGEgcHJldmlvdXMgVmVsb2NpdHktaW5pdGlhdGVkIHF1ZXVlIGVudHJ5ICphbmQqIGlmIHRoaXMgZW50cnkgd2FzIGNyZWF0ZWRcblx0XHRcdFx0XHRcdCB3aGlsZSB0aGUgZWxlbWVudCB3YXMgaW4gdGhlIHByb2Nlc3Mgb2YgYmVpbmcgYW5pbWF0ZWQgYnkgVmVsb2NpdHksIHRoZW4gdGhpcyBjdXJyZW50IGNhbGwgaXMgc2FmZSB0byB1c2Vcblx0XHRcdFx0XHRcdCB0aGUgZW5kIHZhbHVlcyBmcm9tIHRoZSBwcmlvciBjYWxsIGFzIGl0cyBzdGFydCB2YWx1ZXMuIFZlbG9jaXR5IGF0dGVtcHRzIHRvIHBlcmZvcm0gdGhpcyB2YWx1ZSB0cmFuc2ZlclxuXHRcdFx0XHRcdFx0IHByb2Nlc3Mgd2hlbmV2ZXIgcG9zc2libGUgaW4gb3JkZXIgdG8gYXZvaWQgcmVxdWVyeWluZyB0aGUgRE9NLiAqL1xuXHRcdFx0XHRcdFx0LyogSWYgdmFsdWVzIGFyZW4ndCB0cmFuc2ZlcnJlZCBmcm9tIGEgcHJpb3IgY2FsbCBhbmQgc3RhcnQgdmFsdWVzIHdlcmUgbm90IGZvcmNlZmVkIGJ5IHRoZSB1c2VyIChtb3JlIG9uIHRoaXMgYmVsb3cpLFxuXHRcdFx0XHRcdFx0IHRoZW4gdGhlIERPTSBpcyBxdWVyaWVkIGZvciB0aGUgZWxlbWVudCdzIGN1cnJlbnQgdmFsdWVzIGFzIGEgbGFzdCByZXNvcnQuICovXG5cdFx0XHRcdFx0XHQvKiBOb3RlOiBDb252ZXJzZWx5LCBhbmltYXRpb24gcmV2ZXJzYWwgKGFuZCBsb29waW5nKSAqYWx3YXlzKiBwZXJmb3JtIGludGVyLWNhbGwgdmFsdWUgdHJhbnNmZXJzOyB0aGV5IG5ldmVyIHJlcXVlcnkgdGhlIERPTS4gKi9cblxuXHRcdFx0XHRcdFx0ZGF0YSA9IERhdGEoZWxlbWVudCk7XG5cblx0XHRcdFx0XHRcdC8qIFRoZSBwZXItZWxlbWVudCBpc0FuaW1hdGluZyBmbGFnIGlzIHVzZWQgdG8gaW5kaWNhdGUgd2hldGhlciBpdCdzIHNhZmUgKGkuZS4gdGhlIGRhdGEgaXNuJ3Qgc3RhbGUpXG5cdFx0XHRcdFx0XHQgdG8gdHJhbnNmZXIgb3ZlciBlbmQgdmFsdWVzIHRvIHVzZSBhcyBzdGFydCB2YWx1ZXMuIElmIGl0J3Mgc2V0IHRvIHRydWUgYW5kIHRoZXJlIGlzIGEgcHJldmlvdXNcblx0XHRcdFx0XHRcdCBWZWxvY2l0eSBjYWxsIHRvIHB1bGwgdmFsdWVzIGZyb20sIGRvIHNvLiAqL1xuXHRcdFx0XHRcdFx0aWYgKGRhdGEgJiYgZGF0YS50d2VlbnNDb250YWluZXIgJiYgZGF0YS5pc0FuaW1hdGluZyA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHRsYXN0VHdlZW5zQ29udGFpbmVyID0gZGF0YS50d2VlbnNDb250YWluZXI7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdCBUd2VlbiBEYXRhIENhbGN1bGF0aW9uXG5cdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHQvKiBUaGlzIGZ1bmN0aW9uIHBhcnNlcyBwcm9wZXJ0eSBkYXRhIGFuZCBkZWZhdWx0cyBlbmRWYWx1ZSwgZWFzaW5nLCBhbmQgc3RhcnRWYWx1ZSBhcyBhcHByb3ByaWF0ZS4gKi9cblx0XHRcdFx0XHRcdC8qIFByb3BlcnR5IG1hcCB2YWx1ZXMgY2FuIGVpdGhlciB0YWtlIHRoZSBmb3JtIG9mIDEpIGEgc2luZ2xlIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgZW5kIHZhbHVlLFxuXHRcdFx0XHRcdFx0IG9yIDIpIGFuIGFycmF5IGluIHRoZSBmb3JtIG9mIFsgZW5kVmFsdWUsIFssIGVhc2luZ10gWywgc3RhcnRWYWx1ZV0gXS5cblx0XHRcdFx0XHRcdCBUaGUgb3B0aW9uYWwgdGhpcmQgcGFyYW1ldGVyIGlzIGEgZm9yY2VmZWQgc3RhcnRWYWx1ZSB0byBiZSB1c2VkIGluc3RlYWQgb2YgcXVlcnlpbmcgdGhlIERPTSBmb3Jcblx0XHRcdFx0XHRcdCB0aGUgZWxlbWVudCdzIGN1cnJlbnQgdmFsdWUuIFJlYWQgVmVsb2NpdHkncyBkb2NtZW50YXRpb24gdG8gbGVhcm4gbW9yZSBhYm91dCBmb3JjZWZlZWRpbmc6IFZlbG9jaXR5SlMub3JnLyNmb3JjZWZlZWRpbmcgKi9cblx0XHRcdFx0XHRcdHZhciBwYXJzZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbih2YWx1ZURhdGEsIHNraXBSZXNvbHZpbmdFYXNpbmcpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGVuZFZhbHVlLCBlYXNpbmcsIHN0YXJ0VmFsdWU7XG5cblx0XHRcdFx0XHRcdFx0LyogSWYgd2UgaGF2ZSBhIGZ1bmN0aW9uIGFzIHRoZSBtYWluIGFyZ3VtZW50IHRoZW4gcmVzb2x2ZSBpdCBmaXJzdCwgaW4gY2FzZSBpdCByZXR1cm5zIGFuIGFycmF5IHRoYXQgbmVlZHMgdG8gYmUgc3BsaXQgKi9cblx0XHRcdFx0XHRcdFx0aWYgKFR5cGUuaXNGdW5jdGlvbih2YWx1ZURhdGEpKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWVEYXRhID0gdmFsdWVEYXRhLmNhbGwoZWxlbWVudCwgZWxlbWVudEFycmF5SW5kZXgsIGVsZW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8qIEhhbmRsZSB0aGUgYXJyYXkgZm9ybWF0LCB3aGljaCBjYW4gYmUgc3RydWN0dXJlZCBhcyBvbmUgb2YgdGhyZWUgcG90ZW50aWFsIG92ZXJsb2Fkczpcblx0XHRcdFx0XHRcdFx0IEEpIFsgZW5kVmFsdWUsIGVhc2luZywgc3RhcnRWYWx1ZSBdLCBCKSBbIGVuZFZhbHVlLCBlYXNpbmcgXSwgb3IgQykgWyBlbmRWYWx1ZSwgc3RhcnRWYWx1ZSBdICovXG5cdFx0XHRcdFx0XHRcdGlmIChUeXBlLmlzQXJyYXkodmFsdWVEYXRhKSkge1xuXHRcdFx0XHRcdFx0XHRcdC8qIGVuZFZhbHVlIGlzIGFsd2F5cyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgYXJyYXkuIERvbid0IGJvdGhlciB2YWxpZGF0aW5nIGVuZFZhbHVlJ3MgdmFsdWUgbm93XG5cdFx0XHRcdFx0XHRcdFx0IHNpbmNlIHRoZSBlbnN1aW5nIHByb3BlcnR5IGN5Y2xpbmcgbG9naWMgZG9lcyB0aGF0LiAqL1xuXHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlID0gdmFsdWVEYXRhWzBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogVHdvLWl0ZW0gYXJyYXkgZm9ybWF0OiBJZiB0aGUgc2Vjb25kIGl0ZW0gaXMgYSBudW1iZXIsIGZ1bmN0aW9uLCBvciBoZXggc3RyaW5nLCB0cmVhdCBpdCBhcyBhXG5cdFx0XHRcdFx0XHRcdFx0IHN0YXJ0IHZhbHVlIHNpbmNlIGVhc2luZ3MgY2FuIG9ubHkgYmUgbm9uLWhleCBzdHJpbmdzIG9yIGFycmF5cy4gKi9cblx0XHRcdFx0XHRcdFx0XHRpZiAoKCFUeXBlLmlzQXJyYXkodmFsdWVEYXRhWzFdKSAmJiAvXltcXGQtXS8udGVzdCh2YWx1ZURhdGFbMV0pKSB8fCBUeXBlLmlzRnVuY3Rpb24odmFsdWVEYXRhWzFdKSB8fCBDU1MuUmVnRXguaXNIZXgudGVzdCh2YWx1ZURhdGFbMV0pKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlID0gdmFsdWVEYXRhWzFdO1xuXHRcdFx0XHRcdFx0XHRcdFx0LyogVHdvIG9yIHRocmVlLWl0ZW0gYXJyYXk6IElmIHRoZSBzZWNvbmQgaXRlbSBpcyBhIG5vbi1oZXggc3RyaW5nIGVhc2luZyBuYW1lIG9yIGFuIGFycmF5LCB0cmVhdCBpdCBhcyBhbiBlYXNpbmcuICovXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICgoVHlwZS5pc1N0cmluZyh2YWx1ZURhdGFbMV0pICYmICFDU1MuUmVnRXguaXNIZXgudGVzdCh2YWx1ZURhdGFbMV0pICYmIFZlbG9jaXR5LkVhc2luZ3NbdmFsdWVEYXRhWzFdXSkgfHwgVHlwZS5pc0FycmF5KHZhbHVlRGF0YVsxXSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVhc2luZyA9IHNraXBSZXNvbHZpbmdFYXNpbmcgPyB2YWx1ZURhdGFbMV0gOiBnZXRFYXNpbmcodmFsdWVEYXRhWzFdLCBvcHRzLmR1cmF0aW9uKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0LyogRG9uJ3QgYm90aGVyIHZhbGlkYXRpbmcgc3RhcnRWYWx1ZSdzIHZhbHVlIG5vdyBzaW5jZSB0aGUgZW5zdWluZyBwcm9wZXJ0eSBjeWNsaW5nIGxvZ2ljIGluaGVyZW50bHkgZG9lcyB0aGF0LiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RhcnRWYWx1ZSA9IHZhbHVlRGF0YVsyXTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RhcnRWYWx1ZSA9IHZhbHVlRGF0YVsxXSB8fCB2YWx1ZURhdGFbMl07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8qIEhhbmRsZSB0aGUgc2luZ2xlLXZhbHVlIGZvcm1hdC4gKi9cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRlbmRWYWx1ZSA9IHZhbHVlRGF0YTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8qIERlZmF1bHQgdG8gdGhlIGNhbGwncyBlYXNpbmcgaWYgYSBwZXItcHJvcGVydHkgZWFzaW5nIHR5cGUgd2FzIG5vdCBkZWZpbmVkLiAqL1xuXHRcdFx0XHRcdFx0XHRpZiAoIXNraXBSZXNvbHZpbmdFYXNpbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRlYXNpbmcgPSBlYXNpbmcgfHwgb3B0cy5lYXNpbmc7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvKiBJZiBmdW5jdGlvbnMgd2VyZSBwYXNzZWQgaW4gYXMgdmFsdWVzLCBwYXNzIHRoZSBmdW5jdGlvbiB0aGUgY3VycmVudCBlbGVtZW50IGFzIGl0cyBjb250ZXh0LFxuXHRcdFx0XHRcdFx0XHQgcGx1cyB0aGUgZWxlbWVudCdzIGluZGV4IGFuZCB0aGUgZWxlbWVudCBzZXQncyBzaXplIGFzIGFyZ3VtZW50cy4gVGhlbiwgYXNzaWduIHRoZSByZXR1cm5lZCB2YWx1ZS4gKi9cblx0XHRcdFx0XHRcdFx0aWYgKFR5cGUuaXNGdW5jdGlvbihlbmRWYWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRlbmRWYWx1ZSA9IGVuZFZhbHVlLmNhbGwoZWxlbWVudCwgZWxlbWVudEFycmF5SW5kZXgsIGVsZW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmIChUeXBlLmlzRnVuY3Rpb24oc3RhcnRWYWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlID0gc3RhcnRWYWx1ZS5jYWxsKGVsZW1lbnQsIGVsZW1lbnRBcnJheUluZGV4LCBlbGVtZW50c0xlbmd0aCk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvKiBBbGxvdyBzdGFydFZhbHVlIHRvIGJlIGxlZnQgYXMgdW5kZWZpbmVkIHRvIGluZGljYXRlIHRvIHRoZSBlbnN1aW5nIGNvZGUgdGhhdCBpdHMgdmFsdWUgd2FzIG5vdCBmb3JjZWZlZC4gKi9cblx0XHRcdFx0XHRcdFx0cmV0dXJuIFtlbmRWYWx1ZSB8fCAwLCBlYXNpbmcsIHN0YXJ0VmFsdWVdO1xuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0dmFyIGZpeFByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbihwcm9wZXJ0eSwgdmFsdWVEYXRhKSB7XG5cdFx0XHRcdFx0XHRcdC8qIEluIGNhc2UgdGhpcyBwcm9wZXJ0eSBpcyBhIGhvb2ssIHRoZXJlIGFyZSBjaXJjdW1zdGFuY2VzIHdoZXJlIHdlIHdpbGwgaW50ZW5kIHRvIHdvcmsgb24gdGhlIGhvb2sncyByb290IHByb3BlcnR5IGFuZCBub3QgdGhlIGhvb2tlZCBzdWJwcm9wZXJ0eS4gKi9cblx0XHRcdFx0XHRcdFx0dmFyIHJvb3RQcm9wZXJ0eSA9IENTUy5Ib29rcy5nZXRSb290KHByb3BlcnR5KSxcblx0XHRcdFx0XHRcdFx0XHRcdHJvb3RQcm9wZXJ0eVZhbHVlID0gZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBQYXJzZSBvdXQgZW5kVmFsdWUsIGVhc2luZywgYW5kIHN0YXJ0VmFsdWUgZnJvbSB0aGUgcHJvcGVydHkncyBkYXRhLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSB2YWx1ZURhdGFbMF0sXG5cdFx0XHRcdFx0XHRcdFx0XHRlYXNpbmcgPSB2YWx1ZURhdGFbMV0sXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlID0gdmFsdWVEYXRhWzJdLFxuXHRcdFx0XHRcdFx0XHRcdFx0cGF0dGVybjtcblxuXHRcdFx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdFx0IFN0YXJ0IFZhbHVlIFNvdXJjaW5nXG5cdFx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdFx0XHQvKiBPdGhlciB0aGFuIGZvciB0aGUgZHVtbXkgdHdlZW4gcHJvcGVydHksIHByb3BlcnRpZXMgdGhhdCBhcmUgbm90IHN1cHBvcnRlZCBieSB0aGUgYnJvd3NlciAoYW5kIGRvIG5vdCBoYXZlIGFuIGFzc29jaWF0ZWQgbm9ybWFsaXphdGlvbikgd2lsbFxuXHRcdFx0XHRcdFx0XHQgaW5oZXJlbnRseSBwcm9kdWNlIG5vIHN0eWxlIGNoYW5nZXMgd2hlbiBzZXQsIHNvIHRoZXkgYXJlIHNraXBwZWQgaW4gb3JkZXIgdG8gZGVjcmVhc2UgYW5pbWF0aW9uIHRpY2sgb3ZlcmhlYWQuXG5cdFx0XHRcdFx0XHRcdCBQcm9wZXJ0eSBzdXBwb3J0IGlzIGRldGVybWluZWQgdmlhIHByZWZpeENoZWNrKCksIHdoaWNoIHJldHVybnMgYSBmYWxzZSBmbGFnIHdoZW4gbm8gc3VwcG9ydGVkIGlzIGRldGVjdGVkLiAqL1xuXHRcdFx0XHRcdFx0XHQvKiBOb3RlOiBTaW5jZSBTVkcgZWxlbWVudHMgaGF2ZSBzb21lIG9mIHRoZWlyIHByb3BlcnRpZXMgZGlyZWN0bHkgYXBwbGllZCBhcyBIVE1MIGF0dHJpYnV0ZXMsXG5cdFx0XHRcdFx0XHRcdCB0aGVyZSBpcyBubyB3YXkgdG8gY2hlY2sgZm9yIHRoZWlyIGV4cGxpY2l0IGJyb3dzZXIgc3VwcG9ydCwgYW5kIHNvIHdlIHNraXAgc2tpcCB0aGlzIGNoZWNrIGZvciB0aGVtLiAqL1xuXHRcdFx0XHRcdFx0XHRpZiAoKCFkYXRhIHx8ICFkYXRhLmlzU1ZHKSAmJiByb290UHJvcGVydHkgIT09IFwidHdlZW5cIiAmJiBDU1MuTmFtZXMucHJlZml4Q2hlY2socm9vdFByb3BlcnR5KVsxXSA9PT0gZmFsc2UgJiYgQ1NTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbcm9vdFByb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKFZlbG9jaXR5LmRlYnVnKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIlNraXBwaW5nIFtcIiArIHJvb3RQcm9wZXJ0eSArIFwiXSBkdWUgdG8gYSBsYWNrIG9mIGJyb3dzZXIgc3VwcG9ydC5cIik7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8qIElmIHRoZSBkaXNwbGF5IG9wdGlvbiBpcyBiZWluZyBzZXQgdG8gYSBub24tXCJub25lXCIgKGUuZy4gXCJibG9ja1wiKSBhbmQgb3BhY2l0eSAoZmlsdGVyIG9uIElFPD04KSBpcyBiZWluZ1xuXHRcdFx0XHRcdFx0XHQgYW5pbWF0ZWQgdG8gYW4gZW5kVmFsdWUgb2Ygbm9uLXplcm8sIHRoZSB1c2VyJ3MgaW50ZW50aW9uIGlzIHRvIGZhZGUgaW4gZnJvbSBpbnZpc2libGUsIHRodXMgd2UgZm9yY2VmZWVkIG9wYWNpdHlcblx0XHRcdFx0XHRcdFx0IGEgc3RhcnRWYWx1ZSBvZiAwIGlmIGl0cyBzdGFydFZhbHVlIGhhc24ndCBhbHJlYWR5IGJlZW4gc291cmNlZCBieSB2YWx1ZSB0cmFuc2ZlcnJpbmcgb3IgcHJpb3IgZm9yY2VmZWVkaW5nLiAqL1xuXHRcdFx0XHRcdFx0XHRpZiAoKChvcHRzLmRpc3BsYXkgIT09IHVuZGVmaW5lZCAmJiBvcHRzLmRpc3BsYXkgIT09IG51bGwgJiYgb3B0cy5kaXNwbGF5ICE9PSBcIm5vbmVcIikgfHwgKG9wdHMudmlzaWJpbGl0eSAhPT0gdW5kZWZpbmVkICYmIG9wdHMudmlzaWJpbGl0eSAhPT0gXCJoaWRkZW5cIikpICYmIC9vcGFjaXR5fGZpbHRlci8udGVzdChwcm9wZXJ0eSkgJiYgIXN0YXJ0VmFsdWUgJiYgZW5kVmFsdWUgIT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlID0gMDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8qIElmIHZhbHVlcyBoYXZlIGJlZW4gdHJhbnNmZXJyZWQgZnJvbSB0aGUgcHJldmlvdXMgVmVsb2NpdHkgY2FsbCwgZXh0cmFjdCB0aGUgZW5kVmFsdWUgYW5kIHJvb3RQcm9wZXJ0eVZhbHVlXG5cdFx0XHRcdFx0XHRcdCBmb3IgYWxsIG9mIHRoZSBjdXJyZW50IGNhbGwncyBwcm9wZXJ0aWVzIHRoYXQgd2VyZSAqYWxzbyogYW5pbWF0ZWQgaW4gdGhlIHByZXZpb3VzIGNhbGwuICovXG5cdFx0XHRcdFx0XHRcdC8qIE5vdGU6IFZhbHVlIHRyYW5zZmVycmluZyBjYW4gb3B0aW9uYWxseSBiZSBkaXNhYmxlZCBieSB0aGUgdXNlciB2aWEgdGhlIF9jYWNoZVZhbHVlcyBvcHRpb24uICovXG5cdFx0XHRcdFx0XHRcdGlmIChvcHRzLl9jYWNoZVZhbHVlcyAmJiBsYXN0VHdlZW5zQ29udGFpbmVyICYmIGxhc3RUd2VlbnNDb250YWluZXJbcHJvcGVydHldKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHN0YXJ0VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RhcnRWYWx1ZSA9IGxhc3RUd2VlbnNDb250YWluZXJbcHJvcGVydHldLmVuZFZhbHVlICsgbGFzdFR3ZWVuc0NvbnRhaW5lcltwcm9wZXJ0eV0udW5pdFR5cGU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0LyogVGhlIHByZXZpb3VzIGNhbGwncyByb290UHJvcGVydHlWYWx1ZSBpcyBleHRyYWN0ZWQgZnJvbSB0aGUgZWxlbWVudCdzIGRhdGEgY2FjaGUgc2luY2UgdGhhdCdzIHRoZVxuXHRcdFx0XHRcdFx0XHRcdCBpbnN0YW5jZSBvZiByb290UHJvcGVydHlWYWx1ZSB0aGF0IGdldHMgZnJlc2hseSB1cGRhdGVkIGJ5IHRoZSB0d2VlbmluZyBwcm9jZXNzLCB3aGVyZWFzIHRoZSByb290UHJvcGVydHlWYWx1ZVxuXHRcdFx0XHRcdFx0XHRcdCBhdHRhY2hlZCB0byB0aGUgaW5jb21pbmcgbGFzdFR3ZWVuc0NvbnRhaW5lciBpcyBlcXVhbCB0byB0aGUgcm9vdCBwcm9wZXJ0eSdzIHZhbHVlIHByaW9yIHRvIGFueSB0d2VlbmluZy4gKi9cblx0XHRcdFx0XHRcdFx0XHRyb290UHJvcGVydHlWYWx1ZSA9IGRhdGEucm9vdFByb3BlcnR5VmFsdWVDYWNoZVtyb290UHJvcGVydHldO1xuXHRcdFx0XHRcdFx0XHRcdC8qIElmIHZhbHVlcyB3ZXJlIG5vdCB0cmFuc2ZlcnJlZCBmcm9tIGEgcHJldmlvdXMgVmVsb2NpdHkgY2FsbCwgcXVlcnkgdGhlIERPTSBhcyBuZWVkZWQuICovXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0LyogSGFuZGxlIGhvb2tlZCBwcm9wZXJ0aWVzLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmIChDU1MuSG9va3MucmVnaXN0ZXJlZFtwcm9wZXJ0eV0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChzdGFydFZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cm9vdFByb3BlcnR5VmFsdWUgPSBDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCByb290UHJvcGVydHkpOyAvKiBHRVQgKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogTm90ZTogVGhlIGZvbGxvd2luZyBnZXRQcm9wZXJ0eVZhbHVlKCkgY2FsbCBkb2VzIG5vdCBhY3R1YWxseSB0cmlnZ2VyIGEgRE9NIHF1ZXJ5O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQgZ2V0UHJvcGVydHlWYWx1ZSgpIHdpbGwgZXh0cmFjdCB0aGUgaG9vayBmcm9tIHJvb3RQcm9wZXJ0eVZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlID0gQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgcHJvcGVydHksIHJvb3RQcm9wZXJ0eVZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogSWYgc3RhcnRWYWx1ZSBpcyBhbHJlYWR5IGRlZmluZWQgdmlhIGZvcmNlZmVlZGluZywgZG8gbm90IHF1ZXJ5IHRoZSBET00gZm9yIHRoZSByb290IHByb3BlcnR5J3MgdmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCBqdXN0IGdyYWIgcm9vdFByb3BlcnR5J3MgemVyby12YWx1ZSB0ZW1wbGF0ZSBmcm9tIENTUy5Ib29rcy4gVGhpcyBvdmVyd3JpdGVzIHRoZSBlbGVtZW50J3MgYWN0dWFsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCByb290IHByb3BlcnR5IHZhbHVlIChpZiBvbmUgaXMgc2V0KSwgYnV0IHRoaXMgaXMgYWNjZXB0YWJsZSBzaW5jZSB0aGUgcHJpbWFyeSByZWFzb24gdXNlcnMgZm9yY2VmZWVkIGlzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCB0byBhdm9pZCBET00gcXVlcmllcywgYW5kIHRodXMgd2UgbGlrZXdpc2UgYXZvaWQgcXVlcnlpbmcgdGhlIERPTSBmb3IgdGhlIHJvb3QgcHJvcGVydHkncyB2YWx1ZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIEdyYWIgdGhpcyBob29rJ3MgemVyby12YWx1ZSB0ZW1wbGF0ZSwgZS5nLiBcIjBweCAwcHggMHB4IGJsYWNrXCIuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJvb3RQcm9wZXJ0eVZhbHVlID0gQ1NTLkhvb2tzLnRlbXBsYXRlc1tyb290UHJvcGVydHldWzFdO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0LyogSGFuZGxlIG5vbi1ob29rZWQgcHJvcGVydGllcyB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIGRlZmluZWQgdmlhIGZvcmNlZmVlZGluZy4gKi9cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHN0YXJ0VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0c3RhcnRWYWx1ZSA9IENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIHByb3BlcnR5KTsgLyogR0VUICovXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0XHRcdCBWYWx1ZSBEYXRhIEV4dHJhY3Rpb25cblx0XHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdHZhciBzZXBhcmF0ZWRWYWx1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlVW5pdFR5cGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlVW5pdFR5cGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRvcGVyYXRvciA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHRcdC8qIFNlcGFyYXRlcyBhIHByb3BlcnR5IHZhbHVlIGludG8gaXRzIG51bWVyaWMgdmFsdWUgYW5kIGl0cyB1bml0IHR5cGUuICovXG5cdFx0XHRcdFx0XHRcdHZhciBzZXBhcmF0ZVZhbHVlID0gZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHVuaXRUeXBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRudW1lcmljVmFsdWU7XG5cblx0XHRcdFx0XHRcdFx0XHRudW1lcmljVmFsdWUgPSAodmFsdWUgfHwgXCIwXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC50b1N0cmluZygpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC50b0xvd2VyQ2FzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIE1hdGNoIHRoZSB1bml0IHR5cGUgYXQgdGhlIGVuZCBvZiB0aGUgdmFsdWUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9bJUEtel0rJC8sIGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyogR3JhYiB0aGUgdW5pdCB0eXBlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXRUeXBlID0gbWF0Y2g7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBTdHJpcCB0aGUgdW5pdCB0eXBlIG9mZiBvZiB2YWx1ZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJcIjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvKiBJZiBubyB1bml0IHR5cGUgd2FzIHN1cHBsaWVkLCBhc3NpZ24gb25lIHRoYXQgaXMgYXBwcm9wcmlhdGUgZm9yIHRoaXMgcHJvcGVydHkgKGUuZy4gXCJkZWdcIiBmb3Igcm90YXRlWiBvciBcInB4XCIgZm9yIHdpZHRoKS4gKi9cblx0XHRcdFx0XHRcdFx0XHRpZiAoIXVuaXRUeXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bml0VHlwZSA9IENTUy5WYWx1ZXMuZ2V0VW5pdFR5cGUocHJvcGVydHkpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBbbnVtZXJpY1ZhbHVlLCB1bml0VHlwZV07XG5cdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0aWYgKHN0YXJ0VmFsdWUgIT09IGVuZFZhbHVlICYmIFR5cGUuaXNTdHJpbmcoc3RhcnRWYWx1ZSkgJiYgVHlwZS5pc1N0cmluZyhlbmRWYWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRwYXR0ZXJuID0gXCJcIjtcblx0XHRcdFx0XHRcdFx0XHR2YXIgaVN0YXJ0ID0gMCwgLy8gaW5kZXggaW4gc3RhcnRWYWx1ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpRW5kID0gMCwgLy8gaW5kZXggaW4gZW5kVmFsdWVcblx0XHRcdFx0XHRcdFx0XHRcdFx0YVN0YXJ0ID0gW10sIC8vIGFycmF5IG9mIHN0YXJ0VmFsdWUgbnVtYmVyc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRhRW5kID0gW10sIC8vIGFycmF5IG9mIGVuZFZhbHVlIG51bWJlcnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0aW5DYWxjID0gMCwgLy8gS2VlcCB0cmFjayBvZiBiZWluZyBpbnNpZGUgYSBcImNhbGMoKVwiIHNvIHdlIGRvbid0IGR1cGxpY2F0ZSBpdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpblJHQiA9IDAsIC8vIEtlZXAgdHJhY2sgb2YgYmVpbmcgaW5zaWRlIGFuIFJHQiBhcyB3ZSBjYW4ndCB1c2UgZnJhY3Rpb25hbCB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0aW5SR0JBID0gMDsgLy8gS2VlcCB0cmFjayBvZiBiZWluZyBpbnNpZGUgYW4gUkdCQSBhcyB3ZSBtdXN0IHBhc3MgZnJhY3Rpb25hbCBmb3IgdGhlIGFscGhhIGNoYW5uZWxcblxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0VmFsdWUgPSBDU1MuSG9va3MuZml4Q29sb3JzKHN0YXJ0VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlID0gQ1NTLkhvb2tzLmZpeENvbG9ycyhlbmRWYWx1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKGlTdGFydCA8IHN0YXJ0VmFsdWUubGVuZ3RoICYmIGlFbmQgPCBlbmRWYWx1ZS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBjU3RhcnQgPSBzdGFydFZhbHVlW2lTdGFydF0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y0VuZCA9IGVuZFZhbHVlW2lFbmRdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoL1tcXGRcXC4tXS8udGVzdChjU3RhcnQpICYmIC9bXFxkXFwuLV0vLnRlc3QoY0VuZCkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHRTdGFydCA9IGNTdGFydCwgLy8gdGVtcG9yYXJ5IGNoYXJhY3RlciBidWZmZXJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRFbmQgPSBjRW5kLCAvLyB0ZW1wb3JhcnkgY2hhcmFjdGVyIGJ1ZmZlclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZG90U3RhcnQgPSBcIi5cIiwgLy8gTWFrZSBzdXJlIHdlIGNhbiBvbmx5IGV2ZXIgbWF0Y2ggYSBzaW5nbGUgZG90IGluIGEgZGVjaW1hbFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZG90RW5kID0gXCIuXCI7IC8vIE1ha2Ugc3VyZSB3ZSBjYW4gb25seSBldmVyIG1hdGNoIGEgc2luZ2xlIGRvdCBpbiBhIGRlY2ltYWxcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoKytpU3RhcnQgPCBzdGFydFZhbHVlLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNTdGFydCA9IHN0YXJ0VmFsdWVbaVN0YXJ0XTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoY1N0YXJ0ID09PSBkb3RTdGFydCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZG90U3RhcnQgPSBcIi4uXCI7IC8vIENhbiBuZXZlciBtYXRjaCB0d28gY2hhcmFjdGVyc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIS9cXGQvLnRlc3QoY1N0YXJ0KSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRTdGFydCArPSBjU3RhcnQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCsraUVuZCA8IGVuZFZhbHVlLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNFbmQgPSBlbmRWYWx1ZVtpRW5kXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoY0VuZCA9PT0gZG90RW5kKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkb3RFbmQgPSBcIi4uXCI7IC8vIENhbiBuZXZlciBtYXRjaCB0d28gY2hhcmFjdGVyc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIS9cXGQvLnRlc3QoY0VuZCkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0RW5kICs9IGNFbmQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHVTdGFydCA9IENTUy5Ib29rcy5nZXRVbml0KHN0YXJ0VmFsdWUsIGlTdGFydCksIC8vIHRlbXBvcmFyeSB1bml0IHR5cGVcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVFbmQgPSBDU1MuSG9va3MuZ2V0VW5pdChlbmRWYWx1ZSwgaUVuZCk7IC8vIHRlbXBvcmFyeSB1bml0IHR5cGVcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpU3RhcnQgKz0gdVN0YXJ0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aUVuZCArPSB1RW5kLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKHVTdGFydCA9PT0gdUVuZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNhbWUgdW5pdHNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAodFN0YXJ0ID09PSB0RW5kKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTYW1lIG51bWJlcnMsIHNvIGp1c3QgY29weSBvdmVyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwYXR0ZXJuICs9IHRTdGFydCArIHVTdGFydDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGlmZmVyZW50IG51bWJlcnMsIHNvIHN0b3JlIHRoZW1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBhdHRlcm4gKz0gXCJ7XCIgKyBhU3RhcnQubGVuZ3RoICsgKGluUkdCID8gXCIhXCIgOiBcIlwiKSArIFwifVwiICsgdVN0YXJ0O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YVN0YXJ0LnB1c2gocGFyc2VGbG9hdCh0U3RhcnQpKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFFbmQucHVzaChwYXJzZUZsb2F0KHRFbmQpKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGlmZmVyZW50IHVuaXRzLCBzbyBwdXQgaW50byBhIFwiY2FsYyhmcm9tICsgdG8pXCIgYW5kIGFuaW1hdGUgZWFjaCBzaWRlIHRvL2Zyb20gemVyb1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBuU3RhcnQgPSBwYXJzZUZsb2F0KHRTdGFydCksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5FbmQgPSBwYXJzZUZsb2F0KHRFbmQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cGF0dGVybiArPSAoaW5DYWxjIDwgNSA/IFwiY2FsY1wiIDogXCJcIikgKyBcIihcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQrIChuU3RhcnQgPyBcIntcIiArIGFTdGFydC5sZW5ndGggKyAoaW5SR0IgPyBcIiFcIiA6IFwiXCIpICsgXCJ9XCIgOiBcIjBcIikgKyB1U3RhcnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KyBcIiArIFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCsgKG5FbmQgPyBcIntcIiArIChhU3RhcnQubGVuZ3RoICsgKG5TdGFydCA/IDEgOiAwKSkgKyAoaW5SR0IgPyBcIiFcIiA6IFwiXCIpICsgXCJ9XCIgOiBcIjBcIikgKyB1RW5kXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCsgXCIpXCI7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKG5TdGFydCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YVN0YXJ0LnB1c2goblN0YXJ0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFFbmQucHVzaCgwKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKG5FbmQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFTdGFydC5wdXNoKDApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YUVuZC5wdXNoKG5FbmQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChjU3RhcnQgPT09IGNFbmQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGF0dGVybiArPSBjU3RhcnQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlTdGFydCsrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpRW5kKys7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEtlZXAgdHJhY2sgb2YgYmVpbmcgaW5zaWRlIGEgY2FsYygpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChpbkNhbGMgPT09IDAgJiYgY1N0YXJ0ID09PSBcImNcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fHwgaW5DYWxjID09PSAxICYmIGNTdGFydCA9PT0gXCJhXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHx8IGluQ2FsYyA9PT0gMiAmJiBjU3RhcnQgPT09IFwibFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR8fCBpbkNhbGMgPT09IDMgJiYgY1N0YXJ0ID09PSBcImNcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fHwgaW5DYWxjID49IDQgJiYgY1N0YXJ0ID09PSBcIihcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aW5DYWxjKys7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoKGluQ2FsYyAmJiBpbkNhbGMgPCA1KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fHwgaW5DYWxjID49IDQgJiYgY1N0YXJ0ID09PSBcIilcIiAmJiAtLWluQ2FsYyA8IDUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpbkNhbGMgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEtlZXAgdHJhY2sgb2YgYmVpbmcgaW5zaWRlIGFuIHJnYigpIC8gcmdiYSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChpblJHQiA9PT0gMCAmJiBjU3RhcnQgPT09IFwiclwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR8fCBpblJHQiA9PT0gMSAmJiBjU3RhcnQgPT09IFwiZ1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR8fCBpblJHQiA9PT0gMiAmJiBjU3RhcnQgPT09IFwiYlwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR8fCBpblJHQiA9PT0gMyAmJiBjU3RhcnQgPT09IFwiYVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR8fCBpblJHQiA+PSAzICYmIGNTdGFydCA9PT0gXCIoXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChpblJHQiA9PT0gMyAmJiBjU3RhcnQgPT09IFwiYVwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpblJHQkEgPSAxO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpblJHQisrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGluUkdCQSAmJiBjU3RhcnQgPT09IFwiLFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCsraW5SR0JBID4gMykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aW5SR0IgPSBpblJHQkEgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICgoaW5SR0JBICYmIGluUkdCIDwgKGluUkdCQSA/IDUgOiA0KSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHx8IGluUkdCID49IChpblJHQkEgPyA0IDogMykgJiYgY1N0YXJ0ID09PSBcIilcIiAmJiAtLWluUkdCIDwgKGluUkdCQSA/IDUgOiA0KSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGluUkdCID0gaW5SR0JBID0gMDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aW5DYWxjID0gMDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogY2hhbmdpbmcgdW5pdHMsIGZpeGluZyBjb2xvdXJzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoaVN0YXJ0ICE9PSBzdGFydFZhbHVlLmxlbmd0aCB8fCBpRW5kICE9PSBlbmRWYWx1ZS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChWZWxvY2l0eS5kZWJ1Zykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFwiVHJ5aW5nIHRvIHBhdHRlcm4gbWF0Y2ggbWlzLW1hdGNoZWQgc3RyaW5ncyBbXFxcIlwiICsgZW5kVmFsdWUgKyBcIlxcXCIsIFxcXCJcIiArIHN0YXJ0VmFsdWUgKyBcIlxcXCJdXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0cGF0dGVybiA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHBhdHRlcm4pIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChhU3RhcnQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChWZWxvY2l0eS5kZWJ1Zykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiUGF0dGVybiBmb3VuZCBcXFwiXCIgKyBwYXR0ZXJuICsgXCJcXFwiIC0+IFwiLCBhU3RhcnQsIGFFbmQsIFwiW1wiICsgc3RhcnRWYWx1ZSArIFwiLFwiICsgZW5kVmFsdWUgKyBcIl1cIik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0c3RhcnRWYWx1ZSA9IGFTdGFydDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSBhRW5kO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRlbmRWYWx1ZVVuaXRUeXBlID0gc3RhcnRWYWx1ZVVuaXRUeXBlID0gXCJcIjtcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBhdHRlcm4gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKCFwYXR0ZXJuKSB7XG5cdFx0XHRcdFx0XHRcdFx0LyogU2VwYXJhdGUgc3RhcnRWYWx1ZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRzZXBhcmF0ZWRWYWx1ZSA9IHNlcGFyYXRlVmFsdWUocHJvcGVydHksIHN0YXJ0VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0VmFsdWUgPSBzZXBhcmF0ZWRWYWx1ZVswXTtcblx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlVW5pdFR5cGUgPSBzZXBhcmF0ZWRWYWx1ZVsxXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8qIFNlcGFyYXRlIGVuZFZhbHVlLCBhbmQgZXh0cmFjdCBhIHZhbHVlIG9wZXJhdG9yIChlLmcuIFwiKz1cIiwgXCItPVwiKSBpZiBvbmUgZXhpc3RzLiAqL1xuXHRcdFx0XHRcdFx0XHRcdHNlcGFyYXRlZFZhbHVlID0gc2VwYXJhdGVWYWx1ZShwcm9wZXJ0eSwgZW5kVmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlID0gc2VwYXJhdGVkVmFsdWVbMF0ucmVwbGFjZSgvXihbKy1cXC8qXSk9LywgZnVuY3Rpb24obWF0Y2gsIHN1Yk1hdGNoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRvcGVyYXRvciA9IHN1Yk1hdGNoO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBTdHJpcCB0aGUgb3BlcmF0b3Igb2ZmIG9mIHRoZSB2YWx1ZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBcIlwiO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlVW5pdFR5cGUgPSBzZXBhcmF0ZWRWYWx1ZVsxXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8qIFBhcnNlIGZsb2F0IHZhbHVlcyBmcm9tIGVuZFZhbHVlIGFuZCBzdGFydFZhbHVlLiBEZWZhdWx0IHRvIDAgaWYgTmFOIGlzIHJldHVybmVkLiAqL1xuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0VmFsdWUgPSBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpIHx8IDA7XG5cdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSBwYXJzZUZsb2F0KGVuZFZhbHVlKSB8fCAwO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHRcdCBQcm9wZXJ0eS1TcGVjaWZpYyBWYWx1ZSBDb252ZXJzaW9uXG5cdFx0XHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdFx0XHRcdC8qIEN1c3RvbSBzdXBwb3J0IGZvciBwcm9wZXJ0aWVzIHRoYXQgZG9uJ3QgYWN0dWFsbHkgYWNjZXB0IHRoZSAlIHVuaXQgdHlwZSwgYnV0IHdoZXJlIHBvbGx5ZmlsbGluZyBpcyB0cml2aWFsIGFuZCByZWxhdGl2ZWx5IGZvb2xwcm9vZi4gKi9cblx0XHRcdFx0XHRcdFx0XHRpZiAoZW5kVmFsdWVVbml0VHlwZSA9PT0gXCIlXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8qIEEgJS12YWx1ZSBmb250U2l6ZS9saW5lSGVpZ2h0IGlzIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQncyBmb250U2l6ZSAoYXMgb3Bwb3NlZCB0byB0aGUgcGFyZW50J3MgZGltZW5zaW9ucyksXG5cdFx0XHRcdFx0XHRcdFx0XHQgd2hpY2ggaXMgaWRlbnRpY2FsIHRvIHRoZSBlbSB1bml0J3MgYmVoYXZpb3IsIHNvIHdlIHBpZ2d5YmFjayBvZmYgb2YgdGhhdC4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdGlmICgvXihmb250U2l6ZXxsaW5lSGVpZ2h0KSQvLnRlc3QocHJvcGVydHkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIENvbnZlcnQgJSBpbnRvIGFuIGVtIGRlY2ltYWwgdmFsdWUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlID0gZW5kVmFsdWUgLyAxMDA7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlVW5pdFR5cGUgPSBcImVtXCI7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIEZvciBzY2FsZVggYW5kIHNjYWxlWSwgY29udmVydCB0aGUgdmFsdWUgaW50byBpdHMgZGVjaW1hbCBmb3JtYXQgYW5kIHN0cmlwIG9mZiB0aGUgdW5pdCB0eXBlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICgvXnNjYWxlLy50ZXN0KHByb3BlcnR5KSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRlbmRWYWx1ZSA9IGVuZFZhbHVlIC8gMTAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRlbmRWYWx1ZVVuaXRUeXBlID0gXCJcIjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogRm9yIFJHQiBjb21wb25lbnRzLCB0YWtlIHRoZSBkZWZpbmVkIHBlcmNlbnRhZ2Ugb2YgMjU1IGFuZCBzdHJpcCBvZmYgdGhlIHVuaXQgdHlwZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoLyhSZWR8R3JlZW58Qmx1ZSkkL2kudGVzdChwcm9wZXJ0eSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSAoZW5kVmFsdWUgLyAxMDApICogMjU1O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRlbmRWYWx1ZVVuaXRUeXBlID0gXCJcIjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0XHRcdCBVbml0IFJhdGlvIENhbGN1bGF0aW9uXG5cdFx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHRcdFx0LyogV2hlbiBxdWVyaWVkLCB0aGUgYnJvd3NlciByZXR1cm5zIChtb3N0KSBDU1MgcHJvcGVydHkgdmFsdWVzIGluIHBpeGVscy4gVGhlcmVmb3JlLCBpZiBhbiBlbmRWYWx1ZSB3aXRoIGEgdW5pdCB0eXBlIG9mXG5cdFx0XHRcdFx0XHRcdCAlLCBlbSwgb3IgcmVtIGlzIGFuaW1hdGVkIHRvd2FyZCwgc3RhcnRWYWx1ZSBtdXN0IGJlIGNvbnZlcnRlZCBmcm9tIHBpeGVscyBpbnRvIHRoZSBzYW1lIHVuaXQgdHlwZSBhcyBlbmRWYWx1ZSBpbiBvcmRlclxuXHRcdFx0XHRcdFx0XHQgZm9yIHZhbHVlIG1hbmlwdWxhdGlvbiBsb2dpYyAoaW5jcmVtZW50L2RlY3JlbWVudCkgdG8gcHJvY2VlZC4gRnVydGhlciwgaWYgdGhlIHN0YXJ0VmFsdWUgd2FzIGZvcmNlZmVkIG9yIHRyYW5zZmVycmVkXG5cdFx0XHRcdFx0XHRcdCBmcm9tIGEgcHJldmlvdXMgY2FsbCwgc3RhcnRWYWx1ZSBtYXkgYWxzbyBub3QgYmUgaW4gcGl4ZWxzLiBVbml0IGNvbnZlcnNpb24gbG9naWMgdGhlcmVmb3JlIGNvbnNpc3RzIG9mIHR3byBzdGVwczpcblx0XHRcdFx0XHRcdFx0IDEpIENhbGN1bGF0aW5nIHRoZSByYXRpbyBvZiAlL2VtL3JlbS92aC92dyByZWxhdGl2ZSB0byBwaXhlbHNcblx0XHRcdFx0XHRcdFx0IDIpIENvbnZlcnRpbmcgc3RhcnRWYWx1ZSBpbnRvIHRoZSBzYW1lIHVuaXQgb2YgbWVhc3VyZW1lbnQgYXMgZW5kVmFsdWUgYmFzZWQgb24gdGhlc2UgcmF0aW9zLiAqL1xuXHRcdFx0XHRcdFx0XHQvKiBVbml0IGNvbnZlcnNpb24gcmF0aW9zIGFyZSBjYWxjdWxhdGVkIGJ5IGluc2VydGluZyBhIHNpYmxpbmcgbm9kZSBuZXh0IHRvIHRoZSB0YXJnZXQgbm9kZSwgY29weWluZyBvdmVyIGl0cyBwb3NpdGlvbiBwcm9wZXJ0eSxcblx0XHRcdFx0XHRcdFx0IHNldHRpbmcgdmFsdWVzIHdpdGggdGhlIHRhcmdldCB1bml0IHR5cGUgdGhlbiBjb21wYXJpbmcgdGhlIHJldHVybmVkIHBpeGVsIHZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHQvKiBOb3RlOiBFdmVuIGlmIG9ubHkgb25lIG9mIHRoZXNlIHVuaXQgdHlwZXMgaXMgYmVpbmcgYW5pbWF0ZWQsIGFsbCB1bml0IHJhdGlvcyBhcmUgY2FsY3VsYXRlZCBhdCBvbmNlIHNpbmNlIHRoZSBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHQgb2YgYmF0Y2hpbmcgdGhlIFNFVHMgYW5kIEdFVHMgdG9nZXRoZXIgdXBmcm9udCBvdXR3ZWlnaHRzIHRoZSBwb3RlbnRpYWwgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0IG9mIGxheW91dCB0aHJhc2hpbmcgY2F1c2VkIGJ5IHJlLXF1ZXJ5aW5nIGZvciB1bmNhbGN1bGF0ZWQgcmF0aW9zIGZvciBzdWJzZXF1ZW50bHktcHJvY2Vzc2VkIHByb3BlcnRpZXMuICovXG5cdFx0XHRcdFx0XHRcdC8qIFRvZG86IFNoaWZ0IHRoaXMgbG9naWMgaW50byB0aGUgY2FsbHMnIGZpcnN0IHRpY2sgaW5zdGFuY2Ugc28gdGhhdCBpdCdzIHN5bmNlZCB3aXRoIFJBRi4gKi9cblx0XHRcdFx0XHRcdFx0dmFyIGNhbGN1bGF0ZVVuaXRSYXRpb3MgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdFx0XHQgU2FtZSBSYXRpbyBDaGVja3Ncblx0XHRcdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogVGhlIHByb3BlcnRpZXMgYmVsb3cgYXJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGVsZW1lbnQgZGlmZmVycyBzdWZmaWNpZW50bHkgZnJvbSB0aGlzIGNhbGwnc1xuXHRcdFx0XHRcdFx0XHRcdCBwcmV2aW91c2x5IGl0ZXJhdGVkIGVsZW1lbnQgdG8gYWxzbyBkaWZmZXIgaW4gaXRzIHVuaXQgY29udmVyc2lvbiByYXRpb3MuIElmIHRoZSBwcm9wZXJ0aWVzIG1hdGNoIHVwIHdpdGggdGhvc2Vcblx0XHRcdFx0XHRcdFx0XHQgb2YgdGhlIHByaW9yIGVsZW1lbnQsIHRoZSBwcmlvciBlbGVtZW50J3MgY29udmVyc2lvbiByYXRpb3MgYXJlIHVzZWQuIExpa2UgbW9zdCBvcHRpbWl6YXRpb25zIGluIFZlbG9jaXR5LFxuXHRcdFx0XHRcdFx0XHRcdCB0aGlzIGlzIGRvbmUgdG8gbWluaW1pemUgRE9NIHF1ZXJ5aW5nLiAqL1xuXHRcdFx0XHRcdFx0XHRcdHZhciBzYW1lUmF0aW9JbmRpY2F0b3JzID0ge1xuXHRcdFx0XHRcdFx0XHRcdFx0bXlQYXJlbnQ6IGVsZW1lbnQucGFyZW50Tm9kZSB8fCBkb2N1bWVudC5ib2R5LCAvKiBHRVQgKi9cblx0XHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uOiBDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcInBvc2l0aW9uXCIpLCAvKiBHRVQgKi9cblx0XHRcdFx0XHRcdFx0XHRcdGZvbnRTaXplOiBDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcImZvbnRTaXplXCIpIC8qIEdFVCAqL1xuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIERldGVybWluZSBpZiB0aGUgc2FtZSAlIHJhdGlvIGNhbiBiZSB1c2VkLiAlIGlzIGJhc2VkIG9uIHRoZSBlbGVtZW50J3MgcG9zaXRpb24gdmFsdWUgYW5kIGl0cyBwYXJlbnQncyB3aWR0aCBhbmQgaGVpZ2h0IGRpbWVuc2lvbnMuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHNhbWVQZXJjZW50UmF0aW8gPSAoKHNhbWVSYXRpb0luZGljYXRvcnMucG9zaXRpb24gPT09IGNhbGxVbml0Q29udmVyc2lvbkRhdGEubGFzdFBvc2l0aW9uKSAmJiAoc2FtZVJhdGlvSW5kaWNhdG9ycy5teVBhcmVudCA9PT0gY2FsbFVuaXRDb252ZXJzaW9uRGF0YS5sYXN0UGFyZW50KSksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIERldGVybWluZSBpZiB0aGUgc2FtZSBlbSByYXRpbyBjYW4gYmUgdXNlZC4gZW0gaXMgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQncyBmb250U2l6ZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0c2FtZUVtUmF0aW8gPSAoc2FtZVJhdGlvSW5kaWNhdG9ycy5mb250U2l6ZSA9PT0gY2FsbFVuaXRDb252ZXJzaW9uRGF0YS5sYXN0Rm9udFNpemUpO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogU3RvcmUgdGhlc2UgcmF0aW8gaW5kaWNhdG9ycyBjYWxsLXdpZGUgZm9yIHRoZSBuZXh0IGVsZW1lbnQgdG8gY29tcGFyZSBhZ2FpbnN0LiAqL1xuXHRcdFx0XHRcdFx0XHRcdGNhbGxVbml0Q29udmVyc2lvbkRhdGEubGFzdFBhcmVudCA9IHNhbWVSYXRpb0luZGljYXRvcnMubXlQYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbFVuaXRDb252ZXJzaW9uRGF0YS5sYXN0UG9zaXRpb24gPSBzYW1lUmF0aW9JbmRpY2F0b3JzLnBvc2l0aW9uO1xuXHRcdFx0XHRcdFx0XHRcdGNhbGxVbml0Q29udmVyc2lvbkRhdGEubGFzdEZvbnRTaXplID0gc2FtZVJhdGlvSW5kaWNhdG9ycy5mb250U2l6ZTtcblxuXHRcdFx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdFx0XHQgRWxlbWVudC1TcGVjaWZpYyBVbml0c1xuXHRcdFx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHRcdFx0XHQvKiBOb3RlOiBJRTggcm91bmRzIHRvIHRoZSBuZWFyZXN0IHBpeGVsIHdoZW4gcmV0dXJuaW5nIENTUyB2YWx1ZXMsIHRodXMgd2UgcGVyZm9ybSBjb252ZXJzaW9ucyB1c2luZyBhIG1lYXN1cmVtZW50XG5cdFx0XHRcdFx0XHRcdFx0IG9mIDEwMCAoaW5zdGVhZCBvZiAxKSB0byBnaXZlIG91ciByYXRpb3MgYSBwcmVjaXNpb24gb2YgYXQgbGVhc3QgMiBkZWNpbWFsIHZhbHVlcy4gKi9cblx0XHRcdFx0XHRcdFx0XHR2YXIgbWVhc3VyZW1lbnQgPSAxMDAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXRSYXRpb3MgPSB7fTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICghc2FtZUVtUmF0aW8gfHwgIXNhbWVQZXJjZW50UmF0aW8pIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBkdW1teSA9IGRhdGEgJiYgZGF0YS5pc1NWRyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicmVjdFwiKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFZlbG9jaXR5LmluaXQoZHVtbXkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0c2FtZVJhdGlvSW5kaWNhdG9ycy5teVBhcmVudC5hcHBlbmRDaGlsZChkdW1teSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8qIFRvIGFjY3VyYXRlbHkgYW5kIGNvbnNpc3RlbnRseSBjYWxjdWxhdGUgY29udmVyc2lvbiByYXRpb3MsIHRoZSBlbGVtZW50J3MgY2FzY2FkZWQgb3ZlcmZsb3cgYW5kIGJveC1zaXppbmcgYXJlIHN0cmlwcGVkLlxuXHRcdFx0XHRcdFx0XHRcdFx0IFNpbWlsYXJseSwgc2luY2Ugd2lkdGgvaGVpZ2h0IGNhbiBiZSBhcnRpZmljaWFsbHkgY29uc3RyYWluZWQgYnkgdGhlaXIgbWluLS9tYXgtIGVxdWl2YWxlbnRzLCB0aGVzZSBhcmUgY29udHJvbGxlZCBmb3IgYXMgd2VsbC4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdC8qIE5vdGU6IE92ZXJmbG93IG11c3QgYmUgYWxzbyBiZSBjb250cm9sbGVkIGZvciBwZXItYXhpcyBzaW5jZSB0aGUgb3ZlcmZsb3cgcHJvcGVydHkgb3ZlcndyaXRlcyBpdHMgcGVyLWF4aXMgdmFsdWVzLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0JC5lYWNoKFtcIm92ZXJmbG93XCIsIFwib3ZlcmZsb3dYXCIsIFwib3ZlcmZsb3dZXCJdLCBmdW5jdGlvbihpLCBwcm9wZXJ0eSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRWZWxvY2l0eS5DU1Muc2V0UHJvcGVydHlWYWx1ZShkdW1teSwgcHJvcGVydHksIFwiaGlkZGVuXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRWZWxvY2l0eS5DU1Muc2V0UHJvcGVydHlWYWx1ZShkdW1teSwgXCJwb3NpdGlvblwiLCBzYW1lUmF0aW9JbmRpY2F0b3JzLnBvc2l0aW9uKTtcblx0XHRcdFx0XHRcdFx0XHRcdFZlbG9jaXR5LkNTUy5zZXRQcm9wZXJ0eVZhbHVlKGR1bW15LCBcImZvbnRTaXplXCIsIHNhbWVSYXRpb0luZGljYXRvcnMuZm9udFNpemUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0VmVsb2NpdHkuQ1NTLnNldFByb3BlcnR5VmFsdWUoZHVtbXksIFwiYm94U2l6aW5nXCIsIFwiY29udGVudC1ib3hcIik7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8qIHdpZHRoIGFuZCBoZWlnaHQgYWN0IGFzIG91ciBwcm94eSBwcm9wZXJ0aWVzIGZvciBtZWFzdXJpbmcgdGhlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsICUgcmF0aW9zLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0JC5lYWNoKFtcIm1pbldpZHRoXCIsIFwibWF4V2lkdGhcIiwgXCJ3aWR0aFwiLCBcIm1pbkhlaWdodFwiLCBcIm1heEhlaWdodFwiLCBcImhlaWdodFwiXSwgZnVuY3Rpb24oaSwgcHJvcGVydHkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0VmVsb2NpdHkuQ1NTLnNldFByb3BlcnR5VmFsdWUoZHVtbXksIHByb3BlcnR5LCBtZWFzdXJlbWVudCArIFwiJVwiKTtcblx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0LyogcGFkZGluZ0xlZnQgYXJiaXRyYXJpbHkgYWN0cyBhcyBvdXIgcHJveHkgcHJvcGVydHkgZm9yIHRoZSBlbSByYXRpby4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFZlbG9jaXR5LkNTUy5zZXRQcm9wZXJ0eVZhbHVlKGR1bW15LCBcInBhZGRpbmdMZWZ0XCIsIG1lYXN1cmVtZW50ICsgXCJlbVwiKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0LyogRGl2aWRlIHRoZSByZXR1cm5lZCB2YWx1ZSBieSB0aGUgbWVhc3VyZW1lbnQgdG8gZ2V0IHRoZSByYXRpbyBiZXR3ZWVuIDElIGFuZCAxcHguIERlZmF1bHQgdG8gMSBzaW5jZSB3b3JraW5nIHdpdGggMCBjYW4gcHJvZHVjZSBJbmZpbml0ZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdHVuaXRSYXRpb3MucGVyY2VudFRvUHhXaWR0aCA9IGNhbGxVbml0Q29udmVyc2lvbkRhdGEubGFzdFBlcmNlbnRUb1B4V2lkdGggPSAocGFyc2VGbG9hdChDU1MuZ2V0UHJvcGVydHlWYWx1ZShkdW1teSwgXCJ3aWR0aFwiLCBudWxsLCB0cnVlKSkgfHwgMSkgLyBtZWFzdXJlbWVudDsgLyogR0VUICovXG5cdFx0XHRcdFx0XHRcdFx0XHR1bml0UmF0aW9zLnBlcmNlbnRUb1B4SGVpZ2h0ID0gY2FsbFVuaXRDb252ZXJzaW9uRGF0YS5sYXN0UGVyY2VudFRvUHhIZWlnaHQgPSAocGFyc2VGbG9hdChDU1MuZ2V0UHJvcGVydHlWYWx1ZShkdW1teSwgXCJoZWlnaHRcIiwgbnVsbCwgdHJ1ZSkpIHx8IDEpIC8gbWVhc3VyZW1lbnQ7IC8qIEdFVCAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pdFJhdGlvcy5lbVRvUHggPSBjYWxsVW5pdENvbnZlcnNpb25EYXRhLmxhc3RFbVRvUHggPSAocGFyc2VGbG9hdChDU1MuZ2V0UHJvcGVydHlWYWx1ZShkdW1teSwgXCJwYWRkaW5nTGVmdFwiKSkgfHwgMSkgLyBtZWFzdXJlbWVudDsgLyogR0VUICovXG5cblx0XHRcdFx0XHRcdFx0XHRcdHNhbWVSYXRpb0luZGljYXRvcnMubXlQYXJlbnQucmVtb3ZlQ2hpbGQoZHVtbXkpO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bml0UmF0aW9zLmVtVG9QeCA9IGNhbGxVbml0Q29udmVyc2lvbkRhdGEubGFzdEVtVG9QeDtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXRSYXRpb3MucGVyY2VudFRvUHhXaWR0aCA9IGNhbGxVbml0Q29udmVyc2lvbkRhdGEubGFzdFBlcmNlbnRUb1B4V2lkdGg7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bml0UmF0aW9zLnBlcmNlbnRUb1B4SGVpZ2h0ID0gY2FsbFVuaXRDb252ZXJzaW9uRGF0YS5sYXN0UGVyY2VudFRvUHhIZWlnaHQ7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHRcdCBFbGVtZW50LUFnbm9zdGljIFVuaXRzXG5cdFx0XHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdFx0XHRcdC8qIFdoZXJlYXMgJSBhbmQgZW0gcmF0aW9zIGFyZSBkZXRlcm1pbmVkIG9uIGEgcGVyLWVsZW1lbnQgYmFzaXMsIHRoZSByZW0gdW5pdCBvbmx5IG5lZWRzIHRvIGJlIGNoZWNrZWRcblx0XHRcdFx0XHRcdFx0XHQgb25jZSBwZXIgY2FsbCBzaW5jZSBpdCdzIGV4Y2x1c2l2ZWx5IGRlcGVuZGFudCB1cG9uIGRvY3VtZW50LmJvZHkncyBmb250U2l6ZS4gSWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZVxuXHRcdFx0XHRcdFx0XHRcdCB0aGF0IGNhbGN1bGF0ZVVuaXRSYXRpb3MoKSBpcyBiZWluZyBydW4gZHVyaW5nIHRoaXMgY2FsbCwgcmVtVG9QeCB3aWxsIHN0aWxsIGJlIHNldCB0byBpdHMgZGVmYXVsdCB2YWx1ZSBvZiBudWxsLFxuXHRcdFx0XHRcdFx0XHRcdCBzbyB3ZSBjYWxjdWxhdGUgaXQgbm93LiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmIChjYWxsVW5pdENvbnZlcnNpb25EYXRhLnJlbVRvUHggPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8qIERlZmF1bHQgdG8gYnJvd3NlcnMnIGRlZmF1bHQgZm9udFNpemUgb2YgMTZweCBpbiB0aGUgY2FzZSBvZiAwLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FsbFVuaXRDb252ZXJzaW9uRGF0YS5yZW1Ub1B4ID0gcGFyc2VGbG9hdChDU1MuZ2V0UHJvcGVydHlWYWx1ZShkb2N1bWVudC5ib2R5LCBcImZvbnRTaXplXCIpKSB8fCAxNjsgLyogR0VUICovXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0LyogU2ltaWxhcmx5LCB2aWV3cG9ydCB1bml0cyBhcmUgJS1yZWxhdGl2ZSB0byB0aGUgd2luZG93J3MgaW5uZXIgZGltZW5zaW9ucy4gKi9cblx0XHRcdFx0XHRcdFx0XHRpZiAoY2FsbFVuaXRDb252ZXJzaW9uRGF0YS52d1RvUHggPT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNhbGxVbml0Q29udmVyc2lvbkRhdGEudndUb1B4ID0gcGFyc2VGbG9hdCh3aW5kb3cuaW5uZXJXaWR0aCkgLyAxMDA7IC8qIEdFVCAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FsbFVuaXRDb252ZXJzaW9uRGF0YS52aFRvUHggPSBwYXJzZUZsb2F0KHdpbmRvdy5pbm5lckhlaWdodCkgLyAxMDA7IC8qIEdFVCAqL1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdHVuaXRSYXRpb3MucmVtVG9QeCA9IGNhbGxVbml0Q29udmVyc2lvbkRhdGEucmVtVG9QeDtcblx0XHRcdFx0XHRcdFx0XHR1bml0UmF0aW9zLnZ3VG9QeCA9IGNhbGxVbml0Q29udmVyc2lvbkRhdGEudndUb1B4O1xuXHRcdFx0XHRcdFx0XHRcdHVuaXRSYXRpb3MudmhUb1B4ID0gY2FsbFVuaXRDb252ZXJzaW9uRGF0YS52aFRvUHg7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoVmVsb2NpdHkuZGVidWcgPj0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJVbml0IHJhdGlvczogXCIgKyBKU09OLnN0cmluZ2lmeSh1bml0UmF0aW9zKSwgZWxlbWVudCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB1bml0UmF0aW9zO1xuXHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHQgVW5pdCBDb252ZXJzaW9uXG5cdFx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdFx0XHQvKiBUaGUgKiBhbmQgLyBvcGVyYXRvcnMsIHdoaWNoIGFyZSBub3QgcGFzc2VkIGluIHdpdGggYW4gYXNzb2NpYXRlZCB1bml0LCBpbmhlcmVudGx5IHVzZSBzdGFydFZhbHVlJ3MgdW5pdC4gU2tpcCB2YWx1ZSBhbmQgdW5pdCBjb252ZXJzaW9uLiAqL1xuXHRcdFx0XHRcdFx0XHRpZiAoL1tcXC8qXS8udGVzdChvcGVyYXRvcikpIHtcblx0XHRcdFx0XHRcdFx0XHRlbmRWYWx1ZVVuaXRUeXBlID0gc3RhcnRWYWx1ZVVuaXRUeXBlO1xuXHRcdFx0XHRcdFx0XHRcdC8qIElmIHN0YXJ0VmFsdWUgYW5kIGVuZFZhbHVlIGRpZmZlciBpbiB1bml0IHR5cGUsIGNvbnZlcnQgc3RhcnRWYWx1ZSBpbnRvIHRoZSBzYW1lIHVuaXQgdHlwZSBhcyBlbmRWYWx1ZSBzbyB0aGF0IGlmIGVuZFZhbHVlVW5pdFR5cGVcblx0XHRcdFx0XHRcdFx0XHQgaXMgYSByZWxhdGl2ZSB1bml0ICglLCBlbSwgcmVtKSwgdGhlIHZhbHVlcyBzZXQgZHVyaW5nIHR3ZWVuaW5nIHdpbGwgY29udGludWUgdG8gYmUgYWNjdXJhdGVseSByZWxhdGl2ZSBldmVuIGlmIHRoZSBtZXRyaWNzIHRoZXkgZGVwZW5kXG5cdFx0XHRcdFx0XHRcdFx0IG9uIGFyZSBkeW5hbWljYWxseSBjaGFuZ2luZyBkdXJpbmcgdGhlIGNvdXJzZSBvZiB0aGUgYW5pbWF0aW9uLiBDb252ZXJzZWx5LCBpZiB3ZSBhbHdheXMgbm9ybWFsaXplZCBpbnRvIHB4IGFuZCB1c2VkIHB4IGZvciBzZXR0aW5nIHZhbHVlcywgdGhlIHB4IHJhdGlvXG5cdFx0XHRcdFx0XHRcdFx0IHdvdWxkIGJlY29tZSBzdGFsZSBpZiB0aGUgb3JpZ2luYWwgdW5pdCBiZWluZyBhbmltYXRlZCB0b3dhcmQgd2FzIHJlbGF0aXZlIGFuZCB0aGUgdW5kZXJseWluZyBtZXRyaWNzIGNoYW5nZSBkdXJpbmcgdGhlIGFuaW1hdGlvbi4gKi9cblx0XHRcdFx0XHRcdFx0XHQvKiBTaW5jZSAwIGlzIDAgaW4gYW55IHVuaXQgdHlwZSwgbm8gY29udmVyc2lvbiBpcyBuZWNlc3Nhcnkgd2hlbiBzdGFydFZhbHVlIGlzIDAgLS0gd2UganVzdCBzdGFydCBhdCAwIHdpdGggZW5kVmFsdWVVbml0VHlwZS4gKi9cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICgoc3RhcnRWYWx1ZVVuaXRUeXBlICE9PSBlbmRWYWx1ZVVuaXRUeXBlKSAmJiBzdGFydFZhbHVlICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0LyogVW5pdCBjb252ZXJzaW9uIGlzIGFsc28gc2tpcHBlZCB3aGVuIGVuZFZhbHVlIGlzIDAsIGJ1dCAqc3RhcnRWYWx1ZVVuaXRUeXBlKiBtdXN0IGJlIHVzZWQgZm9yIHR3ZWVuIHZhbHVlcyB0byByZW1haW4gYWNjdXJhdGUuICovXG5cdFx0XHRcdFx0XHRcdFx0LyogTm90ZTogU2tpcHBpbmcgdW5pdCBjb252ZXJzaW9uIGhlcmUgbWVhbnMgdGhhdCBpZiBlbmRWYWx1ZVVuaXRUeXBlIHdhcyBvcmlnaW5hbGx5IGEgcmVsYXRpdmUgdW5pdCwgdGhlIGFuaW1hdGlvbiB3b24ndCByZWxhdGl2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0IG1hdGNoIHRoZSB1bmRlcmx5aW5nIG1ldHJpY3MgaWYgdGhleSBjaGFuZ2UsIGJ1dCB0aGlzIGlzIGFjY2VwdGFibGUgc2luY2Ugd2UncmUgYW5pbWF0aW5nIHRvd2FyZCBpbnZpc2liaWxpdHkgaW5zdGVhZCBvZiB0b3dhcmQgdmlzaWJpbGl0eSxcblx0XHRcdFx0XHRcdFx0XHQgd2hpY2ggcmVtYWlucyBwYXN0IHRoZSBwb2ludCBvZiB0aGUgYW5pbWF0aW9uJ3MgY29tcGxldGlvbi4gKi9cblx0XHRcdFx0XHRcdFx0XHRpZiAoZW5kVmFsdWUgPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlVW5pdFR5cGUgPSBzdGFydFZhbHVlVW5pdFR5cGU7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8qIEJ5IHRoaXMgcG9pbnQsIHdlIGNhbm5vdCBhdm9pZCB1bml0IGNvbnZlcnNpb24gKGl0J3MgdW5kZXNpcmFibGUgc2luY2UgaXQgY2F1c2VzIGxheW91dCB0aHJhc2hpbmcpLlxuXHRcdFx0XHRcdFx0XHRcdFx0IElmIHdlIGhhdmVuJ3QgYWxyZWFkeSwgd2UgdHJpZ2dlciBjYWxjdWxhdGVVbml0UmF0aW9zKCksIHdoaWNoIHJ1bnMgb25jZSBwZXIgZWxlbWVudCBwZXIgY2FsbC4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdGVsZW1lbnRVbml0Q29udmVyc2lvbkRhdGEgPSBlbGVtZW50VW5pdENvbnZlcnNpb25EYXRhIHx8IGNhbGN1bGF0ZVVuaXRSYXRpb3MoKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0LyogVGhlIGZvbGxvd2luZyBSZWdFeCBtYXRjaGVzIENTUyBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSB0aGVpciAlIHZhbHVlcyBtZWFzdXJlZCByZWxhdGl2ZSB0byB0aGUgeC1heGlzLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0LyogTm90ZTogVzNDIHNwZWMgbWFuZGF0ZXMgdGhhdCBhbGwgb2YgbWFyZ2luIGFuZCBwYWRkaW5nJ3MgcHJvcGVydGllcyAoZXZlbiB0b3AgYW5kIGJvdHRvbSkgYXJlICUtcmVsYXRpdmUgdG8gdGhlICp3aWR0aCogb2YgdGhlIHBhcmVudCBlbGVtZW50LiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGF4aXMgPSAoL21hcmdpbnxwYWRkaW5nfGxlZnR8cmlnaHR8d2lkdGh8dGV4dHx3b3JkfGxldHRlci9pLnRlc3QocHJvcGVydHkpIHx8IC9YJC8udGVzdChwcm9wZXJ0eSkgfHwgcHJvcGVydHkgPT09IFwieFwiKSA/IFwieFwiIDogXCJ5XCI7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8qIEluIG9yZGVyIHRvIGF2b2lkIGdlbmVyYXRpbmcgbl4yIGJlc3Bva2UgY29udmVyc2lvbiBmdW5jdGlvbnMsIHVuaXQgY29udmVyc2lvbiBpcyBhIHR3by1zdGVwIHByb2Nlc3M6XG5cdFx0XHRcdFx0XHRcdFx0XHQgMSkgQ29udmVydCBzdGFydFZhbHVlIGludG8gcGl4ZWxzLiAyKSBDb252ZXJ0IHRoaXMgbmV3IHBpeGVsIHZhbHVlIGludG8gZW5kVmFsdWUncyB1bml0IHR5cGUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRzd2l0Y2ggKHN0YXJ0VmFsdWVVbml0VHlwZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFwiJVwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIE5vdGU6IHRyYW5zbGF0ZVggYW5kIHRyYW5zbGF0ZVkgYXJlIHRoZSBvbmx5IHByb3BlcnRpZXMgdGhhdCBhcmUgJS1yZWxhdGl2ZSB0byBhbiBlbGVtZW50J3Mgb3duIGRpbWVuc2lvbnMgLS0gbm90IGl0cyBwYXJlbnQncyBkaW1lbnNpb25zLlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCBWZWxvY2l0eSBkb2VzIG5vdCBpbmNsdWRlIGEgc3BlY2lhbCBjb252ZXJzaW9uIHByb2Nlc3MgdG8gYWNjb3VudCBmb3IgdGhpcyBiZWhhdmlvci4gVGhlcmVmb3JlLCBhbmltYXRpbmcgdHJhbnNsYXRlWC9ZIGZyb20gYSAlIHZhbHVlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0IHRvIGEgbm9uLSUgdmFsdWUgd2lsbCBwcm9kdWNlIGFuIGluY29ycmVjdCBzdGFydCB2YWx1ZS4gRm9ydHVuYXRlbHksIHRoaXMgc29ydCBvZiBjcm9zcy11bml0IGNvbnZlcnNpb24gaXMgcmFyZWx5IGRvbmUgYnkgdXNlcnMgaW4gcHJhY3RpY2UuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3RhcnRWYWx1ZSAqPSAoYXhpcyA9PT0gXCJ4XCIgPyBlbGVtZW50VW5pdENvbnZlcnNpb25EYXRhLnBlcmNlbnRUb1B4V2lkdGggOiBlbGVtZW50VW5pdENvbnZlcnNpb25EYXRhLnBlcmNlbnRUb1B4SGVpZ2h0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFwicHhcIjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBweCBhY3RzIGFzIG91ciBtaWRwb2ludCBpbiB0aGUgdW5pdCBjb252ZXJzaW9uIHByb2Nlc3M7IGRvIG5vdGhpbmcuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlICo9IGVsZW1lbnRVbml0Q29udmVyc2lvbkRhdGFbc3RhcnRWYWx1ZVVuaXRUeXBlICsgXCJUb1B4XCJdO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBJbnZlcnQgdGhlIHB4IHJhdGlvcyB0byBjb252ZXJ0IGludG8gdG8gdGhlIHRhcmdldCB1bml0LiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0c3dpdGNoIChlbmRWYWx1ZVVuaXRUeXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgXCIlXCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3RhcnRWYWx1ZSAqPSAxIC8gKGF4aXMgPT09IFwieFwiID8gZWxlbWVudFVuaXRDb252ZXJzaW9uRGF0YS5wZXJjZW50VG9QeFdpZHRoIDogZWxlbWVudFVuaXRDb252ZXJzaW9uRGF0YS5wZXJjZW50VG9QeEhlaWdodCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBcInB4XCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Lyogc3RhcnRWYWx1ZSBpcyBhbHJlYWR5IGluIHB4LCBkbyBub3RoaW5nOyB3ZSdyZSBkb25lLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3RhcnRWYWx1ZSAqPSAxIC8gZWxlbWVudFVuaXRDb252ZXJzaW9uRGF0YVtlbmRWYWx1ZVVuaXRUeXBlICsgXCJUb1B4XCJdO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdFx0IFJlbGF0aXZlIFZhbHVlc1xuXHRcdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdC8qIE9wZXJhdG9yIGxvZ2ljIG11c3QgYmUgcGVyZm9ybWVkIGxhc3Qgc2luY2UgaXQgcmVxdWlyZXMgdW5pdC1ub3JtYWxpemVkIHN0YXJ0IGFuZCBlbmQgdmFsdWVzLiAqL1xuXHRcdFx0XHRcdFx0XHQvKiBOb3RlOiBSZWxhdGl2ZSAqcGVyY2VudCB2YWx1ZXMqIGRvIG5vdCBiZWhhdmUgaG93IG1vc3QgcGVvcGxlIHRoaW5rOyB3aGlsZSBvbmUgd291bGQgZXhwZWN0IFwiKz01MCVcIlxuXHRcdFx0XHRcdFx0XHQgdG8gaW5jcmVhc2UgdGhlIHByb3BlcnR5IDEuNXggaXRzIGN1cnJlbnQgdmFsdWUsIGl0IGluIGZhY3QgaW5jcmVhc2VzIHRoZSBwZXJjZW50IHVuaXRzIGluIGFic29sdXRlIHRlcm1zOlxuXHRcdFx0XHRcdFx0XHQgNTAgcG9pbnRzIGlzIGFkZGVkIG9uIHRvcCBvZiB0aGUgY3VycmVudCAlIHZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKG9wZXJhdG9yKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBcIitcIjpcblx0XHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlID0gc3RhcnRWYWx1ZSArIGVuZFZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRjYXNlIFwiLVwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSBzdGFydFZhbHVlIC0gZW5kVmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgXCIqXCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRlbmRWYWx1ZSA9IHN0YXJ0VmFsdWUgKiBlbmRWYWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBcIi9cIjpcblx0XHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlID0gc3RhcnRWYWx1ZSAvIGVuZFZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdFx0IHR3ZWVuc0NvbnRhaW5lciBQdXNoXG5cdFx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdFx0XHQvKiBDb25zdHJ1Y3QgdGhlIHBlci1wcm9wZXJ0eSB0d2VlbiBvYmplY3QsIGFuZCBwdXNoIGl0IHRvIHRoZSBlbGVtZW50J3MgdHdlZW5zQ29udGFpbmVyLiAqL1xuXHRcdFx0XHRcdFx0XHR0d2VlbnNDb250YWluZXJbcHJvcGVydHldID0ge1xuXHRcdFx0XHRcdFx0XHRcdHJvb3RQcm9wZXJ0eVZhbHVlOiByb290UHJvcGVydHlWYWx1ZSxcblx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlOiBzdGFydFZhbHVlLFxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRWYWx1ZTogc3RhcnRWYWx1ZSxcblx0XHRcdFx0XHRcdFx0XHRlbmRWYWx1ZTogZW5kVmFsdWUsXG5cdFx0XHRcdFx0XHRcdFx0dW5pdFR5cGU6IGVuZFZhbHVlVW5pdFR5cGUsXG5cdFx0XHRcdFx0XHRcdFx0ZWFzaW5nOiBlYXNpbmdcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0aWYgKHBhdHRlcm4pIHtcblx0XHRcdFx0XHRcdFx0XHR0d2VlbnNDb250YWluZXJbcHJvcGVydHldLnBhdHRlcm4gPSBwYXR0ZXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKFZlbG9jaXR5LmRlYnVnKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJ0d2VlbnNDb250YWluZXIgKFwiICsgcHJvcGVydHkgKyBcIik6IFwiICsgSlNPTi5zdHJpbmdpZnkodHdlZW5zQ29udGFpbmVyW3Byb3BlcnR5XSksIGVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHQvKiBDcmVhdGUgYSB0d2VlbiBvdXQgb2YgZWFjaCBwcm9wZXJ0eSwgYW5kIGFwcGVuZCBpdHMgYXNzb2NpYXRlZCBkYXRhIHRvIHR3ZWVuc0NvbnRhaW5lci4gKi9cblx0XHRcdFx0XHRcdGZvciAodmFyIHByb3BlcnR5IGluIHByb3BlcnRpZXNNYXApIHtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIXByb3BlcnRpZXNNYXAuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0LyogVGhlIG9yaWdpbmFsIHByb3BlcnR5IG5hbWUncyBmb3JtYXQgbXVzdCBiZSB1c2VkIGZvciB0aGUgcGFyc2VQcm9wZXJ0eVZhbHVlKCkgbG9va3VwLFxuXHRcdFx0XHRcdFx0XHQgYnV0IHdlIHRoZW4gdXNlIGl0cyBjYW1lbENhc2Ugc3R5bGluZyB0byBub3JtYWxpemUgaXQgZm9yIG1hbmlwdWxhdGlvbi4gKi9cblx0XHRcdFx0XHRcdFx0dmFyIHByb3BlcnR5TmFtZSA9IENTUy5OYW1lcy5jYW1lbENhc2UocHJvcGVydHkpLFxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWVEYXRhID0gcGFyc2VQcm9wZXJ0eVZhbHVlKHByb3BlcnRpZXNNYXBbcHJvcGVydHldKTtcblxuXHRcdFx0XHRcdFx0XHQvKiBGaW5kIHNob3J0aGFuZCBjb2xvciBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBiZWVuIHBhc3NlZCBhIGhleCBzdHJpbmcuICovXG5cdFx0XHRcdFx0XHRcdC8qIFdvdWxkIGJlIHF1aWNrZXIgdG8gdXNlIENTUy5MaXN0cy5jb2xvcnMuaW5jbHVkZXMoKSBpZiBwb3NzaWJsZSAqL1xuXHRcdFx0XHRcdFx0XHRpZiAoX2luQXJyYXkoQ1NTLkxpc3RzLmNvbG9ycywgcHJvcGVydHlOYW1lKSkge1xuXHRcdFx0XHRcdFx0XHRcdC8qIFBhcnNlIHRoZSB2YWx1ZSBkYXRhIGZvciBlYWNoIHNob3J0aGFuZC4gKi9cblx0XHRcdFx0XHRcdFx0XHR2YXIgZW5kVmFsdWUgPSB2YWx1ZURhdGFbMF0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVhc2luZyA9IHZhbHVlRGF0YVsxXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3RhcnRWYWx1ZSA9IHZhbHVlRGF0YVsyXTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChDU1MuUmVnRXguaXNIZXgudGVzdChlbmRWYWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8qIENvbnZlcnQgdGhlIGhleCBzdHJpbmdzIGludG8gdGhlaXIgUkdCIGNvbXBvbmVudCBhcnJheXMuICovXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgY29sb3JDb21wb25lbnRzID0gW1wiUmVkXCIsIFwiR3JlZW5cIiwgXCJCbHVlXCJdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlUkdCID0gQ1NTLlZhbHVlcy5oZXhUb1JnYihlbmRWYWx1ZSksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0c3RhcnRWYWx1ZVJHQiA9IHN0YXJ0VmFsdWUgPyBDU1MuVmFsdWVzLmhleFRvUmdiKHN0YXJ0VmFsdWUpIDogdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBJbmplY3QgdGhlIFJHQiBjb21wb25lbnQgdHdlZW5zIGludG8gcHJvcGVydGllc01hcC4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3JDb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBkYXRhQXJyYXkgPSBbZW5kVmFsdWVSR0JbaV1dO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChlYXNpbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkYXRhQXJyYXkucHVzaChlYXNpbmcpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKHN0YXJ0VmFsdWVSR0IgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRhdGFBcnJheS5wdXNoKHN0YXJ0VmFsdWVSR0JbaV0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Zml4UHJvcGVydHlWYWx1ZShwcm9wZXJ0eU5hbWUgKyBjb2xvckNvbXBvbmVudHNbaV0sIGRhdGFBcnJheSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBJZiB3ZSBoYXZlIHJlcGxhY2VkIGEgc2hvcnRjdXQgY29sb3IgdmFsdWUgdGhlbiBkb24ndCB1cGRhdGUgdGhlIHN0YW5kYXJkIHByb3BlcnR5IG5hbWUgKi9cblx0XHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRmaXhQcm9wZXJ0eVZhbHVlKHByb3BlcnR5TmFtZSwgdmFsdWVEYXRhKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyogQWxvbmcgd2l0aCBpdHMgcHJvcGVydHkgZGF0YSwgc3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgaXRzZWxmIG9udG8gdHdlZW5zQ29udGFpbmVyLiAqL1xuXHRcdFx0XHRcdFx0dHdlZW5zQ29udGFpbmVyLmVsZW1lbnQgPSBlbGVtZW50O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdCBDYWxsIFB1c2hcblx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHQvKiBOb3RlOiB0d2VlbnNDb250YWluZXIgY2FuIGJlIGVtcHR5IGlmIGFsbCBvZiB0aGUgcHJvcGVydGllcyBpbiB0aGlzIGNhbGwncyBwcm9wZXJ0eSBtYXAgd2VyZSBza2lwcGVkIGR1ZSB0byBub3Rcblx0XHRcdFx0XHQgYmVpbmcgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyLiBUaGUgZWxlbWVudCBwcm9wZXJ0eSBpcyB1c2VkIGZvciBjaGVja2luZyB0aGF0IHRoZSB0d2VlbnNDb250YWluZXIgaGFzIGJlZW4gYXBwZW5kZWQgdG8uICovXG5cdFx0XHRcdFx0aWYgKHR3ZWVuc0NvbnRhaW5lci5lbGVtZW50KSB7XG5cdFx0XHRcdFx0XHQvKiBBcHBseSB0aGUgXCJ2ZWxvY2l0eS1hbmltYXRpbmdcIiBpbmRpY2F0b3IgY2xhc3MuICovXG5cdFx0XHRcdFx0XHRDU1MuVmFsdWVzLmFkZENsYXNzKGVsZW1lbnQsIFwidmVsb2NpdHktYW5pbWF0aW5nXCIpO1xuXG5cdFx0XHRcdFx0XHQvKiBUaGUgY2FsbCBhcnJheSBob3VzZXMgdGhlIHR3ZWVuc0NvbnRhaW5lcnMgZm9yIGVhY2ggZWxlbWVudCBiZWluZyBhbmltYXRlZCBpbiB0aGUgY3VycmVudCBjYWxsLiAqL1xuXHRcdFx0XHRcdFx0Y2FsbC5wdXNoKHR3ZWVuc0NvbnRhaW5lcik7XG5cblx0XHRcdFx0XHRcdGRhdGEgPSBEYXRhKGVsZW1lbnQpO1xuXG5cdFx0XHRcdFx0XHRpZiAoZGF0YSkge1xuXHRcdFx0XHRcdFx0XHQvKiBTdG9yZSB0aGUgdHdlZW5zQ29udGFpbmVyIGFuZCBvcHRpb25zIGlmIHdlJ3JlIHdvcmtpbmcgb24gdGhlIGRlZmF1bHQgZWZmZWN0cyBxdWV1ZSwgc28gdGhhdCB0aGV5IGNhbiBiZSB1c2VkIGJ5IHRoZSByZXZlcnNlIGNvbW1hbmQuICovXG5cdFx0XHRcdFx0XHRcdGlmIChvcHRzLnF1ZXVlID09PSBcIlwiKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRkYXRhLnR3ZWVuc0NvbnRhaW5lciA9IHR3ZWVuc0NvbnRhaW5lcjtcblx0XHRcdFx0XHRcdFx0XHRkYXRhLm9wdHMgPSBvcHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0LyogU3dpdGNoIG9uIHRoZSBlbGVtZW50J3MgYW5pbWF0aW5nIGZsYWcuICovXG5cdFx0XHRcdFx0XHRcdGRhdGEuaXNBbmltYXRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBPbmNlIHRoZSBmaW5hbCBlbGVtZW50IGluIHRoaXMgY2FsbCdzIGVsZW1lbnQgc2V0IGhhcyBiZWVuIHByb2Nlc3NlZCwgcHVzaCB0aGUgY2FsbCBhcnJheSBvbnRvXG5cdFx0XHRcdFx0XHQgVmVsb2NpdHkuU3RhdGUuY2FsbHMgZm9yIHRoZSBhbmltYXRpb24gdGljayB0byBpbW1lZGlhdGVseSBiZWdpbiBwcm9jZXNzaW5nLiAqL1xuXHRcdFx0XHRcdFx0aWYgKGVsZW1lbnRzSW5kZXggPT09IGVsZW1lbnRzTGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdFx0XHQvKiBBZGQgdGhlIGN1cnJlbnQgY2FsbCBwbHVzIGl0cyBhc3NvY2lhdGVkIG1ldGFkYXRhICh0aGUgZWxlbWVudCBzZXQgYW5kIHRoZSBjYWxsJ3Mgb3B0aW9ucykgb250byB0aGUgZ2xvYmFsIGNhbGwgY29udGFpbmVyLlxuXHRcdFx0XHRcdFx0XHQgQW55dGhpbmcgb24gdGhpcyBjYWxsIGNvbnRhaW5lciBpcyBzdWJqZWN0ZWQgdG8gdGljaygpIHByb2Nlc3NpbmcuICovXG5cdFx0XHRcdFx0XHRcdFZlbG9jaXR5LlN0YXRlLmNhbGxzLnB1c2goW2NhbGwsIGVsZW1lbnRzLCBvcHRzLCBudWxsLCBwcm9taXNlRGF0YS5yZXNvbHZlciwgbnVsbCwgMF0pO1xuXG5cdFx0XHRcdFx0XHRcdC8qIElmIHRoZSBhbmltYXRpb24gdGljayBpc24ndCBydW5uaW5nLCBzdGFydCBpdC4gKFZlbG9jaXR5IHNodXRzIGl0IG9mZiB3aGVuIHRoZXJlIGFyZSBubyBhY3RpdmUgY2FsbHMgdG8gcHJvY2Vzcy4pICovXG5cdFx0XHRcdFx0XHRcdGlmIChWZWxvY2l0eS5TdGF0ZS5pc1RpY2tpbmcgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0VmVsb2NpdHkuU3RhdGUuaXNUaWNraW5nID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdC8qIFN0YXJ0IHRoZSB0aWNrIGxvb3AuICovXG5cdFx0XHRcdFx0XHRcdFx0dGljaygpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50c0luZGV4Kys7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyogV2hlbiB0aGUgcXVldWUgb3B0aW9uIGlzIHNldCB0byBmYWxzZSwgdGhlIGNhbGwgc2tpcHMgdGhlIGVsZW1lbnQncyBxdWV1ZSBhbmQgZmlyZXMgaW1tZWRpYXRlbHkuICovXG5cdFx0XHRcdGlmIChvcHRzLnF1ZXVlID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdC8qIFNpbmNlIHRoaXMgYnVpbGRRdWV1ZSBjYWxsIGRvZXNuJ3QgcmVzcGVjdCB0aGUgZWxlbWVudCdzIGV4aXN0aW5nIHF1ZXVlICh3aGljaCBpcyB3aGVyZSBhIGRlbGF5IG9wdGlvbiB3b3VsZCBoYXZlIGJlZW4gYXBwZW5kZWQpLFxuXHRcdFx0XHRcdCB3ZSBtYW51YWxseSBpbmplY3QgdGhlIGRlbGF5IHByb3BlcnR5IGhlcmUgd2l0aCBhbiBleHBsaWNpdCBzZXRUaW1lb3V0LiAqL1xuXHRcdFx0XHRcdGlmIChvcHRzLmRlbGF5KSB7XG5cblx0XHRcdFx0XHRcdC8qIFRlbXBvcmFyaWx5IHN0b3JlIGRlbGF5ZWQgZWxlbWVudHMgdG8gZmFjaWxpdGF0ZSBhY2Nlc3MgZm9yIGdsb2JhbCBwYXVzZS9yZXN1bWUgKi9cblx0XHRcdFx0XHRcdHZhciBjYWxsSW5kZXggPSBWZWxvY2l0eS5TdGF0ZS5kZWxheWVkRWxlbWVudHMuY291bnQrKztcblx0XHRcdFx0XHRcdFZlbG9jaXR5LlN0YXRlLmRlbGF5ZWRFbGVtZW50c1tjYWxsSW5kZXhdID0gZWxlbWVudDtcblxuXHRcdFx0XHRcdFx0dmFyIGRlbGF5Q29tcGxldGUgPSAoZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdC8qIENsZWFyIHRoZSB0ZW1wb3JhcnkgZWxlbWVudCAqL1xuXHRcdFx0XHRcdFx0XHRcdFZlbG9jaXR5LlN0YXRlLmRlbGF5ZWRFbGVtZW50c1tpbmRleF0gPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0XHRcdC8qIEZpbmFsbHksIGlzc3VlIHRoZSBjYWxsICovXG5cdFx0XHRcdFx0XHRcdFx0YnVpbGRRdWV1ZSgpO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fSkoY2FsbEluZGV4KTtcblxuXHRcdFx0XHRcdFx0RGF0YShlbGVtZW50KS5kZWxheUJlZ2luID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblx0XHRcdFx0XHRcdERhdGEoZWxlbWVudCkuZGVsYXkgPSBwYXJzZUZsb2F0KG9wdHMuZGVsYXkpO1xuXHRcdFx0XHRcdFx0RGF0YShlbGVtZW50KS5kZWxheVRpbWVyID0ge1xuXHRcdFx0XHRcdFx0XHRzZXRUaW1lb3V0OiBzZXRUaW1lb3V0KGJ1aWxkUXVldWUsIHBhcnNlRmxvYXQob3B0cy5kZWxheSkpLFxuXHRcdFx0XHRcdFx0XHRuZXh0OiBkZWxheUNvbXBsZXRlXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRidWlsZFF1ZXVlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8qIE90aGVyd2lzZSwgdGhlIGNhbGwgdW5kZXJnb2VzIGVsZW1lbnQgcXVldWVpbmcgYXMgbm9ybWFsLiAqL1xuXHRcdFx0XHRcdC8qIE5vdGU6IFRvIGludGVyb3BlcmF0ZSB3aXRoIGpRdWVyeSwgVmVsb2NpdHkgdXNlcyBqUXVlcnkncyBvd24gJC5xdWV1ZSgpIHN0YWNrIGZvciBxdWV1aW5nIGxvZ2ljLiAqL1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCQucXVldWUoZWxlbWVudCwgb3B0cy5xdWV1ZSwgZnVuY3Rpb24obmV4dCwgY2xlYXJRdWV1ZSkge1xuXHRcdFx0XHRcdFx0LyogSWYgdGhlIGNsZWFyUXVldWUgZmxhZyB3YXMgcGFzc2VkIGluIGJ5IHRoZSBzdG9wIGNvbW1hbmQsIHJlc29sdmUgdGhpcyBjYWxsJ3MgcHJvbWlzZS4gKFByb21pc2VzIGNhbiBvbmx5IGJlIHJlc29sdmVkIG9uY2UsXG5cdFx0XHRcdFx0XHQgc28gaXQncyBmaW5lIGlmIHRoaXMgaXMgcmVwZWF0ZWRseSB0cmlnZ2VyZWQgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgYXNzb2NpYXRlZCBjYWxsLikgKi9cblx0XHRcdFx0XHRcdGlmIChjbGVhclF1ZXVlID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChwcm9taXNlRGF0YS5wcm9taXNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvbWlzZURhdGEucmVzb2x2ZXIoZWxlbWVudHMpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0LyogRG8gbm90IGNvbnRpbnVlIHdpdGggYW5pbWF0aW9uIHF1ZXVlaW5nLiAqL1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyogVGhpcyBmbGFnIGluZGljYXRlcyB0byB0aGUgdXBjb21pbmcgY29tcGxldGVDYWxsKCkgZnVuY3Rpb24gdGhhdCB0aGlzIHF1ZXVlIGVudHJ5IHdhcyBpbml0aWF0ZWQgYnkgVmVsb2NpdHkuXG5cdFx0XHRcdFx0XHQgU2VlIGNvbXBsZXRlQ2FsbCgpIGZvciBmdXJ0aGVyIGRldGFpbHMuICovXG5cdFx0XHRcdFx0XHRWZWxvY2l0eS52ZWxvY2l0eVF1ZXVlRW50cnlGbGFnID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0YnVpbGRRdWV1ZShuZXh0KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IEF1dG8tRGVxdWV1aW5nXG5cdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0LyogQXMgcGVyIGpRdWVyeSdzICQucXVldWUoKSBiZWhhdmlvciwgdG8gZmlyZSB0aGUgZmlyc3Qgbm9uLWN1c3RvbS1xdWV1ZSBlbnRyeSBvbiBhbiBlbGVtZW50LCB0aGUgZWxlbWVudFxuXHRcdFx0XHQgbXVzdCBiZSBkZXF1ZXVlZCBpZiBpdHMgcXVldWUgc3RhY2sgY29uc2lzdHMgKnNvbGVseSogb2YgdGhlIGN1cnJlbnQgY2FsbC4gKFRoaXMgY2FuIGJlIGRldGVybWluZWQgYnkgY2hlY2tpbmdcblx0XHRcdFx0IGZvciB0aGUgXCJpbnByb2dyZXNzXCIgaXRlbSB0aGF0IGpRdWVyeSBwcmVwZW5kcyB0byBhY3RpdmUgcXVldWUgc3RhY2sgYXJyYXlzLikgUmVnYXJkbGVzcywgd2hlbmV2ZXIgdGhlIGVsZW1lbnQnc1xuXHRcdFx0XHQgcXVldWUgaXMgZnVydGhlciBhcHBlbmRlZCB3aXRoIGFkZGl0aW9uYWwgaXRlbXMgLS0gaW5jbHVkaW5nICQuZGVsYXkoKSdzIG9yIGV2ZW4gJC5hbmltYXRlKCkgY2FsbHMsIHRoZSBxdWV1ZSdzXG5cdFx0XHRcdCBmaXJzdCBlbnRyeSBpcyBhdXRvbWF0aWNhbGx5IGZpcmVkLiBUaGlzIGJlaGF2aW9yIGNvbnRyYXN0cyB0aGF0IG9mIGN1c3RvbSBxdWV1ZXMsIHdoaWNoIG5ldmVyIGF1dG8tZmlyZS4gKi9cblx0XHRcdFx0LyogTm90ZTogV2hlbiBhbiBlbGVtZW50IHNldCBpcyBiZWluZyBzdWJqZWN0ZWQgdG8gYSBub24tcGFyYWxsZWwgVmVsb2NpdHkgY2FsbCwgdGhlIGFuaW1hdGlvbiB3aWxsIG5vdCBiZWdpbiB1bnRpbFxuXHRcdFx0XHQgZWFjaCBvbmUgb2YgdGhlIGVsZW1lbnRzIGluIHRoZSBzZXQgaGFzIHJlYWNoZWQgdGhlIGVuZCBvZiBpdHMgaW5kaXZpZHVhbGx5IHByZS1leGlzdGluZyBxdWV1ZSBjaGFpbi4gKi9cblx0XHRcdFx0LyogTm90ZTogVW5mb3J0dW5hdGVseSwgbW9zdCBwZW9wbGUgZG9uJ3QgZnVsbHkgZ3Jhc3AgalF1ZXJ5J3MgcG93ZXJmdWwsIHlldCBxdWlya3ksICQucXVldWUoKSBmdW5jdGlvbi5cblx0XHRcdFx0IExlYW4gbW9yZSBoZXJlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTgxNTgvY2FuLXNvbWVib2R5LWV4cGxhaW4tanF1ZXJ5LXF1ZXVlLXRvLW1lICovXG5cdFx0XHRcdGlmICgob3B0cy5xdWV1ZSA9PT0gXCJcIiB8fCBvcHRzLnF1ZXVlID09PSBcImZ4XCIpICYmICQucXVldWUoZWxlbWVudClbMF0gIT09IFwiaW5wcm9ncmVzc1wiKSB7XG5cdFx0XHRcdFx0JC5kZXF1ZXVlKGVsZW1lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0IEVsZW1lbnQgU2V0IEl0ZXJhdGlvblxuXHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHQvKiBJZiB0aGUgXCJub2RlVHlwZVwiIHByb3BlcnR5IGV4aXN0cyBvbiB0aGUgZWxlbWVudHMgdmFyaWFibGUsIHdlJ3JlIGFuaW1hdGluZyBhIHNpbmdsZSBlbGVtZW50LlxuXHRcdFx0IFBsYWNlIGl0IGluIGFuIGFycmF5IHNvIHRoYXQgJC5lYWNoKCkgY2FuIGl0ZXJhdGUgb3ZlciBpdC4gKi9cblx0XHRcdCQuZWFjaChlbGVtZW50cywgZnVuY3Rpb24oaSwgZWxlbWVudCkge1xuXHRcdFx0XHQvKiBFbnN1cmUgZWFjaCBlbGVtZW50IGluIGEgc2V0IGhhcyBhIG5vZGVUeXBlIChpcyBhIHJlYWwgZWxlbWVudCkgdG8gYXZvaWQgdGhyb3dpbmcgZXJyb3JzLiAqL1xuXHRcdFx0XHRpZiAoVHlwZS5pc05vZGUoZWxlbWVudCkpIHtcblx0XHRcdFx0XHRwcm9jZXNzRWxlbWVudChlbGVtZW50LCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8qKioqKioqKioqKioqKioqKipcblx0XHRcdCBPcHRpb246IExvb3Bcblx0XHRcdCAqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdC8qIFRoZSBsb29wIG9wdGlvbiBhY2NlcHRzIGFuIGludGVnZXIgaW5kaWNhdGluZyBob3cgbWFueSB0aW1lcyB0aGUgZWxlbWVudCBzaG91bGQgbG9vcCBiZXR3ZWVuIHRoZSB2YWx1ZXMgaW4gdGhlXG5cdFx0XHQgY3VycmVudCBjYWxsJ3MgcHJvcGVydGllcyBtYXAgYW5kIHRoZSBlbGVtZW50J3MgcHJvcGVydHkgdmFsdWVzIHByaW9yIHRvIHRoaXMgY2FsbC4gKi9cblx0XHRcdC8qIE5vdGU6IFRoZSBsb29wIG9wdGlvbidzIGxvZ2ljIGlzIHBlcmZvcm1lZCBoZXJlIC0tIGFmdGVyIGVsZW1lbnQgcHJvY2Vzc2luZyAtLSBiZWNhdXNlIHRoZSBjdXJyZW50IGNhbGwgbmVlZHNcblx0XHRcdCB0byB1bmRlcmdvIGl0cyBxdWV1ZSBpbnNlcnRpb24gcHJpb3IgdG8gdGhlIGxvb3Agb3B0aW9uIGdlbmVyYXRpbmcgaXRzIHNlcmllcyBvZiBjb25zdGl0dWVudCBcInJldmVyc2VcIiBjYWxscyxcblx0XHRcdCB3aGljaCBjaGFpbiBhZnRlciB0aGUgY3VycmVudCBjYWxsLiBUd28gcmV2ZXJzZSBjYWxscyAodHdvIFwiYWx0ZXJuYXRpb25zXCIpIGNvbnN0aXR1dGUgb25lIGxvb3AuICovXG5cdFx0XHRvcHRzID0gJC5leHRlbmQoe30sIFZlbG9jaXR5LmRlZmF1bHRzLCBvcHRpb25zKTtcblx0XHRcdG9wdHMubG9vcCA9IHBhcnNlSW50KG9wdHMubG9vcCwgMTApO1xuXHRcdFx0dmFyIHJldmVyc2VDYWxsc0NvdW50ID0gKG9wdHMubG9vcCAqIDIpIC0gMTtcblxuXHRcdFx0aWYgKG9wdHMubG9vcCkge1xuXHRcdFx0XHQvKiBEb3VibGUgdGhlIGxvb3AgY291bnQgdG8gY29udmVydCBpdCBpbnRvIGl0cyBhcHByb3ByaWF0ZSBudW1iZXIgb2YgXCJyZXZlcnNlXCIgY2FsbHMuXG5cdFx0XHRcdCBTdWJ0cmFjdCAxIGZyb20gdGhlIHJlc3VsdGluZyB2YWx1ZSBzaW5jZSB0aGUgY3VycmVudCBjYWxsIGlzIGluY2x1ZGVkIGluIHRoZSB0b3RhbCBhbHRlcm5hdGlvbiBjb3VudC4gKi9cblx0XHRcdFx0Zm9yICh2YXIgeCA9IDA7IHggPCByZXZlcnNlQ2FsbHNDb3VudDsgeCsrKSB7XG5cdFx0XHRcdFx0LyogU2luY2UgdGhlIGxvZ2ljIGZvciB0aGUgcmV2ZXJzZSBhY3Rpb24gb2NjdXJzIGluc2lkZSBRdWV1ZWluZyBhbmQgdGhlcmVmb3JlIHRoaXMgY2FsbCdzIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRcdFx0IGlzbid0IHBhcnNlZCB1bnRpbCB0aGVuIGFzIHdlbGwsIHRoZSBjdXJyZW50IGNhbGwncyBkZWxheSBvcHRpb24gbXVzdCBiZSBleHBsaWNpdGx5IHBhc3NlZCBpbnRvIHRoZSByZXZlcnNlXG5cdFx0XHRcdFx0IGNhbGwgc28gdGhhdCB0aGUgZGVsYXkgbG9naWMgdGhhdCBvY2N1cnMgaW5zaWRlICpQcmUtUXVldWVpbmcqIGNhbiBwcm9jZXNzIGl0LiAqL1xuXHRcdFx0XHRcdHZhciByZXZlcnNlT3B0aW9ucyA9IHtcblx0XHRcdFx0XHRcdGRlbGF5OiBvcHRzLmRlbGF5LFxuXHRcdFx0XHRcdFx0cHJvZ3Jlc3M6IG9wdHMucHJvZ3Jlc3Ncblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0LyogSWYgYSBjb21wbGV0ZSBjYWxsYmFjayB3YXMgcGFzc2VkIGludG8gdGhpcyBjYWxsLCB0cmFuc2ZlciBpdCB0byB0aGUgbG9vcCByZWRpcmVjdCdzIGZpbmFsIFwicmV2ZXJzZVwiIGNhbGxcblx0XHRcdFx0XHQgc28gdGhhdCBpdCdzIHRyaWdnZXJlZCB3aGVuIHRoZSBlbnRpcmUgcmVkaXJlY3QgaXMgY29tcGxldGUgKGFuZCBub3Qgd2hlbiB0aGUgdmVyeSBmaXJzdCBhbmltYXRpb24gaXMgY29tcGxldGUpLiAqL1xuXHRcdFx0XHRcdGlmICh4ID09PSByZXZlcnNlQ2FsbHNDb3VudCAtIDEpIHtcblx0XHRcdFx0XHRcdHJldmVyc2VPcHRpb25zLmRpc3BsYXkgPSBvcHRzLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXZlcnNlT3B0aW9ucy52aXNpYmlsaXR5ID0gb3B0cy52aXNpYmlsaXR5O1xuXHRcdFx0XHRcdFx0cmV2ZXJzZU9wdGlvbnMuY29tcGxldGUgPSBvcHRzLmNvbXBsZXRlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGFuaW1hdGUoZWxlbWVudHMsIFwicmV2ZXJzZVwiLCByZXZlcnNlT3B0aW9ucyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0LyoqKioqKioqKioqKioqKlxuXHRcdFx0IENoYWluaW5nXG5cdFx0XHQgKioqKioqKioqKioqKioqL1xuXG5cdFx0XHQvKiBSZXR1cm4gdGhlIGVsZW1lbnRzIGJhY2sgdG8gdGhlIGNhbGwgY2hhaW4sIHdpdGggd3JhcHBlZCBlbGVtZW50cyB0YWtpbmcgcHJlY2VkZW5jZSBpbiBjYXNlIFZlbG9jaXR5IHdhcyBjYWxsZWQgdmlhIHRoZSAkLmZuLiBleHRlbnNpb24uICovXG5cdFx0XHRyZXR1cm4gZ2V0Q2hhaW4oKTtcblx0XHR9O1xuXG5cdFx0LyogVHVybiBWZWxvY2l0eSBpbnRvIHRoZSBhbmltYXRpb24gZnVuY3Rpb24sIGV4dGVuZGVkIHdpdGggdGhlIHByZS1leGlzdGluZyBWZWxvY2l0eSBvYmplY3QuICovXG5cdFx0VmVsb2NpdHkgPSAkLmV4dGVuZChhbmltYXRlLCBWZWxvY2l0eSk7XG5cdFx0LyogRm9yIGxlZ2FjeSBzdXBwb3J0LCBhbHNvIGV4cG9zZSB0aGUgbGl0ZXJhbCBhbmltYXRlIG1ldGhvZC4gKi9cblx0XHRWZWxvY2l0eS5hbmltYXRlID0gYW5pbWF0ZTtcblxuXHRcdC8qKioqKioqKioqKioqKlxuXHRcdCBUaW1pbmdcblx0XHQgKioqKioqKioqKioqKiovXG5cblx0XHQvKiBUaWNrZXIgZnVuY3Rpb24uICovXG5cdFx0dmFyIHRpY2tlciA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgckFGU2hpbTtcblxuXHRcdC8qIEluYWN0aXZlIGJyb3dzZXIgdGFicyBwYXVzZSByQUYsIHdoaWNoIHJlc3VsdHMgaW4gYWxsIGFjdGl2ZSBhbmltYXRpb25zIGltbWVkaWF0ZWx5IHNwcmludGluZyB0byB0aGVpciBjb21wbGV0aW9uIHN0YXRlcyB3aGVuIHRoZSB0YWIgcmVmb2N1c2VzLlxuXHRcdCBUbyBnZXQgYXJvdW5kIHRoaXMsIHdlIGR5bmFtaWNhbGx5IHN3aXRjaCByQUYgdG8gc2V0VGltZW91dCAod2hpY2ggdGhlIGJyb3dzZXIgKmRvZXNuJ3QqIHBhdXNlKSB3aGVuIHRoZSB0YWIgbG9zZXMgZm9jdXMuIFdlIHNraXAgdGhpcyBmb3IgbW9iaWxlXG5cdFx0IGRldmljZXMgdG8gYXZvaWQgd2FzdGluZyBiYXR0ZXJ5IHBvd2VyIG9uIGluYWN0aXZlIHRhYnMuICovXG5cdFx0LyogTm90ZTogVGFiIGZvY3VzIGRldGVjdGlvbiBkb2Vzbid0IHdvcmsgb24gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIGJ1dCB0aGF0J3Mgb2theSBzaW5jZSB0aGV5IGRvbid0IHN1cHBvcnQgckFGIHRvIGJlZ2luIHdpdGguICovXG5cdFx0aWYgKCFWZWxvY2l0eS5TdGF0ZS5pc01vYmlsZSAmJiBkb2N1bWVudC5oaWRkZW4gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dmFyIHVwZGF0ZVRpY2tlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvKiBSZWFzc2lnbiB0aGUgckFGIGZ1bmN0aW9uICh3aGljaCB0aGUgZ2xvYmFsIHRpY2soKSBmdW5jdGlvbiB1c2VzKSBiYXNlZCBvbiB0aGUgdGFiJ3MgZm9jdXMgc3RhdGUuICovXG5cdFx0XHRcdGlmIChkb2N1bWVudC5oaWRkZW4pIHtcblx0XHRcdFx0XHR0aWNrZXIgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0XHRcdFx0LyogVGhlIHRpY2sgZnVuY3Rpb24gbmVlZHMgYSB0cnV0aHkgZmlyc3QgYXJndW1lbnQgaW4gb3JkZXIgdG8gcGFzcyBpdHMgaW50ZXJuYWwgdGltZXN0YW1wIGNoZWNrLiAqL1xuXHRcdFx0XHRcdFx0cmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKHRydWUpO1xuXHRcdFx0XHRcdFx0fSwgMTYpO1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHQvKiBUaGUgckFGIGxvb3AgaGFzIGJlZW4gcGF1c2VkIGJ5IHRoZSBicm93c2VyLCBzbyB3ZSBtYW51YWxseSByZXN0YXJ0IHRoZSB0aWNrLiAqL1xuXHRcdFx0XHRcdHRpY2soKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aWNrZXIgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHJBRlNoaW07XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8qIFBhZ2UgY291bGQgYmUgc2l0dGluZyBpbiB0aGUgYmFja2dyb3VuZCBhdCB0aGlzIHRpbWUgKGkuZS4gb3BlbmVkIGFzIG5ldyB0YWIpIHNvIG1ha2luZyBzdXJlIHdlIHVzZSBjb3JyZWN0IHRpY2tlciBmcm9tIHRoZSBzdGFydCAqL1xuXHRcdFx0dXBkYXRlVGlja2VyKCk7XG5cblx0XHRcdC8qIEFuZCB0aGVuIHJ1biBjaGVjayBhZ2FpbiBldmVyeSB0aW1lIHZpc2liaWxpdHkgY2hhbmdlcyAqL1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgdXBkYXRlVGlja2VyKTtcblx0XHR9XG5cblx0XHQvKioqKioqKioqKioqXG5cdFx0IFRpY2tcblx0XHQgKioqKioqKioqKioqL1xuXG5cdFx0LyogTm90ZTogQWxsIGNhbGxzIHRvIFZlbG9jaXR5IGFyZSBwdXNoZWQgdG8gdGhlIFZlbG9jaXR5LlN0YXRlLmNhbGxzIGFycmF5LCB3aGljaCBpcyBmdWxseSBpdGVyYXRlZCB0aHJvdWdoIHVwb24gZWFjaCB0aWNrLiAqL1xuXHRcdGZ1bmN0aW9uIHRpY2sodGltZXN0YW1wKSB7XG5cdFx0XHQvKiBBbiBlbXB0eSB0aW1lc3RhbXAgYXJndW1lbnQgaW5kaWNhdGVzIHRoYXQgdGhpcyBpcyB0aGUgZmlyc3QgdGljayBvY2N1cmVuY2Ugc2luY2UgdGlja2luZyB3YXMgdHVybmVkIG9uLlxuXHRcdFx0IFdlIGxldmVyYWdlIHRoaXMgbWV0YWRhdGEgdG8gZnVsbHkgaWdub3JlIHRoZSBmaXJzdCB0aWNrIHBhc3Mgc2luY2UgUkFGJ3MgaW5pdGlhbCBwYXNzIGlzIGZpcmVkIHdoZW5ldmVyXG5cdFx0XHQgdGhlIGJyb3dzZXIncyBuZXh0IHRpY2sgc3luYyB0aW1lIG9jY3Vycywgd2hpY2ggcmVzdWx0cyBpbiB0aGUgZmlyc3QgZWxlbWVudHMgc3ViamVjdGVkIHRvIFZlbG9jaXR5XG5cdFx0XHQgY2FsbHMgYmVpbmcgYW5pbWF0ZWQgb3V0IG9mIHN5bmMgd2l0aCBhbnkgZWxlbWVudHMgYW5pbWF0ZWQgaW1tZWRpYXRlbHkgdGhlcmVhZnRlci4gSW4gc2hvcnQsIHdlIGlnbm9yZVxuXHRcdFx0IHRoZSBmaXJzdCBSQUYgdGljayBwYXNzIHNvIHRoYXQgZWxlbWVudHMgYmVpbmcgaW1tZWRpYXRlbHkgY29uc2VjdXRpdmVseSBhbmltYXRlZCAtLSBpbnN0ZWFkIG9mIHNpbXVsdGFuZW91c2x5IGFuaW1hdGVkXG5cdFx0XHQgYnkgdGhlIHNhbWUgVmVsb2NpdHkgY2FsbCAtLSBhcmUgcHJvcGVybHkgYmF0Y2hlZCBpbnRvIHRoZSBzYW1lIGluaXRpYWwgUkFGIHRpY2sgYW5kIGNvbnNlcXVlbnRseSByZW1haW4gaW4gc3luYyB0aGVyZWFmdGVyLiAqL1xuXHRcdFx0aWYgKHRpbWVzdGFtcCkge1xuXHRcdFx0XHQvKiBXZSBub3JtYWxseSB1c2UgUkFGJ3MgaGlnaCByZXNvbHV0aW9uIHRpbWVzdGFtcCBidXQgYXMgaXQgY2FuIGJlIHNpZ25pZmljYW50bHkgb2Zmc2V0IHdoZW4gdGhlIGJyb3dzZXIgaXNcblx0XHRcdFx0IHVuZGVyIGhpZ2ggc3RyZXNzIHdlIGdpdmUgdGhlIG9wdGlvbiBmb3IgY2hvcHBpbmVzcyBvdmVyIGFsbG93aW5nIHRoZSBicm93c2VyIHRvIGRyb3AgaHVnZSBjaHVua3Mgb2YgZnJhbWVzLlxuXHRcdFx0XHQgV2UgdXNlIHBlcmZvcm1hbmNlLm5vdygpIGFuZCBzaGltIGl0IGlmIGl0IGRvZXNuJ3QgZXhpc3QgZm9yIHdoZW4gdGhlIHRhYiBpcyBoaWRkZW4uICovXG5cdFx0XHRcdHZhciB0aW1lQ3VycmVudCA9IFZlbG9jaXR5LnRpbWVzdGFtcCAmJiB0aW1lc3RhbXAgIT09IHRydWUgPyB0aW1lc3RhbXAgOiBwZXJmb3JtYW5jZS5ub3coKTtcblxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IENhbGwgSXRlcmF0aW9uXG5cdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHR2YXIgY2FsbHNMZW5ndGggPSBWZWxvY2l0eS5TdGF0ZS5jYWxscy5sZW5ndGg7XG5cblx0XHRcdFx0LyogVG8gc3BlZWQgdXAgaXRlcmF0aW5nIG92ZXIgdGhpcyBhcnJheSwgaXQgaXMgY29tcGFjdGVkIChmYWxzZXkgaXRlbXMgLS0gY2FsbHMgdGhhdCBoYXZlIGNvbXBsZXRlZCAtLSBhcmUgcmVtb3ZlZClcblx0XHRcdFx0IHdoZW4gaXRzIGxlbmd0aCBoYXMgYmFsbG9vbmVkIHRvIGEgcG9pbnQgdGhhdCBjYW4gaW1wYWN0IHRpY2sgcGVyZm9ybWFuY2UuIFRoaXMgb25seSBiZWNvbWVzIG5lY2Vzc2FyeSB3aGVuIGFuaW1hdGlvblxuXHRcdFx0XHQgaGFzIGJlZW4gY29udGludW91cyB3aXRoIG1hbnkgZWxlbWVudHMgb3ZlciBhIGxvbmcgcGVyaW9kIG9mIHRpbWU7IHdoZW5ldmVyIGFsbCBhY3RpdmUgY2FsbHMgYXJlIGNvbXBsZXRlZCwgY29tcGxldGVDYWxsKCkgY2xlYXJzIFZlbG9jaXR5LlN0YXRlLmNhbGxzLiAqL1xuXHRcdFx0XHRpZiAoY2FsbHNMZW5ndGggPiAxMDAwMCkge1xuXHRcdFx0XHRcdFZlbG9jaXR5LlN0YXRlLmNhbGxzID0gY29tcGFjdFNwYXJzZUFycmF5KFZlbG9jaXR5LlN0YXRlLmNhbGxzKTtcblx0XHRcdFx0XHRjYWxsc0xlbmd0aCA9IFZlbG9jaXR5LlN0YXRlLmNhbGxzLmxlbmd0aDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIGFjdGl2ZSBjYWxsLiAqL1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxzTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHQvKiBXaGVuIGEgVmVsb2NpdHkgY2FsbCBpcyBjb21wbGV0ZWQsIGl0cyBWZWxvY2l0eS5TdGF0ZS5jYWxscyBlbnRyeSBpcyBzZXQgdG8gZmFsc2UuIENvbnRpbnVlIG9uIHRvIHRoZSBuZXh0IGNhbGwuICovXG5cdFx0XHRcdFx0aWYgKCFWZWxvY2l0eS5TdGF0ZS5jYWxsc1tpXSkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdCBDYWxsLVdpZGUgVmFyaWFibGVzXG5cdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdHZhciBjYWxsQ29udGFpbmVyID0gVmVsb2NpdHkuU3RhdGUuY2FsbHNbaV0sXG5cdFx0XHRcdFx0XHRcdGNhbGwgPSBjYWxsQ29udGFpbmVyWzBdLFxuXHRcdFx0XHRcdFx0XHRvcHRzID0gY2FsbENvbnRhaW5lclsyXSxcblx0XHRcdFx0XHRcdFx0dGltZVN0YXJ0ID0gY2FsbENvbnRhaW5lclszXSxcblx0XHRcdFx0XHRcdFx0Zmlyc3RUaWNrID0gIXRpbWVTdGFydCxcblx0XHRcdFx0XHRcdFx0dHdlZW5EdW1teVZhbHVlID0gbnVsbCxcblx0XHRcdFx0XHRcdFx0cGF1c2VPYmplY3QgPSBjYWxsQ29udGFpbmVyWzVdLFxuXHRcdFx0XHRcdFx0XHRtaWxsaXNlY29uZHNFbGxhcHNlZCA9IGNhbGxDb250YWluZXJbNl07XG5cblxuXG5cdFx0XHRcdFx0LyogSWYgdGltZVN0YXJ0IGlzIHVuZGVmaW5lZCwgdGhlbiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHRoYXQgdGhpcyBjYWxsIGhhcyBiZWVuIHByb2Nlc3NlZCBieSB0aWNrKCkuXG5cdFx0XHRcdFx0IFdlIGFzc2lnbiB0aW1lU3RhcnQgbm93IHNvIHRoYXQgaXRzIHZhbHVlIGlzIGFzIGNsb3NlIHRvIHRoZSByZWFsIGFuaW1hdGlvbiBzdGFydCB0aW1lIGFzIHBvc3NpYmxlLlxuXHRcdFx0XHRcdCAoQ29udmVyc2VseSwgaGFkIHRpbWVTdGFydCBiZWVuIGRlZmluZWQgd2hlbiB0aGlzIGNhbGwgd2FzIGFkZGVkIHRvIFZlbG9jaXR5LlN0YXRlLmNhbGxzLCB0aGUgZGVsYXlcblx0XHRcdFx0XHQgYmV0d2VlbiB0aGF0IHRpbWUgYW5kIG5vdyB3b3VsZCBjYXVzZSB0aGUgZmlyc3QgZmV3IGZyYW1lcyBvZiB0aGUgdHdlZW4gdG8gYmUgc2tpcHBlZCBzaW5jZVxuXHRcdFx0XHRcdCBwZXJjZW50Q29tcGxldGUgaXMgY2FsY3VsYXRlZCByZWxhdGl2ZSB0byB0aW1lU3RhcnQuKSAqL1xuXHRcdFx0XHRcdC8qIEZ1cnRoZXIsIHN1YnRyYWN0IDE2bXMgKHRoZSBhcHByb3hpbWF0ZSByZXNvbHV0aW9uIG9mIFJBRikgZnJvbSB0aGUgY3VycmVudCB0aW1lIHZhbHVlIHNvIHRoYXQgdGhlXG5cdFx0XHRcdFx0IGZpcnN0IHRpY2sgaXRlcmF0aW9uIGlzbid0IHdhc3RlZCBieSBhbmltYXRpbmcgYXQgMCUgdHdlZW4gY29tcGxldGlvbiwgd2hpY2ggd291bGQgcHJvZHVjZSB0aGVcblx0XHRcdFx0XHQgc2FtZSBzdHlsZSB2YWx1ZSBhcyB0aGUgZWxlbWVudCdzIGN1cnJlbnQgdmFsdWUuICovXG5cdFx0XHRcdFx0aWYgKCF0aW1lU3RhcnQpIHtcblx0XHRcdFx0XHRcdHRpbWVTdGFydCA9IFZlbG9jaXR5LlN0YXRlLmNhbGxzW2ldWzNdID0gdGltZUN1cnJlbnQgLSAxNjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBJZiBhIHBhdXNlIG9iamVjdCBpcyBwcmVzZW50LCBza2lwIHByb2Nlc3NpbmcgdW5sZXNzIGl0IGhhcyBiZWVuIHNldCB0byByZXN1bWUgKi9cblx0XHRcdFx0XHRpZiAocGF1c2VPYmplY3QpIHtcblx0XHRcdFx0XHRcdGlmIChwYXVzZU9iamVjdC5yZXN1bWUgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0LyogVXBkYXRlIHRoZSB0aW1lIHN0YXJ0IHRvIGFjY29tb2RhdGUgdGhlIHBhdXNlZCBjb21wbGV0aW9uIGFtb3VudCAqL1xuXHRcdFx0XHRcdFx0XHR0aW1lU3RhcnQgPSBjYWxsQ29udGFpbmVyWzNdID0gTWF0aC5yb3VuZCh0aW1lQ3VycmVudCAtIG1pbGxpc2Vjb25kc0VsbGFwc2VkIC0gMTYpO1xuXG5cdFx0XHRcdFx0XHRcdC8qIFJlbW92ZSBwYXVzZSBvYmplY3QgYWZ0ZXIgcHJvY2Vzc2luZyAqL1xuXHRcdFx0XHRcdFx0XHRjYWxsQ29udGFpbmVyWzVdID0gbnVsbDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG1pbGxpc2Vjb25kc0VsbGFwc2VkID0gY2FsbENvbnRhaW5lcls2XSA9IHRpbWVDdXJyZW50IC0gdGltZVN0YXJ0O1xuXG5cdFx0XHRcdFx0LyogVGhlIHR3ZWVuJ3MgY29tcGxldGlvbiBwZXJjZW50YWdlIGlzIHJlbGF0aXZlIHRvIHRoZSB0d2VlbidzIHN0YXJ0IHRpbWUsIG5vdCB0aGUgdHdlZW4ncyBzdGFydCB2YWx1ZVxuXHRcdFx0XHRcdCAod2hpY2ggd291bGQgcmVzdWx0IGluIHVucHJlZGljdGFibGUgdHdlZW4gZHVyYXRpb25zIHNpbmNlIEphdmFTY3JpcHQncyB0aW1lcnMgYXJlIG5vdCBwYXJ0aWN1bGFybHkgYWNjdXJhdGUpLlxuXHRcdFx0XHRcdCBBY2NvcmRpbmdseSwgd2UgZW5zdXJlIHRoYXQgcGVyY2VudENvbXBsZXRlIGRvZXMgbm90IGV4Y2VlZCAxLiAqL1xuXHRcdFx0XHRcdHZhciBwZXJjZW50Q29tcGxldGUgPSBNYXRoLm1pbigobWlsbGlzZWNvbmRzRWxsYXBzZWQpIC8gb3B0cy5kdXJhdGlvbiwgMSk7XG5cblx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdCBFbGVtZW50IEl0ZXJhdGlvblxuXHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0LyogRm9yIGV2ZXJ5IGNhbGwsIGl0ZXJhdGUgdGhyb3VnaCBlYWNoIG9mIHRoZSBlbGVtZW50cyBpbiBpdHMgc2V0LiAqL1xuXHRcdFx0XHRcdGZvciAodmFyIGogPSAwLCBjYWxsTGVuZ3RoID0gY2FsbC5sZW5ndGg7IGogPCBjYWxsTGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdHZhciB0d2VlbnNDb250YWluZXIgPSBjYWxsW2pdLFxuXHRcdFx0XHRcdFx0XHRcdGVsZW1lbnQgPSB0d2VlbnNDb250YWluZXIuZWxlbWVudDtcblxuXHRcdFx0XHRcdFx0LyogQ2hlY2sgdG8gc2VlIGlmIHRoaXMgZWxlbWVudCBoYXMgYmVlbiBkZWxldGVkIG1pZHdheSB0aHJvdWdoIHRoZSBhbmltYXRpb24gYnkgY2hlY2tpbmcgZm9yIHRoZVxuXHRcdFx0XHRcdFx0IGNvbnRpbnVlZCBleGlzdGVuY2Ugb2YgaXRzIGRhdGEgY2FjaGUuIElmIGl0J3MgZ29uZSwgb3IgdGhlIGVsZW1lbnQgaXMgY3VycmVudGx5IHBhdXNlZCwgc2tpcCBhbmltYXRpbmcgdGhpcyBlbGVtZW50LiAqL1xuXHRcdFx0XHRcdFx0aWYgKCFEYXRhKGVsZW1lbnQpKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgdHJhbnNmb3JtUHJvcGVydHlFeGlzdHMgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdCBEaXNwbGF5ICYgVmlzaWJpbGl0eSBUb2dnbGluZ1xuXHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHRcdC8qIElmIHRoZSBkaXNwbGF5IG9wdGlvbiBpcyBzZXQgdG8gbm9uLVwibm9uZVwiLCBzZXQgaXQgdXBmcm9udCBzbyB0aGF0IHRoZSBlbGVtZW50IGNhbiBiZWNvbWUgdmlzaWJsZSBiZWZvcmUgdHdlZW5pbmcgYmVnaW5zLlxuXHRcdFx0XHRcdFx0IChPdGhlcndpc2UsIGRpc3BsYXkncyBcIm5vbmVcIiB2YWx1ZSBpcyBzZXQgaW4gY29tcGxldGVDYWxsKCkgb25jZSB0aGUgYW5pbWF0aW9uIGhhcyBjb21wbGV0ZWQuKSAqL1xuXHRcdFx0XHRcdFx0aWYgKG9wdHMuZGlzcGxheSAhPT0gdW5kZWZpbmVkICYmIG9wdHMuZGlzcGxheSAhPT0gbnVsbCAmJiBvcHRzLmRpc3BsYXkgIT09IFwibm9uZVwiKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChvcHRzLmRpc3BsYXkgPT09IFwiZmxleFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGZsZXhWYWx1ZXMgPSBbXCItd2Via2l0LWJveFwiLCBcIi1tb3otYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCItd2Via2l0LWZsZXhcIl07XG5cblx0XHRcdFx0XHRcdFx0XHQkLmVhY2goZmxleFZhbHVlcywgZnVuY3Rpb24oaSwgZmxleFZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRDU1Muc2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcImRpc3BsYXlcIiwgZmxleFZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdENTUy5zZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwiZGlzcGxheVwiLCBvcHRzLmRpc3BsYXkpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBTYW1lIGdvZXMgd2l0aCB0aGUgdmlzaWJpbGl0eSBvcHRpb24sIGJ1dCBpdHMgXCJub25lXCIgZXF1aXZhbGVudCBpcyBcImhpZGRlblwiLiAqL1xuXHRcdFx0XHRcdFx0aWYgKG9wdHMudmlzaWJpbGl0eSAhPT0gdW5kZWZpbmVkICYmIG9wdHMudmlzaWJpbGl0eSAhPT0gXCJoaWRkZW5cIikge1xuXHRcdFx0XHRcdFx0XHRDU1Muc2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcInZpc2liaWxpdHlcIiwgb3B0cy52aXNpYmlsaXR5KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0IFByb3BlcnR5IEl0ZXJhdGlvblxuXHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdFx0LyogRm9yIGV2ZXJ5IGVsZW1lbnQsIGl0ZXJhdGUgdGhyb3VnaCBlYWNoIHByb3BlcnR5LiAqL1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgcHJvcGVydHkgaW4gdHdlZW5zQ29udGFpbmVyKSB7XG5cdFx0XHRcdFx0XHRcdC8qIE5vdGU6IEluIGFkZGl0aW9uIHRvIHByb3BlcnR5IHR3ZWVuIGRhdGEsIHR3ZWVuc0NvbnRhaW5lciBjb250YWlucyBhIHJlZmVyZW5jZSB0byBpdHMgYXNzb2NpYXRlZCBlbGVtZW50LiAqL1xuXHRcdFx0XHRcdFx0XHRpZiAodHdlZW5zQ29udGFpbmVyLmhhc093blByb3BlcnR5KHByb3BlcnR5KSAmJiBwcm9wZXJ0eSAhPT0gXCJlbGVtZW50XCIpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgdHdlZW4gPSB0d2VlbnNDb250YWluZXJbcHJvcGVydHldLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50VmFsdWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIEVhc2luZyBjYW4gZWl0aGVyIGJlIGEgcHJlLWdlbmVyZWF0ZWQgZnVuY3Rpb24gb3IgYSBzdHJpbmcgdGhhdCByZWZlcmVuY2VzIGEgcHJlLXJlZ2lzdGVyZWQgZWFzaW5nXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCBvbiB0aGUgVmVsb2NpdHkuRWFzaW5ncyBvYmplY3QuIEluIGVpdGhlciBjYXNlLCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIGVhc2luZyAqZnVuY3Rpb24qLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRlYXNpbmcgPSBUeXBlLmlzU3RyaW5nKHR3ZWVuLmVhc2luZykgPyBWZWxvY2l0eS5FYXNpbmdzW3R3ZWVuLmVhc2luZ10gOiB0d2Vlbi5lYXNpbmc7XG5cblx0XHRcdFx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0XHRcdFx0IEN1cnJlbnQgVmFsdWUgQ2FsY3VsYXRpb25cblx0XHRcdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKFR5cGUuaXNTdHJpbmcodHdlZW4ucGF0dGVybikpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBwYXR0ZXJuUmVwbGFjZSA9IHBlcmNlbnRDb21wbGV0ZSA9PT0gMSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oJDAsIGluZGV4LCByb3VuZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJlc3VsdCA9IHR3ZWVuLmVuZFZhbHVlW2luZGV4XTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJvdW5kID8gTWF0aC5yb3VuZChyZXN1bHQpIDogcmVzdWx0O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCQwLCBpbmRleCwgcm91bmQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBzdGFydFZhbHVlID0gdHdlZW4uc3RhcnRWYWx1ZVtpbmRleF0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHdlZW5EZWx0YSA9IHR3ZWVuLmVuZFZhbHVlW2luZGV4XSAtIHN0YXJ0VmFsdWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0ID0gc3RhcnRWYWx1ZSArICh0d2VlbkRlbHRhICogZWFzaW5nKHBlcmNlbnRDb21wbGV0ZSwgb3B0cywgdHdlZW5EZWx0YSkpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcm91bmQgPyBNYXRoLnJvdW5kKHJlc3VsdCkgOiByZXN1bHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFZhbHVlID0gdHdlZW4ucGF0dGVybi5yZXBsYWNlKC97KFxcZCspKCEpP30vZywgcGF0dGVyblJlcGxhY2UpO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAocGVyY2VudENvbXBsZXRlID09PSAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBJZiB0aGlzIGlzIHRoZSBsYXN0IHRpY2sgcGFzcyAoaWYgd2UndmUgcmVhY2hlZCAxMDAlIGNvbXBsZXRpb24gZm9yIHRoaXMgdHdlZW4pLFxuXHRcdFx0XHRcdFx0XHRcdFx0IGVuc3VyZSB0aGF0IGN1cnJlbnRWYWx1ZSBpcyBleHBsaWNpdGx5IHNldCB0byBpdHMgdGFyZ2V0IGVuZFZhbHVlIHNvIHRoYXQgaXQncyBub3Qgc3ViamVjdGVkIHRvIGFueSByb3VuZGluZy4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuLmVuZFZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBPdGhlcndpc2UsIGNhbGN1bGF0ZSBjdXJyZW50VmFsdWUgYmFzZWQgb24gdGhlIGN1cnJlbnQgZGVsdGEgZnJvbSBzdGFydFZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHR3ZWVuRGVsdGEgPSB0d2Vlbi5lbmRWYWx1ZSAtIHR3ZWVuLnN0YXJ0VmFsdWU7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuLnN0YXJ0VmFsdWUgKyAodHdlZW5EZWx0YSAqIGVhc2luZyhwZXJjZW50Q29tcGxldGUsIG9wdHMsIHR3ZWVuRGVsdGEpKTtcblx0XHRcdFx0XHRcdFx0XHRcdC8qIElmIG5vIHZhbHVlIGNoYW5nZSBpcyBvY2N1cnJpbmcsIGRvbid0IHByb2NlZWQgd2l0aCBET00gdXBkYXRpbmcuICovXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmICghZmlyc3RUaWNrICYmIChjdXJyZW50VmFsdWUgPT09IHR3ZWVuLmN1cnJlbnRWYWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdHR3ZWVuLmN1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdC8qIElmIHdlJ3JlIHR3ZWVuaW5nIGEgZmFrZSAndHdlZW4nIHByb3BlcnR5IGluIG9yZGVyIHRvIGxvZyB0cmFuc2l0aW9uIHZhbHVlcywgdXBkYXRlIHRoZSBvbmUtcGVyLWNhbGwgdmFyaWFibGUgc28gdGhhdFxuXHRcdFx0XHRcdFx0XHRcdCBpdCBjYW4gYmUgcGFzc2VkIGludG8gdGhlIHByb2dyZXNzIGNhbGxiYWNrLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmIChwcm9wZXJ0eSA9PT0gXCJ0d2VlblwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0d2VlbkR1bW15VmFsdWUgPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdFx0XHRcdCBIb29rczogUGFydCBJXG5cdFx0XHRcdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqL1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGhvb2tSb290O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBGb3IgaG9va2VkIHByb3BlcnRpZXMsIHRoZSBuZXdseS11cGRhdGVkIHJvb3RQcm9wZXJ0eVZhbHVlQ2FjaGUgaXMgY2FjaGVkIG9udG8gdGhlIGVsZW1lbnQgc28gdGhhdCBpdCBjYW4gYmUgdXNlZFxuXHRcdFx0XHRcdFx0XHRcdFx0IGZvciBzdWJzZXF1ZW50IGhvb2tzIGluIHRoaXMgY2FsbCB0aGF0IGFyZSBhc3NvY2lhdGVkIHdpdGggdGhlIHNhbWUgcm9vdCBwcm9wZXJ0eS4gSWYgd2UgZGlkbid0IGNhY2hlIHRoZSB1cGRhdGVkXG5cdFx0XHRcdFx0XHRcdFx0XHQgcm9vdFByb3BlcnR5VmFsdWUsIGVhY2ggc3Vic2VxdWVudCB1cGRhdGUgdG8gdGhlIHJvb3QgcHJvcGVydHkgaW4gdGhpcyB0aWNrIHBhc3Mgd291bGQgcmVzZXQgdGhlIHByZXZpb3VzIGhvb2snc1xuXHRcdFx0XHRcdFx0XHRcdFx0IHVwZGF0ZXMgdG8gcm9vdFByb3BlcnR5VmFsdWUgcHJpb3IgdG8gaW5qZWN0aW9uLiBBIG5pY2UgcGVyZm9ybWFuY2UgYnlwcm9kdWN0IG9mIHJvb3RQcm9wZXJ0eVZhbHVlIGNhY2hpbmcgaXMgdGhhdFxuXHRcdFx0XHRcdFx0XHRcdFx0IHN1YnNlcXVlbnRseSBjaGFpbmVkIGFuaW1hdGlvbnMgdXNpbmcgdGhlIHNhbWUgaG9va1Jvb3QgYnV0IGEgZGlmZmVyZW50IGhvb2sgY2FuIHVzZSB0aGlzIGNhY2hlZCByb290UHJvcGVydHlWYWx1ZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChDU1MuSG9va3MucmVnaXN0ZXJlZFtwcm9wZXJ0eV0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aG9va1Jvb3QgPSBDU1MuSG9va3MuZ2V0Um9vdChwcm9wZXJ0eSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJvb3RQcm9wZXJ0eVZhbHVlQ2FjaGUgPSBEYXRhKGVsZW1lbnQpLnJvb3RQcm9wZXJ0eVZhbHVlQ2FjaGVbaG9va1Jvb3RdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChyb290UHJvcGVydHlWYWx1ZUNhY2hlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHdlZW4ucm9vdFByb3BlcnR5VmFsdWUgPSByb290UHJvcGVydHlWYWx1ZUNhY2hlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHRcdFx0IERPTSBVcGRhdGVcblx0XHRcdFx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdFx0XHRcdFx0Lyogc2V0UHJvcGVydHlWYWx1ZSgpIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHByb3BlcnR5IG5hbWUgYW5kIHByb3BlcnR5IHZhbHVlIHBvc3QgYW55IG5vcm1hbGl6YXRpb24gdGhhdCBtYXkgaGF2ZSBiZWVuIHBlcmZvcm1lZC4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdC8qIE5vdGU6IFRvIHNvbHZlIGFuIElFPD04IHBvc2l0aW9uaW5nIGJ1ZywgdGhlIHVuaXQgdHlwZSBpcyBkcm9wcGVkIHdoZW4gc2V0dGluZyBhIHByb3BlcnR5IHZhbHVlIG9mIDAuICovXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgYWRqdXN0ZWRTZXREYXRhID0gQ1NTLnNldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgLyogU0VUICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcGVydHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHdlZW4uY3VycmVudFZhbHVlICsgKElFIDwgOSAmJiBwYXJzZUZsb2F0KGN1cnJlbnRWYWx1ZSkgPT09IDAgPyBcIlwiIDogdHdlZW4udW5pdFR5cGUpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR3ZWVuLnJvb3RQcm9wZXJ0eVZhbHVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR3ZWVuLnNjcm9sbERhdGEpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHRcdFx0IEhvb2tzOiBQYXJ0IElJXG5cdFx0XHRcdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdFx0XHRcdFx0LyogTm93IHRoYXQgd2UgaGF2ZSB0aGUgaG9vaydzIHVwZGF0ZWQgcm9vdFByb3BlcnR5VmFsdWUgKHRoZSBwb3N0LXByb2Nlc3NlZCB2YWx1ZSBwcm92aWRlZCBieSBhZGp1c3RlZFNldERhdGEpLCBjYWNoZSBpdCBvbnRvIHRoZSBlbGVtZW50LiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKENTUy5Ib29rcy5yZWdpc3RlcmVkW3Byb3BlcnR5XSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBTaW5jZSBhZGp1c3RlZFNldERhdGEgY29udGFpbnMgbm9ybWFsaXplZCBkYXRhIHJlYWR5IGZvciBET00gdXBkYXRpbmcsIHRoZSByb290UHJvcGVydHlWYWx1ZSBuZWVkcyB0byBiZSByZS1leHRyYWN0ZWQgZnJvbSBpdHMgbm9ybWFsaXplZCBmb3JtLiA/PyAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoQ1NTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbaG9va1Jvb3RdKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0RGF0YShlbGVtZW50KS5yb290UHJvcGVydHlWYWx1ZUNhY2hlW2hvb2tSb290XSA9IENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW2hvb2tSb290XShcImV4dHJhY3RcIiwgbnVsbCwgYWRqdXN0ZWRTZXREYXRhWzFdKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHREYXRhKGVsZW1lbnQpLnJvb3RQcm9wZXJ0eVZhbHVlQ2FjaGVbaG9va1Jvb3RdID0gYWRqdXN0ZWRTZXREYXRhWzFdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdFx0XHRcdCBUcmFuc2Zvcm1zXG5cdFx0XHRcdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBGbGFnIHdoZXRoZXIgYSB0cmFuc2Zvcm0gcHJvcGVydHkgaXMgYmVpbmcgYW5pbWF0ZWQgc28gdGhhdCBmbHVzaFRyYW5zZm9ybUNhY2hlKCkgY2FuIGJlIHRyaWdnZXJlZCBvbmNlIHRoaXMgdGljayBwYXNzIGlzIGNvbXBsZXRlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGFkanVzdGVkU2V0RGF0YVswXSA9PT0gXCJ0cmFuc2Zvcm1cIikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm1Qcm9wZXJ0eUV4aXN0cyA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdCBtb2JpbGVIQVxuXHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHRcdC8qIElmIG1vYmlsZUhBIGlzIGVuYWJsZWQsIHNldCB0aGUgdHJhbnNsYXRlM2QgdHJhbnNmb3JtIHRvIG51bGwgdG8gZm9yY2UgaGFyZHdhcmUgYWNjZWxlcmF0aW9uLlxuXHRcdFx0XHRcdFx0IEl0J3Mgc2FmZSB0byBvdmVycmlkZSB0aGlzIHByb3BlcnR5IHNpbmNlIFZlbG9jaXR5IGRvZXNuJ3QgYWN0dWFsbHkgc3VwcG9ydCBpdHMgYW5pbWF0aW9uIChob29rcyBhcmUgdXNlZCBpbiBpdHMgcGxhY2UpLiAqL1xuXHRcdFx0XHRcdFx0aWYgKG9wdHMubW9iaWxlSEEpIHtcblx0XHRcdFx0XHRcdFx0LyogRG9uJ3Qgc2V0IHRoZSBudWxsIHRyYW5zZm9ybSBoYWNrIGlmIHdlJ3ZlIGFscmVhZHkgZG9uZSBzby4gKi9cblx0XHRcdFx0XHRcdFx0aWYgKERhdGEoZWxlbWVudCkudHJhbnNmb3JtQ2FjaGUudHJhbnNsYXRlM2QgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdC8qIEFsbCBlbnRyaWVzIG9uIHRoZSB0cmFuc2Zvcm1DYWNoZSBvYmplY3QgYXJlIGxhdGVyIGNvbmNhdGVuYXRlZCBpbnRvIGEgc2luZ2xlIHRyYW5zZm9ybSBzdHJpbmcgdmlhIGZsdXNoVHJhbnNmb3JtQ2FjaGUoKS4gKi9cblx0XHRcdFx0XHRcdFx0XHREYXRhKGVsZW1lbnQpLnRyYW5zZm9ybUNhY2hlLnRyYW5zbGF0ZTNkID0gXCIoMHB4LCAwcHgsIDBweClcIjtcblxuXHRcdFx0XHRcdFx0XHRcdHRyYW5zZm9ybVByb3BlcnR5RXhpc3RzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAodHJhbnNmb3JtUHJvcGVydHlFeGlzdHMpIHtcblx0XHRcdFx0XHRcdFx0Q1NTLmZsdXNoVHJhbnNmb3JtQ2FjaGUoZWxlbWVudCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogVGhlIG5vbi1cIm5vbmVcIiBkaXNwbGF5IHZhbHVlIGlzIG9ubHkgYXBwbGllZCB0byBhbiBlbGVtZW50IG9uY2UgLS0gd2hlbiBpdHMgYXNzb2NpYXRlZCBjYWxsIGlzIGZpcnN0IHRpY2tlZCB0aHJvdWdoLlxuXHRcdFx0XHRcdCBBY2NvcmRpbmdseSwgaXQncyBzZXQgdG8gZmFsc2Ugc28gdGhhdCBpdCBpc24ndCByZS1wcm9jZXNzZWQgYnkgdGhpcyBjYWxsIGluIHRoZSBuZXh0IHRpY2suICovXG5cdFx0XHRcdFx0aWYgKG9wdHMuZGlzcGxheSAhPT0gdW5kZWZpbmVkICYmIG9wdHMuZGlzcGxheSAhPT0gXCJub25lXCIpIHtcblx0XHRcdFx0XHRcdFZlbG9jaXR5LlN0YXRlLmNhbGxzW2ldWzJdLmRpc3BsYXkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG9wdHMudmlzaWJpbGl0eSAhPT0gdW5kZWZpbmVkICYmIG9wdHMudmlzaWJpbGl0eSAhPT0gXCJoaWRkZW5cIikge1xuXHRcdFx0XHRcdFx0VmVsb2NpdHkuU3RhdGUuY2FsbHNbaV1bMl0udmlzaWJpbGl0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIFBhc3MgdGhlIGVsZW1lbnRzIGFuZCB0aGUgdGltaW5nIGRhdGEgKHBlcmNlbnRDb21wbGV0ZSwgbXNSZW1haW5pbmcsIHRpbWVTdGFydCwgdHdlZW5EdW1teVZhbHVlKSBpbnRvIHRoZSBwcm9ncmVzcyBjYWxsYmFjay4gKi9cblx0XHRcdFx0XHRpZiAob3B0cy5wcm9ncmVzcykge1xuXHRcdFx0XHRcdFx0b3B0cy5wcm9ncmVzcy5jYWxsKGNhbGxDb250YWluZXJbMV0sXG5cdFx0XHRcdFx0XHRcdFx0Y2FsbENvbnRhaW5lclsxXSxcblx0XHRcdFx0XHRcdFx0XHRwZXJjZW50Q29tcGxldGUsXG5cdFx0XHRcdFx0XHRcdFx0TWF0aC5tYXgoMCwgKHRpbWVTdGFydCArIG9wdHMuZHVyYXRpb24pIC0gdGltZUN1cnJlbnQpLFxuXHRcdFx0XHRcdFx0XHRcdHRpbWVTdGFydCxcblx0XHRcdFx0XHRcdFx0XHR0d2VlbkR1bW15VmFsdWUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIElmIHRoaXMgY2FsbCBoYXMgZmluaXNoZWQgdHdlZW5pbmcsIHBhc3MgaXRzIGluZGV4IHRvIGNvbXBsZXRlQ2FsbCgpIHRvIGhhbmRsZSBjYWxsIGNsZWFudXAuICovXG5cdFx0XHRcdFx0aWYgKHBlcmNlbnRDb21wbGV0ZSA9PT0gMSkge1xuXHRcdFx0XHRcdFx0Y29tcGxldGVDYWxsKGkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvKiBOb3RlOiBjb21wbGV0ZUNhbGwoKSBzZXRzIHRoZSBpc1RpY2tpbmcgZmxhZyB0byBmYWxzZSB3aGVuIHRoZSBsYXN0IGNhbGwgb24gVmVsb2NpdHkuU3RhdGUuY2FsbHMgaGFzIGNvbXBsZXRlZC4gKi9cblx0XHRcdGlmIChWZWxvY2l0eS5TdGF0ZS5pc1RpY2tpbmcpIHtcblx0XHRcdFx0dGlja2VyKHRpY2spO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKioqKioqKioqKioqKioqKioqKioqXG5cdFx0IENhbGwgQ29tcGxldGlvblxuXHRcdCAqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0LyogTm90ZTogVW5saWtlIHRpY2soKSwgd2hpY2ggcHJvY2Vzc2VzIGFsbCBhY3RpdmUgY2FsbHMgYXQgb25jZSwgY2FsbCBjb21wbGV0aW9uIGlzIGhhbmRsZWQgb24gYSBwZXItY2FsbCBiYXNpcy4gKi9cblx0XHRmdW5jdGlvbiBjb21wbGV0ZUNhbGwoY2FsbEluZGV4LCBpc1N0b3BwZWQpIHtcblx0XHRcdC8qIEVuc3VyZSB0aGUgY2FsbCBleGlzdHMuICovXG5cdFx0XHRpZiAoIVZlbG9jaXR5LlN0YXRlLmNhbGxzW2NhbGxJbmRleF0pIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBQdWxsIHRoZSBtZXRhZGF0YSBmcm9tIHRoZSBjYWxsLiAqL1xuXHRcdFx0dmFyIGNhbGwgPSBWZWxvY2l0eS5TdGF0ZS5jYWxsc1tjYWxsSW5kZXhdWzBdLFxuXHRcdFx0XHRcdGVsZW1lbnRzID0gVmVsb2NpdHkuU3RhdGUuY2FsbHNbY2FsbEluZGV4XVsxXSxcblx0XHRcdFx0XHRvcHRzID0gVmVsb2NpdHkuU3RhdGUuY2FsbHNbY2FsbEluZGV4XVsyXSxcblx0XHRcdFx0XHRyZXNvbHZlciA9IFZlbG9jaXR5LlN0YXRlLmNhbGxzW2NhbGxJbmRleF1bNF07XG5cblx0XHRcdHZhciByZW1haW5pbmdDYWxsc0V4aXN0ID0gZmFsc2U7XG5cblx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHQgRWxlbWVudCBGaW5hbGl6YXRpb25cblx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgY2FsbExlbmd0aCA9IGNhbGwubGVuZ3RoOyBpIDwgY2FsbExlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBlbGVtZW50ID0gY2FsbFtpXS5lbGVtZW50O1xuXG5cdFx0XHRcdC8qIElmIHRoZSB1c2VyIHNldCBkaXNwbGF5IHRvIFwibm9uZVwiIChpbnRlbmRpbmcgdG8gaGlkZSB0aGUgZWxlbWVudCksIHNldCBpdCBub3cgdGhhdCB0aGUgYW5pbWF0aW9uIGhhcyBjb21wbGV0ZWQuICovXG5cdFx0XHRcdC8qIE5vdGU6IGRpc3BsYXk6bm9uZSBpc24ndCBzZXQgd2hlbiBjYWxscyBhcmUgbWFudWFsbHkgc3RvcHBlZCAodmlhIFZlbG9jaXR5KFwic3RvcFwiKS4gKi9cblx0XHRcdFx0LyogTm90ZTogRGlzcGxheSBnZXRzIGlnbm9yZWQgd2l0aCBcInJldmVyc2VcIiBjYWxscyBhbmQgaW5maW5pdGUgbG9vcHMsIHNpbmNlIHRoaXMgYmVoYXZpb3Igd291bGQgYmUgdW5kZXNpcmFibGUuICovXG5cdFx0XHRcdGlmICghaXNTdG9wcGVkICYmICFvcHRzLmxvb3ApIHtcblx0XHRcdFx0XHRpZiAob3B0cy5kaXNwbGF5ID09PSBcIm5vbmVcIikge1xuXHRcdFx0XHRcdFx0Q1NTLnNldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJkaXNwbGF5XCIsIG9wdHMuZGlzcGxheSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKG9wdHMudmlzaWJpbGl0eSA9PT0gXCJoaWRkZW5cIikge1xuXHRcdFx0XHRcdFx0Q1NTLnNldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJ2aXNpYmlsaXR5XCIsIG9wdHMudmlzaWJpbGl0eSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyogSWYgdGhlIGVsZW1lbnQncyBxdWV1ZSBpcyBlbXB0eSAoaWYgb25seSB0aGUgXCJpbnByb2dyZXNzXCIgaXRlbSBpcyBsZWZ0IGF0IHBvc2l0aW9uIDApIG9yIGlmIGl0cyBxdWV1ZSBpcyBhYm91dCB0byBydW5cblx0XHRcdFx0IGEgbm9uLVZlbG9jaXR5LWluaXRpYXRlZCBlbnRyeSwgdHVybiBvZmYgdGhlIGlzQW5pbWF0aW5nIGZsYWcuIEEgbm9uLVZlbG9jaXR5LWluaXRpYXRpZWQgcXVldWUgZW50cnkncyBsb2dpYyBtaWdodCBhbHRlclxuXHRcdFx0XHQgYW4gZWxlbWVudCdzIENTUyB2YWx1ZXMgYW5kIHRoZXJlYnkgY2F1c2UgVmVsb2NpdHkncyBjYWNoZWQgdmFsdWUgZGF0YSB0byBnbyBzdGFsZS4gVG8gZGV0ZWN0IGlmIGEgcXVldWUgZW50cnkgd2FzIGluaXRpYXRlZCBieSBWZWxvY2l0eSxcblx0XHRcdFx0IHdlIGNoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIG91ciBzcGVjaWFsIFZlbG9jaXR5LnF1ZXVlRW50cnlGbGFnIGRlY2xhcmF0aW9uLCB3aGljaCBtaW5pZmllcnMgd29uJ3QgcmVuYW1lIHNpbmNlIHRoZSBmbGFnXG5cdFx0XHRcdCBpcyBhc3NpZ25lZCB0byBqUXVlcnkncyBnbG9iYWwgJCBvYmplY3QgYW5kIHRodXMgZXhpc3RzIG91dCBvZiBWZWxvY2l0eSdzIG93biBzY29wZS4gKi9cblx0XHRcdFx0dmFyIGRhdGEgPSBEYXRhKGVsZW1lbnQpO1xuXG5cdFx0XHRcdGlmIChvcHRzLmxvb3AgIT09IHRydWUgJiYgKCQucXVldWUoZWxlbWVudClbMV0gPT09IHVuZGVmaW5lZCB8fCAhL1xcLnZlbG9jaXR5UXVldWVFbnRyeUZsYWcvaS50ZXN0KCQucXVldWUoZWxlbWVudClbMV0pKSkge1xuXHRcdFx0XHRcdC8qIFRoZSBlbGVtZW50IG1heSBoYXZlIGJlZW4gZGVsZXRlZC4gRW5zdXJlIHRoYXQgaXRzIGRhdGEgY2FjaGUgc3RpbGwgZXhpc3RzIGJlZm9yZSBhY3Rpbmcgb24gaXQuICovXG5cdFx0XHRcdFx0aWYgKGRhdGEpIHtcblx0XHRcdFx0XHRcdGRhdGEuaXNBbmltYXRpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHRcdC8qIENsZWFyIHRoZSBlbGVtZW50J3Mgcm9vdFByb3BlcnR5VmFsdWVDYWNoZSwgd2hpY2ggd2lsbCBiZWNvbWUgc3RhbGUuICovXG5cdFx0XHRcdFx0XHRkYXRhLnJvb3RQcm9wZXJ0eVZhbHVlQ2FjaGUgPSB7fTtcblxuXHRcdFx0XHRcdFx0dmFyIHRyYW5zZm9ybUhBUHJvcGVydHlFeGlzdHMgPSBmYWxzZTtcblx0XHRcdFx0XHRcdC8qIElmIGFueSAzRCB0cmFuc2Zvcm0gc3VicHJvcGVydHkgaXMgYXQgaXRzIGRlZmF1bHQgdmFsdWUgKHJlZ2FyZGxlc3Mgb2YgdW5pdCB0eXBlKSwgcmVtb3ZlIGl0LiAqL1xuXHRcdFx0XHRcdFx0JC5lYWNoKENTUy5MaXN0cy50cmFuc2Zvcm1zM0QsIGZ1bmN0aW9uKGksIHRyYW5zZm9ybU5hbWUpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGRlZmF1bHRWYWx1ZSA9IC9ec2NhbGUvLnRlc3QodHJhbnNmb3JtTmFtZSkgPyAxIDogMCxcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGRhdGEudHJhbnNmb3JtQ2FjaGVbdHJhbnNmb3JtTmFtZV07XG5cblx0XHRcdFx0XHRcdFx0aWYgKGRhdGEudHJhbnNmb3JtQ2FjaGVbdHJhbnNmb3JtTmFtZV0gIT09IHVuZGVmaW5lZCAmJiBuZXcgUmVnRXhwKFwiXlxcXFwoXCIgKyBkZWZhdWx0VmFsdWUgKyBcIlteLl1cIikudGVzdChjdXJyZW50VmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtSEFQcm9wZXJ0eUV4aXN0cyA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0XHRkZWxldGUgZGF0YS50cmFuc2Zvcm1DYWNoZVt0cmFuc2Zvcm1OYW1lXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdC8qIE1vYmlsZSBkZXZpY2VzIGhhdmUgaGFyZHdhcmUgYWNjZWxlcmF0aW9uIHJlbW92ZWQgYXQgdGhlIGVuZCBvZiB0aGUgYW5pbWF0aW9uIGluIG9yZGVyIHRvIGF2b2lkIGhvZ2dpbmcgdGhlIEdQVSdzIG1lbW9yeS4gKi9cblx0XHRcdFx0XHRcdGlmIChvcHRzLm1vYmlsZUhBKSB7XG5cdFx0XHRcdFx0XHRcdHRyYW5zZm9ybUhBUHJvcGVydHlFeGlzdHMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgZGF0YS50cmFuc2Zvcm1DYWNoZS50cmFuc2xhdGUzZDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyogRmx1c2ggdGhlIHN1YnByb3BlcnR5IHJlbW92YWxzIHRvIHRoZSBET00uICovXG5cdFx0XHRcdFx0XHRpZiAodHJhbnNmb3JtSEFQcm9wZXJ0eUV4aXN0cykge1xuXHRcdFx0XHRcdFx0XHRDU1MuZmx1c2hUcmFuc2Zvcm1DYWNoZShlbGVtZW50KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyogUmVtb3ZlIHRoZSBcInZlbG9jaXR5LWFuaW1hdGluZ1wiIGluZGljYXRvciBjbGFzcy4gKi9cblx0XHRcdFx0XHRcdENTUy5WYWx1ZXMucmVtb3ZlQ2xhc3MoZWxlbWVudCwgXCJ2ZWxvY2l0eS1hbmltYXRpbmdcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHQgT3B0aW9uOiBDb21wbGV0ZVxuXHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdC8qIENvbXBsZXRlIGlzIGZpcmVkIG9uY2UgcGVyIGNhbGwgKG5vdCBvbmNlIHBlciBlbGVtZW50KSBhbmQgaXMgcGFzc2VkIHRoZSBmdWxsIHJhdyBET00gZWxlbWVudCBzZXQgYXMgYm90aCBpdHMgY29udGV4dCBhbmQgaXRzIGZpcnN0IGFyZ3VtZW50LiAqL1xuXHRcdFx0XHQvKiBOb3RlOiBDYWxsYmFja3MgYXJlbid0IGZpcmVkIHdoZW4gY2FsbHMgYXJlIG1hbnVhbGx5IHN0b3BwZWQgKHZpYSBWZWxvY2l0eShcInN0b3BcIikuICovXG5cdFx0XHRcdGlmICghaXNTdG9wcGVkICYmIG9wdHMuY29tcGxldGUgJiYgIW9wdHMubG9vcCAmJiAoaSA9PT0gY2FsbExlbmd0aCAtIDEpKSB7XG5cdFx0XHRcdFx0LyogV2UgdGhyb3cgY2FsbGJhY2tzIGluIGEgc2V0VGltZW91dCBzbyB0aGF0IHRocm93biBlcnJvcnMgZG9uJ3QgaGFsdCB0aGUgZXhlY3V0aW9uIG9mIFZlbG9jaXR5IGl0c2VsZi4gKi9cblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0b3B0cy5jb21wbGV0ZS5jYWxsKGVsZW1lbnRzLCBlbGVtZW50cyk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0XHRcdFx0fSwgMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IFByb21pc2UgUmVzb2x2aW5nXG5cdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdC8qIE5vdGU6IEluZmluaXRlIGxvb3BzIGRvbid0IHJldHVybiBwcm9taXNlcy4gKi9cblx0XHRcdFx0aWYgKHJlc29sdmVyICYmIG9wdHMubG9vcCAhPT0gdHJ1ZSkge1xuXHRcdFx0XHRcdHJlc29sdmVyKGVsZW1lbnRzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdCBPcHRpb246IExvb3AgKEluZmluaXRlKVxuXHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRpZiAoZGF0YSAmJiBvcHRzLmxvb3AgPT09IHRydWUgJiYgIWlzU3RvcHBlZCkge1xuXHRcdFx0XHRcdC8qIElmIGEgcm90YXRlWC9ZL1ogcHJvcGVydHkgaXMgYmVpbmcgYW5pbWF0ZWQgYnkgMzYwIGRlZyB3aXRoIGxvb3A6dHJ1ZSwgc3dhcCB0d2VlbiBzdGFydC9lbmQgdmFsdWVzIHRvIGVuYWJsZVxuXHRcdFx0XHRcdCBjb250aW51b3VzIGl0ZXJhdGl2ZSByb3RhdGlvbiBsb29waW5nLiAoT3RoZXJpc2UsIHRoZSBlbGVtZW50IHdvdWxkIGp1c3Qgcm90YXRlIGJhY2sgYW5kIGZvcnRoLikgKi9cblx0XHRcdFx0XHQkLmVhY2goZGF0YS50d2VlbnNDb250YWluZXIsIGZ1bmN0aW9uKHByb3BlcnR5TmFtZSwgdHdlZW5Db250YWluZXIpIHtcblx0XHRcdFx0XHRcdGlmICgvXnJvdGF0ZS8udGVzdChwcm9wZXJ0eU5hbWUpICYmICgocGFyc2VGbG9hdCh0d2VlbkNvbnRhaW5lci5zdGFydFZhbHVlKSAtIHBhcnNlRmxvYXQodHdlZW5Db250YWluZXIuZW5kVmFsdWUpKSAlIDM2MCA9PT0gMCkpIHtcblx0XHRcdFx0XHRcdFx0dmFyIG9sZFN0YXJ0VmFsdWUgPSB0d2VlbkNvbnRhaW5lci5zdGFydFZhbHVlO1xuXG5cdFx0XHRcdFx0XHRcdHR3ZWVuQ29udGFpbmVyLnN0YXJ0VmFsdWUgPSB0d2VlbkNvbnRhaW5lci5lbmRWYWx1ZTtcblx0XHRcdFx0XHRcdFx0dHdlZW5Db250YWluZXIuZW5kVmFsdWUgPSBvbGRTdGFydFZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoL15iYWNrZ3JvdW5kUG9zaXRpb24vLnRlc3QocHJvcGVydHlOYW1lKSAmJiBwYXJzZUZsb2F0KHR3ZWVuQ29udGFpbmVyLmVuZFZhbHVlKSA9PT0gMTAwICYmIHR3ZWVuQ29udGFpbmVyLnVuaXRUeXBlID09PSBcIiVcIikge1xuXHRcdFx0XHRcdFx0XHR0d2VlbkNvbnRhaW5lci5lbmRWYWx1ZSA9IDA7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuQ29udGFpbmVyLnN0YXJ0VmFsdWUgPSAxMDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRWZWxvY2l0eShlbGVtZW50LCBcInJldmVyc2VcIiwge2xvb3A6IHRydWUsIGRlbGF5OiBvcHRzLmRlbGF5fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKioqKioqKioqKioqKioqXG5cdFx0XHRcdCBEZXF1ZXVlaW5nXG5cdFx0XHRcdCAqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0LyogRmlyZSB0aGUgbmV4dCBjYWxsIGluIHRoZSBxdWV1ZSBzbyBsb25nIGFzIHRoaXMgY2FsbCdzIHF1ZXVlIHdhc24ndCBzZXQgdG8gZmFsc2UgKHRvIHRyaWdnZXIgYSBwYXJhbGxlbCBhbmltYXRpb24pLFxuXHRcdFx0XHQgd2hpY2ggd291bGQgaGF2ZSBhbHJlYWR5IGNhdXNlZCB0aGUgbmV4dCBjYWxsIHRvIGZpcmUuIE5vdGU6IEV2ZW4gaWYgdGhlIGVuZCBvZiB0aGUgYW5pbWF0aW9uIHF1ZXVlIGhhcyBiZWVuIHJlYWNoZWQsXG5cdFx0XHRcdCAkLmRlcXVldWUoKSBtdXN0IHN0aWxsIGJlIGNhbGxlZCBpbiBvcmRlciB0byBjb21wbGV0ZWx5IGNsZWFyIGpRdWVyeSdzIGFuaW1hdGlvbiBxdWV1ZS4gKi9cblx0XHRcdFx0aWYgKG9wdHMucXVldWUgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0JC5kZXF1ZXVlKGVsZW1lbnQsIG9wdHMucXVldWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdCBDYWxscyBBcnJheSBDbGVhbnVwXG5cdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHQvKiBTaW5jZSB0aGlzIGNhbGwgaXMgY29tcGxldGUsIHNldCBpdCB0byBmYWxzZSBzbyB0aGF0IHRoZSByQUYgdGljayBza2lwcyBpdC4gVGhpcyBhcnJheSBpcyBsYXRlciBjb21wYWN0ZWQgdmlhIGNvbXBhY3RTcGFyc2VBcnJheSgpLlxuXHRcdFx0IChGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgdGhlIGNhbGwgaXMgc2V0IHRvIGZhbHNlIGluc3RlYWQgb2YgYmVpbmcgZGVsZXRlZCBmcm9tIHRoZSBhcnJheTogaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvc3BlZWQvdjgvKSAqL1xuXHRcdFx0VmVsb2NpdHkuU3RhdGUuY2FsbHNbY2FsbEluZGV4XSA9IGZhbHNlO1xuXG5cdFx0XHQvKiBJdGVyYXRlIHRocm91Z2ggdGhlIGNhbGxzIGFycmF5IHRvIGRldGVybWluZSBpZiB0aGlzIHdhcyB0aGUgZmluYWwgaW4tcHJvZ3Jlc3MgYW5pbWF0aW9uLlxuXHRcdFx0IElmIHNvLCBzZXQgYSBmbGFnIHRvIGVuZCB0aWNraW5nIGFuZCBjbGVhciB0aGUgY2FsbHMgYXJyYXkuICovXG5cdFx0XHRmb3IgKHZhciBqID0gMCwgY2FsbHNMZW5ndGggPSBWZWxvY2l0eS5TdGF0ZS5jYWxscy5sZW5ndGg7IGogPCBjYWxsc0xlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGlmIChWZWxvY2l0eS5TdGF0ZS5jYWxsc1tqXSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRyZW1haW5pbmdDYWxsc0V4aXN0ID0gdHJ1ZTtcblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChyZW1haW5pbmdDYWxsc0V4aXN0ID09PSBmYWxzZSkge1xuXHRcdFx0XHQvKiB0aWNrKCkgd2lsbCBkZXRlY3QgdGhpcyBmbGFnIHVwb24gaXRzIG5leHQgaXRlcmF0aW9uIGFuZCBzdWJzZXF1ZW50bHkgdHVybiBpdHNlbGYgb2ZmLiAqL1xuXHRcdFx0XHRWZWxvY2l0eS5TdGF0ZS5pc1RpY2tpbmcgPSBmYWxzZTtcblxuXHRcdFx0XHQvKiBDbGVhciB0aGUgY2FsbHMgYXJyYXkgc28gdGhhdCBpdHMgbGVuZ3RoIGlzIHJlc2V0LiAqL1xuXHRcdFx0XHRkZWxldGUgVmVsb2NpdHkuU3RhdGUuY2FsbHM7XG5cdFx0XHRcdFZlbG9jaXR5LlN0YXRlLmNhbGxzID0gW107XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqKioqKioqKioqKioqKioqKlxuXHRcdCBGcmFtZXdvcmtzXG5cdFx0ICoqKioqKioqKioqKioqKioqKi9cblxuXHRcdC8qIEJvdGggalF1ZXJ5IGFuZCBaZXB0byBhbGxvdyB0aGVpciAkLmZuIG9iamVjdCB0byBiZSBleHRlbmRlZCB0byBhbGxvdyB3cmFwcGVkIGVsZW1lbnRzIHRvIGJlIHN1YmplY3RlZCB0byBwbHVnaW4gY2FsbHMuXG5cdFx0IElmIGVpdGhlciBmcmFtZXdvcmsgaXMgbG9hZGVkLCByZWdpc3RlciBhIFwidmVsb2NpdHlcIiBleHRlbnNpb24gcG9pbnRpbmcgdG8gVmVsb2NpdHkncyBjb3JlIGFuaW1hdGUoKSBtZXRob2QuICBWZWxvY2l0eVxuXHRcdCBhbHNvIHJlZ2lzdGVycyBpdHNlbGYgb250byBhIGdsb2JhbCBjb250YWluZXIgKHdpbmRvdy5qUXVlcnkgfHwgd2luZG93LlplcHRvIHx8IHdpbmRvdykgc28gdGhhdCBjZXJ0YWluIGZlYXR1cmVzIGFyZVxuXHRcdCBhY2Nlc3NpYmxlIGJleW9uZCBqdXN0IGEgcGVyLWVsZW1lbnQgc2NvcGUuIFRoaXMgbWFzdGVyIG9iamVjdCBjb250YWlucyBhbiAuYW5pbWF0ZSgpIG1ldGhvZCwgd2hpY2ggaXMgbGF0ZXIgYXNzaWduZWQgdG8gJC5mblxuXHRcdCAoaWYgalF1ZXJ5IG9yIFplcHRvIGFyZSBwcmVzZW50KS4gQWNjb3JkaW5nbHksIFZlbG9jaXR5IGNhbiBib3RoIGFjdCBvbiB3cmFwcGVkIERPTSBlbGVtZW50cyBhbmQgc3RhbmQgYWxvbmUgZm9yIHRhcmdldGluZyByYXcgRE9NIGVsZW1lbnRzLiAqL1xuXHRcdGdsb2JhbC5WZWxvY2l0eSA9IFZlbG9jaXR5O1xuXG5cdFx0aWYgKGdsb2JhbCAhPT0gd2luZG93KSB7XG5cdFx0XHQvKiBBc3NpZ24gdGhlIGVsZW1lbnQgZnVuY3Rpb24gdG8gVmVsb2NpdHkncyBjb3JlIGFuaW1hdGUoKSBtZXRob2QuICovXG5cdFx0XHRnbG9iYWwuZm4udmVsb2NpdHkgPSBhbmltYXRlO1xuXHRcdFx0LyogQXNzaWduIHRoZSBvYmplY3QgZnVuY3Rpb24ncyBkZWZhdWx0cyB0byBWZWxvY2l0eSdzIGdsb2JhbCBkZWZhdWx0cyBvYmplY3QuICovXG5cdFx0XHRnbG9iYWwuZm4udmVsb2NpdHkuZGVmYXVsdHMgPSBWZWxvY2l0eS5kZWZhdWx0cztcblx0XHR9XG5cblx0XHQvKioqKioqKioqKioqKioqKioqKioqKipcblx0XHQgUGFja2FnZWQgUmVkaXJlY3RzXG5cdFx0ICoqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0Lyogc2xpZGVVcCwgc2xpZGVEb3duICovXG5cdFx0JC5lYWNoKFtcIkRvd25cIiwgXCJVcFwiXSwgZnVuY3Rpb24oaSwgZGlyZWN0aW9uKSB7XG5cdFx0XHRWZWxvY2l0eS5SZWRpcmVjdHNbXCJzbGlkZVwiICsgZGlyZWN0aW9uXSA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMsIGVsZW1lbnRzSW5kZXgsIGVsZW1lbnRzU2l6ZSwgZWxlbWVudHMsIHByb21pc2VEYXRhKSB7XG5cdFx0XHRcdHZhciBvcHRzID0gJC5leHRlbmQoe30sIG9wdGlvbnMpLFxuXHRcdFx0XHRcdFx0YmVnaW4gPSBvcHRzLmJlZ2luLFxuXHRcdFx0XHRcdFx0Y29tcGxldGUgPSBvcHRzLmNvbXBsZXRlLFxuXHRcdFx0XHRcdFx0aW5saW5lVmFsdWVzID0ge30sXG5cdFx0XHRcdFx0XHRjb21wdXRlZFZhbHVlcyA9IHtoZWlnaHQ6IFwiXCIsIG1hcmdpblRvcDogXCJcIiwgbWFyZ2luQm90dG9tOiBcIlwiLCBwYWRkaW5nVG9wOiBcIlwiLCBwYWRkaW5nQm90dG9tOiBcIlwifTtcblxuXHRcdFx0XHRpZiAob3B0cy5kaXNwbGF5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHQvKiBTaG93IHRoZSBlbGVtZW50IGJlZm9yZSBzbGlkZURvd24gYmVnaW5zIGFuZCBoaWRlIHRoZSBlbGVtZW50IGFmdGVyIHNsaWRlVXAgY29tcGxldGVzLiAqL1xuXHRcdFx0XHRcdC8qIE5vdGU6IElubGluZSBlbGVtZW50cyBjYW5ub3QgaGF2ZSBkaW1lbnNpb25zIGFuaW1hdGVkLCBzbyB0aGV5J3JlIHJldmVydGVkIHRvIGlubGluZS1ibG9jay4gKi9cblx0XHRcdFx0XHRvcHRzLmRpc3BsYXkgPSAoZGlyZWN0aW9uID09PSBcIkRvd25cIiA/IChWZWxvY2l0eS5DU1MuVmFsdWVzLmdldERpc3BsYXlUeXBlKGVsZW1lbnQpID09PSBcImlubGluZVwiID8gXCJpbmxpbmUtYmxvY2tcIiA6IFwiYmxvY2tcIikgOiBcIm5vbmVcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRvcHRzLmJlZ2luID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0LyogSWYgdGhlIHVzZXIgcGFzc2VkIGluIGEgYmVnaW4gY2FsbGJhY2ssIGZpcmUgaXQgbm93LiAqL1xuXHRcdFx0XHRcdGlmIChlbGVtZW50c0luZGV4ID09PSAwICYmIGJlZ2luKSB7XG5cdFx0XHRcdFx0XHRiZWdpbi5jYWxsKGVsZW1lbnRzLCBlbGVtZW50cyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogQ2FjaGUgdGhlIGVsZW1lbnRzJyBvcmlnaW5hbCB2ZXJ0aWNhbCBkaW1lbnNpb25hbCBwcm9wZXJ0eSB2YWx1ZXMgc28gdGhhdCB3ZSBjYW4gYW5pbWF0ZSBiYWNrIHRvIHRoZW0uICovXG5cdFx0XHRcdFx0Zm9yICh2YXIgcHJvcGVydHkgaW4gY29tcHV0ZWRWYWx1ZXMpIHtcblx0XHRcdFx0XHRcdGlmICghY29tcHV0ZWRWYWx1ZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aW5saW5lVmFsdWVzW3Byb3BlcnR5XSA9IGVsZW1lbnQuc3R5bGVbcHJvcGVydHldO1xuXG5cdFx0XHRcdFx0XHQvKiBGb3Igc2xpZGVEb3duLCB1c2UgZm9yY2VmZWVkaW5nIHRvIGFuaW1hdGUgYWxsIHZlcnRpY2FsIHByb3BlcnRpZXMgZnJvbSAwLiBGb3Igc2xpZGVVcCxcblx0XHRcdFx0XHRcdCB1c2UgZm9yY2VmZWVkaW5nIHRvIHN0YXJ0IGZyb20gY29tcHV0ZWQgdmFsdWVzIGFuZCBhbmltYXRlIGRvd24gdG8gMC4gKi9cblx0XHRcdFx0XHRcdHZhciBwcm9wZXJ0eVZhbHVlID0gQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgcHJvcGVydHkpO1xuXHRcdFx0XHRcdFx0Y29tcHV0ZWRWYWx1ZXNbcHJvcGVydHldID0gKGRpcmVjdGlvbiA9PT0gXCJEb3duXCIpID8gW3Byb3BlcnR5VmFsdWUsIDBdIDogWzAsIHByb3BlcnR5VmFsdWVdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIEZvcmNlIHZlcnRpY2FsIG92ZXJmbG93IGNvbnRlbnQgdG8gY2xpcCBzbyB0aGF0IHNsaWRpbmcgd29ya3MgYXMgZXhwZWN0ZWQuICovXG5cdFx0XHRcdFx0aW5saW5lVmFsdWVzLm92ZXJmbG93ID0gZWxlbWVudC5zdHlsZS5vdmVyZmxvdztcblx0XHRcdFx0XHRlbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRvcHRzLmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0LyogUmVzZXQgZWxlbWVudCB0byBpdHMgcHJlLXNsaWRlIGlubGluZSB2YWx1ZXMgb25jZSBpdHMgc2xpZGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLiAqL1xuXHRcdFx0XHRcdGZvciAodmFyIHByb3BlcnR5IGluIGlubGluZVZhbHVlcykge1xuXHRcdFx0XHRcdFx0aWYgKGlubGluZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcblx0XHRcdFx0XHRcdFx0ZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gPSBpbmxpbmVWYWx1ZXNbcHJvcGVydHldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIElmIHRoZSB1c2VyIHBhc3NlZCBpbiBhIGNvbXBsZXRlIGNhbGxiYWNrLCBmaXJlIGl0IG5vdy4gKi9cblx0XHRcdFx0XHRpZiAoZWxlbWVudHNJbmRleCA9PT0gZWxlbWVudHNTaXplIC0gMSkge1xuXHRcdFx0XHRcdFx0aWYgKGNvbXBsZXRlKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlLmNhbGwoZWxlbWVudHMsIGVsZW1lbnRzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChwcm9taXNlRGF0YSkge1xuXHRcdFx0XHRcdFx0XHRwcm9taXNlRGF0YS5yZXNvbHZlcihlbGVtZW50cyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdFZlbG9jaXR5KGVsZW1lbnQsIGNvbXB1dGVkVmFsdWVzLCBvcHRzKTtcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHQvKiBmYWRlSW4sIGZhZGVPdXQgKi9cblx0XHQkLmVhY2goW1wiSW5cIiwgXCJPdXRcIl0sIGZ1bmN0aW9uKGksIGRpcmVjdGlvbikge1xuXHRcdFx0VmVsb2NpdHkuUmVkaXJlY3RzW1wiZmFkZVwiICsgZGlyZWN0aW9uXSA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMsIGVsZW1lbnRzSW5kZXgsIGVsZW1lbnRzU2l6ZSwgZWxlbWVudHMsIHByb21pc2VEYXRhKSB7XG5cdFx0XHRcdHZhciBvcHRzID0gJC5leHRlbmQoe30sIG9wdGlvbnMpLFxuXHRcdFx0XHRcdFx0Y29tcGxldGUgPSBvcHRzLmNvbXBsZXRlLFxuXHRcdFx0XHRcdFx0cHJvcGVydGllc01hcCA9IHtvcGFjaXR5OiAoZGlyZWN0aW9uID09PSBcIkluXCIpID8gMSA6IDB9O1xuXG5cdFx0XHRcdC8qIFNpbmNlIHJlZGlyZWN0cyBhcmUgdHJpZ2dlcmVkIGluZGl2aWR1YWxseSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBhbmltYXRlZCBzZXQsIGF2b2lkIHJlcGVhdGVkbHkgdHJpZ2dlcmluZ1xuXHRcdFx0XHQgY2FsbGJhY2tzIGJ5IGZpcmluZyB0aGVtIG9ubHkgd2hlbiB0aGUgZmluYWwgZWxlbWVudCBoYXMgYmVlbiByZWFjaGVkLiAqL1xuXHRcdFx0XHRpZiAoZWxlbWVudHNJbmRleCAhPT0gMCkge1xuXHRcdFx0XHRcdG9wdHMuYmVnaW4gPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlbGVtZW50c0luZGV4ICE9PSBlbGVtZW50c1NpemUgLSAxKSB7XG5cdFx0XHRcdFx0b3B0cy5jb21wbGV0ZSA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b3B0cy5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKGNvbXBsZXRlKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlLmNhbGwoZWxlbWVudHMsIGVsZW1lbnRzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChwcm9taXNlRGF0YSkge1xuXHRcdFx0XHRcdFx0XHRwcm9taXNlRGF0YS5yZXNvbHZlcihlbGVtZW50cyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qIElmIGEgZGlzcGxheSB3YXMgcGFzc2VkIGluLCB1c2UgaXQuIE90aGVyd2lzZSwgZGVmYXVsdCB0byBcIm5vbmVcIiBmb3IgZmFkZU91dCBvciB0aGUgZWxlbWVudC1zcGVjaWZpYyBkZWZhdWx0IGZvciBmYWRlSW4uICovXG5cdFx0XHRcdC8qIE5vdGU6IFdlIGFsbG93IHVzZXJzIHRvIHBhc3MgaW4gXCJudWxsXCIgdG8gc2tpcCBkaXNwbGF5IHNldHRpbmcgYWx0b2dldGhlci4gKi9cblx0XHRcdFx0aWYgKG9wdHMuZGlzcGxheSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0b3B0cy5kaXNwbGF5ID0gKGRpcmVjdGlvbiA9PT0gXCJJblwiID8gXCJhdXRvXCIgOiBcIm5vbmVcIik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRWZWxvY2l0eSh0aGlzLCBwcm9wZXJ0aWVzTWFwLCBvcHRzKTtcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gVmVsb2NpdHk7XG5cdH0oKHdpbmRvdy5qUXVlcnkgfHwgd2luZG93LlplcHRvIHx8IHdpbmRvdyksIHdpbmRvdywgKHdpbmRvdyA/IHdpbmRvdy5kb2N1bWVudCA6IHVuZGVmaW5lZCkpO1xufSkpO1xuXG4vKioqKioqKioqKioqKioqKioqXG4gS25vd24gSXNzdWVzXG4gKioqKioqKioqKioqKioqKioqL1xuXG4vKiBUaGUgQ1NTIHNwZWMgbWFuZGF0ZXMgdGhhdCB0aGUgdHJhbnNsYXRlWC9ZL1ogdHJhbnNmb3JtcyBhcmUgJS1yZWxhdGl2ZSB0byB0aGUgZWxlbWVudCBpdHNlbGYgLS0gbm90IGl0cyBwYXJlbnQuXG4gVmVsb2NpdHksIGhvd2V2ZXIsIGRvZXNuJ3QgbWFrZSB0aGlzIGRpc3RpbmN0aW9uLiBUaHVzLCBjb252ZXJ0aW5nIHRvIG9yIGZyb20gdGhlICUgdW5pdCB3aXRoIHRoZXNlIHN1YnByb3BlcnRpZXNcbiB3aWxsIHByb2R1Y2UgYW4gaW5hY2N1cmF0ZSBjb252ZXJzaW9uIHZhbHVlLiBUaGUgc2FtZSBpc3N1ZSBleGlzdHMgd2l0aCB0aGUgY3gvY3kgYXR0cmlidXRlcyBvZiBTVkcgY2lyY2xlcyBhbmQgZWxsaXBzZXMuICovXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92ZWxvY2l0eS1hbmltYXRlL3ZlbG9jaXR5LmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vanN4LnRzXCIgLz5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmltcG9ydCB7IFZOb2RlLCBWTm9kZVByb3BlcnRpZXMgfSBmcm9tIFwibWFxdWV0dGVcIjtcclxuZGVjbGFyZSB2YXIgcmVxdWlyZTogYW55O1xyXG5pbXBvcnQgKiBhcyBtYXF1ZXR0ZSBmcm9tIFwibWFxdWV0dGVcIjtcclxuY29uc3QgaCA9IG1hcXVldHRlLmg7XHJcbmltcG9ydCB7IENhbGlmb3JuaWFBcHAsIERFRkFVTFRfRVhDRVBUSU9OIH0gZnJvbSBcIi4vQ2FsaWZvcm5pYUFwcFwiO1xyXG5pbXBvcnQgeyBDYWxpZm9ybmlhQ2xpZW50Vmlld01vZGVsLCBDYWxpZm9ybmlhRXZlbnQsIENhbGlmb3JuaWFWaWV3LCBTdHlsZU1vbGVjdWxlLCBSZXNwb25zaXZlRGV2aWNlLCBMYXlvdXRSb3csIENhbGlmb3JuaWFQcm9qZWN0LCBMYXlvdXRBdG9tLCBMYXlvdXRCb3gsIExheW91dFR5cGUsIENvbnRlbnRBdG9tLCBTdHlsZU1vbGVjdWxlQXRvbU1hcHBpbmcgfSBmcm9tIFwiLi9DYWxpZm9ybmlhR2VuZXJhdGVkXCI7XHJcbmltcG9ydCB7IFNUQVRJQ19NQVJHSU5fUFgsIEVkaXRWaWV3TW9kZSB9IGZyb20gXCIuL0NsaWVudFN0YXRlXCI7XHJcbmltcG9ydCB7IExheW91dFN0eWxlSW50ZXJhY3Rpb24gfSBmcm9tIFwiLi4vVHlwZXdyaXRlci9MYXlvdXRTdHlsZUludGVyYWN0aW9uXCI7XHJcbmltcG9ydCB7IFByb3BlcnR5QmFyIH0gZnJvbSBcIi4vUHJvcGVydHlCYXJcIjtcclxuaW1wb3J0IHsgUHJvcGVydHlCYXJNb2RlIH0gZnJvbSBcIi4uL1ZpZXdNb2RlbHMvUHJvcGVydHlCYXJWTVwiO1xyXG5cclxubGV0IGN1cnJlbnRBcHA6IENhbGlmb3JuaWFBcHA7XHJcbmxldCBjdXJyZW50Um91dGVyOiBDYWxpZm9ybmlhUm91dGVyO1xyXG5cclxuZXhwb3J0IGNsYXNzIENhbGlmb3JuaWFSb3V0ZXIge1xyXG4gICAgcHJpdmF0ZSBkZWVwZXN0TGV2ZWxDdXJyZW50Um93OiBudW1iZXIgPSAwOyAvLyBUT0RPIG9wdGltaXplIC8gdHJhbnNmZXIgc2VydmVyID0+IGNvbmNlcHQ/XHJcbiAgICBjb25zdHJ1Y3RvcihjYWxpZm9ybmlhQXBwQXJnOiBDYWxpZm9ybmlhQXBwKSB7XHJcbiAgICAgICAgY3VycmVudFJvdXRlciA9IHRoaXM7XHJcbiAgICAgICAgY3VycmVudEFwcCA9IGNhbGlmb3JuaWFBcHBBcmc7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qcHVibGljIHVwZGF0ZURhdGEgPSAocmVzcG9uc2U6IENhbGlmb3JuaWFDbGllbnRWaWV3TW9kZWwsIHByZXZlbnRSZW5kZXJDaGFpbmVkQ2FsbHM6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQgPT4geyBUT0RPIGtlcHQgYXMgcmVmZXJlbmNlLCB1bnVzZWRcclxuICAgICAgICBDYWxpZm9ybmlhQXBwLkNhbGlmb3JuaWFBcHBJbnN0YW5jZS5wcm9qZWN0b3Iuc2NoZWR1bGVSZW5kZXIoKTtcclxuICAgICAgICAvLyBpbmNyZW1lbnRhbCB1cGRhdGUsIHVzZSBkYXRhIGZyb20gcmVzcG9uc2UgdG8gdXBkYXRlIG5hdGl2ZSBjbGllbnQgZGF0YSBzdG9yZSAoY29udmVyc2lvbnMgZm9yIGRhdGVzLCBvYmplY3QgcmVmZXJlbmNlcyBldGMuKVxyXG4gICAgICAgIGxldCBpc1ZhbGlkUmVzcG9uc2U6IGJvb2xlYW4gPSBjdXJyZW50Um91dGVyLnZhbGlkYXRlUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gICAgICAgIGlmICghaXNWYWxpZFJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETyBjYW4gcmV0dXJuIDQwNCBub3QgZm91bmQgd2hlbiBkZWxldGluZyBhbHJlYWR5IGRlbGV0ZWQgb2JqZWN0cyA9PiBwYWdlIHJlbG9hZFxyXG4gICAgICAgIC8vIFRPRE8gc2VsZWN0ZWQgcHJvamVjdCBjaGFuZ2UgbXVzdCBiZSB0ZXN0ZWQgcHJvcGVybHkgKGJyZWFrcG9pbnQgaW4gY29udHJvbGxlciBhY3Rpb25zIGFuZCBleGVjdXRlIDJuZCB1aSBhY3Rpb24pXHJcbiAgICAgICAgLy8gVE9ETyBvdGhlciBjb25zdHJhaW50cyBsaWtlIFwic2VsZWN0ZWQgcHJvamVjdCBtYXkgbm90IGNoYW5nZVwiP1xyXG4gICAgICAgIC8vIFRPRE8gcmVmYWN0b3IgY2xpZW50IHZpZXcgbW9kZWwgdG8gbm90IGNvbnRhaW4gbXVsdGlwbGUgcmVmZXJlbmNlcyB0byBzYW1lIG9iamVjdCA9PiBzZWxlY3RlZCBwcm9qZWN0IHNob3VsZCBiZSBjYWxpZm9ybmlhUHJvamVjdHNbaW5kZXhdXHJcbiAgICAgICAgLy8gVE9ETyB0ZXN0IGV2ZXJ5IGNsaWVudCBpbnRlcmFjdGlvbiB3aXRoIGEgZGVsYXkgYW5kIHNlbGVjdCBwcm9qZWN0IGluIGJldHdlZW5cclxuICAgICAgICAvLyB0ZW1wb3Jhcnkgc29sdXRpb246IHJlc2V0IG9iamVjdCByZWZlcmVuY2VzID0+IGxlYWRzIHRvIGRpZmZlcmVudCBidWdzXHJcbiAgICAgICAgbGV0IGlzVXBkYXRlU3VjY2VzcyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvLyB1bnVzZWQsIGFsd2F5cyBmdWxsIHBhZ2UgdXBkYXRlXHJcbiAgICAgICAgc3dpdGNoIChyZXNwb25zZS5DYWxpZm9ybmlhRXZlbnQpIHtcclxuICAgICAgICAgICAgY2FzZSBDYWxpZm9ybmlhRXZlbnQuRHVwbGljYXRlU3R5bGVRdWFudHVtOlxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLlN0eWxlUXVhbnR1bSAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0ICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICAmJiBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVRdWFudHVtcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlUXVhbnR1bXMucHVzaChyZXNwb25zZS5TdHlsZVF1YW50dW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucHJvcGVydHlCYXJWTS5zdHlsZVF1YW50dW1NYXBwaW5nLm1hcChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVRdWFudHVtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNVcGRhdGVTdWNjZXNzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYGluY3JlbWVudGFsIHVwZGF0ZSBub3QgaW1wbGVtZW50ZWQgZm9yICR7Q2FsaWZvcm5pYUV2ZW50W3Jlc3BvbnNlLkNhbGlmb3JuaWFFdmVudF19YCk7IC8vIFRPRE9cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNVcGRhdGVTdWNjZXNzKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaW52YWxpZCBjbGllbnQgc3RhdGVcIik7XHJcbiAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpOyAvLyBUT0RPIGF1ZGl0IHNlY3VyaXR5Li4uXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXByZXZlbnRSZW5kZXJDaGFpbmVkQ2FsbHMpIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5wcm9qZWN0b3Iuc2NoZWR1bGVSZW5kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9OyovXHJcblxyXG4gICAgcHVibGljIHVwZGF0ZURhdGEgPSAocmVzcG9uc2U6IENhbGlmb3JuaWFDbGllbnRWaWV3TW9kZWwsIGlzSW5pdGlhbCA9IGZhbHNlLCBwcmV2ZW50UmVuZGVyQ2hhaW5lZENhbGxzOiBib29sZWFuID0gZmFsc2UpOiB2b2lkID0+IHtcclxuICAgICAgICAvLyBjb3B5IGRhdGEgZnJvbSByZXNwb25zZSB0byBuYXRpdmUgY2xpZW50IGRhdGEgc3RvcmUgKGNvbnZlcnNpb25zIGZvciBkYXRlcywgb2JqZWN0IHJlZmVyZW5jZXMgZXRjLilcclxuICAgICAgICBsZXQgaXNWYWxpZFJlc3BvbnNlOiBib29sZWFuID0gY3VycmVudFJvdXRlci52YWxpZGF0ZVJlc3BvbnNlKHJlc3BvbnNlKTtcclxuICAgICAgICBpZiAoIWlzVmFsaWRSZXNwb25zZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE8gbW9yZSBpbml0aWFsIGNsaWVudCBjaGVjayBpZiByZXF1aXJlZCBkYXRhLCBjZXJ0aWZpY2F0ZXMsIC4uLiBpcyBsb2FkZWQgZXRjLiB0ZXN0IGJhc2ljIHNldHVwIGFuZCBjbGVhciB2aWV3IGFnYWluXHJcbiAgICAgICAgbGV0IGlzRnVsbERhdGFVcGRhdGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgICBsZXQgaXNVcGRhdGVTdWNjZXNzOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAgICAgc3dpdGNoIChyZXNwb25zZS5DYWxpZm9ybmlhRXZlbnQpIHtcclxuICAgICAgICAgICAgY2FzZSBDYWxpZm9ybmlhRXZlbnQuVXBkYXRlQ29udGVudEF0b206XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuUGFydGlhbFVwZGF0ZS5Db250ZW50QXRvbSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRDb250ZW50QXRvbUluZGV4OiBudW1iZXIgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ29udGVudEF0b21zLmZpbmRJbmRleChjID0+IGMuQ29udGVudEF0b21JZCA9PSByZXNwb25zZS5QYXJ0aWFsVXBkYXRlLkNvbnRlbnRBdG9tLkNvbnRlbnRBdG9tSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gdGVzdDogZG9lcyB1cGRhdGUgcm91dGluZXMgb2YgcmVuZGVyZWQgbGF5b3V0IGF0b21zIGhhdmUgdG8gYmUgY2FsbGVkIHRvIHJlZnJlc2ggXCJsb2NhbFwiIGNvcHkgb2YgY29udGVudC9yZW5kZXJpbmdcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ29udGVudEF0b21zLnNwbGljZShjdXJyZW50Q29udGVudEF0b21JbmRleCwgMSwgLi4uW3Jlc3BvbnNlLlBhcnRpYWxVcGRhdGUuQ29udGVudEF0b21dKTtcclxuICAgICAgICAgICAgICAgICAgICAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkxheW91dE1vbGVjdWxlcy5maW5kKGwgPT4gbC5MYXlvdXRCYXNlSWQgPT0gcmVzcG9uc2UuUGFydGlhbFVwZGF0ZS5Db250ZW50QXRvbS5JbnN0YW5jZWRPbkxheW91dElkKSBhcyBMYXlvdXRBdG9tKS5Ib3N0ZWRDb250ZW50QXRvbSA9IHJlc3BvbnNlLlBhcnRpYWxVcGRhdGUuQ29udGVudEF0b207XHJcbiAgICAgICAgICAgICAgICAgICAgaXNVcGRhdGVTdWNjZXNzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGlzRnVsbERhdGFVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0Z1bGxEYXRhVXBkYXRlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5DYWxpZm9ybmlhUHJvamVjdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QgPSByZXNwb25zZS5DYWxpZm9ybmlhUHJvamVjdDtcclxuXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QXBwLmNsaWVudERhdGEuVXJsVG9SZWFkT25seSA9IHJlc3BvbnNlLlVybFRvUmVhZE9ubHk7IC8vIFRPRE8gb25seSBpbml0aWFsXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QXBwLmNsaWVudERhdGEuVXJsVG9SZWFkQW5kRWRpdCA9IHJlc3BvbnNlLlVybFRvUmVhZEFuZEVkaXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc29ydCByZXNwb25zaXZlIGRldmljZXM6IC0xLCAwLCAuLi4+MFxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzLmxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIHJlc3BvbnNlLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzLmxlbmd0aCA+IDApIHsgLy8gY2hlY2sgaWYgcmVzcG9uc2l2ZSBkZXZpY2VzIGFyZSBhbHJlYWR5IHNlZWRlZFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5SZXNwb25zaXZlRGV2aWNlcyA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5SZXNwb25zaXZlRGV2aWNlcy5zb3J0KChyMSwgcjIpID0+IChyMS5XaWR0aFRocmVzaG9sZCAhPT0gdW5kZWZpbmVkICYmIHIyLldpZHRoVGhyZXNob2xkICE9PSB1bmRlZmluZWQpID8gKHIxLldpZHRoVGhyZXNob2xkIDwgcjIuV2lkdGhUaHJlc2hvbGQgPyAtMSA6IHIxLldpZHRoVGhyZXNob2xkID09IHIyLldpZHRoVGhyZXNob2xkID8gMCA6IDEpIDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5sb3dlc3RXaWR0aFRocmVzaG9sZFJlc3BvbnNpdmVEZXZpY2VJZCA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5SZXNwb25zaXZlRGV2aWNlc1sxXS5SZXNwb25zaXZlRGV2aWNlSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5oaWdoZXN0V2lkdGhUaHJlc2hvbGRSZXNwb25zaXZlRGV2aWNlSWQgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuUmVzcG9uc2l2ZURldmljZXNbY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzLmxlbmd0aCAtIDFdLlJlc3BvbnNpdmVEZXZpY2VJZDtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLm5vbmVSZXNwb25zaXZlRGV2aWNlSWQgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuUmVzcG9uc2l2ZURldmljZXNbMF0uUmVzcG9uc2l2ZURldmljZUlkO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0luaXRpYWwpIHsgLy8gVE9ETyB3aGF0IGlmIGluaXRpYWwgZGF0YSBpcyBlcnJvbmVvdXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50QXBwLnByb3BlcnR5QmFycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByb3BlcnR5QmFyOiBQcm9wZXJ0eUJhciA9IGN1cnJlbnRBcHAucHJvcGVydHlCYXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlCYXIudmlld01vZGVsLnNldFNlbGVjdGVkUmVzcG9uc2l2ZURldmljZUlkKGN1cnJlbnRBcHAuc3RhdGUubm9uZVJlc3BvbnNpdmVEZXZpY2VJZCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QXBwLnBhZ2VQcmV2aWV3LnZpcnR1YWxTdHlsZUluZGV4Lmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucGFnZVByZXZpZXcudmlydHVhbFN0eWxlSW5kZXggPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5wYWdlUHJldmlldy52aXJ0dWFsUHNldWRvU3R5bGVJbmRleCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByZXNwb25zaXZlRGV2aWNlIG9mIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5SZXNwb25zaXZlRGV2aWNlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5wYWdlUHJldmlldy52aXJ0dWFsU3R5bGVJbmRleC5wdXNoKFtdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucGFnZVByZXZpZXcudmlydHVhbFBzZXVkb1N0eWxlSW5kZXgucHVzaCh7fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJbml0aWFsID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5jbGllbnREYXRhLkFsbENzc1Byb3BlcnRpZXMgPSByZXNwb25zZS5BbGxDc3NQcm9wZXJ0aWVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5TdHlsZUF0b21Dc3NQcm9wZXJ0eU1hcHBpbmcgPSByZXNwb25zZS5TdHlsZUF0b21Dc3NQcm9wZXJ0eU1hcHBpbmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZVF1YW50dW1zICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVBdG9tcyAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlTW9sZWN1bGVzICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuTGF5b3V0TW9sZWN1bGVzICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ2FsaWZvcm5pYVZpZXdzICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ2FsaWZvcm5pYVZpZXdzLmxlbmd0aCA+IDApIHsgLy8gVE9ETyBkdXBsaWNhdGUgbnVtYmVyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBvbmx5IG1hcCB3aGVuIHByb3BlcnR5IGJhciB3YXMgdXNlZCBhdCBsZWFzdCBvbmNlIC8vIFRPRE8gc29ydCBhbmQgcmVvcmRlcmluZyBpcyBoYXBwZW5pbmcgYXQgZGlmZmVyZW50IHBsYWNlZFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSb3V0ZXIucmVzdG9yZUxheW91dE1vbGVjdWxlQW5kU3R5bGVSZWZlcmVuY2VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5zcGVjaWFsU3R5bGVIb2xkZXIgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ2FsaWZvcm5pYVZpZXdzLmZpbmQodiA9PiB2LklzSW50ZXJuYWwgPT09IHRydWUgJiYgdi5OYW1lID09PSBcIltJbnRlcm5hbF0gU3BlY2lhbCBTdHlsZXNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUuc3BlY2lhbFN0eWxlSG9sZGVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pOyAgLy8gVE9ETyB3aWxsIGJyZWFrIHdoZW4gZGF0YSBjaGFuZ2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFWaWV3cy5maWx0ZXIodiA9PiAhdi5Jc0ludGVybmFsKS5tYXAodiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLnNwZWNpYWxTdHlsZUhvbGRlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2FsaWZvcm5pYVZpZXdTdHlsZUhvbGRlclJvdzogTGF5b3V0Um93ID0gY3VycmVudEFwcC5zdGF0ZS5zcGVjaWFsU3R5bGVIb2xkZXIuUGxhY2VkTGF5b3V0Um93cy5maW5kKGxheW91dFJvdyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0eWxlTW9sZWN1bGU6IFN0eWxlTW9sZWN1bGUgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChtID0+IG0uU3R5bGVGb3JMYXlvdXRJZCA9PSBsYXlvdXRSb3cuTGF5b3V0QmFzZUlkKSBhcyBTdHlsZU1vbGVjdWxlOyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZU1vbGVjdWxlLk5hbWUgPT09IGBbSW50ZXJuYWxdICR7di5OYW1lfSBWaWV3IFN0eWxlYCkgeyAvLyBUT0RPIHdpbGwgYnJlYWsgd2hlbiBkYXRhIGNoYW5nZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5TcGVjaWFsU3R5bGVWaWV3U3R5bGVNb2xlY3VsZUlkID0gc3R5bGVNb2xlY3VsZS5TdHlsZU1vbGVjdWxlSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSBhcyBMYXlvdXRSb3c7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2FsaWZvcm5pYVZpZXdCb2R5U3R5bGVIb2xkZXJSb3c6IExheW91dFJvdyA9IGN1cnJlbnRBcHAuc3RhdGUuc3BlY2lhbFN0eWxlSG9sZGVyLlBsYWNlZExheW91dFJvd3MuZmluZChsYXlvdXRSb3cgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdHlsZU1vbGVjdWxlOiBTdHlsZU1vbGVjdWxlID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlTW9sZWN1bGVzLmZpbmQobSA9PiBtLlN0eWxlRm9yTGF5b3V0SWQgPT0gbGF5b3V0Um93LkxheW91dEJhc2VJZCkgYXMgU3R5bGVNb2xlY3VsZTsgLy8gVE9ETyBleHBlbnNpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVNb2xlY3VsZS5OYW1lID09PSBgW0ludGVybmFsXSAke3YuTmFtZX0gQm9keSBTdHlsZWApIHsgLy8gVE9ETyB3aWxsIGJyZWFrIHdoZW4gZGF0YSBjaGFuZ2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuU3BlY2lhbFN0eWxlQm9keVN0eWxlTW9sZWN1bGVJZCA9IHN0eWxlTW9sZWN1bGUuU3R5bGVNb2xlY3VsZUlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgYXMgTGF5b3V0Um93O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNhbGlmb3JuaWFWaWV3SHRtbFN0eWxlSG9sZGVyUm93OiBMYXlvdXRSb3cgPSBjdXJyZW50QXBwLnN0YXRlLnNwZWNpYWxTdHlsZUhvbGRlci5QbGFjZWRMYXlvdXRSb3dzLmZpbmQobGF5b3V0Um93ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3R5bGVNb2xlY3VsZTogU3R5bGVNb2xlY3VsZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcy5maW5kKG0gPT4gbS5TdHlsZUZvckxheW91dElkID09IGxheW91dFJvdy5MYXlvdXRCYXNlSWQpIGFzIFN0eWxlTW9sZWN1bGU7IC8vIFRPRE8gZXhwZW5zaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlTW9sZWN1bGUuTmFtZSA9PT0gYFtJbnRlcm5hbF0gJHt2Lk5hbWV9IEh0bWwgU3R5bGVgKSB7IC8vIFRPRE8gd2lsbCBicmVhayB3aGVuIGRhdGEgY2hhbmdlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LlNwZWNpYWxTdHlsZUh0bWxTdHlsZU1vbGVjdWxlSWQgPSBzdHlsZU1vbGVjdWxlLlN0eWxlTW9sZWN1bGVJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIGFzIExheW91dFJvdztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuU3BlY2lhbFN0eWxlVmlld1N0eWxlTW9sZWN1bGVJZFN0cmluZyA9IHYuU3BlY2lhbFN0eWxlVmlld1N0eWxlTW9sZWN1bGVJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5TcGVjaWFsU3R5bGVWaWV3U3R5bGVTdHJpbmcgPSBgcyR7di5TcGVjaWFsU3R5bGVWaWV3U3R5bGVNb2xlY3VsZUlkU3RyaW5nfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LlNwZWNpYWxTdHlsZUJvZHlTdHlsZU1vbGVjdWxlSWRTdHJpbmcgPSB2LlNwZWNpYWxTdHlsZUJvZHlTdHlsZU1vbGVjdWxlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuU3BlY2lhbFN0eWxlQm9keVN0eWxlU3RyaW5nID0gYHMke3YuU3BlY2lhbFN0eWxlQm9keVN0eWxlTW9sZWN1bGVJZFN0cmluZ31gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5TcGVjaWFsU3R5bGVIdG1sU3R5bGVNb2xlY3VsZUlkU3RyaW5nID0gdi5TcGVjaWFsU3R5bGVIdG1sU3R5bGVNb2xlY3VsZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LlNwZWNpYWxTdHlsZUh0bWxTdHlsZVN0cmluZyA9IGBzJHt2LlNwZWNpYWxTdHlsZUh0bWxTdHlsZU1vbGVjdWxlSWRTdHJpbmd9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuU3BlY2lhbFN0eWxlVmlld1N0eWxlU3RyaW5nID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuU3BlY2lhbFN0eWxlQm9keVN0eWxlU3RyaW5nID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuU3BlY2lhbFN0eWxlSHRtbFN0eWxlU3RyaW5nID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2VhYmxlQXRvbXNWaWV3OiBDYWxpZm9ybmlhVmlldyA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5DYWxpZm9ybmlhVmlld3MuZmluZCh2aWV3ID0+IHZpZXcuSXNJbnRlcm5hbCAmJiB2aWV3Lk5hbWUgPT09IFwiW0ludGVybmFsXSBJbnN0YW5jZWFibGUgTGF5b3V0IEF0b21zXCIpIGFzIENhbGlmb3JuaWFWaWV3OyAvLyBUT0RPIG1hZ2ljIHN0cmluZyA9PiBjb25zdCBleHBvcnRcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2VhYmxlUm93c1ZpZXc6IENhbGlmb3JuaWFWaWV3ID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFWaWV3cy5maW5kKHZpZXcgPT4gdmlldy5Jc0ludGVybmFsICYmIHZpZXcuTmFtZSA9PT0gXCJbSW50ZXJuYWxdIEluc3RhbmNlYWJsZSBMYXlvdXQgUm93c1wiKSBhcyBDYWxpZm9ybmlhVmlldzsgLy8gVE9ETyBtYWdpYyBzdHJpbmcgPT4gY29uc3QgZXhwb3J0XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJvdXRlci5zZXRBY3RpdmVDYWxpZm9ybmlhVmlld0lkKGN1cnJlbnRBcHAucGFnZVByZXZpZXdWTS5hY3RpdmVDYWxpZm9ybmlhVmlld0lkICE9IDAgPyBjdXJyZW50QXBwLnBhZ2VQcmV2aWV3Vk0uYWN0aXZlQ2FsaWZvcm5pYVZpZXdJZCA6IDAsIHRydWUsIGlzSW5pdGlhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50QXBwLnByb3BlcnR5QmFycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnByb3BlcnR5QmFyc1tpXS52aWV3TW9kZWwudXBkYXRlRGF0YShjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVRdWFudHVtcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZUF0b21zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlTW9sZWN1bGVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkxheW91dE1vbGVjdWxlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5DYWxpZm9ybmlhVmlld3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZWFibGVBdG9tc1ZpZXcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZWFibGVSb3dzVmlldyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaXJzdFJvdzogTGF5b3V0Um93ID0gaW5zdGFuY2VhYmxlUm93c1ZpZXcuUGxhY2VkTGF5b3V0Um93c1swXTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLm5ld0JveFN0eWxlTW9sZWN1bGVJZCA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChzID0+IHMuU3R5bGVGb3JMYXlvdXRJZCA9PSBmaXJzdFJvdy5BbGxCb3hlc0JlbG93Um93WzBdLkxheW91dEJhc2VJZCkgYXMgU3R5bGVNb2xlY3VsZSkuU3R5bGVNb2xlY3VsZUlkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5zcGVjaWFsU3R5bGVIb2xkZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE9cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNJbml0aWFsID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGk6IG51bWJlciA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBjdXJyZW50QXBwLnByb3BlcnR5QmFyQ291bnQpIHsgLy8gVE9ETyBleGFtcGxlIHNuaXBwZXQgZm9yIGNvZGUgZ3VpZGVsaW5lcyA9PiBsYXlvdXQgaGVscHMgdG8gd3JpdGUgY29ycmVjdCBjb2RlIC8gbm90IGZvcmdldCBzdHVmZlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnByb3BlcnR5QmFyVk1zW2krK10uY3VycmVudFByb3BlcnR5QmFyTW9kZSA9IFByb3BlcnR5QmFyTW9kZS5DYWxpZm9ybmlhVmlldztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBjdXJyZW50QXBwLnByb3BlcnR5QmFyQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucHJvcGVydHlCYXJWTXNbaSsrXS5jdXJyZW50UHJvcGVydHlCYXJNb2RlID0gUHJvcGVydHlCYXJNb2RlLkFsbENhbGlmb3JuaWFWaWV3cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpIDwgY3VycmVudEFwcC5wcm9wZXJ0eUJhckNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5wcm9wZXJ0eUJhclZNc1tpKytdLmN1cnJlbnRQcm9wZXJ0eUJhck1vZGUgPSBQcm9wZXJ0eUJhck1vZGUuU3R5bGVNb2xlY3VsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IGN1cnJlbnRBcHAucHJvcGVydHlCYXJDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnByb3BlcnR5QmFyVk1zW2krK10uY3VycmVudFByb3BlcnR5QmFyTW9kZSA9IFByb3BlcnR5QmFyTW9kZS5BbGxTdHlsZVF1YW50dW1zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Um91dGVyLnNldHVwVWlGb3JEZXZpY2UoKTsgLy8gVE9ETyB3aGF0IGlmIGZpcnN0IHJlbmRlciBoYXBwZW5zIGFmdGVyIGluaXRpYWwgY2xpZW50IGRhdGEgdXBkYXRlPyBpcyB0aGlzIHBvc3NpYmxlIGF0IGFsbFxyXG5cclxuICAgICAgICAgICAgICAgIGlzVXBkYXRlU3VjY2VzcyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpc1VwZGF0ZVN1Y2Nlc3MgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibWlzc2luZyBjbGllbnQgZGF0YVwiKTtcclxuICAgICAgICAgICAgbG9jYXRpb24ucmVsb2FkKCk7IC8vIFRPRE8gYXVkaXQgc2VjdXJpdHkuLi4gVEVTVFxyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmlzRGF0YUxvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKCFwcmV2ZW50UmVuZGVyQ2hhaW5lZENhbGxzKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAucHJvamVjdG9yLnNjaGVkdWxlUmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY2xlYXJDYWxpZm9ybmlhUHJvcGVydHlCYXJzKGlzQ2xlYXJXaGVuTm9uRXF1YWw6IGJvb2xlYW4sIGNsZWFyV2hlbkVxdWFsc0NhbGlmb3JuaWFWaWV3SWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIC8vIHZpZXcgbW9kZWxzIGNhbiBoYXZlIG5vIHNlbGVjdGlvblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudEFwcC5wcm9wZXJ0eUJhcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5wcm9wZXJ0eUJhcnNbaV0udmlld01vZGVsLmNsZWFyU2VsZWN0ZWRDYWxpZm9ybmlhVmlldyhpc0NsZWFyV2hlbk5vbkVxdWFsLCBjbGVhcldoZW5FcXVhbHNDYWxpZm9ybmlhVmlld0lkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBwdWJsaWMgc2V0QWN0aXZlQ2FsaWZvcm5pYVZpZXdJZChjYWxpZm9ybmlhVmlld0lkOiBudW1iZXIsIGlzRGVmYXVsdFRvSG9tZTogYm9vbGVhbiwgaXNTZXRBbGxQcm9wZXJ0eUJhcnM6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICBsZXQgdXNlclBhZ2VzOiBDYWxpZm9ybmlhVmlld1tdID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFWaWV3cy5maWx0ZXIodmlldyA9PiAhdmlldy5Jc0ludGVybmFsKTtcclxuICAgICAgICBsZXQgYWN0aXZlVmlldzogQ2FsaWZvcm5pYVZpZXcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgbGV0IGFjdGl2ZVBhZ2VJbmRleDogbnVtYmVyID0gLTE7XHJcbiAgICAgICAgaWYgKGNhbGlmb3JuaWFWaWV3SWQgIT0gMCkge1xyXG4gICAgICAgICAgICBhY3RpdmVQYWdlSW5kZXggPSB1c2VyUGFnZXMuZmluZEluZGV4KHYgPT4gdi5DYWxpZm9ybmlhVmlld0lkID09IGNhbGlmb3JuaWFWaWV3SWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWN0aXZlUGFnZUluZGV4ID09IC0xICYmIGlzRGVmYXVsdFRvSG9tZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBhY3RpdmVQYWdlSW5kZXggPSB1c2VyUGFnZXMuZmluZEluZGV4KHYgPT4gdi5OYW1lID09PSBcIkhvbWVcIik7IC8vIFRPRE8gd2lsbCBicmVhayBpZiBkYXRhIGlzIG5vdCBzdXBwbGllZFxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWN0aXZlUGFnZUluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgYWN0aXZlVmlldyA9IHVzZXJQYWdlc1thY3RpdmVQYWdlSW5kZXhdO1xyXG4gICAgICAgICAgICBjdXJyZW50Um91dGVyLnNldEFjdGl2ZUNhbGlmb3JuaWFWaWV3KGFjdGl2ZVZpZXcpO1xyXG4gICAgICAgICAgICBpZiAoaXNTZXRBbGxQcm9wZXJ0eUJhcnMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBjdXJyZW50QXBwLnByb3BlcnR5QmFycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucHJvcGVydHlCYXJzW2ldLnZpZXdNb2RlbC5zZXRTZWxlY3RlZENhbGlmb3JuaWFWaWV3KGFjdGl2ZVZpZXcsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBjb21wbGV4IHVwZGF0ZSB2aWV3IG1vZGVsc1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEFwcC5wcm9wZXJ0eUJhcnNbMF0udmlld01vZGVsLnNldFNlbGVjdGVkQ2FsaWZvcm5pYVZpZXcoYWN0aXZlVmlldywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAxOyBpIDwgY3VycmVudEFwcC5wcm9wZXJ0eUJhcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcHJvcGVydHlCYXJWaWV3SWQ6IG51bWJlciA9IGN1cnJlbnRBcHAucHJvcGVydHlCYXJzW2ldLnZpZXdNb2RlbC5zZWxlY3RlZENhbGlmb3JuaWFWaWV3SWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5QmFyVmlld0lkICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByb3BlcnR5QmFyVmlldzogQ2FsaWZvcm5pYVZpZXcgPSB1c2VyUGFnZXMuZmluZCh2ID0+IHYuQ2FsaWZvcm5pYVZpZXdJZCA9PT0gcHJvcGVydHlCYXJWaWV3SWQpIGFzIENhbGlmb3JuaWFWaWV3O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnByb3BlcnR5QmFyc1tpXS52aWV3TW9kZWwuc2V0U2VsZWN0ZWRDYWxpZm9ybmlhVmlldyhwcm9wZXJ0eUJhclZpZXcsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNldEFjdGl2ZUNhbGlmb3JuaWFWaWV3KGNhbGlmb3JuaWFWaWV3OiBDYWxpZm9ybmlhVmlldyk6IHZvaWQgeyAvLyBUT0RPIHNob3VsZCBiZSBzZXR0ZXIgbWV0aG9kIGZvciBhY3RpdmVDYWxpZm9ybmlhVmlld1xyXG4gICAgICAgIGN1cnJlbnRBcHAucGFnZVByZXZpZXcudmlld01vZGVsLmFjdGl2ZUNhbGlmb3JuaWFWaWV3SWQgPSBjYWxpZm9ybmlhVmlldy5DYWxpZm9ybmlhVmlld0lkO1xyXG4gICAgICAgIGN1cnJlbnRBcHAucGFnZVByZXZpZXdWTS5jYWxpZm9ybmlhVmlld1Byb2plY3Rvci5tYXAoW2NhbGlmb3JuaWFWaWV3XSk7XHJcbiAgICAgICAgY3VycmVudEFwcC5wYWdlUHJldmlld1ZNLmZpeGVkTGF5b3V0Um93c1Byb2plY3Rvci5tYXAoY2FsaWZvcm5pYVZpZXcuUGxhY2VkTGF5b3V0Um93cyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgcmVzdG9yZUxheW91dE1vbGVjdWxlQW5kU3R5bGVSZWZlcmVuY2VzID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIC8vIHJlc3RvcmUgbGF5b3V0IG1vbGVjdWxlIG9iamVjdCByZWZlcmVuY2VzOiB2aWV3ID0+IHJvdyA9PiBib3hlcyA9PiBib3hlcy9hdG9tcyA9PiBhdG9tcyA9PiBjb250ZW50XHJcbiAgICAgICAgbGV0IHByb2plY3Q6IENhbGlmb3JuaWFQcm9qZWN0ID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0O1xyXG4gICAgICAgIGxldCBhbGxSb3dzOiBMYXlvdXRSb3dbXSA9IFtdO1xyXG4gICAgICAgIGxldCBhbGxCb3hlczogTGF5b3V0Qm94W10gPSBbXTtcclxuICAgICAgICBsZXQgYWxsQXRvbXM6IExheW91dEF0b21bXSA9IFtdO1xyXG4gICAgICAgIHByb2plY3QuTGF5b3V0TW9sZWN1bGVzLm1hcChtb2wgPT4ge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG1vbC5MYXlvdXRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIExheW91dFR5cGUuUm93OlxyXG4gICAgICAgICAgICAgICAgICAgIGFsbFJvd3MucHVzaChtb2wgYXMgTGF5b3V0Um93KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTGF5b3V0VHlwZS5Cb3g6XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsQm94ZXMucHVzaChtb2wgYXMgTGF5b3V0Qm94KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTGF5b3V0VHlwZS5BdG9tOlxyXG4gICAgICAgICAgICAgICAgICAgIGFsbEF0b21zLnB1c2gobW9sIGFzIExheW91dEF0b20pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgYWxsQ29udGVudEF0b21zOiBDb250ZW50QXRvbVtdID0gcHJvamVjdC5Db250ZW50QXRvbXM7XHJcbiAgICAgICAgbGV0IGFsbEludGVyYWN0aW9uczogTGF5b3V0U3R5bGVJbnRlcmFjdGlvbltdID0gcHJvamVjdC5MYXlvdXRTdHlsZUludGVyYWN0aW9ucztcclxuICAgICAgICAvLyBsYXlvdXQgcmVmZXJlbmNlc1xyXG4gICAgICAgIC8vIFRPRE8gc29ydCByb3dzIGhlcmU/IHN0cmFuZ2UgZGF0YSBtb2RlbCAvLyBUT0RPIHNvcnRlZCBub3Qgb25seSB3aGVuIHVwZGF0aW5nIGRhdGEgLy8gVE9ETyBpcyBzb3J0IG9yZGVyIGd1YXJhbnRlZWQgdG8gYmUgZ2VuZXJhdGVkIGxheW91dCBpZCBpbiBnZW5lcmF0ZSBwcm9qZWN0IChwcm9iYWJseSB5ZXMpXHJcbiAgICAgICAgcHJvamVjdC5DYWxpZm9ybmlhVmlld3MubWFwKHZpZXcgPT4ge1xyXG4gICAgICAgICAgICB2aWV3LlBsYWNlZExheW91dFJvd3MgPSBhbGxSb3dzLmZpbHRlcihyb3cgPT4gcm93LlBsYWNlZE9uVmlld0lkID09IHZpZXcuQ2FsaWZvcm5pYVZpZXdJZCkuc29ydCgocm93QTogTGF5b3V0Um93LCByb3dCOiBMYXlvdXRSb3cpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChyb3dBLkxheW91dFNvcnRPcmRlcktleSA8IHJvd0IuTGF5b3V0U29ydE9yZGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocm93QS5MYXlvdXRTb3J0T3JkZXJLZXkgPT0gcm93Qi5MYXlvdXRTb3J0T3JkZXJLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgeyAvLyByb3dBLkxheW91dFNvcnRPcmRlcktleSA+IHJvd0IuTGF5b3V0U29ydE9yZGVyS2V5XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCBkZWVwZXN0TGV2ZWxDdXJyZW50VmlldzogbnVtYmVyID0gMDtcclxuICAgICAgICBwcm9qZWN0LkNhbGlmb3JuaWFWaWV3cy5tYXAodmlldyA9PiB7XHJcbiAgICAgICAgICAgIGRlZXBlc3RMZXZlbEN1cnJlbnRWaWV3ID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaVJvdzogbnVtYmVyID0gMDsgaVJvdyA8IHZpZXcuUGxhY2VkTGF5b3V0Um93cy5sZW5ndGg7IGlSb3crKykgeyAvLyBUT0RPIGFyZSBhcnJheSBsaW1pdHMgcmVjb2duaXplZCBhcyBpbW11dGFibGUgYnkgamF2YXNjcmlwdCBydW50aW1lcz8gaWYgbm90LCBkZWNsYXJlIGxpbWl0IGJlZm9yZSBsb29wIGV2ZXJ5d2hlcmVcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSb3V0ZXIuZGVlcGVzdExldmVsQ3VycmVudFJvdyA9IDA7XHJcbiAgICAgICAgICAgICAgICBsZXQgcm93OiBMYXlvdXRSb3cgPSB2aWV3LlBsYWNlZExheW91dFJvd3NbaVJvd107XHJcbiAgICAgICAgICAgICAgICByb3cuQWxsQm94ZXNCZWxvd1JvdyA9IGFsbEJveGVzLmZpbHRlcihib3ggPT4gYm94LkJveE93bmVyUm93SWQgPT0gcm93LkxheW91dEJhc2VJZCAmJiBib3guUGxhY2VkQm94SW5Cb3hJZCA9PSB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgcm93LkFsbEJveGVzQmVsb3dSb3cubWFwKGJveCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJvdXRlci5yZXN0b3JlTGF5b3V0Qm94UmVmZXJlbmNlc1JlY3Vyc2l2ZSgwLCBib3gsIHJvdywgYWxsQm94ZXMsIGFsbEF0b21zLCBhbGxDb250ZW50QXRvbXMsIGFsbEludGVyYWN0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm94LkJveE93bmVyUm93ID0gcm93O1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByb3cuRGVlcGVzdExldmVsID0gY3VycmVudFJvdXRlci5kZWVwZXN0TGV2ZWxDdXJyZW50Um93O1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRSb3V0ZXIuZGVlcGVzdExldmVsQ3VycmVudFJvdyA+IGRlZXBlc3RMZXZlbEN1cnJlbnRWaWV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVlcGVzdExldmVsQ3VycmVudFZpZXcgPSBjdXJyZW50Um91dGVyLmRlZXBlc3RMZXZlbEN1cnJlbnRSb3c7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmlldy5EZWVwZXN0TGV2ZWwgPSBkZWVwZXN0TGV2ZWxDdXJyZW50VmlldztcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBzdHlsZSByZWZlcmVuY2VzXHJcbiAgICAgICAgLypwcm9qZWN0LlN0eWxlQXRvbXMubWFwKGF0b20gPT4ge1xyXG4gICAgICAgICAgICBhdG9tLkFwcGxpZWRWYWx1ZXMgPSBwcm9qZWN0LlN0eWxlVmFsdWVzLmZpbHRlcih2YWwgPT4gdmFsLlN0eWxlQXRvbUlkID09IGF0b20uU3R5bGVBdG9tSWQpO1xyXG4gICAgICAgIH0pOyovXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImFmdGVyIHJlc3RvcmU6XCIpO2NvbnNvbGUubG9nKGN1cnJlbnRBcHAuY2xpZW50RGF0YSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgcmVzdG9yZUxheW91dEJveFJlZmVyZW5jZXNSZWN1cnNpdmUgPSAoYm94TGV2ZWw6IG51bWJlciwgYm94OiBMYXlvdXRCb3gsIGJveE93bmVyUm93OiBMYXlvdXRSb3csIGFsbEJveGVzOiBMYXlvdXRCb3hbXSwgYWxsQXRvbXM6IExheW91dEF0b21bXSwgYWxsQ29udGVudEF0b21zOiBDb250ZW50QXRvbVtdLCBhbGxJbnRlcmFjdGlvbnM6IExheW91dFN0eWxlSW50ZXJhY3Rpb25bXSk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGJveC5MZXZlbCA9IGJveExldmVsO1xyXG4gICAgICAgIGJveC5QbGFjZWRJbkJveEJveGVzID0gYWxsQm94ZXMuZmlsdGVyKHN1YkJveCA9PiBzdWJCb3guUGxhY2VkQm94SW5Cb3hJZCAhPT0gdW5kZWZpbmVkICYmIHN1YkJveC5QbGFjZWRCb3hJbkJveElkID09IGJveC5MYXlvdXRCYXNlSWQpO1xyXG4gICAgICAgIGJveC5QbGFjZWRJbkJveEJveGVzLm1hcChzdWJCb3ggPT4ge1xyXG4gICAgICAgICAgICBjdXJyZW50Um91dGVyLnJlc3RvcmVMYXlvdXRCb3hSZWZlcmVuY2VzUmVjdXJzaXZlKGJveExldmVsICsgMSwgc3ViQm94LCBib3hPd25lclJvdywgYWxsQm94ZXMsIGFsbEF0b21zLCBhbGxDb250ZW50QXRvbXMsIGFsbEludGVyYWN0aW9ucyk7XHJcbiAgICAgICAgICAgIHN1YkJveC5Cb3hPd25lclJvdyA9IGJveE93bmVyUm93O1xyXG4gICAgICAgICAgICBzdWJCb3guUGxhY2VkQm94SW5Cb3ggPSBib3g7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYm94T3duZXJSb3cuQWxsQm94ZXNCZWxvd1Jvdy5wdXNoKC4uLmJveC5QbGFjZWRJbkJveEJveGVzKTtcclxuICAgICAgICBib3guUGxhY2VkSW5Cb3hBdG9tcyA9IGFsbEF0b21zLmZpbHRlcihzdWJBdG9tID0+IHN1YkF0b20uUGxhY2VkQXRvbUluQm94SWQgIT09IHVuZGVmaW5lZCAmJiBzdWJBdG9tLlBsYWNlZEF0b21JbkJveElkID09IGJveC5MYXlvdXRCYXNlSWQpO1xyXG4gICAgICAgIGJveC5QbGFjZWRJbkJveEF0b21zLm1hcChzdWJBdG9tID0+IHtcclxuICAgICAgICAgICAgc3ViQXRvbS5Ib3N0ZWRDb250ZW50QXRvbSA9IGFsbENvbnRlbnRBdG9tcy5maW5kKGNvbnRlbnRBdG9tID0+IGNvbnRlbnRBdG9tLkluc3RhbmNlZE9uTGF5b3V0SWQgPT0gc3ViQXRvbS5MYXlvdXRCYXNlSWQpIGFzIENvbnRlbnRBdG9tO1xyXG4gICAgICAgICAgICBzdWJBdG9tLlBsYWNlZEF0b21JbkJveCA9IGJveDtcclxuICAgICAgICAgICAgc3ViQXRvbS5MYXlvdXRTdHlsZUludGVyYWN0aW9ucyA9IGFsbEludGVyYWN0aW9ucy5maWx0ZXIobWFwID0+IG1hcC5MYXlvdXRBdG9tSWQgPT0gc3ViQXRvbS5MYXlvdXRCYXNlSWQpO1xyXG4gICAgICAgICAgICBzdWJBdG9tLkxldmVsID0gYm94TGV2ZWwgKyAxO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChib3guUGxhY2VkSW5Cb3hBdG9tcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGlmICgoYm94TGV2ZWwgKyAxKSA+IGN1cnJlbnRSb3V0ZXIuZGVlcGVzdExldmVsQ3VycmVudFJvdykge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFJvdXRlci5kZWVwZXN0TGV2ZWxDdXJyZW50Um93ID0gYm94TGV2ZWwgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGJveExldmVsID4gY3VycmVudFJvdXRlci5kZWVwZXN0TGV2ZWxDdXJyZW50Um93KSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRSb3V0ZXIuZGVlcGVzdExldmVsQ3VycmVudFJvdyA9IGJveExldmVsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNldHVwVWlGb3JEZXZpY2UgPSAoKTogdm9pZCA9PiB7XHJcbiAgICAgICAgLy8gVE9ETyB1c2Ugd2luZG93LmlubmVyV2lkdGggdG8gYWRqdXN0IFVJIHN0YXRlLCBjYWxsZWQgb24gcGFnZSBsb2FkIGFuZCB3aW5kb3cgcmVzaXplIFRPRE8gaXBob25lIHNlZW1zIHRvIGhhdmUgdmlld3BvcnQgbGFyZ2VyIHRoYW4gYXZhaWxhYmxlIHNwYWNlLi4uXHJcbiAgICAgICAgbGV0IGNhbGlmb3JuaWFBcHBIZWlnaHQ6IG51bWJlciB8IHVuZGVmaW5lZCA9ICQod2luZG93KS5oZWlnaHQoKTsgLy8gVE9ETyB1c2UgaW5uZXIgb3Igb3V0ZXIgaGVpZ2h0XHJcbiAgICAgICAgaWYgKGNhbGlmb3JuaWFBcHBIZWlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5oZWlnaHQgPSBgJHtjYWxpZm9ybmlhQXBwSGVpZ2h0fXB4YDsgLy8gMTAwJSBoZWlnaHQgb24gaVBhZCwgd2l0aCBhbmQgd2l0aG91dCByZW5kZXJlZCBicm93c2VyIGNvbnRyb2xzXHJcbiAgICAgICAgLy8gY2xpZW50V2lkdGggaW5jbHVkZXMgbWFyZ2luXHJcbiAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUuaXNIaWRlVXNlckludGVyZmFjZSA9PT0gdHJ1ZSB8fCBjdXJyZW50QXBwLnN0YXRlLmVkaXRWaWV3TW9kZSA9PT0gRWRpdFZpZXdNb2RlLlBhZ2VQcmV2aWV3T25seSkge1xyXG4gICAgICAgICAgICAvLyBUT0RPIHZlcmlmeSB0aGlzIHdvcmtzIGV2ZXJ5d2hlcmVcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5hdmFpbGFibGVTcGFjZVBhZ2VQcmV2aWV3UHggPSBjdXJyZW50QXBwLnBhZ2VQcmV2aWV3SG9sZGVyICE9PSB1bmRlZmluZWQgPyB3aW5kb3cuaW5uZXJXaWR0aCArIDIgKiBjdXJyZW50QXBwLnN0YXRlLnRhcmdldFBhZ2VQcmV2aWV3SG9sZGVyTWFyZ2luUHggOiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5hdmFpbGFibGVTcGFjZVBhZ2VQcmV2aWV3UHggPSBjdXJyZW50QXBwLnBhZ2VQcmV2aWV3SG9sZGVyICE9PSB1bmRlZmluZWQgPyBjdXJyZW50QXBwLnBhZ2VQcmV2aWV3SG9sZGVyLmNsaWVudFdpZHRoICsgKDIgKiBjdXJyZW50QXBwLnN0YXRlLnRhcmdldFBhZ2VQcmV2aWV3SG9sZGVyTWFyZ2luUHgpIDogMDsgLy8gVE9ETyB0ZXN0IHJlc3VsdGluZyB2YWx1ZSBjaGFuZ2VzIGRlcGVuZGluZyBvbiBjbGllbnQgYnJvd3Nlci9zeXN0ZW0gYXJjaGl0ZWN0dXJlP1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0ICE9PSB1bmRlZmluZWQgJiYgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzICE9PSB1bmRlZmluZWQgJiYgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRBcHAucGFnZVByZXZpZXdWTS5lZGl0ZWRMYXlvdXRBdG9tSWQgPT0gMCkgeyAvLyBUT0RPXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGRpc2FibGUgcmVzaXplIHdoZW4gZWRpdGluZyB0ZXh0IGFyZWFzIGluIG90aGVyIGNvbnRyb2xzIChlLmcuIHZhbHVlIGluIHByb3BlcnR5IGJhcilcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucGFnZVByZXZpZXcudXBkYXRlUGFnZVByZXZpZXdEaW1lbnNpb25zKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgdmFsaWRhdGVSZXNwb25zZSA9IChyZXNwb25zZTogQ2FsaWZvcm5pYUNsaWVudFZpZXdNb2RlbCk6IGJvb2xlYW4gPT4ge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2cocmVzcG9uc2UpOyAvLyBUT0RPIGV4Y2VwdGlvbiBtYW5hZ2VtZW50OiB3aGVuIGFwcCB0aHJvd3MsIGhhbmdzLCBldGMuIHByaW50IGN1cnJlbnQgZGF0YSBzdGF0ZSAob3Igc2F2ZSBvbiBzZW5kKCEhKSlcclxuICAgICAgICBpZiAocmVzcG9uc2UgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImludmFsaWQgY2xpZW50IGRhdGFcIik7IC8vIFRPRE9cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2UuU3RhdHVzVGV4dCAhPT0gbnVsbCAmJiByZXNwb25zZS5TdGF0dXNUZXh0ICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlLlN0YXR1c1RleHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNoZWNrIHJldmlzaW9uXHJcbiAgICAgICAgaWYgKChjdXJyZW50QXBwLmNsaWVudERhdGEgIT09IHVuZGVmaW5lZCkgJiYgKHJlc3BvbnNlLkN1cnJlbnRSZXZpc2lvbiA8IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DdXJyZW50UmV2aXNpb24pKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSWdub3JpbmcgY2xpZW50IGRhdGE6IHJldmlzaW9uIGlzIGxvd2VyXCIpO1xyXG4gICAgICAgICAgICAvLyBUT0RPIG1ha2Ugc3VyZSBhbGwgb3RoZXIgc3R1ZmYgdGhhdCBjYWxscyB0aGlzIGZ1bmN0aW9uIGhhbmRsZXMgY2FzZSBjb3JyZWN0bHlcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9Nb2RlbHMvQ2FsaWZvcm5pYVJvdXRlci50c3giLCJcclxuXHJcbmltcG9ydCB7Q29udGVudEF0b219IGZyb20gXCIuL0NvbnRlbnRBdG9tXCI7IFxyXG5leHBvcnQgY2xhc3MgQ2FsaWZvcm5pYUNsaWVudFBhcnRpYWxEYXRhIHsgXHJcbiAgICBDb250ZW50QXRvbTogQ29udGVudEF0b207XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9UeXBld3JpdGVyL0NhbGlmb3JuaWFDbGllbnRQYXJ0aWFsRGF0YS50cyJdLCJzb3VyY2VSb290IjoiIn0=