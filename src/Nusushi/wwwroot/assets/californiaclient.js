var Californiaclient =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/assets/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.3.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		noModule: true
	};

	function DOMEval( code, doc, node ) {
		doc = doc || document;

		var i,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {
				if ( node[ i ] ) {
					script[ i ] = node[ i ];
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.3.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		div.style.position = "absolute";
		scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5
		) );
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),
		val = curCSS( elem, dimension, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox;

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = valueIsBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ dimension ] );

	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	if ( val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

		val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

		// offsetWidth/offsetHeight provide border-box values
		valueIsBorderBox = true;
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),
				isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra && boxModelAdjustment(
					elem,
					dimension,
					extra,
					isBorderBox,
					styles
				);

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && support.scrollboxSize() === styles.position ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {
    if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {
        // CommonJS
        factory(exports);
    } else {
        // Browser globals
        factory(root.maquette = {});
    }
}(this, function (exports) {
    'use strict';
    // Comment that is displayed in the API documentation for the maquette module:
    /**
 * Welcome to the API documentation of the **maquette** library.
 *
 * [[http://maquettejs.org/|To the maquette homepage]]
 */
    Object.defineProperty(exports, '__esModule', { value: true });
    var NAMESPACE_W3 = 'http://www.w3.org/';
    var NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';
    var NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';
    // Utilities
    var emptyArray = [];
    var extend = function (base, overrides) {
        var result = {};
        Object.keys(base).forEach(function (key) {
            result[key] = base[key];
        });
        if (overrides) {
            Object.keys(overrides).forEach(function (key) {
                result[key] = overrides[key];
            });
        }
        return result;
    };
    // Hyperscript helper functions
    var same = function (vnode1, vnode2) {
        if (vnode1.vnodeSelector !== vnode2.vnodeSelector) {
            return false;
        }
        if (vnode1.properties && vnode2.properties) {
            if (vnode1.properties.key !== vnode2.properties.key) {
                return false;
            }
            return vnode1.properties.bind === vnode2.properties.bind;
        }
        return !vnode1.properties && !vnode2.properties;
    };
    var toTextVNode = function (data) {
        return {
            vnodeSelector: '',
            properties: undefined,
            children: undefined,
            text: data.toString(),
            domNode: null
        };
    };
    var appendChildren = function (parentSelector, insertions, main) {
        for (var i = 0, length_1 = insertions.length; i < length_1; i++) {
            var item = insertions[i];
            if (Array.isArray(item)) {
                appendChildren(parentSelector, item, main);
            } else {
                if (item !== null && item !== undefined) {
                    if (!item.hasOwnProperty('vnodeSelector')) {
                        item = toTextVNode(item);
                    }
                    main.push(item);
                }
            }
        }
    };
    // Render helper functions
    var missingTransition = function () {
        throw new Error('Provide a transitions object to the projectionOptions to do animations');
    };
    var DEFAULT_PROJECTION_OPTIONS = {
        namespace: undefined,
        eventHandlerInterceptor: undefined,
        styleApplyer: function (domNode, styleName, value) {
            // Provides a hook to add vendor prefixes for browsers that still need it.
            domNode.style[styleName] = value;
        },
        transitions: {
            enter: missingTransition,
            exit: missingTransition
        }
    };
    var applyDefaultProjectionOptions = function (projectorOptions) {
        return extend(DEFAULT_PROJECTION_OPTIONS, projectorOptions);
    };
    var checkStyleValue = function (styleValue) {
        if (typeof styleValue !== 'string') {
            throw new Error('Style values must be strings');
        }
    };
    var setProperties = function (domNode, properties, projectionOptions) {
        if (!properties) {
            return;
        }
        var eventHandlerInterceptor = projectionOptions.eventHandlerInterceptor;
        var propNames = Object.keys(properties);
        var propCount = propNames.length;
        var _loop_1 = function (i) {
            var propName = propNames[i];
            /* tslint:disable:no-var-keyword: edge case */
            var propValue = properties[propName];
            /* tslint:enable:no-var-keyword */
            if (propName === 'className') {
                throw new Error('Property "className" is not supported, use "class".');
            } else if (propName === 'class') {
                propValue.split(/\s+/).forEach(function (token) {
                    return domNode.classList.add(token);
                });
            } else if (propName === 'classes') {
                // object with string keys and boolean values
                var classNames = Object.keys(propValue);
                var classNameCount = classNames.length;
                for (var j = 0; j < classNameCount; j++) {
                    var className = classNames[j];
                    if (propValue[className]) {
                        domNode.classList.add(className);
                    }
                }
            } else if (propName === 'styles') {
                // object with string keys and string (!) values
                var styleNames = Object.keys(propValue);
                var styleCount = styleNames.length;
                for (var j = 0; j < styleCount; j++) {
                    var styleName = styleNames[j];
                    var styleValue = propValue[styleName];
                    if (styleValue) {
                        checkStyleValue(styleValue);
                        projectionOptions.styleApplyer(domNode, styleName, styleValue);
                    }
                }
            } else if (propName !== 'key' && propValue !== null && propValue !== undefined) {
                var type = typeof propValue;
                if (type === 'function') {
                    if (propName.lastIndexOf('on', 0) === 0) {
                        if (eventHandlerInterceptor) {
                            propValue = eventHandlerInterceptor(propName, propValue, domNode, properties);    // intercept eventhandlers
                        }
                        if (propName === 'oninput') {
                            (function () {
                                // record the evt.target.value, because IE and Edge sometimes do a requestAnimationFrame between changing value and running oninput
                                var oldPropValue = propValue;
                                propValue = function (evt) {
                                    oldPropValue.apply(this, [evt]);
                                    evt.target['oninput-value'] = evt.target.value;    // may be HTMLTextAreaElement as well
                                };
                            }());
                        }
                        domNode[propName] = propValue;
                    }
                } else if (type === 'string' && propName !== 'value' && propName !== 'innerHTML') {
                    if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {
                        domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);
                    } else {
                        domNode.setAttribute(propName, propValue);
                    }
                } else {
                    domNode[propName] = propValue;
                }
            }
        };
        for (var i = 0; i < propCount; i++) {
            _loop_1(i);
        }
    };
    var updateProperties = function (domNode, previousProperties, properties, projectionOptions) {
        if (!properties) {
            return;
        }
        var propertiesUpdated = false;
        var propNames = Object.keys(properties);
        var propCount = propNames.length;
        for (var i = 0; i < propCount; i++) {
            var propName = propNames[i];
            // assuming that properties will be nullified instead of missing is by design
            var propValue = properties[propName];
            var previousValue = previousProperties[propName];
            if (propName === 'class') {
                if (previousValue !== propValue) {
                    throw new Error('"class" property may not be updated. Use the "classes" property for conditional css classes.');
                }
            } else if (propName === 'classes') {
                var classList = domNode.classList;
                var classNames = Object.keys(propValue);
                var classNameCount = classNames.length;
                for (var j = 0; j < classNameCount; j++) {
                    var className = classNames[j];
                    var on = !!propValue[className];
                    var previousOn = !!previousValue[className];
                    if (on === previousOn) {
                        continue;
                    }
                    propertiesUpdated = true;
                    if (on) {
                        classList.add(className);
                    } else {
                        classList.remove(className);
                    }
                }
            } else if (propName === 'styles') {
                var styleNames = Object.keys(propValue);
                var styleCount = styleNames.length;
                for (var j = 0; j < styleCount; j++) {
                    var styleName = styleNames[j];
                    var newStyleValue = propValue[styleName];
                    var oldStyleValue = previousValue[styleName];
                    if (newStyleValue === oldStyleValue) {
                        continue;
                    }
                    propertiesUpdated = true;
                    if (newStyleValue) {
                        checkStyleValue(newStyleValue);
                        projectionOptions.styleApplyer(domNode, styleName, newStyleValue);
                    } else {
                        projectionOptions.styleApplyer(domNode, styleName, '');
                    }
                }
            } else {
                if (!propValue && typeof previousValue === 'string') {
                    propValue = '';
                }
                if (propName === 'value') {
                    var domValue = domNode[propName];
                    if (domValue !== propValue    // The 'value' in the DOM tree !== newValue
&& (domNode['oninput-value'] ? domValue === domNode['oninput-value']    // If the last reported value to 'oninput' does not match domValue, do nothing and wait for oninput
 : propValue !== previousValue    // Only update the value if the vdom changed
)) {
                        domNode[propName] = propValue;
                        // Reset the value, even if the virtual DOM did not change
                        domNode['oninput-value'] = undefined;
                    }
                    // else do not update the domNode, otherwise the cursor position would be changed
                    if (propValue !== previousValue) {
                        propertiesUpdated = true;
                    }
                } else if (propValue !== previousValue) {
                    var type = typeof propValue;
                    if (type === 'function') {
                        throw new Error('Functions may not be updated on subsequent renders (property: ' + propName + '). Hint: declare event handler functions outside the render() function.');
                    }
                    if (type === 'string' && propName !== 'innerHTML') {
                        if (projectionOptions.namespace === NAMESPACE_SVG && propName === 'href') {
                            domNode.setAttributeNS(NAMESPACE_XLINK, propName, propValue);
                        } else if (propName === 'role' && propValue === '') {
                            domNode.removeAttribute(propName);
                        } else {
                            domNode.setAttribute(propName, propValue);
                        }
                    } else {
                        if (domNode[propName] !== propValue) {
                            domNode[propName] = propValue;
                        }
                    }
                    propertiesUpdated = true;
                }
            }
        }
        return propertiesUpdated;
    };
    var findIndexOfChild = function (children, sameAs, start) {
        if (sameAs.vnodeSelector !== '') {
            // Never scan for text-nodes
            for (var i = start; i < children.length; i++) {
                if (same(children[i], sameAs)) {
                    return i;
                }
            }
        }
        return -1;
    };
    var nodeAdded = function (vNode, transitions) {
        if (vNode.properties) {
            var enterAnimation = vNode.properties.enterAnimation;
            if (enterAnimation) {
                if (typeof enterAnimation === 'function') {
                    enterAnimation(vNode.domNode, vNode.properties);
                } else {
                    transitions.enter(vNode.domNode, vNode.properties, enterAnimation);
                }
            }
        }
    };
    var nodeToRemove = function (vNode, transitions) {
        var domNode = vNode.domNode;
        if (vNode.properties) {
            var exitAnimation = vNode.properties.exitAnimation;
            if (exitAnimation) {
                domNode.style.pointerEvents = 'none';
                var removeDomNode = function () {
                    if (domNode.parentNode) {
                        domNode.parentNode.removeChild(domNode);
                    }
                };
                if (typeof exitAnimation === 'function') {
                    exitAnimation(domNode, removeDomNode, vNode.properties);
                    return;
                } else {
                    transitions.exit(vNode.domNode, vNode.properties, exitAnimation, removeDomNode);
                    return;
                }
            }
        }
        if (domNode.parentNode) {
            domNode.parentNode.removeChild(domNode);
        }
    };
    var checkDistinguishable = function (childNodes, indexToCheck, parentVNode, operation) {
        var childNode = childNodes[indexToCheck];
        if (childNode.vnodeSelector === '') {
            return;    // Text nodes need not be distinguishable
        }
        var properties = childNode.properties;
        var key = properties ? properties.key === undefined ? properties.bind : properties.key : undefined;
        if (!key) {
            for (var i = 0; i < childNodes.length; i++) {
                if (i !== indexToCheck) {
                    var node = childNodes[i];
                    if (same(node, childNode)) {
                        if (operation === 'added') {
                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'added, but there is now more than one. You must add unique key properties to make them distinguishable.');
                        } else {
                            throw new Error(parentVNode.vnodeSelector + ' had a ' + childNode.vnodeSelector + ' child ' + 'removed, but there were more than one. You must add unique key properties to make them distinguishable.');
                        }
                    }
                }
            }
        }
    };
    var createDom;
    var updateDom;
    var updateChildren = function (vnode, domNode, oldChildren, newChildren, projectionOptions) {
        if (oldChildren === newChildren) {
            return false;
        }
        oldChildren = oldChildren || emptyArray;
        newChildren = newChildren || emptyArray;
        var oldChildrenLength = oldChildren.length;
        var newChildrenLength = newChildren.length;
        var transitions = projectionOptions.transitions;
        var oldIndex = 0;
        var newIndex = 0;
        var i;
        var textUpdated = false;
        while (newIndex < newChildrenLength) {
            var oldChild = oldIndex < oldChildrenLength ? oldChildren[oldIndex] : undefined;
            var newChild = newChildren[newIndex];
            if (oldChild !== undefined && same(oldChild, newChild)) {
                textUpdated = updateDom(oldChild, newChild, projectionOptions) || textUpdated;
                oldIndex++;
            } else {
                var findOldIndex = findIndexOfChild(oldChildren, newChild, oldIndex + 1);
                if (findOldIndex >= 0) {
                    // Remove preceding missing children
                    for (i = oldIndex; i < findOldIndex; i++) {
                        nodeToRemove(oldChildren[i], transitions);
                        checkDistinguishable(oldChildren, i, vnode, 'removed');
                    }
                    textUpdated = updateDom(oldChildren[findOldIndex], newChild, projectionOptions) || textUpdated;
                    oldIndex = findOldIndex + 1;
                } else {
                    // New child
                    createDom(newChild, domNode, oldIndex < oldChildrenLength ? oldChildren[oldIndex].domNode : undefined, projectionOptions);
                    nodeAdded(newChild, transitions);
                    checkDistinguishable(newChildren, newIndex, vnode, 'added');
                }
            }
            newIndex++;
        }
        if (oldChildrenLength > oldIndex) {
            // Remove child fragments
            for (i = oldIndex; i < oldChildrenLength; i++) {
                nodeToRemove(oldChildren[i], transitions);
                checkDistinguishable(oldChildren, i, vnode, 'removed');
            }
        }
        return textUpdated;
    };
    var addChildren = function (domNode, children, projectionOptions) {
        if (!children) {
            return;
        }
        for (var i = 0; i < children.length; i++) {
            createDom(children[i], domNode, undefined, projectionOptions);
        }
    };
    var initPropertiesAndChildren = function (domNode, vnode, projectionOptions) {
        addChildren(domNode, vnode.children, projectionOptions);
        // children before properties, needed for value property of <select>.
        if (vnode.text) {
            domNode.textContent = vnode.text;
        }
        setProperties(domNode, vnode.properties, projectionOptions);
        if (vnode.properties && vnode.properties.afterCreate) {
            vnode.properties.afterCreate.apply(vnode.properties.bind || vnode.properties, [
                domNode,
                projectionOptions,
                vnode.vnodeSelector,
                vnode.properties,
                vnode.children
            ]);
        }
    };
    createDom = function (vnode, parentNode, insertBefore, projectionOptions) {
        var domNode, i, c, start = 0, type, found;
        var vnodeSelector = vnode.vnodeSelector;
        var doc = parentNode.ownerDocument;
        if (vnodeSelector === '') {
            domNode = vnode.domNode = doc.createTextNode(vnode.text);
            if (insertBefore !== undefined) {
                parentNode.insertBefore(domNode, insertBefore);
            } else {
                parentNode.appendChild(domNode);
            }
        } else {
            for (i = 0; i <= vnodeSelector.length; ++i) {
                c = vnodeSelector.charAt(i);
                if (i === vnodeSelector.length || c === '.' || c === '#') {
                    type = vnodeSelector.charAt(start - 1);
                    found = vnodeSelector.slice(start, i);
                    if (type === '.') {
                        domNode.classList.add(found);
                    } else if (type === '#') {
                        domNode.id = found;
                    } else {
                        if (found === 'svg') {
                            projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });
                        }
                        if (projectionOptions.namespace !== undefined) {
                            domNode = vnode.domNode = doc.createElementNS(projectionOptions.namespace, found);
                        } else {
                            domNode = vnode.domNode = vnode.domNode || doc.createElement(found);
                            if (found === 'input' && vnode.properties && vnode.properties.type !== undefined) {
                                // IE8 and older don't support setting input type after the DOM Node has been added to the document
                                domNode.setAttribute('type', vnode.properties.type);
                            }
                        }
                        if (insertBefore !== undefined) {
                            parentNode.insertBefore(domNode, insertBefore);
                        } else if (domNode.parentNode !== parentNode) {
                            parentNode.appendChild(domNode);
                        }
                    }
                    start = i + 1;
                }
            }
            initPropertiesAndChildren(domNode, vnode, projectionOptions);
        }
    };
    updateDom = function (previous, vnode, projectionOptions) {
        var domNode = previous.domNode;
        var textUpdated = false;
        if (previous === vnode) {
            return false;    // By contract, VNode objects may not be modified anymore after passing them to maquette
        }
        var updated = false;
        if (vnode.vnodeSelector === '') {
            if (vnode.text !== previous.text) {
                var newVNode = domNode.ownerDocument.createTextNode(vnode.text);
                domNode.parentNode.replaceChild(newVNode, domNode);
                vnode.domNode = newVNode;
                textUpdated = true;
                return textUpdated;
            }
        } else {
            if (vnode.vnodeSelector.lastIndexOf('svg', 0) === 0) {
                projectionOptions = extend(projectionOptions, { namespace: NAMESPACE_SVG });
            }
            if (previous.text !== vnode.text) {
                updated = true;
                if (vnode.text === undefined) {
                    domNode.removeChild(domNode.firstChild);    // the only textnode presumably
                } else {
                    domNode.textContent = vnode.text;
                }
            }
            updated = updateChildren(vnode, domNode, previous.children, vnode.children, projectionOptions) || updated;
            updated = updateProperties(domNode, previous.properties, vnode.properties, projectionOptions) || updated;
            if (vnode.properties && vnode.properties.afterUpdate) {
                vnode.properties.afterUpdate.apply(vnode.properties.bind || vnode.properties, [
                    domNode,
                    projectionOptions,
                    vnode.vnodeSelector,
                    vnode.properties,
                    vnode.children
                ]);
            }
        }
        if (updated && vnode.properties && vnode.properties.updateAnimation) {
            vnode.properties.updateAnimation(domNode, vnode.properties, previous.properties);
        }
        vnode.domNode = previous.domNode;
        return textUpdated;
    };
    var createProjection = function (vnode, projectionOptions) {
        return {
            update: function (updatedVnode) {
                if (vnode.vnodeSelector !== updatedVnode.vnodeSelector) {
                    throw new Error('The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)');
                }
                updateDom(vnode, updatedVnode, projectionOptions);
                vnode = updatedVnode;
            },
            domNode: vnode.domNode
        };
    };
    // The other two parameters are not added here, because the Typescript compiler creates surrogate code for destructuring 'children'.
    exports.h = function (selector) {
        var properties = arguments[1];
        if (typeof selector !== 'string') {
            throw new Error();
        }
        var childIndex = 1;
        if (properties && !properties.hasOwnProperty('vnodeSelector') && !Array.isArray(properties) && typeof properties === 'object') {
            childIndex = 2;
        } else {
            // Optional properties argument was omitted
            properties = undefined;
        }
        var text;
        var children;
        var argsLength = arguments.length;
        // Recognize a common special case where there is only a single text node
        if (argsLength === childIndex + 1) {
            var onlyChild = arguments[childIndex];
            if (typeof onlyChild === 'string') {
                text = onlyChild;
            } else if (onlyChild !== undefined && onlyChild !== null && onlyChild.length === 1 && typeof onlyChild[0] === 'string') {
                text = onlyChild[0];
            }
        }
        if (text === undefined) {
            children = [];
            for (; childIndex < argsLength; childIndex++) {
                var child = arguments[childIndex];
                if (child === null || child === undefined) {
                } else if (Array.isArray(child)) {
                    appendChildren(selector, child, children);
                } else if (child.hasOwnProperty('vnodeSelector')) {
                    children.push(child);
                } else {
                    children.push(toTextVNode(child));
                }
            }
        }
        return {
            vnodeSelector: selector,
            properties: properties,
            children: children,
            text: text === '' ? undefined : text,
            domNode: null
        };
    };
    /**
 * Contains simple low-level utility functions to manipulate the real DOM.
 */
    exports.dom = {
        /**
     * Creates a real DOM tree from `vnode`. The [[Projection]] object returned will contain the resulting DOM Node in
     * its [[Projection.domNode|domNode]] property.
     * This is a low-level method. Users will typically use a [[Projector]] instead.
     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]
     * objects may only be rendered once.
     * @param projectionOptions - Options to be used to create and update the projection.
     * @returns The [[Projection]] which also contains the DOM Node that was created.
     */
        create: function (vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            createDom(vnode, document.createElement('div'), undefined, projectionOptions);
            return createProjection(vnode, projectionOptions);
        },
        /**
     * Appends a new child node to the DOM which is generated from a [[VNode]].
     * This is a low-level method. Users will typically use a [[Projector]] instead.
     * @param parentNode - The parent node for the new child node.
     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]
     * objects may only be rendered once.
     * @param projectionOptions - Options to be used to create and update the [[Projection]].
     * @returns The [[Projection]] that was created.
     */
        append: function (parentNode, vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            createDom(vnode, parentNode, undefined, projectionOptions);
            return createProjection(vnode, projectionOptions);
        },
        /**
     * Inserts a new DOM node which is generated from a [[VNode]].
     * This is a low-level method. Users wil typically use a [[Projector]] instead.
     * @param beforeNode - The node that the DOM Node is inserted before.
     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function.
     * NOTE: [[VNode]] objects may only be rendered once.
     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].
     * @returns The [[Projection]] that was created.
     */
        insertBefore: function (beforeNode, vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            createDom(vnode, beforeNode.parentNode, beforeNode, projectionOptions);
            return createProjection(vnode, projectionOptions);
        },
        /**
     * Merges a new DOM node which is generated from a [[VNode]] with an existing DOM Node.
     * This means that the virtual DOM and the real DOM will have one overlapping element.
     * Therefore the selector for the root [[VNode]] will be ignored, but its properties and children will be applied to the Element provided.
     * This is a low-level method. Users wil typically use a [[Projector]] instead.
     * @param element - The existing element to adopt as the root of the new virtual DOM. Existing attributes and child nodes are preserved.
     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]] objects
     * may only be rendered once.
     * @param projectionOptions - Options to be used to create and update the projection, see [[createProjector]].
     * @returns The [[Projection]] that was created.
     */
        merge: function (element, vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            vnode.domNode = element;
            initPropertiesAndChildren(element, vnode, projectionOptions);
            return createProjection(vnode, projectionOptions);
        },
        /**
     * Replaces an existing DOM node with a node generated from a [[VNode]].
     * This is a low-level method. Users will typically use a [[Projector]] instead.
     * @param element - The node for the [[VNode]] to replace.
     * @param vnode - The root of the virtual DOM tree that was created using the [[h]] function. NOTE: [[VNode]]
     * objects may only be rendered once.
     * @param projectionOptions - Options to be used to create and update the [[Projection]].
     * @returns The [[Projection]] that was created.
     */
        replace: function (element, vnode, projectionOptions) {
            projectionOptions = applyDefaultProjectionOptions(projectionOptions);
            createDom(vnode, element.parentNode, element, projectionOptions);
            element.parentNode.removeChild(element);
            return createProjection(vnode, projectionOptions);
        }
    };
    /**
 * Creates a [[CalculationCache]] object, useful for caching [[VNode]] trees.
 * In practice, caching of [[VNode]] trees is not needed, because achieving 60 frames per second is almost never a problem.
 * For more information, see [[CalculationCache]].
 *
 * @param <Result> The type of the value that is cached.
 */
    exports.createCache = function () {
        var cachedInputs;
        var cachedOutcome;
        return {
            invalidate: function () {
                cachedOutcome = undefined;
                cachedInputs = undefined;
            },
            result: function (inputs, calculation) {
                if (cachedInputs) {
                    for (var i = 0; i < inputs.length; i++) {
                        if (cachedInputs[i] !== inputs[i]) {
                            cachedOutcome = undefined;
                        }
                    }
                }
                if (!cachedOutcome) {
                    cachedOutcome = calculation();
                    cachedInputs = inputs;
                }
                return cachedOutcome;
            }
        };
    };
    /**
 * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.
 * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.
 *
 * @param <Source>       The type of source items. A database-record for instance.
 * @param <Target>       The type of target items. A [[Component]] for instance.
 * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.
 * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical
 *                       to the `callback` argument in `Array.map(callback)`.
 * @param updateResult   `function(source, target, index)` that updates a result to an updated source.
 */
    exports.createMapping = function (getSourceKey, createResult, updateResult) {
        var keys = [];
        var results = [];
        return {
            results: results,
            map: function (newSources) {
                var newKeys = newSources.map(getSourceKey);
                var oldTargets = results.slice();
                var oldIndex = 0;
                for (var i = 0; i < newSources.length; i++) {
                    var source = newSources[i];
                    var sourceKey = newKeys[i];
                    if (sourceKey === keys[oldIndex]) {
                        results[i] = oldTargets[oldIndex];
                        updateResult(source, oldTargets[oldIndex], i);
                        oldIndex++;
                    } else {
                        var found = false;
                        for (var j = 1; j < keys.length + 1; j++) {
                            var searchIndex = (oldIndex + j) % keys.length;
                            if (keys[searchIndex] === sourceKey) {
                                results[i] = oldTargets[searchIndex];
                                updateResult(newSources[i], oldTargets[searchIndex], i);
                                oldIndex = searchIndex + 1;
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            results[i] = createResult(source, i);
                        }
                    }
                }
                results.length = newSources.length;
                keys = newKeys;
            }
        };
    };
    /**
 * Creates a [[Projector]] instance using the provided projectionOptions.
 *
 * For more information, see [[Projector]].
 *
 * @param projectorOptions   Options that influence how the DOM is rendered and updated.
 */
    exports.createProjector = function (projectorOptions) {
        var projector;
        var projectionOptions = applyDefaultProjectionOptions(projectorOptions);
        projectionOptions.eventHandlerInterceptor = function (propertyName, eventHandler, domNode, properties) {
            return function () {
                // intercept function calls (event handlers) to do a render afterwards.
                projector.scheduleRender();
                return eventHandler.apply(properties.bind || this, arguments);
            };
        };
        var renderCompleted = true;
        var scheduled;
        var stopped = false;
        var projections = [];
        var renderFunctions = [];
        // matches the projections array
        var doRender = function () {
            scheduled = undefined;
            if (!renderCompleted) {
                return;    // The last render threw an error, it should be logged in the browser console.
            }
            renderCompleted = false;
            for (var i = 0; i < projections.length; i++) {
                var updatedVnode = renderFunctions[i]();
                projections[i].update(updatedVnode);
            }
            renderCompleted = true;
        };
        projector = {
            renderNow: doRender,
            scheduleRender: function () {
                if (!scheduled && !stopped) {
                    scheduled = requestAnimationFrame(doRender);
                }
            },
            stop: function () {
                if (scheduled) {
                    cancelAnimationFrame(scheduled);
                    scheduled = undefined;
                }
                stopped = true;
            },
            resume: function () {
                stopped = false;
                renderCompleted = true;
                projector.scheduleRender();
            },
            append: function (parentNode, renderMaquetteFunction) {
                projections.push(exports.dom.append(parentNode, renderMaquetteFunction(), projectionOptions));
                renderFunctions.push(renderMaquetteFunction);
            },
            insertBefore: function (beforeNode, renderMaquetteFunction) {
                projections.push(exports.dom.insertBefore(beforeNode, renderMaquetteFunction(), projectionOptions));
                renderFunctions.push(renderMaquetteFunction);
            },
            merge: function (domNode, renderMaquetteFunction) {
                projections.push(exports.dom.merge(domNode, renderMaquetteFunction(), projectionOptions));
                renderFunctions.push(renderMaquetteFunction);
            },
            replace: function (domNode, renderMaquetteFunction) {
                projections.push(exports.dom.replace(domNode, renderMaquetteFunction(), projectionOptions));
                renderFunctions.push(renderMaquetteFunction);
            },
            detach: function (renderMaquetteFunction) {
                for (var i = 0; i < renderFunctions.length; i++) {
                    if (renderFunctions[i] === renderMaquetteFunction) {
                        renderFunctions.splice(i, 1);
                        return projections.splice(i, 1)[0];
                    }
                }
                throw new Error('renderMaquetteFunction was not found');
            }
        };
        return projector;
    };
}));
//# sourceMappingURL=maquette.js.map


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function __export(m) {
    for (var p in m) {
        if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(15));
__export(__webpack_require__(17));
__export(__webpack_require__(18));
__export(__webpack_require__(19));
__export(__webpack_require__(20));
__export(__webpack_require__(21));
__export(__webpack_require__(22));
__export(__webpack_require__(23));
__export(__webpack_require__(24));
__export(__webpack_require__(25));
__export(__webpack_require__(26));
__export(__webpack_require__(27));
__export(__webpack_require__(28));
__export(__webpack_require__(29));
__export(__webpack_require__(30));
__export(__webpack_require__(31));
__export(__webpack_require__(32));
__export(__webpack_require__(33));
__export(__webpack_require__(34));
__export(__webpack_require__(35));
__export(__webpack_require__(36));

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var maquette = __webpack_require__(1);
var h = maquette.h;
var CaliforniaGenerated_1 = __webpack_require__(2);
var PagePreview_1 = __webpack_require__(37);
var PropertyBar_1 = __webpack_require__(39);
var CaliforniaRouter_1 = __webpack_require__(41);
var ClientState_1 = __webpack_require__(4);
var CaliforniaClientPartialData_1 = __webpack_require__(42);
exports.DEFAULT_EXCEPTION = "unexpected error";
exports.UI_Z_INDEX = 11;
var RESIZE_HANDLER_DELAY_MS = 200;
function getArrayForEnum(targetEnum) {
    return Object.keys(targetEnum).map(function (key) {
        return targetEnum[key];
    }).filter(function (value) {
        return typeof value === "string";
    });
}
exports.getArrayForEnum = getArrayForEnum;
;
function parseIntFromAttribute(element, attributeName) {
    if (element === undefined) {
        console.log("cannot read attribute: element is null");
    }
    var attr = element.attributes.getNamedItem(attributeName);
    if (attr === null) {
        console.log("could not find attribute " + attributeName + " on target");
        console.log(element);
        return 0;
    } else {
        return parseInt(attr.value);
    }
}
exports.parseIntFromAttribute = parseIntFromAttribute;
;
function parseStringFromAttribute(element, attributeName) {
    if (element === undefined) {
        console.log("cannot read attribute: element is null");
    }
    var attr = element.attributes.getNamedItem(attributeName);
    if (attr === null) {
        console.log("could not find attribute " + attributeName + " on target");
        console.log(element);
        return "";
    } else {
        return attr.value;
    }
}
exports.parseStringFromAttribute = parseStringFromAttribute;
;
var CaliforniaApp = function () {
    function CaliforniaApp() {
        var _this = this;
        this.californiaMainDiv = document.getElementById("california-main");
        this.styleSheet = document.getElementById("california-styles").sheet;
        this.pagePreviewHolder = undefined;
        this._propertyBars = [];
        this._propertyBarVMs = [];
        this._propertyBarBoxTreeDomReferences = [];
        this._propertyBarBoxTreeScrollHandled = [];
        this.isAjaxRequestRunning = false;
        this.resizeRtime = new Date();
        this.resizeTimeout = false;
        this.navigationHeigthPx = 32;
        this.controlAreaWidthPx = 500;
        this._propertyBarCount = 4;
        this.clientData = {
            CurrentRevision: 0,
            StatusText: "",
            CaliforniaEvent: CaliforniaGenerated_1.CaliforniaEvent.ReadInitialClientData,
            CaliforniaProject: new CaliforniaGenerated_1.CaliforniaProject(),
            AllCssProperties: [],
            StyleAtomCssPropertyMapping: {},
            UrlToReadAndEdit: "",
            UrlToReadOnly: "",
            PartialUpdate: new CaliforniaClientPartialData_1.CaliforniaClientPartialData(),
            ThirdPartyFonts: []
        };
        this.resizeCheckHandler = function () {
            var curTime = Date.now();
            if (curTime - CaliforniaApp.CaliforniaAppInstance.resizeRtime.getMilliseconds() < RESIZE_HANDLER_DELAY_MS) {
                setTimeout(CaliforniaApp.CaliforniaAppInstance.resizeCheckHandler, RESIZE_HANDLER_DELAY_MS);
            } else {
                CaliforniaApp.CaliforniaAppInstance.resizeChangedHandler();
                CaliforniaApp.CaliforniaAppInstance.resizeTimeout = false;
            }
        };
        this.resizeChangedHandler = function () {
            CaliforniaApp.CaliforniaAppInstance.state.overrideResponsiveDeviceId = 0;
            CaliforniaApp.CaliforniaAppInstance.router.setupUiForDevice();
            CaliforniaApp.CaliforniaAppInstance.projector.scheduleRender();
        };
        this.renderCaliforniaApp = function () {
            var appStyles = {
                "width": "100%",
                "max-width": "100%",
                "height": "100%",
                "max-height": "100%",
                "display": "flex",
                "flex-flow": "row nowrap"
            };
            var renderedPropertyBars = [];
            var maxRenderedPropertyBarCount = _this.state.visiblePropertyBarMaxCount > _this._propertyBarCount ? _this._propertyBarCount : _this.state.visiblePropertyBarMaxCount;
            for (var i = 0; i < maxRenderedPropertyBarCount; i++) {
                renderedPropertyBars.push(_this._propertyBars[i].renderPropertyBar());
            }
            return h(
                "div",
                { styles: appStyles },
                _this.pagePreview.renderPreviewArea(),
                _this.state.isHideUserInterface || _this.state.editViewMode === ClientState_1.EditViewMode.PagePreviewOnly ? undefined : renderedPropertyBars,
                _this._propertyBars[0].renderPropertyBarPoppersRenderOnce()
            );
        };
        this.projector = maquette.createProjector();
        this.pagePreview = new PagePreview_1.PagePreview(this);
        this.pagePreviewVM = this.pagePreview.viewModel;
        for (var i = 0; i < this.propertyBarCount; i++) {
            var propertyBar = new PropertyBar_1.PropertyBar(this, i);
            this._propertyBars.push(propertyBar);
            this._propertyBarVMs.push(propertyBar.viewModel);
            this._propertyBarBoxTreeDomReferences.push(undefined);
            this._propertyBarBoxTreeScrollHandled.push(false);
        }
        this.controller = new CaliforniaGenerated_1.CaliforniaController(this);
        this.router = new CaliforniaRouter_1.CaliforniaRouter(this);
        this.state = new ClientState_1.ClientState(this);
        this.controller.InitialClientDataJson(new Date().toString()).done(function (data) {
            CaliforniaApp.CaliforniaAppInstance.router.updateData(data, true);
        }).fail(function () {
            console.log("could not get data");
        });
        document.addEventListener("DOMContentLoaded", function () {
            CaliforniaApp.CaliforniaAppInstance.projector.append(CaliforniaApp.CaliforniaAppInstance.californiaMainDiv, CaliforniaApp.CaliforniaAppInstance.renderCaliforniaApp);
        });
        window.addEventListener("resize", function () {
            CaliforniaApp.CaliforniaAppInstance.resizeRtime = new Date();
            if (CaliforniaApp.CaliforniaAppInstance.resizeTimeout === false) {
                CaliforniaApp.CaliforniaAppInstance.resizeTimeout = true;
                setTimeout(CaliforniaApp.CaliforniaAppInstance.resizeCheckHandler, RESIZE_HANDLER_DELAY_MS);
            }
        });
    }
    ;
    Object.defineProperty(CaliforniaApp.prototype, "propertyBarCount", {
        get: function get() {
            return this._propertyBarCount;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(CaliforniaApp.prototype, "propertyBars", {
        get: function get() {
            return this._propertyBars;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(CaliforniaApp.prototype, "propertyBarVMs", {
        get: function get() {
            return this._propertyBarVMs;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(CaliforniaApp.prototype, "propertyBarBoxTreeDomReferences", {
        get: function get() {
            return this._propertyBarBoxTreeDomReferences;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(CaliforniaApp.prototype, "propertyBarBoxTreeScrollHandled", {
        get: function get() {
            return this._propertyBarBoxTreeScrollHandled;
        },
        enumerable: true,
        configurable: true
    });
    ;
    return CaliforniaApp;
}();
exports.CaliforniaApp = CaliforniaApp;
;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var CaliforniaGenerated_1 = __webpack_require__(2);
var PropertyBarVM_1 = __webpack_require__(5);
var currentApp;
var currentClientState;
exports.STATIC_MARGIN_PX = 25;
var SelectionMode;
(function (SelectionMode) {
    SelectionMode[SelectionMode["Styles"] = 0] = "Styles";
    SelectionMode[SelectionMode["Content"] = 1] = "Content";
})(SelectionMode = exports.SelectionMode || (exports.SelectionMode = {}));
;
var ReadyState;
(function (ReadyState) {
    ReadyState[ReadyState["Ok"] = 0] = "Ok";
    ReadyState[ReadyState["Pending"] = 1] = "Pending";
})(ReadyState = exports.ReadyState || (exports.ReadyState = {}));
;
var EditViewMode;
(function (EditViewMode) {
    EditViewMode[EditViewMode["Default"] = 0] = "Default";
    EditViewMode[EditViewMode["SidebarOnly"] = 1] = "SidebarOnly";
    EditViewMode[EditViewMode["PagePreviewOnly"] = 2] = "PagePreviewOnly";
})(EditViewMode = exports.EditViewMode || (exports.EditViewMode = {}));
;
var ClientState = function () {
    function ClientState(californiaAppArg) {
        this.isDataLoaded = false;
        this.isHideUserInterface = false;
        this.editViewMode = EditViewMode.Default;
        this.currentSelectionMode = SelectionMode.Content;
        this.currentReadyState = ReadyState.Ok;
        this.isJaxOn = false;
        this.lowestWidthThresholdResponsiveDeviceId = 0;
        this.highestWidthThresholdResponsiveDeviceId = 0;
        this.specialStyleHolder = undefined;
        this.currentResponsiveDeviceId = 0;
        this.noneResponsiveDeviceId = 0;
        this.defaultSymmetricPagePreviewHolderMarginPx = exports.STATIC_MARGIN_PX;
        this.overrideResponsiveDeviceId = 0;
        this.isEnoughAvailableSpacePagePreview = true;
        this.targetPagePreviewHolderMarginPx = exports.STATIC_MARGIN_PX;
        this.visiblePropertyBarMaxCount = 2;
        this.popupTargetPropertyBarIndex = 0;
        this.currentTransactionMode = PropertyBarVM_1.TransactionMode.MoveLayoutMoleculeIntoLayoutMolecule;
        this.highlightedLayoutBaseId = 0;
        this.isSelectAllTextArea = false;
        this.lastCommand = CaliforniaGenerated_1.CaliforniaEvent.ReadInitialClientData;
        this.lastCaliforniaEventData = [];
        this.selectedLayoutBaseId = 0;
        this.preselectedLayoutBaseId = 0;
        this.preselectedCaliforniaViewId = 0;
        this.isDrawHelperLines = false;
        this.hoveredBoxTreeLayoutBaseId = 0;
        this.hoveredPagePreviewLayoutBaseId = 0;
        this.hoveredInsertLayoutBaseId = 0;
        this.backupSortOrder = undefined;
        this.backupOwnerRowId = undefined;
        this.backupPlacedBoxInBoxId = undefined;
        this.newBoxStyleMoleculeId = 0;
        currentClientState = this;
        currentApp = californiaAppArg;
    }
    ;
    return ClientState;
}();
exports.ClientState = ClientState;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var maquette = __webpack_require__(1);
var h = maquette.h;
var CaliforniaGenerated_1 = __webpack_require__(2);
var PropertyBarMode;
(function (PropertyBarMode) {
    PropertyBarMode[PropertyBarMode["None"] = 0] = "None";
    PropertyBarMode[PropertyBarMode["CaliforniaView"] = 1] = "CaliforniaView";
    PropertyBarMode[PropertyBarMode["LayoutMolecules"] = 2] = "LayoutMolecules";
    PropertyBarMode[PropertyBarMode["LayoutAtoms"] = 3] = "LayoutAtoms";
    PropertyBarMode[PropertyBarMode["AllStyleQuantums"] = 4] = "AllStyleQuantums";
    PropertyBarMode[PropertyBarMode["AllStyleAtoms"] = 5] = "AllStyleAtoms";
    PropertyBarMode[PropertyBarMode["AllStyleMolecules"] = 6] = "AllStyleMolecules";
    PropertyBarMode[PropertyBarMode["StyleMolecule"] = 7] = "StyleMolecule";
    PropertyBarMode[PropertyBarMode["AllLayoutMolecules"] = 8] = "AllLayoutMolecules";
    PropertyBarMode[PropertyBarMode["LayoutBase"] = 9] = "LayoutBase";
    PropertyBarMode[PropertyBarMode["AllCaliforniaViews"] = 10] = "AllCaliforniaViews";
})(PropertyBarMode = exports.PropertyBarMode || (exports.PropertyBarMode = {}));
;
var PopupSecondaryMode;
(function (PopupSecondaryMode) {
    PopupSecondaryMode[PopupSecondaryMode["None"] = 0] = "None";
    PopupSecondaryMode[PopupSecondaryMode["SelectBoxIntoBox"] = 1] = "SelectBoxIntoBox";
    PopupSecondaryMode[PopupSecondaryMode["SelectBoxIntoBoxAtomInPlace"] = 2] = "SelectBoxIntoBoxAtomInPlace";
})(PopupSecondaryMode = exports.PopupSecondaryMode || (exports.PopupSecondaryMode = {}));
;
var PopupMode;
(function (PopupMode) {
    PopupMode[PopupMode["None"] = 0] = "None";
    PopupMode[PopupMode["AddCssProperty"] = 1] = "AddCssProperty";
    PopupMode[PopupMode["AllCssProperties"] = 2] = "AllCssProperties";
    PopupMode[PopupMode["UpdateCssValue"] = 3] = "UpdateCssValue";
    PopupMode[PopupMode["MatchingQuantums"] = 4] = "MatchingQuantums";
    PopupMode[PopupMode["UpdateCssQuantum"] = 5] = "UpdateCssQuantum";
    PopupMode[PopupMode["AllCssPropertiesForQuantum"] = 6] = "AllCssPropertiesForQuantum";
    PopupMode[PopupMode["InsertLayoutRowIntoView"] = 7] = "InsertLayoutRowIntoView";
    PopupMode[PopupMode["InsertLayoutAtomIntoBox"] = 8] = "InsertLayoutAtomIntoBox";
    PopupMode[PopupMode["SelectBox"] = 9] = "SelectBox";
    PopupMode[PopupMode["MoveStyleAtom"] = 10] = "MoveStyleAtom";
    PopupMode[PopupMode["ShareCaliforniaProject"] = 11] = "ShareCaliforniaProject";
    PopupMode[PopupMode["SelectInteractionTarget"] = 12] = "SelectInteractionTarget";
    PopupMode[PopupMode["SelectInteractionTargetLayoutFilter"] = 13] = "SelectInteractionTargetLayoutFilter";
    PopupMode[PopupMode["CaliforniaViewSelection"] = 14] = "CaliforniaViewSelection";
    PopupMode[PopupMode["EditUserDefinedCss"] = 15] = "EditUserDefinedCss";
    PopupMode[PopupMode["SuggestedCssValues"] = 16] = "SuggestedCssValues";
})(PopupMode = exports.PopupMode || (exports.PopupMode = {}));
;
var TransactionMode;
(function (TransactionMode) {
    TransactionMode[TransactionMode["MoveLayoutMoleculeIntoLayoutMolecule"] = 0] = "MoveLayoutMoleculeIntoLayoutMolecule";
    TransactionMode[TransactionMode["MoveLayoutMoleculeBeforeLayoutMolecule"] = 1] = "MoveLayoutMoleculeBeforeLayoutMolecule";
    TransactionMode[TransactionMode["SyncLayoutStylesImitating"] = 2] = "SyncLayoutStylesImitating";
})(TransactionMode = exports.TransactionMode || (exports.TransactionMode = {}));
var currentApp;
var PropertyBarVM = function () {
    function PropertyBarVM(propertyBarArg, targetIndex, californiaAppArg) {
        var _this = this;
        this.propertyBarVMIndex = -1;
        this.currentPropertyBarMode = PropertyBarMode.None;
        this.currentPopupMode = PopupMode.None;
        this.currentSecondaryPopupMode = PopupSecondaryMode.None;
        this.tempQuantumName = "Quantum";
        this.tempCssPropertyName = "";
        this.tempCssValue = "";
        this.lastUsedTempCssValue = "";
        this.tempPseudoSelector = "";
        this.tempCaliforniaViewName = "";
        this.tempCssValueForInteraction = "";
        this.selectedStyleAtomId = 0;
        this.selectedStyleValueId = 0;
        this.selectedStyleQuantumId = 0;
        this.selectedStyleMoleculeId = 0;
        this._selectedCaliforniaViewId = 0;
        this.selectedResponsiveDeviceId = 0;
        this.selectedStateModifier = "";
        this.selectedStyleAtomType = CaliforniaGenerated_1.StyleAtomType.Generic;
        this.selectedLayoutBaseIdForFilter = 0;
        this.selectedLayoutStyleInteraction = 0;
        this.tempOriginalContent = "";
        this.tempContent = "";
        this.editedLayoutAtomId = 0;
        this.tempUserDefinedCss = "";
        this._deepestLevelActiveView = 0;
        this.selectedStyleAtomIdForPopup = 0;
        this.isSyncedWithBoxTreeToTheLeft = false;
        this.isSyncedWithPagePreview = false;
        this.setSelectedResponsiveDeviceId = function (responsiveDeviceId, isForce) {
            if (isForce || _this.currentVM.selectedResponsiveDeviceId == 0) {
                _this.currentVM.selectedResponsiveDeviceId = responsiveDeviceId;
            }
        };
        this.setSelectedCaliforniaView = function (californiaView, isForce) {
            if (isForce || _this.currentVM.selectedCaliforniaViewId == 0) {
                _this.currentVM._selectedCaliforniaViewId = californiaView.CaliforniaViewId;
                _this.currentVM._deepestLevelActiveView = californiaView.DeepestLevel;
                _this.currentVM.boxTreeProjector.map([californiaView]);
            } else {
                _this.currentVM.boxTreeProjector.map([]);
                _this.currentVM._deepestLevelActiveView = 0;
                _this.currentVM._selectedCaliforniaViewId = 0;
            }
        };
        this.updateData = function (styleQuantums, styleAtoms, styleMolecules, layoutMolecules, allCaliforniaViews, instanceableAtomsView, instanceableRowsView) {
            _this.currentVM.styleQuantumProjector.map(styleQuantums);
            _this.currentVM.styleAtomProjector.map(styleAtoms);
            _this.currentVM.styleMoleculeProjector.map(styleMolecules);
            _this.currentVM.allLayoutMoleculesProjector.map(layoutMolecules);
            _this.currentVM.allCaliforniaViewsProjector.map(allCaliforniaViews);
            _this.currentVM.instanceableAtomProjector.map(instanceableAtomsView.PlacedLayoutRows);
            _this.currentVM.instanceableMoleculeProjector.map(instanceableRowsView.PlacedLayoutRows);
        };
        currentApp = californiaAppArg;
        this.propertyBarVMIndex = targetIndex;
        this.styleQuantumProjector = propertyBarArg.renderStyleQuantumArray(propertyBarArg);
        this.styleAtomProjector = propertyBarArg.renderStyleAtomArray(propertyBarArg);
        this.styleMoleculeProjector = propertyBarArg.renderStyleMoleculeArray(propertyBarArg);
        this.instanceableAtomProjector = propertyBarArg.renderLayoutRowArray(propertyBarArg);
        this.instanceableMoleculeProjector = propertyBarArg.renderLayoutRowArray(propertyBarArg);
        this.allLayoutMoleculesProjector = propertyBarArg.renderLayoutMoleculeArray(propertyBarArg);
        this.allCaliforniaViewsProjector = propertyBarArg.renderCaliforniaViewArray(propertyBarArg);
        this.boxTreeProjector = propertyBarArg.renderBoxTreeForCaliforniaView(propertyBarArg);
    }
    ;
    Object.defineProperty(PropertyBarVM.prototype, "currentVM", {
        get: function get() {
            return currentApp.propertyBarVMs[this.propertyBarVMIndex];
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PropertyBarVM.prototype, "selectedCaliforniaViewId", {
        get: function get() {
            return this._selectedCaliforniaViewId;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PropertyBarVM.prototype, "deepestLevelActiveView", {
        get: function get() {
            return this._deepestLevelActiveView;
        },
        enumerable: true,
        configurable: true
    });
    ;
    PropertyBarVM.prototype.clearSelectedCaliforniaView = function (isClearWhenNonEqual, clearWhenEqualsCaliforniaViewId) {
        if (isClearWhenNonEqual === true || this.currentVM.selectedCaliforniaViewId == clearWhenEqualsCaliforniaViewId) {
            this.currentVM._selectedCaliforniaViewId = 0;
            this.currentVM._deepestLevelActiveView = 0;
            this.currentVM.boxTreeProjector.map([]);
        }
    };
    ;
    return PropertyBarVM;
}();
exports.PropertyBarVM = PropertyBarVM;

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(global) {/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.14.3
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';

var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
var timeoutDuration = 0;
for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
    timeoutDuration = 1;
    break;
  }
}

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var css = getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null;

  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent;
  // Skip hidden elements which don't have an offsetParent
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }

  // .offsetParent will return the closest TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
}

function getWindowSizes() {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
  var width = sizes.width || element.clientWidth || result.right - result.left;
  var height = sizes.height || element.clientHeight || result.bottom - result.top;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
  if (fixedPosition && parent.nodeName === 'HTML') {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop, 10);
    var marginLeft = parseFloat(styles.marginLeft, 10);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  return isFixed(getParentNode(element));
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }
  return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // NOTE: 1 DOM access here

  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  boundaries.left += padding;
  boundaries.top += padding;
  boundaries.right -= padding;
  boundaries.bottom -= padding;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, reference);
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var styles = getComputedStyle(element);
  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  data.positionFixed = this.options.positionFixed;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroy the popper
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicity asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger onUpdate callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  // Avoid blurry text by using full pixel integers.
  // For pixel-perfect positioning, top/bottom prefers rounded
  // values, while left/right prefers floored values.
  var offsets = {
    left: Math.floor(popper.left),
    top: Math.round(popper.top),
    bottom: Math.round(popper.bottom),
    right: Math.floor(popper.right)
  };

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    top = -offsetParentRect.height + offsets.bottom;
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    left = -offsetParentRect.width + offsets.right;
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjuction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-right` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself
  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification
  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];

  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

  // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;

  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unitless, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the height.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * An scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper this makes sure the popper has always a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier, can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near eachothers
   * without leaving any gap between the two. Expecially useful when the arrow is
   * enabled and you want to assure it to point to its reference element.
   * It cares only about the first axis, you can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjuction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations).
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position,
     * the popper will never be placed outside of the defined boundaries
     * (except if keepTogether is enabled)
     */
    boundariesElement: 'viewport'
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define you own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the informations used by Popper.js
 * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overriden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass as 3rd argument an object with the same
 * structure of this object, example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated, this callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Create a new Popper.js instance
   * @class Popper
   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper.
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedule an update, it will run on the next UI update available
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

/* harmony default export */ __webpack_exports__["default"] = (Popper);
//# sourceMappingURL=popper.js.map

/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(12)))

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var ContentAtomType;
(function (ContentAtomType) {
    ContentAtomType[ContentAtomType["Text"] = 0] = "Text";
    ContentAtomType[ContentAtomType["Html"] = 1] = "Html";
    ContentAtomType[ContentAtomType["Picture"] = 2] = "Picture";
    ContentAtomType[ContentAtomType["Link"] = 3] = "Link";
    ContentAtomType[ContentAtomType["NavLink"] = 4] = "NavLink";
})(ContentAtomType = exports.ContentAtomType || (exports.ContentAtomType = {}));

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(0);
__webpack_require__(9);
__webpack_require__(10);
__webpack_require__(11);
__webpack_require__(6);
__webpack_require__(13);
module.exports = __webpack_require__(14);


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery Validation Plugin v1.17.0
 *
 * https://jqueryvalidation.org/
 *
 * Copyright (c) 2017 Jörn Zaefferer
 * Released under the MIT license
 */
(function( factory ) {
	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof module === "object" && module.exports) {
		module.exports = factory( require( "jquery" ) );
	} else {
		factory( jQuery );
	}
}(function( $ ) {

$.extend( $.fn, {

	// https://jqueryvalidation.org/validate/
	validate: function( options ) {

		// If nothing is selected, return nothing; can't chain anyway
		if ( !this.length ) {
			if ( options && options.debug && window.console ) {
				console.warn( "Nothing selected, can't validate, returning nothing." );
			}
			return;
		}

		// Check if a validator for this form was already created
		var validator = $.data( this[ 0 ], "validator" );
		if ( validator ) {
			return validator;
		}

		// Add novalidate tag if HTML5.
		this.attr( "novalidate", "novalidate" );

		validator = new $.validator( options, this[ 0 ] );
		$.data( this[ 0 ], "validator", validator );

		if ( validator.settings.onsubmit ) {

			this.on( "click.validate", ":submit", function( event ) {

				// Track the used submit button to properly handle scripted
				// submits later.
				validator.submitButton = event.currentTarget;

				// Allow suppressing validation by adding a cancel class to the submit button
				if ( $( this ).hasClass( "cancel" ) ) {
					validator.cancelSubmit = true;
				}

				// Allow suppressing validation by adding the html5 formnovalidate attribute to the submit button
				if ( $( this ).attr( "formnovalidate" ) !== undefined ) {
					validator.cancelSubmit = true;
				}
			} );

			// Validate the form on submit
			this.on( "submit.validate", function( event ) {
				if ( validator.settings.debug ) {

					// Prevent form submit to be able to see console output
					event.preventDefault();
				}
				function handle() {
					var hidden, result;

					// Insert a hidden input as a replacement for the missing submit button
					// The hidden input is inserted in two cases:
					//   - A user defined a `submitHandler`
					//   - There was a pending request due to `remote` method and `stopRequest()`
					//     was called to submit the form in case it's valid
					if ( validator.submitButton && ( validator.settings.submitHandler || validator.formSubmitted ) ) {
						hidden = $( "<input type='hidden'/>" )
							.attr( "name", validator.submitButton.name )
							.val( $( validator.submitButton ).val() )
							.appendTo( validator.currentForm );
					}

					if ( validator.settings.submitHandler ) {
						result = validator.settings.submitHandler.call( validator, validator.currentForm, event );
						if ( hidden ) {

							// And clean up afterwards; thanks to no-block-scope, hidden can be referenced
							hidden.remove();
						}
						if ( result !== undefined ) {
							return result;
						}
						return false;
					}
					return true;
				}

				// Prevent submit for invalid forms or custom submit handlers
				if ( validator.cancelSubmit ) {
					validator.cancelSubmit = false;
					return handle();
				}
				if ( validator.form() ) {
					if ( validator.pendingRequest ) {
						validator.formSubmitted = true;
						return false;
					}
					return handle();
				} else {
					validator.focusInvalid();
					return false;
				}
			} );
		}

		return validator;
	},

	// https://jqueryvalidation.org/valid/
	valid: function() {
		var valid, validator, errorList;

		if ( $( this[ 0 ] ).is( "form" ) ) {
			valid = this.validate().form();
		} else {
			errorList = [];
			valid = true;
			validator = $( this[ 0 ].form ).validate();
			this.each( function() {
				valid = validator.element( this ) && valid;
				if ( !valid ) {
					errorList = errorList.concat( validator.errorList );
				}
			} );
			validator.errorList = errorList;
		}
		return valid;
	},

	// https://jqueryvalidation.org/rules/
	rules: function( command, argument ) {
		var element = this[ 0 ],
			settings, staticRules, existingRules, data, param, filtered;

		// If nothing is selected, return empty object; can't chain anyway
		if ( element == null ) {
			return;
		}

		if ( !element.form && element.hasAttribute( "contenteditable" ) ) {
			element.form = this.closest( "form" )[ 0 ];
			element.name = this.attr( "name" );
		}

		if ( element.form == null ) {
			return;
		}

		if ( command ) {
			settings = $.data( element.form, "validator" ).settings;
			staticRules = settings.rules;
			existingRules = $.validator.staticRules( element );
			switch ( command ) {
			case "add":
				$.extend( existingRules, $.validator.normalizeRule( argument ) );

				// Remove messages from rules, but allow them to be set separately
				delete existingRules.messages;
				staticRules[ element.name ] = existingRules;
				if ( argument.messages ) {
					settings.messages[ element.name ] = $.extend( settings.messages[ element.name ], argument.messages );
				}
				break;
			case "remove":
				if ( !argument ) {
					delete staticRules[ element.name ];
					return existingRules;
				}
				filtered = {};
				$.each( argument.split( /\s/ ), function( index, method ) {
					filtered[ method ] = existingRules[ method ];
					delete existingRules[ method ];
				} );
				return filtered;
			}
		}

		data = $.validator.normalizeRules(
		$.extend(
			{},
			$.validator.classRules( element ),
			$.validator.attributeRules( element ),
			$.validator.dataRules( element ),
			$.validator.staticRules( element )
		), element );

		// Make sure required is at front
		if ( data.required ) {
			param = data.required;
			delete data.required;
			data = $.extend( { required: param }, data );
		}

		// Make sure remote is at back
		if ( data.remote ) {
			param = data.remote;
			delete data.remote;
			data = $.extend( data, { remote: param } );
		}

		return data;
	}
} );

// Custom selectors
$.extend( $.expr.pseudos || $.expr[ ":" ], {		// '|| $.expr[ ":" ]' here enables backwards compatibility to jQuery 1.7. Can be removed when dropping jQ 1.7.x support

	// https://jqueryvalidation.org/blank-selector/
	blank: function( a ) {
		return !$.trim( "" + $( a ).val() );
	},

	// https://jqueryvalidation.org/filled-selector/
	filled: function( a ) {
		var val = $( a ).val();
		return val !== null && !!$.trim( "" + val );
	},

	// https://jqueryvalidation.org/unchecked-selector/
	unchecked: function( a ) {
		return !$( a ).prop( "checked" );
	}
} );

// Constructor for validator
$.validator = function( options, form ) {
	this.settings = $.extend( true, {}, $.validator.defaults, options );
	this.currentForm = form;
	this.init();
};

// https://jqueryvalidation.org/jQuery.validator.format/
$.validator.format = function( source, params ) {
	if ( arguments.length === 1 ) {
		return function() {
			var args = $.makeArray( arguments );
			args.unshift( source );
			return $.validator.format.apply( this, args );
		};
	}
	if ( params === undefined ) {
		return source;
	}
	if ( arguments.length > 2 && params.constructor !== Array  ) {
		params = $.makeArray( arguments ).slice( 1 );
	}
	if ( params.constructor !== Array ) {
		params = [ params ];
	}
	$.each( params, function( i, n ) {
		source = source.replace( new RegExp( "\\{" + i + "\\}", "g" ), function() {
			return n;
		} );
	} );
	return source;
};

$.extend( $.validator, {

	defaults: {
		messages: {},
		groups: {},
		rules: {},
		errorClass: "error",
		pendingClass: "pending",
		validClass: "valid",
		errorElement: "label",
		focusCleanup: false,
		focusInvalid: true,
		errorContainer: $( [] ),
		errorLabelContainer: $( [] ),
		onsubmit: true,
		ignore: ":hidden",
		ignoreTitle: false,
		onfocusin: function( element ) {
			this.lastActive = element;

			// Hide error label and remove error class on focus if enabled
			if ( this.settings.focusCleanup ) {
				if ( this.settings.unhighlight ) {
					this.settings.unhighlight.call( this, element, this.settings.errorClass, this.settings.validClass );
				}
				this.hideThese( this.errorsFor( element ) );
			}
		},
		onfocusout: function( element ) {
			if ( !this.checkable( element ) && ( element.name in this.submitted || !this.optional( element ) ) ) {
				this.element( element );
			}
		},
		onkeyup: function( element, event ) {

			// Avoid revalidate the field when pressing one of the following keys
			// Shift       => 16
			// Ctrl        => 17
			// Alt         => 18
			// Caps lock   => 20
			// End         => 35
			// Home        => 36
			// Left arrow  => 37
			// Up arrow    => 38
			// Right arrow => 39
			// Down arrow  => 40
			// Insert      => 45
			// Num lock    => 144
			// AltGr key   => 225
			var excludedKeys = [
				16, 17, 18, 20, 35, 36, 37,
				38, 39, 40, 45, 144, 225
			];

			if ( event.which === 9 && this.elementValue( element ) === "" || $.inArray( event.keyCode, excludedKeys ) !== -1 ) {
				return;
			} else if ( element.name in this.submitted || element.name in this.invalid ) {
				this.element( element );
			}
		},
		onclick: function( element ) {

			// Click on selects, radiobuttons and checkboxes
			if ( element.name in this.submitted ) {
				this.element( element );

			// Or option elements, check parent select in that case
			} else if ( element.parentNode.name in this.submitted ) {
				this.element( element.parentNode );
			}
		},
		highlight: function( element, errorClass, validClass ) {
			if ( element.type === "radio" ) {
				this.findByName( element.name ).addClass( errorClass ).removeClass( validClass );
			} else {
				$( element ).addClass( errorClass ).removeClass( validClass );
			}
		},
		unhighlight: function( element, errorClass, validClass ) {
			if ( element.type === "radio" ) {
				this.findByName( element.name ).removeClass( errorClass ).addClass( validClass );
			} else {
				$( element ).removeClass( errorClass ).addClass( validClass );
			}
		}
	},

	// https://jqueryvalidation.org/jQuery.validator.setDefaults/
	setDefaults: function( settings ) {
		$.extend( $.validator.defaults, settings );
	},

	messages: {
		required: "This field is required.",
		remote: "Please fix this field.",
		email: "Please enter a valid email address.",
		url: "Please enter a valid URL.",
		date: "Please enter a valid date.",
		dateISO: "Please enter a valid date (ISO).",
		number: "Please enter a valid number.",
		digits: "Please enter only digits.",
		equalTo: "Please enter the same value again.",
		maxlength: $.validator.format( "Please enter no more than {0} characters." ),
		minlength: $.validator.format( "Please enter at least {0} characters." ),
		rangelength: $.validator.format( "Please enter a value between {0} and {1} characters long." ),
		range: $.validator.format( "Please enter a value between {0} and {1}." ),
		max: $.validator.format( "Please enter a value less than or equal to {0}." ),
		min: $.validator.format( "Please enter a value greater than or equal to {0}." ),
		step: $.validator.format( "Please enter a multiple of {0}." )
	},

	autoCreateRanges: false,

	prototype: {

		init: function() {
			this.labelContainer = $( this.settings.errorLabelContainer );
			this.errorContext = this.labelContainer.length && this.labelContainer || $( this.currentForm );
			this.containers = $( this.settings.errorContainer ).add( this.settings.errorLabelContainer );
			this.submitted = {};
			this.valueCache = {};
			this.pendingRequest = 0;
			this.pending = {};
			this.invalid = {};
			this.reset();

			var groups = ( this.groups = {} ),
				rules;
			$.each( this.settings.groups, function( key, value ) {
				if ( typeof value === "string" ) {
					value = value.split( /\s/ );
				}
				$.each( value, function( index, name ) {
					groups[ name ] = key;
				} );
			} );
			rules = this.settings.rules;
			$.each( rules, function( key, value ) {
				rules[ key ] = $.validator.normalizeRule( value );
			} );

			function delegate( event ) {

				// Set form expando on contenteditable
				if ( !this.form && this.hasAttribute( "contenteditable" ) ) {
					this.form = $( this ).closest( "form" )[ 0 ];
					this.name = $( this ).attr( "name" );
				}

				var validator = $.data( this.form, "validator" ),
					eventType = "on" + event.type.replace( /^validate/, "" ),
					settings = validator.settings;
				if ( settings[ eventType ] && !$( this ).is( settings.ignore ) ) {
					settings[ eventType ].call( validator, this, event );
				}
			}

			$( this.currentForm )
				.on( "focusin.validate focusout.validate keyup.validate",
					":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], " +
					"[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], " +
					"[type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], " +
					"[type='radio'], [type='checkbox'], [contenteditable], [type='button']", delegate )

				// Support: Chrome, oldIE
				// "select" is provided as event.target when clicking a option
				.on( "click.validate", "select, option, [type='radio'], [type='checkbox']", delegate );

			if ( this.settings.invalidHandler ) {
				$( this.currentForm ).on( "invalid-form.validate", this.settings.invalidHandler );
			}
		},

		// https://jqueryvalidation.org/Validator.form/
		form: function() {
			this.checkForm();
			$.extend( this.submitted, this.errorMap );
			this.invalid = $.extend( {}, this.errorMap );
			if ( !this.valid() ) {
				$( this.currentForm ).triggerHandler( "invalid-form", [ this ] );
			}
			this.showErrors();
			return this.valid();
		},

		checkForm: function() {
			this.prepareForm();
			for ( var i = 0, elements = ( this.currentElements = this.elements() ); elements[ i ]; i++ ) {
				this.check( elements[ i ] );
			}
			return this.valid();
		},

		// https://jqueryvalidation.org/Validator.element/
		element: function( element ) {
			var cleanElement = this.clean( element ),
				checkElement = this.validationTargetFor( cleanElement ),
				v = this,
				result = true,
				rs, group;

			if ( checkElement === undefined ) {
				delete this.invalid[ cleanElement.name ];
			} else {
				this.prepareElement( checkElement );
				this.currentElements = $( checkElement );

				// If this element is grouped, then validate all group elements already
				// containing a value
				group = this.groups[ checkElement.name ];
				if ( group ) {
					$.each( this.groups, function( name, testgroup ) {
						if ( testgroup === group && name !== checkElement.name ) {
							cleanElement = v.validationTargetFor( v.clean( v.findByName( name ) ) );
							if ( cleanElement && cleanElement.name in v.invalid ) {
								v.currentElements.push( cleanElement );
								result = v.check( cleanElement ) && result;
							}
						}
					} );
				}

				rs = this.check( checkElement ) !== false;
				result = result && rs;
				if ( rs ) {
					this.invalid[ checkElement.name ] = false;
				} else {
					this.invalid[ checkElement.name ] = true;
				}

				if ( !this.numberOfInvalids() ) {

					// Hide error containers on last error
					this.toHide = this.toHide.add( this.containers );
				}
				this.showErrors();

				// Add aria-invalid status for screen readers
				$( element ).attr( "aria-invalid", !rs );
			}

			return result;
		},

		// https://jqueryvalidation.org/Validator.showErrors/
		showErrors: function( errors ) {
			if ( errors ) {
				var validator = this;

				// Add items to error list and map
				$.extend( this.errorMap, errors );
				this.errorList = $.map( this.errorMap, function( message, name ) {
					return {
						message: message,
						element: validator.findByName( name )[ 0 ]
					};
				} );

				// Remove items from success list
				this.successList = $.grep( this.successList, function( element ) {
					return !( element.name in errors );
				} );
			}
			if ( this.settings.showErrors ) {
				this.settings.showErrors.call( this, this.errorMap, this.errorList );
			} else {
				this.defaultShowErrors();
			}
		},

		// https://jqueryvalidation.org/Validator.resetForm/
		resetForm: function() {
			if ( $.fn.resetForm ) {
				$( this.currentForm ).resetForm();
			}
			this.invalid = {};
			this.submitted = {};
			this.prepareForm();
			this.hideErrors();
			var elements = this.elements()
				.removeData( "previousValue" )
				.removeAttr( "aria-invalid" );

			this.resetElements( elements );
		},

		resetElements: function( elements ) {
			var i;

			if ( this.settings.unhighlight ) {
				for ( i = 0; elements[ i ]; i++ ) {
					this.settings.unhighlight.call( this, elements[ i ],
						this.settings.errorClass, "" );
					this.findByName( elements[ i ].name ).removeClass( this.settings.validClass );
				}
			} else {
				elements
					.removeClass( this.settings.errorClass )
					.removeClass( this.settings.validClass );
			}
		},

		numberOfInvalids: function() {
			return this.objectLength( this.invalid );
		},

		objectLength: function( obj ) {
			/* jshint unused: false */
			var count = 0,
				i;
			for ( i in obj ) {

				// This check allows counting elements with empty error
				// message as invalid elements
				if ( obj[ i ] !== undefined && obj[ i ] !== null && obj[ i ] !== false ) {
					count++;
				}
			}
			return count;
		},

		hideErrors: function() {
			this.hideThese( this.toHide );
		},

		hideThese: function( errors ) {
			errors.not( this.containers ).text( "" );
			this.addWrapper( errors ).hide();
		},

		valid: function() {
			return this.size() === 0;
		},

		size: function() {
			return this.errorList.length;
		},

		focusInvalid: function() {
			if ( this.settings.focusInvalid ) {
				try {
					$( this.findLastActive() || this.errorList.length && this.errorList[ 0 ].element || [] )
					.filter( ":visible" )
					.focus()

					// Manually trigger focusin event; without it, focusin handler isn't called, findLastActive won't have anything to find
					.trigger( "focusin" );
				} catch ( e ) {

					// Ignore IE throwing errors when focusing hidden elements
				}
			}
		},

		findLastActive: function() {
			var lastActive = this.lastActive;
			return lastActive && $.grep( this.errorList, function( n ) {
				return n.element.name === lastActive.name;
			} ).length === 1 && lastActive;
		},

		elements: function() {
			var validator = this,
				rulesCache = {};

			// Select all valid inputs inside the form (no submit or reset buttons)
			return $( this.currentForm )
			.find( "input, select, textarea, [contenteditable]" )
			.not( ":submit, :reset, :image, :disabled" )
			.not( this.settings.ignore )
			.filter( function() {
				var name = this.name || $( this ).attr( "name" ); // For contenteditable
				if ( !name && validator.settings.debug && window.console ) {
					console.error( "%o has no name assigned", this );
				}

				// Set form expando on contenteditable
				if ( this.hasAttribute( "contenteditable" ) ) {
					this.form = $( this ).closest( "form" )[ 0 ];
					this.name = name;
				}

				// Select only the first element for each name, and only those with rules specified
				if ( name in rulesCache || !validator.objectLength( $( this ).rules() ) ) {
					return false;
				}

				rulesCache[ name ] = true;
				return true;
			} );
		},

		clean: function( selector ) {
			return $( selector )[ 0 ];
		},

		errors: function() {
			var errorClass = this.settings.errorClass.split( " " ).join( "." );
			return $( this.settings.errorElement + "." + errorClass, this.errorContext );
		},

		resetInternals: function() {
			this.successList = [];
			this.errorList = [];
			this.errorMap = {};
			this.toShow = $( [] );
			this.toHide = $( [] );
		},

		reset: function() {
			this.resetInternals();
			this.currentElements = $( [] );
		},

		prepareForm: function() {
			this.reset();
			this.toHide = this.errors().add( this.containers );
		},

		prepareElement: function( element ) {
			this.reset();
			this.toHide = this.errorsFor( element );
		},

		elementValue: function( element ) {
			var $element = $( element ),
				type = element.type,
				val, idx;

			if ( type === "radio" || type === "checkbox" ) {
				return this.findByName( element.name ).filter( ":checked" ).val();
			} else if ( type === "number" && typeof element.validity !== "undefined" ) {
				return element.validity.badInput ? "NaN" : $element.val();
			}

			if ( element.hasAttribute( "contenteditable" ) ) {
				val = $element.text();
			} else {
				val = $element.val();
			}

			if ( type === "file" ) {

				// Modern browser (chrome & safari)
				if ( val.substr( 0, 12 ) === "C:\\fakepath\\" ) {
					return val.substr( 12 );
				}

				// Legacy browsers
				// Unix-based path
				idx = val.lastIndexOf( "/" );
				if ( idx >= 0 ) {
					return val.substr( idx + 1 );
				}

				// Windows-based path
				idx = val.lastIndexOf( "\\" );
				if ( idx >= 0 ) {
					return val.substr( idx + 1 );
				}

				// Just the file name
				return val;
			}

			if ( typeof val === "string" ) {
				return val.replace( /\r/g, "" );
			}
			return val;
		},

		check: function( element ) {
			element = this.validationTargetFor( this.clean( element ) );

			var rules = $( element ).rules(),
				rulesCount = $.map( rules, function( n, i ) {
					return i;
				} ).length,
				dependencyMismatch = false,
				val = this.elementValue( element ),
				result, method, rule, normalizer;

			// Prioritize the local normalizer defined for this element over the global one
			// if the former exists, otherwise user the global one in case it exists.
			if ( typeof rules.normalizer === "function" ) {
				normalizer = rules.normalizer;
			} else if (	typeof this.settings.normalizer === "function" ) {
				normalizer = this.settings.normalizer;
			}

			// If normalizer is defined, then call it to retreive the changed value instead
			// of using the real one.
			// Note that `this` in the normalizer is `element`.
			if ( normalizer ) {
				val = normalizer.call( element, val );

				if ( typeof val !== "string" ) {
					throw new TypeError( "The normalizer should return a string value." );
				}

				// Delete the normalizer from rules to avoid treating it as a pre-defined method.
				delete rules.normalizer;
			}

			for ( method in rules ) {
				rule = { method: method, parameters: rules[ method ] };
				try {
					result = $.validator.methods[ method ].call( this, val, element, rule.parameters );

					// If a method indicates that the field is optional and therefore valid,
					// don't mark it as valid when there are no other rules
					if ( result === "dependency-mismatch" && rulesCount === 1 ) {
						dependencyMismatch = true;
						continue;
					}
					dependencyMismatch = false;

					if ( result === "pending" ) {
						this.toHide = this.toHide.not( this.errorsFor( element ) );
						return;
					}

					if ( !result ) {
						this.formatAndAdd( element, rule );
						return false;
					}
				} catch ( e ) {
					if ( this.settings.debug && window.console ) {
						console.log( "Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.", e );
					}
					if ( e instanceof TypeError ) {
						e.message += ".  Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.";
					}

					throw e;
				}
			}
			if ( dependencyMismatch ) {
				return;
			}
			if ( this.objectLength( rules ) ) {
				this.successList.push( element );
			}
			return true;
		},

		// Return the custom message for the given element and validation method
		// specified in the element's HTML5 data attribute
		// return the generic message if present and no method specific message is present
		customDataMessage: function( element, method ) {
			return $( element ).data( "msg" + method.charAt( 0 ).toUpperCase() +
				method.substring( 1 ).toLowerCase() ) || $( element ).data( "msg" );
		},

		// Return the custom message for the given element name and validation method
		customMessage: function( name, method ) {
			var m = this.settings.messages[ name ];
			return m && ( m.constructor === String ? m : m[ method ] );
		},

		// Return the first defined argument, allowing empty strings
		findDefined: function() {
			for ( var i = 0; i < arguments.length; i++ ) {
				if ( arguments[ i ] !== undefined ) {
					return arguments[ i ];
				}
			}
			return undefined;
		},

		// The second parameter 'rule' used to be a string, and extended to an object literal
		// of the following form:
		// rule = {
		//     method: "method name",
		//     parameters: "the given method parameters"
		// }
		//
		// The old behavior still supported, kept to maintain backward compatibility with
		// old code, and will be removed in the next major release.
		defaultMessage: function( element, rule ) {
			if ( typeof rule === "string" ) {
				rule = { method: rule };
			}

			var message = this.findDefined(
					this.customMessage( element.name, rule.method ),
					this.customDataMessage( element, rule.method ),

					// 'title' is never undefined, so handle empty string as undefined
					!this.settings.ignoreTitle && element.title || undefined,
					$.validator.messages[ rule.method ],
					"<strong>Warning: No message defined for " + element.name + "</strong>"
				),
				theregex = /\$?\{(\d+)\}/g;
			if ( typeof message === "function" ) {
				message = message.call( this, rule.parameters, element );
			} else if ( theregex.test( message ) ) {
				message = $.validator.format( message.replace( theregex, "{$1}" ), rule.parameters );
			}

			return message;
		},

		formatAndAdd: function( element, rule ) {
			var message = this.defaultMessage( element, rule );

			this.errorList.push( {
				message: message,
				element: element,
				method: rule.method
			} );

			this.errorMap[ element.name ] = message;
			this.submitted[ element.name ] = message;
		},

		addWrapper: function( toToggle ) {
			if ( this.settings.wrapper ) {
				toToggle = toToggle.add( toToggle.parent( this.settings.wrapper ) );
			}
			return toToggle;
		},

		defaultShowErrors: function() {
			var i, elements, error;
			for ( i = 0; this.errorList[ i ]; i++ ) {
				error = this.errorList[ i ];
				if ( this.settings.highlight ) {
					this.settings.highlight.call( this, error.element, this.settings.errorClass, this.settings.validClass );
				}
				this.showLabel( error.element, error.message );
			}
			if ( this.errorList.length ) {
				this.toShow = this.toShow.add( this.containers );
			}
			if ( this.settings.success ) {
				for ( i = 0; this.successList[ i ]; i++ ) {
					this.showLabel( this.successList[ i ] );
				}
			}
			if ( this.settings.unhighlight ) {
				for ( i = 0, elements = this.validElements(); elements[ i ]; i++ ) {
					this.settings.unhighlight.call( this, elements[ i ], this.settings.errorClass, this.settings.validClass );
				}
			}
			this.toHide = this.toHide.not( this.toShow );
			this.hideErrors();
			this.addWrapper( this.toShow ).show();
		},

		validElements: function() {
			return this.currentElements.not( this.invalidElements() );
		},

		invalidElements: function() {
			return $( this.errorList ).map( function() {
				return this.element;
			} );
		},

		showLabel: function( element, message ) {
			var place, group, errorID, v,
				error = this.errorsFor( element ),
				elementID = this.idOrName( element ),
				describedBy = $( element ).attr( "aria-describedby" );

			if ( error.length ) {

				// Refresh error/success class
				error.removeClass( this.settings.validClass ).addClass( this.settings.errorClass );

				// Replace message on existing label
				error.html( message );
			} else {

				// Create error element
				error = $( "<" + this.settings.errorElement + ">" )
					.attr( "id", elementID + "-error" )
					.addClass( this.settings.errorClass )
					.html( message || "" );

				// Maintain reference to the element to be placed into the DOM
				place = error;
				if ( this.settings.wrapper ) {

					// Make sure the element is visible, even in IE
					// actually showing the wrapped element is handled elsewhere
					place = error.hide().show().wrap( "<" + this.settings.wrapper + "/>" ).parent();
				}
				if ( this.labelContainer.length ) {
					this.labelContainer.append( place );
				} else if ( this.settings.errorPlacement ) {
					this.settings.errorPlacement.call( this, place, $( element ) );
				} else {
					place.insertAfter( element );
				}

				// Link error back to the element
				if ( error.is( "label" ) ) {

					// If the error is a label, then associate using 'for'
					error.attr( "for", elementID );

					// If the element is not a child of an associated label, then it's necessary
					// to explicitly apply aria-describedby
				} else if ( error.parents( "label[for='" + this.escapeCssMeta( elementID ) + "']" ).length === 0 ) {
					errorID = error.attr( "id" );

					// Respect existing non-error aria-describedby
					if ( !describedBy ) {
						describedBy = errorID;
					} else if ( !describedBy.match( new RegExp( "\\b" + this.escapeCssMeta( errorID ) + "\\b" ) ) ) {

						// Add to end of list if not already present
						describedBy += " " + errorID;
					}
					$( element ).attr( "aria-describedby", describedBy );

					// If this element is grouped, then assign to all elements in the same group
					group = this.groups[ element.name ];
					if ( group ) {
						v = this;
						$.each( v.groups, function( name, testgroup ) {
							if ( testgroup === group ) {
								$( "[name='" + v.escapeCssMeta( name ) + "']", v.currentForm )
									.attr( "aria-describedby", error.attr( "id" ) );
							}
						} );
					}
				}
			}
			if ( !message && this.settings.success ) {
				error.text( "" );
				if ( typeof this.settings.success === "string" ) {
					error.addClass( this.settings.success );
				} else {
					this.settings.success( error, element );
				}
			}
			this.toShow = this.toShow.add( error );
		},

		errorsFor: function( element ) {
			var name = this.escapeCssMeta( this.idOrName( element ) ),
				describer = $( element ).attr( "aria-describedby" ),
				selector = "label[for='" + name + "'], label[for='" + name + "'] *";

			// 'aria-describedby' should directly reference the error element
			if ( describer ) {
				selector = selector + ", #" + this.escapeCssMeta( describer )
					.replace( /\s+/g, ", #" );
			}

			return this
				.errors()
				.filter( selector );
		},

		// See https://api.jquery.com/category/selectors/, for CSS
		// meta-characters that should be escaped in order to be used with JQuery
		// as a literal part of a name/id or any selector.
		escapeCssMeta: function( string ) {
			return string.replace( /([\\!"#$%&'()*+,./:;<=>?@\[\]^`{|}~])/g, "\\$1" );
		},

		idOrName: function( element ) {
			return this.groups[ element.name ] || ( this.checkable( element ) ? element.name : element.id || element.name );
		},

		validationTargetFor: function( element ) {

			// If radio/checkbox, validate first element in group instead
			if ( this.checkable( element ) ) {
				element = this.findByName( element.name );
			}

			// Always apply ignore filter
			return $( element ).not( this.settings.ignore )[ 0 ];
		},

		checkable: function( element ) {
			return ( /radio|checkbox/i ).test( element.type );
		},

		findByName: function( name ) {
			return $( this.currentForm ).find( "[name='" + this.escapeCssMeta( name ) + "']" );
		},

		getLength: function( value, element ) {
			switch ( element.nodeName.toLowerCase() ) {
			case "select":
				return $( "option:selected", element ).length;
			case "input":
				if ( this.checkable( element ) ) {
					return this.findByName( element.name ).filter( ":checked" ).length;
				}
			}
			return value.length;
		},

		depend: function( param, element ) {
			return this.dependTypes[ typeof param ] ? this.dependTypes[ typeof param ]( param, element ) : true;
		},

		dependTypes: {
			"boolean": function( param ) {
				return param;
			},
			"string": function( param, element ) {
				return !!$( param, element.form ).length;
			},
			"function": function( param, element ) {
				return param( element );
			}
		},

		optional: function( element ) {
			var val = this.elementValue( element );
			return !$.validator.methods.required.call( this, val, element ) && "dependency-mismatch";
		},

		startRequest: function( element ) {
			if ( !this.pending[ element.name ] ) {
				this.pendingRequest++;
				$( element ).addClass( this.settings.pendingClass );
				this.pending[ element.name ] = true;
			}
		},

		stopRequest: function( element, valid ) {
			this.pendingRequest--;

			// Sometimes synchronization fails, make sure pendingRequest is never < 0
			if ( this.pendingRequest < 0 ) {
				this.pendingRequest = 0;
			}
			delete this.pending[ element.name ];
			$( element ).removeClass( this.settings.pendingClass );
			if ( valid && this.pendingRequest === 0 && this.formSubmitted && this.form() ) {
				$( this.currentForm ).submit();

				// Remove the hidden input that was used as a replacement for the
				// missing submit button. The hidden input is added by `handle()`
				// to ensure that the value of the used submit button is passed on
				// for scripted submits triggered by this method
				if ( this.submitButton ) {
					$( "input:hidden[name='" + this.submitButton.name + "']", this.currentForm ).remove();
				}

				this.formSubmitted = false;
			} else if ( !valid && this.pendingRequest === 0 && this.formSubmitted ) {
				$( this.currentForm ).triggerHandler( "invalid-form", [ this ] );
				this.formSubmitted = false;
			}
		},

		previousValue: function( element, method ) {
			method = typeof method === "string" && method || "remote";

			return $.data( element, "previousValue" ) || $.data( element, "previousValue", {
				old: null,
				valid: true,
				message: this.defaultMessage( element, { method: method } )
			} );
		},

		// Cleans up all forms and elements, removes validator-specific events
		destroy: function() {
			this.resetForm();

			$( this.currentForm )
				.off( ".validate" )
				.removeData( "validator" )
				.find( ".validate-equalTo-blur" )
					.off( ".validate-equalTo" )
					.removeClass( "validate-equalTo-blur" );
		}

	},

	classRuleSettings: {
		required: { required: true },
		email: { email: true },
		url: { url: true },
		date: { date: true },
		dateISO: { dateISO: true },
		number: { number: true },
		digits: { digits: true },
		creditcard: { creditcard: true }
	},

	addClassRules: function( className, rules ) {
		if ( className.constructor === String ) {
			this.classRuleSettings[ className ] = rules;
		} else {
			$.extend( this.classRuleSettings, className );
		}
	},

	classRules: function( element ) {
		var rules = {},
			classes = $( element ).attr( "class" );

		if ( classes ) {
			$.each( classes.split( " " ), function() {
				if ( this in $.validator.classRuleSettings ) {
					$.extend( rules, $.validator.classRuleSettings[ this ] );
				}
			} );
		}
		return rules;
	},

	normalizeAttributeRule: function( rules, type, method, value ) {

		// Convert the value to a number for number inputs, and for text for backwards compability
		// allows type="date" and others to be compared as strings
		if ( /min|max|step/.test( method ) && ( type === null || /number|range|text/.test( type ) ) ) {
			value = Number( value );

			// Support Opera Mini, which returns NaN for undefined minlength
			if ( isNaN( value ) ) {
				value = undefined;
			}
		}

		if ( value || value === 0 ) {
			rules[ method ] = value;
		} else if ( type === method && type !== "range" ) {

			// Exception: the jquery validate 'range' method
			// does not test for the html5 'range' type
			rules[ method ] = true;
		}
	},

	attributeRules: function( element ) {
		var rules = {},
			$element = $( element ),
			type = element.getAttribute( "type" ),
			method, value;

		for ( method in $.validator.methods ) {

			// Support for <input required> in both html5 and older browsers
			if ( method === "required" ) {
				value = element.getAttribute( method );

				// Some browsers return an empty string for the required attribute
				// and non-HTML5 browsers might have required="" markup
				if ( value === "" ) {
					value = true;
				}

				// Force non-HTML5 browsers to return bool
				value = !!value;
			} else {
				value = $element.attr( method );
			}

			this.normalizeAttributeRule( rules, type, method, value );
		}

		// 'maxlength' may be returned as -1, 2147483647 ( IE ) and 524288 ( safari ) for text inputs
		if ( rules.maxlength && /-1|2147483647|524288/.test( rules.maxlength ) ) {
			delete rules.maxlength;
		}

		return rules;
	},

	dataRules: function( element ) {
		var rules = {},
			$element = $( element ),
			type = element.getAttribute( "type" ),
			method, value;

		for ( method in $.validator.methods ) {
			value = $element.data( "rule" + method.charAt( 0 ).toUpperCase() + method.substring( 1 ).toLowerCase() );
			this.normalizeAttributeRule( rules, type, method, value );
		}
		return rules;
	},

	staticRules: function( element ) {
		var rules = {},
			validator = $.data( element.form, "validator" );

		if ( validator.settings.rules ) {
			rules = $.validator.normalizeRule( validator.settings.rules[ element.name ] ) || {};
		}
		return rules;
	},

	normalizeRules: function( rules, element ) {

		// Handle dependency check
		$.each( rules, function( prop, val ) {

			// Ignore rule when param is explicitly false, eg. required:false
			if ( val === false ) {
				delete rules[ prop ];
				return;
			}
			if ( val.param || val.depends ) {
				var keepRule = true;
				switch ( typeof val.depends ) {
				case "string":
					keepRule = !!$( val.depends, element.form ).length;
					break;
				case "function":
					keepRule = val.depends.call( element, element );
					break;
				}
				if ( keepRule ) {
					rules[ prop ] = val.param !== undefined ? val.param : true;
				} else {
					$.data( element.form, "validator" ).resetElements( $( element ) );
					delete rules[ prop ];
				}
			}
		} );

		// Evaluate parameters
		$.each( rules, function( rule, parameter ) {
			rules[ rule ] = $.isFunction( parameter ) && rule !== "normalizer" ? parameter( element ) : parameter;
		} );

		// Clean number parameters
		$.each( [ "minlength", "maxlength" ], function() {
			if ( rules[ this ] ) {
				rules[ this ] = Number( rules[ this ] );
			}
		} );
		$.each( [ "rangelength", "range" ], function() {
			var parts;
			if ( rules[ this ] ) {
				if ( $.isArray( rules[ this ] ) ) {
					rules[ this ] = [ Number( rules[ this ][ 0 ] ), Number( rules[ this ][ 1 ] ) ];
				} else if ( typeof rules[ this ] === "string" ) {
					parts = rules[ this ].replace( /[\[\]]/g, "" ).split( /[\s,]+/ );
					rules[ this ] = [ Number( parts[ 0 ] ), Number( parts[ 1 ] ) ];
				}
			}
		} );

		if ( $.validator.autoCreateRanges ) {

			// Auto-create ranges
			if ( rules.min != null && rules.max != null ) {
				rules.range = [ rules.min, rules.max ];
				delete rules.min;
				delete rules.max;
			}
			if ( rules.minlength != null && rules.maxlength != null ) {
				rules.rangelength = [ rules.minlength, rules.maxlength ];
				delete rules.minlength;
				delete rules.maxlength;
			}
		}

		return rules;
	},

	// Converts a simple string to a {string: true} rule, e.g., "required" to {required:true}
	normalizeRule: function( data ) {
		if ( typeof data === "string" ) {
			var transformed = {};
			$.each( data.split( /\s/ ), function() {
				transformed[ this ] = true;
			} );
			data = transformed;
		}
		return data;
	},

	// https://jqueryvalidation.org/jQuery.validator.addMethod/
	addMethod: function( name, method, message ) {
		$.validator.methods[ name ] = method;
		$.validator.messages[ name ] = message !== undefined ? message : $.validator.messages[ name ];
		if ( method.length < 3 ) {
			$.validator.addClassRules( name, $.validator.normalizeRule( name ) );
		}
	},

	// https://jqueryvalidation.org/jQuery.validator.methods/
	methods: {

		// https://jqueryvalidation.org/required-method/
		required: function( value, element, param ) {

			// Check if dependency is met
			if ( !this.depend( param, element ) ) {
				return "dependency-mismatch";
			}
			if ( element.nodeName.toLowerCase() === "select" ) {

				// Could be an array for select-multiple or a string, both are fine this way
				var val = $( element ).val();
				return val && val.length > 0;
			}
			if ( this.checkable( element ) ) {
				return this.getLength( value, element ) > 0;
			}
			return value.length > 0;
		},

		// https://jqueryvalidation.org/email-method/
		email: function( value, element ) {

			// From https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address
			// Retrieved 2014-01-14
			// If you have a problem with this implementation, report a bug against the above spec
			// Or use custom methods to implement your own email validation
			return this.optional( element ) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test( value );
		},

		// https://jqueryvalidation.org/url-method/
		url: function( value, element ) {

			// Copyright (c) 2010-2013 Diego Perini, MIT licensed
			// https://gist.github.com/dperini/729294
			// see also https://mathiasbynens.be/demo/url-regex
			// modified to allow protocol-relative URLs
			return this.optional( element ) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test( value );
		},

		// https://jqueryvalidation.org/date-method/
		date: function( value, element ) {
			return this.optional( element ) || !/Invalid|NaN/.test( new Date( value ).toString() );
		},

		// https://jqueryvalidation.org/dateISO-method/
		dateISO: function( value, element ) {
			return this.optional( element ) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test( value );
		},

		// https://jqueryvalidation.org/number-method/
		number: function( value, element ) {
			return this.optional( element ) || /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test( value );
		},

		// https://jqueryvalidation.org/digits-method/
		digits: function( value, element ) {
			return this.optional( element ) || /^\d+$/.test( value );
		},

		// https://jqueryvalidation.org/minlength-method/
		minlength: function( value, element, param ) {
			var length = $.isArray( value ) ? value.length : this.getLength( value, element );
			return this.optional( element ) || length >= param;
		},

		// https://jqueryvalidation.org/maxlength-method/
		maxlength: function( value, element, param ) {
			var length = $.isArray( value ) ? value.length : this.getLength( value, element );
			return this.optional( element ) || length <= param;
		},

		// https://jqueryvalidation.org/rangelength-method/
		rangelength: function( value, element, param ) {
			var length = $.isArray( value ) ? value.length : this.getLength( value, element );
			return this.optional( element ) || ( length >= param[ 0 ] && length <= param[ 1 ] );
		},

		// https://jqueryvalidation.org/min-method/
		min: function( value, element, param ) {
			return this.optional( element ) || value >= param;
		},

		// https://jqueryvalidation.org/max-method/
		max: function( value, element, param ) {
			return this.optional( element ) || value <= param;
		},

		// https://jqueryvalidation.org/range-method/
		range: function( value, element, param ) {
			return this.optional( element ) || ( value >= param[ 0 ] && value <= param[ 1 ] );
		},

		// https://jqueryvalidation.org/step-method/
		step: function( value, element, param ) {
			var type = $( element ).attr( "type" ),
				errorMessage = "Step attribute on input type " + type + " is not supported.",
				supportedTypes = [ "text", "number", "range" ],
				re = new RegExp( "\\b" + type + "\\b" ),
				notSupported = type && !re.test( supportedTypes.join() ),
				decimalPlaces = function( num ) {
					var match = ( "" + num ).match( /(?:\.(\d+))?$/ );
					if ( !match ) {
						return 0;
					}

					// Number of digits right of decimal point.
					return match[ 1 ] ? match[ 1 ].length : 0;
				},
				toInt = function( num ) {
					return Math.round( num * Math.pow( 10, decimals ) );
				},
				valid = true,
				decimals;

			// Works only for text, number and range input types
			// TODO find a way to support input types date, datetime, datetime-local, month, time and week
			if ( notSupported ) {
				throw new Error( errorMessage );
			}

			decimals = decimalPlaces( param );

			// Value can't have too many decimals
			if ( decimalPlaces( value ) > decimals || toInt( value ) % toInt( param ) !== 0 ) {
				valid = false;
			}

			return this.optional( element ) || valid;
		},

		// https://jqueryvalidation.org/equalTo-method/
		equalTo: function( value, element, param ) {

			// Bind to the blur event of the target in order to revalidate whenever the target field is updated
			var target = $( param );
			if ( this.settings.onfocusout && target.not( ".validate-equalTo-blur" ).length ) {
				target.addClass( "validate-equalTo-blur" ).on( "blur.validate-equalTo", function() {
					$( element ).valid();
				} );
			}
			return value === target.val();
		},

		// https://jqueryvalidation.org/remote-method/
		remote: function( value, element, param, method ) {
			if ( this.optional( element ) ) {
				return "dependency-mismatch";
			}

			method = typeof method === "string" && method || "remote";

			var previous = this.previousValue( element, method ),
				validator, data, optionDataString;

			if ( !this.settings.messages[ element.name ] ) {
				this.settings.messages[ element.name ] = {};
			}
			previous.originalMessage = previous.originalMessage || this.settings.messages[ element.name ][ method ];
			this.settings.messages[ element.name ][ method ] = previous.message;

			param = typeof param === "string" && { url: param } || param;
			optionDataString = $.param( $.extend( { data: value }, param.data ) );
			if ( previous.old === optionDataString ) {
				return previous.valid;
			}

			previous.old = optionDataString;
			validator = this;
			this.startRequest( element );
			data = {};
			data[ element.name ] = value;
			$.ajax( $.extend( true, {
				mode: "abort",
				port: "validate" + element.name,
				dataType: "json",
				data: data,
				context: validator.currentForm,
				success: function( response ) {
					var valid = response === true || response === "true",
						errors, message, submitted;

					validator.settings.messages[ element.name ][ method ] = previous.originalMessage;
					if ( valid ) {
						submitted = validator.formSubmitted;
						validator.resetInternals();
						validator.toHide = validator.errorsFor( element );
						validator.formSubmitted = submitted;
						validator.successList.push( element );
						validator.invalid[ element.name ] = false;
						validator.showErrors();
					} else {
						errors = {};
						message = response || validator.defaultMessage( element, { method: method, parameters: value } );
						errors[ element.name ] = previous.message = message;
						validator.invalid[ element.name ] = true;
						validator.showErrors( errors );
					}
					previous.valid = valid;
					validator.stopRequest( element, valid );
				}
			}, param ) );
			return "pending";
		}
	}

} );

// Ajax mode: abort
// usage: $.ajax({ mode: "abort"[, port: "uniqueport"]});
// if mode:"abort" is used, the previous request on that port (port can be undefined) is aborted via XMLHttpRequest.abort()

var pendingRequests = {},
	ajax;

// Use a prefilter if available (1.5+)
if ( $.ajaxPrefilter ) {
	$.ajaxPrefilter( function( settings, _, xhr ) {
		var port = settings.port;
		if ( settings.mode === "abort" ) {
			if ( pendingRequests[ port ] ) {
				pendingRequests[ port ].abort();
			}
			pendingRequests[ port ] = xhr;
		}
	} );
} else {

	// Proxy ajax
	ajax = $.ajax;
	$.ajax = function( settings ) {
		var mode = ( "mode" in settings ? settings : $.ajaxSettings ).mode,
			port = ( "port" in settings ? settings : $.ajaxSettings ).port;
		if ( mode === "abort" ) {
			if ( pendingRequests[ port ] ) {
				pendingRequests[ port ].abort();
			}
			pendingRequests[ port ] = ajax.apply( this, arguments );
			return pendingRequests[ port ];
		}
		return ajax.apply( this, arguments );
	};
}
return $;
}));

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(jQuery) {/*!
** Unobtrusive validation support library for jQuery and jQuery Validate
** Copyright (C) Microsoft Corporation. All rights reserved.
*/

/*jslint white: true, browser: true, onevar: true, undef: true, nomen: true, eqeqeq: true, plusplus: true, bitwise: true, regexp: true, newcap: true, immed: true, strict: false */
/*global document: false, jQuery: false */

(function ($) {
    var $jQval = $.validator,
        adapters,
        data_validation = "unobtrusiveValidation";

    function setValidationValues(options, ruleName, value) {
        options.rules[ruleName] = value;
        if (options.message) {
            options.messages[ruleName] = options.message;
        }
    }

    function splitAndTrim(value) {
        return value.replace(/^\s+|\s+$/g, "").split(/\s*,\s*/g);
    }

    function escapeAttributeValue(value) {
        // As mentioned on http://api.jquery.com/category/selectors/
        return value.replace(/([!"#$%&'()*+,./:;<=>?@\[\\\]^`{|}~])/g, "\\$1");
    }

    function getModelPrefix(fieldName) {
        return fieldName.substr(0, fieldName.lastIndexOf(".") + 1);
    }

    function appendModelPrefix(value, prefix) {
        if (value.indexOf("*.") === 0) {
            value = value.replace("*.", prefix);
        }
        return value;
    }

    function onError(error, inputElement) {  // 'this' is the form element
        var container = $(this).find("[data-valmsg-for='" + escapeAttributeValue(inputElement[0].name) + "']"),
            replaceAttrValue = container.attr("data-valmsg-replace"),
            replace = replaceAttrValue ? $.parseJSON(replaceAttrValue) !== false : null;

        container.removeClass("field-validation-valid").addClass("field-validation-error");
        error.data("unobtrusiveContainer", container);

        if (replace) {
            container.empty();
            error.removeClass("input-validation-error").appendTo(container);
        }
        else {
            error.hide();
        }
    }

    function onErrors(event, validator) {  // 'this' is the form element
        var container = $(this).find("[data-valmsg-summary=true]"),
            list = container.find("ul");

        if (list && list.length && validator.errorList.length) {
            list.empty();
            container.addClass("validation-summary-errors").removeClass("validation-summary-valid");

            $.each(validator.errorList, function () {
                $("<li />").html(this.message).appendTo(list);
            });
        }
    }

    function onSuccess(error) {  // 'this' is the form element
        var container = error.data("unobtrusiveContainer");

        if (container) {
            var replaceAttrValue = container.attr("data-valmsg-replace"),
                replace = replaceAttrValue ? $.parseJSON(replaceAttrValue) : null;

            container.addClass("field-validation-valid").removeClass("field-validation-error");
            error.removeData("unobtrusiveContainer");

            if (replace) {
                container.empty();
            }
        }
    }

    function onReset(event) {  // 'this' is the form element
        var $form = $(this),
            key = '__jquery_unobtrusive_validation_form_reset';
        if ($form.data(key)) {
            return;
        }
        // Set a flag that indicates we're currently resetting the form.
        $form.data(key, true);
        try {
            $form.data("validator").resetForm();
        } finally {
            $form.removeData(key);
        }

        $form.find(".validation-summary-errors")
            .addClass("validation-summary-valid")
            .removeClass("validation-summary-errors");
        $form.find(".field-validation-error")
            .addClass("field-validation-valid")
            .removeClass("field-validation-error")
            .removeData("unobtrusiveContainer")
            .find(">*")  // If we were using valmsg-replace, get the underlying error
                .removeData("unobtrusiveContainer");
    }

    function validationInfo(form) {
        var $form = $(form),
            result = $form.data(data_validation),
            onResetProxy = $.proxy(onReset, form),
            defaultOptions = $jQval.unobtrusive.options || {},
            execInContext = function (name, args) {
                var func = defaultOptions[name];
                func && $.isFunction(func) && func.apply(form, args);
            }

        if (!result) {
            result = {
                options: {  // options structure passed to jQuery Validate's validate() method
                    errorClass: defaultOptions.errorClass || "input-validation-error",
                    errorElement: defaultOptions.errorElement || "span",
                    errorPlacement: function () {
                        onError.apply(form, arguments);
                        execInContext("errorPlacement", arguments);
                    },
                    invalidHandler: function () {
                        onErrors.apply(form, arguments);
                        execInContext("invalidHandler", arguments);
                    },
                    messages: {},
                    rules: {},
                    success: function () {
                        onSuccess.apply(form, arguments);
                        execInContext("success", arguments);
                    }
                },
                attachValidation: function () {
                    $form
                        .off("reset." + data_validation, onResetProxy)
                        .on("reset." + data_validation, onResetProxy)
                        .validate(this.options);
                },
                validate: function () {  // a validation function that is called by unobtrusive Ajax
                    $form.validate();
                    return $form.valid();
                }
            };
            $form.data(data_validation, result);
        }

        return result;
    }

    $jQval.unobtrusive = {
        adapters: [],

        parseElement: function (element, skipAttach) {
            /// <summary>
            /// Parses a single HTML element for unobtrusive validation attributes.
            /// </summary>
            /// <param name="element" domElement="true">The HTML element to be parsed.</param>
            /// <param name="skipAttach" type="Boolean">[Optional] true to skip attaching the
            /// validation to the form. If parsing just this single element, you should specify true.
            /// If parsing several elements, you should specify false, and manually attach the validation
            /// to the form when you are finished. The default is false.</param>
            var $element = $(element),
                form = $element.parents("form")[0],
                valInfo, rules, messages;

            if (!form) {  // Cannot do client-side validation without a form
                return;
            }

            valInfo = validationInfo(form);
            valInfo.options.rules[element.name] = rules = {};
            valInfo.options.messages[element.name] = messages = {};

            $.each(this.adapters, function () {
                var prefix = "data-val-" + this.name,
                    message = $element.attr(prefix),
                    paramValues = {};

                if (message !== undefined) {  // Compare against undefined, because an empty message is legal (and falsy)
                    prefix += "-";

                    $.each(this.params, function () {
                        paramValues[this] = $element.attr(prefix + this);
                    });

                    this.adapt({
                        element: element,
                        form: form,
                        message: message,
                        params: paramValues,
                        rules: rules,
                        messages: messages
                    });
                }
            });

            $.extend(rules, { "__dummy__": true });

            if (!skipAttach) {
                valInfo.attachValidation();
            }
        },

        parse: function (selector) {
            /// <summary>
            /// Parses all the HTML elements in the specified selector. It looks for input elements decorated
            /// with the [data-val=true] attribute value and enables validation according to the data-val-*
            /// attribute values.
            /// </summary>
            /// <param name="selector" type="String">Any valid jQuery selector.</param>

            // $forms includes all forms in selector's DOM hierarchy (parent, children and self) that have at least one
            // element with data-val=true
            var $selector = $(selector),
                $forms = $selector.parents()
                                  .addBack()
                                  .filter("form")
                                  .add($selector.find("form"))
                                  .has("[data-val=true]");

            $selector.find("[data-val=true]").each(function () {
                $jQval.unobtrusive.parseElement(this, true);
            });

            $forms.each(function () {
                var info = validationInfo(this);
                if (info) {
                    info.attachValidation();
                }
            });
        }
    };

    adapters = $jQval.unobtrusive.adapters;

    adapters.add = function (adapterName, params, fn) {
        /// <summary>Adds a new adapter to convert unobtrusive HTML into a jQuery Validate validation.</summary>
        /// <param name="adapterName" type="String">The name of the adapter to be added. This matches the name used
        /// in the data-val-nnnn HTML attribute (where nnnn is the adapter name).</param>
        /// <param name="params" type="Array" optional="true">[Optional] An array of parameter names (strings) that will
        /// be extracted from the data-val-nnnn-mmmm HTML attributes (where nnnn is the adapter name, and
        /// mmmm is the parameter name).</param>
        /// <param name="fn" type="Function">The function to call, which adapts the values from the HTML
        /// attributes into jQuery Validate rules and/or messages.</param>
        /// <returns type="jQuery.validator.unobtrusive.adapters" />
        if (!fn) {  // Called with no params, just a function
            fn = params;
            params = [];
        }
        this.push({ name: adapterName, params: params, adapt: fn });
        return this;
    };

    adapters.addBool = function (adapterName, ruleName) {
        /// <summary>Adds a new adapter to convert unobtrusive HTML into a jQuery Validate validation, where
        /// the jQuery Validate validation rule has no parameter values.</summary>
        /// <param name="adapterName" type="String">The name of the adapter to be added. This matches the name used
        /// in the data-val-nnnn HTML attribute (where nnnn is the adapter name).</param>
        /// <param name="ruleName" type="String" optional="true">[Optional] The name of the jQuery Validate rule. If not provided, the value
        /// of adapterName will be used instead.</param>
        /// <returns type="jQuery.validator.unobtrusive.adapters" />
        return this.add(adapterName, function (options) {
            setValidationValues(options, ruleName || adapterName, true);
        });
    };

    adapters.addMinMax = function (adapterName, minRuleName, maxRuleName, minMaxRuleName, minAttribute, maxAttribute) {
        /// <summary>Adds a new adapter to convert unobtrusive HTML into a jQuery Validate validation, where
        /// the jQuery Validate validation has three potential rules (one for min-only, one for max-only, and
        /// one for min-and-max). The HTML parameters are expected to be named -min and -max.</summary>
        /// <param name="adapterName" type="String">The name of the adapter to be added. This matches the name used
        /// in the data-val-nnnn HTML attribute (where nnnn is the adapter name).</param>
        /// <param name="minRuleName" type="String">The name of the jQuery Validate rule to be used when you only
        /// have a minimum value.</param>
        /// <param name="maxRuleName" type="String">The name of the jQuery Validate rule to be used when you only
        /// have a maximum value.</param>
        /// <param name="minMaxRuleName" type="String">The name of the jQuery Validate rule to be used when you
        /// have both a minimum and maximum value.</param>
        /// <param name="minAttribute" type="String" optional="true">[Optional] The name of the HTML attribute that
        /// contains the minimum value. The default is "min".</param>
        /// <param name="maxAttribute" type="String" optional="true">[Optional] The name of the HTML attribute that
        /// contains the maximum value. The default is "max".</param>
        /// <returns type="jQuery.validator.unobtrusive.adapters" />
        return this.add(adapterName, [minAttribute || "min", maxAttribute || "max"], function (options) {
            var min = options.params.min,
                max = options.params.max;

            if (min && max) {
                setValidationValues(options, minMaxRuleName, [min, max]);
            }
            else if (min) {
                setValidationValues(options, minRuleName, min);
            }
            else if (max) {
                setValidationValues(options, maxRuleName, max);
            }
        });
    };

    adapters.addSingleVal = function (adapterName, attribute, ruleName) {
        /// <summary>Adds a new adapter to convert unobtrusive HTML into a jQuery Validate validation, where
        /// the jQuery Validate validation rule has a single value.</summary>
        /// <param name="adapterName" type="String">The name of the adapter to be added. This matches the name used
        /// in the data-val-nnnn HTML attribute(where nnnn is the adapter name).</param>
        /// <param name="attribute" type="String">[Optional] The name of the HTML attribute that contains the value.
        /// The default is "val".</param>
        /// <param name="ruleName" type="String" optional="true">[Optional] The name of the jQuery Validate rule. If not provided, the value
        /// of adapterName will be used instead.</param>
        /// <returns type="jQuery.validator.unobtrusive.adapters" />
        return this.add(adapterName, [attribute || "val"], function (options) {
            setValidationValues(options, ruleName || adapterName, options.params[attribute]);
        });
    };

    $jQval.addMethod("__dummy__", function (value, element, params) {
        return true;
    });

    $jQval.addMethod("regex", function (value, element, params) {
        var match;
        if (this.optional(element)) {
            return true;
        }

        match = new RegExp(params).exec(value);
        return (match && (match.index === 0) && (match[0].length === value.length));
    });

    $jQval.addMethod("nonalphamin", function (value, element, nonalphamin) {
        var match;
        if (nonalphamin) {
            match = value.match(/\W/g);
            match = match && match.length >= nonalphamin;
        }
        return match;
    });

    if ($jQval.methods.extension) {
        adapters.addSingleVal("accept", "mimtype");
        adapters.addSingleVal("extension", "extension");
    } else {
        // for backward compatibility, when the 'extension' validation method does not exist, such as with versions
        // of JQuery Validation plugin prior to 1.10, we should use the 'accept' method for
        // validating the extension, and ignore mime-type validations as they are not supported.
        adapters.addSingleVal("extension", "extension", "accept");
    }

    adapters.addSingleVal("regex", "pattern");
    adapters.addBool("creditcard").addBool("date").addBool("digits").addBool("email").addBool("number").addBool("url");
    adapters.addMinMax("length", "minlength", "maxlength", "rangelength").addMinMax("range", "min", "max", "range");
    adapters.addMinMax("minlength", "minlength").addMinMax("maxlength", "minlength", "maxlength");
    adapters.add("equalto", ["other"], function (options) {
        var prefix = getModelPrefix(options.element.name),
            other = options.params.other,
            fullOtherName = appendModelPrefix(other, prefix),
            element = $(options.form).find(":input").filter("[name='" + escapeAttributeValue(fullOtherName) + "']")[0];

        setValidationValues(options, "equalTo", element);
    });
    adapters.add("required", function (options) {
        // jQuery Validate equates "required" with "mandatory" for checkbox elements
        if (options.element.tagName.toUpperCase() !== "INPUT" || options.element.type.toUpperCase() !== "CHECKBOX") {
            setValidationValues(options, "required", true);
        }
    });
    adapters.add("remote", ["url", "type", "additionalfields"], function (options) {
        var value = {
            url: options.params.url,
            type: options.params.type || "GET",
            data: {}
        },
            prefix = getModelPrefix(options.element.name);

        $.each(splitAndTrim(options.params.additionalfields || options.element.name), function (i, fieldName) {
            var paramName = appendModelPrefix(fieldName, prefix);
            value.data[paramName] = function () {
                var field = $(options.form).find(":input").filter("[name='" + escapeAttributeValue(paramName) + "']");
                // For checkboxes and radio buttons, only pick up values from checked fields.
                if (field.is(":checkbox")) {
                    return field.filter(":checked").val() || field.filter(":hidden").val() || '';
                }
                else if (field.is(":radio")) {
                    return field.filter(":checked").val() || '';
                }
                return field.val();
            };
        });

        setValidationValues(options, "remote", value);
    });
    adapters.add("password", ["min", "nonalphamin", "regex"], function (options) {
        if (options.params.min) {
            setValidationValues(options, "minlength", options.params.min);
        }
        if (options.params.nonalphamin) {
            setValidationValues(options, "nonalphamin", options.params.nonalphamin);
        }
        if (options.params.regex) {
            setValidationValues(options, "regex", options.params.regex);
        }
    });

    $(function () {
        $jQval.unobtrusive.parse(document);
    });
}(jQuery));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! tether 1.4.3 */

(function(root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports === 'object') {
    module.exports = factory(require, exports, module);
  } else {
    root.Tether = factory();
  }
}(this, function(require, exports, module) {

'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var TetherBase = undefined;
if (typeof TetherBase === 'undefined') {
  TetherBase = { modules: [] };
}

var zeroElement = null;

// Same as native getBoundingClientRect, except it takes into account parent <frame> offsets
// if the element lies within a nested document (<frame> or <iframe>-like).
function getActualBoundingClientRect(node) {
  var boundingRect = node.getBoundingClientRect();

  // The original object returned by getBoundingClientRect is immutable, so we clone it
  // We can't use extend because the properties are not considered part of the object by hasOwnProperty in IE9
  var rect = {};
  for (var k in boundingRect) {
    rect[k] = boundingRect[k];
  }

  if (node.ownerDocument !== document) {
    var _frameElement = node.ownerDocument.defaultView.frameElement;
    if (_frameElement) {
      var frameRect = getActualBoundingClientRect(_frameElement);
      rect.top += frameRect.top;
      rect.bottom += frameRect.top;
      rect.left += frameRect.left;
      rect.right += frameRect.left;
    }
  }

  return rect;
}

function getScrollParents(el) {
  // In firefox if the el is inside an iframe with display: none; window.getComputedStyle() will return null;
  // https://bugzilla.mozilla.org/show_bug.cgi?id=548397
  var computedStyle = getComputedStyle(el) || {};
  var position = computedStyle.position;
  var parents = [];

  if (position === 'fixed') {
    return [el];
  }

  var parent = el;
  while ((parent = parent.parentNode) && parent && parent.nodeType === 1) {
    var style = undefined;
    try {
      style = getComputedStyle(parent);
    } catch (err) {}

    if (typeof style === 'undefined' || style === null) {
      parents.push(parent);
      return parents;
    }

    var _style = style;
    var overflow = _style.overflow;
    var overflowX = _style.overflowX;
    var overflowY = _style.overflowY;

    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      if (position !== 'absolute' || ['relative', 'absolute', 'fixed'].indexOf(style.position) >= 0) {
        parents.push(parent);
      }
    }
  }

  parents.push(el.ownerDocument.body);

  // If the node is within a frame, account for the parent window scroll
  if (el.ownerDocument !== document) {
    parents.push(el.ownerDocument.defaultView);
  }

  return parents;
}

var uniqueId = (function () {
  var id = 0;
  return function () {
    return ++id;
  };
})();

var zeroPosCache = {};
var getOrigin = function getOrigin() {
  // getBoundingClientRect is unfortunately too accurate.  It introduces a pixel or two of
  // jitter as the user scrolls that messes with our ability to detect if two positions
  // are equivilant or not.  We place an element at the top left of the page that will
  // get the same jitter, so we can cancel the two out.
  var node = zeroElement;
  if (!node || !document.body.contains(node)) {
    node = document.createElement('div');
    node.setAttribute('data-tether-id', uniqueId());
    extend(node.style, {
      top: 0,
      left: 0,
      position: 'absolute'
    });

    document.body.appendChild(node);

    zeroElement = node;
  }

  var id = node.getAttribute('data-tether-id');
  if (typeof zeroPosCache[id] === 'undefined') {
    zeroPosCache[id] = getActualBoundingClientRect(node);

    // Clear the cache when this position call is done
    defer(function () {
      delete zeroPosCache[id];
    });
  }

  return zeroPosCache[id];
};

function removeUtilElements() {
  if (zeroElement) {
    document.body.removeChild(zeroElement);
  }
  zeroElement = null;
};

function getBounds(el) {
  var doc = undefined;
  if (el === document) {
    doc = document;
    el = document.documentElement;
  } else {
    doc = el.ownerDocument;
  }

  var docEl = doc.documentElement;

  var box = getActualBoundingClientRect(el);

  var origin = getOrigin();

  box.top -= origin.top;
  box.left -= origin.left;

  if (typeof box.width === 'undefined') {
    box.width = document.body.scrollWidth - box.left - box.right;
  }
  if (typeof box.height === 'undefined') {
    box.height = document.body.scrollHeight - box.top - box.bottom;
  }

  box.top = box.top - docEl.clientTop;
  box.left = box.left - docEl.clientLeft;
  box.right = doc.body.clientWidth - box.width - box.left;
  box.bottom = doc.body.clientHeight - box.height - box.top;

  return box;
}

function getOffsetParent(el) {
  return el.offsetParent || document.documentElement;
}

var _scrollBarSize = null;
function getScrollBarSize() {
  if (_scrollBarSize) {
    return _scrollBarSize;
  }
  var inner = document.createElement('div');
  inner.style.width = '100%';
  inner.style.height = '200px';

  var outer = document.createElement('div');
  extend(outer.style, {
    position: 'absolute',
    top: 0,
    left: 0,
    pointerEvents: 'none',
    visibility: 'hidden',
    width: '200px',
    height: '150px',
    overflow: 'hidden'
  });

  outer.appendChild(inner);

  document.body.appendChild(outer);

  var widthContained = inner.offsetWidth;
  outer.style.overflow = 'scroll';
  var widthScroll = inner.offsetWidth;

  if (widthContained === widthScroll) {
    widthScroll = outer.clientWidth;
  }

  document.body.removeChild(outer);

  var width = widthContained - widthScroll;

  _scrollBarSize = { width: width, height: width };
  return _scrollBarSize;
}

function extend() {
  var out = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  var args = [];

  Array.prototype.push.apply(args, arguments);

  args.slice(1).forEach(function (obj) {
    if (obj) {
      for (var key in obj) {
        if (({}).hasOwnProperty.call(obj, key)) {
          out[key] = obj[key];
        }
      }
    }
  });

  return out;
}

function removeClass(el, name) {
  if (typeof el.classList !== 'undefined') {
    name.split(' ').forEach(function (cls) {
      if (cls.trim()) {
        el.classList.remove(cls);
      }
    });
  } else {
    var regex = new RegExp('(^| )' + name.split(' ').join('|') + '( |$)', 'gi');
    var className = getClassName(el).replace(regex, ' ');
    setClassName(el, className);
  }
}

function addClass(el, name) {
  if (typeof el.classList !== 'undefined') {
    name.split(' ').forEach(function (cls) {
      if (cls.trim()) {
        el.classList.add(cls);
      }
    });
  } else {
    removeClass(el, name);
    var cls = getClassName(el) + (' ' + name);
    setClassName(el, cls);
  }
}

function hasClass(el, name) {
  if (typeof el.classList !== 'undefined') {
    return el.classList.contains(name);
  }
  var className = getClassName(el);
  return new RegExp('(^| )' + name + '( |$)', 'gi').test(className);
}

function getClassName(el) {
  // Can't use just SVGAnimatedString here since nodes within a Frame in IE have
  // completely separately SVGAnimatedString base classes
  if (el.className instanceof el.ownerDocument.defaultView.SVGAnimatedString) {
    return el.className.baseVal;
  }
  return el.className;
}

function setClassName(el, className) {
  el.setAttribute('class', className);
}

function updateClasses(el, add, all) {
  // Of the set of 'all' classes, we need the 'add' classes, and only the
  // 'add' classes to be set.
  all.forEach(function (cls) {
    if (add.indexOf(cls) === -1 && hasClass(el, cls)) {
      removeClass(el, cls);
    }
  });

  add.forEach(function (cls) {
    if (!hasClass(el, cls)) {
      addClass(el, cls);
    }
  });
}

var deferred = [];

var defer = function defer(fn) {
  deferred.push(fn);
};

var flush = function flush() {
  var fn = undefined;
  while (fn = deferred.pop()) {
    fn();
  }
};

var Evented = (function () {
  function Evented() {
    _classCallCheck(this, Evented);
  }

  _createClass(Evented, [{
    key: 'on',
    value: function on(event, handler, ctx) {
      var once = arguments.length <= 3 || arguments[3] === undefined ? false : arguments[3];

      if (typeof this.bindings === 'undefined') {
        this.bindings = {};
      }
      if (typeof this.bindings[event] === 'undefined') {
        this.bindings[event] = [];
      }
      this.bindings[event].push({ handler: handler, ctx: ctx, once: once });
    }
  }, {
    key: 'once',
    value: function once(event, handler, ctx) {
      this.on(event, handler, ctx, true);
    }
  }, {
    key: 'off',
    value: function off(event, handler) {
      if (typeof this.bindings === 'undefined' || typeof this.bindings[event] === 'undefined') {
        return;
      }

      if (typeof handler === 'undefined') {
        delete this.bindings[event];
      } else {
        var i = 0;
        while (i < this.bindings[event].length) {
          if (this.bindings[event][i].handler === handler) {
            this.bindings[event].splice(i, 1);
          } else {
            ++i;
          }
        }
      }
    }
  }, {
    key: 'trigger',
    value: function trigger(event) {
      if (typeof this.bindings !== 'undefined' && this.bindings[event]) {
        var i = 0;

        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        while (i < this.bindings[event].length) {
          var _bindings$event$i = this.bindings[event][i];
          var handler = _bindings$event$i.handler;
          var ctx = _bindings$event$i.ctx;
          var once = _bindings$event$i.once;

          var context = ctx;
          if (typeof context === 'undefined') {
            context = this;
          }

          handler.apply(context, args);

          if (once) {
            this.bindings[event].splice(i, 1);
          } else {
            ++i;
          }
        }
      }
    }
  }]);

  return Evented;
})();

TetherBase.Utils = {
  getActualBoundingClientRect: getActualBoundingClientRect,
  getScrollParents: getScrollParents,
  getBounds: getBounds,
  getOffsetParent: getOffsetParent,
  extend: extend,
  addClass: addClass,
  removeClass: removeClass,
  hasClass: hasClass,
  updateClasses: updateClasses,
  defer: defer,
  flush: flush,
  uniqueId: uniqueId,
  Evented: Evented,
  getScrollBarSize: getScrollBarSize,
  removeUtilElements: removeUtilElements
};
/* globals TetherBase, performance */

'use strict';

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x6, _x7, _x8) { var _again = true; _function: while (_again) { var object = _x6, property = _x7, receiver = _x8; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x6 = parent; _x7 = property; _x8 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

if (typeof TetherBase === 'undefined') {
  throw new Error('You must include the utils.js file before tether.js');
}

var _TetherBase$Utils = TetherBase.Utils;
var getScrollParents = _TetherBase$Utils.getScrollParents;
var getBounds = _TetherBase$Utils.getBounds;
var getOffsetParent = _TetherBase$Utils.getOffsetParent;
var extend = _TetherBase$Utils.extend;
var addClass = _TetherBase$Utils.addClass;
var removeClass = _TetherBase$Utils.removeClass;
var updateClasses = _TetherBase$Utils.updateClasses;
var defer = _TetherBase$Utils.defer;
var flush = _TetherBase$Utils.flush;
var getScrollBarSize = _TetherBase$Utils.getScrollBarSize;
var removeUtilElements = _TetherBase$Utils.removeUtilElements;

function within(a, b) {
  var diff = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];

  return a + diff >= b && b >= a - diff;
}

var transformKey = (function () {
  if (typeof document === 'undefined') {
    return '';
  }
  var el = document.createElement('div');

  var transforms = ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform'];
  for (var i = 0; i < transforms.length; ++i) {
    var key = transforms[i];
    if (el.style[key] !== undefined) {
      return key;
    }
  }
})();

var tethers = [];

var position = function position() {
  tethers.forEach(function (tether) {
    tether.position(false);
  });
  flush();
};

function now() {
  if (typeof performance === 'object' && typeof performance.now === 'function') {
    return performance.now();
  }
  return +new Date();
}

(function () {
  var lastCall = null;
  var lastDuration = null;
  var pendingTimeout = null;

  var tick = function tick() {
    if (typeof lastDuration !== 'undefined' && lastDuration > 16) {
      // We voluntarily throttle ourselves if we can't manage 60fps
      lastDuration = Math.min(lastDuration - 16, 250);

      // Just in case this is the last event, remember to position just once more
      pendingTimeout = setTimeout(tick, 250);
      return;
    }

    if (typeof lastCall !== 'undefined' && now() - lastCall < 10) {
      // Some browsers call events a little too frequently, refuse to run more than is reasonable
      return;
    }

    if (pendingTimeout != null) {
      clearTimeout(pendingTimeout);
      pendingTimeout = null;
    }

    lastCall = now();
    position();
    lastDuration = now() - lastCall;
  };

  if (typeof window !== 'undefined' && typeof window.addEventListener !== 'undefined') {
    ['resize', 'scroll', 'touchmove'].forEach(function (event) {
      window.addEventListener(event, tick);
    });
  }
})();

var MIRROR_LR = {
  center: 'center',
  left: 'right',
  right: 'left'
};

var MIRROR_TB = {
  middle: 'middle',
  top: 'bottom',
  bottom: 'top'
};

var OFFSET_MAP = {
  top: 0,
  left: 0,
  middle: '50%',
  center: '50%',
  bottom: '100%',
  right: '100%'
};

var autoToFixedAttachment = function autoToFixedAttachment(attachment, relativeToAttachment) {
  var left = attachment.left;
  var top = attachment.top;

  if (left === 'auto') {
    left = MIRROR_LR[relativeToAttachment.left];
  }

  if (top === 'auto') {
    top = MIRROR_TB[relativeToAttachment.top];
  }

  return { left: left, top: top };
};

var attachmentToOffset = function attachmentToOffset(attachment) {
  var left = attachment.left;
  var top = attachment.top;

  if (typeof OFFSET_MAP[attachment.left] !== 'undefined') {
    left = OFFSET_MAP[attachment.left];
  }

  if (typeof OFFSET_MAP[attachment.top] !== 'undefined') {
    top = OFFSET_MAP[attachment.top];
  }

  return { left: left, top: top };
};

function addOffset() {
  var out = { top: 0, left: 0 };

  for (var _len = arguments.length, offsets = Array(_len), _key = 0; _key < _len; _key++) {
    offsets[_key] = arguments[_key];
  }

  offsets.forEach(function (_ref) {
    var top = _ref.top;
    var left = _ref.left;

    if (typeof top === 'string') {
      top = parseFloat(top, 10);
    }
    if (typeof left === 'string') {
      left = parseFloat(left, 10);
    }

    out.top += top;
    out.left += left;
  });

  return out;
}

function offsetToPx(offset, size) {
  if (typeof offset.left === 'string' && offset.left.indexOf('%') !== -1) {
    offset.left = parseFloat(offset.left, 10) / 100 * size.width;
  }
  if (typeof offset.top === 'string' && offset.top.indexOf('%') !== -1) {
    offset.top = parseFloat(offset.top, 10) / 100 * size.height;
  }

  return offset;
}

var parseOffset = function parseOffset(value) {
  var _value$split = value.split(' ');

  var _value$split2 = _slicedToArray(_value$split, 2);

  var top = _value$split2[0];
  var left = _value$split2[1];

  return { top: top, left: left };
};
var parseAttachment = parseOffset;

var TetherClass = (function (_Evented) {
  _inherits(TetherClass, _Evented);

  function TetherClass(options) {
    var _this = this;

    _classCallCheck(this, TetherClass);

    _get(Object.getPrototypeOf(TetherClass.prototype), 'constructor', this).call(this);
    this.position = this.position.bind(this);

    tethers.push(this);

    this.history = [];

    this.setOptions(options, false);

    TetherBase.modules.forEach(function (module) {
      if (typeof module.initialize !== 'undefined') {
        module.initialize.call(_this);
      }
    });

    this.position();
  }

  _createClass(TetherClass, [{
    key: 'getClass',
    value: function getClass() {
      var key = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
      var classes = this.options.classes;

      if (typeof classes !== 'undefined' && classes[key]) {
        return this.options.classes[key];
      } else if (this.options.classPrefix) {
        return this.options.classPrefix + '-' + key;
      } else {
        return key;
      }
    }
  }, {
    key: 'setOptions',
    value: function setOptions(options) {
      var _this2 = this;

      var pos = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];

      var defaults = {
        offset: '0 0',
        targetOffset: '0 0',
        targetAttachment: 'auto auto',
        classPrefix: 'tether'
      };

      this.options = extend(defaults, options);

      var _options = this.options;
      var element = _options.element;
      var target = _options.target;
      var targetModifier = _options.targetModifier;

      this.element = element;
      this.target = target;
      this.targetModifier = targetModifier;

      if (this.target === 'viewport') {
        this.target = document.body;
        this.targetModifier = 'visible';
      } else if (this.target === 'scroll-handle') {
        this.target = document.body;
        this.targetModifier = 'scroll-handle';
      }

      ['element', 'target'].forEach(function (key) {
        if (typeof _this2[key] === 'undefined') {
          throw new Error('Tether Error: Both element and target must be defined');
        }

        if (typeof _this2[key].jquery !== 'undefined') {
          _this2[key] = _this2[key][0];
        } else if (typeof _this2[key] === 'string') {
          _this2[key] = document.querySelector(_this2[key]);
        }
      });

      addClass(this.element, this.getClass('element'));
      if (!(this.options.addTargetClasses === false)) {
        addClass(this.target, this.getClass('target'));
      }

      if (!this.options.attachment) {
        throw new Error('Tether Error: You must provide an attachment');
      }

      this.targetAttachment = parseAttachment(this.options.targetAttachment);
      this.attachment = parseAttachment(this.options.attachment);
      this.offset = parseOffset(this.options.offset);
      this.targetOffset = parseOffset(this.options.targetOffset);

      if (typeof this.scrollParents !== 'undefined') {
        this.disable();
      }

      if (this.targetModifier === 'scroll-handle') {
        this.scrollParents = [this.target];
      } else {
        this.scrollParents = getScrollParents(this.target);
      }

      if (!(this.options.enabled === false)) {
        this.enable(pos);
      }
    }
  }, {
    key: 'getTargetBounds',
    value: function getTargetBounds() {
      if (typeof this.targetModifier !== 'undefined') {
        if (this.targetModifier === 'visible') {
          if (this.target === document.body) {
            return { top: pageYOffset, left: pageXOffset, height: innerHeight, width: innerWidth };
          } else {
            var bounds = getBounds(this.target);

            var out = {
              height: bounds.height,
              width: bounds.width,
              top: bounds.top,
              left: bounds.left
            };

            out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));
            out.height = Math.min(out.height, bounds.height - (bounds.top + bounds.height - (pageYOffset + innerHeight)));
            out.height = Math.min(innerHeight, out.height);
            out.height -= 2;

            out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));
            out.width = Math.min(out.width, bounds.width - (bounds.left + bounds.width - (pageXOffset + innerWidth)));
            out.width = Math.min(innerWidth, out.width);
            out.width -= 2;

            if (out.top < pageYOffset) {
              out.top = pageYOffset;
            }
            if (out.left < pageXOffset) {
              out.left = pageXOffset;
            }

            return out;
          }
        } else if (this.targetModifier === 'scroll-handle') {
          var bounds = undefined;
          var target = this.target;
          if (target === document.body) {
            target = document.documentElement;

            bounds = {
              left: pageXOffset,
              top: pageYOffset,
              height: innerHeight,
              width: innerWidth
            };
          } else {
            bounds = getBounds(target);
          }

          var style = getComputedStyle(target);

          var hasBottomScroll = target.scrollWidth > target.clientWidth || [style.overflow, style.overflowX].indexOf('scroll') >= 0 || this.target !== document.body;

          var scrollBottom = 0;
          if (hasBottomScroll) {
            scrollBottom = 15;
          }

          var height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;

          var out = {
            width: 15,
            height: height * 0.975 * (height / target.scrollHeight),
            left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15
          };

          var fitAdj = 0;
          if (height < 408 && this.target === document.body) {
            fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;
          }

          if (this.target !== document.body) {
            out.height = Math.max(out.height, 24);
          }

          var scrollPercentage = this.target.scrollTop / (target.scrollHeight - height);
          out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);

          if (this.target === document.body) {
            out.height = Math.max(out.height, 24);
          }

          return out;
        }
      } else {
        return getBounds(this.target);
      }
    }
  }, {
    key: 'clearCache',
    value: function clearCache() {
      this._cache = {};
    }
  }, {
    key: 'cache',
    value: function cache(k, getter) {
      // More than one module will often need the same DOM info, so
      // we keep a cache which is cleared on each position call
      if (typeof this._cache === 'undefined') {
        this._cache = {};
      }

      if (typeof this._cache[k] === 'undefined') {
        this._cache[k] = getter.call(this);
      }

      return this._cache[k];
    }
  }, {
    key: 'enable',
    value: function enable() {
      var _this3 = this;

      var pos = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

      if (!(this.options.addTargetClasses === false)) {
        addClass(this.target, this.getClass('enabled'));
      }
      addClass(this.element, this.getClass('enabled'));
      this.enabled = true;

      this.scrollParents.forEach(function (parent) {
        if (parent !== _this3.target.ownerDocument) {
          parent.addEventListener('scroll', _this3.position);
        }
      });

      if (pos) {
        this.position();
      }
    }
  }, {
    key: 'disable',
    value: function disable() {
      var _this4 = this;

      removeClass(this.target, this.getClass('enabled'));
      removeClass(this.element, this.getClass('enabled'));
      this.enabled = false;

      if (typeof this.scrollParents !== 'undefined') {
        this.scrollParents.forEach(function (parent) {
          parent.removeEventListener('scroll', _this4.position);
        });
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var _this5 = this;

      this.disable();

      tethers.forEach(function (tether, i) {
        if (tether === _this5) {
          tethers.splice(i, 1);
        }
      });

      // Remove any elements we were using for convenience from the DOM
      if (tethers.length === 0) {
        removeUtilElements();
      }
    }
  }, {
    key: 'updateAttachClasses',
    value: function updateAttachClasses(elementAttach, targetAttach) {
      var _this6 = this;

      elementAttach = elementAttach || this.attachment;
      targetAttach = targetAttach || this.targetAttachment;
      var sides = ['left', 'top', 'bottom', 'right', 'middle', 'center'];

      if (typeof this._addAttachClasses !== 'undefined' && this._addAttachClasses.length) {
        // updateAttachClasses can be called more than once in a position call, so
        // we need to clean up after ourselves such that when the last defer gets
        // ran it doesn't add any extra classes from previous calls.
        this._addAttachClasses.splice(0, this._addAttachClasses.length);
      }

      if (typeof this._addAttachClasses === 'undefined') {
        this._addAttachClasses = [];
      }
      var add = this._addAttachClasses;

      if (elementAttach.top) {
        add.push(this.getClass('element-attached') + '-' + elementAttach.top);
      }
      if (elementAttach.left) {
        add.push(this.getClass('element-attached') + '-' + elementAttach.left);
      }
      if (targetAttach.top) {
        add.push(this.getClass('target-attached') + '-' + targetAttach.top);
      }
      if (targetAttach.left) {
        add.push(this.getClass('target-attached') + '-' + targetAttach.left);
      }

      var all = [];
      sides.forEach(function (side) {
        all.push(_this6.getClass('element-attached') + '-' + side);
        all.push(_this6.getClass('target-attached') + '-' + side);
      });

      defer(function () {
        if (!(typeof _this6._addAttachClasses !== 'undefined')) {
          return;
        }

        updateClasses(_this6.element, _this6._addAttachClasses, all);
        if (!(_this6.options.addTargetClasses === false)) {
          updateClasses(_this6.target, _this6._addAttachClasses, all);
        }

        delete _this6._addAttachClasses;
      });
    }
  }, {
    key: 'position',
    value: function position() {
      var _this7 = this;

      var flushChanges = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

      // flushChanges commits the changes immediately, leave true unless you are positioning multiple
      // tethers (in which case call Tether.Utils.flush yourself when you're done)

      if (!this.enabled) {
        return;
      }

      this.clearCache();

      // Turn 'auto' attachments into the appropriate corner or edge
      var targetAttachment = autoToFixedAttachment(this.targetAttachment, this.attachment);

      this.updateAttachClasses(this.attachment, targetAttachment);

      var elementPos = this.cache('element-bounds', function () {
        return getBounds(_this7.element);
      });

      var width = elementPos.width;
      var height = elementPos.height;

      if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {
        var _lastSize = this.lastSize;

        // We cache the height and width to make it possible to position elements that are
        // getting hidden.
        width = _lastSize.width;
        height = _lastSize.height;
      } else {
        this.lastSize = { width: width, height: height };
      }

      var targetPos = this.cache('target-bounds', function () {
        return _this7.getTargetBounds();
      });
      var targetSize = targetPos;

      // Get an actual px offset from the attachment
      var offset = offsetToPx(attachmentToOffset(this.attachment), { width: width, height: height });
      var targetOffset = offsetToPx(attachmentToOffset(targetAttachment), targetSize);

      var manualOffset = offsetToPx(this.offset, { width: width, height: height });
      var manualTargetOffset = offsetToPx(this.targetOffset, targetSize);

      // Add the manually provided offset
      offset = addOffset(offset, manualOffset);
      targetOffset = addOffset(targetOffset, manualTargetOffset);

      // It's now our goal to make (element position + offset) == (target position + target offset)
      var left = targetPos.left + targetOffset.left - offset.left;
      var top = targetPos.top + targetOffset.top - offset.top;

      for (var i = 0; i < TetherBase.modules.length; ++i) {
        var _module2 = TetherBase.modules[i];
        var ret = _module2.position.call(this, {
          left: left,
          top: top,
          targetAttachment: targetAttachment,
          targetPos: targetPos,
          elementPos: elementPos,
          offset: offset,
          targetOffset: targetOffset,
          manualOffset: manualOffset,
          manualTargetOffset: manualTargetOffset,
          scrollbarSize: scrollbarSize,
          attachment: this.attachment
        });

        if (ret === false) {
          return false;
        } else if (typeof ret === 'undefined' || typeof ret !== 'object') {
          continue;
        } else {
          top = ret.top;
          left = ret.left;
        }
      }

      // We describe the position three different ways to give the optimizer
      // a chance to decide the best possible way to position the element
      // with the fewest repaints.
      var next = {
        // It's position relative to the page (absolute positioning when
        // the element is a child of the body)
        page: {
          top: top,
          left: left
        },

        // It's position relative to the viewport (fixed positioning)
        viewport: {
          top: top - pageYOffset,
          bottom: pageYOffset - top - height + innerHeight,
          left: left - pageXOffset,
          right: pageXOffset - left - width + innerWidth
        }
      };

      var doc = this.target.ownerDocument;
      var win = doc.defaultView;

      var scrollbarSize = undefined;
      if (win.innerHeight > doc.documentElement.clientHeight) {
        scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);
        next.viewport.bottom -= scrollbarSize.height;
      }

      if (win.innerWidth > doc.documentElement.clientWidth) {
        scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);
        next.viewport.right -= scrollbarSize.width;
      }

      if (['', 'static'].indexOf(doc.body.style.position) === -1 || ['', 'static'].indexOf(doc.body.parentElement.style.position) === -1) {
        // Absolute positioning in the body will be relative to the page, not the 'initial containing block'
        next.page.bottom = doc.body.scrollHeight - top - height;
        next.page.right = doc.body.scrollWidth - left - width;
      }

      if (typeof this.options.optimizations !== 'undefined' && this.options.optimizations.moveElement !== false && !(typeof this.targetModifier !== 'undefined')) {
        (function () {
          var offsetParent = _this7.cache('target-offsetparent', function () {
            return getOffsetParent(_this7.target);
          });
          var offsetPosition = _this7.cache('target-offsetparent-bounds', function () {
            return getBounds(offsetParent);
          });
          var offsetParentStyle = getComputedStyle(offsetParent);
          var offsetParentSize = offsetPosition;

          var offsetBorder = {};
          ['Top', 'Left', 'Bottom', 'Right'].forEach(function (side) {
            offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle['border' + side + 'Width']);
          });

          offsetPosition.right = doc.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;
          offsetPosition.bottom = doc.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;

          if (next.page.top >= offsetPosition.top + offsetBorder.top && next.page.bottom >= offsetPosition.bottom) {
            if (next.page.left >= offsetPosition.left + offsetBorder.left && next.page.right >= offsetPosition.right) {
              // We're within the visible part of the target's scroll parent
              var scrollTop = offsetParent.scrollTop;
              var scrollLeft = offsetParent.scrollLeft;

              // It's position relative to the target's offset parent (absolute positioning when
              // the element is moved to be a child of the target's offset parent).
              next.offset = {
                top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,
                left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left
              };
            }
          }
        })();
      }

      // We could also travel up the DOM and try each containing context, rather than only
      // looking at the body, but we're gonna get diminishing returns.

      this.move(next);

      this.history.unshift(next);

      if (this.history.length > 3) {
        this.history.pop();
      }

      if (flushChanges) {
        flush();
      }

      return true;
    }

    // THE ISSUE
  }, {
    key: 'move',
    value: function move(pos) {
      var _this8 = this;

      if (!(typeof this.element.parentNode !== 'undefined')) {
        return;
      }

      var same = {};

      for (var type in pos) {
        same[type] = {};

        for (var key in pos[type]) {
          var found = false;

          for (var i = 0; i < this.history.length; ++i) {
            var point = this.history[i];
            if (typeof point[type] !== 'undefined' && !within(point[type][key], pos[type][key])) {
              found = true;
              break;
            }
          }

          if (!found) {
            same[type][key] = true;
          }
        }
      }

      var css = { top: '', left: '', right: '', bottom: '' };

      var transcribe = function transcribe(_same, _pos) {
        var hasOptimizations = typeof _this8.options.optimizations !== 'undefined';
        var gpu = hasOptimizations ? _this8.options.optimizations.gpu : null;
        if (gpu !== false) {
          var yPos = undefined,
              xPos = undefined;
          if (_same.top) {
            css.top = 0;
            yPos = _pos.top;
          } else {
            css.bottom = 0;
            yPos = -_pos.bottom;
          }

          if (_same.left) {
            css.left = 0;
            xPos = _pos.left;
          } else {
            css.right = 0;
            xPos = -_pos.right;
          }

          if (window.matchMedia) {
            // HubSpot/tether#207
            var retina = window.matchMedia('only screen and (min-resolution: 1.3dppx)').matches || window.matchMedia('only screen and (-webkit-min-device-pixel-ratio: 1.3)').matches;
            if (!retina) {
              xPos = Math.round(xPos);
              yPos = Math.round(yPos);
            }
          }

          css[transformKey] = 'translateX(' + xPos + 'px) translateY(' + yPos + 'px)';

          if (transformKey !== 'msTransform') {
            // The Z transform will keep this in the GPU (faster, and prevents artifacts),
            // but IE9 doesn't support 3d transforms and will choke.
            css[transformKey] += " translateZ(0)";
          }
        } else {
          if (_same.top) {
            css.top = _pos.top + 'px';
          } else {
            css.bottom = _pos.bottom + 'px';
          }

          if (_same.left) {
            css.left = _pos.left + 'px';
          } else {
            css.right = _pos.right + 'px';
          }
        }
      };

      var moved = false;
      if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {
        css.position = 'absolute';
        transcribe(same.page, pos.page);
      } else if ((same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {
        css.position = 'fixed';
        transcribe(same.viewport, pos.viewport);
      } else if (typeof same.offset !== 'undefined' && same.offset.top && same.offset.left) {
        (function () {
          css.position = 'absolute';
          var offsetParent = _this8.cache('target-offsetparent', function () {
            return getOffsetParent(_this8.target);
          });

          if (getOffsetParent(_this8.element) !== offsetParent) {
            defer(function () {
              _this8.element.parentNode.removeChild(_this8.element);
              offsetParent.appendChild(_this8.element);
            });
          }

          transcribe(same.offset, pos.offset);
          moved = true;
        })();
      } else {
        css.position = 'absolute';
        transcribe({ top: true, left: true }, pos.page);
      }

      if (!moved) {
        if (this.options.bodyElement) {
          if (this.element.parentNode !== this.options.bodyElement) {
            this.options.bodyElement.appendChild(this.element);
          }
        } else {
          var offsetParentIsBody = true;
          var currentNode = this.element.parentNode;
          while (currentNode && currentNode.nodeType === 1 && currentNode.tagName !== 'BODY') {
            if (getComputedStyle(currentNode).position !== 'static') {
              offsetParentIsBody = false;
              break;
            }

            currentNode = currentNode.parentNode;
          }

          if (!offsetParentIsBody) {
            this.element.parentNode.removeChild(this.element);
            this.element.ownerDocument.body.appendChild(this.element);
          }
        }
      }

      // Any css change will trigger a repaint, so let's avoid one if nothing changed
      var writeCSS = {};
      var write = false;
      for (var key in css) {
        var val = css[key];
        var elVal = this.element.style[key];

        if (elVal !== val) {
          write = true;
          writeCSS[key] = val;
        }
      }

      if (write) {
        defer(function () {
          extend(_this8.element.style, writeCSS);
          _this8.trigger('repositioned');
        });
      }
    }
  }]);

  return TetherClass;
})(Evented);

TetherClass.modules = [];

TetherBase.position = position;

var Tether = extend(TetherClass, TetherBase);
/* globals TetherBase */

'use strict';

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

var _TetherBase$Utils = TetherBase.Utils;
var getBounds = _TetherBase$Utils.getBounds;
var extend = _TetherBase$Utils.extend;
var updateClasses = _TetherBase$Utils.updateClasses;
var defer = _TetherBase$Utils.defer;

var BOUNDS_FORMAT = ['left', 'top', 'right', 'bottom'];

function getBoundingRect(tether, to) {
  if (to === 'scrollParent') {
    to = tether.scrollParents[0];
  } else if (to === 'window') {
    to = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset];
  }

  if (to === document) {
    to = to.documentElement;
  }

  if (typeof to.nodeType !== 'undefined') {
    (function () {
      var node = to;
      var size = getBounds(to);
      var pos = size;
      var style = getComputedStyle(to);

      to = [pos.left, pos.top, size.width + pos.left, size.height + pos.top];

      // Account any parent Frames scroll offset
      if (node.ownerDocument !== document) {
        var win = node.ownerDocument.defaultView;
        to[0] += win.pageXOffset;
        to[1] += win.pageYOffset;
        to[2] += win.pageXOffset;
        to[3] += win.pageYOffset;
      }

      BOUNDS_FORMAT.forEach(function (side, i) {
        side = side[0].toUpperCase() + side.substr(1);
        if (side === 'Top' || side === 'Left') {
          to[i] += parseFloat(style['border' + side + 'Width']);
        } else {
          to[i] -= parseFloat(style['border' + side + 'Width']);
        }
      });
    })();
  }

  return to;
}

TetherBase.modules.push({
  position: function position(_ref) {
    var _this = this;

    var top = _ref.top;
    var left = _ref.left;
    var targetAttachment = _ref.targetAttachment;

    if (!this.options.constraints) {
      return true;
    }

    var _cache = this.cache('element-bounds', function () {
      return getBounds(_this.element);
    });

    var height = _cache.height;
    var width = _cache.width;

    if (width === 0 && height === 0 && typeof this.lastSize !== 'undefined') {
      var _lastSize = this.lastSize;

      // Handle the item getting hidden as a result of our positioning without glitching
      // the classes in and out
      width = _lastSize.width;
      height = _lastSize.height;
    }

    var targetSize = this.cache('target-bounds', function () {
      return _this.getTargetBounds();
    });

    var targetHeight = targetSize.height;
    var targetWidth = targetSize.width;

    var allClasses = [this.getClass('pinned'), this.getClass('out-of-bounds')];

    this.options.constraints.forEach(function (constraint) {
      var outOfBoundsClass = constraint.outOfBoundsClass;
      var pinnedClass = constraint.pinnedClass;

      if (outOfBoundsClass) {
        allClasses.push(outOfBoundsClass);
      }
      if (pinnedClass) {
        allClasses.push(pinnedClass);
      }
    });

    allClasses.forEach(function (cls) {
      ['left', 'top', 'right', 'bottom'].forEach(function (side) {
        allClasses.push(cls + '-' + side);
      });
    });

    var addClasses = [];

    var tAttachment = extend({}, targetAttachment);
    var eAttachment = extend({}, this.attachment);

    this.options.constraints.forEach(function (constraint) {
      var to = constraint.to;
      var attachment = constraint.attachment;
      var pin = constraint.pin;

      if (typeof attachment === 'undefined') {
        attachment = '';
      }

      var changeAttachX = undefined,
          changeAttachY = undefined;
      if (attachment.indexOf(' ') >= 0) {
        var _attachment$split = attachment.split(' ');

        var _attachment$split2 = _slicedToArray(_attachment$split, 2);

        changeAttachY = _attachment$split2[0];
        changeAttachX = _attachment$split2[1];
      } else {
        changeAttachX = changeAttachY = attachment;
      }

      var bounds = getBoundingRect(_this, to);

      if (changeAttachY === 'target' || changeAttachY === 'both') {
        if (top < bounds[1] && tAttachment.top === 'top') {
          top += targetHeight;
          tAttachment.top = 'bottom';
        }

        if (top + height > bounds[3] && tAttachment.top === 'bottom') {
          top -= targetHeight;
          tAttachment.top = 'top';
        }
      }

      if (changeAttachY === 'together') {
        if (tAttachment.top === 'top') {
          if (eAttachment.top === 'bottom' && top < bounds[1]) {
            top += targetHeight;
            tAttachment.top = 'bottom';

            top += height;
            eAttachment.top = 'top';
          } else if (eAttachment.top === 'top' && top + height > bounds[3] && top - (height - targetHeight) >= bounds[1]) {
            top -= height - targetHeight;
            tAttachment.top = 'bottom';

            eAttachment.top = 'bottom';
          }
        }

        if (tAttachment.top === 'bottom') {
          if (eAttachment.top === 'top' && top + height > bounds[3]) {
            top -= targetHeight;
            tAttachment.top = 'top';

            top -= height;
            eAttachment.top = 'bottom';
          } else if (eAttachment.top === 'bottom' && top < bounds[1] && top + (height * 2 - targetHeight) <= bounds[3]) {
            top += height - targetHeight;
            tAttachment.top = 'top';

            eAttachment.top = 'top';
          }
        }

        if (tAttachment.top === 'middle') {
          if (top + height > bounds[3] && eAttachment.top === 'top') {
            top -= height;
            eAttachment.top = 'bottom';
          } else if (top < bounds[1] && eAttachment.top === 'bottom') {
            top += height;
            eAttachment.top = 'top';
          }
        }
      }

      if (changeAttachX === 'target' || changeAttachX === 'both') {
        if (left < bounds[0] && tAttachment.left === 'left') {
          left += targetWidth;
          tAttachment.left = 'right';
        }

        if (left + width > bounds[2] && tAttachment.left === 'right') {
          left -= targetWidth;
          tAttachment.left = 'left';
        }
      }

      if (changeAttachX === 'together') {
        if (left < bounds[0] && tAttachment.left === 'left') {
          if (eAttachment.left === 'right') {
            left += targetWidth;
            tAttachment.left = 'right';

            left += width;
            eAttachment.left = 'left';
          } else if (eAttachment.left === 'left') {
            left += targetWidth;
            tAttachment.left = 'right';

            left -= width;
            eAttachment.left = 'right';
          }
        } else if (left + width > bounds[2] && tAttachment.left === 'right') {
          if (eAttachment.left === 'left') {
            left -= targetWidth;
            tAttachment.left = 'left';

            left -= width;
            eAttachment.left = 'right';
          } else if (eAttachment.left === 'right') {
            left -= targetWidth;
            tAttachment.left = 'left';

            left += width;
            eAttachment.left = 'left';
          }
        } else if (tAttachment.left === 'center') {
          if (left + width > bounds[2] && eAttachment.left === 'left') {
            left -= width;
            eAttachment.left = 'right';
          } else if (left < bounds[0] && eAttachment.left === 'right') {
            left += width;
            eAttachment.left = 'left';
          }
        }
      }

      if (changeAttachY === 'element' || changeAttachY === 'both') {
        if (top < bounds[1] && eAttachment.top === 'bottom') {
          top += height;
          eAttachment.top = 'top';
        }

        if (top + height > bounds[3] && eAttachment.top === 'top') {
          top -= height;
          eAttachment.top = 'bottom';
        }
      }

      if (changeAttachX === 'element' || changeAttachX === 'both') {
        if (left < bounds[0]) {
          if (eAttachment.left === 'right') {
            left += width;
            eAttachment.left = 'left';
          } else if (eAttachment.left === 'center') {
            left += width / 2;
            eAttachment.left = 'left';
          }
        }

        if (left + width > bounds[2]) {
          if (eAttachment.left === 'left') {
            left -= width;
            eAttachment.left = 'right';
          } else if (eAttachment.left === 'center') {
            left -= width / 2;
            eAttachment.left = 'right';
          }
        }
      }

      if (typeof pin === 'string') {
        pin = pin.split(',').map(function (p) {
          return p.trim();
        });
      } else if (pin === true) {
        pin = ['top', 'left', 'right', 'bottom'];
      }

      pin = pin || [];

      var pinned = [];
      var oob = [];

      if (top < bounds[1]) {
        if (pin.indexOf('top') >= 0) {
          top = bounds[1];
          pinned.push('top');
        } else {
          oob.push('top');
        }
      }

      if (top + height > bounds[3]) {
        if (pin.indexOf('bottom') >= 0) {
          top = bounds[3] - height;
          pinned.push('bottom');
        } else {
          oob.push('bottom');
        }
      }

      if (left < bounds[0]) {
        if (pin.indexOf('left') >= 0) {
          left = bounds[0];
          pinned.push('left');
        } else {
          oob.push('left');
        }
      }

      if (left + width > bounds[2]) {
        if (pin.indexOf('right') >= 0) {
          left = bounds[2] - width;
          pinned.push('right');
        } else {
          oob.push('right');
        }
      }

      if (pinned.length) {
        (function () {
          var pinnedClass = undefined;
          if (typeof _this.options.pinnedClass !== 'undefined') {
            pinnedClass = _this.options.pinnedClass;
          } else {
            pinnedClass = _this.getClass('pinned');
          }

          addClasses.push(pinnedClass);
          pinned.forEach(function (side) {
            addClasses.push(pinnedClass + '-' + side);
          });
        })();
      }

      if (oob.length) {
        (function () {
          var oobClass = undefined;
          if (typeof _this.options.outOfBoundsClass !== 'undefined') {
            oobClass = _this.options.outOfBoundsClass;
          } else {
            oobClass = _this.getClass('out-of-bounds');
          }

          addClasses.push(oobClass);
          oob.forEach(function (side) {
            addClasses.push(oobClass + '-' + side);
          });
        })();
      }

      if (pinned.indexOf('left') >= 0 || pinned.indexOf('right') >= 0) {
        eAttachment.left = tAttachment.left = false;
      }
      if (pinned.indexOf('top') >= 0 || pinned.indexOf('bottom') >= 0) {
        eAttachment.top = tAttachment.top = false;
      }

      if (tAttachment.top !== targetAttachment.top || tAttachment.left !== targetAttachment.left || eAttachment.top !== _this.attachment.top || eAttachment.left !== _this.attachment.left) {
        _this.updateAttachClasses(eAttachment, tAttachment);
        _this.trigger('update', {
          attachment: eAttachment,
          targetAttachment: tAttachment
        });
      }
    });

    defer(function () {
      if (!(_this.options.addTargetClasses === false)) {
        updateClasses(_this.target, addClasses, allClasses);
      }
      updateClasses(_this.element, addClasses, allClasses);
    });

    return { top: top, left: left };
  }
});
/* globals TetherBase */

'use strict';

var _TetherBase$Utils = TetherBase.Utils;
var getBounds = _TetherBase$Utils.getBounds;
var updateClasses = _TetherBase$Utils.updateClasses;
var defer = _TetherBase$Utils.defer;

TetherBase.modules.push({
  position: function position(_ref) {
    var _this = this;

    var top = _ref.top;
    var left = _ref.left;

    var _cache = this.cache('element-bounds', function () {
      return getBounds(_this.element);
    });

    var height = _cache.height;
    var width = _cache.width;

    var targetPos = this.getTargetBounds();

    var bottom = top + height;
    var right = left + width;

    var abutted = [];
    if (top <= targetPos.bottom && bottom >= targetPos.top) {
      ['left', 'right'].forEach(function (side) {
        var targetPosSide = targetPos[side];
        if (targetPosSide === left || targetPosSide === right) {
          abutted.push(side);
        }
      });
    }

    if (left <= targetPos.right && right >= targetPos.left) {
      ['top', 'bottom'].forEach(function (side) {
        var targetPosSide = targetPos[side];
        if (targetPosSide === top || targetPosSide === bottom) {
          abutted.push(side);
        }
      });
    }

    var allClasses = [];
    var addClasses = [];

    var sides = ['left', 'top', 'right', 'bottom'];
    allClasses.push(this.getClass('abutted'));
    sides.forEach(function (side) {
      allClasses.push(_this.getClass('abutted') + '-' + side);
    });

    if (abutted.length) {
      addClasses.push(this.getClass('abutted'));
    }

    abutted.forEach(function (side) {
      addClasses.push(_this.getClass('abutted') + '-' + side);
    });

    defer(function () {
      if (!(_this.options.addTargetClasses === false)) {
        updateClasses(_this.target, addClasses, allClasses);
      }
      updateClasses(_this.element, addClasses, allClasses);
    });

    return true;
  }
});
/* globals TetherBase */

'use strict';

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

TetherBase.modules.push({
  position: function position(_ref) {
    var top = _ref.top;
    var left = _ref.left;

    if (!this.options.shift) {
      return;
    }

    var shift = this.options.shift;
    if (typeof this.options.shift === 'function') {
      shift = this.options.shift.call(this, { top: top, left: left });
    }

    var shiftTop = undefined,
        shiftLeft = undefined;
    if (typeof shift === 'string') {
      shift = shift.split(' ');
      shift[1] = shift[1] || shift[0];

      var _shift = shift;

      var _shift2 = _slicedToArray(_shift, 2);

      shiftTop = _shift2[0];
      shiftLeft = _shift2[1];

      shiftTop = parseFloat(shiftTop, 10);
      shiftLeft = parseFloat(shiftLeft, 10);
    } else {
      shiftTop = shift.top;
      shiftLeft = shift.left;
    }

    top += shiftTop;
    left += shiftLeft;

    return { top: top, left: left };
  }
});
return Tether;

}));


/***/ }),
/* 12 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var CaliforniaApp_1 = __webpack_require__(3);
CaliforniaApp_1.CaliforniaApp.CaliforniaAppInstance = new CaliforniaApp_1.CaliforniaApp();
if (!Array.prototype.find) {
    Object.defineProperty(Array.prototype, 'find', {
        value: function value(predicate) {
            if (this == null) {
                throw new TypeError('"this" is null or not defined');
            }
            var o = Object(this);
            var len = o.length >>> 0;
            if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
            }
            var thisArg = arguments[1];
            var k = 0;
            while (k < len) {
                var kValue = o[k];
                if (predicate.call(thisArg, kValue, k, o)) {
                    return kValue;
                }
                k++;
            }
            return undefined;
        }
    });
}
if (!Array.prototype.findIndex) {
    Object.defineProperty(Array.prototype, 'findIndex', {
        value: function value(predicate) {
            if (this == null) {
                throw new TypeError('"this" is null or not defined');
            }
            var o = Object(this);
            var len = o.length >>> 0;
            if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
            }
            var thisArg = arguments[1];
            var k = 0;
            while (k < len) {
                var kValue = o[k];
                if (predicate.call(thisArg, kValue, k, o)) {
                    return k;
                }
                k++;
            }
            return -1;
        }
    });
}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var helpers = __webpack_require__(16);
var currentApp;
var CaliforniaController = function () {
    function CaliforniaController(californiaAppArg) {
        var _this = this;
        this.beforeSendAjax = function (jqXHR, settings) {
            if (currentApp.isAjaxRequestRunning === true) {
                console.log("ignored request (ajax call still in progress)");
                return false;
            }
            currentApp.isAjaxRequestRunning = true;
            jqXHR.done(function (xhr) {
                currentApp.isAjaxRequestRunning = false;
            }).fail(function (xhr) {
                currentApp.isAjaxRequestRunning = false;
                currentApp.projector.scheduleRender();
            });
        };
        this.LogoutAction = function () {
            return helpers.Action("/california/Logout", "post", null, _this.beforeSendAjax);
        };
        this.IndexAction = function (id, token) {
            return helpers.Action("/california/Index" + encodeURIComponent(id) + "?token=" + encodeURIComponent(token), "get", null, _this.beforeSendAjax);
        };
        this.DeleteLayoutStyleInteractionJson = function (layoutStyleInteractionId) {
            return helpers.Json("/california/DeleteLayoutStyleInteraction?layoutStyleInteractionId=" + layoutStyleInteractionId, "post", null, _this.beforeSendAjax);
        };
        this.DeleteStyleValueInteractionJson = function (layoutStyleInteractionId, styleValueId) {
            return helpers.Json("/california/DeleteStyleValueInteraction?layoutStyleInteractionId=" + layoutStyleInteractionId + "&styleValueId=" + styleValueId, "post", null, _this.beforeSendAjax);
        };
        this.CreateLayoutStyleInteractionForLayoutAtomJson = function (layoutAtomId) {
            return helpers.Json("/california/CreateLayoutStyleInteractionForLayoutAtom?layoutAtomId=" + layoutAtomId, "post", null, _this.beforeSendAjax);
        };
        this.pubAction = function (view, id) {
            return helpers.Action("/california/pub" + encodeURIComponent(id) + "?view=" + encodeURIComponent(view), "get", null, _this.beforeSendAjax);
        };
        this.StaticCssAction = function (id) {
            return helpers.Action("/california/StaticCss" + encodeURIComponent(id), "get", null, _this.beforeSendAjax);
        };
        this.StaticJsAction = function (id) {
            return helpers.Action("/california/StaticJs" + encodeURIComponent(id), "get", null, _this.beforeSendAjax);
        };
        this.PublishAction = function (californiaProjectId, view) {
            return helpers.Action("/california/Publish?californiaProjectId=" + californiaProjectId + "&view=" + encodeURIComponent(view), "post", null, _this.beforeSendAjax);
        };
        this.InitialClientDataJson = function (jsTimeString) {
            return helpers.Json("/california/InitialClientData?jsTimeString=" + encodeURIComponent(jsTimeString), "post", null, _this.beforeSendAjax);
        };
        this.SetSpecialLayoutBoxTypeJson = function (layoutBoxId, specialLayoutBoxType) {
            return helpers.Json("/california/SetSpecialLayoutBoxType?layoutBoxId=" + layoutBoxId + "&specialLayoutBoxType=" + specialLayoutBoxType, "post", null, _this.beforeSendAjax);
        };
        this.DeleteStyleQuantumJson = function (styleQuantumId) {
            return helpers.Json("/california/DeleteStyleQuantum?styleQuantumId=" + styleQuantumId, "post", null, _this.beforeSendAjax);
        };
        this.DeleteLayoutJson = function (layoutBaseId, isOnlyBelow) {
            return helpers.Json("/california/DeleteLayout?layoutBaseId=" + layoutBaseId + "&isOnlyBelow=" + isOnlyBelow, "post", null, _this.beforeSendAjax);
        };
        this.SetStyleMoleculeAsReferenceStyleJson = function (styleMoleculeId) {
            return helpers.Json("/california/SetStyleMoleculeAsReferenceStyle?styleMoleculeId=" + styleMoleculeId, "post", null, _this.beforeSendAjax);
        };
        this.SetStyleMoleculeReferenceJson = function (styleMoleculeId, referenceStyleMoleculeId) {
            return helpers.Json("/california/SetStyleMoleculeReference?styleMoleculeId=" + styleMoleculeId + "&referenceStyleMoleculeId=" + referenceStyleMoleculeId, "post", null, _this.beforeSendAjax);
        };
        this.SyncStyleMoleculeToReferenceStyleJson = function (styleMoleculeId) {
            return helpers.Json("/california/SyncStyleMoleculeToReferenceStyle?styleMoleculeId=" + styleMoleculeId, "post", null, _this.beforeSendAjax);
        };
        this.SyncStyleMoleculeFromReferenceStyleJson = function (styleMoleculeId) {
            return helpers.Json("/california/SyncStyleMoleculeFromReferenceStyle?styleMoleculeId=" + styleMoleculeId, "post", null, _this.beforeSendAjax);
        };
        this.SyncLayoutStylesImitatingReferenceLayoutJson = function (targetLayoutMoleculeId, referenceLayoutMoleculeId) {
            return helpers.Json("/california/SyncLayoutStylesImitatingReferenceLayout?targetLayoutMoleculeId=" + targetLayoutMoleculeId + "&referenceLayoutMoleculeId=" + referenceLayoutMoleculeId, "post", null, _this.beforeSendAjax);
        };
        this.SetLayoutBoxCountForRowOrBoxJson = function (layoutRowId, boxStyleMoleculeId, targetBoxCount, isFitWidth) {
            return helpers.Json("/california/SetLayoutBoxCountForRowOrBox?layoutRowId=" + layoutRowId + "&boxStyleMoleculeId=" + boxStyleMoleculeId + "&targetBoxCount=" + targetBoxCount + "&isFitWidth=" + isFitWidth, "post", null, _this.beforeSendAjax);
        };
        this.CreateStyleValueForAtomJson = function (styleAtomId, cssProperty) {
            return helpers.Json("/california/CreateStyleValueForAtom?styleAtomId=" + styleAtomId + "&cssProperty=" + encodeURIComponent(cssProperty), "post", null, _this.beforeSendAjax);
        };
        this.CreateCaliforniaViewJson = function (californiaProjectId, californiaViewName) {
            return helpers.Json("/california/CreateCaliforniaView?californiaProjectId=" + californiaProjectId + "&californiaViewName=" + encodeURIComponent(californiaViewName), "post", null, _this.beforeSendAjax);
        };
        this.CreateCaliforniaViewFromReferenceViewJson = function (californiaProjectId, californiaViewName, referenceCaliforniaViewId) {
            return helpers.Json("/california/CreateCaliforniaViewFromReferenceView?californiaProjectId=" + californiaProjectId + "&californiaViewName=" + encodeURIComponent(californiaViewName) + "&referenceCaliforniaViewId=" + referenceCaliforniaViewId, "post", null, _this.beforeSendAjax);
        };
        this.DeleteCaliforniaViewJson = function (californiaViewId) {
            return helpers.Json("/california/DeleteCaliforniaView?californiaViewId=" + californiaViewId, "post", null, _this.beforeSendAjax);
        };
        this.CreateStyleValueInteractionJson = function (layoutStyleInteractionId, styleValueId, cssValue) {
            return helpers.Json("/california/CreateStyleValueInteraction?layoutStyleInteractionId=" + layoutStyleInteractionId + "&styleValueId=" + styleValueId + "&cssValue=" + encodeURIComponent(cssValue), "post", null, _this.beforeSendAjax);
        };
        this.CreateStyleAtomForMoleculeJson = function (styleMoleculeId, styleAtomType, responsiveDeviceId, stateModifier) {
            return helpers.Json("/california/CreateStyleAtomForMolecule?styleMoleculeId=" + styleMoleculeId + "&styleAtomType=" + styleAtomType + "&responsiveDeviceId=" + responsiveDeviceId + "&stateModifier=" + encodeURIComponent(stateModifier), "post", null, _this.beforeSendAjax);
        };
        this.DeleteStyleAtomJson = function (styleAtomId) {
            return helpers.Json("/california/DeleteStyleAtom?styleAtomId=" + styleAtomId, "post", null, _this.beforeSendAjax);
        };
        this.ApplyStyleQuantumToAtomJson = function (styleAtomId, styleQuantumId) {
            return helpers.Json("/california/ApplyStyleQuantumToAtom?styleAtomId=" + styleAtomId + "&styleQuantumId=" + styleQuantumId, "post", null, _this.beforeSendAjax);
        };
        this.CreateStyleQuantumJson = function (californiaProjectId, quantumName, cssProperty, cssValue) {
            return helpers.Json("/california/CreateStyleQuantum?californiaProjectId=" + californiaProjectId + "&quantumName=" + encodeURIComponent(quantumName) + "&cssProperty=" + encodeURIComponent(cssProperty) + "&cssValue=" + encodeURIComponent(cssValue), "post", null, _this.beforeSendAjax);
        };
        this.UpdateTextContentAtomJson = function (contentAtomId, updatedTextContent) {
            return helpers.Json("/california/UpdateTextContentAtom?contentAtomId=" + contentAtomId + "&updatedTextContent=" + encodeURIComponent(updatedTextContent), "post", null, _this.beforeSendAjax);
        };
        this.UpdateStyleQuantumJson = function (styleQuantumId, cssValue) {
            return helpers.Json("/california/UpdateStyleQuantum?styleQuantumId=" + styleQuantumId + "&cssValue=" + encodeURIComponent(cssValue), "post", null, _this.beforeSendAjax);
        };
        this.UpdateStyleValueJson = function (styleValueId, cssValue) {
            return helpers.Json("/california/UpdateStyleValue?styleValueId=" + styleValueId + "&cssValue=" + encodeURIComponent(cssValue), "post", null, _this.beforeSendAjax);
        };
        this.UpdateUserDefinedCssForProjectJson = function (californiaProjectId, cssValue) {
            return helpers.Json("/california/UpdateUserDefinedCssForProject?californiaProjectId=" + californiaProjectId + "&cssValue=" + encodeURIComponent(cssValue), "post", null, _this.beforeSendAjax);
        };
        this.UpdateUserDefinedCssForViewJson = function (californiaViewId, cssValue) {
            return helpers.Json("/california/UpdateUserDefinedCssForView?californiaViewId=" + californiaViewId + "&cssValue=" + encodeURIComponent(cssValue), "post", null, _this.beforeSendAjax);
        };
        this.DeleteStyleValueJson = function (styleValueId) {
            return helpers.Json("/california/DeleteStyleValue?styleValueId=" + styleValueId, "post", null, _this.beforeSendAjax);
        };
        this.DuplicateStyleQuantumJson = function (styleQuantumId) {
            return helpers.Json("/california/DuplicateStyleQuantum?styleQuantumId=" + styleQuantumId, "post", null, _this.beforeSendAjax);
        };
        this.CreateLayoutAtomForBoxJson = function (targetLayoutBoxId, referenceLayoutAtomId) {
            return helpers.Json("/california/CreateLayoutAtomForBox?targetLayoutBoxId=" + targetLayoutBoxId + "&referenceLayoutAtomId=" + referenceLayoutAtomId, "post", null, _this.beforeSendAjax);
        };
        this.CreateLayoutBoxForBoxOrRowJson = function (targetLayoutBoxOrRowId, referenceLayoutBoxId) {
            return helpers.Json("/california/CreateLayoutBoxForBoxOrRow?targetLayoutBoxOrRowId=" + targetLayoutBoxOrRowId + "&referenceLayoutBoxId=" + referenceLayoutBoxId, "post", null, _this.beforeSendAjax);
        };
        this.CreateLayoutBoxForAtomInPlaceJson = function (targetLayoutAtomId, referenceLayoutBoxId) {
            return helpers.Json("/california/CreateLayoutBoxForAtomInPlace?targetLayoutAtomId=" + targetLayoutAtomId + "&referenceLayoutBoxId=" + referenceLayoutBoxId, "post", null, _this.beforeSendAjax);
        };
        this.CreateLayoutRowForViewJson = function (targetCaliforniaViewId, referenceLayoutRowId) {
            return helpers.Json("/california/CreateLayoutRowForView?targetCaliforniaViewId=" + targetCaliforniaViewId + "&referenceLayoutRowId=" + referenceLayoutRowId, "post", null, _this.beforeSendAjax);
        };
        this.SetLayoutRowOrBoxAsInstanceableJson = function (californiaProjectId, layoutRowOrBoxId) {
            return helpers.Json("/california/SetLayoutRowOrBoxAsInstanceable?californiaProjectId=" + californiaProjectId + "&layoutRowOrBoxId=" + layoutRowOrBoxId, "post", null, _this.beforeSendAjax);
        };
        this.MoveStyleAtomToResponsiveDeviceJson = function (styleAtomId, targetResponsiveDeviceId) {
            return helpers.Json("/california/MoveStyleAtomToResponsiveDevice?styleAtomId=" + styleAtomId + "&targetResponsiveDeviceId=" + targetResponsiveDeviceId, "post", null, _this.beforeSendAjax);
        };
        this.RefreshExternalApisAction = function () {
            return helpers.Action("/california/RefreshExternalApis", "get", null, _this.beforeSendAjax);
        };
        this.MoveLayoutMoleculeIntoLayoutMoleculeJson = function (movedLayoutMoleculeId, targetContainerLayoutMoleculeId) {
            return helpers.Json("/california/MoveLayoutMoleculeIntoLayoutMolecule?movedLayoutMoleculeId=" + movedLayoutMoleculeId + "&targetContainerLayoutMoleculeId=" + targetContainerLayoutMoleculeId, "post", null, _this.beforeSendAjax);
        };
        this.MoveLayoutMoleculeNextToLayoutMoleculeJson = function (movedLayoutMoleculeId, targetNeighborLayoutMoleculeId, isMoveBefore) {
            return helpers.Json("/california/MoveLayoutMoleculeNextToLayoutMolecule?movedLayoutMoleculeId=" + movedLayoutMoleculeId + "&targetNeighborLayoutMoleculeId=" + targetNeighborLayoutMoleculeId + "&isMoveBefore=" + isMoveBefore, "post", null, _this.beforeSendAjax);
        };
        currentApp = californiaAppArg;
    }
    return CaliforniaController;
}();
exports.CaliforniaController = CaliforniaController;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(jQuery) {

Object.defineProperty(exports, "__esModule", { value: true });
function Json(url, method, data, beforeSendCallback) {
    var request;
    if (data !== null) {
        request = jQuery.ajax(url, { method: method, data: JSON.stringify(data), contentType: "application/json; charset=utf-8", beforeSend: beforeSendCallback });
    } else {
        request = jQuery.ajax(url, { method: method, beforeSend: beforeSendCallback });
    }
    request.fail(function (data) {
        if (data.responseJSON !== undefined && data.responseJSON.StatusText !== undefined) {
            console.log(data.responseJSON.StatusText);
        }
    });
    return request;
}
exports.Json = Json;
;
function Action(url, method, data, beforeSendCallback) {
    var request;
    if (data !== null) {
        request = jQuery.ajax(url, { method: method, data: JSON.stringify(data), contentType: "application/json; charset=utf-8", beforeSend: beforeSendCallback });
    } else {
        request = jQuery.ajax(url, { method: method, beforeSend: beforeSendCallback });
    }
    request.fail(function (data) {
        if (data.statusText !== undefined) {
            console.log(data.statusText);
        }
    });
    return request;
}
exports.Action = Action;
;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var CaliforniaEvent;
(function (CaliforniaEvent) {
    CaliforniaEvent[CaliforniaEvent["ReadInitialClientData"] = 0] = "ReadInitialClientData";
    CaliforniaEvent[CaliforniaEvent["CreateStore"] = 1] = "CreateStore";
    CaliforniaEvent[CaliforniaEvent["ReadStore"] = 2] = "ReadStore";
    CaliforniaEvent[CaliforniaEvent["CreateStyleQuantum"] = 3] = "CreateStyleQuantum";
    CaliforniaEvent[CaliforniaEvent["DuplicateStyleQuantum"] = 4] = "DuplicateStyleQuantum";
    CaliforniaEvent[CaliforniaEvent["DeleteStyleQuantum"] = 5] = "DeleteStyleQuantum";
    CaliforniaEvent[CaliforniaEvent["DeleteStyleValue"] = 6] = "DeleteStyleValue";
    CaliforniaEvent[CaliforniaEvent["CreateStyleValueForAtom"] = 7] = "CreateStyleValueForAtom";
    CaliforniaEvent[CaliforniaEvent["UpdateStyleValue"] = 8] = "UpdateStyleValue";
    CaliforniaEvent[CaliforniaEvent["UpdateStyleQuantum"] = 9] = "UpdateStyleQuantum";
    CaliforniaEvent[CaliforniaEvent["ApplyStyleQuantumToAtom"] = 10] = "ApplyStyleQuantumToAtom";
    CaliforniaEvent[CaliforniaEvent["CreateStyleAtomForMolecule"] = 11] = "CreateStyleAtomForMolecule";
    CaliforniaEvent[CaliforniaEvent["DeleteStyleAtom"] = 12] = "DeleteStyleAtom";
    CaliforniaEvent[CaliforniaEvent["UpdateContentAtom"] = 13] = "UpdateContentAtom";
    CaliforniaEvent[CaliforniaEvent["CreateLayoutAtomForBox"] = 14] = "CreateLayoutAtomForBox";
    CaliforniaEvent[CaliforniaEvent["CreateLayoutRowForView"] = 15] = "CreateLayoutRowForView";
    CaliforniaEvent[CaliforniaEvent["DeleteLayout"] = 16] = "DeleteLayout";
    CaliforniaEvent[CaliforniaEvent["SetBoxCount"] = 17] = "SetBoxCount";
    CaliforniaEvent[CaliforniaEvent["CreateLayoutBoxForBoxOrRow"] = 18] = "CreateLayoutBoxForBoxOrRow";
    CaliforniaEvent[CaliforniaEvent["MoveStyleAtomToResponsiveDevice"] = 19] = "MoveStyleAtomToResponsiveDevice";
    CaliforniaEvent[CaliforniaEvent["SetStyleMoleculeReference"] = 20] = "SetStyleMoleculeReference";
    CaliforniaEvent[CaliforniaEvent["SetStyleMoleculeAsReference"] = 21] = "SetStyleMoleculeAsReference";
    CaliforniaEvent[CaliforniaEvent["SetLayoutMoleculeAsInstanceable"] = 22] = "SetLayoutMoleculeAsInstanceable";
    CaliforniaEvent[CaliforniaEvent["SyncStyleMoleculeToReference"] = 23] = "SyncStyleMoleculeToReference";
    CaliforniaEvent[CaliforniaEvent["SyncStyleMoleculeFromReference"] = 24] = "SyncStyleMoleculeFromReference";
    CaliforniaEvent[CaliforniaEvent["MoveLayoutMoleculeIntoLayoutMolecule"] = 25] = "MoveLayoutMoleculeIntoLayoutMolecule";
    CaliforniaEvent[CaliforniaEvent["MoveLayoutMoleculeNextToLayoutMolecule"] = 26] = "MoveLayoutMoleculeNextToLayoutMolecule";
    CaliforniaEvent[CaliforniaEvent["Publish"] = 27] = "Publish";
    CaliforniaEvent[CaliforniaEvent["View"] = 28] = "View";
    CaliforniaEvent[CaliforniaEvent["CreateCaliforniaView"] = 29] = "CreateCaliforniaView";
    CaliforniaEvent[CaliforniaEvent["DeleteCaliforniaView"] = 30] = "DeleteCaliforniaView";
    CaliforniaEvent[CaliforniaEvent["CreateLayoutStyleInteraction"] = 31] = "CreateLayoutStyleInteraction";
    CaliforniaEvent[CaliforniaEvent["CreateStyleValueInteraction"] = 32] = "CreateStyleValueInteraction";
    CaliforniaEvent[CaliforniaEvent["DeleteLayoutStyleInteraction"] = 33] = "DeleteLayoutStyleInteraction";
    CaliforniaEvent[CaliforniaEvent["CreateLayoutBoxForAtomInPlace"] = 34] = "CreateLayoutBoxForAtomInPlace";
    CaliforniaEvent[CaliforniaEvent["SyncLayoutStylesImitatingReference"] = 35] = "SyncLayoutStylesImitatingReference";
    CaliforniaEvent[CaliforniaEvent["CreateCaliforniaViewFromReferenceView"] = 36] = "CreateCaliforniaViewFromReferenceView";
    CaliforniaEvent[CaliforniaEvent["DeleteStyleValueInteraction"] = 37] = "DeleteStyleValueInteraction";
    CaliforniaEvent[CaliforniaEvent["SetSpecialLayoutBoxType"] = 38] = "SetSpecialLayoutBoxType";
    CaliforniaEvent[CaliforniaEvent["ViewJs"] = 39] = "ViewJs";
    CaliforniaEvent[CaliforniaEvent["ViewCss"] = 40] = "ViewCss";
    CaliforniaEvent[CaliforniaEvent["UpdateUserDefinedCssForProject"] = 41] = "UpdateUserDefinedCssForProject";
    CaliforniaEvent[CaliforniaEvent["UpdateUserDefinedCssForView"] = 42] = "UpdateUserDefinedCssForView";
})(CaliforniaEvent = exports.CaliforniaEvent || (exports.CaliforniaEvent = {}));

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var CaliforniaProject = function () {
    function CaliforniaProject() {}
    return CaliforniaProject;
}();
exports.CaliforniaProject = CaliforniaProject;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var CaliforniaUserDefaults = function () {
    function CaliforniaUserDefaults() {}
    return CaliforniaUserDefaults;
}();
exports.CaliforniaUserDefaults = CaliforniaUserDefaults;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var CaliforniaClientViewModel = function () {
    function CaliforniaClientViewModel() {}
    return CaliforniaClientViewModel;
}();
exports.CaliforniaClientViewModel = CaliforniaClientViewModel;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var StyleMolecule = function () {
    function StyleMolecule() {}
    return StyleMolecule;
}();
exports.StyleMolecule = StyleMolecule;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var StyleQuantum = function () {
    function StyleQuantum() {}
    return StyleQuantum;
}();
exports.StyleQuantum = StyleQuantum;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var StyleAtom = function () {
    function StyleAtom() {}
    return StyleAtom;
}();
exports.StyleAtom = StyleAtom;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var StyleAtomType;
(function (StyleAtomType) {
    StyleAtomType[StyleAtomType["Generic"] = 0] = "Generic";
    StyleAtomType[StyleAtomType["Font"] = 1] = "Font";
    StyleAtomType[StyleAtomType["Typography"] = 2] = "Typography";
    StyleAtomType[StyleAtomType["Divider"] = 3] = "Divider";
    StyleAtomType[StyleAtomType["Background"] = 4] = "Background";
    StyleAtomType[StyleAtomType["Spacing"] = 5] = "Spacing";
    StyleAtomType[StyleAtomType["Picture"] = 6] = "Picture";
    StyleAtomType[StyleAtomType["Grid"] = 7] = "Grid";
    StyleAtomType[StyleAtomType["Row"] = 8] = "Row";
    StyleAtomType[StyleAtomType["Navbar"] = 9] = "Navbar";
    StyleAtomType[StyleAtomType["List"] = 10] = "List";
    StyleAtomType[StyleAtomType["Box"] = 11] = "Box";
})(StyleAtomType = exports.StyleAtomType || (exports.StyleAtomType = {}));

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var StyleValue = function () {
    function StyleValue() {}
    return StyleValue;
}();
exports.StyleValue = StyleValue;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var ResponsiveDevice = function () {
    function ResponsiveDevice() {}
    return ResponsiveDevice;
}();
exports.ResponsiveDevice = ResponsiveDevice;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var CaliforniaView = function () {
    function CaliforniaView() {}
    return CaliforniaView;
}();
exports.CaliforniaView = CaliforniaView;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var LayoutRow = function () {
    function LayoutRow() {}
    return LayoutRow;
}();
exports.LayoutRow = LayoutRow;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var LayoutBox = function () {
    function LayoutBox() {}
    return LayoutBox;
}();
exports.LayoutBox = LayoutBox;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var LayoutAtom = function () {
    function LayoutAtom() {}
    return LayoutAtom;
}();
exports.LayoutAtom = LayoutAtom;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var StyleMoleculeAtomMapping = function () {
    function StyleMoleculeAtomMapping() {}
    return StyleMoleculeAtomMapping;
}();
exports.StyleMoleculeAtomMapping = StyleMoleculeAtomMapping;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var ContentAtom = function () {
    function ContentAtom() {}
    return ContentAtom;
}();
exports.ContentAtom = ContentAtom;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var LayoutBase = function () {
    function LayoutBase() {}
    return LayoutBase;
}();
exports.LayoutBase = LayoutBase;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var LayoutType;
(function (LayoutType) {
    LayoutType[LayoutType["Row"] = 0] = "Row";
    LayoutType[LayoutType["Box"] = 1] = "Box";
    LayoutType[LayoutType["Atom"] = 2] = "Atom";
})(LayoutType = exports.LayoutType || (exports.LayoutType = {}));

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var SpecialLayoutBoxType;
(function (SpecialLayoutBoxType) {
    SpecialLayoutBoxType[SpecialLayoutBoxType["Default"] = 0] = "Default";
    SpecialLayoutBoxType[SpecialLayoutBoxType["CaliforniaViewHolder"] = 1] = "CaliforniaViewHolder";
    SpecialLayoutBoxType[SpecialLayoutBoxType["Navigation"] = 2] = "Navigation";
    SpecialLayoutBoxType[SpecialLayoutBoxType["UnsortedList"] = 3] = "UnsortedList";
    SpecialLayoutBoxType[SpecialLayoutBoxType["SortedList"] = 4] = "SortedList";
    SpecialLayoutBoxType[SpecialLayoutBoxType["ListItem"] = 5] = "ListItem";
    SpecialLayoutBoxType[SpecialLayoutBoxType["RichText"] = 6] = "RichText";
})(SpecialLayoutBoxType = exports.SpecialLayoutBoxType || (exports.SpecialLayoutBoxType = {}));

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var LayoutStyleInteraction = function () {
    function LayoutStyleInteraction() {}
    return LayoutStyleInteraction;
}();
exports.LayoutStyleInteraction = LayoutStyleInteraction;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", { value: true });
var maquette = __webpack_require__(1);
var h = maquette.h;
var CaliforniaApp_1 = __webpack_require__(3);
var PagePreviewVM_1 = __webpack_require__(38);
var CaliforniaGenerated_1 = __webpack_require__(2);
var ClientState_1 = __webpack_require__(4);
var ContentAtomType_1 = __webpack_require__(7);
var currentApp;
var currentPagePreview;
exports.HIGHLIGHT_BACKGROUND_COLOR_STRING = "rgb(233,233,233)";
exports.MANUALLY_HIGHLIGHT_BACKGROUND_COLOR_STRING = "rgb(222,222,222)";
var PagePreview = function () {
    function PagePreview(californiaAppArg) {
        this.dynamicClientGridBreakpoints = [];
        this.virtualStyleIndex = [];
        this.virtualPseudoStyleIndex = [];
        this._visibleLayoutAtomDomNodeReferences = [];
        this._activeViewLayoutAtomDomNodeReferences = {};
        this._visibleLayoutAtomKeys = [];
        this._mostUpperVisibleLayoutAtomId = 0;
        this.renderPreviewArea = function () {
            var previewAreaStyles = {
                "flex": currentApp.state.editViewMode === ClientState_1.EditViewMode.SidebarOnly ? "0 0 1px" : "1 1 777px",
                "display": "flex",
                "flex-flow": "column nowrap",
                "width": "533px",
                "max-width": "100%",
                "height": "100%",
                "overflow": "visible"
            };
            var isRRButtonEnabled = currentApp.state.lastCaliforniaEventData.length > 0;
            return h(
                "div",
                { key: "0", styles: previewAreaStyles },
                currentApp.state.isHideUserInterface ? undefined : currentPagePreview.renderNavigation(),
                currentApp.state.editViewMode === ClientState_1.EditViewMode.SidebarOnly ? undefined : currentPagePreview.renderPagePreviewHolder(),
                currentApp.state.isHideUserInterface ? h(
                    "div",
                    { key: "2", styles: { "position": "absolute", "left": "0", "top": "0", "z-index": CaliforniaApp_1.UI_Z_INDEX.toString(), "display": "flex", "flex-flow": "column nowrap" } },
                    h(
                        "button",
                        { key: "a", onclick: currentPagePreview.previewClickHandler },
                        "\u2026"
                    ),
                    h(
                        "button",
                        { key: "b", onclick: currentApp.propertyBars[0].insertLayoutRowIntoViewClickHandler },
                        "+(R)"
                    ),
                    isRRButtonEnabled ? h(
                        "button",
                        { key: "c", onclick: currentPagePreview.repeatClickHandler, styles: { "flex": "0 0 auto", "width": "auto" } },
                        "RR"
                    ) : h(
                        "button",
                        { disabled: true, key: "c0", onclick: currentPagePreview.repeatClickHandler, styles: { "flex": "0 0 auto", "width": "auto" } },
                        "RR"
                    )
                ) : undefined
            );
        };
        this.renderNavigation = function () {
            var navigationStyles = {
                "flex": "0 0 " + currentApp.navigationHeigthPx + "px",
                "position": "relative",
                "display": "flex",
                "flex-flow": "row nowrap",
                "z-index": "3"
            };
            var loadingIndicatorStyles = {
                "position": "absolute",
                "right": "0px",
                "background-color": "red",
                "color": "white",
                "border": "solid black 1px"
            };
            var navigationButtonStyles = {
                "flex": "0 0 auto"
            };
            var isRRButtonEnabled = currentApp.state.lastCaliforniaEventData.length > 0;
            return h(
                "div",
                { key: "0", styles: navigationStyles },
                currentApp.isAjaxRequestRunning ? h(
                    "p",
                    { key: "z", styles: loadingIndicatorStyles },
                    "Loading..."
                ) : undefined,
                h(
                    "button",
                    { key: "a", onclick: currentPagePreview.previewClickHandler, styles: { "flex": "0 0 auto", "width": "auto" } },
                    "Preview"
                ),
                h(
                    "button",
                    { key: "b", eid: ClientState_1.EditViewMode.PagePreviewOnly.toString(), onclick: currentPagePreview.changeEditModeClickHandler, styles: { "flex": "0 0 auto", "background-color": currentApp.state.editViewMode === ClientState_1.EditViewMode.PagePreviewOnly ? "red" : undefined } },
                    "P"
                ),
                h(
                    "button",
                    { key: "c", eid: ClientState_1.EditViewMode.SidebarOnly.toString(), onclick: currentPagePreview.changeEditModeClickHandler, styles: { "flex": "0 0 auto", "background-color": currentApp.state.editViewMode === ClientState_1.EditViewMode.SidebarOnly ? "red" : undefined } },
                    "S"
                ),
                h(
                    "button",
                    { key: "d", onclick: currentPagePreview.toggleSideBarCount, cid: "1", styles: { "flex": "0 0 auto" } },
                    "x1"
                ),
                h(
                    "button",
                    { key: "e", onclick: currentPagePreview.toggleSideBarCount, cid: "2", styles: { "flex": "0 0 auto" } },
                    "x2"
                ),
                h(
                    "button",
                    { key: "f", onclick: currentPagePreview.toggleSideBarCount, cid: "4", styles: { "flex": "0 0 auto" } },
                    "x4"
                ),
                currentPagePreview.renderResponsiveDeviceSelectors(),
                h(
                    "button",
                    { key: "h", onclick: currentPagePreview.changeSelectionModeClickHandler, styles: { "flex": "0 0 auto", "background-color": currentApp.state.currentSelectionMode === ClientState_1.SelectionMode.Content ? "red" : undefined, "color": currentApp.state.currentSelectionMode === ClientState_1.SelectionMode.Styles ? "red" : undefined } },
                    ClientState_1.SelectionMode[currentApp.state.currentSelectionMode]
                ),
                h(
                    "button",
                    { key: "i", onclick: currentPagePreview.publishClickHandler, styles: { "flex": "0 0 auto", "width": "auto" } },
                    "Save"
                ),
                h(
                    "button",
                    { key: "j", onclick: currentPagePreview.publishAndOpenClickHandler, styles: { "flex": "0 0 auto", "width": "auto" } },
                    "Save&Open"
                ),
                h(
                    "button",
                    { key: "k", onclick: currentPagePreview.refreshClickHandler, styles: { "flex": "0 0 auto", "width": "auto" } },
                    "JAX"
                ),
                isRRButtonEnabled ? h(
                    "button",
                    { key: "l", onclick: currentPagePreview.repeatClickHandler, styles: { "flex": "0 0 auto", "width": "auto" } },
                    "RR"
                ) : h(
                    "button",
                    { disabled: true, key: "l0", onclick: currentPagePreview.repeatClickHandler, styles: { "flex": "0 0 auto", "width": "auto" } },
                    "RR"
                )
            );
        };
        this.toggleSideBarCount = function (evt) {
            var sidebarCount = CaliforniaApp_1.parseIntFromAttribute(evt.target, "cid");
            if (sidebarCount > 0 && sidebarCount <= 4) {
                currentApp.state.visiblePropertyBarMaxCount = sidebarCount;
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
        };
        this.publishClickHandler = function (evt) {
            currentPagePreview.publish(false);
        };
        this.publishAndOpenClickHandler = function (evt) {
            currentPagePreview.publish(true);
        };
        this.publish = function (isOpen) {
            var currentCaliforniaView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (v) {
                return v.CaliforniaViewId == currentPagePreview.viewModel.activeCaliforniaViewId;
            });
            if (isOpen) {
                currentApp.controller.PublishAction(currentApp.clientData.CaliforniaProject.CaliforniaProjectId, currentCaliforniaView.Name).done(function (response) {
                    window.location.assign(window.location.origin + ("/california/pub/" + currentCaliforniaView.Name));
                }).fail(function (req) {
                    console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                });
            } else {
                currentApp.controller.PublishAction(currentApp.clientData.CaliforniaProject.CaliforniaProjectId, currentCaliforniaView.Name);
            }
        };
        this.refreshClickHandler = function (evt) {
            if (!currentApp.state.isJaxOn) {
                var head = document.getElementsByTagName("head")[0],
                    script;
                script = document.createElement("script");
                script.type = "text/x-mathjax-config";
                script.text = "MathJax.Hub.Config({\n" + "  root: \"../third_party/mathjax\",\n" + "  extensions: [\"tex2jax.js\"],\n" + "  jax: [\"input/TeX\", \"output/HTML-CSS\"],\n" + "  tex2jax: { inlineMath: [['$','$'], ['\\\\(','\\\\)']], skipTags: [\"script\",\"noscript\",\"style\",\"textarea\",\"pre\",\"code\",\"input\"], processEscapes: true},\n" + "  TeX: { extensions: [\"AMSmath.js\", \"AMSsymbols.js\"], equationNumbers: { autoNumber: \"all\" } }, showProcessingMessages: true, messageStyle:\"normal\",\n" + "  \"HTML-CSS\": { availableFonts: [\"TeX\"], preferredFont: \"TeX\", imageFont: null }\n" + "});";
                head.appendChild(script);
                script = document.createElement("script");
                script.type = "text/javascript";
                script.src = "../third_party/mathjax/MathJax.js";
                script.onload = function () {
                    currentApp.state.isJaxOn = true;
                };
                head.appendChild(script);
            } else {
                MathJax.Hub.Queue(["resetEquationNumbers", MathJax.InputJax.TeX]);
                currentPagePreview.resetEquationNumbersWhenModifying(true);
            }
        };
        this.repeatClickHandler = function (evt) {
            if (currentApp.state.lastCommand === CaliforniaGenerated_1.CaliforniaEvent.CreateLayoutBoxForBoxOrRow) {
                currentApp.controller.CreateLayoutBoxForBoxOrRowJson(currentApp.state.lastCaliforniaEventData[0], currentApp.state.lastCaliforniaEventData[1]).done(function (data) {
                    return currentApp.router.updateData(data);
                });
            } else if (currentApp.state.lastCommand === CaliforniaGenerated_1.CaliforniaEvent.CreateLayoutRowForView) {
                currentApp.controller.CreateLayoutRowForViewJson(currentApp.state.lastCaliforniaEventData[0], currentApp.state.lastCaliforniaEventData[1]).done(function (data) {
                    return currentApp.router.updateData(data);
                });
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                return;
            }
        };
        this.resetEquationNumbersWhenModifying = function (isReprocess) {
            if (currentApp.state.isJaxOn) {
                if (isReprocess) {
                    MathJax.Hub.Queue(["PreProcess", MathJax.Hub]);
                    MathJax.Hub.Queue(["Reprocess", MathJax.Hub]);
                }
            }
        };
        this.previewClickHandler = function (evt) {
            currentApp.state.isHideUserInterface = !currentApp.state.isHideUserInterface;
            currentApp.projector.renderNow();
            currentApp.resizeChangedHandler();
        };
        this.changeEditModeClickHandler = function (evt) {
            var selectedEditViewMode = CaliforniaApp_1.parseIntFromAttribute(evt.target, "eid");
            if (currentApp.state.editViewMode === selectedEditViewMode) {
                if (currentApp.state.editViewMode === ClientState_1.EditViewMode.Default) {
                    return;
                } else {
                    currentApp.state.editViewMode = ClientState_1.EditViewMode.Default;
                    currentApp.projector.renderNow();
                }
            } else {
                currentApp.state.editViewMode = selectedEditViewMode;
            }
            currentApp.resizeChangedHandler();
        };
        this.changeSelectionModeClickHandler = function (evt) {
            currentApp.state.currentSelectionMode = currentApp.state.currentSelectionMode === ClientState_1.SelectionMode.Content ? ClientState_1.SelectionMode.Styles : ClientState_1.SelectionMode.Content;
            currentPagePreview.resetContentAtomEditMode();
        };
        this.renderResponsiveDeviceSelectors = function () {
            var responsiveGroupStyles = {
                "flex": "0 0 auto",
                "display": "flex",
                "flex-flow": "row nowrap"
            };
            return h(
                "div",
                { key: "1", styles: responsiveGroupStyles },
                currentApp.clientData.CaliforniaProject.ResponsiveDevices !== undefined ? currentApp.clientData.CaliforniaProject.ResponsiveDevices.map(function (r) {
                    if (r.WidthThreshold < 0) {
                        return undefined;
                    }
                    var responsiveButtonStyles = {
                        "flex": "0 0 auto",
                        "background-color": r.ResponsiveDeviceId == currentApp.state.overrideResponsiveDeviceId ? "red" : undefined,
                        "color": r.ResponsiveDeviceId == currentApp.state.currentResponsiveDeviceId && currentApp.state.overrideResponsiveDeviceId == 0 ? "red" : undefined
                    };
                    var responsiveDeviceIdString = r.ResponsiveDeviceId.toString();
                    return h(
                        "button",
                        { key: responsiveDeviceIdString, rid: responsiveDeviceIdString, onclick: currentPagePreview.selectResponsiveDeviceClickHandler, styles: responsiveButtonStyles },
                        r.NameShort
                    );
                }) : undefined
            );
        };
        this.selectResponsiveDeviceClickHandler = function (evt) {
            var selectedId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "rid");
            if (currentApp.state.overrideResponsiveDeviceId == selectedId) {
                currentApp.state.overrideResponsiveDeviceId = 0;
            } else {
                currentApp.state.overrideResponsiveDeviceId = selectedId;
            }
            currentPagePreview.updatePagePreviewDimensions();
        };
        this.renderPagePreviewHolder = function () {
            var pagePreviewHolderStyles = {
                "flex": currentApp.state.isHideUserInterface ? "1 1 auto" : "1 1 100%",
                "margin": currentApp.state.isHideUserInterface || currentApp.state.editViewMode === ClientState_1.EditViewMode.PagePreviewOnly ? "0" : "0 " + currentApp.state.targetPagePreviewHolderMarginPx + "px",
                "position": "relative",
                "height": "100%",
                "max-height": "100%",
                "overflow": "auto"
            };
            var scrolledPagePreview = {
                "display": "flex",
                "flex-flow": "column nowrap"
            };
            return h(
                "div",
                { key: "1", styles: pagePreviewHolderStyles, onscroll: currentPagePreview.pagePreviewHolderScrollHandler, afterCreate: currentPagePreview.pagePreviewHolderAfterCreateHandler, afterUpdate: currentPagePreview.pagePreviewHolderAfterUpdateHandler },
                h(
                    "div",
                    { key: "p0", styles: scrolledPagePreview },
                    currentPagePreview.renderPagePreview()
                ),
                currentPagePreview.viewModel.fixedLayoutRowsProjector.results.map(function (r) {
                    return r.renderMaquette();
                })
            );
        };
        this.pagePreviewHolderAfterCreateHandler = function (element, projectionOptions, vnodeSelector, properties, children) {
            currentApp.pagePreviewHolder = element;
            currentApp.resizeChangedHandler();
        };
        this.pagePreviewHolderAfterUpdateHandler = function (element, projectionOptions, vnodeSelector, properties, children) {
            currentApp.pagePreviewHolder = element;
            currentPagePreview.updateVisibleLayoutAtoms();
        };
        this.pagePreviewHolderScrollHandler = function (evt) {
            if (currentApp.state.visiblePropertyBarMaxCount > 0) {
                currentPagePreview.updateVisibleLayoutAtoms();
            }
        };
        this.syncScrollPositionFromBoxTree = function () {
            if (currentApp.propertyBarVMs[0].isSyncedWithPagePreview) {
                if (currentApp.pagePreviewHolder !== undefined) {
                    var staticOffsetPx = currentApp.navigationHeigthPx;
                    var targetLayoutAtomId_1 = currentApp.propertyBars[0].mostUpperVisibleLayoutAtomId;
                    var domNodeOfTargetLayout = currentPagePreview._visibleLayoutAtomDomNodeReferences.find(function (r) {
                        return CaliforniaApp_1.parseIntFromAttribute(r, "aid") == targetLayoutAtomId_1;
                    });
                    if (domNodeOfTargetLayout === undefined) {
                        domNodeOfTargetLayout = currentPagePreview._activeViewLayoutAtomDomNodeReferences[targetLayoutAtomId_1];
                        currentApp.pagePreviewHolder.scrollTop = currentApp.pagePreviewHolder.scrollTop + (domNodeOfTargetLayout.getBoundingClientRect().top - staticOffsetPx);
                    }
                }
            }
        };
        this.updateVisibleLayoutAtoms = function () {
            var pagePreviewHolder = currentApp.pagePreviewHolder;
            currentPagePreview._visibleLayoutAtomDomNodeReferences = [];
            currentPagePreview._visibleLayoutAtomKeys = [];
            var processedElementCount = 0;
            var mostUpperVisibleIndex = -1;
            var mostUpperVisibleLayoutAtomId = 0;
            var mostUpperVisibleDeltaTopLeft = pagePreviewHolder.clientHeight + 1;
            var staticOffsetPx = currentApp.navigationHeigthPx;
            var currentScrollTop = pagePreviewHolder.scrollTop;
            var minXPreview = 0;
            var maxXPreview = pagePreviewHolder.clientHeight;
            for (var elementKey in currentPagePreview._activeViewLayoutAtomDomNodeReferences) {
                var domNode = currentPagePreview._activeViewLayoutAtomDomNodeReferences[elementKey];
                var isDomNodeVisible = false;
                var boundingRectElement = domNode.getBoundingClientRect();
                var minXElementDeltaTopLeft = boundingRectElement.top - staticOffsetPx;
                var maxXElementDeltaBottomLeft = pagePreviewHolder.clientHeight - (boundingRectElement.top - staticOffsetPx + currentScrollTop + boundingRectElement.height) + currentScrollTop;
                if (boundingRectElement.height > 0) {
                    if (minXElementDeltaTopLeft >= 0.0 && minXElementDeltaTopLeft <= pagePreviewHolder.clientHeight) {
                        isDomNodeVisible = true;
                    } else if (maxXElementDeltaBottomLeft >= 0.0 && maxXElementDeltaBottomLeft <= pagePreviewHolder.clientHeight) {
                        isDomNodeVisible = true;
                    } else if (minXElementDeltaTopLeft <= 0.0 && maxXElementDeltaBottomLeft <= 0.0) {
                        isDomNodeVisible = true;
                    }
                }
                if (isDomNodeVisible) {
                    currentPagePreview._visibleLayoutAtomDomNodeReferences.push(domNode);
                    currentPagePreview._visibleLayoutAtomKeys.push(elementKey);
                    if (minXElementDeltaTopLeft < mostUpperVisibleDeltaTopLeft) {
                        mostUpperVisibleDeltaTopLeft = minXElementDeltaTopLeft;
                        mostUpperVisibleIndex = currentPagePreview._visibleLayoutAtomKeys.length;
                        mostUpperVisibleLayoutAtomId = CaliforniaApp_1.parseIntFromAttribute(domNode, "aid");
                    }
                }
                if (mostUpperVisibleLayoutAtomId != currentPagePreview._mostUpperVisibleLayoutAtomId) {
                    currentPagePreview._mostUpperVisibleLayoutAtomId = mostUpperVisibleLayoutAtomId;
                    if (mostUpperVisibleLayoutAtomId != 0 && currentApp.propertyBarVMs[0].isSyncedWithPagePreview) {
                        currentApp.propertyBars[0].syncScrollPositionFromPagePreview();
                    }
                }
                processedElementCount++;
            }
        };
        this.renderPagePreview = function () {
            var pagePreviewStyles = {
                "width": currentApp.state.isDataLoaded && !currentApp.state.isEnoughAvailableSpacePagePreview ? currentApp.state.targetPagePreviewWidthPx + "px" : undefined,
                "display": "flex"
            };
            var isRenderView = currentApp.clientData.CaliforniaProject.CaliforniaViews !== undefined;
            var californiaViewBodyStyleString = undefined;
            if (currentApp.clientData.CaliforniaProject.CaliforniaViews !== undefined) {
                californiaViewBodyStyleString = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (v) {
                    return v.CaliforniaViewId == currentPagePreview.viewModel.activeCaliforniaViewId;
                }).SpecialStyleBodyStyleString;
            }
            return isRenderView ? h(
                "div",
                { key: "vp" + currentPagePreview.viewModel.activeCaliforniaViewId, "class": californiaViewBodyStyleString, styles: pagePreviewStyles },
                currentPagePreview.viewModel.californiaViewProjector.results.map(function (r) {
                    return r.renderMaquette();
                })
            ) : h("div", { key: "vp0", styles: pagePreviewStyles });
        };
        this.renderCaliforniaViewArray = function () {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.CaliforniaViewId;
            }, function createSectionTarget(source) {
                var sourceCaliforniaViewIdString = source.CaliforniaViewId.toString();
                var layoutRows = currentPagePreview.renderLayoutRowArray(false);
                layoutRows.map(source.PlacedLayoutRows);
                return {
                    renderMaquette: function renderMaquette() {
                        var californiaViewStyles = {
                            "flex": "1 1 1px"
                        };
                        return h(
                            "div",
                            { "class": source.SpecialStyleViewStyleString, key: sourceCaliforniaViewIdString, id: "california-v" + source.CaliforniaViewId + "_" + source.Name, vid: sourceCaliforniaViewIdString, styles: californiaViewStyles },
                            layoutRows.results.map(function (r) {
                                return r.renderMaquette();
                            })
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        layoutRows.map(source.PlacedLayoutRows);
                        sourceCaliforniaViewIdString = source.CaliforniaViewId.toString();
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.renderLayoutRowArray = function (isRenderFixedLayout) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.LayoutBaseId;
            }, function createSectionTarget(source) {
                var sourceLayoutRowIdString = source.LayoutBaseId.toString();
                var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                    return m.StyleForLayoutId == source.LayoutBaseId;
                });
                var layoutBoxMapping = currentPagePreview.renderLayoutBoxArray(isRenderFixedLayout, styleMolecule.IsPositionFixed);
                var unsortedBoxes = source.AllBoxesBelowRow.filter(function (b) {
                    return b.PlacedBoxInBoxId === undefined;
                });
                var sortedBoxes = unsortedBoxes.sort(function (boxA, boxB) {
                    if (boxA.LayoutSortOrderKey < boxB.LayoutSortOrderKey) {
                        return -1;
                    } else if (boxA.LayoutSortOrderKey == boxB.LayoutSortOrderKey) {
                        return 0;
                    } else {
                        return 1;
                    }
                });
                layoutBoxMapping.map(sortedBoxes);
                var pagePreviewOverrideStyles;
                var marginTopOverrideValue;
                var topOverrideValue;
                var marginLeftOverrideValue;
                if (styleMolecule.IsPositionFixed) {
                    marginTopOverrideValue = styleMolecule.TopCssValuePx + "px";
                    topOverrideValue = styleMolecule.TopCssValuePx !== undefined ? currentApp.navigationHeigthPx + "px" : undefined;
                    marginLeftOverrideValue = styleMolecule.LeftCssValuePx + "px";
                } else {
                    marginTopOverrideValue = undefined;
                    topOverrideValue = undefined;
                    marginLeftOverrideValue = undefined;
                }
                var styleMoleculeId = styleMolecule.StyleMoleculeId;
                var styleMoleculeIdString = styleMoleculeId.toString();
                var layoutRowStyleClass = "s" + styleMoleculeIdString;
                var holderKeyString = "" + (isRenderFixedLayout ? "f" : "g") + sourceLayoutRowIdString;
                return {
                    renderMaquette: function renderMaquette() {
                        var renderedLayoutBoxes = layoutBoxMapping.results.length > 0 ? layoutBoxMapping.results.map(function (r) {
                            return r.renderMaquette();
                        }) : [];
                        var isHoveredInBoxTree = currentApp.state.hoveredBoxTreeLayoutBaseId == source.LayoutBaseId;
                        if (!isRenderFixedLayout && styleMolecule.IsPositionFixed) {
                            return undefined;
                        }
                        if (styleMolecule.IsPositionFixed) {
                            pagePreviewOverrideStyles = {
                                "position": "absolute"
                            };
                        } else {
                            if (isRenderFixedLayout) {
                                if (renderedLayoutBoxes.filter(function (v) {
                                    return v !== undefined;
                                }).length == 0) {
                                    return undefined;
                                }
                            }
                            pagePreviewOverrideStyles = {
                                "position": undefined
                            };
                        }
                        pagePreviewOverrideStyles["background-color"] = isHoveredInBoxTree ? exports.HIGHLIGHT_BACKGROUND_COLOR_STRING : undefined;
                        if (source.LayoutBaseId == currentApp.state.highlightedLayoutBaseId) {
                            pagePreviewOverrideStyles["outline"] = "solid 1px black";
                            pagePreviewOverrideStyles["outline-offset"] = "-1px";
                            pagePreviewOverrideStyles["background-color"] = exports.MANUALLY_HIGHLIGHT_BACKGROUND_COLOR_STRING;
                        } else {
                            pagePreviewOverrideStyles["outline"] = undefined;
                            pagePreviewOverrideStyles["outline-offset"] = undefined;
                        }
                        if (styleMolecule.IsPositionFixed) {}
                        return h(
                            "div",
                            { key: holderKeyString, "class": layoutRowStyleClass, styles: pagePreviewOverrideStyles },
                            renderedLayoutBoxes
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        sourceLayoutRowIdString = source.LayoutBaseId.toString();
                        styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                            return m.StyleForLayoutId == source.LayoutBaseId;
                        });
                        layoutBoxMapping = currentPagePreview.renderLayoutBoxArray(isRenderFixedLayout, styleMolecule.IsPositionFixed);
                        unsortedBoxes = source.AllBoxesBelowRow.filter(function (b) {
                            return b.PlacedBoxInBoxId === undefined;
                        });
                        sortedBoxes = unsortedBoxes.sort(function (boxA, boxB) {
                            if (boxA.LayoutSortOrderKey < boxB.LayoutSortOrderKey) {
                                return -1;
                            } else if (boxA.LayoutSortOrderKey == boxB.LayoutSortOrderKey) {
                                return 0;
                            } else {
                                return 1;
                            }
                        });
                        layoutBoxMapping.map(sortedBoxes);
                        if (styleMolecule.IsPositionFixed) {
                            marginTopOverrideValue = styleMolecule.TopCssValuePx + "px";
                            topOverrideValue = styleMolecule.TopCssValuePx !== undefined ? currentApp.navigationHeigthPx + "px" : undefined;
                            marginLeftOverrideValue = styleMolecule.LeftCssValuePx + "px";
                        } else {
                            marginTopOverrideValue = undefined;
                            topOverrideValue = undefined;
                            marginLeftOverrideValue = undefined;
                        }
                        styleMoleculeId = styleMolecule.StyleMoleculeId;
                        styleMoleculeIdString = styleMoleculeId.toString();
                        layoutRowStyleClass = "s" + styleMoleculeId;
                        holderKeyString = "" + (isRenderFixedLayout ? "f" : "g") + sourceLayoutRowIdString;
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.renderLayoutBoxArray = function (isRenderFixedLayout, isLayoutBoxInsideFixed) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.LayoutBaseId;
            }, function createSectionTarget(source) {
                var sourceLayoutBoxIdString = source.LayoutBaseId.toString();
                var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                    return m.StyleForLayoutId == source.LayoutBaseId;
                });
                var renderedLayoutAtoms = currentPagePreview.renderLayoutAtomArray(isRenderFixedLayout, styleMolecule.IsPositionFixed || isLayoutBoxInsideFixed);
                var renderedLayoutBoxes = currentPagePreview.renderLayoutBoxArray(isRenderFixedLayout, styleMolecule.IsPositionFixed || isLayoutBoxInsideFixed);
                var pagePreviewOverrideStyles;
                var marginTopOverrideValue;
                var topOverrideValue;
                var marginLeftOverrideValue;
                if (styleMolecule.IsPositionFixed) {
                    marginTopOverrideValue = styleMolecule.TopCssValuePx + "px";
                    topOverrideValue = styleMolecule.TopCssValuePx !== undefined ? currentApp.navigationHeigthPx + "px" : undefined;
                    marginLeftOverrideValue = styleMolecule.LeftCssValuePx + "px";
                } else {
                    marginTopOverrideValue = undefined;
                    topOverrideValue = undefined;
                    marginLeftOverrideValue = undefined;
                }
                var styleMoleculeId = styleMolecule.StyleMoleculeId;
                var styleMoleculeIdString = styleMoleculeId.toString();
                var layoutBoxStyleClass = "s" + styleMoleculeId;
                var richTextTag = "p";
                if (source.SpecialLayoutBoxType === CaliforniaGenerated_1.SpecialLayoutBoxType.RichText && source.PlacedInBoxAtoms.length > 0) {
                    var layoutIdOfFirstAtom_1 = source.PlacedInBoxAtoms[0].LayoutBaseId;
                    var styleOfFirstAtom = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                        return m.StyleForLayoutId == layoutIdOfFirstAtom_1;
                    });
                    if (styleOfFirstAtom.HtmlTag !== undefined) {
                        richTextTag = styleOfFirstAtom.HtmlTag;
                    } else {
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                    }
                }
                return {
                    renderMaquette: function renderMaquette() {
                        var renderedBoxContent = currentPagePreview.mapAndRenderLayoutBoxContent(source, source.PlacedInBoxAtoms, renderedLayoutAtoms, source.PlacedInBoxBoxes, renderedLayoutBoxes);
                        var isHoveredInBoxTree = currentApp.state.hoveredBoxTreeLayoutBaseId == source.LayoutBaseId;
                        if (!isRenderFixedLayout && styleMolecule.IsPositionFixed) {
                            return undefined;
                        }
                        if (styleMolecule.IsPositionFixed) {
                            pagePreviewOverrideStyles = {
                                "position": "absolute"
                            };
                        } else {
                            if (isRenderFixedLayout && !isLayoutBoxInsideFixed) {
                                if (renderedBoxContent.filter(function (v) {
                                    return v !== undefined;
                                }).length == 0) {
                                    return undefined;
                                }
                            }
                            pagePreviewOverrideStyles = {
                                "position": undefined
                            };
                        }
                        pagePreviewOverrideStyles["background-color"] = isHoveredInBoxTree ? exports.HIGHLIGHT_BACKGROUND_COLOR_STRING : undefined;
                        if (source.LayoutBaseId == currentApp.state.highlightedLayoutBaseId) {
                            pagePreviewOverrideStyles["outline"] = "solid 1px black";
                            pagePreviewOverrideStyles["outline-offset"] = "-1px";
                            pagePreviewOverrideStyles["background-color"] = exports.MANUALLY_HIGHLIGHT_BACKGROUND_COLOR_STRING;
                        } else {
                            pagePreviewOverrideStyles["outline"] = undefined;
                            pagePreviewOverrideStyles["outline-offset"] = undefined;
                        }
                        if (styleMolecule.IsPositionFixed) {}
                        return source.SpecialLayoutBoxType === CaliforniaGenerated_1.SpecialLayoutBoxType.Default ? h(
                            "div",
                            { key: sourceLayoutBoxIdString, "class": layoutBoxStyleClass, styles: pagePreviewOverrideStyles },
                            renderedBoxContent
                        ) : source.SpecialLayoutBoxType === CaliforniaGenerated_1.SpecialLayoutBoxType.UnsortedList ? h(
                            "ul",
                            { key: sourceLayoutBoxIdString, "class": layoutBoxStyleClass, styles: pagePreviewOverrideStyles },
                            renderedBoxContent
                        ) : source.SpecialLayoutBoxType === CaliforniaGenerated_1.SpecialLayoutBoxType.SortedList ? h(
                            "ol",
                            { key: sourceLayoutBoxIdString, "class": layoutBoxStyleClass, styles: pagePreviewOverrideStyles },
                            renderedBoxContent
                        ) : source.SpecialLayoutBoxType === CaliforniaGenerated_1.SpecialLayoutBoxType.ListItem ? h(
                            "li",
                            { key: sourceLayoutBoxIdString, "class": layoutBoxStyleClass, styles: pagePreviewOverrideStyles },
                            renderedBoxContent.length > 0 ? renderedBoxContent : h(
                                "p",
                                null,
                                "add atoms..."
                            )
                        ) : source.SpecialLayoutBoxType === CaliforniaGenerated_1.SpecialLayoutBoxType.RichText ? h(richTextTag, {
                            key: sourceLayoutBoxIdString,
                            styles: pagePreviewOverrideStyles,
                            class: layoutBoxStyleClass
                        }, [renderedBoxContent.length > 0 ? renderedBoxContent : h("p", ["add atoms..."])]) : h(
                            "p",
                            null,
                            "TODO Box Type not implemented!"
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        sourceLayoutBoxIdString = source.LayoutBaseId.toString();
                        styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                            return m.StyleForLayoutId == source.LayoutBaseId;
                        });
                        renderedLayoutAtoms = currentPagePreview.renderLayoutAtomArray(isRenderFixedLayout, styleMolecule.IsPositionFixed || isLayoutBoxInsideFixed);
                        renderedLayoutBoxes = currentPagePreview.renderLayoutBoxArray(isRenderFixedLayout, styleMolecule.IsPositionFixed || isLayoutBoxInsideFixed);
                        if (styleMolecule.IsPositionFixed) {
                            marginTopOverrideValue = styleMolecule.TopCssValuePx + "px";
                            topOverrideValue = styleMolecule.TopCssValuePx !== undefined ? currentApp.navigationHeigthPx + "px" : undefined;
                            marginLeftOverrideValue = styleMolecule.LeftCssValuePx + "px";
                        } else {
                            marginTopOverrideValue = undefined;
                            topOverrideValue = undefined;
                            marginLeftOverrideValue = undefined;
                        }
                        styleMoleculeId = styleMolecule.StyleMoleculeId;
                        styleMoleculeIdString = styleMoleculeId.toString();
                        layoutBoxStyleClass = "s" + styleMoleculeId;
                        richTextTag = "p";
                        if (source.SpecialLayoutBoxType === CaliforniaGenerated_1.SpecialLayoutBoxType.RichText && source.PlacedInBoxAtoms.length > 0) {
                            var layoutIdOfFirstAtom_2 = source.PlacedInBoxAtoms[0].LayoutBaseId;
                            var styleOfFirstAtom = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                                return m.StyleForLayoutId == layoutIdOfFirstAtom_2;
                            });
                            if (styleOfFirstAtom.HtmlTag !== undefined) {
                                richTextTag = styleOfFirstAtom.HtmlTag;
                            } else {
                                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                            }
                        }
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.renderLayoutAtomArray = function (isRenderFixedLayout, isLayoutAtomInsideFixed) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.LayoutBaseId;
            }, function createSectionTarget(source) {
                var sourceLayoutAtomIdString = source.LayoutBaseId.toString();
                var sourceContentAtomIdString = source.HostedContentAtom.ContentAtomId.toString();
                var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                    return m.StyleForLayoutId == source.LayoutBaseId;
                });
                var pagePreviewOverrideStyles;
                var marginTopOverrideValue;
                var topOverrideValue;
                var marginLeftOverrideValue;
                var backgroundOverrideValue;
                if (styleMolecule.IsPositionFixed) {
                    marginTopOverrideValue = styleMolecule.TopCssValuePx + "px";
                    topOverrideValue = styleMolecule.TopCssValuePx !== undefined ? currentApp.navigationHeigthPx + "px" : undefined;
                    marginLeftOverrideValue = styleMolecule.LeftCssValuePx + "px";
                } else {
                    marginTopOverrideValue = undefined;
                    topOverrideValue = undefined;
                    marginLeftOverrideValue = undefined;
                }
                var styleMoleculeId = styleMolecule.StyleMoleculeId;
                var styleMoleculeIdString = styleMoleculeId.toString();
                var layoutAtomStyleClass = "s" + styleMoleculeIdString;
                var hostedContentAtom = currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (c) {
                    return c.ContentAtomId == source.HostedContentAtom.ContentAtomId;
                });
                if (styleMolecule.HtmlTag === undefined) {
                    console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                    return undefined;
                }
                var layoutAtomHtmlTag = styleMolecule.HtmlTag !== undefined ? styleMolecule.HtmlTag : "p";
                if (source.PlacedAtomInBox.SpecialLayoutBoxType === CaliforniaGenerated_1.SpecialLayoutBoxType.RichText) {
                    layoutAtomHtmlTag = "span";
                }
                return {
                    renderMaquette: function renderMaquette() {
                        var isHoveredInBoxTree = currentApp.state.hoveredBoxTreeLayoutBaseId == source.LayoutBaseId;
                        if (isRenderFixedLayout && !isLayoutAtomInsideFixed) {
                            return undefined;
                        }
                        if (styleMolecule.IsPositionFixed) {
                            pagePreviewOverrideStyles = {
                                "margin-top": marginTopOverrideValue,
                                "margin-left": marginLeftOverrideValue,
                                "top": topOverrideValue,
                                "left": undefined,
                                "max-width": undefined,
                                "z-index": undefined,
                                "background-color": undefined
                            };
                        } else {
                            pagePreviewOverrideStyles = {
                                "margin-top": undefined,
                                "margin-left": undefined,
                                "top": undefined,
                                "left": undefined,
                                "max-width": undefined,
                                "z-index": undefined,
                                "background-color": undefined
                            };
                        }
                        pagePreviewOverrideStyles["background-color"] = isHoveredInBoxTree ? exports.HIGHLIGHT_BACKGROUND_COLOR_STRING : undefined;
                        if (source.LayoutBaseId == currentApp.state.highlightedLayoutBaseId) {
                            pagePreviewOverrideStyles["outline"] = "solid 1px black";
                            pagePreviewOverrideStyles["outline-offset"] = "-1px";
                            pagePreviewOverrideStyles["background-color"] = exports.MANUALLY_HIGHLIGHT_BACKGROUND_COLOR_STRING;
                        } else {
                            pagePreviewOverrideStyles["outline"] = undefined;
                            pagePreviewOverrideStyles["outline-offset"] = undefined;
                        }
                        if (styleMolecule.IsPositionFixed) {
                            pagePreviewOverrideStyles["max-width"] = styleMolecule.IsPositionFixed && currentApp.state.isDataLoaded && currentApp.state.isEnoughAvailableSpacePagePreview && currentApp.state.editViewMode !== ClientState_1.EditViewMode.PagePreviewOnly ? currentApp.state.targetPagePreviewWidthPx + "px" : undefined;
                            pagePreviewOverrideStyles["left"] = styleMolecule.IsPositionFixed && styleMolecule.LeftCssValuePx !== undefined ? parseInt(styleMolecule.LeftCssValuePx) + currentApp.state.targetPagePreviewHolderMarginPx + "px" : undefined;
                        }
                        var isEditedLayoutAtomId = source.LayoutBaseId == currentPagePreview.viewModel.editedLayoutAtomId;
                        pagePreviewOverrideStyles["z-index"] = isEditedLayoutAtomId ? "30" : undefined;
                        if (isEditedLayoutAtomId) {
                            return h("textarea", { key: "i" + sourceLayoutAtomIdString, "class": layoutAtomStyleClass, value: currentPagePreview.viewModel.tempContent, oninput: currentPagePreview.contentAtomInputHandler, onblur: currentPagePreview.contentAtomLostFocusHandler, onkeydown: currentPagePreview.contentAtomKeyDownHandler, afterCreate: currentPagePreview.contentAtomAfterCreateHandler, afterUpdate: currentPagePreview.contentAtomAfterUpdateHandler, exitAnimation: currentPagePreview.contentAtomExitAnimationHandler, cid: sourceContentAtomIdString, styles: pagePreviewOverrideStyles });
                        }
                        if (hostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Text) {
                            return h(layoutAtomHtmlTag, {
                                key: sourceLayoutAtomIdString,
                                class: layoutAtomStyleClass,
                                onclick: currentPagePreview.layoutAtomClickHandler,
                                ondblclick: currentPagePreview.layoutAtomDblClickHandler,
                                aid: sourceLayoutAtomIdString,
                                cid: sourceContentAtomIdString,
                                styles: pagePreviewOverrideStyles,
                                afterCreate: currentPagePreview.layoutAtomAfterCreateHandler,
                                afterUpdate: currentPagePreview.layoutAtomAfterUpdateHandler,
                                exitAnimation: currentPagePreview.layoutAtomExitAnimationHandler,
                                onmouseenter: currentPagePreview.layoutAtomMouseEnterHandler,
                                onmouseleave: currentPagePreview.layoutAtomMouseLeaveHandler
                            }, [hostedContentAtom.TextContent]);
                        } else if (hostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Link) {
                            return h(layoutAtomHtmlTag, {
                                key: sourceLayoutAtomIdString,
                                class: layoutAtomStyleClass,
                                onclick: currentPagePreview.layoutAtomClickHandler,
                                ondblclick: currentPagePreview.layoutAtomDblClickHandler,
                                aid: sourceLayoutAtomIdString,
                                cid: sourceContentAtomIdString,
                                href: "",
                                styles: pagePreviewOverrideStyles,
                                onmouseenter: currentPagePreview.layoutAtomMouseEnterHandler,
                                onmouseleave: currentPagePreview.layoutAtomMouseLeaveHandler
                            }, [hostedContentAtom.Url]);
                        } else {
                            console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                            return undefined;
                        }
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        sourceLayoutAtomIdString = source.LayoutBaseId.toString();
                        sourceContentAtomIdString = source.HostedContentAtom.ContentAtomId.toString();
                        styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                            return m.StyleForLayoutId == source.LayoutBaseId;
                        });
                        if (styleMolecule.IsPositionFixed) {
                            marginTopOverrideValue = styleMolecule.TopCssValuePx + "px";
                            topOverrideValue = styleMolecule.TopCssValuePx !== undefined ? currentApp.navigationHeigthPx + "px" : undefined;
                            marginLeftOverrideValue = styleMolecule.LeftCssValuePx + "px";
                        } else {
                            marginTopOverrideValue = undefined;
                            topOverrideValue = undefined;
                            marginLeftOverrideValue = undefined;
                        }
                        styleMoleculeId = styleMolecule.StyleMoleculeId;
                        styleMoleculeIdString = styleMoleculeId.toString();
                        layoutAtomStyleClass = "s" + styleMoleculeId;
                        hostedContentAtom = currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (c) {
                            return c.ContentAtomId == source.HostedContentAtom.ContentAtomId;
                        });
                        if (styleMolecule.HtmlTag === undefined) {
                            console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                        }
                        layoutAtomHtmlTag = styleMolecule.HtmlTag !== undefined ? styleMolecule.HtmlTag : "p";
                        if (source.PlacedAtomInBox.SpecialLayoutBoxType === CaliforniaGenerated_1.SpecialLayoutBoxType.RichText) {
                            layoutAtomHtmlTag = "span";
                        }
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.resetContentAtomEditMode = function () {
            currentPagePreview.resetEquationNumbersWhenModifying(false);
            currentPagePreview.viewModel.editedLayoutAtomId = 0;
            currentPagePreview.viewModel.tempContent = "";
            currentPagePreview.viewModel.tempOriginalContent = "";
            currentPagePreview.viewModel.stylesOfEditedContent = {};
        };
        this.contentAtomLostFocusHandler = function (evt) {
            currentPagePreview.updateContentAtom(CaliforniaApp_1.parseIntFromAttribute(evt.target, "cid"));
        };
        this.updateContentAtom = function (contentAtomId) {
            if (currentPagePreview.viewModel.editedLayoutAtomId != 0) {
                if (currentPagePreview.viewModel.tempContent !== currentPagePreview.viewModel.tempOriginalContent) {
                    var contentAtom = currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (a) {
                        return a.InstancedOnLayoutId == currentPagePreview.viewModel.editedLayoutAtomId;
                    });
                    if (contentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Text) {
                        contentAtom.TextContent = currentPagePreview.viewModel.tempContent;
                    } else if (contentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Link) {
                        contentAtom.Url = currentPagePreview.viewModel.tempContent;
                    } else {
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                        return;
                    }
                    if (currentPagePreview.viewModel.tempContent === "") {
                        currentApp.controller.DeleteLayoutJson(currentPagePreview.viewModel.editedLayoutAtomId, false).done(function (data) {
                            return currentApp.router.updateData(data);
                        });
                    } else {
                        currentApp.state.currentReadyState = ClientState_1.ReadyState.Pending;
                        currentApp.controller.UpdateTextContentAtomJson(contentAtomId, currentPagePreview.viewModel.tempContent).done(function (data) {
                            currentApp.router.updateData(data);
                            currentPagePreview.resetEquationNumbersWhenModifying(false);
                        }).always(function (data) {
                            return currentApp.state.currentReadyState = ClientState_1.ReadyState.Ok;
                        });
                    }
                }
            }
            currentPagePreview.resetContentAtomEditMode();
        };
        this.contentAtomKeyDownHandler = function (evt) {
            if (evt.keyCode == 13) {
                evt.preventDefault();
                if (evt.shiftKey === true) {
                    currentPagePreview.contentAtomCreateNewLine(CaliforniaApp_1.parseIntFromAttribute(evt.target, "cid"));
                }
                evt.target.blur();
            } else if (evt.keyCode == 27) {
                evt.preventDefault();
                currentPagePreview.resetContentAtomEditMode();
                evt.target.blur();
            } else if (evt.keyCode == undefined) {
                evt.preventDefault();
            }
        };
        this.contentAtomCreateNewLine = function (contentAtomId) {
            if (currentPagePreview.viewModel.editedLayoutAtomId != 0) {
                var editedLayoutAtom = currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                    return l.LayoutBaseId == currentPagePreview.viewModel.editedLayoutAtomId;
                });
                var editedLayoutAtomIdChainedCall_1 = currentPagePreview.viewModel.editedLayoutAtomId;
                var placedAtomInBoxIdChainedCall_1 = editedLayoutAtom.PlacedAtomInBoxId;
                if (currentPagePreview.viewModel.tempContent !== currentPagePreview.viewModel.tempOriginalContent) {
                    currentApp.state.currentReadyState = ClientState_1.ReadyState.Pending;
                    currentApp.controller.UpdateTextContentAtomJson(contentAtomId, currentPagePreview.viewModel.tempContent).done(function (data) {
                        currentPagePreview.chainedAddMoveLayoutAtomCallWithFullUpdate(placedAtomInBoxIdChainedCall_1, editedLayoutAtomIdChainedCall_1);
                    }).always(function (data) {
                        return currentApp.state.currentReadyState = ClientState_1.ReadyState.Ok;
                    });
                    currentPagePreview.resetContentAtomEditMode();
                } else {
                    currentPagePreview.chainedAddMoveLayoutAtomCallWithFullUpdate(placedAtomInBoxIdChainedCall_1, editedLayoutAtomIdChainedCall_1);
                }
            }
        };
        this.chainedAddMoveLayoutAtomCallWithFullUpdate = function (placedAtomInBoxIdChainedCall, editedLayoutAtomIdChainedCall) {
            currentApp.controller.CreateLayoutAtomForBoxJson(placedAtomInBoxIdChainedCall, editedLayoutAtomIdChainedCall).done(function (dataSub) {
                var subBoxAtoms = dataSub.CaliforniaProject.LayoutMolecules.filter(function (m) {
                    return m.LayoutType === CaliforniaGenerated_1.LayoutType.Atom && m.PlacedAtomInBoxId == placedAtomInBoxIdChainedCall;
                });
                var createdLayoutMoleculeId = subBoxAtoms[subBoxAtoms.length - 1].LayoutBaseId;
                currentApp.controller.MoveLayoutMoleculeNextToLayoutMoleculeJson(createdLayoutMoleculeId, editedLayoutAtomIdChainedCall, true).done(function (dataSubSub) {
                    currentApp.controller.MoveLayoutMoleculeNextToLayoutMoleculeJson(editedLayoutAtomIdChainedCall, createdLayoutMoleculeId, true).done(function (dataSubSubSub) {
                        currentApp.router.updateData(dataSubSubSub);
                        var hostedContentAtom = currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (c) {
                            return c.InstancedOnLayoutId == createdLayoutMoleculeId;
                        });
                        currentPagePreview.viewModel.tempContent = "";
                        currentPagePreview.viewModel.tempOriginalContent = "";
                        if (hostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Text) {
                            currentPagePreview.viewModel.tempOriginalContent = hostedContentAtom.TextContent;
                        } else if (hostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Link) {
                            currentPagePreview.viewModel.tempOriginalContent = hostedContentAtom.Url;
                        } else {
                            console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                            return;
                        }
                        currentPagePreview.viewModel.editedLayoutAtomId = createdLayoutMoleculeId;
                    });
                });
            });
        };
        this.contentAtomAfterCreateHandler = function (element, projectionOptions, vnodeSelector, properties, children) {
            var targetElement = element;
            $(targetElement).css(currentPagePreview.viewModel.stylesOfEditedContent);
            if (currentApp.state.isSelectAllTextArea === true) {
                targetElement.setSelectionRange(0, currentPagePreview.viewModel.tempContent.length);
            }
            targetElement.focus();
        };
        this.contentAtomAfterUpdateHandler = function (element, projectionOptions, vnodeSelector, properties, children) {};
        this.contentAtomExitAnimationHandler = function (element, removeElement, properties) {
            removeElement();
        };
        this.layoutAtomAfterCreateHandler = function (element, projectionOptions, vnodeSelector, properties, children) {
            if (currentApp.state.isJaxOn) {
                var targetElement = element;
                currentPagePreview._activeViewLayoutAtomDomNodeReferences[properties.key] = targetElement;
                if (targetElement.innerText.indexOf("$") != -1) {
                    MathJax.Hub.Queue(["Typeset", MathJax.Hub, targetElement]);
                }
            }
        };
        this.layoutAtomExitAnimationHandler = function (element, removeElement, properties) {
            delete currentPagePreview._activeViewLayoutAtomDomNodeReferences[properties.key];
            removeElement();
        };
        this.layoutAtomMouseEnterHandler = function (evt) {
            var targetElement = evt.target;
            currentApp.state.hoveredPagePreviewLayoutBaseId = CaliforniaApp_1.parseIntFromAttribute(targetElement, "aid");
        };
        this.layoutAtomMouseLeaveHandler = function (evt) {
            currentApp.state.hoveredPagePreviewLayoutBaseId = 0;
        };
        this.layoutAtomAfterUpdateHandler = function (element, projectionOptions, vnodeSelector, properties, children) {
            if (currentApp.state.isJaxOn) {
                var targetElement = element;
                var math = MathJax.Hub.getAllJax(targetElement)[0];
                if (math !== undefined) {} else if (targetElement.innerText.indexOf("$") != -1) {
                    MathJax.Hub.Queue(["Typeset", MathJax.Hub, targetElement]);
                    currentPagePreview.resetEquationNumbersWhenModifying(false);
                }
            }
        };
        this.contentAtomInputHandler = function (evt) {
            currentPagePreview.viewModel.tempContent = evt.target.value;
        };
        this.layoutAtomDblClickHandler = function (evt) {
            evt.preventDefault();
            if (currentApp.state.currentReadyState !== ClientState_1.ReadyState.Ok) {
                console.log("pending...");
                return;
            }
            if (currentApp.state.currentSelectionMode === ClientState_1.SelectionMode.Content) {
                var targetElement = evt.currentTarget;
                currentPagePreview.viewModel.stylesOfEditedContent = currentPagePreview.getStyleObject(targetElement);
                var contentId = CaliforniaApp_1.parseIntFromAttribute(targetElement, "cid");
                var layoutId = CaliforniaApp_1.parseIntFromAttribute(targetElement, "aid");
                var targetWidth = targetElement.clientWidth;
                var targetHeight = targetElement.clientHeight;
                var maxIterations = 10;
                var currentIteration = 0;
                while (currentIteration++ < maxIterations) {
                    if (targetWidth == 0 || targetHeight == 0) {
                        if (targetElement.parentElement !== null) {
                            targetWidth = targetElement.parentElement.clientWidth;
                            targetHeight = targetElement.parentElement.clientHeight;
                            targetElement = targetElement.parentElement;
                        }
                    }
                }
                currentPagePreview.layoutAtomToTextAreaSetup(contentId, layoutId, true, targetWidth, targetHeight);
            } else {}
        };
        this.layoutAtomClickHandler = function (evt) {
            evt.preventDefault();
            if (currentApp.state.currentReadyState !== ClientState_1.ReadyState.Ok) {
                console.log("pending...");
                return;
            }
            if (currentApp.state.currentSelectionMode === ClientState_1.SelectionMode.Content) {
                var targetElement = evt.currentTarget;
                currentPagePreview.viewModel.stylesOfEditedContent = currentPagePreview.getStyleObject(targetElement);
                var contentId = CaliforniaApp_1.parseIntFromAttribute(targetElement, "cid");
                var layoutId = CaliforniaApp_1.parseIntFromAttribute(targetElement, "aid");
                var targetWidth = targetElement.clientWidth;
                var targetHeight = targetElement.clientHeight;
                var maxIterations = 10;
                var currentIteration = 0;
                while (currentIteration++ < maxIterations) {
                    if (targetWidth == 0 || targetHeight == 0) {
                        if (targetElement.parentElement !== null) {
                            targetWidth = targetElement.parentElement.clientWidth;
                            targetHeight = targetElement.parentElement.clientHeight;
                            targetElement = targetElement.parentElement;
                        }
                    }
                }
                currentPagePreview.layoutAtomToTextAreaSetup(contentId, layoutId, true, targetWidth, targetHeight);
            } else {}
        };
        this.layoutAtomToTextAreaSetup = function (contentAtomId, layoutAtomId, isPreSelectAll, targetWidthPx, targetHeightPx) {
            currentApp.state.isSelectAllTextArea = isPreSelectAll;
            currentPagePreview.viewModel.stylesOfEditedContent["outline"] = "solid 1px rgb(200,200,200)";
            currentPagePreview.viewModel.stylesOfEditedContent["outline-offset"] = "-1px";
            if (currentPagePreview.viewModel.stylesOfEditedContent["width"] === undefined || currentPagePreview.viewModel.stylesOfEditedContent["height"] === undefined) {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            } else {
                var targetWidthString = (targetWidthPx == 0 ? 300 : targetWidthPx).toString() + "px";
                var targetHeightString = (targetHeightPx == 0 ? 300 : targetHeightPx).toString() + "px";
                currentPagePreview.viewModel.stylesOfEditedContent["width"] = targetWidthString;
                currentPagePreview.viewModel.stylesOfEditedContent["min-width"] = targetWidthString;
                currentPagePreview.viewModel.stylesOfEditedContent["height"] = targetHeightString;
                currentPagePreview.viewModel.stylesOfEditedContent["min-height"] = targetHeightString;
            }
            var hostedContentAtom = currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (c) {
                return c.ContentAtomId == contentAtomId;
            });
            currentPagePreview.viewModel.tempContent = "";
            if (hostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Text) {
                currentPagePreview.viewModel.tempContent = hostedContentAtom.TextContent;
            } else if (hostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Link) {
                currentPagePreview.viewModel.tempContent = hostedContentAtom.Url;
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                return;
            }
            currentPagePreview.viewModel.tempOriginalContent = currentPagePreview.viewModel.tempContent;
            currentPagePreview.viewModel.editedLayoutAtomId = layoutAtomId;
        };
        this.getStyleObject = function (targetElement) {
            var dom = $(targetElement).get(0);
            var style;
            var returns = {};
            var camelize = function camelize(a, b) {
                return b.toUpperCase();
            };
            style = window.getComputedStyle(dom, undefined);
            for (var i = 0, l = style.length; i < l; i++) {
                var prop = style[i];
                var camel = prop.replace(/\-([a-z])/g, camelize);
                var val = style.getPropertyValue(prop);
                returns[camel] = val;
            }
            ;
            return returns;
        };
        this.mapAndRenderLayoutBoxContent = function (refLayoutBox, unsortedAtoms, atomMapping, unsortedBoxes, boxMapping) {
            if (unsortedAtoms.length == 0 && unsortedBoxes.length == 0) {
                return [];
            }
            var sortedAtoms = unsortedAtoms.sort(function (atomA, atomB) {
                if (atomA.LayoutSortOrderKey < atomB.LayoutSortOrderKey) {
                    return -1;
                } else if (atomA.LayoutSortOrderKey == atomB.LayoutSortOrderKey) {
                    return 0;
                } else {
                    return 1;
                }
            });
            var sortedBoxes = unsortedBoxes.sort(function (boxA, boxB) {
                if (boxA.LayoutSortOrderKey < boxB.LayoutSortOrderKey) {
                    return -1;
                } else if (boxA.LayoutSortOrderKey == boxB.LayoutSortOrderKey) {
                    return 0;
                } else {
                    return 1;
                }
            });
            atomMapping.map(sortedAtoms);
            boxMapping.map(sortedBoxes);
            var renderedAtomsAndBoxes = [];
            var atomIndex = 0;
            var boxIndex = 0;
            var atomsLength = sortedAtoms.length;
            var boxesLength = sortedBoxes.length;
            var totalItems = atomsLength + boxesLength;
            for (var i = 0; i < totalItems; i++) {
                var currentAtom = undefined;
                var currentBox = undefined;
                if (atomIndex < atomsLength) {
                    currentAtom = sortedAtoms[atomIndex];
                }
                if (boxIndex < boxesLength) {
                    currentBox = sortedBoxes[boxIndex];
                }
                if (currentAtom !== undefined && currentBox !== undefined) {
                    if (currentAtom.LayoutSortOrderKey < currentBox.LayoutSortOrderKey) {
                        renderedAtomsAndBoxes.push(atomMapping.results[atomIndex++].renderMaquette());
                    } else {
                        renderedAtomsAndBoxes.push(boxMapping.results[boxIndex++].renderMaquette());
                    }
                } else if (currentAtom !== undefined) {
                    var remainingAtoms = atomsLength - atomIndex;
                    for (var j = 0; j < remainingAtoms; j++) {
                        renderedAtomsAndBoxes.push(atomMapping.results[atomIndex++].renderMaquette());
                    }
                    break;
                } else {
                    var remainingBoxes = boxesLength - boxIndex;
                    for (var j = 0; j < remainingBoxes; j++) {
                        renderedAtomsAndBoxes.push(boxMapping.results[boxIndex++].renderMaquette());
                    }
                    break;
                }
            }
            return renderedAtomsAndBoxes;
        };
        this.getCssRuleOf = function (styleMolecule, responsiveDevice, stateModifier) {
            var selector = ".s" + styleMolecule.StyleMoleculeId;
            if (stateModifier === undefined || stateModifier === "") {
                var styleRule = selector + "{";
                var _loop_1 = function _loop_1(styleAtomMapping) {
                    var styleAtomId = currentApp.clientData.CaliforniaProject.StyleAtoms.find(function (a) {
                        return a.MappedToMoleculeId == styleAtomMapping.StyleMoleculeAtomMappingId;
                    }).StyleAtomId;
                    var appliedValues = currentApp.clientData.CaliforniaProject.StyleValues.filter(function (v) {
                        return v.StyleAtomId == styleAtomId;
                    });
                    for (var _i = 0, appliedValues_1 = appliedValues; _i < appliedValues_1.length; _i++) {
                        var cssProp = appliedValues_1[_i];
                        if (cssProp.CssValue !== "") {
                            styleRule += cssProp.CssProperty + ": " + cssProp.CssValue + ";";
                        }
                    }
                };
                for (var _i = 0, _a = styleMolecule.MappedStyleAtoms.filter(function (styleAtomMap) {
                    return styleAtomMap.ResponsiveDeviceId == responsiveDevice.ResponsiveDeviceId && (styleAtomMap.StateModifier === undefined || styleAtomMap.StateModifier === "");
                }); _i < _a.length; _i++) {
                    var styleAtomMapping = _a[_i];
                    _loop_1(styleAtomMapping);
                }
                styleRule += "}";
                return currentPagePreview.wrapCssMediaQuery(styleRule, responsiveDevice);
            } else {
                var pseudoStyleRule = "" + selector + stateModifier + "{";
                var _loop_2 = function _loop_2(pseudoStyleAtomMapping) {
                    var styleAtomId = currentApp.clientData.CaliforniaProject.StyleAtoms.find(function (a) {
                        return a.MappedToMoleculeId == pseudoStyleAtomMapping.StyleMoleculeAtomMappingId;
                    }).StyleAtomId;
                    var appliedValues = currentApp.clientData.CaliforniaProject.StyleValues.filter(function (v) {
                        return v.StyleAtomId == styleAtomId;
                    });
                    for (var _i = 0, appliedValues_2 = appliedValues; _i < appliedValues_2.length; _i++) {
                        var cssProp = appliedValues_2[_i];
                        if (cssProp.CssValue !== "") {
                            pseudoStyleRule += cssProp.CssProperty + ": " + cssProp.CssValue + ";";
                        }
                    }
                };
                for (var _b = 0, _c = styleMolecule.MappedStyleAtoms.filter(function (styleAtomMap) {
                    return styleAtomMap.ResponsiveDeviceId == responsiveDevice.ResponsiveDeviceId && styleAtomMap.StateModifier === stateModifier;
                }); _b < _c.length; _b++) {
                    var pseudoStyleAtomMapping = _c[_b];
                    _loop_2(pseudoStyleAtomMapping);
                }
                pseudoStyleRule += "}";
                return currentPagePreview.wrapCssMediaQuery(pseudoStyleRule, responsiveDevice);
            }
        };
        this.wrapCssMediaQuery = function (styleRule, responsiveDevice) {
            if (responsiveDevice.WidthThreshold !== undefined && responsiveDevice.WidthThreshold > 0) {
                return "@media(min-width:" + currentPagePreview.dynamicClientGridBreakpoints[currentApp.clientData.CaliforniaProject.ResponsiveDevices.indexOf(responsiveDevice)] + "px){" + styleRule + "}";
            } else {
                return styleRule;
            }
        };
        this.appendStyleRulesFor = function (styleMolecule, styleSheet) {
            var ruleIndex;
            var styleRule;
            for (var i = 0; i < currentApp.clientData.CaliforniaProject.ResponsiveDevices.length; i++) {
                var responsiveDevice = currentApp.clientData.CaliforniaProject.ResponsiveDevices[i];
                ruleIndex = styleSheet.cssRules.length;
                styleRule = currentPagePreview.getCssRuleOf(styleMolecule, responsiveDevice, undefined);
                styleSheet.insertRule(styleRule, ruleIndex);
                currentPagePreview.virtualStyleIndex[i][styleMolecule.StyleMoleculeId] = ruleIndex;
                var stateModifiers = [];
                var _loop_3 = function _loop_3(i_1) {
                    var styleAtomMap = styleMolecule.MappedStyleAtoms[i_1];
                    if (styleAtomMap.ResponsiveDeviceId == responsiveDevice.ResponsiveDeviceId && styleAtomMap.StateModifier !== undefined) if (stateModifiers.findIndex(function (s) {
                        return s === styleAtomMap.StateModifier;
                    }) == -1) {
                        stateModifiers.push(styleAtomMap.StateModifier);
                    }
                };
                for (var i_1 = 0; i_1 < styleMolecule.MappedStyleAtoms.length; i_1++) {
                    _loop_3(i_1);
                }
                for (var _i = 0, stateModifiers_1 = stateModifiers; _i < stateModifiers_1.length; _i++) {
                    var stateModifier = stateModifiers_1[_i];
                    ruleIndex = styleSheet.cssRules.length;
                    styleRule = currentPagePreview.getCssRuleOf(styleMolecule, responsiveDevice, stateModifier);
                    styleSheet.insertRule(styleRule, ruleIndex);
                    currentPagePreview.virtualPseudoStyleIndex[i]["" + styleMolecule.StyleMoleculeId + stateModifier] = ruleIndex;
                }
            }
        };
        this.reloadCssStyles = function () {
            for (var i = currentApp.styleSheet.cssRules.length; i > 0; i--) {
                currentApp.styleSheet.deleteRule(i - 1);
            }
            for (var i = 0; i < currentApp.clientData.CaliforniaProject.StyleMolecules.length; i++) {
                var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules[i];
                currentPagePreview.appendStyleRulesFor(styleMolecule, currentApp.styleSheet);
            }
        };
        this.updatePagePreviewDimensions = function () {
            var staticMargin = currentApp.state.defaultSymmetricPagePreviewHolderMarginPx;
            var targetWidthPx = 0;
            if (currentApp.state.overrideResponsiveDeviceId == 0) {
                currentApp.state.targetPagePreviewHolderMarginPx = staticMargin;
                targetWidthPx = currentApp.state.availableSpacePagePreviewPx - 2 * staticMargin;
                currentApp.state.targetPagePreviewWidthPx = targetWidthPx;
                currentApp.state.isEnoughAvailableSpacePagePreview = true;
            } else {
                var overrideWithResponsiveDevice = currentApp.clientData.CaliforniaProject.ResponsiveDevices.find(function (r) {
                    return r.ResponsiveDeviceId == currentApp.state.overrideResponsiveDeviceId;
                });
                if (currentApp.state.overrideResponsiveDeviceId == currentApp.state.highestWidthThresholdResponsiveDeviceId) {
                    targetWidthPx = overrideWithResponsiveDevice.WidthThreshold + 1;
                } else {
                    var targetResponsiveSettingAbove = currentApp.clientData.CaliforniaProject.ResponsiveDevices[currentApp.clientData.CaliforniaProject.ResponsiveDevices.indexOf(overrideWithResponsiveDevice) + 1];
                    targetWidthPx = targetResponsiveSettingAbove.WidthThreshold - 1;
                }
                if (currentApp.state.availableSpacePagePreviewPx - 2 * staticMargin >= targetWidthPx) {
                    var remainingSpacePx = currentApp.state.availableSpacePagePreviewPx - 2 * staticMargin - targetWidthPx;
                    currentApp.state.targetPagePreviewHolderMarginPx = staticMargin + remainingSpacePx / 2;
                    currentApp.state.targetPagePreviewWidthPx = currentApp.state.availableSpacePagePreviewPx - remainingSpacePx;
                    currentApp.state.isEnoughAvailableSpacePagePreview = true;
                } else {
                    currentApp.state.isEnoughAvailableSpacePagePreview = false;
                    currentApp.state.targetPagePreviewHolderMarginPx = staticMargin;
                    currentApp.state.targetPagePreviewWidthPx = targetWidthPx;
                }
            }
            if (currentApp.state.isDataLoaded === true) {
                var currentResponsiveDeviceIndex = currentApp.clientData.CaliforniaProject.ResponsiveDevices.findIndex(function (r) {
                    return targetWidthPx < r.WidthThreshold;
                });
                if (currentResponsiveDeviceIndex == 0) {
                    console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                } else if (currentResponsiveDeviceIndex == -1) {
                    currentApp.state.currentResponsiveDeviceId = currentApp.state.highestWidthThresholdResponsiveDeviceId;
                } else {
                    currentApp.state.currentResponsiveDeviceId = currentApp.clientData.CaliforniaProject.ResponsiveDevices[currentResponsiveDeviceIndex - 1].ResponsiveDeviceId;
                }
            }
            currentPagePreview.dynamicClientGridBreakpoints = [];
            var californiaAppWidth = $(window).width();
            if (californiaAppWidth === undefined) {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                return;
            }
            var californiaUIWidth = californiaAppWidth - currentApp.state.availableSpacePagePreviewPx;
            for (var i = 0; i < currentApp.clientData.CaliforniaProject.ResponsiveDevices.length; i++) {
                var responsiveDevice = currentApp.clientData.CaliforniaProject.ResponsiveDevices[i];
                if (responsiveDevice.WidthThreshold < 0) {
                    currentPagePreview.dynamicClientGridBreakpoints.push(0);
                } else if (responsiveDevice.WidthThreshold == 0) {
                    currentPagePreview.dynamicClientGridBreakpoints.push(0);
                } else {
                    var currentDeviceIndex = currentApp.clientData.CaliforniaProject.ResponsiveDevices.findIndex(function (r) {
                        return r.ResponsiveDeviceId == currentApp.state.currentResponsiveDeviceId;
                    });
                    var safetyMarginPx = 50;
                    if (i <= currentDeviceIndex) {
                        var adjustedBreakPoint = californiaAppWidth - safetyMarginPx - (currentDeviceIndex + 1 - i);
                        currentPagePreview.dynamicClientGridBreakpoints.push(adjustedBreakPoint);
                    } else {
                        var adjustedBreakPoint = californiaAppWidth + safetyMarginPx + (i - currentDeviceIndex);
                        currentPagePreview.dynamicClientGridBreakpoints.push(adjustedBreakPoint);
                    }
                }
            }
            currentPagePreview.reloadCssStyles();
        };
        currentPagePreview = this;
        currentApp = californiaAppArg;
        this.viewModel = new PagePreviewVM_1.PagePreviewVM(this);
    }
    ;
    Object.defineProperty(PagePreview.prototype, "visibleLayoutAtomDomNodeReferences", {
        get: function get() {
            return this._visibleLayoutAtomDomNodeReferences;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PagePreview.prototype, "visibleLayoutAtomKeys", {
        get: function get() {
            return this._visibleLayoutAtomKeys;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PagePreview.prototype, "activeViewLayoutAtomDomNodeReferences", {
        get: function get() {
            return this._activeViewLayoutAtomDomNodeReferences;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PagePreview.prototype, "mostUpperVisibleLayoutAtomId", {
        get: function get() {
            return this._mostUpperVisibleLayoutAtomId;
        },
        enumerable: true,
        configurable: true
    });
    ;
    return PagePreview;
}();
exports.PagePreview = PagePreview;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var maquette = __webpack_require__(1);
var h = maquette.h;
var currentVM;
var PagePreviewVM = function () {
    function PagePreviewVM(pagePreviewArg) {
        this.tempOriginalContent = "";
        this.tempContent = "";
        this.editedLayoutAtomId = 0;
        this.stylesOfEditedContent = {};
        this.activeCaliforniaViewId = 0;
        this.activeCaliforniaViewBodyStyleString = "";
        this.activeCaliforniaViewStyleString = "";
        currentVM = this;
        this.californiaViewProjector = pagePreviewArg.renderCaliforniaViewArray();
        this.fixedLayoutRowsProjector = pagePreviewArg.renderLayoutRowArray(true);
    }
    ;
    return PagePreviewVM;
}();
exports.PagePreviewVM = PagePreviewVM;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(jQuery, $) {

Object.defineProperty(exports, "__esModule", { value: true });
var velocity = __webpack_require__(40);
var maquette = __webpack_require__(1);
var h = maquette.h;
var CaliforniaApp_1 = __webpack_require__(3);
var PropertyBarVM_1 = __webpack_require__(5);
var CaliforniaGenerated_1 = __webpack_require__(2);
var ClientState_1 = __webpack_require__(4);
var popperjs = __webpack_require__(6);
var ContentAtomType_1 = __webpack_require__(7);
var currentApp;
exports.VERY_HIGH_VALUE = 2300000000;
var CaliforniaViewSpecialStyle;
(function (CaliforniaViewSpecialStyle) {
    CaliforniaViewSpecialStyle[CaliforniaViewSpecialStyle["View"] = 0] = "View";
    CaliforniaViewSpecialStyle[CaliforniaViewSpecialStyle["Body"] = 1] = "Body";
    CaliforniaViewSpecialStyle[CaliforniaViewSpecialStyle["Html"] = 2] = "Html";
})(CaliforniaViewSpecialStyle || (CaliforniaViewSpecialStyle = {}));
var PropertyBar = function () {
    function PropertyBar(californiaAppArg, targetIndex) {
        var _this = this;
        this.propertyBarIndex = -1;
        this._visibleLayoutAtomDomNodeReferences = [];
        this._activeViewLayoutAtomDomNodeReferences = {};
        this._visibleLayoutAtomKeys = [];
        this._mostUpperVisibleLayoutAtomId = 0;
        this.renderPropertyBar = function () {
            var divPropertyBarsStyles = {
                "flex": currentApp.state.editViewMode === ClientState_1.EditViewMode.SidebarOnly ? "1 1 200px" : "1 1 200px",
                "display": "flex",
                "flex-flow": "row nowrap",
                "height": "100%",
                "min-width": "100px",
                "width": "200px",
                "z-index": "2"
            };
            var propertyBarStyles = {
                "flex": currentApp.state.editViewMode === ClientState_1.EditViewMode.SidebarOnly ? "1 1 1px" : "1 1 1px",
                "border-right": _this.propertyBarIndex < currentApp.propertyBarCount - 1 && _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.CaliforniaView ? "solid 3px black" : undefined,
                "width": "100%",
                "height": "100%",
                "display": "flex",
                "flex-flow": "column nowrap"
            };
            return h(
                "div",
                { key: "p" + _this.propertyBarIndex.toString(), styles: divPropertyBarsStyles },
                h(
                    "div",
                    { key: "v0", styles: propertyBarStyles },
                    _this.currentPropertyBar.renderPropertyBarNavigation(),
                    _this.currentPropertyBar.renderPropertyBarControls(),
                    _this.propertyBarIndex != 0 ? _this.currentPropertyBar.renderPropertyBarPoppersRenderOnce() : undefined
                )
            );
        };
        this.renderPropertyBarPoppersRenderOnce = function () {
            return h(
                "div",
                { key: "k0" },
                _this.currentPropertyBar.renderAddCssPropertyPopup(),
                _this.currentPropertyBar.renderAllCssPropertiesPopup(),
                _this.currentPropertyBar.renderUpdateCssValuePopup(),
                _this.currentPropertyBar.renderMatchingQuantumsPopup(),
                _this.currentPropertyBar.renderUpdateCssQuantumPopup(),
                _this.currentPropertyBar.renderAllCssPropertiesForQuantumPopup(),
                _this.currentPropertyBar.insertLayoutRowIntoViewPopup(),
                _this.currentPropertyBar.insertLayoutAtomIntoBoxPopup(),
                _this.currentPropertyBar.insertLayoutBoxIntoBoxPopup(),
                _this.currentPropertyBar.moveStyleAtomToResponsiveDevicePopup(),
                _this.currentPropertyBar.renderSelectInteractionTargetPopup(),
                _this.currentPropertyBar.renderSelectInteractionTargetLayoutFilterPopup(),
                _this.currentPropertyBar.renderShareCaliforniaProjectPopup(),
                _this.currentPropertyBar.renderCaliforniaViewSelectionPopup(),
                _this.currentPropertyBar.renderEditUserDefinedCssPopup(),
                _this.currentPropertyBar.renderSuggestedCssValuesPopup()
            );
        };
        this.renderPropertyBarNavigation = function () {
            var propertyBarNavigationStyles = {
                "margin-top": currentApp.navigationHeigthPx + "px",
                "display": "flex",
                "flex-flow": "row nowrap",
                "height": "auto",
                "width": "100%",
                "flex": "0 0 auto"
            };
            var hiddenModeButtons = [PropertyBarVM_1.PropertyBarMode.None, PropertyBarVM_1.PropertyBarMode.AllStyleAtoms, PropertyBarVM_1.PropertyBarMode.LayoutAtoms, PropertyBarVM_1.PropertyBarMode.LayoutBase, PropertyBarVM_1.PropertyBarMode.LayoutMolecules, PropertyBarVM_1.PropertyBarMode.StyleMolecule];
            var propertyBarModeIconStrings = {};
            propertyBarModeIconStrings[PropertyBarVM_1.PropertyBarMode.AllCaliforniaViews] = "V";
            propertyBarModeIconStrings[PropertyBarVM_1.PropertyBarMode.AllLayoutMolecules] = "L";
            propertyBarModeIconStrings[PropertyBarVM_1.PropertyBarMode.AllStyleMolecules] = "S";
            propertyBarModeIconStrings[PropertyBarVM_1.PropertyBarMode.AllStyleQuantums] = "Q";
            propertyBarModeIconStrings[PropertyBarVM_1.PropertyBarMode.CaliforniaView] = ":)";
            var propertyBarModeButtons = CaliforniaApp_1.getArrayForEnum(PropertyBarVM_1.PropertyBarMode).map(function (type, index) {
                var modeButtonStyles = {
                    "color": index === _this.currentPropertyBar.viewModel.currentPropertyBarMode ? "red" : undefined,
                    "width": "1px",
                    "margin-right": "5px",
                    "margin-left": "5px",
                    "flex": "1 1 1px"
                };
                if (hiddenModeButtons.findIndex(function (el) {
                    return el == index;
                }) != -1) {
                    return undefined;
                }
                return h(
                    "button",
                    { key: index, role: "button", pid: index.toString(), onclick: _this.currentPropertyBar.setPropertyBarMode, styles: modeButtonStyles },
                    propertyBarModeIconStrings[index] !== undefined ? propertyBarModeIconStrings[index] : type
                );
            });
            return h(
                "div",
                { key: "n0", styles: propertyBarNavigationStyles },
                propertyBarModeButtons,
                _this.propertyBarIndex == 0 ? h(
                    "button",
                    { key: "a", onclick: _this.currentPropertyBar.logoutPopupClickHandler, styles: { "flex": "0 0 auto", "width": "auto" } },
                    "\u2709\u2026"
                ) : undefined
            );
        };
        this.setPropertyBarMode = function (evt) {
            _this.currentPropertyBar.viewModel.currentPropertyBarMode = CaliforniaApp_1.parseIntFromAttribute(evt.target, "pid");
        };
        this.renderPropertyBarControls = function () {
            var divPropertyBarControlsStyles = {
                "flex": "1 1 auto",
                "height": "1px",
                "width": "100%"
            };
            var propertyBarControlsStyles = {
                "width": "100%",
                "height": "100%",
                "overflow": "auto"
            };
            return h(
                "div",
                { key: _this.currentPropertyBar.viewModel.currentPropertyBarMode, styles: divPropertyBarControlsStyles },
                _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.AllStyleAtoms ? h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.AllStyleAtoms, styles: propertyBarControlsStyles },
                    _this.currentPropertyBar.viewModel.styleAtomProjector.results.map(function (r) {
                        return r.renderMaquette();
                    })
                ) : _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.AllStyleQuantums ? h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.AllStyleQuantums, styles: propertyBarControlsStyles },
                    _this.currentPropertyBar.renderStyleQuantumControls(),
                    _this.currentPropertyBar.viewModel.styleQuantumProjector.results.map(function (r) {
                        return r.renderMaquette();
                    })
                ) : _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.AllStyleMolecules ? h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.AllStyleMolecules, styles: propertyBarControlsStyles },
                    _this.currentPropertyBar.viewModel.styleMoleculeProjector.results.map(function (r) {
                        return r.renderMaquette();
                    })
                ) : _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.StyleMolecule ? h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.AllStyleMolecules, styles: propertyBarControlsStyles },
                    _this.currentPropertyBar.renderStyleMoleculeControls(_this)
                ) : _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.LayoutAtoms ? h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.LayoutAtoms, styles: propertyBarControlsStyles },
                    _this.currentPropertyBar.viewModel.instanceableAtomProjector.results.map(function (r) {
                        return r.renderMaquette();
                    })
                ) : _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.LayoutMolecules ? h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.LayoutMolecules, styles: propertyBarControlsStyles },
                    _this.currentPropertyBar.viewModel.instanceableMoleculeProjector.results.map(function (r) {
                        return r.renderMaquette();
                    })
                ) : _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.AllLayoutMolecules ? h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.AllLayoutMolecules, styles: propertyBarControlsStyles },
                    _this.currentPropertyBar.viewModel.allLayoutMoleculesProjector.results.map(function (r) {
                        return r.renderMaquette();
                    })
                ) : _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.LayoutBase ? h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.LayoutBase, styles: propertyBarControlsStyles },
                    _this.currentPropertyBar.renderLayoutBaseControls()
                ) : _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.AllCaliforniaViews ? h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.AllCaliforniaViews, styles: propertyBarControlsStyles },
                    _this.currentPropertyBar.renderCaliforniaViewControlsWhenAll(),
                    _this.currentPropertyBar.viewModel.allCaliforniaViewsProjector.results.map(function (r) {
                        return r.renderMaquette();
                    })
                ) : _this.currentPropertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.CaliforniaView ? h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.CaliforniaView, styles: propertyBarControlsStyles },
                    _this.currentPropertyBar.renderCaliforniaViewControls()
                ) : undefined
            );
        };
        this.renderStyleMoleculeControls = function (propertyBar) {
            if (propertyBar.viewModel.selectedStyleMoleculeId != 0) {
                var sourceStyleMoleculeIdString = propertyBar.viewModel.selectedStyleMoleculeId.toString();
                var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                    return m.StyleMoleculeId == propertyBar.viewModel.selectedStyleMoleculeId;
                });
                if (styleMolecule === undefined) {
                    return undefined;
                }
                var isClonedStyle = false;
                var cloneRefStyleMoleculeIdString = undefined;
                if (styleMolecule.ClonedFromStyleId !== undefined) {
                    isClonedStyle = true;
                    cloneRefStyleMoleculeIdString = styleMolecule.ClonedFromStyleId.toString();
                }
                var styledLayoutBaseIdString = styleMolecule.StyleForLayoutId.toString();
                var propertyBarControlsStyles = {
                    "height": "100%",
                    "width": "100%",
                    "display": "flex",
                    "flex-flow": "column nowrap"
                };
                return h(
                    "div",
                    { key: PropertyBarVM_1.PropertyBarMode.StyleMolecule, styles: propertyBarControlsStyles },
                    h(
                        "div",
                        { key: "0", styles: { "flex": "0 0 auto" } },
                        "Selected StyleMolecule #",
                        propertyBar.viewModel.selectedStyleMoleculeId,
                        isClonedStyle ? h(
                            "div",
                            { key: "0" },
                            h(
                                "button",
                                { key: "a", role: "button", mid: cloneRefStyleMoleculeIdString, onclick: propertyBar.selectStyleMoleculeClickHandler },
                                "ref style (#",
                                cloneRefStyleMoleculeIdString,
                                ")"
                            ),
                            h(
                                "button",
                                { disabled: true, key: "b", role: "button", mid: sourceStyleMoleculeIdString, onclick: propertyBar.createReferenceStyleMoleculeClickHandler },
                                "make ref"
                            ),
                            h(
                                "button",
                                { disabled: true, key: "c", role: "button", mid: sourceStyleMoleculeIdString, onclick: propertyBar.syncToReferenceStyleClickHandler },
                                "sync to ref"
                            ),
                            h(
                                "button",
                                { disabled: true, key: "d", role: "button", mid: sourceStyleMoleculeIdString, onclick: propertyBar.syncFromReferenceStyleClickHandler },
                                "sync from ref"
                            )
                        ) : propertyBar.renderStyleMoleculeReferenceSelector(),
                        propertyBar.renderResponsiveDeviceSelectors(),
                        propertyBar.renderStateModifierSelectors(),
                        propertyBar.renderStyleAtomControls()
                    ),
                    h(
                        "div",
                        { key: "1", styles: { "flex": "1 1 1px", "overflow": "scroll" } },
                        propertyBar.viewModel.styleAtomProjector.results.map(function (r) {
                            return r.renderMaquette();
                        }),
                        propertyBar.renderStyleMoleculeChildren(propertyBar)
                    ),
                    h(
                        "div",
                        { key: "2", styles: { "flex": "0 0 auto" } },
                        h(
                            "button",
                            { key: "a", role: "button", lid: styledLayoutBaseIdString, onclick: propertyBar.selectLayoutBaseClickHandler },
                            "layout #",
                            styledLayoutBaseIdString
                        )
                    )
                );
            } else {
                return undefined;
            }
        };
        this.syncToReferenceStyleClickHandler = function (evt) {
            currentApp.controller.SyncStyleMoleculeToReferenceStyleJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "mid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.syncFromReferenceStyleClickHandler = function (evt) {
            currentApp.controller.SyncStyleMoleculeFromReferenceStyleJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "mid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.createReferenceStyleMoleculeClickHandler = function (evt) {
            currentApp.controller.SetStyleMoleculeAsReferenceStyleJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "mid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.renderStyleMoleculeReferenceSelector = function () {
            return h(
                "div",
                { key: "-1" },
                h(
                    "select",
                    { disabled: true, onchange: _this.currentPropertyBar.styleMoleculeReferenceChangedHandler },
                    currentApp.clientData.CaliforniaProject.StyleMolecules.map(function (mol) {
                        if (mol.ClonedFromStyleId !== undefined) {
                            return undefined;
                        }
                        var styleMoleculeIdString = mol.StyleMoleculeId.toString();
                        if (mol.StyleMoleculeId == _this.currentPropertyBar.viewModel.selectedStyleMoleculeId) {
                            return h(
                                "option",
                                { selected: true, key: styleMoleculeIdString, value: styleMoleculeIdString },
                                mol.Name,
                                " #",
                                mol.StyleMoleculeId
                            );
                        } else {
                            return h(
                                "option",
                                { key: styleMoleculeIdString, value: styleMoleculeIdString },
                                mol.Name,
                                " #",
                                mol.StyleMoleculeId
                            );
                        }
                    })
                )
            );
        };
        this.styleMoleculeReferenceChangedHandler = function (evt) {
            var targetSelect = evt.target;
            var parsedStyleMoleculeId = undefined;
            if (targetSelect.selectedIndex < targetSelect.childElementCount) {
                var selectOptionElement = targetSelect.options[targetSelect.selectedIndex];
                parsedStyleMoleculeId = parseInt(selectOptionElement.value);
            }
            if (parsedStyleMoleculeId !== undefined) {
                currentApp.controller.SetStyleMoleculeReferenceJson(_this.currentPropertyBar.viewModel.selectedStyleMoleculeId, parsedStyleMoleculeId).done(function (data) {
                    return currentApp.router.updateData(data);
                });
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
        };
        this.renderStyleMoleculeChildren = function (propertyBar) {
            var childMolecules = [];
            if (propertyBar.viewModel.selectedStyleMoleculeId != 0) {
                childMolecules = currentApp.clientData.CaliforniaProject.StyleMolecules.filter(function (s) {
                    return s.ClonedFromStyleId == _this.currentPropertyBar.viewModel.selectedStyleMoleculeId;
                });
            }
            return h(
                "div",
                { key: "-4" },
                " affects styles:",
                childMolecules.map(function (s) {
                    var styleMoleculeIdString = s.StyleMoleculeId.toString();
                    return h(
                        "div",
                        { key: styleMoleculeIdString },
                        h(
                            "button",
                            { key: "a", role: "button", mid: styleMoleculeIdString, onclick: propertyBar.selectStyleMoleculeClickHandler },
                            "#",
                            styleMoleculeIdString
                        )
                    );
                })
            );
        };
        this.renderBoxTreeForCaliforniaView = function (propertyBar) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.CaliforniaViewId;
            }, function createSectionTarget(source) {
                var sourceCaliforniaViewIdString = source.CaliforniaViewId.toString();
                var layoutRows = propertyBar.renderLayoutRowArray(propertyBar);
                layoutRows.map(source.PlacedLayoutRows);
                return {
                    renderMaquette: function renderMaquette() {
                        var treeViewStyles = {
                            "display": "flex",
                            "flex-direction": "row",
                            "flex-wrap": "wrap",
                            "margin-right": "-15px",
                            "font-family": "sans-serif",
                            "border-bottom": "solid, 1px, black",
                            "width": "auto",
                            "height": "auto",
                            "padding-bottom": "123px"
                        };
                        return propertyBar.viewModel.selectedCaliforniaViewId == source.CaliforniaViewId ? h(
                            "div",
                            { key: sourceCaliforniaViewIdString, styles: treeViewStyles },
                            layoutRows.results.map(function (r) {
                                return r.renderMaquette();
                            })
                        ) : undefined;
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        layoutRows.map(source.PlacedLayoutRows);
                        sourceCaliforniaViewIdString = source.CaliforniaViewId.toString();
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.renderLayoutRowArray = function (propertyBar) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.LayoutBaseId;
            }, function createSectionTarget(source) {
                var sourceLayoutRowIdString = source.LayoutBaseId.toString();
                var renderedLayoutBoxes = propertyBar.renderLayoutBoxArray(propertyBar);
                var unsortedBoxes = source.AllBoxesBelowRow.filter(function (b) {
                    return b.PlacedBoxInBoxId === undefined;
                });
                var sortedBoxes = unsortedBoxes.sort(function (boxA, boxB) {
                    if (boxA.LayoutSortOrderKey < boxB.LayoutSortOrderKey) {
                        return -1;
                    } else if (boxA.LayoutSortOrderKey == boxB.LayoutSortOrderKey) {
                        return 0;
                    } else {
                        return 1;
                    }
                });
                renderedLayoutBoxes.map(sortedBoxes);
                var styleMoleculeId = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                    return m.StyleForLayoutId == source.LayoutBaseId;
                }).StyleMoleculeId;
                var styleMoleculeIdString = styleMoleculeId.toString();
                var layoutRowStyleClass = "s" + styleMoleculeIdString;
                return {
                    renderMaquette: function renderMaquette() {
                        var treeRowStyles = {
                            "flex-basis": "100%",
                            "width": "100%",
                            "max-width": "100%",
                            "padding-left": "15px",
                            "padding-right": "15px",
                            "background-color": "rgb(222, 222, 222)"
                        };
                        var captionStyles = {
                            "flex-basis": "auto",
                            "width": "auto",
                            "color": "rgb(78, 78, 78)",
                            "padding-left": "15px",
                            "padding-right": "15px",
                            "margin": "0",
                            "background-color": "rgb(222, 222, 222)",
                            "text-decoration": "underline"
                        };
                        var divButtonStyles = {
                            "display": "flex",
                            "flex-direction": "row",
                            "flex-wrap": "nowrap",
                            "margin-right": "-15px",
                            "width": "auto",
                            "flex": "0 0 auto"
                        };
                        var buttonStyles = {
                            "font-size": "10px",
                            "color": "rgb(78, 78, 78)",
                            "background-color": "rgb(222, 222, 222)",
                            "width": "auto",
                            "flex": "0 0 auto",
                            "outline": undefined,
                            "outline-offset": undefined
                        };
                        var isPreselectedAny = currentApp.state.preselectedLayoutBaseId != 0;
                        var isPreselectedCurrent = isPreselectedAny && currentApp.state.preselectedLayoutBaseId == source.LayoutBaseId;
                        var buttonStylesTarget = {
                            "font-size": "10px",
                            "color": !isPreselectedAny || isPreselectedCurrent ? "rgb(222, 222, 222)" : "rgb(78, 78, 78)",
                            "background-color": "rgb(222, 222, 222)",
                            "width": "auto",
                            "flex": "0 0 auto",
                            "outline": !isPreselectedAny || isPreselectedCurrent ? undefined : "solid 4px rgb(200,0,0)",
                            "outline-offset": !isPreselectedAny || isPreselectedCurrent ? undefined : "-4px"
                        };
                        var buttonStylesPreselectRow = {
                            "font-size": "10px",
                            "color": isPreselectedCurrent ? "rgb(222,222,222)" : isPreselectedAny ? "rgb(222, 222, 222)" : "rgb(78, 78, 78)",
                            "background-color": isPreselectedCurrent ? "rgb(200,0,0)" : "rgb(222, 222, 222)",
                            "width": "auto",
                            "flex": "0 0 auto",
                            "outline": isPreselectedCurrent || isPreselectedAny ? undefined : "solid 1px rgb(200,0,0)",
                            "outline-offset": isPreselectedCurrent || isPreselectedAny ? undefined : "-1px"
                        };
                        var divSubBoxStyles = {
                            "flex-basis": "100%",
                            "width": "100%",
                            "max-width": "100%",
                            "padding-left": "15px",
                            "padding-right": "15px"
                        };
                        return h(
                            "div",
                            { key: sourceLayoutRowIdString, styles: treeRowStyles, lid: sourceLayoutRowIdString, onmouseenter: propertyBar.layoutBaseMouseEnterHandler, onmouseleave: propertyBar.layoutBaseMouseLeaveHandler },
                            h(
                                "div",
                                { key: "-2", styles: divButtonStyles },
                                h(
                                    "p",
                                    { key: "-1", styles: captionStyles },
                                    "ROW"
                                ),
                                h(
                                    "button",
                                    { key: "a", styles: buttonStyles, lid: sourceLayoutRowIdString, onclick: propertyBar.insertLayoutBoxIntoBoxClickHandler },
                                    "+(B)"
                                ),
                                h(
                                    "button",
                                    { key: "b", styles: buttonStyles, lid: sourceLayoutRowIdString, onclick: propertyBar.selectLayoutBaseClickHandler },
                                    "\u2026"
                                ),
                                h(
                                    "button",
                                    { key: "c", styles: buttonStyles, lid: sourceLayoutRowIdString, onclick: propertyBar.highlightLayoutBaseClickHandler },
                                    "?"
                                ),
                                h(
                                    "button",
                                    { key: "d", styles: buttonStyles, mid: styleMoleculeIdString, onclick: propertyBar.selectStyleMoleculeClickHandler },
                                    "S\u2026"
                                ),
                                h(
                                    "button",
                                    { key: "e", styles: buttonStyles, lid: sourceLayoutRowIdString, onclick: propertyBar.saveLayoutMoleculeClickHandler },
                                    "!!!"
                                ),
                                isPreselectedCurrent || !isPreselectedAny ? h(
                                    "button",
                                    { key: "f", styles: buttonStylesPreselectRow, lid: sourceLayoutRowIdString, onclick: propertyBar.moveLayoutRowBeforeRowClickHandler },
                                    "MV(R)"
                                ) : h(
                                    "button",
                                    { disabled: true, key: "f0", styles: buttonStylesPreselectRow, lid: sourceLayoutRowIdString, onclick: propertyBar.moveLayoutRowBeforeRowClickHandler },
                                    "MV(R)"
                                ),
                                isPreselectedCurrent || !isPreselectedAny ? h(
                                    "button",
                                    { key: "g", styles: buttonStylesPreselectRow, lid: sourceLayoutRowIdString, onclick: propertyBar.syncLayoutBaseStylesClickHandler },
                                    "ST(R)"
                                ) : h(
                                    "button",
                                    { disabled: true, key: "g0", styles: buttonStylesPreselectRow, lid: sourceLayoutRowIdString, onclick: propertyBar.syncLayoutBaseStylesClickHandler },
                                    "ST(R)"
                                ),
                                isPreselectedAny && !isPreselectedCurrent ? h(
                                    "button",
                                    { key: "h", styles: buttonStylesTarget, lid: sourceLayoutRowIdString, onclick: propertyBar.finalizeLayoutRequest },
                                    "$(B:R)"
                                ) : h(
                                    "button",
                                    { disabled: true, key: "h0", styles: buttonStylesTarget, lid: sourceLayoutRowIdString, onclick: propertyBar.finalizeLayoutRequest },
                                    "$(B:R)"
                                ),
                                !isPreselectedAny ? h(
                                    "button",
                                    { key: "i", styles: buttonStyles, lid: sourceLayoutRowIdString, onclick: propertyBar.deleteLayoutBaseClickHandler },
                                    "X"
                                ) : h(
                                    "button",
                                    { disabled: true, key: "i0", styles: buttonStyles, lid: sourceLayoutRowIdString, onclick: propertyBar.deleteLayoutBaseClickHandler },
                                    "X"
                                ),
                                !isPreselectedAny && sortedBoxes.length > 0 ? h(
                                    "button",
                                    { key: "j", styles: buttonStyles, lid: sourceLayoutRowIdString, onclick: propertyBar.deleteBelowLayoutBaseClickHandler },
                                    "CLR"
                                ) : h(
                                    "button",
                                    { disabled: true, key: "j0", styles: buttonStyles, lid: sourceLayoutRowIdString, onclick: propertyBar.deleteBelowLayoutBaseClickHandler },
                                    "CLR"
                                )
                            ),
                            h(
                                "div",
                                { key: "0", styles: divSubBoxStyles },
                                renderedLayoutBoxes.results.map(function (r) {
                                    return r.renderMaquette();
                                })
                            )
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        sourceLayoutRowIdString = source.LayoutBaseId.toString();
                        unsortedBoxes = source.AllBoxesBelowRow.filter(function (b) {
                            return b.PlacedBoxInBoxId === undefined;
                        });
                        sortedBoxes = unsortedBoxes.sort(function (boxA, boxB) {
                            if (boxA.LayoutSortOrderKey < boxB.LayoutSortOrderKey) {
                                return -1;
                            } else if (boxA.LayoutSortOrderKey == boxB.LayoutSortOrderKey) {
                                return 0;
                            } else {
                                return 1;
                            }
                        });
                        renderedLayoutBoxes.map(sortedBoxes);
                        styleMoleculeId = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                            return m.StyleForLayoutId == source.LayoutBaseId;
                        }).StyleMoleculeId;
                        styleMoleculeIdString = styleMoleculeId.toString();
                        layoutRowStyleClass = "s" + styleMoleculeId;
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.renderLayoutBoxArray = function (propertyBar) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.LayoutBaseId;
            }, function createSectionTarget(source) {
                var sourceLayoutBoxIdString = source.LayoutBaseId.toString();
                var renderedLayoutAtoms = propertyBar.renderLayoutAtomArray(propertyBar);
                var renderedLayoutBoxes = propertyBar.renderLayoutBoxArray(propertyBar);
                var styleMoleculeId = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                    return m.StyleForLayoutId == source.LayoutBaseId;
                }).StyleMoleculeId;
                var styleMoleculeIdString = styleMoleculeId.toString();
                var layoutBoxStyleClass = "s" + styleMoleculeId;
                var deepnessPadding = "";
                var calculatedBackgroundColor = "";
                var calculatedColor = "";
                var calculatedBorderColor = "";
                var hasSubAtoms = false;
                var isOddLevel = false;
                deepnessPadding = (source.Level + 1) * 15 + "px";
                calculatedBackgroundColor = propertyBar.calculateBackgroundColorForLevel(source.Level);
                calculatedColor = propertyBar.calculateColorForLevel(source.Level);
                calculatedBorderColor = "solid 1px " + propertyBar.calculateBackgroundColorForLevel(source.Level + 1);
                hasSubAtoms = source.PlacedInBoxAtoms.length > 0;
                isOddLevel = source.Level % 2 != 0;
                return {
                    renderMaquette: function renderMaquette() {
                        var renderedBoxContent = currentApp.pagePreview.mapAndRenderLayoutBoxContent(source, source.PlacedInBoxAtoms, renderedLayoutAtoms, source.PlacedInBoxBoxes, renderedLayoutBoxes);
                        var treeBoxStyles = {
                            "display": "flex",
                            "flex-direction": "row",
                            "flex-wrap": "wrap",
                            "margin-right": "-15px",
                            "background-color": "rgb(222, 222, 222)",
                            "border-bottom": hasSubAtoms ? calculatedBorderColor : undefined,
                            "border-left": "solid 1px black",
                            "zoom": "1.05"
                        };
                        var boxCaptionStyles = {
                            "padding-left": "15px",
                            "padding-right": "15px",
                            "width": "auto",
                            "flex": "0 0 auto",
                            "margin": "0",
                            "text-decoration": "underline",
                            "color": calculatedColor,
                            "background-color": calculatedBackgroundColor,
                            "font-stretch": isOddLevel ? "extra-condensed" : undefined
                        };
                        var divButtonStyles = {
                            "display": "flex",
                            "flex-direction": "row",
                            "flex-wrap": "nowrap",
                            "margin-left": "-15px",
                            "margin-right": "-15px"
                        };
                        var buttonStyles = {
                            "font-size": "10px",
                            "color": calculatedColor,
                            "background-color": calculatedBackgroundColor,
                            "width": "auto",
                            "flex": "0 0 auto",
                            "outline": undefined,
                            "outline-offset": undefined
                        };
                        var buttonDisabledStyles = {
                            "font-size": "10px",
                            "background-color": "rgb(242,242,242)",
                            "color": calculatedColor,
                            "width": "auto",
                            "flex": "0 0 auto",
                            "outline": undefined,
                            "outline-offset": undefined
                        };
                        var isPreselectedAny = currentApp.state.preselectedLayoutBaseId != 0;
                        var isPreselectedCurrent = isPreselectedAny && currentApp.state.preselectedLayoutBaseId == source.LayoutBaseId;
                        var buttonStylesTarget = {
                            "font-size": "10px",
                            "color": !isPreselectedAny || isPreselectedCurrent ? calculatedBackgroundColor : calculatedColor,
                            "background-color": calculatedBackgroundColor,
                            "width": "auto",
                            "flex": "0 0 auto",
                            "outline": !isPreselectedAny || isPreselectedCurrent ? undefined : "solid 4px rgb(200,0,0)",
                            "outline-offset": !isPreselectedAny || isPreselectedCurrent ? undefined : "-4px"
                        };
                        var buttonStylesPreselectAny = {
                            "font-size": "10px",
                            "color": isPreselectedCurrent ? calculatedBackgroundColor : isPreselectedAny ? calculatedBackgroundColor : calculatedColor,
                            "background-color": isPreselectedCurrent ? "rgb(200,0,0)" : calculatedBackgroundColor,
                            "width": "auto",
                            "flex": "0 0 auto",
                            "outline": isPreselectedCurrent || isPreselectedAny ? undefined : "solid 1px rgb(200,0,0)",
                            "outline-offset": isPreselectedCurrent || isPreselectedAny ? undefined : "-1px"
                        };
                        var divSubTreeStyles = {
                            "flex-basis": "100%",
                            "width": "100%",
                            "max-width": "100%",
                            "padding-left": "15px",
                            "padding-right": "15px",
                            "background-color": calculatedBackgroundColor
                        };
                        return h(
                            "div",
                            { key: sourceLayoutBoxIdString, styles: treeBoxStyles },
                            h(
                                "div",
                                { key: "0", styles: divSubTreeStyles, lid: sourceLayoutBoxIdString, onmouseenter: propertyBar.layoutBaseMouseEnterHandler, onmouseleave: propertyBar.layoutBaseMouseLeaveHandler },
                                h(
                                    "div",
                                    { key: "-2", styles: divButtonStyles },
                                    h(
                                        "p",
                                        { key: "-1", styles: boxCaptionStyles },
                                        "BOX",
                                        !isOddLevel ? " |" : undefined
                                    ),
                                    h(
                                        "button",
                                        { key: "a", styles: buttonStyles, lid: sourceLayoutBoxIdString, onclick: propertyBar.insertLayoutAtomIntoBoxClickHandler },
                                        "+(A)"
                                    ),
                                    h(
                                        "button",
                                        { key: "b", styles: buttonStyles, lid: sourceLayoutBoxIdString, onclick: propertyBar.insertLayoutBoxIntoBoxClickHandler },
                                        "+(B)"
                                    ),
                                    h(
                                        "button",
                                        { key: "c", styles: buttonStyles, lid: sourceLayoutBoxIdString, onclick: propertyBar.selectLayoutBaseClickHandler },
                                        "\u2026"
                                    ),
                                    h(
                                        "button",
                                        { key: "d", styles: buttonStyles, lid: sourceLayoutBoxIdString, onclick: propertyBar.highlightLayoutBaseClickHandler },
                                        "?"
                                    ),
                                    h(
                                        "button",
                                        { key: "e", styles: buttonStyles, mid: styleMoleculeIdString, onclick: propertyBar.selectStyleMoleculeClickHandler },
                                        "S\u2026"
                                    ),
                                    h(
                                        "button",
                                        { key: "f", styles: buttonStyles, lid: sourceLayoutBoxIdString, onclick: propertyBar.saveLayoutMoleculeClickHandler },
                                        "!!!"
                                    ),
                                    isPreselectedCurrent || !isPreselectedAny ? h(
                                        "button",
                                        { key: "g", styles: buttonStylesPreselectAny, lid: sourceLayoutBoxIdString, onclick: propertyBar.moveLayoutBoxIntoRowClickHandler },
                                        "IN(R)"
                                    ) : h(
                                        "button",
                                        { disabled: true, key: "g0", styles: buttonStylesPreselectAny, lid: sourceLayoutBoxIdString, onclick: propertyBar.moveLayoutBoxIntoRowClickHandler },
                                        "IN(R)"
                                    ),
                                    isPreselectedCurrent || !isPreselectedAny ? h(
                                        "button",
                                        { key: "h", styles: buttonStylesPreselectAny, lid: sourceLayoutBoxIdString, onclick: propertyBar.moveLayoutBoxIntoBoxClickHandler },
                                        "IN(B)"
                                    ) : h(
                                        "button",
                                        { disabled: true, key: "h0", styles: buttonStylesPreselectAny, lid: sourceLayoutBoxIdString, onclick: propertyBar.moveLayoutBoxIntoBoxClickHandler },
                                        "IN(B)"
                                    ),
                                    isPreselectedCurrent || !isPreselectedAny ? h(
                                        "button",
                                        { key: "i", styles: buttonStylesPreselectAny, lid: sourceLayoutBoxIdString, onclick: propertyBar.moveLayoutBoxBeforeBoxClickHandler },
                                        "MV(A:B)"
                                    ) : h(
                                        "button",
                                        { disabled: true, key: "i0", styles: buttonStylesPreselectAny, lid: sourceLayoutBoxIdString, onclick: propertyBar.moveLayoutBoxBeforeBoxClickHandler },
                                        "MV(A:B)"
                                    ),
                                    isPreselectedCurrent || !isPreselectedAny ? h(
                                        "button",
                                        { key: "j", styles: buttonStylesPreselectAny, lid: sourceLayoutBoxIdString, onclick: propertyBar.syncLayoutBaseStylesClickHandler },
                                        "ST(B)"
                                    ) : h(
                                        "button",
                                        { disabled: true, key: "j0", styles: buttonStylesPreselectAny, lid: sourceLayoutBoxIdString, onclick: propertyBar.syncLayoutBaseStylesClickHandler },
                                        "ST(B)"
                                    ),
                                    isPreselectedAny && !isPreselectedCurrent ? h(
                                        "button",
                                        { key: "k", styles: buttonStylesTarget, lid: sourceLayoutBoxIdString, onclick: propertyBar.finalizeLayoutRequest },
                                        "$(A:B)"
                                    ) : h(
                                        "button",
                                        { disabled: true, key: "k0", styles: buttonStylesTarget, lid: sourceLayoutBoxIdString, onclick: propertyBar.finalizeLayoutRequest },
                                        "$(A:B)"
                                    ),
                                    !isPreselectedAny ? h(
                                        "button",
                                        { key: "l", styles: buttonStyles, lid: sourceLayoutBoxIdString, onclick: propertyBar.deleteLayoutBaseClickHandler },
                                        "X"
                                    ) : h(
                                        "button",
                                        { disabled: true, key: "l0", styles: buttonStyles, lid: sourceLayoutBoxIdString, onclick: propertyBar.deleteLayoutBaseClickHandler },
                                        "X"
                                    ),
                                    !isPreselectedAny && renderedBoxContent.length > 0 ? h(
                                        "button",
                                        { key: "m", styles: buttonStyles, lid: sourceLayoutBoxIdString, onclick: propertyBar.deleteBelowLayoutBaseClickHandler },
                                        "CLR"
                                    ) : h(
                                        "button",
                                        { disabled: true, key: "m0", styles: buttonStyles, lid: sourceLayoutBoxIdString, onclick: propertyBar.deleteBelowLayoutBaseClickHandler },
                                        "CLR"
                                    )
                                ),
                                renderedBoxContent
                            )
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        sourceLayoutBoxIdString = source.LayoutBaseId.toString();
                        styleMoleculeId = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                            return m.StyleForLayoutId == source.LayoutBaseId;
                        }).StyleMoleculeId;
                        styleMoleculeIdString = styleMoleculeId.toString();
                        layoutBoxStyleClass = "s" + styleMoleculeId;
                        deepnessPadding = (source.Level + 1) * 15 + "px";
                        calculatedBackgroundColor = propertyBar.calculateBackgroundColorForLevel(source.Level);
                        calculatedColor = propertyBar.calculateColorForLevel(source.Level);
                        calculatedBorderColor = "solid 1px " + propertyBar.calculateBackgroundColorForLevel(source.Level + 1);
                        hasSubAtoms = source.PlacedInBoxAtoms.length > 0;
                        isOddLevel = source.Level % 2 != 0;
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.calculateColorForLevel = function (level) {
            level = level < 0 ? 0 : level;
            var colorValue = level > 2 ? 222 : 78 + level * 12;
            return "rgb(" + colorValue + "," + colorValue + "," + colorValue + ")";
        };
        this.calculateBackgroundColorForLevel = function (level) {
            level = level < 0 ? 0 : level;
            var colorValue = 200 - level * 22;
            colorValue = colorValue < 0 ? 0 : colorValue;
            return "rgb(" + colorValue + "," + colorValue + "," + colorValue + ")";
        };
        this.renderLayoutAtomArray = function (propertyBar) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.LayoutBaseId;
            }, function createSectionTarget(source) {
                var sourceLayoutAtomIdString = source.LayoutBaseId.toString();
                var sourceContentAtomIdString = source.HostedContentAtom.ContentAtomId.toString();
                var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                    return m.StyleForLayoutId == source.LayoutBaseId;
                });
                var styleMoleculeId = styleMolecule.StyleMoleculeId;
                var styleMoleculeIdString = styleMoleculeId.toString();
                var layoutAtomStyleClass = "s" + styleMoleculeIdString;
                var calculatedPaddingPx = (propertyBar.viewModel.deepestLevelActiveView + 1 - source.Level) * 15;
                var calculatedMargin = "";
                var calculatedColor = "";
                var calculatedBackgroundColor = "";
                calculatedMargin = source.Level * 15 + 15 + "px";
                calculatedColor = propertyBar.calculateColorForLevel(source.Level);
                calculatedBackgroundColor = propertyBar.calculateBackgroundColorForLevel(source.Level);
                var hostedContentAtom = currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (c) {
                    return c.ContentAtomId == source.HostedContentAtom.ContentAtomId;
                });
                return {
                    renderMaquette: function renderMaquette() {
                        var isRenderedAtomVisible = currentApp.pagePreview.visibleLayoutAtomKeys.findIndex(function (k) {
                            return k === sourceLayoutAtomIdString;
                        }) != -1;
                        var isRenderedAtomHovered = currentApp.state.hoveredPagePreviewLayoutBaseId == source.LayoutBaseId;
                        var divAtomStyles = {
                            "display": "flex",
                            "flex-direction": "row",
                            "flex-wrap": "nowrap",
                            "margin-right": "-15px",
                            "border-left": "solid 1px black"
                        };
                        var atomCaptionStyles = {
                            "text-decoration": "underline",
                            "flex": "0 0 auto",
                            "width": "auto",
                            "margin-left": "15px",
                            "padding-left": (calculatedPaddingPx + (isRenderedAtomVisible ? -1 : 0)).toString() + "px",
                            "padding-right": "15px",
                            "margin": "0",
                            "color": calculatedColor,
                            "background-color": calculatedBackgroundColor,
                            "font-size": undefined,
                            "min-width": undefined,
                            "border-left": isRenderedAtomHovered ? "solid 3px rgb(200,0,0)" : isRenderedAtomVisible ? "dashed 1px rgb(200,0,0)" : undefined
                        };
                        var inputStyles = {
                            "text-decoration": undefined,
                            "flex": "0 0 auto",
                            "width": "auto",
                            "margin-left": "15px",
                            "padding-left": undefined,
                            "padding-right": "15px",
                            "margin": "0",
                            "color": undefined,
                            "background-color": undefined,
                            "font-size": "0.8rem",
                            "min-width": "200px"
                        };
                        var buttonStyles = {
                            "font-size": "10px",
                            "color": calculatedColor,
                            "background-color": calculatedBackgroundColor,
                            "width": "auto",
                            "flex": "0 0 auto",
                            "outline": undefined,
                            "outline-offset": undefined
                        };
                        var isPreselectedAny = currentApp.state.preselectedLayoutBaseId != 0;
                        var isPreselectedCurrent = isPreselectedAny && currentApp.state.preselectedLayoutBaseId == source.LayoutBaseId;
                        var buttonStylesTarget = {
                            "font-size": "10px",
                            "color": !isPreselectedAny || isPreselectedCurrent ? calculatedBackgroundColor : calculatedColor,
                            "background-color": calculatedBackgroundColor,
                            "width": "auto",
                            "flex": "0 0 auto",
                            "outline": !isPreselectedAny || isPreselectedCurrent ? undefined : "solid 4px rgb(200,0,0)",
                            "outline-offset": !isPreselectedAny || isPreselectedCurrent ? undefined : "-4px"
                        };
                        var buttonStylesPreselectAny = {
                            "font-size": "10px",
                            "color": isPreselectedCurrent ? calculatedBackgroundColor : isPreselectedAny ? calculatedBackgroundColor : calculatedColor,
                            "background-color": isPreselectedCurrent ? "rgb(200,0,0)" : calculatedBackgroundColor,
                            "width": "auto",
                            "flex": "0 0 auto",
                            "outline": isPreselectedCurrent || isPreselectedAny ? undefined : "solid 1px rgb(200,0,0)",
                            "outline-offset": isPreselectedCurrent || isPreselectedAny ? undefined : "-1px"
                        };
                        var description = "";
                        if (hostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Text && hostedContentAtom.TextContent !== undefined) {
                            description = hostedContentAtom.TextContent.length > 20 ? hostedContentAtom.TextContent.substring(0, 20) + "..." : hostedContentAtom.TextContent;
                        } else if (hostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Link && hostedContentAtom.Url !== undefined) {
                            description = hostedContentAtom.Url.length > 20 ? hostedContentAtom.Url.substring(0, 20) + "..." : hostedContentAtom.Url;
                        } else {
                            console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                            return undefined;
                        }
                        var renderedInputForContent = undefined;
                        var isEditedLayoutAtomId = source.LayoutBaseId == propertyBar.viewModel.editedLayoutAtomId;
                        if (isEditedLayoutAtomId) {
                            renderedInputForContent = h("input", { key: "inp" + sourceLayoutAtomIdString, "class": layoutAtomStyleClass, value: propertyBar.viewModel.tempContent, oninput: propertyBar.contentAtomInputHandler, onblur: propertyBar.contentAtomLostFocusHandler, onkeydown: propertyBar.contentAtomKeyDownHandler, styles: inputStyles, afterCreate: propertyBar.contentAtomAfterCreateHandler, cid: sourceContentAtomIdString });
                        }
                        return h(
                            "div",
                            { key: sourceLayoutAtomIdString, lid: sourceLayoutAtomIdString, styles: divAtomStyles, afterCreate: propertyBar.layoutAtomAfterCreateHandler, onmouseenter: propertyBar.layoutBaseMouseEnterHandler, onmouseleave: propertyBar.layoutBaseMouseLeaveHandler },
                            !isEditedLayoutAtomId ? h(
                                "p",
                                { key: "0", styles: atomCaptionStyles, aid: sourceLayoutAtomIdString, cid: sourceContentAtomIdString, onclick: propertyBar.layoutAtomClickHandler },
                                h(
                                    "small",
                                    { key: "0", aid: sourceLayoutAtomIdString, cid: sourceContentAtomIdString },
                                    description,
                                    "ATOM"
                                )
                            ) : renderedInputForContent,
                            h(
                                "button",
                                { key: "a", styles: buttonStyles, lid: sourceLayoutAtomIdString, onclick: propertyBar.selectLayoutBaseClickHandler },
                                "\u2026"
                            ),
                            h(
                                "button",
                                { key: "b", styles: buttonStyles, lid: sourceLayoutAtomIdString, onclick: propertyBar.highlightLayoutBaseClickHandler },
                                "?"
                            ),
                            h(
                                "button",
                                { key: "c", styles: buttonStyles, mid: styleMoleculeIdString, onclick: propertyBar.selectStyleMoleculeClickHandler },
                                "S\u2026"
                            ),
                            isPreselectedCurrent || !isPreselectedAny ? h(
                                "button",
                                { key: "d", styles: buttonStylesPreselectAny, lid: sourceLayoutAtomIdString, onclick: propertyBar.moveLayoutAtomIntoBoxClickHandler },
                                "IN"
                            ) : h(
                                "button",
                                { disabled: true, key: "d0", styles: buttonStylesPreselectAny, lid: sourceLayoutAtomIdString, onclick: propertyBar.moveLayoutAtomIntoBoxClickHandler },
                                "IN"
                            ),
                            isPreselectedCurrent || !isPreselectedAny ? h(
                                "button",
                                { key: "e", styles: buttonStylesPreselectAny, lid: sourceLayoutAtomIdString, onclick: propertyBar.moveLayoutAtomBeforeAtomClickHandler },
                                "MV"
                            ) : h(
                                "button",
                                { disabled: true, key: "e0", styles: buttonStylesPreselectAny, lid: sourceLayoutAtomIdString, onclick: propertyBar.moveLayoutAtomBeforeAtomClickHandler },
                                "MV"
                            ),
                            isPreselectedCurrent || !isPreselectedAny ? h(
                                "button",
                                { key: "f", styles: buttonStylesPreselectAny, lid: sourceLayoutAtomIdString, onclick: propertyBar.syncLayoutBaseStylesClickHandler },
                                "ST(A)"
                            ) : h(
                                "button",
                                { disabled: true, key: "f0", styles: buttonStylesPreselectAny, lid: sourceLayoutAtomIdString, onclick: propertyBar.syncLayoutBaseStylesClickHandler },
                                "ST(A)"
                            ),
                            isPreselectedCurrent || !isPreselectedAny ? h(
                                "button",
                                { key: "g", styles: buttonStylesPreselectAny, lid: sourceLayoutAtomIdString, onclick: propertyBar.createBoxForAtomInPlaceClickHandler },
                                "+(B).IN"
                            ) : h(
                                "button",
                                { disabled: true, key: "g0", styles: buttonStylesPreselectAny, lid: sourceLayoutAtomIdString, onclick: propertyBar.createBoxForAtomInPlaceClickHandler },
                                "+(B).IN"
                            ),
                            isPreselectedAny && !isPreselectedCurrent ? h(
                                "button",
                                { key: "h", styles: buttonStylesTarget, lid: sourceLayoutAtomIdString, onclick: propertyBar.finalizeLayoutRequest },
                                "$(A:B)"
                            ) : h(
                                "button",
                                { disabled: true, key: "h0", styles: buttonStylesTarget, lid: sourceLayoutAtomIdString, onclick: propertyBar.finalizeLayoutRequest },
                                "$(A:B)"
                            ),
                            !isPreselectedAny ? h(
                                "button",
                                { key: "i", styles: buttonStyles, lid: sourceLayoutAtomIdString, onclick: propertyBar.deleteLayoutBaseClickHandler },
                                "X"
                            ) : h(
                                "button",
                                { disabled: true, key: "i0", styles: buttonStyles, lid: sourceLayoutAtomIdString, onclick: propertyBar.deleteLayoutBaseClickHandler },
                                "X"
                            )
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        sourceLayoutAtomIdString = source.LayoutBaseId.toString();
                        sourceContentAtomIdString = source.HostedContentAtom.ContentAtomId.toString();
                        styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                            return m.StyleForLayoutId == source.LayoutBaseId;
                        });
                        styleMoleculeId = styleMolecule.StyleMoleculeId;
                        styleMoleculeIdString = styleMoleculeId.toString();
                        layoutAtomStyleClass = "s" + styleMoleculeId;
                        calculatedPaddingPx = (propertyBar.viewModel.deepestLevelActiveView - source.Level) * 15 + 15;
                        calculatedColor = propertyBar.calculateColorForLevel(source.Level);
                        calculatedMargin = source.Level * 15 + 15 + "px";
                        calculatedBackgroundColor = propertyBar.calculateBackgroundColorForLevel(source.Level);
                        hostedContentAtom = currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (c) {
                            return c.ContentAtomId == source.HostedContentAtom.ContentAtomId;
                        });
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.contentAtomAfterCreateHandler = function (element, projectionOptions, vnodeSelector, properties, children) {
            var targetElement = element;
            targetElement.focus();
        };
        this.layoutBaseMouseEnterHandler = function (evt) {
            var targetElement = evt.target;
            currentApp.state.hoveredBoxTreeLayoutBaseId = CaliforniaApp_1.parseIntFromAttribute(targetElement, "lid");
        };
        this.layoutBaseMouseLeaveHandler = function (evt) {
            currentApp.state.hoveredBoxTreeLayoutBaseId = 0;
        };
        this.layoutAtomAfterCreateHandler = function (element, projectionOptions, vnodeSelector, properties, children) {
            if (_this.currentPropertyBar.propertyBarIndex == 0) {
                var targetElement = element;
                _this.currentPropertyBar._activeViewLayoutAtomDomNodeReferences[properties.key] = targetElement;
            }
        };
        this.resetContentAtomEditMode = function () {
            currentApp.pagePreview.resetEquationNumbersWhenModifying(false);
            _this.currentPropertyBar.viewModel.editedLayoutAtomId = 0;
            _this.currentPropertyBar.viewModel.tempContent = "";
            _this.currentPropertyBar.viewModel.tempOriginalContent = "";
        };
        this.contentAtomLostFocusHandler = function (evt) {
            _this.currentPropertyBar.updateContentAtom(CaliforniaApp_1.parseIntFromAttribute(evt.target, "cid"));
        };
        this.updateContentAtom = function (contentAtomId) {
            if (_this.currentPropertyBar.viewModel.editedLayoutAtomId != 0) {
                if (_this.currentPropertyBar.viewModel.tempContent !== _this.currentPropertyBar.viewModel.tempOriginalContent) {
                    if (_this.currentPropertyBar.viewModel.tempContent !== "") {
                        var contentAtom = currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (a) {
                            return a.InstancedOnLayoutId == _this.currentPropertyBar.viewModel.editedLayoutAtomId;
                        });
                        if (contentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Text) {
                            contentAtom.TextContent = _this.currentPropertyBar.viewModel.tempContent;
                        } else if (contentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Link) {
                            contentAtom.Url = _this.currentPropertyBar.viewModel.tempContent;
                        } else {
                            console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                            return;
                        }
                        currentApp.state.currentReadyState = ClientState_1.ReadyState.Pending;
                        currentApp.controller.UpdateTextContentAtomJson(contentAtomId, _this.currentPropertyBar.viewModel.tempContent).done(function (data) {
                            currentApp.router.updateData(data);
                        }).always(function (data) {
                            return currentApp.state.currentReadyState = ClientState_1.ReadyState.Ok;
                        });
                    } else {
                        currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (c) {
                            return c.InstancedOnLayoutId == _this.currentPropertyBar.viewModel.editedLayoutAtomId;
                        }).TextContent = _this.currentPropertyBar.viewModel.tempOriginalContent;
                    }
                }
            }
            _this.currentPropertyBar.resetContentAtomEditMode();
        };
        this.contentAtomKeyDownHandler = function (evt) {
            if (evt.keyCode == 13) {
                evt.preventDefault();
                evt.target.blur();
            } else if (evt.keyCode == 27) {
                evt.preventDefault();
                currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (c) {
                    return c.InstancedOnLayoutId == _this.currentPropertyBar.viewModel.editedLayoutAtomId;
                }).TextContent = _this.currentPropertyBar.viewModel.tempOriginalContent;
                _this.currentPropertyBar.resetContentAtomEditMode();
                evt.target.blur();
            } else if (evt.keyCode == undefined) {
                evt.preventDefault();
            }
        };
        this.contentAtomInputHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempContent = evt.target.value;
            currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (c) {
                return c.InstancedOnLayoutId == _this.currentPropertyBar.viewModel.editedLayoutAtomId;
            }).TextContent = _this.currentPropertyBar.viewModel.tempContent;
        };
        this.layoutAtomClickHandler = function (evt) {
            evt.preventDefault();
            if (currentApp.state.currentReadyState !== ClientState_1.ReadyState.Ok) {
                console.log("pending...");
                return;
            }
            if (currentApp.state.currentSelectionMode === ClientState_1.SelectionMode.Content) {
                var contentAtomId_1 = CaliforniaApp_1.parseIntFromAttribute(evt.target, "cid");
                var layoutAtomId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "aid");
                var hostedContentAtom = currentApp.clientData.CaliforniaProject.ContentAtoms.find(function (c) {
                    return c.ContentAtomId == contentAtomId_1;
                });
                _this.currentPropertyBar.viewModel.tempContent = "";
                if (hostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Text) {
                    _this.currentPropertyBar.viewModel.tempContent = hostedContentAtom.TextContent;
                } else if (hostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Link) {
                    _this.currentPropertyBar.viewModel.tempContent = hostedContentAtom.Url;
                } else {
                    console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                    return;
                }
                _this.currentPropertyBar.viewModel.tempOriginalContent = _this.currentPropertyBar.viewModel.tempContent;
                _this.currentPropertyBar.viewModel.editedLayoutAtomId = layoutAtomId;
            } else {}
        };
        this.renderStateModifierSelectors = function () {
            var stateModifierGroupStyles = {
                "display": "flex",
                "flex-flow": "row nowrap"
            };
            var stateModifiers = [];
            var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                return m.StyleMoleculeId == _this.currentPropertyBar.viewModel.selectedStyleMoleculeId;
            });
            var _loop_1 = function _loop_1(i) {
                var modifier = styleMolecule.MappedStyleAtoms[i].StateModifier;
                if (modifier === undefined) {
                    modifier = "";
                }
                if (stateModifiers.findIndex(function (s) {
                    return s === modifier;
                }) == -1) {
                    stateModifiers.push(modifier);
                }
            };
            for (var i = 0; i < styleMolecule.MappedStyleAtoms.length; i++) {
                _loop_1(i);
            }
            var renderedModifiers = [];
            for (var i = 0; i < stateModifiers.length; i++) {
                var modifier = stateModifiers[i];
                var modifierButtonStyles = {
                    "flex": "0 0 auto",
                    "background-color": modifier == _this.currentPropertyBar.viewModel.selectedStateModifier ? "red" : undefined
                };
                renderedModifiers.push(h(
                    "button",
                    { key: modifier, role: "button", mid: modifier, onclick: _this.currentPropertyBar.stateModifierClickHandler, styles: modifierButtonStyles },
                    modifier
                ));
            }
            return h(
                "div",
                { key: "-2", styles: stateModifierGroupStyles },
                renderedModifiers
            );
        };
        this.stateModifierClickHandler = function (evt) {
            var selectedStateModifier = CaliforniaApp_1.parseStringFromAttribute(evt.target, "mid");
            if (selectedStateModifier === _this.currentPropertyBar.viewModel.selectedStateModifier) {
                _this.currentPropertyBar.viewModel.selectedStateModifier = "";
            } else {
                _this.currentPropertyBar.viewModel.selectedStateModifier = selectedStateModifier;
            }
        };
        this.renderResponsiveDeviceSelectors = function () {
            var responsiveGroupStyles = {
                "display": "flex",
                "flex-flow": "row wrap"
            };
            return h(
                "div",
                { key: "-3", styles: responsiveGroupStyles },
                currentApp.clientData.CaliforniaProject.ResponsiveDevices !== undefined ? currentApp.clientData.CaliforniaProject.ResponsiveDevices.map(function (r) {
                    var responsiveButtonStyles = {
                        "flex": "0 0 auto",
                        "background-color": r.ResponsiveDeviceId == _this.currentPropertyBar.viewModel.selectedResponsiveDeviceId ? "red" : undefined
                    };
                    var responsiveDeviceIdString = r.ResponsiveDeviceId.toString();
                    return h(
                        "button",
                        { key: responsiveDeviceIdString, role: "button", rid: responsiveDeviceIdString, onclick: _this.currentPropertyBar.selectResponsiveDeviceClickHandler, styles: responsiveButtonStyles },
                        r.NameShort
                    );
                }) : undefined
            );
        };
        this.selectResponsiveDeviceClickHandler = function (evt) {
            var selectedResponsiveId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "rid");
            if (_this.currentPropertyBar.viewModel.selectedResponsiveDeviceId == selectedResponsiveId) {
                _this.currentPropertyBar.viewModel.selectedResponsiveDeviceId = currentApp.state.noneResponsiveDeviceId;
            } else {
                _this.currentPropertyBar.viewModel.selectedResponsiveDeviceId = selectedResponsiveId;
            }
        };
        this.renderStyleAtomControls = function () {
            return h(
                "div",
                { key: "-1" },
                h(
                    "select",
                    { key: "0", onchange: _this.currentPropertyBar.styleAtomTypeChangedHandler },
                    CaliforniaApp_1.getArrayForEnum(CaliforniaGenerated_1.StyleAtomType).map(function (type, index) {
                        var isSelected = index === _this.currentPropertyBar.viewModel.selectedStyleAtomType;
                        return isSelected ? h(
                            "option",
                            { selected: true, key: index, value: index.toString() },
                            type
                        ) : h(
                            "option",
                            { key: index, value: index.toString() },
                            type
                        );
                    })
                ),
                h("input", { key: "-1", placeholder: "optional :hover,:before,...", value: _this.currentPropertyBar.viewModel.tempPseudoSelector, oninput: _this.currentPropertyBar.pseudoSelectorInputHandler }),
                h(
                    "button",
                    { key: "a", role: "button", onclick: _this.currentPropertyBar.createStyleAtomForMoleculeClickHandler },
                    "+"
                )
            );
        };
        this.pseudoSelectorInputHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempPseudoSelector = evt.target.value;
        };
        this.styleAtomTypeChangedHandler = function (evt) {
            var targetSelect = evt.target;
            var parsedStyleAtomType = undefined;
            if (targetSelect.selectedIndex < targetSelect.childElementCount) {
                var selectOptionElement = targetSelect.options[targetSelect.selectedIndex];
                parsedStyleAtomType = parseInt(selectOptionElement.value);
            }
            if (parsedStyleAtomType !== undefined) {
                _this.currentPropertyBar.viewModel.selectedStyleAtomType = parsedStyleAtomType;
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
        };
        this.createStyleAtomForMoleculeClickHandler = function (evt) {
            if (_this.currentPropertyBar.viewModel.tempPseudoSelector !== "") {
                _this.currentPropertyBar.viewModel.selectedStateModifier = _this.currentPropertyBar.viewModel.tempPseudoSelector;
            }
            currentApp.controller.CreateStyleAtomForMoleculeJson(_this.currentPropertyBar.viewModel.selectedStyleMoleculeId, _this.currentPropertyBar.viewModel.selectedStyleAtomType, _this.currentPropertyBar.viewModel.selectedResponsiveDeviceId, _this.currentPropertyBar.viewModel.selectedStateModifier).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.viewModel.tempPseudoSelector = "";
        };
        this.renderStyleQuantumControls = function () {
            return h(
                "div",
                { key: "0" },
                h("input", { key: "-3", value: _this.currentPropertyBar.viewModel.tempQuantumName, oninput: _this.currentPropertyBar.quantumNameInputHandler }),
                h("input", { key: "-2", value: _this.currentPropertyBar.viewModel.tempCssPropertyName, oninput: _this.currentPropertyBar.cssPropertyNameInputHandler }),
                h("input", { key: "-1", value: _this.currentPropertyBar.viewModel.tempCssValue, oninput: _this.currentPropertyBar.cssValueInputHandler }),
                h(
                    "button",
                    { key: "a", role: "button", onclick: _this.currentPropertyBar.createStyleQuantumClickHandler },
                    "\u2714"
                ),
                h(
                    "button",
                    { key: "b", role: "button", onclick: _this.currentPropertyBar.showAllCssPropertiesForQuantumClickHandler },
                    "?"
                )
            );
        };
        this.showAllCssPropertiesForQuantumClickHandler = function (evt) {
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.AllCssPropertiesForQuantum);
        };
        this.createStyleQuantumClickHandler = function (evt) {
            currentApp.controller.CreateStyleQuantumJson(currentApp.clientData.CaliforniaProject.CaliforniaProjectId, _this.currentPropertyBar.viewModel.tempQuantumName, _this.currentPropertyBar.viewModel.tempCssPropertyName, _this.currentPropertyBar.viewModel.tempCssValue).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.resetAddQuantumState();
        };
        this.resetAddQuantumState = function () {
            _this.currentPropertyBar.viewModel.tempQuantumName = "Quantum";
            _this.currentPropertyBar.viewModel.tempCssPropertyName = "";
            _this.currentPropertyBar.viewModel.tempCssValue = "";
        };
        this.quantumNameInputHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempQuantumName = evt.target.value;
        };
        this.renderStyleValueArray = function (propertyBar) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.StyleValueId;
            }, function createSectionTarget(source) {
                var sourceIdString = source.StyleValueId.toString();
                var styleValueButtonStyle = {
                    "flex": "0 0 auto",
                    "width": "auto",
                    "height": "1rem"
                };
                var styleValueTextStyle = {
                    "outline": source.CssValue === "" ? "solid white 1px" : undefined,
                    "outline-offset": source.CssValue === "" ? "-1px" : undefined,
                    "flex": "0 0 auto",
                    "width": "auto",
                    "margin": "0"
                };
                return {
                    renderMaquette: function renderMaquette() {
                        return h(
                            "div",
                            { key: sourceIdString, exitAnimation: propertyBar.styleElementExitAnimation, styles: { "display": "flex", "flex-flow": "row nowrap" } },
                            h(
                                "p",
                                { styles: styleValueTextStyle },
                                source.CssProperty,
                                ": ",
                                source.CssValue
                            ),
                            h(
                                "button",
                                { key: "a", role: "button", vid: sourceIdString, onclick: propertyBar.deleteStyleValueClickHandler, styles: styleValueButtonStyle },
                                "X"
                            ),
                            h(
                                "button",
                                { key: "b", role: "button", aid: source.StyleAtomId.toString(), vid: sourceIdString, onclick: propertyBar.updateCssValueClickHandler, styles: styleValueButtonStyle },
                                "Edit"
                            )
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        sourceIdString = source.StyleValueId.toString();
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.renderStyleQuantumArrayForStyleAtom = function () {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.StyleQuantumId;
            }, function createSectionTarget(source) {
                var sourceIdString = source.StyleQuantumId.toString();
                return {
                    renderMaquette: function renderMaquette() {
                        return h(
                            "div",
                            { key: sourceIdString },
                            h(
                                "p",
                                { styles: { "margin": "0" } },
                                source.Name,
                                ": ",
                                source.CssProperty,
                                " (",
                                source.CssValue,
                                ")"
                            )
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        sourceIdString = source.StyleQuantumId.toString();
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.renderStyleAtomArray = function (propertyBar) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.StyleAtomId;
            }, function createSectionTarget(source) {
                var styleAtomIdString = source.StyleAtomId.toString();
                var appliedValuesMap = propertyBar.renderStyleValueArray(propertyBar);
                var appliedQuantumsMap = propertyBar.renderStyleQuantumArrayForStyleAtom();
                if (source.AppliedValues !== undefined) {
                    appliedValuesMap.map(source.AppliedValues);
                } else {
                    appliedValuesMap.map([]);
                }
                if (source.MappedQuantums !== undefined) {
                    appliedQuantumsMap.map(source.MappedQuantums.map(function (qm) {
                        return qm.StyleQuantum;
                    }));
                } else {
                    appliedQuantumsMap.map([]);
                }
                return {
                    renderMaquette: function renderMaquette() {
                        var isDisplayStyleAtom = true;
                        if (propertyBar.viewModel.currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.StyleMolecule) {
                            var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                                return m.StyleMoleculeId == propertyBar.viewModel.selectedStyleMoleculeId;
                            });
                            var targetMappingIndex = styleMolecule.MappedStyleAtoms.findIndex(function (m) {
                                return m.ResponsiveDeviceId == propertyBar.viewModel.selectedResponsiveDeviceId && m.StyleMoleculeAtomMappingId == source.MappedToMoleculeId && (m.StateModifier === undefined && propertyBar.viewModel.selectedStateModifier === "" || m.StateModifier === propertyBar.viewModel.selectedStateModifier);
                            });
                            isDisplayStyleAtom = targetMappingIndex != -1;
                        }
                        var divStyleAtomStyles = {
                            "display": !isDisplayStyleAtom ? "none" : undefined,
                            "width": "100%",
                            "height": "auto"
                        };
                        return h(
                            "div",
                            { key: styleAtomIdString, exitAnimation: propertyBar.styleElementExitAnimation, styles: divStyleAtomStyles },
                            h(
                                "p",
                                { key: "0", styles: { "margin": "0" } },
                                "(#",
                                styleAtomIdString,
                                ")",
                                source.Name,
                                ":"
                            ),
                            appliedValuesMap.results.map(function (r) {
                                return r.renderMaquette();
                            }),
                            h(
                                "button",
                                { key: "a", role: "button", aid: styleAtomIdString, onclick: propertyBar.createCssPropertyForAtomClickHandler },
                                "+"
                            ),
                            h(
                                "button",
                                { key: "b", role: "button", aid: styleAtomIdString, onclick: propertyBar.moveStyleAtomPopupClickHandler },
                                "=>"
                            ),
                            source.IsDeletable ? h(
                                "button",
                                { key: "b0", role: "button", aid: styleAtomIdString, onclick: propertyBar.deleteStyleAtomClickHandler },
                                "X"
                            ) : h(
                                "button",
                                { disabled: true, key: "b1", role: "button", aid: styleAtomIdString },
                                "X"
                            ),
                            source.MappedQuantums.length > 0 ? h(
                                "p",
                                { key: "-1" },
                                "quantums:"
                            ) : undefined,
                            " ",
                            appliedQuantumsMap.results.map(function (r) {
                                return r.renderMaquette();
                            })
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        appliedValuesMap.map(updatedSource.AppliedValues);
                        appliedQuantumsMap.map(updatedSource.MappedQuantums.map(function (qm) {
                            return qm.StyleQuantum;
                        }));
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.moveStyleAtomPopupClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.selectedStyleAtomIdForPopup = CaliforniaApp_1.parseIntFromAttribute(evt.target, "aid");
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.MoveStyleAtom);
        };
        this.createCssPropertyForAtomClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.selectedStyleAtomId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "aid");
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.AddCssProperty);
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.AllCssProperties);
        };
        this.deleteStyleAtomClickHandler = function (evt) {
            currentApp.controller.DeleteStyleAtomJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "aid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.updateCssValueClickHandler = function (evt) {
            var styleValueId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "vid");
            var styleAtomId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "aid");
            _this.currentPropertyBar.viewModel.selectedStyleValueId = styleValueId;
            _this.currentPropertyBar.viewModel.selectedStyleAtomId = styleAtomId;
            var targetStyleValue = currentApp.clientData.CaliforniaProject.StyleValues.find(function (val) {
                return val.StyleValueId == styleValueId;
            });
            _this.currentPropertyBar.viewModel.tempCssValue = targetStyleValue.CssValue;
            _this.currentPropertyBar.viewModel.tempCssPropertyName = targetStyleValue.CssProperty;
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.UpdateCssValue);
        };
        this.deleteStyleValueClickHandler = function (evt) {
            currentApp.controller.DeleteStyleValueJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "vid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.renderAddCssPropertyPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.AddCssProperty || _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.AllCssProperties;
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.AddCssProperty], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px" } },
                h(
                    "div",
                    { styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.saveCssPropertyForAtomClickHandler },
                        "\u2714"
                    ),
                    h(
                        "button",
                        { key: "b", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelAddCssPropertyForAtomClickHandler },
                        "x"
                    )
                ),
                h(
                    "div",
                    null,
                    h("input", { key: "-1", value: _this.currentPropertyBar.viewModel.tempCssPropertyName, oninput: _this.currentPropertyBar.cssPropertyNameInputHandler }),
                    h(
                        "button",
                        { key: "a", role: "button", onclick: _this.currentPropertyBar.showAllCssPropertiesClickHandler },
                        "?"
                    )
                )
            );
        };
        this.renderAllCssPropertiesForQuantumPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.AllCssPropertiesForQuantum;
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.AllCssPropertiesForQuantum], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px", "height": "300px", "overflow": "scroll" } },
                h(
                    "div",
                    { styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelUpdateCssPropertyForQuantumClickHandler },
                        "x"
                    )
                ),
                currentApp.clientData.AllCssProperties.map(function (prop) {
                    return h(
                        "div",
                        { key: prop },
                        prop,
                        h(
                            "button",
                            { key: "a", role: "button", cid: prop, onclick: _this.currentPropertyBar.setSelectedCssPropertyForQuantumClickHandler },
                            "\u2714"
                        )
                    );
                })
            );
        };
        this.setSelectedCssPropertyForQuantumClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCssPropertyName = CaliforniaApp_1.parseStringFromAttribute(evt.target, "cid");
            _this.currentPropertyBar.closePopup();
        };
        this.cancelUpdateCssPropertyForQuantumClickHandler = function (evt) {
            _this.currentPropertyBar.closePopup();
        };
        this.insertLayoutRowIntoViewPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.InsertLayoutRowIntoView;
            var instanceableLayoutRows = [];
            if (isPopupVisible) {
                var instanceableRowsView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (view) {
                    return view.IsInternal && view.Name === "[Internal] Instanceable Layout Rows";
                });
                instanceableLayoutRows.push.apply(instanceableLayoutRows, instanceableRowsView.PlacedLayoutRows);
                var userInstanceableRowsView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (view) {
                    return view.IsInternal && view.Name === "[Internal] User Layout Molecules";
                });
                for (var i = 1; i < userInstanceableRowsView.PlacedLayoutRows.length; i++) {
                    instanceableLayoutRows.push(userInstanceableRowsView.PlacedLayoutRows[i]);
                }
            }
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.InsertLayoutRowIntoView], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px", "height": "300px", "overflow": "scroll" } },
                h(
                    "div",
                    { styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelInsertLayoutRowIntoViewClickHandler },
                        "x"
                    )
                ),
                instanceableLayoutRows.map(function (prop) {
                    return h(
                        "div",
                        { key: prop.LayoutBaseId },
                        h(
                            "button",
                            { styles: { "width": "auto", "margin": "0" }, key: "a", lid: prop.LayoutBaseId.toString(), onclick: _this.currentPropertyBar.insertSelectedLayoutRowIntoViewClickHandler, onmouseenter: _this.currentPropertyBar.insertRowShowPreviewHandler, onmouseleave: _this.currentPropertyBar.insertRowHidePreviewHandler },
                            "\u2714"
                        ),
                        h(
                            "p",
                            { key: "0", styles: { "-webkit-user-select": "none", "width": "auto", "margin": "0", "float": "left" }, lid: prop.LayoutBaseId.toString(), ontouchstart: _this.currentPropertyBar.insertRowShowPreviewHandler, ontouchend: _this.currentPropertyBar.insertRowHidePreviewHandler },
                            prop.LayoutBaseId
                        )
                    );
                })
            );
        };
        this.insertSelectedLayoutRowIntoViewClickHandler = function (evt) {
            var layoutId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            currentApp.controller.CreateLayoutRowForViewJson(_this.currentPropertyBar.viewModel.selectedCaliforniaViewId, layoutId).done(function (data) {
                return currentApp.router.updateData(data);
            });
            currentApp.state.lastCommand = CaliforniaGenerated_1.CaliforniaEvent.CreateLayoutRowForView;
            currentApp.state.lastCaliforniaEventData = [_this.currentPropertyBar.viewModel.selectedCaliforniaViewId, layoutId];
            _this.currentPropertyBar.closePopup();
        };
        this.cancelInsertLayoutRowIntoViewClickHandler = function (evt) {
            _this.currentPropertyBar.closePopup();
        };
        this.insertLayoutAtomIntoBoxPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.InsertLayoutAtomIntoBox;
            var instanceableLayoutAtoms = [];
            if (isPopupVisible) {
                var instanceableAtomsView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (view) {
                    return view.IsInternal && view.Name === "[Internal] Instanceable Layout Atoms";
                });
                var atomContainerBox = instanceableAtomsView.PlacedLayoutRows[0].AllBoxesBelowRow.find(function (b) {
                    return b.PlacedInBoxAtoms.length > 0;
                });
                instanceableLayoutAtoms.push.apply(instanceableLayoutAtoms, atomContainerBox.PlacedInBoxAtoms);
            }
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.InsertLayoutAtomIntoBox], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px", "height": "300px", "overflow": "scroll" } },
                h(
                    "div",
                    { styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelInsertLayoutAtomIntoBoxClickHandler },
                        "x"
                    )
                ),
                instanceableLayoutAtoms.map(function (prop) {
                    var textPreview = "";
                    if (prop.HostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Text) {
                        textPreview = prop.HostedContentAtom.TextContent;
                    } else if (prop.HostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Link) {
                        textPreview = prop.HostedContentAtom.Url;
                    } else {
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                        return;
                    }
                    return h(
                        "div",
                        { key: prop.LayoutBaseId },
                        h(
                            "button",
                            { styles: { "width": "auto", "margin": "0" }, key: "a", lid: prop.LayoutBaseId.toString(), onclick: _this.currentPropertyBar.insertSelectedLayoutAtomIntoBoxClickHandler, onmouseenter: _this.currentPropertyBar.insertAtomShowPreviewHandler, onmouseleave: _this.currentPropertyBar.insertAtomHidePreviewHandler },
                            "\u2714"
                        ),
                        h(
                            "p",
                            { key: "0", styles: { "-webkit-user-select": "none", "width": "auto", "margin": "0", "float": "left" }, lid: prop.LayoutBaseId.toString(), ontouchstart: _this.currentPropertyBar.insertAtomShowPreviewHandler, ontouchend: _this.currentPropertyBar.insertAtomHidePreviewHandler },
                            prop.LayoutBaseId,
                            " ",
                            textPreview
                        )
                    );
                })
            );
        };
        this.insertSelectedLayoutAtomIntoBoxClickHandler = function (evt) {
            var targetBoxId = currentApp.state.selectedLayoutBaseId;
            currentApp.controller.CreateLayoutAtomForBoxJson(targetBoxId, CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid")).done(function (data) {
                currentApp.router.updateData(data);
                currentApp.projector.renderNow();
                var updatedSubAtoms = currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                    return l.LayoutBaseId == targetBoxId;
                }).PlacedInBoxAtoms;
                _this.currentPropertyBar.viewModel.editedLayoutAtomId = updatedSubAtoms[updatedSubAtoms.length - 1].LayoutBaseId;
            });
            _this.currentPropertyBar.closePopup();
        };
        this.cancelInsertLayoutAtomIntoBoxClickHandler = function (evt) {
            _this.currentPropertyBar.closePopup();
        };
        this.displayPopup = function (targetPosition, popupMode) {
            var popupElement = null;
            popupElement = document.getElementById(_this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[popupMode]);
            if (popupElement !== null) {
                _this.viewModel.currentPopupMode = popupMode;
                var displayPopup = new popperjs.default(targetPosition, popupElement, {
                    placement: 'bottom-end',
                    modifiers: {
                        preventOverflow: {
                            boundariesElement: document.body
                        }
                    }
                });
                currentApp.projector.renderNow();
                return;
            }
            console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
        };
        this.closePopup = function () {
            _this.viewModel.currentPopupMode = PropertyBarVM_1.PopupMode.None;
            _this.viewModel.currentSecondaryPopupMode = PropertyBarVM_1.PopupSecondaryMode.None;
        };
        this.insertLayoutBoxIntoBoxPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.SelectBox;
            var instanceableLayoutBoxes = [];
            if (isPopupVisible) {
                var instanceableRowsView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (view) {
                    return view.IsInternal && view.Name === "[Internal] Instanceable Layout Rows";
                });
                var allBoxes = instanceableRowsView.PlacedLayoutRows[0].AllBoxesBelowRow;
                var firstSubBox = allBoxes.find(function (b) {
                    return b.PlacedBoxInBoxId === undefined;
                });
                instanceableLayoutBoxes.push(firstSubBox);
                var userInstanceableView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (view) {
                    return view.IsInternal && view.Name === "[Internal] User Layout Molecules";
                });
                var userBoxes = userInstanceableView.PlacedLayoutRows[0].AllBoxesBelowRow.filter(function (b) {
                    return b.PlacedBoxInBoxId === undefined;
                });
                instanceableLayoutBoxes.push.apply(instanceableLayoutBoxes, userBoxes);
            }
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.SelectBox], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px", "height": "300px", "overflow": "scroll" } },
                h(
                    "div",
                    { styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelInsertLayoutBoxIntoBoxClickHandler },
                        "x"
                    )
                ),
                instanceableLayoutBoxes.map(function (prop) {
                    return h(
                        "div",
                        { key: prop.LayoutBaseId },
                        h(
                            "button",
                            { styles: { "width": "auto", "margin": "0" }, key: "a", role: "button", lid: prop.LayoutBaseId.toString(), onclick: _this.currentPropertyBar.insertSelectedLayoutBoxIntoBoxOrRowClickHandler, onmouseenter: _this.currentPropertyBar.insertBoxShowPreviewHandler, onmouseleave: _this.currentPropertyBar.insertBoxHidePreviewHandler },
                            "\u2714"
                        ),
                        h(
                            "p",
                            { key: "0", styles: { "-webkit-user-select": "none", "width": "auto", "margin": "0", "float": "left" }, lid: prop.LayoutBaseId.toString(), ontouchstart: _this.currentPropertyBar.insertBoxShowPreviewHandler, ontouchend: _this.currentPropertyBar.insertBoxHidePreviewHandler },
                            prop.LayoutBaseId
                        )
                    );
                })
            );
        };
        this.insertRowShowPreviewHandler = function (evt) {
            var targetElement = evt.target;
            var hoveredLayoutId = CaliforniaApp_1.parseIntFromAttribute(targetElement, "lid");
            currentApp.state.hoveredInsertLayoutBaseId = hoveredLayoutId;
            var tempRow = currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                return l.LayoutBaseId == hoveredLayoutId;
            });
            currentApp.state.backupSortOrder = tempRow.LayoutSortOrderKey;
            tempRow.LayoutSortOrderKey = exports.VERY_HIGH_VALUE;
            var californiaView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (v) {
                return v.CaliforniaViewId == _this.currentPropertyBar.viewModel.selectedCaliforniaViewId;
            });
            californiaView.PlacedLayoutRows.push(tempRow);
            currentApp.router.setActiveCaliforniaView(californiaView);
        };
        this.insertRowHidePreviewHandler = function (evt) {
            var californiaView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (v) {
                return v.CaliforniaViewId == _this.currentPropertyBar.viewModel.selectedCaliforniaViewId;
            });
            var tempRowIndex = californiaView.PlacedLayoutRows.findIndex(function (r) {
                return r.LayoutBaseId == currentApp.state.hoveredInsertLayoutBaseId;
            });
            if (tempRowIndex != -1) {
                var tempRow = californiaView.PlacedLayoutRows.splice(tempRowIndex, 1)[0];
                if (currentApp.state.backupSortOrder !== undefined) {
                    tempRow.LayoutSortOrderKey = currentApp.state.backupSortOrder;
                } else {
                    console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                }
                currentApp.state.backupSortOrder = undefined;
                currentApp.state.hoveredInsertLayoutBaseId = 0;
                currentApp.router.setActiveCaliforniaView(californiaView);
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
        };
        this.insertBoxShowPreviewHandler = function (evt) {
            var targetElement = evt.target;
            var hoveredLayoutId = CaliforniaApp_1.parseIntFromAttribute(targetElement, "lid");
            currentApp.state.hoveredInsertLayoutBaseId = hoveredLayoutId;
            var tempBox = currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                return l.LayoutBaseId == hoveredLayoutId;
            });
            currentApp.state.backupSortOrder = tempBox.LayoutSortOrderKey;
            tempBox.LayoutSortOrderKey = exports.VERY_HIGH_VALUE;
            var selectedBoxOrRow = currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                return l.LayoutBaseId == currentApp.state.selectedLayoutBaseId;
            });
            if (selectedBoxOrRow.LayoutType === CaliforniaGenerated_1.LayoutType.Box) {
                selectedBoxOrRow.PlacedInBoxBoxes.push(tempBox);
            } else if (selectedBoxOrRow.LayoutType === CaliforniaGenerated_1.LayoutType.Row) {
                var tempNewOwnerRow = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (v) {
                    return v.CaliforniaViewId == currentApp.pagePreviewVM.activeCaliforniaViewId;
                }).PlacedLayoutRows.find(function (ro) {
                    return ro.LayoutBaseId == currentApp.state.selectedLayoutBaseId;
                });
                tempNewOwnerRow.AllBoxesBelowRow.push(tempBox);
                currentApp.state.backupOwnerRowId = tempBox.BoxOwnerRowId;
                tempBox.BoxOwnerRowId = tempNewOwnerRow.LayoutBaseId;
                tempBox.BoxOwnerRow = tempNewOwnerRow;
                currentApp.state.backupPlacedBoxInBoxId = tempBox.PlacedBoxInBoxId;
                tempBox.PlacedBoxInBoxId = undefined;
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
            currentApp.router.setActiveCaliforniaView(currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (v) {
                return v.CaliforniaViewId == currentApp.pagePreviewVM.activeCaliforniaViewId;
            }));
        };
        this.insertBoxHidePreviewHandler = function (evt) {
            var selectedBoxOrRow = currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                return l.LayoutBaseId == currentApp.state.selectedLayoutBaseId;
            });
            if (selectedBoxOrRow.LayoutType === CaliforniaGenerated_1.LayoutType.Box) {
                var layoutBox = selectedBoxOrRow;
                var tempBoxIndex = layoutBox.PlacedInBoxBoxes.findIndex(function (b) {
                    return b.LayoutBaseId == currentApp.state.hoveredInsertLayoutBaseId;
                });
                if (tempBoxIndex != -1) {
                    var tempBox = layoutBox.PlacedInBoxBoxes.splice(tempBoxIndex, 1)[0];
                    if (currentApp.state.backupSortOrder !== undefined) {
                        tempBox.LayoutSortOrderKey = currentApp.state.backupSortOrder;
                    } else {
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                    }
                    currentApp.state.backupSortOrder = undefined;
                    currentApp.state.hoveredInsertLayoutBaseId = 0;
                } else {
                    console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                }
            } else if (selectedBoxOrRow.LayoutType === CaliforniaGenerated_1.LayoutType.Row) {
                var layoutRow = selectedBoxOrRow;
                var tempBoxIndex = layoutRow.AllBoxesBelowRow.findIndex(function (b) {
                    return b.LayoutBaseId == currentApp.state.hoveredInsertLayoutBaseId;
                });
                if (tempBoxIndex != -1) {
                    var tempBox = layoutRow.AllBoxesBelowRow.splice(tempBoxIndex, 1)[0];
                    if (currentApp.state.backupSortOrder !== undefined) {
                        tempBox.LayoutSortOrderKey = currentApp.state.backupSortOrder;
                    } else {
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                    }
                    if (currentApp.state.backupOwnerRowId !== undefined) {
                        var backupRow = currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (r) {
                            return r.LayoutBaseId == currentApp.state.backupOwnerRowId;
                        });
                        tempBox.BoxOwnerRowId = currentApp.state.backupOwnerRowId;
                        tempBox.BoxOwnerRow = backupRow;
                        if (currentApp.state.backupPlacedBoxInBoxId !== undefined) {
                            tempBox.PlacedBoxInBoxId = currentApp.state.backupPlacedBoxInBoxId;
                        }
                        currentApp.state.backupOwnerRowId = undefined;
                        currentApp.state.backupPlacedBoxInBoxId = undefined;
                    }
                    currentApp.state.backupSortOrder = undefined;
                    currentApp.state.hoveredInsertLayoutBaseId = 0;
                } else {
                    console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                }
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
            currentApp.router.setActiveCaliforniaView(currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (v) {
                return v.CaliforniaViewId == currentApp.pagePreviewVM.activeCaliforniaViewId;
            }));
        };
        this.insertAtomShowPreviewHandler = function (evt) {
            var targetElement = evt.target;
            var hoveredLayoutId = CaliforniaApp_1.parseIntFromAttribute(targetElement, "lid");
            currentApp.state.hoveredInsertLayoutBaseId = hoveredLayoutId;
            var tempAtom = currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                return l.LayoutBaseId == hoveredLayoutId;
            });
            currentApp.state.backupSortOrder = tempAtom.LayoutSortOrderKey;
            tempAtom.LayoutSortOrderKey = exports.VERY_HIGH_VALUE;
            var layoutBox = currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                return l.LayoutBaseId == currentApp.state.selectedLayoutBaseId;
            });
            layoutBox.PlacedInBoxAtoms.push(tempAtom);
        };
        this.insertAtomHidePreviewHandler = function (evt) {
            var layoutBox = currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                return l.LayoutBaseId == currentApp.state.selectedLayoutBaseId;
            });
            var tempAtomIndex = layoutBox.PlacedInBoxAtoms.findIndex(function (a) {
                return a.LayoutBaseId == currentApp.state.hoveredInsertLayoutBaseId;
            });
            if (tempAtomIndex != -1) {
                var tempAtom = layoutBox.PlacedInBoxAtoms.splice(tempAtomIndex, 1)[0];
                if (currentApp.state.backupSortOrder !== undefined) {
                    tempAtom.LayoutSortOrderKey = currentApp.state.backupSortOrder;
                } else {
                    console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                }
                currentApp.state.backupSortOrder = undefined;
                currentApp.state.hoveredInsertLayoutBaseId = 0;
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
        };
        this.insertSelectedLayoutBoxIntoBoxOrRowClickHandler = function (evt) {
            if (_this.viewModel.currentSecondaryPopupMode === PropertyBarVM_1.PopupSecondaryMode.SelectBoxIntoBox) {
                var layoutId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
                var targetLayoutId = currentApp.state.selectedLayoutBaseId;
                currentApp.controller.CreateLayoutBoxForBoxOrRowJson(targetLayoutId, layoutId).done(function (data) {
                    currentApp.router.updateData(data);
                });
                currentApp.state.lastCommand = CaliforniaGenerated_1.CaliforniaEvent.CreateLayoutBoxForBoxOrRow;
                currentApp.state.lastCaliforniaEventData = [currentApp.state.selectedLayoutBaseId, layoutId];
            } else if (_this.viewModel.currentSecondaryPopupMode === PropertyBarVM_1.PopupSecondaryMode.SelectBoxIntoBoxAtomInPlace) {
                currentApp.controller.CreateLayoutBoxForAtomInPlaceJson(currentApp.state.selectedLayoutBaseId, CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid")).done(function (data) {
                    currentApp.router.updateData(data);
                });
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
            _this.currentPropertyBar.closePopup();
        };
        this.cancelInsertLayoutBoxIntoBoxClickHandler = function (evt) {
            _this.currentPropertyBar.closePopup();
        };
        this.moveLayoutMoleculeIntoLayoutMolecule = function () {
            currentApp.controller.MoveLayoutMoleculeIntoLayoutMoleculeJson(currentApp.state.preselectedLayoutBaseId, currentApp.state.selectedLayoutBaseId).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.closePopup();
        };
        this.moveLayoutMoleculeBeforeLayoutMolecule = function () {
            currentApp.controller.MoveLayoutMoleculeNextToLayoutMoleculeJson(currentApp.state.preselectedLayoutBaseId, currentApp.state.selectedLayoutBaseId, true).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.closePopup();
        };
        this.syncLayoutMoleculeStylesImitatingReferenceLayout = function () {
            currentApp.controller.SyncLayoutStylesImitatingReferenceLayoutJson(currentApp.state.selectedLayoutBaseId, currentApp.state.preselectedLayoutBaseId).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.closePopup();
        };
        this.moveStyleAtomToResponsiveDevicePopup = function () {
            var thisPopupMode = PropertyBarVM_1.PopupMode.MoveStyleAtom;
            var isPopupVisible = _this.viewModel.currentPopupMode === thisPopupMode;
            var isDataLoaded = currentApp.clientData.CaliforniaProject !== undefined && currentApp.clientData.CaliforniaProject.ResponsiveDevices !== undefined;
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[thisPopupMode], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px" } },
                h(
                    "div",
                    { styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelMoveStyleAtomClickHandler },
                        "x"
                    )
                ),
                isDataLoaded ? currentApp.clientData.CaliforniaProject.ResponsiveDevices.map(function (responsiveDevice) {
                    var responsiveDeviceIdString = responsiveDevice.ResponsiveDeviceId.toString();
                    var isSelectedResponsiveDeviceInPropertyBar = _this.currentPropertyBar.viewModel.selectedResponsiveDeviceId == responsiveDevice.ResponsiveDeviceId;
                    return h(
                        "div",
                        { key: responsiveDeviceIdString },
                        !isSelectedResponsiveDeviceInPropertyBar ? h(
                            "button",
                            { key: "a", rid: responsiveDeviceIdString, onclick: _this.currentPropertyBar.moveStyleAtomToResponsiveDeviceClickHandler },
                            responsiveDevice.NameShort
                        ) : h(
                            "button",
                            { disabled: true, key: "a0", rid: responsiveDeviceIdString, onclick: _this.currentPropertyBar.moveStyleAtomToResponsiveDeviceClickHandler },
                            responsiveDevice.NameShort
                        )
                    );
                }) : undefined
            );
        };
        this.moveStyleAtomToResponsiveDeviceClickHandler = function (evt) {
            var targetResponsiveDeviceId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "rid");
            currentApp.controller.MoveStyleAtomToResponsiveDeviceJson(_this.currentPropertyBar.viewModel.selectedStyleAtomIdForPopup, targetResponsiveDeviceId).done(function (data) {
                currentApp.router.updateData(data);
                _this.currentPropertyBar.viewModel.selectedResponsiveDeviceId = targetResponsiveDeviceId;
            });
            _this.currentPropertyBar.viewModel.selectedStyleAtomIdForPopup = 0;
            _this.currentPropertyBar.closePopup();
        };
        this.cancelMoveStyleAtomClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.selectedStyleAtomIdForPopup = 0;
            _this.currentPropertyBar.closePopup();
        };
        this.renderAllCssPropertiesPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.AllCssProperties;
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.AllCssProperties], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px", "height": "300px", "overflow": "scroll" } },
                h(
                    "div",
                    { styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelUpdateCssPropertylickHandler },
                        "x"
                    )
                ),
                currentApp.clientData.AllCssProperties.map(function (prop) {
                    var isPropertyUnmapped = true;
                    var isPropertyVisible = false;
                    if (_this.currentPropertyBar.viewModel.selectedStyleAtomId != 0 && currentApp.clientData.CaliforniaProject !== undefined && currentApp.clientData.CaliforniaProject.StyleAtoms !== undefined) {
                        var targetAtom = currentApp.clientData.CaliforniaProject.StyleAtoms.find(function (s) {
                            return s.StyleAtomId == _this.currentPropertyBar.viewModel.selectedStyleAtomId;
                        });
                        if (targetAtom !== undefined && targetAtom.AppliedValues !== undefined) {
                            isPropertyVisible = currentApp.clientData.StyleAtomCssPropertyMapping[CaliforniaGenerated_1.StyleAtomType[targetAtom.StyleAtomType]].findIndex(function (p) {
                                return p === prop;
                            }) != -1;
                            isPropertyUnmapped = targetAtom.AppliedValues.findIndex(function (v) {
                                return v.CssProperty === prop;
                            }) == -1;
                        }
                    }
                    return isPropertyVisible ? h(
                        "div",
                        { key: prop },
                        prop,
                        isPropertyUnmapped ? h(
                            "button",
                            { key: "a0", role: "button", cid: prop, onclick: _this.currentPropertyBar.setSelectedCssPropertyClickHandler },
                            "\u2714"
                        ) : h(
                            "button",
                            { disabled: true, key: "a1", role: "button", cid: prop, onclick: _this.currentPropertyBar.setSelectedCssPropertyClickHandler },
                            "\u2714"
                        )
                    ) : undefined;
                })
            );
        };
        this.cancelUpdateCssPropertylickHandler = function (evt) {
            _this.viewModel.currentPopupMode = PropertyBarVM_1.PopupMode.AddCssProperty;
        };
        this.showAllCssPropertiesClickHandler = function (evt) {
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.AllCssProperties);
        };
        this.setSelectedCssPropertyClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCssPropertyName = CaliforniaApp_1.parseStringFromAttribute(evt.target, "cid");
            _this.currentPropertyBar.saveCssPropertyForAtom();
        };
        this.saveCssPropertyForAtomClickHandler = function (evt) {
            _this.currentPropertyBar.saveCssPropertyForAtom();
        };
        this.saveCssPropertyForAtom = function () {
            currentApp.controller.CreateStyleValueForAtomJson(_this.currentPropertyBar.viewModel.selectedStyleAtomId, _this.currentPropertyBar.viewModel.tempCssPropertyName).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.resetTempCssPropertyState();
        };
        this.cancelAddCssPropertyForAtomClickHandler = function (evt) {
            _this.currentPropertyBar.resetTempCssPropertyState();
        };
        this.resetTempCssPropertyState = function () {
            _this.currentPropertyBar.viewModel.tempCssPropertyName = "";
            _this.currentPropertyBar.viewModel.tempCssValue = "";
            _this.currentPropertyBar.viewModel.selectedStyleAtomId = 0;
            _this.currentPropertyBar.viewModel.selectedStyleValueId = 0;
            _this.currentPropertyBar.viewModel.selectedStyleQuantumId = 0;
            _this.currentPropertyBar.closePopup();
        };
        this.cssPropertyNameInputHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCssPropertyName = evt.target.value;
        };
        this.renderUpdateCssValuePopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.UpdateCssValue || _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.MatchingQuantums;
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.UpdateCssValue], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px" } },
                h(
                    "div",
                    { styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.saveUpdatedCssValueClickHandler },
                        "\u2714"
                    ),
                    h(
                        "button",
                        { key: "b", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelUpdateCssValueClickHandler },
                        "x"
                    )
                ),
                h(
                    "div",
                    null,
                    h("input", { key: "-1", value: _this.currentPropertyBar.viewModel.tempCssValue, oninput: _this.currentPropertyBar.cssValueInputHandler }),
                    h(
                        "button",
                        { key: "a", role: "button", onclick: _this.currentPropertyBar.showMatchingQuantumsClickHandler },
                        "?"
                    ),
                    h(
                        "button",
                        { key: "b", role: "button", onclick: _this.currentPropertyBar.showSuggestedCssValuesClickHandler },
                        "??"
                    ),
                    h(
                        "button",
                        { key: "c", role: "button", onclick: _this.currentPropertyBar.setTempCssToZeroClickHandler },
                        "0"
                    ),
                    h(
                        "button",
                        { key: "d", role: "button", onclick: _this.currentPropertyBar.setTempCssToNoneClickHandler },
                        "none"
                    ),
                    h(
                        "button",
                        { key: "e", role: "button", onclick: _this.currentPropertyBar.setTempCssToNullClickHandler },
                        "null"
                    ),
                    h(
                        "button",
                        { key: "f", role: "button", onclick: _this.currentPropertyBar.setTempCssToAutoClickHandler },
                        "auto"
                    ),
                    _this.currentPropertyBar.viewModel.lastUsedTempCssValue !== "" ? h(
                        "button",
                        { key: "g", role: "button", onclick: _this.currentPropertyBar.setTempCssAppendLastUsedClickHandler },
                        "+",
                        _this.currentPropertyBar.viewModel.lastUsedTempCssValue.length > 10 ? _this.currentPropertyBar.viewModel.lastUsedTempCssValue.substring(0, 10) + "..." : _this.currentPropertyBar.viewModel.lastUsedTempCssValue
                    ) : undefined
                )
            );
        };
        this.showSuggestedCssValuesClickHandler = function (evt) {
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.SuggestedCssValues);
        };
        this.setTempCssToZeroClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCssValue = "0";
        };
        this.setTempCssToNullClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCssValue = "null";
        };
        this.setTempCssToNoneClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCssValue = "none";
        };
        this.setTempCssToAutoClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCssValue = "auto";
        };
        this.setTempCssAppendLastUsedClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCssValue = _this.currentPropertyBar.viewModel.tempCssValue + _this.currentPropertyBar.viewModel.lastUsedTempCssValue;
        };
        this.renderUpdateCssQuantumPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.UpdateCssQuantum;
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.UpdateCssQuantum], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px" } },
                h(
                    "div",
                    { styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.saveUpdatedCssQuantumClickHandler },
                        "\u2714"
                    ),
                    h(
                        "button",
                        { key: "b", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelUpdateCssQuantumClickHandler },
                        "x"
                    )
                ),
                h(
                    "div",
                    null,
                    h("input", { key: "-1", value: _this.currentPropertyBar.viewModel.tempCssValue, oninput: _this.currentPropertyBar.cssValueInputHandler })
                )
            );
        };
        this.showMatchingQuantumsClickHandler = function (evt) {
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.MatchingQuantums);
        };
        this.saveUpdatedCssQuantumClickHandler = function (evt) {
            currentApp.controller.UpdateStyleQuantumJson(_this.currentPropertyBar.viewModel.selectedStyleQuantumId, _this.currentPropertyBar.viewModel.tempCssValue).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.viewModel.lastUsedTempCssValue = _this.currentPropertyBar.viewModel.tempCssValue;
            _this.currentPropertyBar.resetTempCssPropertyState();
        };
        this.cancelUpdateCssQuantumClickHandler = function (evt) {
            _this.currentPropertyBar.resetTempCssPropertyState();
        };
        this.saveUpdatedCssValueFromAttrClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCssValue = CaliforniaApp_1.parseStringFromAttribute(evt.target, "fid");
            _this.currentPropertyBar.saveUpdatedCssValue();
        };
        this.saveUpdatedCssValueClickHandler = function (evt) {
            _this.currentPropertyBar.saveUpdatedCssValue();
        };
        this.saveUpdatedCssValue = function () {
            currentApp.controller.UpdateStyleValueJson(_this.currentPropertyBar.viewModel.selectedStyleValueId, _this.currentPropertyBar.viewModel.tempCssValue).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.viewModel.lastUsedTempCssValue = _this.currentPropertyBar.viewModel.tempCssValue;
            _this.currentPropertyBar.resetTempCssPropertyState();
        };
        this.cancelUpdateCssValueClickHandler = function (evt) {
            _this.currentPropertyBar.resetTempCssPropertyState();
        };
        this.cssValueInputHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCssValue = evt.target.value;
        };
        this.cssValueForInteractionInputHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCssValueForInteraction = evt.target.value;
        };
        this.renderSelectInteractionTargetPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.SelectInteractionTarget;
            var renderedOptions = [];
            if (isPopupVisible === true) {
                currentApp.clientData.CaliforniaProject.LayoutMolecules.map(function (m) {
                    var layoutBaseIdString = m.LayoutBaseId.toString();
                    renderedOptions.push(h(
                        "div",
                        { key: layoutBaseIdString, styles: { "flex": "0 0 100%", "width": "100%", "min-width": "100%" } },
                        "layout #",
                        layoutBaseIdString,
                        " ",
                        h(
                            "button",
                            { key: "a", role: "button", bid: layoutBaseIdString, onclick: _this.currentPropertyBar.selectLayoutBaseForInteractionTargetClickHandler },
                            "\u2714"
                        )
                    ));
                });
            }
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.SelectInteractionTarget], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px" } },
                h(
                    "div",
                    { key: "0", styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelSelectInteractionTargetClickHandler },
                        "x"
                    )
                ),
                h(
                    "div",
                    { key: "1", styles: { "display": "flex", "flex-flow": "row wrap" } },
                    renderedOptions
                )
            );
        };
        this.renderEditUserDefinedCssPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.EditUserDefinedCss;
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.EditUserDefinedCss], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px" } },
                h(
                    "div",
                    { key: "0", styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.confirmEditUserDefinedCssClickHandler },
                        "\u2714"
                    ),
                    h(
                        "button",
                        { key: "b", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelEditUserDefinedCssClickHandler },
                        "x"
                    )
                ),
                h(
                    "div",
                    { key: "1" },
                    h("textarea", { value: _this.currentPropertyBar.viewModel.tempUserDefinedCss, oninput: _this.currentPropertyBar.userDefinedCssInputHandler })
                )
            );
        };
        this.userDefinedCssInputHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempUserDefinedCss = evt.target.value;
        };
        this.updateUserDefinedCss = function () {
            if (_this.currentPropertyBar.viewModel.tempUserDefinedCss !== undefined) {
                currentApp.controller.UpdateUserDefinedCssForViewJson(currentApp.state.preselectedCaliforniaViewId, _this.currentPropertyBar.viewModel.tempUserDefinedCss).done(function (data) {
                    return currentApp.router.updateData(data);
                });
                _this.currentPropertyBar.cancelEditUserDefinedCss();
            }
        };
        this.cancelEditUserDefinedCssClickHandler = function (evt) {
            _this.currentPropertyBar.cancelEditUserDefinedCss();
        };
        this.confirmEditUserDefinedCssClickHandler = function (evt) {
            _this.currentPropertyBar.updateUserDefinedCss();
        };
        this.cancelEditUserDefinedCss = function () {
            _this.currentPropertyBar.viewModel.tempUserDefinedCss = "";
            currentApp.state.preselectedCaliforniaViewId = 0;
            _this.currentPropertyBar.closePopup();
        };
        this.selectLayoutBaseForInteractionTargetClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.selectedLayoutBaseIdForFilter = CaliforniaApp_1.parseIntFromAttribute(evt.target, "bid");
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.SelectInteractionTargetLayoutFilter);
        };
        this.cancelSelectInteractionTargetClickHandler = function (evt) {
            _this.currentPropertyBar.closePopup();
            _this.currentPropertyBar.viewModel.selectedLayoutBaseIdForFilter = 0;
            _this.currentPropertyBar.viewModel.selectedLayoutStyleInteraction = 0;
        };
        this.renderSelectInteractionTargetLayoutFilterPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.SelectInteractionTargetLayoutFilter;
            var renderedOptions = [];
            if (isPopupVisible === true) {
                currentApp.clientData.CaliforniaProject.StyleValues.map(function (v) {
                    var styleAtom = currentApp.clientData.CaliforniaProject.StyleAtoms.find(function (a) {
                        return a.AppliedValues.findIndex(function (map) {
                            return map.StyleValueId == v.StyleValueId;
                        }) != -1;
                    });
                    var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                        return m.MappedStyleAtoms.findIndex(function (map) {
                            return map.StyleMoleculeAtomMappingId == styleAtom.MappedToMoleculeId;
                        }) != -1;
                    });
                    if (styleMolecule.StyleForLayoutId == _this.currentPropertyBar.viewModel.selectedLayoutBaseIdForFilter) {
                        var styleValueIdString = v.StyleValueId.toString();
                        renderedOptions.push(h(
                            "div",
                            { key: styleValueIdString, styles: { "flex": "0 0 100%", "width": "100%", "min-width": "100%" } },
                            "value #",
                            styleValueIdString,
                            ": ",
                            v.CssProperty,
                            ":",
                            v.CssValue,
                            " ",
                            h(
                                "button",
                                { key: "a", role: "button", vid: styleValueIdString, onclick: _this.currentPropertyBar.selectStyleValueForInteractionTargetClickHandler },
                                "\u2714"
                            )
                        ));
                    }
                });
            }
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.SelectInteractionTargetLayoutFilter], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px" } },
                h(
                    "div",
                    { key: "0", styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelSelectStyleValueForInteractionTargetClickHandler },
                        "x"
                    )
                ),
                h(
                    "div",
                    { key: "1", styles: { "display": "flex", "flex-flow": "row wrap" } },
                    renderedOptions
                )
            );
        };
        this.selectStyleValueForInteractionTargetClickHandler = function (evt) {
            _this.currentPropertyBar.closePopup();
            currentApp.controller.CreateStyleValueInteractionJson(_this.currentPropertyBar.viewModel.selectedLayoutStyleInteraction, CaliforniaApp_1.parseIntFromAttribute(evt.target, "vid"), _this.currentPropertyBar.viewModel.tempCssValueForInteraction).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.cancelSelectStyleValueForInteractionTargetClickHandler = function (evt) {
            _this.currentPropertyBar.closePopup();
            _this.currentPropertyBar.viewModel.selectedLayoutBaseIdForFilter = 0;
            _this.currentPropertyBar.viewModel.selectedLayoutStyleInteraction = 0;
        };
        this.renderMatchingQuantumsPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.MatchingQuantums;
            var renderedOptions = [];
            if (isPopupVisible === true) {
                currentApp.clientData.CaliforniaProject.StyleQuantums.map(function (quantum) {
                    var isMatchingProperty = quantum.CssProperty === _this.currentPropertyBar.viewModel.tempCssPropertyName;
                    if (isMatchingProperty === true) {
                        renderedOptions.push(h(
                            "div",
                            { key: quantum.StyleQuantumId },
                            quantum.Name,
                            " = ",
                            quantum.CssValue,
                            " ",
                            h(
                                "button",
                                { key: "a", role: "button", qid: quantum.StyleQuantumId.toString(), onclick: _this.currentPropertyBar.setQuantumOnAtomClickHandler },
                                "\u2714"
                            )
                        ));
                    }
                });
                if (renderedOptions.length == 0) {
                    renderedOptions.push(h(
                        "div",
                        { key: "0" },
                        "No quantums available."
                    ));
                }
            }
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.MatchingQuantums], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px", "height": "300px", "overflow": "scroll" } },
                h(
                    "div",
                    { styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelSelectMatchingCssQuantumClickHandler },
                        "x"
                    )
                ),
                renderedOptions
            );
        };
        this.cancelSelectMatchingCssQuantumClickHandler = function (evt) {
            _this.viewModel.currentPopupMode = PropertyBarVM_1.PopupMode.UpdateCssValue;
        };
        this.renderSuggestedCssValuesPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.SuggestedCssValues;
            var renderedOptions = [];
            if (isPopupVisible === true) {
                if (_this.currentPropertyBar.viewModel.tempCssPropertyName === "font-family") {
                    currentApp.clientData.ThirdPartyFonts.map(function (family, index) {
                        renderedOptions.push(h(
                            "div",
                            { key: index },
                            "Google Font: ",
                            family,
                            " ",
                            h(
                                "button",
                                { key: "a", role: "button", fid: family, onclick: _this.currentPropertyBar.saveUpdatedCssValueFromAttrClickHandler },
                                "\u2714"
                            )
                        ));
                    });
                }
                if (renderedOptions.length == 0) {
                    renderedOptions.push(h(
                        "div",
                        { key: "0" },
                        "No suggestions available."
                    ));
                }
            }
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.SuggestedCssValues], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px", "height": "300px", "overflow": "scroll" } },
                h(
                    "div",
                    { styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "a", role: "button", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelSuggestedCssValuesClickHandler },
                        "x"
                    )
                ),
                renderedOptions
            );
        };
        this.cancelSuggestedCssValuesClickHandler = function (evt) {
            _this.currentPropertyBar.closePopup();
        };
        this.setQuantumOnAtomClickHandler = function (evt) {
            var quantumId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "qid");
            currentApp.controller.ApplyStyleQuantumToAtomJson(_this.currentPropertyBar.viewModel.selectedStyleAtomId, quantumId).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.resetTempCssPropertyState();
            _this.currentPropertyBar.viewModel.lastUsedTempCssValue = currentApp.clientData.CaliforniaProject.StyleQuantums.find(function (q) {
                return q.StyleQuantumId == quantumId;
            }).CssValue;
        };
        this.renderStyleMoleculeArray = function (propertyBar) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.StyleMoleculeId;
            }, function createSectionTarget(source) {
                var sourceStyleMoleculeIdString = source.StyleMoleculeId.toString();
                return {
                    renderMaquette: function renderMaquette() {
                        return h(
                            "div",
                            { key: sourceStyleMoleculeIdString, exitAnimation: propertyBar.styleElementExitAnimation },
                            h(
                                "p",
                                null,
                                "(#",
                                sourceStyleMoleculeIdString,
                                ")",
                                source.Name
                            ),
                            h(
                                "button",
                                { key: "a", role: "button", mid: sourceStyleMoleculeIdString, onclick: propertyBar.selectStyleMoleculeClickHandler },
                                "Edit"
                            )
                        );
                    },
                    update: function update(updatedSource) {
                        sourceStyleMoleculeIdString = updatedSource.StyleMoleculeId.toString();
                        source = updatedSource;
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.selectStyleMoleculeClickHandler = function (evt) {
            _this.nextExceptLastPropertyBar.viewModel.selectedStyleMoleculeId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "mid");
            _this.nextExceptLastPropertyBar.viewModel.selectedStateModifier = "";
            _this.nextExceptLastPropertyBar.viewModel.currentPropertyBarMode = PropertyBarVM_1.PropertyBarMode.StyleMolecule;
        };
        this.showEditUserDefinedCssClickHandler = function (evt) {
            var californiaViewId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "vid");
            var californiaViewCss = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (v) {
                return v.CaliforniaViewId == californiaViewId;
            }).UserDefinedCss;
            _this.currentPropertyBar.viewModel.tempUserDefinedCss = californiaViewCss !== undefined ? californiaViewCss : "";
            currentApp.state.preselectedCaliforniaViewId = californiaViewId;
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.EditUserDefinedCss);
        };
        this.highlightLayoutBaseClickHandler = function (evt) {
            var targetLayoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            if (currentApp.state.highlightedLayoutBaseId != targetLayoutBaseId) {
                currentApp.state.highlightedLayoutBaseId = targetLayoutBaseId;
            } else {
                currentApp.state.highlightedLayoutBaseId = 0;
            }
        };
        this.renderStyleQuantumArray = function (propertyBar) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.StyleQuantumId;
            }, function createSectionTarget(source) {
                var sourceIdString = source.StyleQuantumId.toString();
                return {
                    renderMaquette: function renderMaquette() {
                        return h(
                            "div",
                            { key: sourceIdString, exitAnimation: propertyBar.styleElementExitAnimation },
                            h(
                                "p",
                                { key: "0", styles: { "margin": "0" } },
                                "(#",
                                sourceIdString,
                                ")",
                                source.Name,
                                ": ",
                                source.CssProperty,
                                " => ",
                                source.CssValue
                            ),
                            h(
                                "button",
                                { key: "a", role: "button", qid: sourceIdString, onclick: propertyBar.duplicateStyleQuantumClickHandler },
                                "DD"
                            ),
                            source.IsDeletable ? h(
                                "button",
                                { key: "b0", role: "button", qid: sourceIdString, onclick: propertyBar.deleteStyleQuantumClickHandler },
                                "X"
                            ) : h(
                                "button",
                                { disabled: true, key: "b1", role: "button" },
                                "X"
                            ),
                            h(
                                "button",
                                { key: "c", role: "button", qid: sourceIdString, onclick: propertyBar.updateCssQuantumClickHandler },
                                "Edit"
                            )
                        );
                    },
                    update: function update(updatedSource) {
                        sourceIdString = updatedSource.StyleQuantumId.toString();
                        source = updatedSource;
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.updateCssQuantumClickHandler = function (evt) {
            var styleQuantumId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "qid");
            _this.currentPropertyBar.viewModel.selectedStyleQuantumId = styleQuantumId;
            var targetStyleQuantum = currentApp.clientData.CaliforniaProject.StyleQuantums.find(function (val) {
                return val.StyleQuantumId == styleQuantumId;
            });
            _this.currentPropertyBar.viewModel.tempCssValue = targetStyleQuantum.CssValue;
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.UpdateCssQuantum);
        };
        this.deleteStyleQuantumClickHandler = function (evt) {
            currentApp.controller.DeleteStyleQuantumJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "qid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.duplicateStyleQuantumClickHandler = function (evt) {
            currentApp.controller.DuplicateStyleQuantumJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "qid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.styleElementExitAnimation = function (domNode, removeElement, properties) {
            domNode.style.overflow = "hidden";
            velocity.animate(domNode, { opacity: 0.5, height: 0 }, { duration: 100, easing: "ease-out", complete: removeElement });
        };
        this.renderLayoutMoleculeArray = function (propertyBar) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.LayoutBaseId;
            }, function createSectionTarget(source) {
                var sourceLayoutBaseIdString = source.LayoutBaseId.toString();
                var sourceStyleMoleculeIdString = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                    return m.StyleForLayoutId == source.LayoutBaseId;
                }).StyleMoleculeId.toString();
                var layoutControlButtonStyles = {
                    "margin-right": "5px"
                };
                return {
                    renderMaquette: function renderMaquette() {
                        var description = "";
                        if (source.LayoutType === CaliforniaGenerated_1.LayoutType.Atom) {
                            var sourceLayoutAtom = source;
                            var textContentString = "";
                            if (sourceLayoutAtom.HostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Text) {
                                textContentString = sourceLayoutAtom.HostedContentAtom.TextContent;
                            } else if (sourceLayoutAtom.HostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Link) {
                                textContentString = sourceLayoutAtom.HostedContentAtom.Url;
                            } else {
                                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                            }
                            description = textContentString.length > 20 ? textContentString.substring(0, 20) + "..." : textContentString;
                            description += " in box #" + source.PlacedAtomInBoxId;
                        }
                        return h(
                            "div",
                            { key: sourceLayoutBaseIdString },
                            " ",
                            CaliforniaGenerated_1.LayoutType[source.LayoutType].toString(),
                            " #",
                            sourceLayoutBaseIdString,
                            " ",
                            description,
                            h(
                                "button",
                                { key: "a", role: "button", lid: sourceLayoutBaseIdString, onclick: propertyBar.selectLayoutBaseClickHandler, styles: layoutControlButtonStyles },
                                "?"
                            ),
                            h(
                                "button",
                                { key: "b", role: "button", mid: sourceStyleMoleculeIdString, onclick: propertyBar.selectStyleMoleculeClickHandler, styles: layoutControlButtonStyles },
                                "S"
                            ),
                            h(
                                "button",
                                { key: "c", role: "button", lid: sourceLayoutBaseIdString, onclick: propertyBar.deleteLayoutBaseClickHandler, styles: layoutControlButtonStyles },
                                "X"
                            )
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        sourceLayoutBaseIdString = source.LayoutBaseId.toString();
                        var sourceStyleMoleculeIdString = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                            return m.StyleForLayoutId == source.LayoutBaseId;
                        }).StyleMoleculeId.toString();
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.renderCaliforniaViewArray = function (propertyBar) {
            return maquette.createMapping(function getSectionSourceKey(source) {
                return source.CaliforniaViewId;
            }, function createSectionTarget(source) {
                var sourceCaliforniaViewIdString = source.CaliforniaViewId.toString();
                return {
                    renderMaquette: function renderMaquette() {
                        var isDeleteButtonEnabled = source.PlacedLayoutRows.length == 0;
                        return h(
                            "div",
                            { key: sourceCaliforniaViewIdString },
                            source.Name,
                            " View #",
                            sourceCaliforniaViewIdString,
                            h(
                                "button",
                                { key: "a", role: "button", vid: sourceCaliforniaViewIdString, onclick: propertyBar.selectCaliforniaViewClickHandler },
                                ":)"
                            ),
                            !source.IsInternal && source.CaliforniaViewId != currentApp.pagePreview.viewModel.activeCaliforniaViewId ? h(
                                "button",
                                { key: "b", role: "button", vid: sourceCaliforniaViewIdString, onclick: propertyBar.activateCaliforniaViewClickHandler },
                                "\u2714"
                            ) : undefined,
                            ": ",
                            source.IsInternal ? "internal" : undefined,
                            " ",
                            source.Name,
                            " hosted by ",
                            source.HostedByLayoutMappings.length,
                            " layouts",
                            h(
                                "button",
                                { key: "c", role: "button", mid: source.SpecialStyleViewStyleMoleculeIdString, onclick: propertyBar.selectStyleMoleculeClickHandler },
                                "style #",
                                source.SpecialStyleViewStyleMoleculeIdString
                            ),
                            h(
                                "button",
                                { key: "d", role: "button", mid: source.SpecialStyleBodyStyleMoleculeIdString, onclick: propertyBar.selectStyleMoleculeClickHandler },
                                "body style #",
                                source.SpecialStyleBodyStyleMoleculeIdString
                            ),
                            h(
                                "button",
                                { key: "e", role: "button", mid: source.SpecialStyleHtmlStyleMoleculeIdString, onclick: propertyBar.selectStyleMoleculeClickHandler },
                                "HTML style #",
                                source.SpecialStyleHtmlStyleMoleculeIdString
                            ),
                            h(
                                "button",
                                { key: "f", role: "button", vid: sourceCaliforniaViewIdString, onclick: propertyBar.showEditUserDefinedCssClickHandler },
                                "CSS"
                            ),
                            isDeleteButtonEnabled ? h(
                                "button",
                                { key: "g", role: "button", vid: sourceCaliforniaViewIdString, onclick: propertyBar.deleteCaliforniaViewClickHandler },
                                "X"
                            ) : h(
                                "button",
                                { disabled: true, key: "g0", role: "button", onclick: propertyBar.deleteCaliforniaViewClickHandler },
                                "X"
                            )
                        );
                    },
                    update: function update(updatedSource) {
                        source = updatedSource;
                        sourceCaliforniaViewIdString = source.CaliforniaViewId.toString();
                    }
                };
            }, function updateSectionTarget(updatedSource, target) {
                target.update(updatedSource);
            });
        };
        this.logoutPopupClickHandler = function (evt) {
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.ShareCaliforniaProject);
        };
        this.renderShareCaliforniaProjectPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.ShareCaliforniaProject;
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.ShareCaliforniaProject], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px" } },
                h(
                    "div",
                    { key: "0", styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "b", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelShareCaliforniaProjectClickHandler },
                        "x"
                    )
                ),
                h(
                    "div",
                    { key: "1", styles: { "display": "flex", "flex-flow": "row wrap" } },
                    h(
                        "p",
                        { key: "a", styles: { "flex": "0 0 100%", "width": "100%", "min-width": "100%" } },
                        currentApp.clientData.UrlToReadOnly
                    ),
                    "Bookmark! Clear browser history!",
                    h(
                        "button",
                        { key: "c", type: "button", onclick: _this.currentPropertyBar.logoutClickHandler, styles: { "flex": "0 0 10%", "width": "10%", "min-width": "10%" } },
                        "\uD83D\uDD12"
                    ),
                    h(
                        "button",
                        { key: "d", type: "button", onclick: _this.currentPropertyBar.tokyoClickHandler, styles: { "flex": "0 0 10%", "width": "10%", "min-width": "10%" } },
                        "TOKYO"
                    )
                )
            );
        };
        this.tokyoClickHandler = function (evt) {
            window.location.assign(window.location.origin + "/tokyo/");
        };
        this.cancelShareCaliforniaProjectClickHandler = function (evt) {
            _this.currentPropertyBar.closePopup();
        };
        this.logoutClickHandler = function (evt) {
            currentApp.controller.LogoutAction().done(function (response) {
                window.location.assign(window.location.origin + "/california/");
            });
        };
        this.activateCaliforniaViewClickHandler = function (evt) {
            var californiaViewId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "vid");
            var userPages = currentApp.clientData.CaliforniaProject.CaliforniaViews.filter(function (view) {
                return !view.IsInternal;
            });
            var activeView = undefined;
            var activePageIndex = userPages.findIndex(function (v) {
                return v.CaliforniaViewId == californiaViewId;
            });
            if (activePageIndex > -1) {
                activeView = userPages[activePageIndex];
                currentApp.router.setActiveCaliforniaView(activeView);
                currentApp.pagePreview.resetEquationNumbersWhenModifying(true);
                _this.currentPropertyBar.viewModel.setSelectedCaliforniaView(activeView, true);
                _this.viewModel.currentPropertyBarMode = PropertyBarVM_1.PropertyBarMode.CaliforniaView;
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
        };
        this.selectLayoutBaseClickHandler = function (evt) {
            var layoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            currentApp.state.selectedLayoutBaseId = layoutBaseId;
            _this.currentPropertyBar.viewModel.currentPropertyBarMode = PropertyBarVM_1.PropertyBarMode.LayoutBase;
        };
        this.selectCaliforniaViewClickHandler = function (evt) {
            var californiaViewId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "vid");
            var userPages = currentApp.clientData.CaliforniaProject.CaliforniaViews.filter(function (view) {
                return !view.IsInternal;
            });
            var activeView = undefined;
            var activePageIndex = userPages.findIndex(function (v) {
                return v.CaliforniaViewId == californiaViewId;
            });
            if (activePageIndex > -1) {
                activeView = userPages[activePageIndex];
                if (_this.currentPropertyBar.propertyBarIndex == 0) {
                    currentApp.router.setActiveCaliforniaView(activeView);
                    currentApp.pagePreview.resetEquationNumbersWhenModifying(true);
                } else {
                    _this.currentPropertyBar.viewModel.isSyncedWithBoxTreeToTheLeft = false;
                }
                _this.currentPropertyBar.viewModel.setSelectedCaliforniaView(activeView, true);
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
            _this.currentPropertyBar.viewModel.currentPropertyBarMode = PropertyBarVM_1.PropertyBarMode.CaliforniaView;
        };
        this.deleteLayoutBaseClickHandler = function (evt) {
            if (currentApp.state.preselectedLayoutBaseId != 0) {
                return;
            }
            currentApp.state.selectedLayoutBaseId = 0;
            currentApp.controller.DeleteLayoutJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid"), false).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.deleteBelowLayoutBaseClickHandler = function (evt) {
            if (currentApp.state.preselectedLayoutBaseId != 0) {
                return;
            }
            currentApp.state.selectedLayoutBaseId = 0;
            currentApp.controller.DeleteLayoutJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid"), true).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.renderLayoutBaseControls = function () {
            if (currentApp.state.selectedLayoutBaseId == 0) {
                return undefined;
            }
            var selectedLayoutBase = currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                return l.LayoutBaseId == currentApp.state.selectedLayoutBaseId;
            });
            var layoutBaseIdString = selectedLayoutBase.LayoutBaseId.toString();
            var sourceStyleMoleculeIdString = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                return m.StyleForLayoutId == selectedLayoutBase.LayoutBaseId;
            }).StyleMoleculeId.toString();
            if (selectedLayoutBase.LayoutType === CaliforniaGenerated_1.LayoutType.Atom) {
                var selectedLayoutAtom = selectedLayoutBase;
                var isPictureContent = selectedLayoutAtom.HostedContentAtom.ContentAtomType === ContentAtomType_1.ContentAtomType.Picture;
                var pictureContentIdString = isPictureContent ? selectedLayoutAtom.HostedContentAtom.PictureContent.PictureContentId.toString() : undefined;
                return h(
                    "div",
                    { key: CaliforniaGenerated_1.LayoutType.Atom },
                    " Atom:",
                    h(
                        "button",
                        { key: "a", role: "button", mid: sourceStyleMoleculeIdString, onclick: _this.currentPropertyBar.selectStyleMoleculeClickHandler },
                        "style #",
                        sourceStyleMoleculeIdString
                    ),
                    h(
                        "button",
                        { key: "b", role: "button", lid: layoutBaseIdString, onclick: _this.currentPropertyBar.deleteLayoutBaseClickHandler },
                        "X"
                    ),
                    h(
                        "button",
                        { key: "c", role: "button", aid: layoutBaseIdString, onclick: _this.currentPropertyBar.createLayoutStyleInteraction },
                        "+ Interaction"
                    ),
                    selectedLayoutAtom.LayoutStyleInteractions.map(function (interaction) {
                        var interactionIdString = interaction.LayoutStyleInteractionId.toString();
                        return h(
                            "div",
                            { key: "i" + interactionIdString },
                            h(
                                "p",
                                { key: "0" },
                                "Interaction #",
                                interaction.LayoutStyleInteractionId
                            ),
                            h("input", { key: "1", value: _this.currentPropertyBar.viewModel.tempCssValueForInteraction, oninput: _this.currentPropertyBar.cssValueForInteractionInputHandler }),
                            _this.currentPropertyBar.viewModel.tempCssValueForInteraction !== "" ? h(
                                "button",
                                { key: "a", role: "button", lid: interactionIdString, onclick: _this.currentPropertyBar.selectInteractionTargetClickHandler },
                                "?"
                            ) : h(
                                "button",
                                { disabled: true, key: "a0", role: "button", lid: interactionIdString, onclick: _this.currentPropertyBar.selectInteractionTargetClickHandler },
                                "?"
                            ),
                            h(
                                "button",
                                { key: "b", role: "button", lid: interactionIdString, onclick: _this.currentPropertyBar.deleteLayoutStyleInteractionClickHandler },
                                "X"
                            ),
                            interaction.StyleValueInteractions.map(function (map) {
                                var mappingIdString = map.StyleValueInteractionMappingId.toString();
                                return h(
                                    "div",
                                    { key: mappingIdString },
                                    h(
                                        "p",
                                        { key: "0" },
                                        "#",
                                        mappingIdString,
                                        ": ",
                                        map.CssValue
                                    ),
                                    h(
                                        "button",
                                        { key: "a", role: "button", vid: map.StyleValueId.toString(), lid: interactionIdString, onclick: _this.currentPropertyBar.deleteStyleValueInteractionClickHandler },
                                        "X"
                                    )
                                );
                            })
                        );
                    }),
                    h(
                        "form",
                        { key: "0", action: "UploadFiles", method: "post", enctype: "multipart/form-data" },
                        h(
                            "p",
                            { key: "0" },
                            "picture id #",
                            pictureContentIdString
                        ),
                        h("input", { multiple: true, key: "1", type: "file", name: "formFiles", onchange: _this.currentPropertyBar.uploadFileChangeHandler }),
                        h(
                            "button",
                            { key: "a", role: "button", pid: pictureContentIdString, onclick: _this.currentPropertyBar.uploadFileClickHandler },
                            "..."
                        )
                    )
                );
            } else if (selectedLayoutBase.LayoutType === CaliforniaGenerated_1.LayoutType.Box) {
                var selectedLayoutBox_1 = selectedLayoutBase;
                var specialLayoutBoxTypeSelectors_1 = [];
                CaliforniaApp_1.getArrayForEnum(CaliforniaGenerated_1.SpecialLayoutBoxType).map(function (type, index) {
                    var isLayoutBoxType = index == selectedLayoutBox_1.SpecialLayoutBoxType;
                    var layoutBoxTypeString = index.toString();
                    specialLayoutBoxTypeSelectors_1.push(isLayoutBoxType ? h(
                        "option",
                        { selected: true, key: layoutBoxTypeString, value: layoutBoxTypeString },
                        type
                    ) : h(
                        "option",
                        { key: layoutBoxTypeString, value: layoutBoxTypeString },
                        type
                    ));
                });
                return h(
                    "div",
                    { key: CaliforniaGenerated_1.LayoutType.Box },
                    " Box:",
                    h(
                        "button",
                        { key: "a", role: "button", mid: sourceStyleMoleculeIdString, onclick: _this.currentPropertyBar.selectStyleMoleculeClickHandler },
                        "style #",
                        sourceStyleMoleculeIdString
                    ),
                    h(
                        "button",
                        { disabled: true, key: "b", role: "button", onclick: _this.currentPropertyBar.createViewForBoxClickHandler },
                        "Create View"
                    ),
                    h(
                        "button",
                        { key: "c", role: "button", lid: layoutBaseIdString, onclick: _this.currentPropertyBar.deleteLayoutBaseClickHandler },
                        "X"
                    ),
                    h(
                        "select",
                        { key: "0", bid: layoutBaseIdString, onchange: _this.currentPropertyBar.specialLayoutBoxTypeChangedHandler },
                        specialLayoutBoxTypeSelectors_1
                    )
                );
            } else if (selectedLayoutBase.LayoutType === CaliforniaGenerated_1.LayoutType.Row) {
                var selectedLayoutRow = selectedLayoutBase;
                var currentBoxCount = selectedLayoutRow.AllBoxesBelowRow.filter(function (b) {
                    return b.PlacedBoxInBoxId === undefined;
                }).length;
                var boxCountSelectors = [];
                for (var i = 0; i <= 12; i++) {
                    var isSelected = i == currentBoxCount;
                    var boxCountString = i.toString();
                    if (i == 0) {
                        boxCountSelectors.push(isSelected ? h(
                            "option",
                            { disabled: true, selected: true, key: boxCountString, value: boxCountString },
                            boxCountString
                        ) : h(
                            "option",
                            { disabled: true, key: boxCountString, value: boxCountString },
                            boxCountString
                        ));
                    } else {
                        boxCountSelectors.push(isSelected ? h(
                            "option",
                            { selected: true, key: boxCountString, value: boxCountString },
                            boxCountString
                        ) : h(
                            "option",
                            { key: boxCountString, value: boxCountString },
                            boxCountString
                        ));
                    }
                }
                return h(
                    "div",
                    { key: CaliforniaGenerated_1.LayoutType.Row },
                    " Row:",
                    h(
                        "button",
                        { key: "a", role: "button", mid: sourceStyleMoleculeIdString, onclick: _this.currentPropertyBar.selectStyleMoleculeClickHandler },
                        "style #",
                        sourceStyleMoleculeIdString
                    ),
                    h(
                        "button",
                        { key: "b", role: "button", lid: layoutBaseIdString, onclick: _this.currentPropertyBar.deleteLayoutBaseClickHandler },
                        "X"
                    ),
                    h(
                        "select",
                        { key: "c", rid: layoutBaseIdString, onchange: _this.currentPropertyBar.boxCountInRowChangedHandler },
                        boxCountSelectors
                    )
                );
            }
            console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            return undefined;
        };
        this.uploadFileChangeHandler = function (evt) {
            var fileSelector = evt.target;
            if (fileSelector.files !== null) {
                var fileArray = [];
                for (var index in fileSelector.files) {
                    var file = fileSelector.files[index];
                    fileArray.push(file);
                    console.log(file);
                    var fileReader = new FileReader();
                    fileReader.addEventListener("loadend", _this.currentPropertyBar.fileProcessingLoadEndHandler);
                }
                if (fileSelector.files.length == 0) {
                    console.log("empty");
                }
            } else {
                console.log("undefined");
            }
        };
        this.fileProcessingLoadEndHandler = function (evt) {
            console.log(evt.total);
            console.log(evt.target.result);
        };
        this.uploadFileClickHandler = function (evt) {
            evt.preventDefault();
            var targetForm = evt.target.form;
            console.log("upload dialog TODO");
            jQuery.ajax(targetForm.action, {
                method: targetForm.method,
                contentType: "multipart/form-data",
                data: $(targetForm).serialize()
            });
        };
        this.selectInteractionTargetClickHandler = function (evt) {
            _this.currentPropertyBar.viewModel.selectedLayoutStyleInteraction = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.SelectInteractionTarget);
        };
        this.deleteStyleValueInteractionClickHandler = function (evt) {
            currentApp.controller.DeleteStyleValueInteractionJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid"), CaliforniaApp_1.parseIntFromAttribute(evt.target, "vid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.deleteLayoutStyleInteractionClickHandler = function (evt) {
            currentApp.controller.DeleteLayoutStyleInteractionJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.createLayoutStyleInteraction = function (evt) {
            currentApp.controller.CreateLayoutStyleInteractionForLayoutAtomJson(CaliforniaApp_1.parseIntFromAttribute(evt.target, "aid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.specialLayoutBoxTypeChangedHandler = function (evt) {
            var targetSelect = evt.target;
            var selectedSpecialLayoutBoxType = undefined;
            if (targetSelect.selectedIndex < targetSelect.childElementCount) {
                var selectOptionElement = targetSelect.options[targetSelect.selectedIndex];
                selectedSpecialLayoutBoxType = parseInt(selectOptionElement.value);
            }
            if (selectedSpecialLayoutBoxType !== undefined) {
                currentApp.controller.SetSpecialLayoutBoxTypeJson(CaliforniaApp_1.parseIntFromAttribute(targetSelect, "bid"), selectedSpecialLayoutBoxType).done(function (data) {
                    return currentApp.router.updateData(data);
                });
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
        };
        this.boxCountInRowChangedHandler = function (evt) {
            var targetSelect = evt.target;
            var parsedBoxCount = undefined;
            if (targetSelect.selectedIndex < targetSelect.childElementCount) {
                var selectOptionElement = targetSelect.options[targetSelect.selectedIndex];
                parsedBoxCount = parseInt(selectOptionElement.value);
            }
            if (parsedBoxCount !== undefined) {
                currentApp.controller.SetLayoutBoxCountForRowOrBoxJson(CaliforniaApp_1.parseIntFromAttribute(targetSelect, "rid"), currentApp.state.newBoxStyleMoleculeId, parsedBoxCount, false).done(function (data) {
                    return currentApp.router.updateData(data);
                });
            } else {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
            }
        };
        this.finalizeLayoutRequest = function (evt) {
            currentApp.state.selectedLayoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            if (currentApp.state.currentTransactionMode === PropertyBarVM_1.TransactionMode.MoveLayoutMoleculeIntoLayoutMolecule) {
                _this.currentPropertyBar.moveLayoutMoleculeIntoLayoutMolecule();
                currentApp.state.preselectedLayoutBaseId = 0;
            } else if (currentApp.state.currentTransactionMode === PropertyBarVM_1.TransactionMode.MoveLayoutMoleculeBeforeLayoutMolecule) {
                _this.currentPropertyBar.moveLayoutMoleculeBeforeLayoutMolecule();
                currentApp.state.preselectedLayoutBaseId = 0;
            } else if (currentApp.state.currentTransactionMode === PropertyBarVM_1.TransactionMode.SyncLayoutStylesImitating) {
                _this.currentPropertyBar.syncLayoutMoleculeStylesImitatingReferenceLayout();
            } else {
                currentApp.state.preselectedLayoutBaseId = 0;
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                return;
            }
        };
        this.moveLayoutBoxIntoRowClickHandler = function (evt) {
            var layoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            if (currentApp.state.preselectedLayoutBaseId != layoutBaseId) {
                currentApp.state.preselectedLayoutBaseId = layoutBaseId;
                currentApp.state.currentTransactionMode = PropertyBarVM_1.TransactionMode.MoveLayoutMoleculeIntoLayoutMolecule;
            } else {
                currentApp.state.preselectedLayoutBaseId = 0;
            }
        };
        this.moveLayoutBoxIntoBoxClickHandler = function (evt) {
            var layoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            if (currentApp.state.preselectedLayoutBaseId != layoutBaseId) {
                currentApp.state.preselectedLayoutBaseId = layoutBaseId;
                currentApp.state.currentTransactionMode = PropertyBarVM_1.TransactionMode.MoveLayoutMoleculeIntoLayoutMolecule;
            } else {
                currentApp.state.preselectedLayoutBaseId = 0;
            }
        };
        this.moveLayoutBoxBeforeBoxClickHandler = function (evt) {
            var layoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            if (currentApp.state.preselectedLayoutBaseId != layoutBaseId) {
                currentApp.state.preselectedLayoutBaseId = layoutBaseId;
                currentApp.state.currentTransactionMode = PropertyBarVM_1.TransactionMode.MoveLayoutMoleculeBeforeLayoutMolecule;
            } else {
                currentApp.state.preselectedLayoutBaseId = 0;
            }
        };
        this.moveLayoutRowBeforeRowClickHandler = function (evt) {
            var layoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            if (currentApp.state.preselectedLayoutBaseId != layoutBaseId) {
                currentApp.state.preselectedLayoutBaseId = layoutBaseId;
                currentApp.state.currentTransactionMode = PropertyBarVM_1.TransactionMode.MoveLayoutMoleculeBeforeLayoutMolecule;
            } else {
                currentApp.state.preselectedLayoutBaseId = 0;
            }
        };
        this.syncLayoutBaseStylesClickHandler = function (evt) {
            var layoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            if (currentApp.state.preselectedLayoutBaseId != layoutBaseId) {
                currentApp.state.preselectedLayoutBaseId = layoutBaseId;
                currentApp.state.currentTransactionMode = PropertyBarVM_1.TransactionMode.SyncLayoutStylesImitating;
            } else {
                currentApp.state.preselectedLayoutBaseId = 0;
            }
        };
        this.moveLayoutAtomIntoBoxClickHandler = function (evt) {
            var layoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            if (currentApp.state.preselectedLayoutBaseId != layoutBaseId) {
                currentApp.state.preselectedLayoutBaseId = layoutBaseId;
                currentApp.state.currentTransactionMode = PropertyBarVM_1.TransactionMode.MoveLayoutMoleculeIntoLayoutMolecule;
            } else {
                currentApp.state.preselectedLayoutBaseId = 0;
            }
        };
        this.createBoxForAtomInPlaceClickHandler = function (evt) {
            currentApp.state.selectedLayoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            _this.viewModel.currentSecondaryPopupMode = PropertyBarVM_1.PopupSecondaryMode.SelectBoxIntoBoxAtomInPlace;
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.SelectBox);
        };
        this.moveLayoutAtomBeforeAtomClickHandler = function (evt) {
            var layoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            if (currentApp.state.preselectedLayoutBaseId != layoutBaseId) {
                currentApp.state.preselectedLayoutBaseId = layoutBaseId;
                currentApp.state.currentTransactionMode = PropertyBarVM_1.TransactionMode.MoveLayoutMoleculeBeforeLayoutMolecule;
            } else {
                currentApp.state.preselectedLayoutBaseId = 0;
            }
        };
        this.moveLayoutAtomBeforeBoxClickHandler = function (evt) {
            var layoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            if (currentApp.state.preselectedLayoutBaseId != layoutBaseId) {
                currentApp.state.preselectedLayoutBaseId = layoutBaseId;
                currentApp.state.currentTransactionMode = PropertyBarVM_1.TransactionMode.MoveLayoutMoleculeBeforeLayoutMolecule;
            } else {
                currentApp.state.preselectedLayoutBaseId = 0;
            }
        };
        this.saveLayoutMoleculeClickHandler = function (evt) {
            currentApp.controller.SetLayoutRowOrBoxAsInstanceableJson(currentApp.clientData.CaliforniaProject.CaliforniaProjectId, CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.createViewForBoxClickHandler = function (evt) {
            console.log("TODO");
        };
        this.insertLayoutAtomIntoBoxClickHandler = function (evt) {
            currentApp.state.selectedLayoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.InsertLayoutAtomIntoBox);
        };
        this.insertLayoutBoxIntoBoxClickHandler = function (evt) {
            currentApp.state.selectedLayoutBaseId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "lid");
            _this.viewModel.currentSecondaryPopupMode = PropertyBarVM_1.PopupSecondaryMode.SelectBoxIntoBox;
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.SelectBox);
        };
        this.renderCaliforniaViewControlsWhenAll = function () {
            var isAddButtonEnabled = _this.currentPropertyBar.viewModel.tempCaliforniaViewName !== "";
            return h(
                "div",
                { key: "-1" },
                h("input", { key: "0", value: _this.currentPropertyBar.viewModel.tempCaliforniaViewName, oninput: _this.currentPropertyBar.californiaViewNameInputHandler }),
                isAddButtonEnabled ? h(
                    "button",
                    { key: "a", role: "button", onclick: _this.currentPropertyBar.createCaliforniaViewClickHandler },
                    "\u2714"
                ) : h(
                    "button",
                    { disabled: true, key: "a0", role: "button", onclick: _this.currentPropertyBar.createCaliforniaViewClickHandler },
                    "\u2714"
                ),
                isAddButtonEnabled ? h(
                    "button",
                    { key: "b", role: "button", onclick: _this.currentPropertyBar.createCaliforniaViewFromReferenceClickHandler },
                    "x2"
                ) : h(
                    "button",
                    { disabled: true, key: "b0", role: "button", onclick: _this.currentPropertyBar.createCaliforniaViewFromReferenceClickHandler },
                    "x2"
                )
            );
        };
        this.createCaliforniaViewFromReferenceClickHandler = function (evt) {
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.CaliforniaViewSelection);
        };
        this.createCaliforniaViewClickHandler = function (evt) {
            currentApp.controller.CreateCaliforniaViewJson(currentApp.clientData.CaliforniaProject.CaliforniaProjectId, _this.currentPropertyBar.viewModel.tempCaliforniaViewName).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.viewModel.tempCaliforniaViewName = "";
        };
        this.californiaViewNameInputHandler = function (evt) {
            _this.currentPropertyBar.viewModel.tempCaliforniaViewName = evt.target.value;
        };
        this.renderCaliforniaViewSelectionPopup = function () {
            var isPopupVisible = _this.viewModel.currentPopupMode === PropertyBarVM_1.PopupMode.CaliforniaViewSelection;
            var renderedOptions = [];
            if (isPopupVisible === true) {
                currentApp.clientData.CaliforniaProject.CaliforniaViews.filter(function (m) {
                    return !m.IsInternal;
                }).map(function (m) {
                    var californiaViewIdString = m.CaliforniaViewId.toString();
                    renderedOptions.push(h(
                        "div",
                        { key: californiaViewIdString, styles: { "flex": "0 0 100%", "width": "100%", "min-width": "100%" } },
                        "view #",
                        californiaViewIdString,
                        ": ",
                        m.Name,
                        " ",
                        h(
                            "button",
                            { key: "a", role: "button", vid: californiaViewIdString, onclick: _this.currentPropertyBar.selectCaliforniaViewInPopupClickHandler },
                            "\u2714"
                        )
                    ));
                });
            }
            return h(
                "div",
                { id: _this.currentPropertyBar.propertyBarIndex + "PopupMode" + PropertyBarVM_1.PopupMode[PropertyBarVM_1.PopupMode.CaliforniaViewSelection], styles: { "display": isPopupVisible ? "block" : "none", "z-index": "31", "background-color": "white", "border": "solid black 1px" } },
                h(
                    "div",
                    { key: "0", styles: { "display": "flex", "flex-flow": "row nowrap", "min-width": "250px" } },
                    h(
                        "button",
                        { key: "b", styles: { "flex": "1 0 10%", "width": "10%", "min-width": "10%" }, onclick: _this.currentPropertyBar.cancelSelectCaliforniaViewPopupClickHandler },
                        "x"
                    )
                ),
                h(
                    "div",
                    { key: "1", styles: { "display": "flex", "flex-flow": "row wrap" } },
                    renderedOptions
                )
            );
        };
        this.selectCaliforniaViewInPopupClickHandler = function (evt) {
            currentApp.controller.CreateCaliforniaViewFromReferenceViewJson(currentApp.clientData.CaliforniaProject.CaliforniaProjectId, _this.currentPropertyBar.viewModel.tempCaliforniaViewName, CaliforniaApp_1.parseIntFromAttribute(evt.target, "vid")).done(function (data) {
                return currentApp.router.updateData(data);
            });
            _this.currentPropertyBar.viewModel.tempCaliforniaViewName = "";
            _this.currentPropertyBar.closePopup();
        };
        this.cancelSelectCaliforniaViewPopupClickHandler = function (evt) {
            _this.currentPropertyBar.closePopup();
        };
        this.renderCaliforniaViewControls = function () {
            if (_this.currentPropertyBar.viewModel.selectedCaliforniaViewId == 0) {
                return undefined;
            }
            var selectedCaliforniaView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (v) {
                return v.CaliforniaViewId == _this.currentPropertyBar.viewModel.selectedCaliforniaViewId;
            });
            var californiaViewIdString = selectedCaliforniaView.CaliforniaViewId.toString();
            var viewControlsButtonHolderStyles = {
                "flex": "0 0 auto",
                "height": "auto"
            };
            var viewControlsBoxTreeHolderStyles = {
                "flex": "1 1 1px",
                "width": "100%",
                "height": "auto",
                "overflow": "scroll"
            };
            var isSyncWithPreviewActive = _this.currentPropertyBar.propertyBarIndex == 0;
            var isSyncWithLeftActive = _this.currentPropertyBar.propertyBarIndex != 0;
            var isDrawHelperLinesActive = _this.currentPropertyBar.propertyBarIndex == 0;
            var syncWithLeftBoxTreeButtonStyles = {
                "outline": !isSyncWithLeftActive ? undefined : _this.currentPropertyBar.viewModel.isSyncedWithBoxTreeToTheLeft ? "solid 1px rgb(200,0,0)" : "solid 1px rgb(0,242,0)",
                "outline-offset": !isSyncWithLeftActive ? undefined : "-1px"
            };
            var syncWithPreviewButtonStyles = {
                "outline": !isSyncWithPreviewActive ? undefined : _this.currentPropertyBar.viewModel.isSyncedWithPagePreview ? "solid 1px rgb(200,0,0)" : "solid 1px rgb(0,242,0)",
                "outline-offset": !isSyncWithPreviewActive ? undefined : "-1px"
            };
            var drawHelperLinesButtonStyles = {
                "outline": !isDrawHelperLinesActive ? undefined : currentApp.state.isDrawHelperLines ? "solid 1px rgb(200,0,0)" : undefined,
                "outline-offset": !isDrawHelperLinesActive ? undefined : "-1px"
            };
            return h(
                "div",
                { styles: { "width": "100%", "height": "100%", "display": "flex", "flex-flow": "column nowrap" } },
                " View #",
                californiaViewIdString,
                h(
                    "div",
                    { key: "0", styles: viewControlsButtonHolderStyles },
                    h(
                        "button",
                        { key: "a", onclick: _this.currentPropertyBar.insertLayoutRowIntoViewClickHandler },
                        "+(R)"
                    ),
                    h(
                        "button",
                        { key: "b", mid: selectedCaliforniaView.SpecialStyleViewStyleMoleculeIdString, onclick: _this.currentPropertyBar.selectStyleMoleculeClickHandler },
                        "style #",
                        selectedCaliforniaView.SpecialStyleViewStyleMoleculeIdString
                    ),
                    h(
                        "button",
                        { key: "c", mid: selectedCaliforniaView.SpecialStyleBodyStyleMoleculeIdString, onclick: _this.currentPropertyBar.selectStyleMoleculeClickHandler },
                        "body style #",
                        selectedCaliforniaView.SpecialStyleBodyStyleMoleculeIdString
                    ),
                    h(
                        "button",
                        { key: "d", mid: selectedCaliforniaView.SpecialStyleHtmlStyleMoleculeIdString, onclick: _this.currentPropertyBar.selectStyleMoleculeClickHandler },
                        "HTML style #",
                        selectedCaliforniaView.SpecialStyleHtmlStyleMoleculeIdString
                    ),
                    h(
                        "button",
                        { key: "e", onclick: _this.currentPropertyBar.resetPreselectedLayoutClickHandler },
                        "o"
                    ),
                    isDrawHelperLinesActive ? h(
                        "button",
                        { key: "f", onclick: _this.currentPropertyBar.drawHelperLinesClickHandler, styles: drawHelperLinesButtonStyles },
                        "\\-\\"
                    ) : h(
                        "button",
                        { disabled: true, key: "f0", onclick: _this.currentPropertyBar.drawHelperLinesClickHandler, styles: drawHelperLinesButtonStyles },
                        "\\-\\"
                    ),
                    isSyncWithPreviewActive ? h(
                        "button",
                        { key: "g", onclick: _this.currentPropertyBar.syncWithPagePreviewClickHandler, styles: syncWithPreviewButtonStyles },
                        "-=-"
                    ) : h(
                        "button",
                        { disabled: true, key: "g0", onclick: _this.currentPropertyBar.syncWithPagePreviewClickHandler, styles: syncWithPreviewButtonStyles },
                        "-=-"
                    ),
                    isSyncWithLeftActive ? h(
                        "button",
                        { key: "h", onclick: _this.currentPropertyBar.syncWithLeftPropertyBarClickHandler, styles: syncWithLeftBoxTreeButtonStyles },
                        "=="
                    ) : h(
                        "button",
                        { disabled: true, key: "h0", onclick: _this.currentPropertyBar.syncWithLeftPropertyBarClickHandler, styles: syncWithLeftBoxTreeButtonStyles },
                        "=="
                    )
                ),
                h(
                    "div",
                    { key: "1", styles: viewControlsBoxTreeHolderStyles, onscroll: _this.currentPropertyBar.boxTreeScrollHandler, afterCreate: _this.currentPropertyBar.boxTreeAfterCreateHandler },
                    _this.currentPropertyBar.viewModel.boxTreeProjector.results.map(function (r) {
                        return r.renderMaquette();
                    })
                )
            );
        };
        this.boxTreeScrollHandler = function (evt) {
            var currentPropertyBarIndex = _this.currentPropertyBar.propertyBarIndex;
            var currentScrollDom = currentApp.propertyBarBoxTreeDomReferences[currentPropertyBarIndex];
            if (currentApp.state.visiblePropertyBarMaxCount > 1 && currentApp.propertyBarBoxTreeScrollHandled[currentPropertyBarIndex] === false) {
                currentApp.propertyBarBoxTreeScrollHandled[currentPropertyBarIndex] = true;
                var currentViewModel = _this.currentPropertyBar.viewModel;
                if (currentScrollDom === undefined) {
                    console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                    return;
                }
                var progressingPropertyBarIndex = currentPropertyBarIndex;
                var isKeepGoingLeft = currentPropertyBarIndex > 0;
                var currentIteration = 0;
                var maxIteration = currentPropertyBarIndex - 1;
                while (isKeepGoingLeft === true && progressingPropertyBarIndex > 0) {
                    if (currentApp.propertyBarVMs[progressingPropertyBarIndex].isSyncedWithBoxTreeToTheLeft) {
                        var targetScrollDom = currentApp.propertyBarBoxTreeDomReferences[progressingPropertyBarIndex - 1];
                        if (targetScrollDom !== undefined && targetScrollDom.scrollTop != currentScrollDom.scrollTop) {
                            currentApp.propertyBarBoxTreeScrollHandled[progressingPropertyBarIndex - 1] = true;
                            targetScrollDom.scrollTop = currentScrollDom.scrollTop;
                        }
                    } else {
                        isKeepGoingLeft = false;
                        break;
                    }
                    if (currentIteration > maxIteration) {
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                        break;
                    }
                    progressingPropertyBarIndex--;
                    currentIteration++;
                }
                progressingPropertyBarIndex = currentPropertyBarIndex + 1;
                var isKeepGoingRight = true;
                currentIteration = 0;
                maxIteration = currentApp.state.visiblePropertyBarMaxCount - 1 - currentPropertyBarIndex;
                while (isKeepGoingRight === true && progressingPropertyBarIndex < currentApp.state.visiblePropertyBarMaxCount) {
                    if (currentApp.propertyBarVMs[progressingPropertyBarIndex].isSyncedWithBoxTreeToTheLeft) {
                        var targetScrollDom = currentApp.propertyBarBoxTreeDomReferences[progressingPropertyBarIndex];
                        if (targetScrollDom !== undefined && targetScrollDom.scrollTop != currentScrollDom.scrollTop) {
                            currentApp.propertyBarBoxTreeScrollHandled[progressingPropertyBarIndex] = true;
                            targetScrollDom.scrollTop = currentScrollDom.scrollTop;
                        }
                    } else {
                        isKeepGoingRight = false;
                        break;
                    }
                    if (currentIteration > maxIteration) {
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                        break;
                    }
                    progressingPropertyBarIndex++;
                    currentIteration++;
                }
            } else {
                for (var i = 0; i < currentApp.state.visiblePropertyBarMaxCount; i++) {
                    currentApp.propertyBarBoxTreeScrollHandled[i] = false;
                }
            }
            if (currentPropertyBarIndex == 0 && _this.currentPropertyBar.viewModel.isSyncedWithPagePreview) {
                _this.currentPropertyBar._visibleLayoutAtomDomNodeReferences = [];
                _this.currentPropertyBar._visibleLayoutAtomKeys = [];
                _this.currentPropertyBar._mostUpperVisibleLayoutAtomId = 0;
                var processedElementCount = 0;
                var mostUpperVisibleIndex = -1;
                var mostUpperVisibleLayoutAtomId = 0;
                var mostUpperVisibleDeltaTopLeft = currentScrollDom.clientHeight + 1;
                var staticOffsetPx = currentScrollDom.getBoundingClientRect().top;
                var currentScrollTop = currentScrollDom.scrollTop;
                var minXPreview = 0;
                var maxXPreview = currentScrollDom.clientHeight;
                for (var elementKey in _this.currentPropertyBar._activeViewLayoutAtomDomNodeReferences) {
                    var domNode = _this.currentPropertyBar._activeViewLayoutAtomDomNodeReferences[elementKey];
                    var isDomNodeVisible = false;
                    var boundingRectElement = domNode.getBoundingClientRect();
                    var minXElementDeltaTopLeft = boundingRectElement.top - staticOffsetPx;
                    var maxXElementDeltaBottomLeft = currentScrollDom.clientHeight - (boundingRectElement.top - staticOffsetPx + currentScrollTop + boundingRectElement.height) + currentScrollTop;
                    if (boundingRectElement.height > 0) {
                        if (minXElementDeltaTopLeft >= 0.0 && minXElementDeltaTopLeft <= currentScrollDom.clientHeight) {
                            isDomNodeVisible = true;
                        } else if (maxXElementDeltaBottomLeft >= 0.0 && maxXElementDeltaBottomLeft <= currentScrollDom.clientHeight) {
                            isDomNodeVisible = true;
                        } else if (minXElementDeltaTopLeft <= 0.0 && maxXElementDeltaBottomLeft <= 0.0) {
                            isDomNodeVisible = true;
                        }
                    }
                    if (isDomNodeVisible) {
                        _this.currentPropertyBar._visibleLayoutAtomDomNodeReferences.push(domNode);
                        _this.currentPropertyBar._visibleLayoutAtomKeys.push(elementKey);
                        if (minXElementDeltaTopLeft < mostUpperVisibleDeltaTopLeft) {
                            mostUpperVisibleDeltaTopLeft = minXElementDeltaTopLeft;
                            mostUpperVisibleIndex = _this.currentPropertyBar._visibleLayoutAtomKeys.length;
                            mostUpperVisibleLayoutAtomId = CaliforniaApp_1.parseIntFromAttribute(domNode, "lid");
                        }
                    }
                    processedElementCount++;
                }
                if (mostUpperVisibleLayoutAtomId != _this.currentPropertyBar._mostUpperVisibleLayoutAtomId) {
                    _this.currentPropertyBar._mostUpperVisibleLayoutAtomId = mostUpperVisibleLayoutAtomId;
                    if (mostUpperVisibleLayoutAtomId != 0 && _this.currentPropertyBar.viewModel.isSyncedWithPagePreview) {
                        currentApp.pagePreview.syncScrollPositionFromBoxTree();
                    }
                }
            }
        };
        this.syncScrollPositionFromPagePreview = function () {
            if (_this.currentPropertyBar.viewModel.isSyncedWithPagePreview) {
                var currentPropertyBarIndex = _this.currentPropertyBar.propertyBarIndex;
                var currentScrollDom = currentApp.propertyBarBoxTreeDomReferences[currentPropertyBarIndex];
                if (currentScrollDom !== undefined) {
                    var staticOffsetPx = currentScrollDom.getBoundingClientRect().top;
                    var targetLayoutAtomId_1 = currentApp.pagePreview.mostUpperVisibleLayoutAtomId;
                    console.log("tree from preview for target layout #" + targetLayoutAtomId_1);
                    var domNodeOfTargetLayout = _this.currentPropertyBar._visibleLayoutAtomDomNodeReferences.find(function (r) {
                        return CaliforniaApp_1.parseIntFromAttribute(r, "lid") == targetLayoutAtomId_1;
                    });
                    if (domNodeOfTargetLayout === undefined) {
                        domNodeOfTargetLayout = _this.currentPropertyBar._activeViewLayoutAtomDomNodeReferences[targetLayoutAtomId_1];
                    }
                    if (domNodeOfTargetLayout !== undefined) {
                        currentScrollDom.scrollTop = currentScrollDom.scrollTop + (domNodeOfTargetLayout.getBoundingClientRect().top - staticOffsetPx);
                    } else {
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                    }
                } else {}
            }
        };
        this.boxTreeAfterCreateHandler = function (element, projectionOptions, vnodeSelector, properties, children) {
            currentApp.propertyBarBoxTreeDomReferences[_this.currentPropertyBar.propertyBarIndex] = element;
        };
        this.deleteCaliforniaViewClickHandler = function (evt) {
            var deleteCaliforniaViewId = CaliforniaApp_1.parseIntFromAttribute(evt.target, "vid");
            currentApp.router.clearCaliforniaPropertyBars(false, deleteCaliforniaViewId);
            currentApp.controller.DeleteCaliforniaViewJson(deleteCaliforniaViewId).done(function (data) {
                return currentApp.router.updateData(data);
            });
        };
        this.insertLayoutRowIntoViewClickHandler = function (evt) {
            _this.currentPropertyBar.displayPopup(evt.target, PropertyBarVM_1.PopupMode.InsertLayoutRowIntoView);
        };
        this.resetPreselectedLayoutClickHandler = function (evt) {
            currentApp.state.preselectedLayoutBaseId = 0;
        };
        this.drawHelperLinesClickHandler = function (evt) {
            currentApp.state.isDrawHelperLines = !currentApp.state.isDrawHelperLines;
        };
        this.syncWithPagePreviewClickHandler = function (evt) {
            var currentPropertyBarIndex = _this.currentPropertyBar.propertyBarIndex;
            var currentViewModel = _this.currentPropertyBar.viewModel;
            if (currentPropertyBarIndex == 0) {
                currentViewModel.isSyncedWithPagePreview = !currentViewModel.isSyncedWithPagePreview;
                if (currentViewModel.isSyncedWithPagePreview) {
                    var currentBoxTreeDomReference = currentApp.propertyBarBoxTreeDomReferences[currentPropertyBarIndex];
                    if (currentBoxTreeDomReference !== undefined) {
                        if (currentBoxTreeDomReference.scrollTop <= 1.0) {
                            _this.currentPropertyBar.syncScrollPositionFromPagePreview();
                        } else {
                            currentApp.pagePreview.syncScrollPositionFromBoxTree();
                        }
                    }
                }
            }
        };
        this.syncWithLeftPropertyBarClickHandler = function (evt) {
            var currentPropertyBarIndex = _this.currentPropertyBar.propertyBarIndex;
            var currentViewModel = _this.currentPropertyBar.viewModel;
            if (currentPropertyBarIndex != 0 && currentApp.propertyBarVMs[currentPropertyBarIndex - 1].currentPropertyBarMode === PropertyBarVM_1.PropertyBarMode.CaliforniaView && currentApp.propertyBarVMs[currentPropertyBarIndex - 1].selectedCaliforniaViewId == currentViewModel.selectedCaliforniaViewId) {
                currentViewModel.isSyncedWithBoxTreeToTheLeft = !currentViewModel.isSyncedWithBoxTreeToTheLeft;
                if (currentViewModel.isSyncedWithBoxTreeToTheLeft === true) {
                    var currentBoxTreeDomReference = currentApp.propertyBarBoxTreeDomReferences[currentPropertyBarIndex];
                    var otherBoxTreeDomReference = currentApp.propertyBarBoxTreeDomReferences[currentPropertyBarIndex - 1];
                    if (currentBoxTreeDomReference !== undefined && otherBoxTreeDomReference !== undefined) {
                        otherBoxTreeDomReference.scrollTop = currentBoxTreeDomReference.scrollTop;
                    } else {
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                        currentViewModel.isSyncedWithBoxTreeToTheLeft = false;
                    }
                }
            } else {
                currentViewModel.isSyncedWithBoxTreeToTheLeft = false;
            }
        };
        currentApp = californiaAppArg;
        this.propertyBarIndex = targetIndex;
        this.viewModel = new PropertyBarVM_1.PropertyBarVM(this, targetIndex, californiaAppArg);
        this.viewModel.isSyncedWithBoxTreeToTheLeft = false;
        this.viewModel.isSyncedWithPagePreview = false;
    }
    ;
    Object.defineProperty(PropertyBar.prototype, "currentPropertyBar", {
        get: function get() {
            return currentApp.propertyBars[this.propertyBarIndex];
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PropertyBar.prototype, "nextExceptLastPropertyBar", {
        get: function get() {
            var nextPropertyBarIndex = this.propertyBarIndex + 1;
            if (nextPropertyBarIndex < currentApp.state.visiblePropertyBarMaxCount) {
                return currentApp.propertyBars[nextPropertyBarIndex];
            } else {
                return this.currentPropertyBar;
            }
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PropertyBar.prototype, "visibleLayoutAtomDomNodeReferences", {
        get: function get() {
            return this._visibleLayoutAtomDomNodeReferences;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PropertyBar.prototype, "visibleLayoutAtomKeys", {
        get: function get() {
            return this._visibleLayoutAtomKeys;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PropertyBar.prototype, "mostUpperVisibleLayoutAtomId", {
        get: function get() {
            return this._mostUpperVisibleLayoutAtomId;
        },
        enumerable: true,
        configurable: true
    });
    ;
    Object.defineProperty(PropertyBar.prototype, "activeViewLayoutAtomDomNodeReferences", {
        get: function get() {
            return this._activeViewLayoutAtomDomNodeReferences;
        },
        enumerable: true,
        configurable: true
    });
    ;
    return PropertyBar;
}();
exports.PropertyBar = PropertyBar;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(0)))

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery, jQuery) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! VelocityJS.org (1.5.0). (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License */

/*************************
 Velocity jQuery Shim
 *************************/

/*! VelocityJS.org jQuery Shim (1.0.1). (C) 2014 The jQuery Foundation. MIT @license: en.wikipedia.org/wiki/MIT_License. */

/* This file contains the jQuery functions that Velocity relies on, thereby removing Velocity's dependency on a full copy of jQuery, and allowing it to work in any environment. */
/* These shimmed functions are only used if jQuery isn't present. If both this shim and jQuery are loaded, Velocity defaults to jQuery proper. */
/* Browser support: Using this shim instead of jQuery proper removes support for IE8. */

(function(window) {
	"use strict";
	/***************
	 Setup
	 ***************/

	/* If jQuery is already loaded, there's no point in loading this shim. */
	if (__webpack_provided_window_dot_jQuery) {
		return;
	}

	/* jQuery base. */
	var $ = function(selector, context) {
		return new $.fn.init(selector, context);
	};

	/********************
	 Private Methods
	 ********************/

	/* jQuery */
	$.isWindow = function(obj) {
		/* jshint eqeqeq: false */
		return obj && obj === obj.window;
	};

	/* jQuery */
	$.type = function(obj) {
		if (!obj) {
			return obj + "";
		}

		return typeof obj === "object" || typeof obj === "function" ?
				class2type[toString.call(obj)] || "object" :
				typeof obj;
	};

	/* jQuery */
	$.isArray = Array.isArray || function(obj) {
		return $.type(obj) === "array";
	};

	/* jQuery */
	function isArraylike(obj) {
		var length = obj.length,
				type = $.type(obj);

		if (type === "function" || $.isWindow(obj)) {
			return false;
		}

		if (obj.nodeType === 1 && length) {
			return true;
		}

		return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
	}

	/***************
	 $ Methods
	 ***************/

	/* jQuery: Support removed for IE<9. */
	$.isPlainObject = function(obj) {
		var key;

		if (!obj || $.type(obj) !== "object" || obj.nodeType || $.isWindow(obj)) {
			return false;
		}

		try {
			if (obj.constructor &&
					!hasOwn.call(obj, "constructor") &&
					!hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
				return false;
			}
		} catch (e) {
			return false;
		}

		for (key in obj) {
		}

		return key === undefined || hasOwn.call(obj, key);
	};

	/* jQuery */
	$.each = function(obj, callback, args) {
		var value,
				i = 0,
				length = obj.length,
				isArray = isArraylike(obj);

		if (args) {
			if (isArray) {
				for (; i < length; i++) {
					value = callback.apply(obj[i], args);

					if (value === false) {
						break;
					}
				}
			} else {
				for (i in obj) {
					if (!obj.hasOwnProperty(i)) {
						continue;
					}
					value = callback.apply(obj[i], args);

					if (value === false) {
						break;
					}
				}
			}

		} else {
			if (isArray) {
				for (; i < length; i++) {
					value = callback.call(obj[i], i, obj[i]);

					if (value === false) {
						break;
					}
				}
			} else {
				for (i in obj) {
					if (!obj.hasOwnProperty(i)) {
						continue;
					}
					value = callback.call(obj[i], i, obj[i]);

					if (value === false) {
						break;
					}
				}
			}
		}

		return obj;
	};

	/* Custom */
	$.data = function(node, key, value) {
		/* $.getData() */
		if (value === undefined) {
			var getId = node[$.expando],
					store = getId && cache[getId];

			if (key === undefined) {
				return store;
			} else if (store) {
				if (key in store) {
					return store[key];
				}
			}
			/* $.setData() */
		} else if (key !== undefined) {
			var setId = node[$.expando] || (node[$.expando] = ++$.uuid);

			cache[setId] = cache[setId] || {};
			cache[setId][key] = value;

			return value;
		}
	};

	/* Custom */
	$.removeData = function(node, keys) {
		var id = node[$.expando],
				store = id && cache[id];

		if (store) {
			// Cleanup the entire store if no keys are provided.
			if (!keys) {
				delete cache[id];
			} else {
				$.each(keys, function(_, key) {
					delete store[key];
				});
			}
		}
	};

	/* jQuery */
	$.extend = function() {
		var src, copyIsArray, copy, name, options, clone,
				target = arguments[0] || {},
				i = 1,
				length = arguments.length,
				deep = false;

		if (typeof target === "boolean") {
			deep = target;

			target = arguments[i] || {};
			i++;
		}

		if (typeof target !== "object" && $.type(target) !== "function") {
			target = {};
		}

		if (i === length) {
			target = this;
			i--;
		}

		for (; i < length; i++) {
			if ((options = arguments[i])) {
				for (name in options) {
					if (!options.hasOwnProperty(name)) {
						continue;
					}
					src = target[name];
					copy = options[name];

					if (target === copy) {
						continue;
					}

					if (deep && copy && ($.isPlainObject(copy) || (copyIsArray = $.isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && $.isArray(src) ? src : [];

						} else {
							clone = src && $.isPlainObject(src) ? src : {};
						}

						target[name] = $.extend(deep, clone, copy);

					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}

		return target;
	};

	/* jQuery 1.4.3 */
	$.queue = function(elem, type, data) {
		function $makeArray(arr, results) {
			var ret = results || [];

			if (arr) {
				if (isArraylike(Object(arr))) {
					/* $.merge */
					(function(first, second) {
						var len = +second.length,
								j = 0,
								i = first.length;

						while (j < len) {
							first[i++] = second[j++];
						}

						if (len !== len) {
							while (second[j] !== undefined) {
								first[i++] = second[j++];
							}
						}

						first.length = i;

						return first;
					})(ret, typeof arr === "string" ? [arr] : arr);
				} else {
					[].push.call(ret, arr);
				}
			}

			return ret;
		}

		if (!elem) {
			return;
		}

		type = (type || "fx") + "queue";

		var q = $.data(elem, type);

		if (!data) {
			return q || [];
		}

		if (!q || $.isArray(data)) {
			q = $.data(elem, type, $makeArray(data));
		} else {
			q.push(data);
		}

		return q;
	};

	/* jQuery 1.4.3 */
	$.dequeue = function(elems, type) {
		/* Custom: Embed element iteration. */
		$.each(elems.nodeType ? [elems] : elems, function(i, elem) {
			type = type || "fx";

			var queue = $.queue(elem, type),
					fn = queue.shift();

			if (fn === "inprogress") {
				fn = queue.shift();
			}

			if (fn) {
				if (type === "fx") {
					queue.unshift("inprogress");
				}

				fn.call(elem, function() {
					$.dequeue(elem, type);
				});
			}
		});
	};

	/******************
	 $.fn Methods
	 ******************/

	/* jQuery */
	$.fn = $.prototype = {
		init: function(selector) {
			/* Just return the element wrapped inside an array; don't proceed with the actual jQuery node wrapping process. */
			if (selector.nodeType) {
				this[0] = selector;

				return this;
			} else {
				throw new Error("Not a DOM node.");
			}
		},
		offset: function() {
			/* jQuery altered code: Dropped disconnected DOM node checking. */
			var box = this[0].getBoundingClientRect ? this[0].getBoundingClientRect() : {top: 0, left: 0};

			return {
				top: box.top + (window.pageYOffset || document.scrollTop || 0) - (document.clientTop || 0),
				left: box.left + (window.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || 0)
			};
		},
		position: function() {
			/* jQuery */
			function offsetParentFn(elem) {
				var offsetParent = elem.offsetParent;

				while (offsetParent && (offsetParent.nodeName.toLowerCase() !== "html" && offsetParent.style && offsetParent.style.position.toLowerCase() === "static")) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || document;
			}

			/* Zepto */
			var elem = this[0],
					offsetParent = offsetParentFn(elem),
					offset = this.offset(),
					parentOffset = /^(?:body|html)$/i.test(offsetParent.nodeName) ? {top: 0, left: 0} : $(offsetParent).offset();

			offset.top -= parseFloat(elem.style.marginTop) || 0;
			offset.left -= parseFloat(elem.style.marginLeft) || 0;

			if (offsetParent.style) {
				parentOffset.top += parseFloat(offsetParent.style.borderTopWidth) || 0;
				parentOffset.left += parseFloat(offsetParent.style.borderLeftWidth) || 0;
			}

			return {
				top: offset.top - parentOffset.top,
				left: offset.left - parentOffset.left
			};
		}
	};

	/**********************
	 Private Variables
	 **********************/

	/* For $.data() */
	var cache = {};
	$.expando = "velocity" + (new Date().getTime());
	$.uuid = 0;

	/* For $.queue() */
	var class2type = {},
			hasOwn = class2type.hasOwnProperty,
			toString = class2type.toString;

	var types = "Boolean Number String Function Array Date RegExp Object Error".split(" ");
	for (var i = 0; i < types.length; i++) {
		class2type["[object " + types[i] + "]"] = types[i].toLowerCase();
	}

	/* Makes $(node) possible, without having to call init. */
	$.fn.init.prototype = $.fn;

	/* Globalize Velocity onto the window, and assign its Utilities property. */
	window.Velocity = {Utilities: $};
})(window);

/******************
 Velocity.js
 ******************/

(function(factory) {
	"use strict";
	/* CommonJS module. */
	if (typeof module === "object" && typeof module.exports === "object") {
		module.exports = factory();
		/* AMD module. */
	} else if (true) {
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		/* Browser globals. */
	} else {
		factory();
	}
}(function() {
	"use strict";
	return function(global, window, document, undefined) {

		/***************
		 Summary
		 ***************/

		/*
		 - CSS: CSS stack that works independently from the rest of Velocity.
		 - animate(): Core animation method that iterates over the targeted elements and queues the incoming call onto each element individually.
		 - Pre-Queueing: Prepare the element for animation by instantiating its data cache and processing the call's options.
		 - Queueing: The logic that runs once the call has reached its point of execution in the element's $.queue() stack.
		 Most logic is placed here to avoid risking it becoming stale (if the element's properties have changed).
		 - Pushing: Consolidation of the tween data followed by its push onto the global in-progress calls container.
		 - tick(): The single requestAnimationFrame loop responsible for tweening all in-progress calls.
		 - completeCall(): Handles the cleanup process for each Velocity call.
		 */

		/*********************
		 Helper Functions
		 *********************/

		/* IE detection. Gist: https://gist.github.com/julianshapiro/9098609 */
		var IE = (function() {
			if (document.documentMode) {
				return document.documentMode;
			} else {
				for (var i = 7; i > 4; i--) {
					var div = document.createElement("div");

					div.innerHTML = "<!--[if IE " + i + "]><span></span><![endif]-->";

					if (div.getElementsByTagName("span").length) {
						div = null;

						return i;
					}
				}
			}

			return undefined;
		})();

		/* rAF shim. Gist: https://gist.github.com/julianshapiro/9497513 */
		var rAFShim = (function() {
			var timeLast = 0;

			return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
				var timeCurrent = (new Date()).getTime(),
						timeDelta;

				/* Dynamically set delay on a per-tick basis to match 60fps. */
				/* Technique by Erik Moller. MIT license: https://gist.github.com/paulirish/1579671 */
				timeDelta = Math.max(0, 16 - (timeCurrent - timeLast));
				timeLast = timeCurrent + timeDelta;

				return setTimeout(function() {
					callback(timeCurrent + timeDelta);
				}, timeDelta);
			};
		})();

		var performance = (function() {
			var perf = window.performance || {};

			if (typeof perf.now !== "function") {
				var nowOffset = perf.timing && perf.timing.navigationStart ? perf.timing.navigationStart : (new Date()).getTime();

				perf.now = function() {
					return (new Date()).getTime() - nowOffset;
				};
			}
			return perf;
		})();

		/* Array compacting. Copyright Lo-Dash. MIT License: https://github.com/lodash/lodash/blob/master/LICENSE.txt */
		function compactSparseArray(array) {
			var index = -1,
					length = array ? array.length : 0,
					result = [];

			while (++index < length) {
				var value = array[index];

				if (value) {
					result.push(value);
				}
			}

			return result;
		}

		/**
		 * Shim for "fixing" IE's lack of support (IE < 9) for applying slice
		 * on host objects like NamedNodeMap, NodeList, and HTMLCollection
		 * (technically, since host objects have been implementation-dependent,
		 * at least before ES2015, IE hasn't needed to work this way).
		 * Also works on strings, fixes IE < 9 to allow an explicit undefined
		 * for the 2nd argument (as in Firefox), and prevents errors when
		 * called on other DOM objects.
		 */
		var _slice = (function() {
			var slice = Array.prototype.slice;

			try {
				// Can't be used with DOM elements in IE < 9
				slice.call(document.documentElement);
				return slice;
			} catch (e) { // Fails in IE < 9

				// This will work for genuine arrays, array-like objects, 
				// NamedNodeMap (attributes, entities, notations),
				// NodeList (e.g., getElementsByTagName), HTMLCollection (e.g., childNodes),
				// and will not fail on other DOM objects (as do DOM elements in IE < 9)
				return function(begin, end) {
					var len = this.length;

					if (typeof begin !== "number") {
						begin = 0;
					}
					// IE < 9 gets unhappy with an undefined end argument
					if (typeof end !== "number") {
						end = len;
					}
					// For native Array objects, we use the native slice function
					if (this.slice) {
						return slice.call(this, begin, end);
					}
					// For array like object we handle it ourselves.
					var i,
							cloned = [],
							// Handle negative value for "begin"
							start = (begin >= 0) ? begin : Math.max(0, len + begin),
							// Handle negative value for "end"
							upTo = end < 0 ? len + end : Math.min(end, len),
							// Actual expected size of the slice
							size = upTo - start;

					if (size > 0) {
						cloned = new Array(size);
						if (this.charAt) {
							for (i = 0; i < size; i++) {
								cloned[i] = this.charAt(start + i);
							}
						} else {
							for (i = 0; i < size; i++) {
								cloned[i] = this[start + i];
							}
						}
					}
					return cloned;
				};
			}
		})();

		/* .indexOf doesn't exist in IE<9 */
		var _inArray = (function() {
			if (Array.prototype.includes) {
				return function(arr, val) {
					return arr.includes(val);
				};
			}
			if (Array.prototype.indexOf) {
				return function(arr, val) {
					return arr.indexOf(val) >= 0;
				};
			}
			return function(arr, val) {
				for (var i = 0; i < arr.length; i++) {
					if (arr[i] === val) {
						return true;
					}
				}
				return false;
			};
		});

		function sanitizeElements(elements) {
			/* Unwrap jQuery/Zepto objects. */
			if (Type.isWrapped(elements)) {
				elements = _slice.call(elements);
				/* Wrap a single element in an array so that $.each() can iterate with the element instead of its node's children. */
			} else if (Type.isNode(elements)) {
				elements = [elements];
			}

			return elements;
		}

		var Type = {
			isNumber: function(variable) {
				return (typeof variable === "number");
			},
			isString: function(variable) {
				return (typeof variable === "string");
			},
			isArray: Array.isArray || function(variable) {
				return Object.prototype.toString.call(variable) === "[object Array]";
			},
			isFunction: function(variable) {
				return Object.prototype.toString.call(variable) === "[object Function]";
			},
			isNode: function(variable) {
				return variable && variable.nodeType;
			},
			/* Determine if variable is an array-like wrapped jQuery, Zepto or similar element, or even a NodeList etc. */
			/* NOTE: HTMLFormElements also have a length. */
			isWrapped: function(variable) {
				return variable
						&& variable !== window
						&& Type.isNumber(variable.length)
						&& !Type.isString(variable)
						&& !Type.isFunction(variable)
						&& !Type.isNode(variable)
						&& (variable.length === 0 || Type.isNode(variable[0]));
			},
			isSVG: function(variable) {
				return window.SVGElement && (variable instanceof window.SVGElement);
			},
			isEmptyObject: function(variable) {
				for (var name in variable) {
					if (variable.hasOwnProperty(name)) {
						return false;
					}
				}

				return true;
			}
		};

		/*****************
		 Dependencies
		 *****************/

		var $,
				isJQuery = false;

		if (global.fn && global.fn.jquery) {
			$ = global;
			isJQuery = true;
		} else {
			$ = window.Velocity.Utilities;
		}

		if (IE <= 8 && !isJQuery) {
			throw new Error("Velocity: IE8 and below require jQuery to be loaded before Velocity.");
		} else if (IE <= 7) {
			/* Revert to jQuery's $.animate(), and lose Velocity's extra features. */
			jQuery.fn.velocity = jQuery.fn.animate;

			/* Now that $.fn.velocity is aliased, abort this Velocity declaration. */
			return;
		}

		/*****************
		 Constants
		 *****************/

		var DURATION_DEFAULT = 400,
				EASING_DEFAULT = "swing";

		/*************
		 State
		 *************/

		var Velocity = {
			/* Container for page-wide Velocity state data. */
			State: {
				/* Detect mobile devices to determine if mobileHA should be turned on. */
				isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(window.navigator.userAgent),
				/* The mobileHA option's behavior changes on older Android devices (Gingerbread, versions 2.3.3-2.3.7). */
				isAndroid: /Android/i.test(window.navigator.userAgent),
				isGingerbread: /Android 2\.3\.[3-7]/i.test(window.navigator.userAgent),
				isChrome: window.chrome,
				isFirefox: /Firefox/i.test(window.navigator.userAgent),
				/* Create a cached element for re-use when checking for CSS property prefixes. */
				prefixElement: document.createElement("div"),
				/* Cache every prefix match to avoid repeating lookups. */
				prefixMatches: {},
				/* Cache the anchor used for animating window scrolling. */
				scrollAnchor: null,
				/* Cache the browser-specific property names associated with the scroll anchor. */
				scrollPropertyLeft: null,
				scrollPropertyTop: null,
				/* Keep track of whether our RAF tick is running. */
				isTicking: false,
				/* Container for every in-progress call to Velocity. */
				calls: [],
				delayedElements: {
					count: 0
				}
			},
			/* Velocity's custom CSS stack. Made global for unit testing. */
			CSS: {/* Defined below. */},
			/* A shim of the jQuery utility functions used by Velocity -- provided by Velocity's optional jQuery shim. */
			Utilities: $,
			/* Container for the user's custom animation redirects that are referenced by name in place of the properties map argument. */
			Redirects: {/* Manually registered by the user. */},
			Easings: {/* Defined below. */},
			/* Attempt to use ES6 Promises by default. Users can override this with a third-party promises library. */
			Promise: window.Promise,
			/* Velocity option defaults, which can be overriden by the user. */
			defaults: {
				queue: "",
				duration: DURATION_DEFAULT,
				easing: EASING_DEFAULT,
				begin: undefined,
				complete: undefined,
				progress: undefined,
				display: undefined,
				visibility: undefined,
				loop: false,
				delay: false,
				mobileHA: true,
				/* Advanced: Set to false to prevent property values from being cached between consecutive Velocity-initiated chain calls. */
				_cacheValues: true,
				/* Advanced: Set to false if the promise should always resolve on empty element lists. */
				promiseRejectEmpty: true
			},
			/* A design goal of Velocity is to cache data wherever possible in order to avoid DOM requerying. Accordingly, each element has a data cache. */
			init: function(element) {
				$.data(element, "velocity", {
					/* Store whether this is an SVG element, since its properties are retrieved and updated differently than standard HTML elements. */
					isSVG: Type.isSVG(element),
					/* Keep track of whether the element is currently being animated by Velocity.
					 This is used to ensure that property values are not transferred between non-consecutive (stale) calls. */
					isAnimating: false,
					/* A reference to the element's live computedStyle object. Learn more here: https://developer.mozilla.org/en/docs/Web/API/window.getComputedStyle */
					computedStyle: null,
					/* Tween data is cached for each animation on the element so that data can be passed across calls --
					 in particular, end values are used as subsequent start values in consecutive Velocity calls. */
					tweensContainer: null,
					/* The full root property values of each CSS hook being animated on this element are cached so that:
					 1) Concurrently-animating hooks sharing the same root can have their root values' merged into one while tweening.
					 2) Post-hook-injection root values can be transferred over to consecutively chained Velocity calls as starting root values. */
					rootPropertyValueCache: {},
					/* A cache for transform updates, which must be manually flushed via CSS.flushTransformCache(). */
					transformCache: {}
				});
			},
			/* A parallel to jQuery's $.css(), used for getting/setting Velocity's hooked CSS properties. */
			hook: null, /* Defined below. */
			/* Velocity-wide animation time remapping for testing purposes. */
			mock: false,
			version: {major: 1, minor: 5, patch: 1},
			/* Set to 1 or 2 (most verbose) to output debug info to console. */
			debug: false,
			/* Use rAF high resolution timestamp when available */
			timestamp: true,
			/* Pause all animations */
			pauseAll: function(queueName) {
				var currentTime = (new Date()).getTime();

				$.each(Velocity.State.calls, function(i, activeCall) {

					if (activeCall) {

						/* If we have a queueName and this call is not on that queue, skip */
						if (queueName !== undefined && ((activeCall[2].queue !== queueName) || (activeCall[2].queue === false))) {
							return true;
						}

						/* Set call to paused */
						activeCall[5] = {
							resume: false
						};
					}
				});

				/* Pause timers on any currently delayed calls */
				$.each(Velocity.State.delayedElements, function(k, element) {
					if (!element) {
						return;
					}
					pauseDelayOnElement(element, currentTime);
				});
			},
			/* Resume all animations */
			resumeAll: function(queueName) {
				var currentTime = (new Date()).getTime();

				$.each(Velocity.State.calls, function(i, activeCall) {

					if (activeCall) {

						/* If we have a queueName and this call is not on that queue, skip */
						if (queueName !== undefined && ((activeCall[2].queue !== queueName) || (activeCall[2].queue === false))) {
							return true;
						}

						/* Set call to resumed if it was paused */
						if (activeCall[5]) {
							activeCall[5].resume = true;
						}
					}
				});
				/* Resume timers on any currently delayed calls */
				$.each(Velocity.State.delayedElements, function(k, element) {
					if (!element) {
						return;
					}
					resumeDelayOnElement(element, currentTime);
				});
			}
		};

		/* Retrieve the appropriate scroll anchor and property name for the browser: https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY */
		if (window.pageYOffset !== undefined) {
			Velocity.State.scrollAnchor = window;
			Velocity.State.scrollPropertyLeft = "pageXOffset";
			Velocity.State.scrollPropertyTop = "pageYOffset";
		} else {
			Velocity.State.scrollAnchor = document.documentElement || document.body.parentNode || document.body;
			Velocity.State.scrollPropertyLeft = "scrollLeft";
			Velocity.State.scrollPropertyTop = "scrollTop";
		}

		/* Shorthand alias for jQuery's $.data() utility. */
		function Data(element) {
			/* Hardcode a reference to the plugin name. */
			var response = $.data(element, "velocity");

			/* jQuery <=1.4.2 returns null instead of undefined when no match is found. We normalize this behavior. */
			return response === null ? undefined : response;
		}

		/**************
		 Delay Timer
		 **************/

		function pauseDelayOnElement(element, currentTime) {
			/* Check for any delay timers, and pause the set timeouts (while preserving time data)
			 to be resumed when the "resume" command is issued */
			var data = Data(element);
			if (data && data.delayTimer && !data.delayPaused) {
				data.delayRemaining = data.delay - currentTime + data.delayBegin;
				data.delayPaused = true;
				clearTimeout(data.delayTimer.setTimeout);
			}
		}

		function resumeDelayOnElement(element, currentTime) {
			/* Check for any paused timers and resume */
			var data = Data(element);
			if (data && data.delayTimer && data.delayPaused) {
				/* If the element was mid-delay, re initiate the timeout with the remaining delay */
				data.delayPaused = false;
				data.delayTimer.setTimeout = setTimeout(data.delayTimer.next, data.delayRemaining);
			}
		}



		/**************
		 Easing
		 **************/

		/* Step easing generator. */
		function generateStep(steps) {
			return function(p) {
				return Math.round(p * steps) * (1 / steps);
			};
		}

		/* Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */
		function generateBezier(mX1, mY1, mX2, mY2) {
			var NEWTON_ITERATIONS = 4,
					NEWTON_MIN_SLOPE = 0.001,
					SUBDIVISION_PRECISION = 0.0000001,
					SUBDIVISION_MAX_ITERATIONS = 10,
					kSplineTableSize = 11,
					kSampleStepSize = 1.0 / (kSplineTableSize - 1.0),
					float32ArraySupported = "Float32Array" in window;

			/* Must contain four arguments. */
			if (arguments.length !== 4) {
				return false;
			}

			/* Arguments must be numbers. */
			for (var i = 0; i < 4; ++i) {
				if (typeof arguments[i] !== "number" || isNaN(arguments[i]) || !isFinite(arguments[i])) {
					return false;
				}
			}

			/* X values must be in the [0, 1] range. */
			mX1 = Math.min(mX1, 1);
			mX2 = Math.min(mX2, 1);
			mX1 = Math.max(mX1, 0);
			mX2 = Math.max(mX2, 0);

			var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

			function A(aA1, aA2) {
				return 1.0 - 3.0 * aA2 + 3.0 * aA1;
			}
			function B(aA1, aA2) {
				return 3.0 * aA2 - 6.0 * aA1;
			}
			function C(aA1) {
				return 3.0 * aA1;
			}

			function calcBezier(aT, aA1, aA2) {
				return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
			}

			function getSlope(aT, aA1, aA2) {
				return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
			}

			function newtonRaphsonIterate(aX, aGuessT) {
				for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
					var currentSlope = getSlope(aGuessT, mX1, mX2);

					if (currentSlope === 0.0) {
						return aGuessT;
					}

					var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
					aGuessT -= currentX / currentSlope;
				}

				return aGuessT;
			}

			function calcSampleValues() {
				for (var i = 0; i < kSplineTableSize; ++i) {
					mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
				}
			}

			function binarySubdivide(aX, aA, aB) {
				var currentX, currentT, i = 0;

				do {
					currentT = aA + (aB - aA) / 2.0;
					currentX = calcBezier(currentT, mX1, mX2) - aX;
					if (currentX > 0.0) {
						aB = currentT;
					} else {
						aA = currentT;
					}
				} while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

				return currentT;
			}

			function getTForX(aX) {
				var intervalStart = 0.0,
						currentSample = 1,
						lastSample = kSplineTableSize - 1;

				for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
					intervalStart += kSampleStepSize;
				}

				--currentSample;

				var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]),
						guessForT = intervalStart + dist * kSampleStepSize,
						initialSlope = getSlope(guessForT, mX1, mX2);

				if (initialSlope >= NEWTON_MIN_SLOPE) {
					return newtonRaphsonIterate(aX, guessForT);
				} else if (initialSlope === 0.0) {
					return guessForT;
				} else {
					return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);
				}
			}

			var _precomputed = false;

			function precompute() {
				_precomputed = true;
				if (mX1 !== mY1 || mX2 !== mY2) {
					calcSampleValues();
				}
			}

			var f = function(aX) {
				if (!_precomputed) {
					precompute();
				}
				if (mX1 === mY1 && mX2 === mY2) {
					return aX;
				}
				if (aX === 0) {
					return 0;
				}
				if (aX === 1) {
					return 1;
				}

				return calcBezier(getTForX(aX), mY1, mY2);
			};

			f.getControlPoints = function() {
				return [{x: mX1, y: mY1}, {x: mX2, y: mY2}];
			};

			var str = "generateBezier(" + [mX1, mY1, mX2, mY2] + ")";
			f.toString = function() {
				return str;
			};

			return f;
		}

		/* Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */
		/* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
		 then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */
		var generateSpringRK4 = (function() {
			function springAccelerationForState(state) {
				return (-state.tension * state.x) - (state.friction * state.v);
			}

			function springEvaluateStateWithDerivative(initialState, dt, derivative) {
				var state = {
					x: initialState.x + derivative.dx * dt,
					v: initialState.v + derivative.dv * dt,
					tension: initialState.tension,
					friction: initialState.friction
				};

				return {dx: state.v, dv: springAccelerationForState(state)};
			}

			function springIntegrateState(state, dt) {
				var a = {
					dx: state.v,
					dv: springAccelerationForState(state)
				},
						b = springEvaluateStateWithDerivative(state, dt * 0.5, a),
						c = springEvaluateStateWithDerivative(state, dt * 0.5, b),
						d = springEvaluateStateWithDerivative(state, dt, c),
						dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),
						dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);

				state.x = state.x + dxdt * dt;
				state.v = state.v + dvdt * dt;

				return state;
			}

			return function springRK4Factory(tension, friction, duration) {

				var initState = {
					x: -1,
					v: 0,
					tension: null,
					friction: null
				},
						path = [0],
						time_lapsed = 0,
						tolerance = 1 / 10000,
						DT = 16 / 1000,
						have_duration, dt, last_state;

				tension = parseFloat(tension) || 500;
				friction = parseFloat(friction) || 20;
				duration = duration || null;

				initState.tension = tension;
				initState.friction = friction;

				have_duration = duration !== null;

				/* Calculate the actual time it takes for this animation to complete with the provided conditions. */
				if (have_duration) {
					/* Run the simulation without a duration. */
					time_lapsed = springRK4Factory(tension, friction);
					/* Compute the adjusted time delta. */
					dt = time_lapsed / duration * DT;
				} else {
					dt = DT;
				}

				while (true) {
					/* Next/step function .*/
					last_state = springIntegrateState(last_state || initState, dt);
					/* Store the position. */
					path.push(1 + last_state.x);
					time_lapsed += 16;
					/* If the change threshold is reached, break. */
					if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {
						break;
					}
				}

				/* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
				 computed path and returns a snapshot of the position according to a given percentComplete. */
				return !have_duration ? time_lapsed : function(percentComplete) {
					return path[ (percentComplete * (path.length - 1)) | 0 ];
				};
			};
		}());

		/* jQuery easings. */
		Velocity.Easings = {
			linear: function(p) {
				return p;
			},
			swing: function(p) {
				return 0.5 - Math.cos(p * Math.PI) / 2;
			},
			/* Bonus "spring" easing, which is a less exaggerated version of easeInOutElastic. */
			spring: function(p) {
				return 1 - (Math.cos(p * 4.5 * Math.PI) * Math.exp(-p * 6));
			}
		};

		/* CSS3 and Robert Penner easings. */
		$.each(
				[
					["ease", [0.25, 0.1, 0.25, 1.0]],
					["ease-in", [0.42, 0.0, 1.00, 1.0]],
					["ease-out", [0.00, 0.0, 0.58, 1.0]],
					["ease-in-out", [0.42, 0.0, 0.58, 1.0]],
					["easeInSine", [0.47, 0, 0.745, 0.715]],
					["easeOutSine", [0.39, 0.575, 0.565, 1]],
					["easeInOutSine", [0.445, 0.05, 0.55, 0.95]],
					["easeInQuad", [0.55, 0.085, 0.68, 0.53]],
					["easeOutQuad", [0.25, 0.46, 0.45, 0.94]],
					["easeInOutQuad", [0.455, 0.03, 0.515, 0.955]],
					["easeInCubic", [0.55, 0.055, 0.675, 0.19]],
					["easeOutCubic", [0.215, 0.61, 0.355, 1]],
					["easeInOutCubic", [0.645, 0.045, 0.355, 1]],
					["easeInQuart", [0.895, 0.03, 0.685, 0.22]],
					["easeOutQuart", [0.165, 0.84, 0.44, 1]],
					["easeInOutQuart", [0.77, 0, 0.175, 1]],
					["easeInQuint", [0.755, 0.05, 0.855, 0.06]],
					["easeOutQuint", [0.23, 1, 0.32, 1]],
					["easeInOutQuint", [0.86, 0, 0.07, 1]],
					["easeInExpo", [0.95, 0.05, 0.795, 0.035]],
					["easeOutExpo", [0.19, 1, 0.22, 1]],
					["easeInOutExpo", [1, 0, 0, 1]],
					["easeInCirc", [0.6, 0.04, 0.98, 0.335]],
					["easeOutCirc", [0.075, 0.82, 0.165, 1]],
					["easeInOutCirc", [0.785, 0.135, 0.15, 0.86]]
				], function(i, easingArray) {
			Velocity.Easings[easingArray[0]] = generateBezier.apply(null, easingArray[1]);
		});

		/* Determine the appropriate easing type given an easing input. */
		function getEasing(value, duration) {
			var easing = value;

			/* The easing option can either be a string that references a pre-registered easing,
			 or it can be a two-/four-item array of integers to be converted into a bezier/spring function. */
			if (Type.isString(value)) {
				/* Ensure that the easing has been assigned to jQuery's Velocity.Easings object. */
				if (!Velocity.Easings[value]) {
					easing = false;
				}
			} else if (Type.isArray(value) && value.length === 1) {
				easing = generateStep.apply(null, value);
			} else if (Type.isArray(value) && value.length === 2) {
				/* springRK4 must be passed the animation's duration. */
				/* Note: If the springRK4 array contains non-numbers, generateSpringRK4() returns an easing
				 function generated with default tension and friction values. */
				easing = generateSpringRK4.apply(null, value.concat([duration]));
			} else if (Type.isArray(value) && value.length === 4) {
				/* Note: If the bezier array contains non-numbers, generateBezier() returns false. */
				easing = generateBezier.apply(null, value);
			} else {
				easing = false;
			}

			/* Revert to the Velocity-wide default easing type, or fall back to "swing" (which is also jQuery's default)
			 if the Velocity-wide default has been incorrectly modified. */
			if (easing === false) {
				if (Velocity.Easings[Velocity.defaults.easing]) {
					easing = Velocity.defaults.easing;
				} else {
					easing = EASING_DEFAULT;
				}
			}

			return easing;
		}

		/*****************
		 CSS Stack
		 *****************/

		/* The CSS object is a highly condensed and performant CSS stack that fully replaces jQuery's.
		 It handles the validation, getting, and setting of both standard CSS properties and CSS property hooks. */
		/* Note: A "CSS" shorthand is aliased so that our code is easier to read. */
		var CSS = Velocity.CSS = {
			/*************
			 RegEx
			 *************/

			RegEx: {
				isHex: /^#([A-f\d]{3}){1,2}$/i,
				/* Unwrap a property value's surrounding text, e.g. "rgba(4, 3, 2, 1)" ==> "4, 3, 2, 1" and "rect(4px 3px 2px 1px)" ==> "4px 3px 2px 1px". */
				valueUnwrap: /^[A-z]+\((.*)\)$/i,
				wrappedValueAlreadyExtracted: /[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/,
				/* Split a multi-value property into an array of subvalues, e.g. "rgba(4, 3, 2, 1) 4px 3px 2px 1px" ==> [ "rgba(4, 3, 2, 1)", "4px", "3px", "2px", "1px" ]. */
				valueSplit: /([A-z]+\(.+\))|(([A-z0-9#-.]+?)(?=\s|$))/ig
			},
			/************
			 Lists
			 ************/

			Lists: {
				colors: ["fill", "stroke", "stopColor", "color", "backgroundColor", "borderColor", "borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor", "outlineColor"],
				transformsBase: ["translateX", "translateY", "scale", "scaleX", "scaleY", "skewX", "skewY", "rotateZ"],
				transforms3D: ["transformPerspective", "translateZ", "scaleZ", "rotateX", "rotateY"],
				units: [
					"%", // relative
					"em", "ex", "ch", "rem", // font relative
					"vw", "vh", "vmin", "vmax", // viewport relative
					"cm", "mm", "Q", "in", "pc", "pt", "px", // absolute lengths
					"deg", "grad", "rad", "turn", // angles
					"s", "ms" // time
				],
				colorNames: {
					"aliceblue": "240,248,255",
					"antiquewhite": "250,235,215",
					"aquamarine": "127,255,212",
					"aqua": "0,255,255",
					"azure": "240,255,255",
					"beige": "245,245,220",
					"bisque": "255,228,196",
					"black": "0,0,0",
					"blanchedalmond": "255,235,205",
					"blueviolet": "138,43,226",
					"blue": "0,0,255",
					"brown": "165,42,42",
					"burlywood": "222,184,135",
					"cadetblue": "95,158,160",
					"chartreuse": "127,255,0",
					"chocolate": "210,105,30",
					"coral": "255,127,80",
					"cornflowerblue": "100,149,237",
					"cornsilk": "255,248,220",
					"crimson": "220,20,60",
					"cyan": "0,255,255",
					"darkblue": "0,0,139",
					"darkcyan": "0,139,139",
					"darkgoldenrod": "184,134,11",
					"darkgray": "169,169,169",
					"darkgrey": "169,169,169",
					"darkgreen": "0,100,0",
					"darkkhaki": "189,183,107",
					"darkmagenta": "139,0,139",
					"darkolivegreen": "85,107,47",
					"darkorange": "255,140,0",
					"darkorchid": "153,50,204",
					"darkred": "139,0,0",
					"darksalmon": "233,150,122",
					"darkseagreen": "143,188,143",
					"darkslateblue": "72,61,139",
					"darkslategray": "47,79,79",
					"darkturquoise": "0,206,209",
					"darkviolet": "148,0,211",
					"deeppink": "255,20,147",
					"deepskyblue": "0,191,255",
					"dimgray": "105,105,105",
					"dimgrey": "105,105,105",
					"dodgerblue": "30,144,255",
					"firebrick": "178,34,34",
					"floralwhite": "255,250,240",
					"forestgreen": "34,139,34",
					"fuchsia": "255,0,255",
					"gainsboro": "220,220,220",
					"ghostwhite": "248,248,255",
					"gold": "255,215,0",
					"goldenrod": "218,165,32",
					"gray": "128,128,128",
					"grey": "128,128,128",
					"greenyellow": "173,255,47",
					"green": "0,128,0",
					"honeydew": "240,255,240",
					"hotpink": "255,105,180",
					"indianred": "205,92,92",
					"indigo": "75,0,130",
					"ivory": "255,255,240",
					"khaki": "240,230,140",
					"lavenderblush": "255,240,245",
					"lavender": "230,230,250",
					"lawngreen": "124,252,0",
					"lemonchiffon": "255,250,205",
					"lightblue": "173,216,230",
					"lightcoral": "240,128,128",
					"lightcyan": "224,255,255",
					"lightgoldenrodyellow": "250,250,210",
					"lightgray": "211,211,211",
					"lightgrey": "211,211,211",
					"lightgreen": "144,238,144",
					"lightpink": "255,182,193",
					"lightsalmon": "255,160,122",
					"lightseagreen": "32,178,170",
					"lightskyblue": "135,206,250",
					"lightslategray": "119,136,153",
					"lightsteelblue": "176,196,222",
					"lightyellow": "255,255,224",
					"limegreen": "50,205,50",
					"lime": "0,255,0",
					"linen": "250,240,230",
					"magenta": "255,0,255",
					"maroon": "128,0,0",
					"mediumaquamarine": "102,205,170",
					"mediumblue": "0,0,205",
					"mediumorchid": "186,85,211",
					"mediumpurple": "147,112,219",
					"mediumseagreen": "60,179,113",
					"mediumslateblue": "123,104,238",
					"mediumspringgreen": "0,250,154",
					"mediumturquoise": "72,209,204",
					"mediumvioletred": "199,21,133",
					"midnightblue": "25,25,112",
					"mintcream": "245,255,250",
					"mistyrose": "255,228,225",
					"moccasin": "255,228,181",
					"navajowhite": "255,222,173",
					"navy": "0,0,128",
					"oldlace": "253,245,230",
					"olivedrab": "107,142,35",
					"olive": "128,128,0",
					"orangered": "255,69,0",
					"orange": "255,165,0",
					"orchid": "218,112,214",
					"palegoldenrod": "238,232,170",
					"palegreen": "152,251,152",
					"paleturquoise": "175,238,238",
					"palevioletred": "219,112,147",
					"papayawhip": "255,239,213",
					"peachpuff": "255,218,185",
					"peru": "205,133,63",
					"pink": "255,192,203",
					"plum": "221,160,221",
					"powderblue": "176,224,230",
					"purple": "128,0,128",
					"red": "255,0,0",
					"rosybrown": "188,143,143",
					"royalblue": "65,105,225",
					"saddlebrown": "139,69,19",
					"salmon": "250,128,114",
					"sandybrown": "244,164,96",
					"seagreen": "46,139,87",
					"seashell": "255,245,238",
					"sienna": "160,82,45",
					"silver": "192,192,192",
					"skyblue": "135,206,235",
					"slateblue": "106,90,205",
					"slategray": "112,128,144",
					"snow": "255,250,250",
					"springgreen": "0,255,127",
					"steelblue": "70,130,180",
					"tan": "210,180,140",
					"teal": "0,128,128",
					"thistle": "216,191,216",
					"tomato": "255,99,71",
					"turquoise": "64,224,208",
					"violet": "238,130,238",
					"wheat": "245,222,179",
					"whitesmoke": "245,245,245",
					"white": "255,255,255",
					"yellowgreen": "154,205,50",
					"yellow": "255,255,0"
				}
			},
			/************
			 Hooks
			 ************/

			/* Hooks allow a subproperty (e.g. "boxShadowBlur") of a compound-value CSS property
			 (e.g. "boxShadow: X Y Blur Spread Color") to be animated as if it were a discrete property. */
			/* Note: Beyond enabling fine-grained property animation, hooking is necessary since Velocity only
			 tweens properties with single numeric values; unlike CSS transitions, Velocity does not interpolate compound-values. */
			Hooks: {
				/********************
				 Registration
				 ********************/

				/* Templates are a concise way of indicating which subproperties must be individually registered for each compound-value CSS property. */
				/* Each template consists of the compound-value's base name, its constituent subproperty names, and those subproperties' default values. */
				templates: {
					"textShadow": ["Color X Y Blur", "black 0px 0px 0px"],
					"boxShadow": ["Color X Y Blur Spread", "black 0px 0px 0px 0px"],
					"clip": ["Top Right Bottom Left", "0px 0px 0px 0px"],
					"backgroundPosition": ["X Y", "0% 0%"],
					"transformOrigin": ["X Y Z", "50% 50% 0px"],
					"perspectiveOrigin": ["X Y", "50% 50%"]
				},
				/* A "registered" hook is one that has been converted from its template form into a live,
				 tweenable property. It contains data to associate it with its root property. */
				registered: {
					/* Note: A registered hook looks like this ==> textShadowBlur: [ "textShadow", 3 ],
					 which consists of the subproperty's name, the associated root property's name,
					 and the subproperty's position in the root's value. */
				},
				/* Convert the templates into individual hooks then append them to the registered object above. */
				register: function() {
					/* Color hooks registration: Colors are defaulted to white -- as opposed to black -- since colors that are
					 currently set to "transparent" default to their respective template below when color-animated,
					 and white is typically a closer match to transparent than black is. An exception is made for text ("color"),
					 which is almost always set closer to black than white. */
					for (var i = 0; i < CSS.Lists.colors.length; i++) {
						var rgbComponents = (CSS.Lists.colors[i] === "color") ? "0 0 0 1" : "255 255 255 1";
						CSS.Hooks.templates[CSS.Lists.colors[i]] = ["Red Green Blue Alpha", rgbComponents];
					}

					var rootProperty,
							hookTemplate,
							hookNames;

					/* In IE, color values inside compound-value properties are positioned at the end the value instead of at the beginning.
					 Thus, we re-arrange the templates accordingly. */
					if (IE) {
						for (rootProperty in CSS.Hooks.templates) {
							if (!CSS.Hooks.templates.hasOwnProperty(rootProperty)) {
								continue;
							}
							hookTemplate = CSS.Hooks.templates[rootProperty];
							hookNames = hookTemplate[0].split(" ");

							var defaultValues = hookTemplate[1].match(CSS.RegEx.valueSplit);

							if (hookNames[0] === "Color") {
								/* Reposition both the hook's name and its default value to the end of their respective strings. */
								hookNames.push(hookNames.shift());
								defaultValues.push(defaultValues.shift());

								/* Replace the existing template for the hook's root property. */
								CSS.Hooks.templates[rootProperty] = [hookNames.join(" "), defaultValues.join(" ")];
							}
						}
					}

					/* Hook registration. */
					for (rootProperty in CSS.Hooks.templates) {
						if (!CSS.Hooks.templates.hasOwnProperty(rootProperty)) {
							continue;
						}
						hookTemplate = CSS.Hooks.templates[rootProperty];
						hookNames = hookTemplate[0].split(" ");

						for (var j in hookNames) {
							if (!hookNames.hasOwnProperty(j)) {
								continue;
							}
							var fullHookName = rootProperty + hookNames[j],
									hookPosition = j;

							/* For each hook, register its full name (e.g. textShadowBlur) with its root property (e.g. textShadow)
							 and the hook's position in its template's default value string. */
							CSS.Hooks.registered[fullHookName] = [rootProperty, hookPosition];
						}
					}
				},
				/*****************************
				 Injection and Extraction
				 *****************************/

				/* Look up the root property associated with the hook (e.g. return "textShadow" for "textShadowBlur"). */
				/* Since a hook cannot be set directly (the browser won't recognize it), style updating for hooks is routed through the hook's root property. */
				getRoot: function(property) {
					var hookData = CSS.Hooks.registered[property];

					if (hookData) {
						return hookData[0];
					} else {
						/* If there was no hook match, return the property name untouched. */
						return property;
					}
				},
				getUnit: function(str, start) {
					var unit = (str.substr(start || 0, 5).match(/^[a-z%]+/) || [])[0] || "";

					if (unit && _inArray(CSS.Lists.units, unit)) {
						return unit;
					}
					return "";
				},
				fixColors: function(str) {
					return str.replace(/(rgba?\(\s*)?(\b[a-z]+\b)/g, function($0, $1, $2) {
						if (CSS.Lists.colorNames.hasOwnProperty($2)) {
							return ($1 ? $1 : "rgba(") + CSS.Lists.colorNames[$2] + ($1 ? "" : ",1)");
						}
						return $1 + $2;
					});
				},
				/* Convert any rootPropertyValue, null or otherwise, into a space-delimited list of hook values so that
				 the targeted hook can be injected or extracted at its standard position. */
				cleanRootPropertyValue: function(rootProperty, rootPropertyValue) {
					/* If the rootPropertyValue is wrapped with "rgb()", "clip()", etc., remove the wrapping to normalize the value before manipulation. */
					if (CSS.RegEx.valueUnwrap.test(rootPropertyValue)) {
						rootPropertyValue = rootPropertyValue.match(CSS.RegEx.valueUnwrap)[1];
					}

					/* If rootPropertyValue is a CSS null-value (from which there's inherently no hook value to extract),
					 default to the root's default value as defined in CSS.Hooks.templates. */
					/* Note: CSS null-values include "none", "auto", and "transparent". They must be converted into their
					 zero-values (e.g. textShadow: "none" ==> textShadow: "0px 0px 0px black") for hook manipulation to proceed. */
					if (CSS.Values.isCSSNullValue(rootPropertyValue)) {
						rootPropertyValue = CSS.Hooks.templates[rootProperty][1];
					}

					return rootPropertyValue;
				},
				/* Extracted the hook's value from its root property's value. This is used to get the starting value of an animating hook. */
				extractValue: function(fullHookName, rootPropertyValue) {
					var hookData = CSS.Hooks.registered[fullHookName];

					if (hookData) {
						var hookRoot = hookData[0],
								hookPosition = hookData[1];

						rootPropertyValue = CSS.Hooks.cleanRootPropertyValue(hookRoot, rootPropertyValue);

						/* Split rootPropertyValue into its constituent hook values then grab the desired hook at its standard position. */
						return rootPropertyValue.toString().match(CSS.RegEx.valueSplit)[hookPosition];
					} else {
						/* If the provided fullHookName isn't a registered hook, return the rootPropertyValue that was passed in. */
						return rootPropertyValue;
					}
				},
				/* Inject the hook's value into its root property's value. This is used to piece back together the root property
				 once Velocity has updated one of its individually hooked values through tweening. */
				injectValue: function(fullHookName, hookValue, rootPropertyValue) {
					var hookData = CSS.Hooks.registered[fullHookName];

					if (hookData) {
						var hookRoot = hookData[0],
								hookPosition = hookData[1],
								rootPropertyValueParts,
								rootPropertyValueUpdated;

						rootPropertyValue = CSS.Hooks.cleanRootPropertyValue(hookRoot, rootPropertyValue);

						/* Split rootPropertyValue into its individual hook values, replace the targeted value with hookValue,
						 then reconstruct the rootPropertyValue string. */
						rootPropertyValueParts = rootPropertyValue.toString().match(CSS.RegEx.valueSplit);
						rootPropertyValueParts[hookPosition] = hookValue;
						rootPropertyValueUpdated = rootPropertyValueParts.join(" ");

						return rootPropertyValueUpdated;
					} else {
						/* If the provided fullHookName isn't a registered hook, return the rootPropertyValue that was passed in. */
						return rootPropertyValue;
					}
				}
			},
			/*******************
			 Normalizations
			 *******************/

			/* Normalizations standardize CSS property manipulation by pollyfilling browser-specific implementations (e.g. opacity)
			 and reformatting special properties (e.g. clip, rgba) to look like standard ones. */
			Normalizations: {
				/* Normalizations are passed a normalization target (either the property's name, its extracted value, or its injected value),
				 the targeted element (which may need to be queried), and the targeted property value. */
				registered: {
					clip: function(type, element, propertyValue) {
						switch (type) {
							case "name":
								return "clip";
								/* Clip needs to be unwrapped and stripped of its commas during extraction. */
							case "extract":
								var extracted;

								/* If Velocity also extracted this value, skip extraction. */
								if (CSS.RegEx.wrappedValueAlreadyExtracted.test(propertyValue)) {
									extracted = propertyValue;
								} else {
									/* Remove the "rect()" wrapper. */
									extracted = propertyValue.toString().match(CSS.RegEx.valueUnwrap);

									/* Strip off commas. */
									extracted = extracted ? extracted[1].replace(/,(\s+)?/g, " ") : propertyValue;
								}

								return extracted;
								/* Clip needs to be re-wrapped during injection. */
							case "inject":
								return "rect(" + propertyValue + ")";
						}
					},
					blur: function(type, element, propertyValue) {
						switch (type) {
							case "name":
								return Velocity.State.isFirefox ? "filter" : "-webkit-filter";
							case "extract":
								var extracted = parseFloat(propertyValue);

								/* If extracted is NaN, meaning the value isn't already extracted. */
								if (!(extracted || extracted === 0)) {
									var blurComponent = propertyValue.toString().match(/blur\(([0-9]+[A-z]+)\)/i);

									/* If the filter string had a blur component, return just the blur value and unit type. */
									if (blurComponent) {
										extracted = blurComponent[1];
										/* If the component doesn't exist, default blur to 0. */
									} else {
										extracted = 0;
									}
								}

								return extracted;
								/* Blur needs to be re-wrapped during injection. */
							case "inject":
								/* For the blur effect to be fully de-applied, it needs to be set to "none" instead of 0. */
								if (!parseFloat(propertyValue)) {
									return "none";
								} else {
									return "blur(" + propertyValue + ")";
								}
						}
					},
					/* <=IE8 do not support the standard opacity property. They use filter:alpha(opacity=INT) instead. */
					opacity: function(type, element, propertyValue) {
						if (IE <= 8) {
							switch (type) {
								case "name":
									return "filter";
								case "extract":
									/* <=IE8 return a "filter" value of "alpha(opacity=\d{1,3})".
									 Extract the value and convert it to a decimal value to match the standard CSS opacity property's formatting. */
									var extracted = propertyValue.toString().match(/alpha\(opacity=(.*)\)/i);

									if (extracted) {
										/* Convert to decimal value. */
										propertyValue = extracted[1] / 100;
									} else {
										/* When extracting opacity, default to 1 since a null value means opacity hasn't been set. */
										propertyValue = 1;
									}

									return propertyValue;
								case "inject":
									/* Opacified elements are required to have their zoom property set to a non-zero value. */
									element.style.zoom = 1;

									/* Setting the filter property on elements with certain font property combinations can result in a
									 highly unappealing ultra-bolding effect. There's no way to remedy this throughout a tween, but dropping the
									 value altogether (when opacity hits 1) at leasts ensures that the glitch is gone post-tweening. */
									if (parseFloat(propertyValue) >= 1) {
										return "";
									} else {
										/* As per the filter property's spec, convert the decimal value to a whole number and wrap the value. */
										return "alpha(opacity=" + parseInt(parseFloat(propertyValue) * 100, 10) + ")";
									}
							}
							/* With all other browsers, normalization is not required; return the same values that were passed in. */
						} else {
							switch (type) {
								case "name":
									return "opacity";
								case "extract":
									return propertyValue;
								case "inject":
									return propertyValue;
							}
						}
					}
				},
				/*****************************
				 Batched Registrations
				 *****************************/

				/* Note: Batched normalizations extend the CSS.Normalizations.registered object. */
				register: function() {

					/*****************
					 Transforms
					 *****************/

					/* Transforms are the subproperties contained by the CSS "transform" property. Transforms must undergo normalization
					 so that they can be referenced in a properties map by their individual names. */
					/* Note: When transforms are "set", they are actually assigned to a per-element transformCache. When all transform
					 setting is complete complete, CSS.flushTransformCache() must be manually called to flush the values to the DOM.
					 Transform setting is batched in this way to improve performance: the transform style only needs to be updated
					 once when multiple transform subproperties are being animated simultaneously. */
					/* Note: IE9 and Android Gingerbread have support for 2D -- but not 3D -- transforms. Since animating unsupported
					 transform properties results in the browser ignoring the *entire* transform string, we prevent these 3D values
					 from being normalized for these browsers so that tweening skips these properties altogether
					 (since it will ignore them as being unsupported by the browser.) */
					if ((!IE || IE > 9) && !Velocity.State.isGingerbread) {
						/* Note: Since the standalone CSS "perspective" property and the CSS transform "perspective" subproperty
						 share the same name, the latter is given a unique token within Velocity: "transformPerspective". */
						CSS.Lists.transformsBase = CSS.Lists.transformsBase.concat(CSS.Lists.transforms3D);
					}

					for (var i = 0; i < CSS.Lists.transformsBase.length; i++) {
						/* Wrap the dynamically generated normalization function in a new scope so that transformName's value is
						 paired with its respective function. (Otherwise, all functions would take the final for loop's transformName.) */
						(function() {
							var transformName = CSS.Lists.transformsBase[i];

							CSS.Normalizations.registered[transformName] = function(type, element, propertyValue) {
								switch (type) {
									/* The normalized property name is the parent "transform" property -- the property that is actually set in CSS. */
									case "name":
										return "transform";
										/* Transform values are cached onto a per-element transformCache object. */
									case "extract":
										/* If this transform has yet to be assigned a value, return its null value. */
										if (Data(element) === undefined || Data(element).transformCache[transformName] === undefined) {
											/* Scale CSS.Lists.transformsBase default to 1 whereas all other transform properties default to 0. */
											return /^scale/i.test(transformName) ? 1 : 0;
											/* When transform values are set, they are wrapped in parentheses as per the CSS spec.
											 Thus, when extracting their values (for tween calculations), we strip off the parentheses. */
										}
										return Data(element).transformCache[transformName].replace(/[()]/g, "");
									case "inject":
										var invalid = false;

										/* If an individual transform property contains an unsupported unit type, the browser ignores the *entire* transform property.
										 Thus, protect users from themselves by skipping setting for transform values supplied with invalid unit types. */
										/* Switch on the base transform type; ignore the axis by removing the last letter from the transform's name. */
										switch (transformName.substr(0, transformName.length - 1)) {
											/* Whitelist unit types for each transform. */
											case "translate":
												invalid = !/(%|px|em|rem|vw|vh|\d)$/i.test(propertyValue);
												break;
												/* Since an axis-free "scale" property is supported as well, a little hack is used here to detect it by chopping off its last letter. */
											case "scal":
											case "scale":
												/* Chrome on Android has a bug in which scaled elements blur if their initial scale
												 value is below 1 (which can happen with forcefeeding). Thus, we detect a yet-unset scale property
												 and ensure that its first value is always 1. More info: http://stackoverflow.com/questions/10417890/css3-animations-with-transform-causes-blurred-elements-on-webkit/10417962#10417962 */
												if (Velocity.State.isAndroid && Data(element).transformCache[transformName] === undefined && propertyValue < 1) {
													propertyValue = 1;
												}

												invalid = !/(\d)$/i.test(propertyValue);
												break;
											case "skew":
												invalid = !/(deg|\d)$/i.test(propertyValue);
												break;
											case "rotate":
												invalid = !/(deg|\d)$/i.test(propertyValue);
												break;
										}

										if (!invalid) {
											/* As per the CSS spec, wrap the value in parentheses. */
											Data(element).transformCache[transformName] = "(" + propertyValue + ")";
										}

										/* Although the value is set on the transformCache object, return the newly-updated value for the calling code to process as normal. */
										return Data(element).transformCache[transformName];
								}
							};
						})();
					}

					/*************
					 Colors
					 *************/

					/* Since Velocity only animates a single numeric value per property, color animation is achieved by hooking the individual RGBA components of CSS color properties.
					 Accordingly, color values must be normalized (e.g. "#ff0000", "red", and "rgb(255, 0, 0)" ==> "255 0 0 1") so that their components can be injected/extracted by CSS.Hooks logic. */
					for (var j = 0; j < CSS.Lists.colors.length; j++) {
						/* Wrap the dynamically generated normalization function in a new scope so that colorName's value is paired with its respective function.
						 (Otherwise, all functions would take the final for loop's colorName.) */
						(function() {
							var colorName = CSS.Lists.colors[j];

							/* Note: In IE<=8, which support rgb but not rgba, color properties are reverted to rgb by stripping off the alpha component. */
							CSS.Normalizations.registered[colorName] = function(type, element, propertyValue) {
								switch (type) {
									case "name":
										return colorName;
										/* Convert all color values into the rgb format. (Old IE can return hex values and color names instead of rgb/rgba.) */
									case "extract":
										var extracted;

										/* If the color is already in its hookable form (e.g. "255 255 255 1") due to having been previously extracted, skip extraction. */
										if (CSS.RegEx.wrappedValueAlreadyExtracted.test(propertyValue)) {
											extracted = propertyValue;
										} else {
											var converted,
													colorNames = {
														black: "rgb(0, 0, 0)",
														blue: "rgb(0, 0, 255)",
														gray: "rgb(128, 128, 128)",
														green: "rgb(0, 128, 0)",
														red: "rgb(255, 0, 0)",
														white: "rgb(255, 255, 255)"
													};

											/* Convert color names to rgb. */
											if (/^[A-z]+$/i.test(propertyValue)) {
												if (colorNames[propertyValue] !== undefined) {
													converted = colorNames[propertyValue];
												} else {
													/* If an unmatched color name is provided, default to black. */
													converted = colorNames.black;
												}
												/* Convert hex values to rgb. */
											} else if (CSS.RegEx.isHex.test(propertyValue)) {
												converted = "rgb(" + CSS.Values.hexToRgb(propertyValue).join(" ") + ")";
												/* If the provided color doesn't match any of the accepted color formats, default to black. */
											} else if (!(/^rgba?\(/i.test(propertyValue))) {
												converted = colorNames.black;
											}

											/* Remove the surrounding "rgb/rgba()" string then replace commas with spaces and strip
											 repeated spaces (in case the value included spaces to begin with). */
											extracted = (converted || propertyValue).toString().match(CSS.RegEx.valueUnwrap)[1].replace(/,(\s+)?/g, " ");
										}

										/* So long as this isn't <=IE8, add a fourth (alpha) component if it's missing and default it to 1 (visible). */
										if ((!IE || IE > 8) && extracted.split(" ").length === 3) {
											extracted += " 1";
										}

										return extracted;
									case "inject":
										/* If we have a pattern then it might already have the right values */
										if (/^rgb/.test(propertyValue)) {
											return propertyValue;
										}

										/* If this is IE<=8 and an alpha component exists, strip it off. */
										if (IE <= 8) {
											if (propertyValue.split(" ").length === 4) {
												propertyValue = propertyValue.split(/\s+/).slice(0, 3).join(" ");
											}
											/* Otherwise, add a fourth (alpha) component if it's missing and default it to 1 (visible). */
										} else if (propertyValue.split(" ").length === 3) {
											propertyValue += " 1";
										}

										/* Re-insert the browser-appropriate wrapper("rgb/rgba()"), insert commas, and strip off decimal units
										 on all values but the fourth (R, G, and B only accept whole numbers). */
										return (IE <= 8 ? "rgb" : "rgba") + "(" + propertyValue.replace(/\s+/g, ",").replace(/\.(\d)+(?=,)/g, "") + ")";
								}
							};
						})();
					}

					/**************
					 Dimensions
					 **************/
					function augmentDimension(name, element, wantInner) {
						var isBorderBox = CSS.getPropertyValue(element, "boxSizing").toString().toLowerCase() === "border-box";

						if (isBorderBox === (wantInner || false)) {
							/* in box-sizing mode, the CSS width / height accessors already give the outerWidth / outerHeight. */
							var i,
									value,
									augment = 0,
									sides = name === "width" ? ["Left", "Right"] : ["Top", "Bottom"],
									fields = ["padding" + sides[0], "padding" + sides[1], "border" + sides[0] + "Width", "border" + sides[1] + "Width"];

							for (i = 0; i < fields.length; i++) {
								value = parseFloat(CSS.getPropertyValue(element, fields[i]));
								if (!isNaN(value)) {
									augment += value;
								}
							}
							return wantInner ? -augment : augment;
						}
						return 0;
					}
					function getDimension(name, wantInner) {
						return function(type, element, propertyValue) {
							switch (type) {
								case "name":
									return name;
								case "extract":
									return parseFloat(propertyValue) + augmentDimension(name, element, wantInner);
								case "inject":
									return (parseFloat(propertyValue) - augmentDimension(name, element, wantInner)) + "px";
							}
						};
					}
					CSS.Normalizations.registered.innerWidth = getDimension("width", true);
					CSS.Normalizations.registered.innerHeight = getDimension("height", true);
					CSS.Normalizations.registered.outerWidth = getDimension("width");
					CSS.Normalizations.registered.outerHeight = getDimension("height");
				}
			},
			/************************
			 CSS Property Names
			 ************************/

			Names: {
				/* Camelcase a property name into its JavaScript notation (e.g. "background-color" ==> "backgroundColor").
				 Camelcasing is used to normalize property names between and across calls. */
				camelCase: function(property) {
					return property.replace(/-(\w)/g, function(match, subMatch) {
						return subMatch.toUpperCase();
					});
				},
				/* For SVG elements, some properties (namely, dimensional ones) are GET/SET via the element's HTML attributes (instead of via CSS styles). */
				SVGAttribute: function(property) {
					var SVGAttributes = "width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2";

					/* Certain browsers require an SVG transform to be applied as an attribute. (Otherwise, application via CSS is preferable due to 3D support.) */
					if (IE || (Velocity.State.isAndroid && !Velocity.State.isChrome)) {
						SVGAttributes += "|transform";
					}

					return new RegExp("^(" + SVGAttributes + ")$", "i").test(property);
				},
				/* Determine whether a property should be set with a vendor prefix. */
				/* If a prefixed version of the property exists, return it. Otherwise, return the original property name.
				 If the property is not at all supported by the browser, return a false flag. */
				prefixCheck: function(property) {
					/* If this property has already been checked, return the cached value. */
					if (Velocity.State.prefixMatches[property]) {
						return [Velocity.State.prefixMatches[property], true];
					} else {
						var vendors = ["", "Webkit", "Moz", "ms", "O"];

						for (var i = 0, vendorsLength = vendors.length; i < vendorsLength; i++) {
							var propertyPrefixed;

							if (i === 0) {
								propertyPrefixed = property;
							} else {
								/* Capitalize the first letter of the property to conform to JavaScript vendor prefix notation (e.g. webkitFilter). */
								propertyPrefixed = vendors[i] + property.replace(/^\w/, function(match) {
									return match.toUpperCase();
								});
							}

							/* Check if the browser supports this property as prefixed. */
							if (Type.isString(Velocity.State.prefixElement.style[propertyPrefixed])) {
								/* Cache the match. */
								Velocity.State.prefixMatches[property] = propertyPrefixed;

								return [propertyPrefixed, true];
							}
						}

						/* If the browser doesn't support this property in any form, include a false flag so that the caller can decide how to proceed. */
						return [property, false];
					}
				}
			},
			/************************
			 CSS Property Values
			 ************************/

			Values: {
				/* Hex to RGB conversion. Copyright Tim Down: http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb */
				hexToRgb: function(hex) {
					var shortformRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i,
							longformRegex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
							rgbParts;

					hex = hex.replace(shortformRegex, function(m, r, g, b) {
						return r + r + g + g + b + b;
					});

					rgbParts = longformRegex.exec(hex);

					return rgbParts ? [parseInt(rgbParts[1], 16), parseInt(rgbParts[2], 16), parseInt(rgbParts[3], 16)] : [0, 0, 0];
				},
				isCSSNullValue: function(value) {
					/* The browser defaults CSS values that have not been set to either 0 or one of several possible null-value strings.
					 Thus, we check for both falsiness and these special strings. */
					/* Null-value checking is performed to default the special strings to 0 (for the sake of tweening) or their hook
					 templates as defined as CSS.Hooks (for the sake of hook injection/extraction). */
					/* Note: Chrome returns "rgba(0, 0, 0, 0)" for an undefined color whereas IE returns "transparent". */
					return (!value || /^(none|auto|transparent|(rgba\(0, ?0, ?0, ?0\)))$/i.test(value));
				},
				/* Retrieve a property's default unit type. Used for assigning a unit type when one is not supplied by the user. */
				getUnitType: function(property) {
					if (/^(rotate|skew)/i.test(property)) {
						return "deg";
					} else if (/(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(property)) {
						/* The above properties are unitless. */
						return "";
					} else {
						/* Default to px for all other properties. */
						return "px";
					}
				},
				/* HTML elements default to an associated display type when they're not set to display:none. */
				/* Note: This function is used for correctly setting the non-"none" display value in certain Velocity redirects, such as fadeIn/Out. */
				getDisplayType: function(element) {
					var tagName = element && element.tagName.toString().toLowerCase();

					if (/^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(tagName)) {
						return "inline";
					} else if (/^(li)$/i.test(tagName)) {
						return "list-item";
					} else if (/^(tr)$/i.test(tagName)) {
						return "table-row";
					} else if (/^(table)$/i.test(tagName)) {
						return "table";
					} else if (/^(tbody)$/i.test(tagName)) {
						return "table-row-group";
						/* Default to "block" when no match is found. */
					} else {
						return "block";
					}
				},
				/* The class add/remove functions are used to temporarily apply a "velocity-animating" class to elements while they're animating. */
				addClass: function(element, className) {
					if (element) {
						if (element.classList) {
							element.classList.add(className);
						} else if (Type.isString(element.className)) {
							// Element.className is around 15% faster then set/getAttribute
							element.className += (element.className.length ? " " : "") + className;
						} else {
							// Work around for IE strict mode animating SVG - and anything else that doesn't behave correctly - the same way jQuery does it
							var currentClass = element.getAttribute(IE <= 7 ? "className" : "class") || "";

							element.setAttribute("class", currentClass + (currentClass ? " " : "") + className);
						}
					}
				},
				removeClass: function(element, className) {
					if (element) {
						if (element.classList) {
							element.classList.remove(className);
						} else if (Type.isString(element.className)) {
							// Element.className is around 15% faster then set/getAttribute
							// TODO: Need some jsperf tests on performance - can we get rid of the regex and maybe use split / array manipulation?
							element.className = element.className.toString().replace(new RegExp("(^|\\s)" + className.split(" ").join("|") + "(\\s|$)", "gi"), " ");
						} else {
							// Work around for IE strict mode animating SVG - and anything else that doesn't behave correctly - the same way jQuery does it
							var currentClass = element.getAttribute(IE <= 7 ? "className" : "class") || "";

							element.setAttribute("class", currentClass.replace(new RegExp("(^|\s)" + className.split(" ").join("|") + "(\s|$)", "gi"), " "));
						}
					}
				}
			},
			/****************************
			 Style Getting & Setting
			 ****************************/

			/* The singular getPropertyValue, which routes the logic for all normalizations, hooks, and standard CSS properties. */
			getPropertyValue: function(element, property, rootPropertyValue, forceStyleLookup) {
				/* Get an element's computed property value. */
				/* Note: Retrieving the value of a CSS property cannot simply be performed by checking an element's
				 style attribute (which only reflects user-defined values). Instead, the browser must be queried for a property's
				 *computed* value. You can read more about getComputedStyle here: https://developer.mozilla.org/en/docs/Web/API/window.getComputedStyle */
				function computePropertyValue(element, property) {
					/* When box-sizing isn't set to border-box, height and width style values are incorrectly computed when an
					 element's scrollbars are visible (which expands the element's dimensions). Thus, we defer to the more accurate
					 offsetHeight/Width property, which includes the total dimensions for interior, border, padding, and scrollbar.
					 We subtract border and padding to get the sum of interior + scrollbar. */
					var computedValue = 0;

					/* IE<=8 doesn't support window.getComputedStyle, thus we defer to jQuery, which has an extensive array
					 of hacks to accurately retrieve IE8 property values. Re-implementing that logic here is not worth bloating the
					 codebase for a dying browser. The performance repercussions of using jQuery here are minimal since
					 Velocity is optimized to rarely (and sometimes never) query the DOM. Further, the $.css() codepath isn't that slow. */
					if (IE <= 8) {
						computedValue = $.css(element, property); /* GET */
						/* All other browsers support getComputedStyle. The returned live object reference is cached onto its
						 associated element so that it does not need to be refetched upon every GET. */
					} else {
						/* Browsers do not return height and width values for elements that are set to display:"none". Thus, we temporarily
						 toggle display to the element type's default value. */
						var toggleDisplay = false;

						if (/^(width|height)$/.test(property) && CSS.getPropertyValue(element, "display") === 0) {
							toggleDisplay = true;
							CSS.setPropertyValue(element, "display", CSS.Values.getDisplayType(element));
						}

						var revertDisplay = function() {
							if (toggleDisplay) {
								CSS.setPropertyValue(element, "display", "none");
							}
						};

						if (!forceStyleLookup) {
							if (property === "height" && CSS.getPropertyValue(element, "boxSizing").toString().toLowerCase() !== "border-box") {
								var contentBoxHeight = element.offsetHeight - (parseFloat(CSS.getPropertyValue(element, "borderTopWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "borderBottomWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingTop")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingBottom")) || 0);
								revertDisplay();

								return contentBoxHeight;
							} else if (property === "width" && CSS.getPropertyValue(element, "boxSizing").toString().toLowerCase() !== "border-box") {
								var contentBoxWidth = element.offsetWidth - (parseFloat(CSS.getPropertyValue(element, "borderLeftWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "borderRightWidth")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingLeft")) || 0) - (parseFloat(CSS.getPropertyValue(element, "paddingRight")) || 0);
								revertDisplay();

								return contentBoxWidth;
							}
						}

						var computedStyle;

						/* For elements that Velocity hasn't been called on directly (e.g. when Velocity queries the DOM on behalf
						 of a parent of an element its animating), perform a direct getComputedStyle lookup since the object isn't cached. */
						if (Data(element) === undefined) {
							computedStyle = window.getComputedStyle(element, null); /* GET */
							/* If the computedStyle object has yet to be cached, do so now. */
						} else if (!Data(element).computedStyle) {
							computedStyle = Data(element).computedStyle = window.getComputedStyle(element, null); /* GET */
							/* If computedStyle is cached, use it. */
						} else {
							computedStyle = Data(element).computedStyle;
						}

						/* IE and Firefox do not return a value for the generic borderColor -- they only return individual values for each border side's color.
						 Also, in all browsers, when border colors aren't all the same, a compound value is returned that Velocity isn't setup to parse.
						 So, as a polyfill for querying individual border side colors, we just return the top border's color and animate all borders from that value. */
						if (property === "borderColor") {
							property = "borderTopColor";
						}

						/* IE9 has a bug in which the "filter" property must be accessed from computedStyle using the getPropertyValue method
						 instead of a direct property lookup. The getPropertyValue method is slower than a direct lookup, which is why we avoid it by default. */
						if (IE === 9 && property === "filter") {
							computedValue = computedStyle.getPropertyValue(property); /* GET */
						} else {
							computedValue = computedStyle[property];
						}

						/* Fall back to the property's style value (if defined) when computedValue returns nothing,
						 which can happen when the element hasn't been painted. */
						if (computedValue === "" || computedValue === null) {
							computedValue = element.style[property];
						}

						revertDisplay();
					}

					/* For top, right, bottom, and left (TRBL) values that are set to "auto" on elements of "fixed" or "absolute" position,
					 defer to jQuery for converting "auto" to a numeric value. (For elements with a "static" or "relative" position, "auto" has the same
					 effect as being set to 0, so no conversion is necessary.) */
					/* An example of why numeric conversion is necessary: When an element with "position:absolute" has an untouched "left"
					 property, which reverts to "auto", left's value is 0 relative to its parent element, but is often non-zero relative
					 to its *containing* (not parent) element, which is the nearest "position:relative" ancestor or the viewport (and always the viewport in the case of "position:fixed"). */
					if (computedValue === "auto" && /^(top|right|bottom|left)$/i.test(property)) {
						var position = computePropertyValue(element, "position"); /* GET */

						/* For absolute positioning, jQuery's $.position() only returns values for top and left;
						 right and bottom will have their "auto" value reverted to 0. */
						/* Note: A jQuery object must be created here since jQuery doesn't have a low-level alias for $.position().
						 Not a big deal since we're currently in a GET batch anyway. */
						if (position === "fixed" || (position === "absolute" && /top|left/i.test(property))) {
							/* Note: jQuery strips the pixel unit from its returned values; we re-add it here to conform with computePropertyValue's behavior. */
							computedValue = $(element).position()[property] + "px"; /* GET */
						}
					}

					return computedValue;
				}

				var propertyValue;

				/* If this is a hooked property (e.g. "clipLeft" instead of the root property of "clip"),
				 extract the hook's value from a normalized rootPropertyValue using CSS.Hooks.extractValue(). */
				if (CSS.Hooks.registered[property]) {
					var hook = property,
							hookRoot = CSS.Hooks.getRoot(hook);

					/* If a cached rootPropertyValue wasn't passed in (which Velocity always attempts to do in order to avoid requerying the DOM),
					 query the DOM for the root property's value. */
					if (rootPropertyValue === undefined) {
						/* Since the browser is now being directly queried, use the official post-prefixing property name for this lookup. */
						rootPropertyValue = CSS.getPropertyValue(element, CSS.Names.prefixCheck(hookRoot)[0]); /* GET */
					}

					/* If this root has a normalization registered, peform the associated normalization extraction. */
					if (CSS.Normalizations.registered[hookRoot]) {
						rootPropertyValue = CSS.Normalizations.registered[hookRoot]("extract", element, rootPropertyValue);
					}

					/* Extract the hook's value. */
					propertyValue = CSS.Hooks.extractValue(hook, rootPropertyValue);

					/* If this is a normalized property (e.g. "opacity" becomes "filter" in <=IE8) or "translateX" becomes "transform"),
					 normalize the property's name and value, and handle the special case of transforms. */
					/* Note: Normalizing a property is mutually exclusive from hooking a property since hook-extracted values are strictly
					 numerical and therefore do not require normalization extraction. */
				} else if (CSS.Normalizations.registered[property]) {
					var normalizedPropertyName,
							normalizedPropertyValue;

					normalizedPropertyName = CSS.Normalizations.registered[property]("name", element);

					/* Transform values are calculated via normalization extraction (see below), which checks against the element's transformCache.
					 At no point do transform GETs ever actually query the DOM; initial stylesheet values are never processed.
					 This is because parsing 3D transform matrices is not always accurate and would bloat our codebase;
					 thus, normalization extraction defaults initial transform values to their zero-values (e.g. 1 for scaleX and 0 for translateX). */
					if (normalizedPropertyName !== "transform") {
						normalizedPropertyValue = computePropertyValue(element, CSS.Names.prefixCheck(normalizedPropertyName)[0]); /* GET */

						/* If the value is a CSS null-value and this property has a hook template, use that zero-value template so that hooks can be extracted from it. */
						if (CSS.Values.isCSSNullValue(normalizedPropertyValue) && CSS.Hooks.templates[property]) {
							normalizedPropertyValue = CSS.Hooks.templates[property][1];
						}
					}

					propertyValue = CSS.Normalizations.registered[property]("extract", element, normalizedPropertyValue);
				}

				/* If a (numeric) value wasn't produced via hook extraction or normalization, query the DOM. */
				if (!/^[\d-]/.test(propertyValue)) {
					/* For SVG elements, dimensional properties (which SVGAttribute() detects) are tweened via
					 their HTML attribute values instead of their CSS style values. */
					var data = Data(element);

					if (data && data.isSVG && CSS.Names.SVGAttribute(property)) {
						/* Since the height/width attribute values must be set manually, they don't reflect computed values.
						 Thus, we use use getBBox() to ensure we always get values for elements with undefined height/width attributes. */
						if (/^(height|width)$/i.test(property)) {
							/* Firefox throws an error if .getBBox() is called on an SVG that isn't attached to the DOM. */
							try {
								propertyValue = element.getBBox()[property];
							} catch (error) {
								propertyValue = 0;
							}
							/* Otherwise, access the attribute value directly. */
						} else {
							propertyValue = element.getAttribute(property);
						}
					} else {
						propertyValue = computePropertyValue(element, CSS.Names.prefixCheck(property)[0]); /* GET */
					}
				}

				/* Since property lookups are for animation purposes (which entails computing the numeric delta between start and end values),
				 convert CSS null-values to an integer of value 0. */
				if (CSS.Values.isCSSNullValue(propertyValue)) {
					propertyValue = 0;
				}

				if (Velocity.debug >= 2) {
					console.log("Get " + property + ": " + propertyValue);
				}

				return propertyValue;
			},
			/* The singular setPropertyValue, which routes the logic for all normalizations, hooks, and standard CSS properties. */
			setPropertyValue: function(element, property, propertyValue, rootPropertyValue, scrollData) {
				var propertyName = property;

				/* In order to be subjected to call options and element queueing, scroll animation is routed through Velocity as if it were a standard CSS property. */
				if (property === "scroll") {
					/* If a container option is present, scroll the container instead of the browser window. */
					if (scrollData.container) {
						scrollData.container["scroll" + scrollData.direction] = propertyValue;
						/* Otherwise, Velocity defaults to scrolling the browser window. */
					} else {
						if (scrollData.direction === "Left") {
							window.scrollTo(propertyValue, scrollData.alternateValue);
						} else {
							window.scrollTo(scrollData.alternateValue, propertyValue);
						}
					}
				} else {
					/* Transforms (translateX, rotateZ, etc.) are applied to a per-element transformCache object, which is manually flushed via flushTransformCache().
					 Thus, for now, we merely cache transforms being SET. */
					if (CSS.Normalizations.registered[property] && CSS.Normalizations.registered[property]("name", element) === "transform") {
						/* Perform a normalization injection. */
						/* Note: The normalization logic handles the transformCache updating. */
						CSS.Normalizations.registered[property]("inject", element, propertyValue);

						propertyName = "transform";
						propertyValue = Data(element).transformCache[property];
					} else {
						/* Inject hooks. */
						if (CSS.Hooks.registered[property]) {
							var hookName = property,
									hookRoot = CSS.Hooks.getRoot(property);

							/* If a cached rootPropertyValue was not provided, query the DOM for the hookRoot's current value. */
							rootPropertyValue = rootPropertyValue || CSS.getPropertyValue(element, hookRoot); /* GET */

							propertyValue = CSS.Hooks.injectValue(hookName, propertyValue, rootPropertyValue);
							property = hookRoot;
						}

						/* Normalize names and values. */
						if (CSS.Normalizations.registered[property]) {
							propertyValue = CSS.Normalizations.registered[property]("inject", element, propertyValue);
							property = CSS.Normalizations.registered[property]("name", element);
						}

						/* Assign the appropriate vendor prefix before performing an official style update. */
						propertyName = CSS.Names.prefixCheck(property)[0];

						/* A try/catch is used for IE<=8, which throws an error when "invalid" CSS values are set, e.g. a negative width.
						 Try/catch is avoided for other browsers since it incurs a performance overhead. */
						if (IE <= 8) {
							try {
								element.style[propertyName] = propertyValue;
							} catch (error) {
								if (Velocity.debug) {
									console.log("Browser does not support [" + propertyValue + "] for [" + propertyName + "]");
								}
							}
							/* SVG elements have their dimensional properties (width, height, x, y, cx, etc.) applied directly as attributes instead of as styles. */
							/* Note: IE8 does not support SVG elements, so it's okay that we skip it for SVG animation. */
						} else {
							var data = Data(element);

							if (data && data.isSVG && CSS.Names.SVGAttribute(property)) {
								/* Note: For SVG attributes, vendor-prefixed property names are never used. */
								/* Note: Not all CSS properties can be animated via attributes, but the browser won't throw an error for unsupported properties. */
								element.setAttribute(property, propertyValue);
							} else {
								element.style[propertyName] = propertyValue;
							}
						}

						if (Velocity.debug >= 2) {
							console.log("Set " + property + " (" + propertyName + "): " + propertyValue);
						}
					}
				}

				/* Return the normalized property name and value in case the caller wants to know how these values were modified before being applied to the DOM. */
				return [propertyName, propertyValue];
			},
			/* To increase performance by batching transform updates into a single SET, transforms are not directly applied to an element until flushTransformCache() is called. */
			/* Note: Velocity applies transform properties in the same order that they are chronogically introduced to the element's CSS styles. */
			flushTransformCache: function(element) {
				var transformString = "",
						data = Data(element);

				/* Certain browsers require that SVG transforms be applied as an attribute. However, the SVG transform attribute takes a modified version of CSS's transform string
				 (units are dropped and, except for skewX/Y, subproperties are merged into their master property -- e.g. scaleX and scaleY are merged into scale(X Y). */
				if ((IE || (Velocity.State.isAndroid && !Velocity.State.isChrome)) && data && data.isSVG) {
					/* Since transform values are stored in their parentheses-wrapped form, we use a helper function to strip out their numeric values.
					 Further, SVG transform properties only take unitless (representing pixels) values, so it's okay that parseFloat() strips the unit suffixed to the float value. */
					var getTransformFloat = function(transformProperty) {
						return parseFloat(CSS.getPropertyValue(element, transformProperty));
					};

					/* Create an object to organize all the transforms that we'll apply to the SVG element. To keep the logic simple,
					 we process *all* transform properties -- even those that may not be explicitly applied (since they default to their zero-values anyway). */
					var SVGTransforms = {
						translate: [getTransformFloat("translateX"), getTransformFloat("translateY")],
						skewX: [getTransformFloat("skewX")], skewY: [getTransformFloat("skewY")],
						/* If the scale property is set (non-1), use that value for the scaleX and scaleY values
						 (this behavior mimics the result of animating all these properties at once on HTML elements). */
						scale: getTransformFloat("scale") !== 1 ? [getTransformFloat("scale"), getTransformFloat("scale")] : [getTransformFloat("scaleX"), getTransformFloat("scaleY")],
						/* Note: SVG's rotate transform takes three values: rotation degrees followed by the X and Y values
						 defining the rotation's origin point. We ignore the origin values (default them to 0). */
						rotate: [getTransformFloat("rotateZ"), 0, 0]
					};

					/* Iterate through the transform properties in the user-defined property map order.
					 (This mimics the behavior of non-SVG transform animation.) */
					$.each(Data(element).transformCache, function(transformName) {
						/* Except for with skewX/Y, revert the axis-specific transform subproperties to their axis-free master
						 properties so that they match up with SVG's accepted transform properties. */
						if (/^translate/i.test(transformName)) {
							transformName = "translate";
						} else if (/^scale/i.test(transformName)) {
							transformName = "scale";
						} else if (/^rotate/i.test(transformName)) {
							transformName = "rotate";
						}

						/* Check that we haven't yet deleted the property from the SVGTransforms container. */
						if (SVGTransforms[transformName]) {
							/* Append the transform property in the SVG-supported transform format. As per the spec, surround the space-delimited values in parentheses. */
							transformString += transformName + "(" + SVGTransforms[transformName].join(" ") + ")" + " ";

							/* After processing an SVG transform property, delete it from the SVGTransforms container so we don't
							 re-insert the same master property if we encounter another one of its axis-specific properties. */
							delete SVGTransforms[transformName];
						}
					});
				} else {
					var transformValue,
							perspective;

					/* Transform properties are stored as members of the transformCache object. Concatenate all the members into a string. */
					$.each(Data(element).transformCache, function(transformName) {
						transformValue = Data(element).transformCache[transformName];

						/* Transform's perspective subproperty must be set first in order to take effect. Store it temporarily. */
						if (transformName === "transformPerspective") {
							perspective = transformValue;
							return true;
						}

						/* IE9 only supports one rotation type, rotateZ, which it refers to as "rotate". */
						if (IE === 9 && transformName === "rotateZ") {
							transformName = "rotate";
						}

						transformString += transformName + transformValue + " ";
					});

					/* If present, set the perspective subproperty first. */
					if (perspective) {
						transformString = "perspective" + perspective + " " + transformString;
					}
				}

				CSS.setPropertyValue(element, "transform", transformString);
			}
		};

		/* Register hooks and normalizations. */
		CSS.Hooks.register();
		CSS.Normalizations.register();

		/* Allow hook setting in the same fashion as jQuery's $.css(). */
		Velocity.hook = function(elements, arg2, arg3) {
			var value;

			elements = sanitizeElements(elements);

			$.each(elements, function(i, element) {
				/* Initialize Velocity's per-element data cache if this element hasn't previously been animated. */
				if (Data(element) === undefined) {
					Velocity.init(element);
				}

				/* Get property value. If an element set was passed in, only return the value for the first element. */
				if (arg3 === undefined) {
					if (value === undefined) {
						value = CSS.getPropertyValue(element, arg2);
					}
					/* Set property value. */
				} else {
					/* sPV returns an array of the normalized propertyName/propertyValue pair used to update the DOM. */
					var adjustedSet = CSS.setPropertyValue(element, arg2, arg3);

					/* Transform properties don't automatically set. They have to be flushed to the DOM. */
					if (adjustedSet[0] === "transform") {
						Velocity.CSS.flushTransformCache(element);
					}

					value = adjustedSet;
				}
			});

			return value;
		};

		/*****************
		 Animation
		 *****************/

		var animate = function() {
			var opts;

			/******************
			 Call Chain
			 ******************/

			/* Logic for determining what to return to the call stack when exiting out of Velocity. */
			function getChain() {
				/* If we are using the utility function, attempt to return this call's promise. If no promise library was detected,
				 default to null instead of returning the targeted elements so that utility function's return value is standardized. */
				if (isUtility) {
					return promiseData.promise || null;
					/* Otherwise, if we're using $.fn, return the jQuery-/Zepto-wrapped element set. */
				} else {
					return elementsWrapped;
				}
			}

			/*************************
			 Arguments Assignment
			 *************************/

			/* To allow for expressive CoffeeScript code, Velocity supports an alternative syntax in which "elements" (or "e"), "properties" (or "p"), and "options" (or "o")
			 objects are defined on a container object that's passed in as Velocity's sole argument. */
			/* Note: Some browsers automatically populate arguments with a "properties" object. We detect it by checking for its default "names" property. */
			var syntacticSugar = (arguments[0] && (arguments[0].p || (($.isPlainObject(arguments[0].properties) && !arguments[0].properties.names) || Type.isString(arguments[0].properties)))),
					/* Whether Velocity was called via the utility function (as opposed to on a jQuery/Zepto object). */
					isUtility,
					/* When Velocity is called via the utility function ($.Velocity()/Velocity()), elements are explicitly
					 passed in as the first parameter. Thus, argument positioning varies. We normalize them here. */
					elementsWrapped,
					argumentIndex;

			var elements,
					propertiesMap,
					options;

			/* Detect jQuery/Zepto elements being animated via the $.fn method. */
			if (Type.isWrapped(this)) {
				isUtility = false;

				argumentIndex = 0;
				elements = this;
				elementsWrapped = this;
				/* Otherwise, raw elements are being animated via the utility function. */
			} else {
				isUtility = true;

				argumentIndex = 1;
				elements = syntacticSugar ? (arguments[0].elements || arguments[0].e) : arguments[0];
			}

			/***************
			 Promises
			 ***************/

			var promiseData = {
				promise: null,
				resolver: null,
				rejecter: null
			};

			/* If this call was made via the utility function (which is the default method of invocation when jQuery/Zepto are not being used), and if
			 promise support was detected, create a promise object for this call and store references to its resolver and rejecter methods. The resolve
			 method is used when a call completes naturally or is prematurely stopped by the user. In both cases, completeCall() handles the associated
			 call cleanup and promise resolving logic. The reject method is used when an invalid set of arguments is passed into a Velocity call. */
			/* Note: Velocity employs a call-based queueing architecture, which means that stopping an animating element actually stops the full call that
			 triggered it -- not that one element exclusively. Similarly, there is one promise per call, and all elements targeted by a Velocity call are
			 grouped together for the purposes of resolving and rejecting a promise. */
			if (isUtility && Velocity.Promise) {
				promiseData.promise = new Velocity.Promise(function(resolve, reject) {
					promiseData.resolver = resolve;
					promiseData.rejecter = reject;
				});
			}

			if (syntacticSugar) {
				propertiesMap = arguments[0].properties || arguments[0].p;
				options = arguments[0].options || arguments[0].o;
			} else {
				propertiesMap = arguments[argumentIndex];
				options = arguments[argumentIndex + 1];
			}

			elements = sanitizeElements(elements);

			if (!elements) {
				if (promiseData.promise) {
					if (!propertiesMap || !options || options.promiseRejectEmpty !== false) {
						promiseData.rejecter();
					} else {
						promiseData.resolver();
					}
				}
				return;
			}

			/* The length of the element set (in the form of a nodeList or an array of elements) is defaulted to 1 in case a
			 single raw DOM element is passed in (which doesn't contain a length property). */
			var elementsLength = elements.length,
					elementsIndex = 0;

			/***************************
			 Argument Overloading
			 ***************************/

			/* Support is included for jQuery's argument overloading: $.animate(propertyMap [, duration] [, easing] [, complete]).
			 Overloading is detected by checking for the absence of an object being passed into options. */
			/* Note: The stop/finish/pause/resume actions do not accept animation options, and are therefore excluded from this check. */
			if (!/^(stop|finish|finishAll|pause|resume)$/i.test(propertiesMap) && !$.isPlainObject(options)) {
				/* The utility function shifts all arguments one position to the right, so we adjust for that offset. */
				var startingArgumentPosition = argumentIndex + 1;

				options = {};

				/* Iterate through all options arguments */
				for (var i = startingArgumentPosition; i < arguments.length; i++) {
					/* Treat a number as a duration. Parse it out. */
					/* Note: The following RegEx will return true if passed an array with a number as its first item.
					 Thus, arrays are skipped from this check. */
					if (!Type.isArray(arguments[i]) && (/^(fast|normal|slow)$/i.test(arguments[i]) || /^\d/.test(arguments[i]))) {
						options.duration = arguments[i];
						/* Treat strings and arrays as easings. */
					} else if (Type.isString(arguments[i]) || Type.isArray(arguments[i])) {
						options.easing = arguments[i];
						/* Treat a function as a complete callback. */
					} else if (Type.isFunction(arguments[i])) {
						options.complete = arguments[i];
					}
				}
			}

			/*********************
			 Action Detection
			 *********************/

			/* Velocity's behavior is categorized into "actions": Elements can either be specially scrolled into view,
			 or they can be started, stopped, paused, resumed, or reversed . If a literal or referenced properties map is passed in as Velocity's
			 first argument, the associated action is "start". Alternatively, "scroll", "reverse", "pause", "resume" or "stop" can be passed in 
			 instead of a properties map. */
			var action;

			switch (propertiesMap) {
				case "scroll":
					action = "scroll";
					break;

				case "reverse":
					action = "reverse";
					break;

				case "pause":

					/*******************
					 Action: Pause
					 *******************/

					var currentTime = (new Date()).getTime();

					/* Handle delay timers */
					$.each(elements, function(i, element) {
						pauseDelayOnElement(element, currentTime);
					});

					/* Pause and Resume are call-wide (not on a per element basis). Thus, calling pause or resume on a 
					 single element will cause any calls that containt tweens for that element to be paused/resumed
					 as well. */

					/* Iterate through all calls and pause any that contain any of our elements */
					$.each(Velocity.State.calls, function(i, activeCall) {

						var found = false;
						/* Inactive calls are set to false by the logic inside completeCall(). Skip them. */
						if (activeCall) {
							/* Iterate through the active call's targeted elements. */
							$.each(activeCall[1], function(k, activeElement) {
								var queueName = (options === undefined) ? "" : options;

								if (queueName !== true && (activeCall[2].queue !== queueName) && !(options === undefined && activeCall[2].queue === false)) {
									return true;
								}

								/* Iterate through the calls targeted by the stop command. */
								$.each(elements, function(l, element) {
									/* Check that this call was applied to the target element. */
									if (element === activeElement) {

										/* Set call to paused */
										activeCall[5] = {
											resume: false
										};

										/* Once we match an element, we can bounce out to the next call entirely */
										found = true;
										return false;
									}
								});

								/* Proceed to check next call if we have already matched */
								if (found) {
									return false;
								}
							});
						}

					});

					/* Since pause creates no new tweens, exit out of Velocity. */
					return getChain();

				case "resume":

					/*******************
					 Action: Resume
					 *******************/

					/* Handle delay timers */
					$.each(elements, function(i, element) {
						resumeDelayOnElement(element, currentTime);
					});

					/* Pause and Resume are call-wide (not on a per elemnt basis). Thus, calling pause or resume on a 
					 single element will cause any calls that containt tweens for that element to be paused/resumed
					 as well. */

					/* Iterate through all calls and pause any that contain any of our elements */
					$.each(Velocity.State.calls, function(i, activeCall) {
						var found = false;
						/* Inactive calls are set to false by the logic inside completeCall(). Skip them. */
						if (activeCall) {
							/* Iterate through the active call's targeted elements. */
							$.each(activeCall[1], function(k, activeElement) {
								var queueName = (options === undefined) ? "" : options;

								if (queueName !== true && (activeCall[2].queue !== queueName) && !(options === undefined && activeCall[2].queue === false)) {
									return true;
								}

								/* Skip any calls that have never been paused */
								if (!activeCall[5]) {
									return true;
								}

								/* Iterate through the calls targeted by the stop command. */
								$.each(elements, function(l, element) {
									/* Check that this call was applied to the target element. */
									if (element === activeElement) {

										/* Flag a pause object to be resumed, which will occur during the next tick. In
										 addition, the pause object will at that time be deleted */
										activeCall[5].resume = true;

										/* Once we match an element, we can bounce out to the next call entirely */
										found = true;
										return false;
									}
								});

								/* Proceed to check next call if we have already matched */
								if (found) {
									return false;
								}
							});
						}

					});

					/* Since resume creates no new tweens, exit out of Velocity. */
					return getChain();

				case "finish":
				case "finishAll":
				case "stop":
					/*******************
					 Action: Stop
					 *******************/

					/* Clear the currently-active delay on each targeted element. */
					$.each(elements, function(i, element) {
						if (Data(element) && Data(element).delayTimer) {
							/* Stop the timer from triggering its cached next() function. */
							clearTimeout(Data(element).delayTimer.setTimeout);

							/* Manually call the next() function so that the subsequent queue items can progress. */
							if (Data(element).delayTimer.next) {
								Data(element).delayTimer.next();
							}

							delete Data(element).delayTimer;
						}

						/* If we want to finish everything in the queue, we have to iterate through it
						 and call each function. This will make them active calls below, which will
						 cause them to be applied via the duration setting. */
						if (propertiesMap === "finishAll" && (options === true || Type.isString(options))) {
							/* Iterate through the items in the element's queue. */
							$.each($.queue(element, Type.isString(options) ? options : ""), function(_, item) {
								/* The queue array can contain an "inprogress" string, which we skip. */
								if (Type.isFunction(item)) {
									item();
								}
							});

							/* Clearing the $.queue() array is achieved by resetting it to []. */
							$.queue(element, Type.isString(options) ? options : "", []);
						}
					});

					var callsToStop = [];

					/* When the stop action is triggered, the elements' currently active call is immediately stopped. The active call might have
					 been applied to multiple elements, in which case all of the call's elements will be stopped. When an element
					 is stopped, the next item in its animation queue is immediately triggered. */
					/* An additional argument may be passed in to clear an element's remaining queued calls. Either true (which defaults to the "fx" queue)
					 or a custom queue string can be passed in. */
					/* Note: The stop command runs prior to Velocity's Queueing phase since its behavior is intended to take effect *immediately*,
					 regardless of the element's current queue state. */

					/* Iterate through every active call. */
					$.each(Velocity.State.calls, function(i, activeCall) {
						/* Inactive calls are set to false by the logic inside completeCall(). Skip them. */
						if (activeCall) {
							/* Iterate through the active call's targeted elements. */
							$.each(activeCall[1], function(k, activeElement) {
								/* If true was passed in as a secondary argument, clear absolutely all calls on this element. Otherwise, only
								 clear calls associated with the relevant queue. */
								/* Call stopping logic works as follows:
								 - options === true --> stop current default queue calls (and queue:false calls), including remaining queued ones.
								 - options === undefined --> stop current queue:"" call and all queue:false calls.
								 - options === false --> stop only queue:false calls.
								 - options === "custom" --> stop current queue:"custom" call, including remaining queued ones (there is no functionality to only clear the currently-running queue:"custom" call). */
								var queueName = (options === undefined) ? "" : options;

								if (queueName !== true && (activeCall[2].queue !== queueName) && !(options === undefined && activeCall[2].queue === false)) {
									return true;
								}

								/* Iterate through the calls targeted by the stop command. */
								$.each(elements, function(l, element) {
									/* Check that this call was applied to the target element. */
									if (element === activeElement) {
										/* Optionally clear the remaining queued calls. If we're doing "finishAll" this won't find anything,
										 due to the queue-clearing above. */
										if (options === true || Type.isString(options)) {
											/* Iterate through the items in the element's queue. */
											$.each($.queue(element, Type.isString(options) ? options : ""), function(_, item) {
												/* The queue array can contain an "inprogress" string, which we skip. */
												if (Type.isFunction(item)) {
													/* Pass the item's callback a flag indicating that we want to abort from the queue call.
													 (Specifically, the queue will resolve the call's associated promise then abort.)  */
													item(null, true);
												}
											});

											/* Clearing the $.queue() array is achieved by resetting it to []. */
											$.queue(element, Type.isString(options) ? options : "", []);
										}

										if (propertiesMap === "stop") {
											/* Since "reverse" uses cached start values (the previous call's endValues), these values must be
											 changed to reflect the final value that the elements were actually tweened to. */
											/* Note: If only queue:false animations are currently running on an element, it won't have a tweensContainer
											 object. Also, queue:false animations can't be reversed. */
											var data = Data(element);
											if (data && data.tweensContainer && queueName !== false) {
												$.each(data.tweensContainer, function(m, activeTween) {
													activeTween.endValue = activeTween.currentValue;
												});
											}

											callsToStop.push(i);
										} else if (propertiesMap === "finish" || propertiesMap === "finishAll") {
											/* To get active tweens to finish immediately, we forcefully shorten their durations to 1ms so that
											 they finish upon the next rAf tick then proceed with normal call completion logic. */
											activeCall[2].duration = 1;
										}
									}
								});
							});
						}
					});

					/* Prematurely call completeCall() on each matched active call. Pass an additional flag for "stop" to indicate
					 that the complete callback and display:none setting should be skipped since we're completing prematurely. */
					if (propertiesMap === "stop") {
						$.each(callsToStop, function(i, j) {
							completeCall(j, true);
						});

						if (promiseData.promise) {
							/* Immediately resolve the promise associated with this stop call since stop runs synchronously. */
							promiseData.resolver(elements);
						}
					}

					/* Since we're stopping, and not proceeding with queueing, exit out of Velocity. */
					return getChain();

				default:
					/* Treat a non-empty plain object as a literal properties map. */
					if ($.isPlainObject(propertiesMap) && !Type.isEmptyObject(propertiesMap)) {
						action = "start";

						/****************
						 Redirects
						 ****************/

						/* Check if a string matches a registered redirect (see Redirects above). */
					} else if (Type.isString(propertiesMap) && Velocity.Redirects[propertiesMap]) {
						opts = $.extend({}, options);

						var durationOriginal = opts.duration,
								delayOriginal = opts.delay || 0;

						/* If the backwards option was passed in, reverse the element set so that elements animate from the last to the first. */
						if (opts.backwards === true) {
							elements = $.extend(true, [], elements).reverse();
						}

						/* Individually trigger the redirect for each element in the set to prevent users from having to handle iteration logic in their redirect. */
						$.each(elements, function(elementIndex, element) {
							/* If the stagger option was passed in, successively delay each element by the stagger value (in ms). Retain the original delay value. */
							if (parseFloat(opts.stagger)) {
								opts.delay = delayOriginal + (parseFloat(opts.stagger) * elementIndex);
							} else if (Type.isFunction(opts.stagger)) {
								opts.delay = delayOriginal + opts.stagger.call(element, elementIndex, elementsLength);
							}

							/* If the drag option was passed in, successively increase/decrease (depending on the presense of opts.backwards)
							 the duration of each element's animation, using floors to prevent producing very short durations. */
							if (opts.drag) {
								/* Default the duration of UI pack effects (callouts and transitions) to 1000ms instead of the usual default duration of 400ms. */
								opts.duration = parseFloat(durationOriginal) || (/^(callout|transition)/.test(propertiesMap) ? 1000 : DURATION_DEFAULT);

								/* For each element, take the greater duration of: A) animation completion percentage relative to the original duration,
								 B) 75% of the original duration, or C) a 200ms fallback (in case duration is already set to a low value).
								 The end result is a baseline of 75% of the redirect's duration that increases/decreases as the end of the element set is approached. */
								opts.duration = Math.max(opts.duration * (opts.backwards ? 1 - elementIndex / elementsLength : (elementIndex + 1) / elementsLength), opts.duration * 0.75, 200);
							}

							/* Pass in the call's opts object so that the redirect can optionally extend it. It defaults to an empty object instead of null to
							 reduce the opts checking logic required inside the redirect. */
							Velocity.Redirects[propertiesMap].call(element, element, opts || {}, elementIndex, elementsLength, elements, promiseData.promise ? promiseData : undefined);
						});

						/* Since the animation logic resides within the redirect's own code, abort the remainder of this call.
						 (The performance overhead up to this point is virtually non-existant.) */
						/* Note: The jQuery call chain is kept intact by returning the complete element set. */
						return getChain();
					} else {
						var abortError = "Velocity: First argument (" + propertiesMap + ") was not a property map, a known action, or a registered redirect. Aborting.";

						if (promiseData.promise) {
							promiseData.rejecter(new Error(abortError));
						} else if (window.console) {
							console.log(abortError);
						}

						return getChain();
					}
			}

			/**************************
			 Call-Wide Variables
			 **************************/

			/* A container for CSS unit conversion ratios (e.g. %, rem, and em ==> px) that is used to cache ratios across all elements
			 being animated in a single Velocity call. Calculating unit ratios necessitates DOM querying and updating, and is therefore
			 avoided (via caching) wherever possible. This container is call-wide instead of page-wide to avoid the risk of using stale
			 conversion metrics across Velocity animations that are not immediately consecutively chained. */
			var callUnitConversionData = {
				lastParent: null,
				lastPosition: null,
				lastFontSize: null,
				lastPercentToPxWidth: null,
				lastPercentToPxHeight: null,
				lastEmToPx: null,
				remToPx: null,
				vwToPx: null,
				vhToPx: null
			};

			/* A container for all the ensuing tween data and metadata associated with this call. This container gets pushed to the page-wide
			 Velocity.State.calls array that is processed during animation ticking. */
			var call = [];

			/************************
			 Element Processing
			 ************************/

			/* Element processing consists of three parts -- data processing that cannot go stale and data processing that *can* go stale (i.e. third-party style modifications):
			 1) Pre-Queueing: Element-wide variables, including the element's data storage, are instantiated. Call options are prepared. If triggered, the Stop action is executed.
			 2) Queueing: The logic that runs once this call has reached its point of execution in the element's $.queue() stack. Most logic is placed here to avoid risking it becoming stale.
			 3) Pushing: Consolidation of the tween data followed by its push onto the global in-progress calls container.
			 `elementArrayIndex` allows passing index of the element in the original array to value functions.
			 If `elementsIndex` were used instead the index would be determined by the elements' per-element queue.
			 */
			function processElement(element, elementArrayIndex) {

				/*************************
				 Part I: Pre-Queueing
				 *************************/

				/***************************
				 Element-Wide Variables
				 ***************************/

				var /* The runtime opts object is the extension of the current call's options and Velocity's page-wide option defaults. */
						opts = $.extend({}, Velocity.defaults, options),
						/* A container for the processed data associated with each property in the propertyMap.
						 (Each property in the map produces its own "tween".) */
						tweensContainer = {},
						elementUnitConversionData;

				/******************
				 Element Init
				 ******************/

				if (Data(element) === undefined) {
					Velocity.init(element);
				}

				/******************
				 Option: Delay
				 ******************/

				/* Since queue:false doesn't respect the item's existing queue, we avoid injecting its delay here (it's set later on). */
				/* Note: Velocity rolls its own delay function since jQuery doesn't have a utility alias for $.fn.delay()
				 (and thus requires jQuery element creation, which we avoid since its overhead includes DOM querying). */
				if (parseFloat(opts.delay) && opts.queue !== false) {
					$.queue(element, opts.queue, function(next, clearQueue) {
						if (clearQueue === true) {
							/* Do not continue with animation queueing. */
							return true;
						}

						/* This is a flag used to indicate to the upcoming completeCall() function that this queue entry was initiated by Velocity. See completeCall() for further details. */
						Velocity.velocityQueueEntryFlag = true;

						/* The ensuing queue item (which is assigned to the "next" argument that $.queue() automatically passes in) will be triggered after a setTimeout delay.
						 The setTimeout is stored so that it can be subjected to clearTimeout() if this animation is prematurely stopped via Velocity's "stop" command, and
						 delayBegin/delayTime is used to ensure we can "pause" and "resume" a tween that is still mid-delay. */

						/* Temporarily store delayed elements to facilite access for global pause/resume */
						var callIndex = Velocity.State.delayedElements.count++;
						Velocity.State.delayedElements[callIndex] = element;

						var delayComplete = (function(index) {
							return function() {
								/* Clear the temporary element */
								Velocity.State.delayedElements[index] = false;

								/* Finally, issue the call */
								next();
							};
						})(callIndex);


						Data(element).delayBegin = (new Date()).getTime();
						Data(element).delay = parseFloat(opts.delay);
						Data(element).delayTimer = {
							setTimeout: setTimeout(next, parseFloat(opts.delay)),
							next: delayComplete
						};
					});
				}

				/*********************
				 Option: Duration
				 *********************/

				/* Support for jQuery's named durations. */
				switch (opts.duration.toString().toLowerCase()) {
					case "fast":
						opts.duration = 200;
						break;

					case "normal":
						opts.duration = DURATION_DEFAULT;
						break;

					case "slow":
						opts.duration = 600;
						break;

					default:
						/* Remove the potential "ms" suffix and default to 1 if the user is attempting to set a duration of 0 (in order to produce an immediate style change). */
						opts.duration = parseFloat(opts.duration) || 1;
				}

				/************************
				 Global Option: Mock
				 ************************/

				if (Velocity.mock !== false) {
					/* In mock mode, all animations are forced to 1ms so that they occur immediately upon the next rAF tick.
					 Alternatively, a multiplier can be passed in to time remap all delays and durations. */
					if (Velocity.mock === true) {
						opts.duration = opts.delay = 1;
					} else {
						opts.duration *= parseFloat(Velocity.mock) || 1;
						opts.delay *= parseFloat(Velocity.mock) || 1;
					}
				}

				/*******************
				 Option: Easing
				 *******************/

				opts.easing = getEasing(opts.easing, opts.duration);

				/**********************
				 Option: Callbacks
				 **********************/

				/* Callbacks must functions. Otherwise, default to null. */
				if (opts.begin && !Type.isFunction(opts.begin)) {
					opts.begin = null;
				}

				if (opts.progress && !Type.isFunction(opts.progress)) {
					opts.progress = null;
				}

				if (opts.complete && !Type.isFunction(opts.complete)) {
					opts.complete = null;
				}

				/*********************************
				 Option: Display & Visibility
				 *********************************/

				/* Refer to Velocity's documentation (VelocityJS.org/#displayAndVisibility) for a description of the display and visibility options' behavior. */
				/* Note: We strictly check for undefined instead of falsiness because display accepts an empty string value. */
				if (opts.display !== undefined && opts.display !== null) {
					opts.display = opts.display.toString().toLowerCase();

					/* Users can pass in a special "auto" value to instruct Velocity to set the element to its default display value. */
					if (opts.display === "auto") {
						opts.display = Velocity.CSS.Values.getDisplayType(element);
					}
				}

				if (opts.visibility !== undefined && opts.visibility !== null) {
					opts.visibility = opts.visibility.toString().toLowerCase();
				}

				/**********************
				 Option: mobileHA
				 **********************/

				/* When set to true, and if this is a mobile device, mobileHA automatically enables hardware acceleration (via a null transform hack)
				 on animating elements. HA is removed from the element at the completion of its animation. */
				/* Note: Android Gingerbread doesn't support HA. If a null transform hack (mobileHA) is in fact set, it will prevent other tranform subproperties from taking effect. */
				/* Note: You can read more about the use of mobileHA in Velocity's documentation: VelocityJS.org/#mobileHA. */
				opts.mobileHA = (opts.mobileHA && Velocity.State.isMobile && !Velocity.State.isGingerbread);

				/***********************
				 Part II: Queueing
				 ***********************/

				/* When a set of elements is targeted by a Velocity call, the set is broken up and each element has the current Velocity call individually queued onto it.
				 In this way, each element's existing queue is respected; some elements may already be animating and accordingly should not have this current Velocity call triggered immediately. */
				/* In each queue, tween data is processed for each animating property then pushed onto the call-wide calls array. When the last element in the set has had its tweens processed,
				 the call array is pushed to Velocity.State.calls for live processing by the requestAnimationFrame tick. */
				function buildQueue(next) {
					var data, lastTweensContainer;

					/*******************
					 Option: Begin
					 *******************/

					/* The begin callback is fired once per call -- not once per elemenet -- and is passed the full raw DOM element set as both its context and its first argument. */
					if (opts.begin && elementsIndex === 0) {
						/* We throw callbacks in a setTimeout so that thrown errors don't halt the execution of Velocity itself. */
						try {
							opts.begin.call(elements, elements);
						} catch (error) {
							setTimeout(function() {
								throw error;
							}, 1);
						}
					}

					/*****************************************
					 Tween Data Construction (for Scroll)
					 *****************************************/

					/* Note: In order to be subjected to chaining and animation options, scroll's tweening is routed through Velocity as if it were a standard CSS property animation. */
					if (action === "scroll") {
						/* The scroll action uniquely takes an optional "offset" option -- specified in pixels -- that offsets the targeted scroll position. */
						var scrollDirection = (/^x$/i.test(opts.axis) ? "Left" : "Top"),
								scrollOffset = parseFloat(opts.offset) || 0,
								scrollPositionCurrent,
								scrollPositionCurrentAlternate,
								scrollPositionEnd;

						/* Scroll also uniquely takes an optional "container" option, which indicates the parent element that should be scrolled --
						 as opposed to the browser window itself. This is useful for scrolling toward an element that's inside an overflowing parent element. */
						if (opts.container) {
							/* Ensure that either a jQuery object or a raw DOM element was passed in. */
							if (Type.isWrapped(opts.container) || Type.isNode(opts.container)) {
								/* Extract the raw DOM element from the jQuery wrapper. */
								opts.container = opts.container[0] || opts.container;
								/* Note: Unlike other properties in Velocity, the browser's scroll position is never cached since it so frequently changes
								 (due to the user's natural interaction with the page). */
								scrollPositionCurrent = opts.container["scroll" + scrollDirection]; /* GET */

								/* $.position() values are relative to the container's currently viewable area (without taking into account the container's true dimensions
								 -- say, for example, if the container was not overflowing). Thus, the scroll end value is the sum of the child element's position *and*
								 the scroll container's current scroll position. */
								scrollPositionEnd = (scrollPositionCurrent + $(element).position()[scrollDirection.toLowerCase()]) + scrollOffset; /* GET */
								/* If a value other than a jQuery object or a raw DOM element was passed in, default to null so that this option is ignored. */
							} else {
								opts.container = null;
							}
						} else {
							/* If the window itself is being scrolled -- not a containing element -- perform a live scroll position lookup using
							 the appropriate cached property names (which differ based on browser type). */
							scrollPositionCurrent = Velocity.State.scrollAnchor[Velocity.State["scrollProperty" + scrollDirection]]; /* GET */
							/* When scrolling the browser window, cache the alternate axis's current value since window.scrollTo() doesn't let us change only one value at a time. */
							scrollPositionCurrentAlternate = Velocity.State.scrollAnchor[Velocity.State["scrollProperty" + (scrollDirection === "Left" ? "Top" : "Left")]]; /* GET */

							/* Unlike $.position(), $.offset() values are relative to the browser window's true dimensions -- not merely its currently viewable area --
							 and therefore end values do not need to be compounded onto current values. */
							scrollPositionEnd = $(element).offset()[scrollDirection.toLowerCase()] + scrollOffset; /* GET */
						}

						/* Since there's only one format that scroll's associated tweensContainer can take, we create it manually. */
						tweensContainer = {
							scroll: {
								rootPropertyValue: false,
								startValue: scrollPositionCurrent,
								currentValue: scrollPositionCurrent,
								endValue: scrollPositionEnd,
								unitType: "",
								easing: opts.easing,
								scrollData: {
									container: opts.container,
									direction: scrollDirection,
									alternateValue: scrollPositionCurrentAlternate
								}
							},
							element: element
						};

						if (Velocity.debug) {
							console.log("tweensContainer (scroll): ", tweensContainer.scroll, element);
						}

						/******************************************
						 Tween Data Construction (for Reverse)
						 ******************************************/

						/* Reverse acts like a "start" action in that a property map is animated toward. The only difference is
						 that the property map used for reverse is the inverse of the map used in the previous call. Thus, we manipulate
						 the previous call to construct our new map: use the previous map's end values as our new map's start values. Copy over all other data. */
						/* Note: Reverse can be directly called via the "reverse" parameter, or it can be indirectly triggered via the loop option. (Loops are composed of multiple reverses.) */
						/* Note: Reverse calls do not need to be consecutively chained onto a currently-animating element in order to operate on cached values;
						 there is no harm to reverse being called on a potentially stale data cache since reverse's behavior is simply defined
						 as reverting to the element's values as they were prior to the previous *Velocity* call. */
					} else if (action === "reverse") {
						data = Data(element);

						/* Abort if there is no prior animation data to reverse to. */
						if (!data) {
							return;
						}

						if (!data.tweensContainer) {
							/* Dequeue the element so that this queue entry releases itself immediately, allowing subsequent queue entries to run. */
							$.dequeue(element, opts.queue);

							return;
						} else {
							/*********************
							 Options Parsing
							 *********************/

							/* If the element was hidden via the display option in the previous call,
							 revert display to "auto" prior to reversal so that the element is visible again. */
							if (data.opts.display === "none") {
								data.opts.display = "auto";
							}

							if (data.opts.visibility === "hidden") {
								data.opts.visibility = "visible";
							}

							/* If the loop option was set in the previous call, disable it so that "reverse" calls aren't recursively generated.
							 Further, remove the previous call's callback options; typically, users do not want these to be refired. */
							data.opts.loop = false;
							data.opts.begin = null;
							data.opts.complete = null;

							/* Since we're extending an opts object that has already been extended with the defaults options object,
							 we remove non-explicitly-defined properties that are auto-assigned values. */
							if (!options.easing) {
								delete opts.easing;
							}

							if (!options.duration) {
								delete opts.duration;
							}

							/* The opts object used for reversal is an extension of the options object optionally passed into this
							 reverse call plus the options used in the previous Velocity call. */
							opts = $.extend({}, data.opts, opts);

							/*************************************
							 Tweens Container Reconstruction
							 *************************************/

							/* Create a deepy copy (indicated via the true flag) of the previous call's tweensContainer. */
							lastTweensContainer = $.extend(true, {}, data ? data.tweensContainer : null);

							/* Manipulate the previous tweensContainer by replacing its end values and currentValues with its start values. */
							for (var lastTween in lastTweensContainer) {
								/* In addition to tween data, tweensContainers contain an element property that we ignore here. */
								if (lastTweensContainer.hasOwnProperty(lastTween) && lastTween !== "element") {
									var lastStartValue = lastTweensContainer[lastTween].startValue;

									lastTweensContainer[lastTween].startValue = lastTweensContainer[lastTween].currentValue = lastTweensContainer[lastTween].endValue;
									lastTweensContainer[lastTween].endValue = lastStartValue;

									/* Easing is the only option that embeds into the individual tween data (since it can be defined on a per-property basis).
									 Accordingly, every property's easing value must be updated when an options object is passed in with a reverse call.
									 The side effect of this extensibility is that all per-property easing values are forcefully reset to the new value. */
									if (!Type.isEmptyObject(options)) {
										lastTweensContainer[lastTween].easing = opts.easing;
									}

									if (Velocity.debug) {
										console.log("reverse tweensContainer (" + lastTween + "): " + JSON.stringify(lastTweensContainer[lastTween]), element);
									}
								}
							}

							tweensContainer = lastTweensContainer;
						}

						/*****************************************
						 Tween Data Construction (for Start)
						 *****************************************/

					} else if (action === "start") {

						/*************************
						 Value Transferring
						 *************************/

						/* If this queue entry follows a previous Velocity-initiated queue entry *and* if this entry was created
						 while the element was in the process of being animated by Velocity, then this current call is safe to use
						 the end values from the prior call as its start values. Velocity attempts to perform this value transfer
						 process whenever possible in order to avoid requerying the DOM. */
						/* If values aren't transferred from a prior call and start values were not forcefed by the user (more on this below),
						 then the DOM is queried for the element's current values as a last resort. */
						/* Note: Conversely, animation reversal (and looping) *always* perform inter-call value transfers; they never requery the DOM. */

						data = Data(element);

						/* The per-element isAnimating flag is used to indicate whether it's safe (i.e. the data isn't stale)
						 to transfer over end values to use as start values. If it's set to true and there is a previous
						 Velocity call to pull values from, do so. */
						if (data && data.tweensContainer && data.isAnimating === true) {
							lastTweensContainer = data.tweensContainer;
						}

						/***************************
						 Tween Data Calculation
						 ***************************/

						/* This function parses property data and defaults endValue, easing, and startValue as appropriate. */
						/* Property map values can either take the form of 1) a single value representing the end value,
						 or 2) an array in the form of [ endValue, [, easing] [, startValue] ].
						 The optional third parameter is a forcefed startValue to be used instead of querying the DOM for
						 the element's current value. Read Velocity's docmentation to learn more about forcefeeding: VelocityJS.org/#forcefeeding */
						var parsePropertyValue = function(valueData, skipResolvingEasing) {
							var endValue, easing, startValue;

							/* If we have a function as the main argument then resolve it first, in case it returns an array that needs to be split */
							if (Type.isFunction(valueData)) {
								valueData = valueData.call(element, elementArrayIndex, elementsLength);
							}

							/* Handle the array format, which can be structured as one of three potential overloads:
							 A) [ endValue, easing, startValue ], B) [ endValue, easing ], or C) [ endValue, startValue ] */
							if (Type.isArray(valueData)) {
								/* endValue is always the first item in the array. Don't bother validating endValue's value now
								 since the ensuing property cycling logic does that. */
								endValue = valueData[0];

								/* Two-item array format: If the second item is a number, function, or hex string, treat it as a
								 start value since easings can only be non-hex strings or arrays. */
								if ((!Type.isArray(valueData[1]) && /^[\d-]/.test(valueData[1])) || Type.isFunction(valueData[1]) || CSS.RegEx.isHex.test(valueData[1])) {
									startValue = valueData[1];
									/* Two or three-item array: If the second item is a non-hex string easing name or an array, treat it as an easing. */
								} else if ((Type.isString(valueData[1]) && !CSS.RegEx.isHex.test(valueData[1]) && Velocity.Easings[valueData[1]]) || Type.isArray(valueData[1])) {
									easing = skipResolvingEasing ? valueData[1] : getEasing(valueData[1], opts.duration);

									/* Don't bother validating startValue's value now since the ensuing property cycling logic inherently does that. */
									startValue = valueData[2];
								} else {
									startValue = valueData[1] || valueData[2];
								}
								/* Handle the single-value format. */
							} else {
								endValue = valueData;
							}

							/* Default to the call's easing if a per-property easing type was not defined. */
							if (!skipResolvingEasing) {
								easing = easing || opts.easing;
							}

							/* If functions were passed in as values, pass the function the current element as its context,
							 plus the element's index and the element set's size as arguments. Then, assign the returned value. */
							if (Type.isFunction(endValue)) {
								endValue = endValue.call(element, elementArrayIndex, elementsLength);
							}

							if (Type.isFunction(startValue)) {
								startValue = startValue.call(element, elementArrayIndex, elementsLength);
							}

							/* Allow startValue to be left as undefined to indicate to the ensuing code that its value was not forcefed. */
							return [endValue || 0, easing, startValue];
						};

						var fixPropertyValue = function(property, valueData) {
							/* In case this property is a hook, there are circumstances where we will intend to work on the hook's root property and not the hooked subproperty. */
							var rootProperty = CSS.Hooks.getRoot(property),
									rootPropertyValue = false,
									/* Parse out endValue, easing, and startValue from the property's data. */
									endValue = valueData[0],
									easing = valueData[1],
									startValue = valueData[2],
									pattern;

							/**************************
							 Start Value Sourcing
							 **************************/

							/* Other than for the dummy tween property, properties that are not supported by the browser (and do not have an associated normalization) will
							 inherently produce no style changes when set, so they are skipped in order to decrease animation tick overhead.
							 Property support is determined via prefixCheck(), which returns a false flag when no supported is detected. */
							/* Note: Since SVG elements have some of their properties directly applied as HTML attributes,
							 there is no way to check for their explicit browser support, and so we skip skip this check for them. */
							if ((!data || !data.isSVG) && rootProperty !== "tween" && CSS.Names.prefixCheck(rootProperty)[1] === false && CSS.Normalizations.registered[rootProperty] === undefined) {
								if (Velocity.debug) {
									console.log("Skipping [" + rootProperty + "] due to a lack of browser support.");
								}
								return;
							}

							/* If the display option is being set to a non-"none" (e.g. "block") and opacity (filter on IE<=8) is being
							 animated to an endValue of non-zero, the user's intention is to fade in from invisible, thus we forcefeed opacity
							 a startValue of 0 if its startValue hasn't already been sourced by value transferring or prior forcefeeding. */
							if (((opts.display !== undefined && opts.display !== null && opts.display !== "none") || (opts.visibility !== undefined && opts.visibility !== "hidden")) && /opacity|filter/.test(property) && !startValue && endValue !== 0) {
								startValue = 0;
							}

							/* If values have been transferred from the previous Velocity call, extract the endValue and rootPropertyValue
							 for all of the current call's properties that were *also* animated in the previous call. */
							/* Note: Value transferring can optionally be disabled by the user via the _cacheValues option. */
							if (opts._cacheValues && lastTweensContainer && lastTweensContainer[property]) {
								if (startValue === undefined) {
									startValue = lastTweensContainer[property].endValue + lastTweensContainer[property].unitType;
								}

								/* The previous call's rootPropertyValue is extracted from the element's data cache since that's the
								 instance of rootPropertyValue that gets freshly updated by the tweening process, whereas the rootPropertyValue
								 attached to the incoming lastTweensContainer is equal to the root property's value prior to any tweening. */
								rootPropertyValue = data.rootPropertyValueCache[rootProperty];
								/* If values were not transferred from a previous Velocity call, query the DOM as needed. */
							} else {
								/* Handle hooked properties. */
								if (CSS.Hooks.registered[property]) {
									if (startValue === undefined) {
										rootPropertyValue = CSS.getPropertyValue(element, rootProperty); /* GET */
										/* Note: The following getPropertyValue() call does not actually trigger a DOM query;
										 getPropertyValue() will extract the hook from rootPropertyValue. */
										startValue = CSS.getPropertyValue(element, property, rootPropertyValue);
										/* If startValue is already defined via forcefeeding, do not query the DOM for the root property's value;
										 just grab rootProperty's zero-value template from CSS.Hooks. This overwrites the element's actual
										 root property value (if one is set), but this is acceptable since the primary reason users forcefeed is
										 to avoid DOM queries, and thus we likewise avoid querying the DOM for the root property's value. */
									} else {
										/* Grab this hook's zero-value template, e.g. "0px 0px 0px black". */
										rootPropertyValue = CSS.Hooks.templates[rootProperty][1];
									}
									/* Handle non-hooked properties that haven't already been defined via forcefeeding. */
								} else if (startValue === undefined) {
									startValue = CSS.getPropertyValue(element, property); /* GET */
								}
							}

							/**************************
							 Value Data Extraction
							 **************************/

							var separatedValue,
									endValueUnitType,
									startValueUnitType,
									operator = false;

							/* Separates a property value into its numeric value and its unit type. */
							var separateValue = function(property, value) {
								var unitType,
										numericValue;

								numericValue = (value || "0")
										.toString()
										.toLowerCase()
										/* Match the unit type at the end of the value. */
										.replace(/[%A-z]+$/, function(match) {
											/* Grab the unit type. */
											unitType = match;

											/* Strip the unit type off of value. */
											return "";
										});

								/* If no unit type was supplied, assign one that is appropriate for this property (e.g. "deg" for rotateZ or "px" for width). */
								if (!unitType) {
									unitType = CSS.Values.getUnitType(property);
								}

								return [numericValue, unitType];
							};

							if (startValue !== endValue && Type.isString(startValue) && Type.isString(endValue)) {
								pattern = "";
								var iStart = 0, // index in startValue
										iEnd = 0, // index in endValue
										aStart = [], // array of startValue numbers
										aEnd = [], // array of endValue numbers
										inCalc = 0, // Keep track of being inside a "calc()" so we don't duplicate it
										inRGB = 0, // Keep track of being inside an RGB as we can't use fractional values
										inRGBA = 0; // Keep track of being inside an RGBA as we must pass fractional for the alpha channel

								startValue = CSS.Hooks.fixColors(startValue);
								endValue = CSS.Hooks.fixColors(endValue);
								while (iStart < startValue.length && iEnd < endValue.length) {
									var cStart = startValue[iStart],
											cEnd = endValue[iEnd];

									if (/[\d\.-]/.test(cStart) && /[\d\.-]/.test(cEnd)) {
										var tStart = cStart, // temporary character buffer
												tEnd = cEnd, // temporary character buffer
												dotStart = ".", // Make sure we can only ever match a single dot in a decimal
												dotEnd = "."; // Make sure we can only ever match a single dot in a decimal

										while (++iStart < startValue.length) {
											cStart = startValue[iStart];
											if (cStart === dotStart) {
												dotStart = ".."; // Can never match two characters
											} else if (!/\d/.test(cStart)) {
												break;
											}
											tStart += cStart;
										}
										while (++iEnd < endValue.length) {
											cEnd = endValue[iEnd];
											if (cEnd === dotEnd) {
												dotEnd = ".."; // Can never match two characters
											} else if (!/\d/.test(cEnd)) {
												break;
											}
											tEnd += cEnd;
										}
										var uStart = CSS.Hooks.getUnit(startValue, iStart), // temporary unit type
												uEnd = CSS.Hooks.getUnit(endValue, iEnd); // temporary unit type

										iStart += uStart.length;
										iEnd += uEnd.length;
										if (uStart === uEnd) {
											// Same units
											if (tStart === tEnd) {
												// Same numbers, so just copy over
												pattern += tStart + uStart;
											} else {
												// Different numbers, so store them
												pattern += "{" + aStart.length + (inRGB ? "!" : "") + "}" + uStart;
												aStart.push(parseFloat(tStart));
												aEnd.push(parseFloat(tEnd));
											}
										} else {
											// Different units, so put into a "calc(from + to)" and animate each side to/from zero
											var nStart = parseFloat(tStart),
													nEnd = parseFloat(tEnd);

											pattern += (inCalc < 5 ? "calc" : "") + "("
													+ (nStart ? "{" + aStart.length + (inRGB ? "!" : "") + "}" : "0") + uStart
													+ " + "
													+ (nEnd ? "{" + (aStart.length + (nStart ? 1 : 0)) + (inRGB ? "!" : "") + "}" : "0") + uEnd
													+ ")";
											if (nStart) {
												aStart.push(nStart);
												aEnd.push(0);
											}
											if (nEnd) {
												aStart.push(0);
												aEnd.push(nEnd);
											}
										}
									} else if (cStart === cEnd) {
										pattern += cStart;
										iStart++;
										iEnd++;
										// Keep track of being inside a calc()
										if (inCalc === 0 && cStart === "c"
												|| inCalc === 1 && cStart === "a"
												|| inCalc === 2 && cStart === "l"
												|| inCalc === 3 && cStart === "c"
												|| inCalc >= 4 && cStart === "("
												) {
											inCalc++;
										} else if ((inCalc && inCalc < 5)
												|| inCalc >= 4 && cStart === ")" && --inCalc < 5) {
											inCalc = 0;
										}
										// Keep track of being inside an rgb() / rgba()
										if (inRGB === 0 && cStart === "r"
												|| inRGB === 1 && cStart === "g"
												|| inRGB === 2 && cStart === "b"
												|| inRGB === 3 && cStart === "a"
												|| inRGB >= 3 && cStart === "("
												) {
											if (inRGB === 3 && cStart === "a") {
												inRGBA = 1;
											}
											inRGB++;
										} else if (inRGBA && cStart === ",") {
											if (++inRGBA > 3) {
												inRGB = inRGBA = 0;
											}
										} else if ((inRGBA && inRGB < (inRGBA ? 5 : 4))
												|| inRGB >= (inRGBA ? 4 : 3) && cStart === ")" && --inRGB < (inRGBA ? 5 : 4)) {
											inRGB = inRGBA = 0;
										}
									} else {
										inCalc = 0;
										// TODO: changing units, fixing colours
										break;
									}
								}
								if (iStart !== startValue.length || iEnd !== endValue.length) {
									if (Velocity.debug) {
										console.error("Trying to pattern match mis-matched strings [\"" + endValue + "\", \"" + startValue + "\"]");
									}
									pattern = undefined;
								}
								if (pattern) {
									if (aStart.length) {
										if (Velocity.debug) {
											console.log("Pattern found \"" + pattern + "\" -> ", aStart, aEnd, "[" + startValue + "," + endValue + "]");
										}
										startValue = aStart;
										endValue = aEnd;
										endValueUnitType = startValueUnitType = "";
									} else {
										pattern = undefined;
									}
								}
							}

							if (!pattern) {
								/* Separate startValue. */
								separatedValue = separateValue(property, startValue);
								startValue = separatedValue[0];
								startValueUnitType = separatedValue[1];

								/* Separate endValue, and extract a value operator (e.g. "+=", "-=") if one exists. */
								separatedValue = separateValue(property, endValue);
								endValue = separatedValue[0].replace(/^([+-\/*])=/, function(match, subMatch) {
									operator = subMatch;

									/* Strip the operator off of the value. */
									return "";
								});
								endValueUnitType = separatedValue[1];

								/* Parse float values from endValue and startValue. Default to 0 if NaN is returned. */
								startValue = parseFloat(startValue) || 0;
								endValue = parseFloat(endValue) || 0;

								/***************************************
								 Property-Specific Value Conversion
								 ***************************************/

								/* Custom support for properties that don't actually accept the % unit type, but where pollyfilling is trivial and relatively foolproof. */
								if (endValueUnitType === "%") {
									/* A %-value fontSize/lineHeight is relative to the parent's fontSize (as opposed to the parent's dimensions),
									 which is identical to the em unit's behavior, so we piggyback off of that. */
									if (/^(fontSize|lineHeight)$/.test(property)) {
										/* Convert % into an em decimal value. */
										endValue = endValue / 100;
										endValueUnitType = "em";
										/* For scaleX and scaleY, convert the value into its decimal format and strip off the unit type. */
									} else if (/^scale/.test(property)) {
										endValue = endValue / 100;
										endValueUnitType = "";
										/* For RGB components, take the defined percentage of 255 and strip off the unit type. */
									} else if (/(Red|Green|Blue)$/i.test(property)) {
										endValue = (endValue / 100) * 255;
										endValueUnitType = "";
									}
								}
							}

							/***************************
							 Unit Ratio Calculation
							 ***************************/

							/* When queried, the browser returns (most) CSS property values in pixels. Therefore, if an endValue with a unit type of
							 %, em, or rem is animated toward, startValue must be converted from pixels into the same unit type as endValue in order
							 for value manipulation logic (increment/decrement) to proceed. Further, if the startValue was forcefed or transferred
							 from a previous call, startValue may also not be in pixels. Unit conversion logic therefore consists of two steps:
							 1) Calculating the ratio of %/em/rem/vh/vw relative to pixels
							 2) Converting startValue into the same unit of measurement as endValue based on these ratios. */
							/* Unit conversion ratios are calculated by inserting a sibling node next to the target node, copying over its position property,
							 setting values with the target unit type then comparing the returned pixel value. */
							/* Note: Even if only one of these unit types is being animated, all unit ratios are calculated at once since the overhead
							 of batching the SETs and GETs together upfront outweights the potential overhead
							 of layout thrashing caused by re-querying for uncalculated ratios for subsequently-processed properties. */
							/* Todo: Shift this logic into the calls' first tick instance so that it's synced with RAF. */
							var calculateUnitRatios = function() {

								/************************
								 Same Ratio Checks
								 ************************/

								/* The properties below are used to determine whether the element differs sufficiently from this call's
								 previously iterated element to also differ in its unit conversion ratios. If the properties match up with those
								 of the prior element, the prior element's conversion ratios are used. Like most optimizations in Velocity,
								 this is done to minimize DOM querying. */
								var sameRatioIndicators = {
									myParent: element.parentNode || document.body, /* GET */
									position: CSS.getPropertyValue(element, "position"), /* GET */
									fontSize: CSS.getPropertyValue(element, "fontSize") /* GET */
								},
										/* Determine if the same % ratio can be used. % is based on the element's position value and its parent's width and height dimensions. */
										samePercentRatio = ((sameRatioIndicators.position === callUnitConversionData.lastPosition) && (sameRatioIndicators.myParent === callUnitConversionData.lastParent)),
										/* Determine if the same em ratio can be used. em is relative to the element's fontSize. */
										sameEmRatio = (sameRatioIndicators.fontSize === callUnitConversionData.lastFontSize);

								/* Store these ratio indicators call-wide for the next element to compare against. */
								callUnitConversionData.lastParent = sameRatioIndicators.myParent;
								callUnitConversionData.lastPosition = sameRatioIndicators.position;
								callUnitConversionData.lastFontSize = sameRatioIndicators.fontSize;

								/***************************
								 Element-Specific Units
								 ***************************/

								/* Note: IE8 rounds to the nearest pixel when returning CSS values, thus we perform conversions using a measurement
								 of 100 (instead of 1) to give our ratios a precision of at least 2 decimal values. */
								var measurement = 100,
										unitRatios = {};

								if (!sameEmRatio || !samePercentRatio) {
									var dummy = data && data.isSVG ? document.createElementNS("http://www.w3.org/2000/svg", "rect") : document.createElement("div");

									Velocity.init(dummy);
									sameRatioIndicators.myParent.appendChild(dummy);

									/* To accurately and consistently calculate conversion ratios, the element's cascaded overflow and box-sizing are stripped.
									 Similarly, since width/height can be artificially constrained by their min-/max- equivalents, these are controlled for as well. */
									/* Note: Overflow must be also be controlled for per-axis since the overflow property overwrites its per-axis values. */
									$.each(["overflow", "overflowX", "overflowY"], function(i, property) {
										Velocity.CSS.setPropertyValue(dummy, property, "hidden");
									});
									Velocity.CSS.setPropertyValue(dummy, "position", sameRatioIndicators.position);
									Velocity.CSS.setPropertyValue(dummy, "fontSize", sameRatioIndicators.fontSize);
									Velocity.CSS.setPropertyValue(dummy, "boxSizing", "content-box");

									/* width and height act as our proxy properties for measuring the horizontal and vertical % ratios. */
									$.each(["minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height"], function(i, property) {
										Velocity.CSS.setPropertyValue(dummy, property, measurement + "%");
									});
									/* paddingLeft arbitrarily acts as our proxy property for the em ratio. */
									Velocity.CSS.setPropertyValue(dummy, "paddingLeft", measurement + "em");

									/* Divide the returned value by the measurement to get the ratio between 1% and 1px. Default to 1 since working with 0 can produce Infinite. */
									unitRatios.percentToPxWidth = callUnitConversionData.lastPercentToPxWidth = (parseFloat(CSS.getPropertyValue(dummy, "width", null, true)) || 1) / measurement; /* GET */
									unitRatios.percentToPxHeight = callUnitConversionData.lastPercentToPxHeight = (parseFloat(CSS.getPropertyValue(dummy, "height", null, true)) || 1) / measurement; /* GET */
									unitRatios.emToPx = callUnitConversionData.lastEmToPx = (parseFloat(CSS.getPropertyValue(dummy, "paddingLeft")) || 1) / measurement; /* GET */

									sameRatioIndicators.myParent.removeChild(dummy);
								} else {
									unitRatios.emToPx = callUnitConversionData.lastEmToPx;
									unitRatios.percentToPxWidth = callUnitConversionData.lastPercentToPxWidth;
									unitRatios.percentToPxHeight = callUnitConversionData.lastPercentToPxHeight;
								}

								/***************************
								 Element-Agnostic Units
								 ***************************/

								/* Whereas % and em ratios are determined on a per-element basis, the rem unit only needs to be checked
								 once per call since it's exclusively dependant upon document.body's fontSize. If this is the first time
								 that calculateUnitRatios() is being run during this call, remToPx will still be set to its default value of null,
								 so we calculate it now. */
								if (callUnitConversionData.remToPx === null) {
									/* Default to browsers' default fontSize of 16px in the case of 0. */
									callUnitConversionData.remToPx = parseFloat(CSS.getPropertyValue(document.body, "fontSize")) || 16; /* GET */
								}

								/* Similarly, viewport units are %-relative to the window's inner dimensions. */
								if (callUnitConversionData.vwToPx === null) {
									callUnitConversionData.vwToPx = parseFloat(window.innerWidth) / 100; /* GET */
									callUnitConversionData.vhToPx = parseFloat(window.innerHeight) / 100; /* GET */
								}

								unitRatios.remToPx = callUnitConversionData.remToPx;
								unitRatios.vwToPx = callUnitConversionData.vwToPx;
								unitRatios.vhToPx = callUnitConversionData.vhToPx;

								if (Velocity.debug >= 1) {
									console.log("Unit ratios: " + JSON.stringify(unitRatios), element);
								}
								return unitRatios;
							};

							/********************
							 Unit Conversion
							 ********************/

							/* The * and / operators, which are not passed in with an associated unit, inherently use startValue's unit. Skip value and unit conversion. */
							if (/[\/*]/.test(operator)) {
								endValueUnitType = startValueUnitType;
								/* If startValue and endValue differ in unit type, convert startValue into the same unit type as endValue so that if endValueUnitType
								 is a relative unit (%, em, rem), the values set during tweening will continue to be accurately relative even if the metrics they depend
								 on are dynamically changing during the course of the animation. Conversely, if we always normalized into px and used px for setting values, the px ratio
								 would become stale if the original unit being animated toward was relative and the underlying metrics change during the animation. */
								/* Since 0 is 0 in any unit type, no conversion is necessary when startValue is 0 -- we just start at 0 with endValueUnitType. */
							} else if ((startValueUnitType !== endValueUnitType) && startValue !== 0) {
								/* Unit conversion is also skipped when endValue is 0, but *startValueUnitType* must be used for tween values to remain accurate. */
								/* Note: Skipping unit conversion here means that if endValueUnitType was originally a relative unit, the animation won't relatively
								 match the underlying metrics if they change, but this is acceptable since we're animating toward invisibility instead of toward visibility,
								 which remains past the point of the animation's completion. */
								if (endValue === 0) {
									endValueUnitType = startValueUnitType;
								} else {
									/* By this point, we cannot avoid unit conversion (it's undesirable since it causes layout thrashing).
									 If we haven't already, we trigger calculateUnitRatios(), which runs once per element per call. */
									elementUnitConversionData = elementUnitConversionData || calculateUnitRatios();

									/* The following RegEx matches CSS properties that have their % values measured relative to the x-axis. */
									/* Note: W3C spec mandates that all of margin and padding's properties (even top and bottom) are %-relative to the *width* of the parent element. */
									var axis = (/margin|padding|left|right|width|text|word|letter/i.test(property) || /X$/.test(property) || property === "x") ? "x" : "y";

									/* In order to avoid generating n^2 bespoke conversion functions, unit conversion is a two-step process:
									 1) Convert startValue into pixels. 2) Convert this new pixel value into endValue's unit type. */
									switch (startValueUnitType) {
										case "%":
											/* Note: translateX and translateY are the only properties that are %-relative to an element's own dimensions -- not its parent's dimensions.
											 Velocity does not include a special conversion process to account for this behavior. Therefore, animating translateX/Y from a % value
											 to a non-% value will produce an incorrect start value. Fortunately, this sort of cross-unit conversion is rarely done by users in practice. */
											startValue *= (axis === "x" ? elementUnitConversionData.percentToPxWidth : elementUnitConversionData.percentToPxHeight);
											break;

										case "px":
											/* px acts as our midpoint in the unit conversion process; do nothing. */
											break;

										default:
											startValue *= elementUnitConversionData[startValueUnitType + "ToPx"];
									}

									/* Invert the px ratios to convert into to the target unit. */
									switch (endValueUnitType) {
										case "%":
											startValue *= 1 / (axis === "x" ? elementUnitConversionData.percentToPxWidth : elementUnitConversionData.percentToPxHeight);
											break;

										case "px":
											/* startValue is already in px, do nothing; we're done. */
											break;

										default:
											startValue *= 1 / elementUnitConversionData[endValueUnitType + "ToPx"];
									}
								}
							}

							/*********************
							 Relative Values
							 *********************/

							/* Operator logic must be performed last since it requires unit-normalized start and end values. */
							/* Note: Relative *percent values* do not behave how most people think; while one would expect "+=50%"
							 to increase the property 1.5x its current value, it in fact increases the percent units in absolute terms:
							 50 points is added on top of the current % value. */
							switch (operator) {
								case "+":
									endValue = startValue + endValue;
									break;

								case "-":
									endValue = startValue - endValue;
									break;

								case "*":
									endValue = startValue * endValue;
									break;

								case "/":
									endValue = startValue / endValue;
									break;
							}

							/**************************
							 tweensContainer Push
							 **************************/

							/* Construct the per-property tween object, and push it to the element's tweensContainer. */
							tweensContainer[property] = {
								rootPropertyValue: rootPropertyValue,
								startValue: startValue,
								currentValue: startValue,
								endValue: endValue,
								unitType: endValueUnitType,
								easing: easing
							};
							if (pattern) {
								tweensContainer[property].pattern = pattern;
							}

							if (Velocity.debug) {
								console.log("tweensContainer (" + property + "): " + JSON.stringify(tweensContainer[property]), element);
							}
						};

						/* Create a tween out of each property, and append its associated data to tweensContainer. */
						for (var property in propertiesMap) {

							if (!propertiesMap.hasOwnProperty(property)) {
								continue;
							}
							/* The original property name's format must be used for the parsePropertyValue() lookup,
							 but we then use its camelCase styling to normalize it for manipulation. */
							var propertyName = CSS.Names.camelCase(property),
									valueData = parsePropertyValue(propertiesMap[property]);

							/* Find shorthand color properties that have been passed a hex string. */
							/* Would be quicker to use CSS.Lists.colors.includes() if possible */
							if (_inArray(CSS.Lists.colors, propertyName)) {
								/* Parse the value data for each shorthand. */
								var endValue = valueData[0],
										easing = valueData[1],
										startValue = valueData[2];

								if (CSS.RegEx.isHex.test(endValue)) {
									/* Convert the hex strings into their RGB component arrays. */
									var colorComponents = ["Red", "Green", "Blue"],
											endValueRGB = CSS.Values.hexToRgb(endValue),
											startValueRGB = startValue ? CSS.Values.hexToRgb(startValue) : undefined;

									/* Inject the RGB component tweens into propertiesMap. */
									for (var i = 0; i < colorComponents.length; i++) {
										var dataArray = [endValueRGB[i]];

										if (easing) {
											dataArray.push(easing);
										}

										if (startValueRGB !== undefined) {
											dataArray.push(startValueRGB[i]);
										}

										fixPropertyValue(propertyName + colorComponents[i], dataArray);
									}
									/* If we have replaced a shortcut color value then don't update the standard property name */
									continue;
								}
							}
							fixPropertyValue(propertyName, valueData);
						}

						/* Along with its property data, store a reference to the element itself onto tweensContainer. */
						tweensContainer.element = element;
					}

					/*****************
					 Call Push
					 *****************/

					/* Note: tweensContainer can be empty if all of the properties in this call's property map were skipped due to not
					 being supported by the browser. The element property is used for checking that the tweensContainer has been appended to. */
					if (tweensContainer.element) {
						/* Apply the "velocity-animating" indicator class. */
						CSS.Values.addClass(element, "velocity-animating");

						/* The call array houses the tweensContainers for each element being animated in the current call. */
						call.push(tweensContainer);

						data = Data(element);

						if (data) {
							/* Store the tweensContainer and options if we're working on the default effects queue, so that they can be used by the reverse command. */
							if (opts.queue === "") {

								data.tweensContainer = tweensContainer;
								data.opts = opts;
							}

							/* Switch on the element's animating flag. */
							data.isAnimating = true;
						}

						/* Once the final element in this call's element set has been processed, push the call array onto
						 Velocity.State.calls for the animation tick to immediately begin processing. */
						if (elementsIndex === elementsLength - 1) {
							/* Add the current call plus its associated metadata (the element set and the call's options) onto the global call container.
							 Anything on this call container is subjected to tick() processing. */
							Velocity.State.calls.push([call, elements, opts, null, promiseData.resolver, null, 0]);

							/* If the animation tick isn't running, start it. (Velocity shuts it off when there are no active calls to process.) */
							if (Velocity.State.isTicking === false) {
								Velocity.State.isTicking = true;

								/* Start the tick loop. */
								tick();
							}
						} else {
							elementsIndex++;
						}
					}
				}

				/* When the queue option is set to false, the call skips the element's queue and fires immediately. */
				if (opts.queue === false) {
					/* Since this buildQueue call doesn't respect the element's existing queue (which is where a delay option would have been appended),
					 we manually inject the delay property here with an explicit setTimeout. */
					if (opts.delay) {

						/* Temporarily store delayed elements to facilitate access for global pause/resume */
						var callIndex = Velocity.State.delayedElements.count++;
						Velocity.State.delayedElements[callIndex] = element;

						var delayComplete = (function(index) {
							return function() {
								/* Clear the temporary element */
								Velocity.State.delayedElements[index] = false;

								/* Finally, issue the call */
								buildQueue();
							};
						})(callIndex);

						Data(element).delayBegin = (new Date()).getTime();
						Data(element).delay = parseFloat(opts.delay);
						Data(element).delayTimer = {
							setTimeout: setTimeout(buildQueue, parseFloat(opts.delay)),
							next: delayComplete
						};
					} else {
						buildQueue();
					}
					/* Otherwise, the call undergoes element queueing as normal. */
					/* Note: To interoperate with jQuery, Velocity uses jQuery's own $.queue() stack for queuing logic. */
				} else {
					$.queue(element, opts.queue, function(next, clearQueue) {
						/* If the clearQueue flag was passed in by the stop command, resolve this call's promise. (Promises can only be resolved once,
						 so it's fine if this is repeatedly triggered for each element in the associated call.) */
						if (clearQueue === true) {
							if (promiseData.promise) {
								promiseData.resolver(elements);
							}

							/* Do not continue with animation queueing. */
							return true;
						}

						/* This flag indicates to the upcoming completeCall() function that this queue entry was initiated by Velocity.
						 See completeCall() for further details. */
						Velocity.velocityQueueEntryFlag = true;

						buildQueue(next);
					});
				}

				/*********************
				 Auto-Dequeuing
				 *********************/

				/* As per jQuery's $.queue() behavior, to fire the first non-custom-queue entry on an element, the element
				 must be dequeued if its queue stack consists *solely* of the current call. (This can be determined by checking
				 for the "inprogress" item that jQuery prepends to active queue stack arrays.) Regardless, whenever the element's
				 queue is further appended with additional items -- including $.delay()'s or even $.animate() calls, the queue's
				 first entry is automatically fired. This behavior contrasts that of custom queues, which never auto-fire. */
				/* Note: When an element set is being subjected to a non-parallel Velocity call, the animation will not begin until
				 each one of the elements in the set has reached the end of its individually pre-existing queue chain. */
				/* Note: Unfortunately, most people don't fully grasp jQuery's powerful, yet quirky, $.queue() function.
				 Lean more here: http://stackoverflow.com/questions/1058158/can-somebody-explain-jquery-queue-to-me */
				if ((opts.queue === "" || opts.queue === "fx") && $.queue(element)[0] !== "inprogress") {
					$.dequeue(element);
				}
			}

			/**************************
			 Element Set Iteration
			 **************************/

			/* If the "nodeType" property exists on the elements variable, we're animating a single element.
			 Place it in an array so that $.each() can iterate over it. */
			$.each(elements, function(i, element) {
				/* Ensure each element in a set has a nodeType (is a real element) to avoid throwing errors. */
				if (Type.isNode(element)) {
					processElement(element, i);
				}
			});

			/******************
			 Option: Loop
			 ******************/

			/* The loop option accepts an integer indicating how many times the element should loop between the values in the
			 current call's properties map and the element's property values prior to this call. */
			/* Note: The loop option's logic is performed here -- after element processing -- because the current call needs
			 to undergo its queue insertion prior to the loop option generating its series of constituent "reverse" calls,
			 which chain after the current call. Two reverse calls (two "alternations") constitute one loop. */
			opts = $.extend({}, Velocity.defaults, options);
			opts.loop = parseInt(opts.loop, 10);
			var reverseCallsCount = (opts.loop * 2) - 1;

			if (opts.loop) {
				/* Double the loop count to convert it into its appropriate number of "reverse" calls.
				 Subtract 1 from the resulting value since the current call is included in the total alternation count. */
				for (var x = 0; x < reverseCallsCount; x++) {
					/* Since the logic for the reverse action occurs inside Queueing and therefore this call's options object
					 isn't parsed until then as well, the current call's delay option must be explicitly passed into the reverse
					 call so that the delay logic that occurs inside *Pre-Queueing* can process it. */
					var reverseOptions = {
						delay: opts.delay,
						progress: opts.progress
					};

					/* If a complete callback was passed into this call, transfer it to the loop redirect's final "reverse" call
					 so that it's triggered when the entire redirect is complete (and not when the very first animation is complete). */
					if (x === reverseCallsCount - 1) {
						reverseOptions.display = opts.display;
						reverseOptions.visibility = opts.visibility;
						reverseOptions.complete = opts.complete;
					}

					animate(elements, "reverse", reverseOptions);
				}
			}

			/***************
			 Chaining
			 ***************/

			/* Return the elements back to the call chain, with wrapped elements taking precedence in case Velocity was called via the $.fn. extension. */
			return getChain();
		};

		/* Turn Velocity into the animation function, extended with the pre-existing Velocity object. */
		Velocity = $.extend(animate, Velocity);
		/* For legacy support, also expose the literal animate method. */
		Velocity.animate = animate;

		/**************
		 Timing
		 **************/

		/* Ticker function. */
		var ticker = window.requestAnimationFrame || rAFShim;

		/* Inactive browser tabs pause rAF, which results in all active animations immediately sprinting to their completion states when the tab refocuses.
		 To get around this, we dynamically switch rAF to setTimeout (which the browser *doesn't* pause) when the tab loses focus. We skip this for mobile
		 devices to avoid wasting battery power on inactive tabs. */
		/* Note: Tab focus detection doesn't work on older versions of IE, but that's okay since they don't support rAF to begin with. */
		if (!Velocity.State.isMobile && document.hidden !== undefined) {
			var updateTicker = function() {
				/* Reassign the rAF function (which the global tick() function uses) based on the tab's focus state. */
				if (document.hidden) {
					ticker = function(callback) {
						/* The tick function needs a truthy first argument in order to pass its internal timestamp check. */
						return setTimeout(function() {
							callback(true);
						}, 16);
					};

					/* The rAF loop has been paused by the browser, so we manually restart the tick. */
					tick();
				} else {
					ticker = window.requestAnimationFrame || rAFShim;
				}
			};

			/* Page could be sitting in the background at this time (i.e. opened as new tab) so making sure we use correct ticker from the start */
			updateTicker();

			/* And then run check again every time visibility changes */
			document.addEventListener("visibilitychange", updateTicker);
		}

		/************
		 Tick
		 ************/

		/* Note: All calls to Velocity are pushed to the Velocity.State.calls array, which is fully iterated through upon each tick. */
		function tick(timestamp) {
			/* An empty timestamp argument indicates that this is the first tick occurence since ticking was turned on.
			 We leverage this metadata to fully ignore the first tick pass since RAF's initial pass is fired whenever
			 the browser's next tick sync time occurs, which results in the first elements subjected to Velocity
			 calls being animated out of sync with any elements animated immediately thereafter. In short, we ignore
			 the first RAF tick pass so that elements being immediately consecutively animated -- instead of simultaneously animated
			 by the same Velocity call -- are properly batched into the same initial RAF tick and consequently remain in sync thereafter. */
			if (timestamp) {
				/* We normally use RAF's high resolution timestamp but as it can be significantly offset when the browser is
				 under high stress we give the option for choppiness over allowing the browser to drop huge chunks of frames.
				 We use performance.now() and shim it if it doesn't exist for when the tab is hidden. */
				var timeCurrent = Velocity.timestamp && timestamp !== true ? timestamp : performance.now();

				/********************
				 Call Iteration
				 ********************/

				var callsLength = Velocity.State.calls.length;

				/* To speed up iterating over this array, it is compacted (falsey items -- calls that have completed -- are removed)
				 when its length has ballooned to a point that can impact tick performance. This only becomes necessary when animation
				 has been continuous with many elements over a long period of time; whenever all active calls are completed, completeCall() clears Velocity.State.calls. */
				if (callsLength > 10000) {
					Velocity.State.calls = compactSparseArray(Velocity.State.calls);
					callsLength = Velocity.State.calls.length;
				}

				/* Iterate through each active call. */
				for (var i = 0; i < callsLength; i++) {
					/* When a Velocity call is completed, its Velocity.State.calls entry is set to false. Continue on to the next call. */
					if (!Velocity.State.calls[i]) {
						continue;
					}

					/************************
					 Call-Wide Variables
					 ************************/

					var callContainer = Velocity.State.calls[i],
							call = callContainer[0],
							opts = callContainer[2],
							timeStart = callContainer[3],
							firstTick = !timeStart,
							tweenDummyValue = null,
							pauseObject = callContainer[5],
							millisecondsEllapsed = callContainer[6];



					/* If timeStart is undefined, then this is the first time that this call has been processed by tick().
					 We assign timeStart now so that its value is as close to the real animation start time as possible.
					 (Conversely, had timeStart been defined when this call was added to Velocity.State.calls, the delay
					 between that time and now would cause the first few frames of the tween to be skipped since
					 percentComplete is calculated relative to timeStart.) */
					/* Further, subtract 16ms (the approximate resolution of RAF) from the current time value so that the
					 first tick iteration isn't wasted by animating at 0% tween completion, which would produce the
					 same style value as the element's current value. */
					if (!timeStart) {
						timeStart = Velocity.State.calls[i][3] = timeCurrent - 16;
					}

					/* If a pause object is present, skip processing unless it has been set to resume */
					if (pauseObject) {
						if (pauseObject.resume === true) {
							/* Update the time start to accomodate the paused completion amount */
							timeStart = callContainer[3] = Math.round(timeCurrent - millisecondsEllapsed - 16);

							/* Remove pause object after processing */
							callContainer[5] = null;
						} else {
							continue;
						}
					}

					millisecondsEllapsed = callContainer[6] = timeCurrent - timeStart;

					/* The tween's completion percentage is relative to the tween's start time, not the tween's start value
					 (which would result in unpredictable tween durations since JavaScript's timers are not particularly accurate).
					 Accordingly, we ensure that percentComplete does not exceed 1. */
					var percentComplete = Math.min((millisecondsEllapsed) / opts.duration, 1);

					/**********************
					 Element Iteration
					 **********************/

					/* For every call, iterate through each of the elements in its set. */
					for (var j = 0, callLength = call.length; j < callLength; j++) {
						var tweensContainer = call[j],
								element = tweensContainer.element;

						/* Check to see if this element has been deleted midway through the animation by checking for the
						 continued existence of its data cache. If it's gone, or the element is currently paused, skip animating this element. */
						if (!Data(element)) {
							continue;
						}

						var transformPropertyExists = false;

						/**********************************
						 Display & Visibility Toggling
						 **********************************/

						/* If the display option is set to non-"none", set it upfront so that the element can become visible before tweening begins.
						 (Otherwise, display's "none" value is set in completeCall() once the animation has completed.) */
						if (opts.display !== undefined && opts.display !== null && opts.display !== "none") {
							if (opts.display === "flex") {
								var flexValues = ["-webkit-box", "-moz-box", "-ms-flexbox", "-webkit-flex"];

								$.each(flexValues, function(i, flexValue) {
									CSS.setPropertyValue(element, "display", flexValue);
								});
							}

							CSS.setPropertyValue(element, "display", opts.display);
						}

						/* Same goes with the visibility option, but its "none" equivalent is "hidden". */
						if (opts.visibility !== undefined && opts.visibility !== "hidden") {
							CSS.setPropertyValue(element, "visibility", opts.visibility);
						}

						/************************
						 Property Iteration
						 ************************/

						/* For every element, iterate through each property. */
						for (var property in tweensContainer) {
							/* Note: In addition to property tween data, tweensContainer contains a reference to its associated element. */
							if (tweensContainer.hasOwnProperty(property) && property !== "element") {
								var tween = tweensContainer[property],
										currentValue,
										/* Easing can either be a pre-genereated function or a string that references a pre-registered easing
										 on the Velocity.Easings object. In either case, return the appropriate easing *function*. */
										easing = Type.isString(tween.easing) ? Velocity.Easings[tween.easing] : tween.easing;

								/******************************
								 Current Value Calculation
								 ******************************/

								if (Type.isString(tween.pattern)) {
									var patternReplace = percentComplete === 1 ?
											function($0, index, round) {
												var result = tween.endValue[index];

												return round ? Math.round(result) : result;
											} :
											function($0, index, round) {
												var startValue = tween.startValue[index],
														tweenDelta = tween.endValue[index] - startValue,
														result = startValue + (tweenDelta * easing(percentComplete, opts, tweenDelta));

												return round ? Math.round(result) : result;
											};

									currentValue = tween.pattern.replace(/{(\d+)(!)?}/g, patternReplace);
								} else if (percentComplete === 1) {
									/* If this is the last tick pass (if we've reached 100% completion for this tween),
									 ensure that currentValue is explicitly set to its target endValue so that it's not subjected to any rounding. */
									currentValue = tween.endValue;
								} else {
									/* Otherwise, calculate currentValue based on the current delta from startValue. */
									var tweenDelta = tween.endValue - tween.startValue;

									currentValue = tween.startValue + (tweenDelta * easing(percentComplete, opts, tweenDelta));
									/* If no value change is occurring, don't proceed with DOM updating. */
								}
								if (!firstTick && (currentValue === tween.currentValue)) {
									continue;
								}

								tween.currentValue = currentValue;

								/* If we're tweening a fake 'tween' property in order to log transition values, update the one-per-call variable so that
								 it can be passed into the progress callback. */
								if (property === "tween") {
									tweenDummyValue = currentValue;
								} else {
									/******************
									 Hooks: Part I
									 ******************/
									var hookRoot;

									/* For hooked properties, the newly-updated rootPropertyValueCache is cached onto the element so that it can be used
									 for subsequent hooks in this call that are associated with the same root property. If we didn't cache the updated
									 rootPropertyValue, each subsequent update to the root property in this tick pass would reset the previous hook's
									 updates to rootPropertyValue prior to injection. A nice performance byproduct of rootPropertyValue caching is that
									 subsequently chained animations using the same hookRoot but a different hook can use this cached rootPropertyValue. */
									if (CSS.Hooks.registered[property]) {
										hookRoot = CSS.Hooks.getRoot(property);

										var rootPropertyValueCache = Data(element).rootPropertyValueCache[hookRoot];

										if (rootPropertyValueCache) {
											tween.rootPropertyValue = rootPropertyValueCache;
										}
									}

									/*****************
									 DOM Update
									 *****************/

									/* setPropertyValue() returns an array of the property name and property value post any normalization that may have been performed. */
									/* Note: To solve an IE<=8 positioning bug, the unit type is dropped when setting a property value of 0. */
									var adjustedSetData = CSS.setPropertyValue(element, /* SET */
											property,
											tween.currentValue + (IE < 9 && parseFloat(currentValue) === 0 ? "" : tween.unitType),
											tween.rootPropertyValue,
											tween.scrollData);

									/*******************
									 Hooks: Part II
									 *******************/

									/* Now that we have the hook's updated rootPropertyValue (the post-processed value provided by adjustedSetData), cache it onto the element. */
									if (CSS.Hooks.registered[property]) {
										/* Since adjustedSetData contains normalized data ready for DOM updating, the rootPropertyValue needs to be re-extracted from its normalized form. ?? */
										if (CSS.Normalizations.registered[hookRoot]) {
											Data(element).rootPropertyValueCache[hookRoot] = CSS.Normalizations.registered[hookRoot]("extract", null, adjustedSetData[1]);
										} else {
											Data(element).rootPropertyValueCache[hookRoot] = adjustedSetData[1];
										}
									}

									/***************
									 Transforms
									 ***************/

									/* Flag whether a transform property is being animated so that flushTransformCache() can be triggered once this tick pass is complete. */
									if (adjustedSetData[0] === "transform") {
										transformPropertyExists = true;
									}

								}
							}
						}

						/****************
						 mobileHA
						 ****************/

						/* If mobileHA is enabled, set the translate3d transform to null to force hardware acceleration.
						 It's safe to override this property since Velocity doesn't actually support its animation (hooks are used in its place). */
						if (opts.mobileHA) {
							/* Don't set the null transform hack if we've already done so. */
							if (Data(element).transformCache.translate3d === undefined) {
								/* All entries on the transformCache object are later concatenated into a single transform string via flushTransformCache(). */
								Data(element).transformCache.translate3d = "(0px, 0px, 0px)";

								transformPropertyExists = true;
							}
						}

						if (transformPropertyExists) {
							CSS.flushTransformCache(element);
						}
					}

					/* The non-"none" display value is only applied to an element once -- when its associated call is first ticked through.
					 Accordingly, it's set to false so that it isn't re-processed by this call in the next tick. */
					if (opts.display !== undefined && opts.display !== "none") {
						Velocity.State.calls[i][2].display = false;
					}
					if (opts.visibility !== undefined && opts.visibility !== "hidden") {
						Velocity.State.calls[i][2].visibility = false;
					}

					/* Pass the elements and the timing data (percentComplete, msRemaining, timeStart, tweenDummyValue) into the progress callback. */
					if (opts.progress) {
						opts.progress.call(callContainer[1],
								callContainer[1],
								percentComplete,
								Math.max(0, (timeStart + opts.duration) - timeCurrent),
								timeStart,
								tweenDummyValue);
					}

					/* If this call has finished tweening, pass its index to completeCall() to handle call cleanup. */
					if (percentComplete === 1) {
						completeCall(i);
					}
				}
			}

			/* Note: completeCall() sets the isTicking flag to false when the last call on Velocity.State.calls has completed. */
			if (Velocity.State.isTicking) {
				ticker(tick);
			}
		}

		/**********************
		 Call Completion
		 **********************/

		/* Note: Unlike tick(), which processes all active calls at once, call completion is handled on a per-call basis. */
		function completeCall(callIndex, isStopped) {
			/* Ensure the call exists. */
			if (!Velocity.State.calls[callIndex]) {
				return false;
			}

			/* Pull the metadata from the call. */
			var call = Velocity.State.calls[callIndex][0],
					elements = Velocity.State.calls[callIndex][1],
					opts = Velocity.State.calls[callIndex][2],
					resolver = Velocity.State.calls[callIndex][4];

			var remainingCallsExist = false;

			/*************************
			 Element Finalization
			 *************************/

			for (var i = 0, callLength = call.length; i < callLength; i++) {
				var element = call[i].element;

				/* If the user set display to "none" (intending to hide the element), set it now that the animation has completed. */
				/* Note: display:none isn't set when calls are manually stopped (via Velocity("stop"). */
				/* Note: Display gets ignored with "reverse" calls and infinite loops, since this behavior would be undesirable. */
				if (!isStopped && !opts.loop) {
					if (opts.display === "none") {
						CSS.setPropertyValue(element, "display", opts.display);
					}

					if (opts.visibility === "hidden") {
						CSS.setPropertyValue(element, "visibility", opts.visibility);
					}
				}

				/* If the element's queue is empty (if only the "inprogress" item is left at position 0) or if its queue is about to run
				 a non-Velocity-initiated entry, turn off the isAnimating flag. A non-Velocity-initiatied queue entry's logic might alter
				 an element's CSS values and thereby cause Velocity's cached value data to go stale. To detect if a queue entry was initiated by Velocity,
				 we check for the existence of our special Velocity.queueEntryFlag declaration, which minifiers won't rename since the flag
				 is assigned to jQuery's global $ object and thus exists out of Velocity's own scope. */
				var data = Data(element);

				if (opts.loop !== true && ($.queue(element)[1] === undefined || !/\.velocityQueueEntryFlag/i.test($.queue(element)[1]))) {
					/* The element may have been deleted. Ensure that its data cache still exists before acting on it. */
					if (data) {
						data.isAnimating = false;
						/* Clear the element's rootPropertyValueCache, which will become stale. */
						data.rootPropertyValueCache = {};

						var transformHAPropertyExists = false;
						/* If any 3D transform subproperty is at its default value (regardless of unit type), remove it. */
						$.each(CSS.Lists.transforms3D, function(i, transformName) {
							var defaultValue = /^scale/.test(transformName) ? 1 : 0,
									currentValue = data.transformCache[transformName];

							if (data.transformCache[transformName] !== undefined && new RegExp("^\\(" + defaultValue + "[^.]").test(currentValue)) {
								transformHAPropertyExists = true;

								delete data.transformCache[transformName];
							}
						});

						/* Mobile devices have hardware acceleration removed at the end of the animation in order to avoid hogging the GPU's memory. */
						if (opts.mobileHA) {
							transformHAPropertyExists = true;
							delete data.transformCache.translate3d;
						}

						/* Flush the subproperty removals to the DOM. */
						if (transformHAPropertyExists) {
							CSS.flushTransformCache(element);
						}

						/* Remove the "velocity-animating" indicator class. */
						CSS.Values.removeClass(element, "velocity-animating");
					}
				}

				/*********************
				 Option: Complete
				 *********************/

				/* Complete is fired once per call (not once per element) and is passed the full raw DOM element set as both its context and its first argument. */
				/* Note: Callbacks aren't fired when calls are manually stopped (via Velocity("stop"). */
				if (!isStopped && opts.complete && !opts.loop && (i === callLength - 1)) {
					/* We throw callbacks in a setTimeout so that thrown errors don't halt the execution of Velocity itself. */
					try {
						opts.complete.call(elements, elements);
					} catch (error) {
						setTimeout(function() {
							throw error;
						}, 1);
					}
				}

				/**********************
				 Promise Resolving
				 **********************/

				/* Note: Infinite loops don't return promises. */
				if (resolver && opts.loop !== true) {
					resolver(elements);
				}

				/****************************
				 Option: Loop (Infinite)
				 ****************************/

				if (data && opts.loop === true && !isStopped) {
					/* If a rotateX/Y/Z property is being animated by 360 deg with loop:true, swap tween start/end values to enable
					 continuous iterative rotation looping. (Otherise, the element would just rotate back and forth.) */
					$.each(data.tweensContainer, function(propertyName, tweenContainer) {
						if (/^rotate/.test(propertyName) && ((parseFloat(tweenContainer.startValue) - parseFloat(tweenContainer.endValue)) % 360 === 0)) {
							var oldStartValue = tweenContainer.startValue;

							tweenContainer.startValue = tweenContainer.endValue;
							tweenContainer.endValue = oldStartValue;
						}

						if (/^backgroundPosition/.test(propertyName) && parseFloat(tweenContainer.endValue) === 100 && tweenContainer.unitType === "%") {
							tweenContainer.endValue = 0;
							tweenContainer.startValue = 100;
						}
					});

					Velocity(element, "reverse", {loop: true, delay: opts.delay});
				}

				/***************
				 Dequeueing
				 ***************/

				/* Fire the next call in the queue so long as this call's queue wasn't set to false (to trigger a parallel animation),
				 which would have already caused the next call to fire. Note: Even if the end of the animation queue has been reached,
				 $.dequeue() must still be called in order to completely clear jQuery's animation queue. */
				if (opts.queue !== false) {
					$.dequeue(element, opts.queue);
				}
			}

			/************************
			 Calls Array Cleanup
			 ************************/

			/* Since this call is complete, set it to false so that the rAF tick skips it. This array is later compacted via compactSparseArray().
			 (For performance reasons, the call is set to false instead of being deleted from the array: http://www.html5rocks.com/en/tutorials/speed/v8/) */
			Velocity.State.calls[callIndex] = false;

			/* Iterate through the calls array to determine if this was the final in-progress animation.
			 If so, set a flag to end ticking and clear the calls array. */
			for (var j = 0, callsLength = Velocity.State.calls.length; j < callsLength; j++) {
				if (Velocity.State.calls[j] !== false) {
					remainingCallsExist = true;

					break;
				}
			}

			if (remainingCallsExist === false) {
				/* tick() will detect this flag upon its next iteration and subsequently turn itself off. */
				Velocity.State.isTicking = false;

				/* Clear the calls array so that its length is reset. */
				delete Velocity.State.calls;
				Velocity.State.calls = [];
			}
		}

		/******************
		 Frameworks
		 ******************/

		/* Both jQuery and Zepto allow their $.fn object to be extended to allow wrapped elements to be subjected to plugin calls.
		 If either framework is loaded, register a "velocity" extension pointing to Velocity's core animate() method.  Velocity
		 also registers itself onto a global container (window.jQuery || window.Zepto || window) so that certain features are
		 accessible beyond just a per-element scope. This master object contains an .animate() method, which is later assigned to $.fn
		 (if jQuery or Zepto are present). Accordingly, Velocity can both act on wrapped DOM elements and stand alone for targeting raw DOM elements. */
		global.Velocity = Velocity;

		if (global !== window) {
			/* Assign the element function to Velocity's core animate() method. */
			global.fn.velocity = animate;
			/* Assign the object function's defaults to Velocity's global defaults object. */
			global.fn.velocity.defaults = Velocity.defaults;
		}

		/***********************
		 Packaged Redirects
		 ***********************/

		/* slideUp, slideDown */
		$.each(["Down", "Up"], function(i, direction) {
			Velocity.Redirects["slide" + direction] = function(element, options, elementsIndex, elementsSize, elements, promiseData) {
				var opts = $.extend({}, options),
						begin = opts.begin,
						complete = opts.complete,
						inlineValues = {},
						computedValues = {height: "", marginTop: "", marginBottom: "", paddingTop: "", paddingBottom: ""};

				if (opts.display === undefined) {
					/* Show the element before slideDown begins and hide the element after slideUp completes. */
					/* Note: Inline elements cannot have dimensions animated, so they're reverted to inline-block. */
					opts.display = (direction === "Down" ? (Velocity.CSS.Values.getDisplayType(element) === "inline" ? "inline-block" : "block") : "none");
				}

				opts.begin = function() {
					/* If the user passed in a begin callback, fire it now. */
					if (elementsIndex === 0 && begin) {
						begin.call(elements, elements);
					}

					/* Cache the elements' original vertical dimensional property values so that we can animate back to them. */
					for (var property in computedValues) {
						if (!computedValues.hasOwnProperty(property)) {
							continue;
						}
						inlineValues[property] = element.style[property];

						/* For slideDown, use forcefeeding to animate all vertical properties from 0. For slideUp,
						 use forcefeeding to start from computed values and animate down to 0. */
						var propertyValue = CSS.getPropertyValue(element, property);
						computedValues[property] = (direction === "Down") ? [propertyValue, 0] : [0, propertyValue];
					}

					/* Force vertical overflow content to clip so that sliding works as expected. */
					inlineValues.overflow = element.style.overflow;
					element.style.overflow = "hidden";
				};

				opts.complete = function() {
					/* Reset element to its pre-slide inline values once its slide animation is complete. */
					for (var property in inlineValues) {
						if (inlineValues.hasOwnProperty(property)) {
							element.style[property] = inlineValues[property];
						}
					}

					/* If the user passed in a complete callback, fire it now. */
					if (elementsIndex === elementsSize - 1) {
						if (complete) {
							complete.call(elements, elements);
						}
						if (promiseData) {
							promiseData.resolver(elements);
						}
					}
				};

				Velocity(element, computedValues, opts);
			};
		});

		/* fadeIn, fadeOut */
		$.each(["In", "Out"], function(i, direction) {
			Velocity.Redirects["fade" + direction] = function(element, options, elementsIndex, elementsSize, elements, promiseData) {
				var opts = $.extend({}, options),
						complete = opts.complete,
						propertiesMap = {opacity: (direction === "In") ? 1 : 0};

				/* Since redirects are triggered individually for each element in the animated set, avoid repeatedly triggering
				 callbacks by firing them only when the final element has been reached. */
				if (elementsIndex !== 0) {
					opts.begin = null;
				}
				if (elementsIndex !== elementsSize - 1) {
					opts.complete = null;
				} else {
					opts.complete = function() {
						if (complete) {
							complete.call(elements, elements);
						}
						if (promiseData) {
							promiseData.resolver(elements);
						}
					};
				}

				/* If a display was passed in, use it. Otherwise, default to "none" for fadeOut or the element-specific default for fadeIn. */
				/* Note: We allow users to pass in "null" to skip display setting altogether. */
				if (opts.display === undefined) {
					opts.display = (direction === "In" ? "auto" : "none");
				}

				Velocity(this, propertiesMap, opts);
			};
		});

		return Velocity;
	}((__webpack_provided_window_dot_jQuery || window.Zepto || window), window, (window ? window.document : undefined));
}));

/******************
 Known Issues
 ******************/

/* The CSS spec mandates that the translateX/Y/Z transforms are %-relative to the element itself -- not its parent.
 Velocity, however, doesn't make this distinction. Thus, converting to or from the % unit with these subproperties
 will produce an inaccurate conversion value. The same issue exists with the cx/cy attributes of SVG circles and ellipses. */

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0), __webpack_require__(0)))

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", { value: true });
var maquette = __webpack_require__(1);
var h = maquette.h;
var CaliforniaApp_1 = __webpack_require__(3);
var CaliforniaGenerated_1 = __webpack_require__(2);
var ClientState_1 = __webpack_require__(4);
var PropertyBarVM_1 = __webpack_require__(5);
var currentApp;
var currentRouter;
var CaliforniaRouter = function () {
    function CaliforniaRouter(californiaAppArg) {
        this.deepestLevelCurrentRow = 0;
        this.updateData = function (response, isInitial, preventRenderChainedCalls) {
            var _a;
            if (isInitial === void 0) {
                isInitial = false;
            }
            if (preventRenderChainedCalls === void 0) {
                preventRenderChainedCalls = false;
            }
            var isValidResponse = currentRouter.validateResponse(response);
            if (!isValidResponse) {
                return;
            }
            var isFullDataUpdate = false;
            var isUpdateSuccess = false;
            switch (response.CaliforniaEvent) {
                case CaliforniaGenerated_1.CaliforniaEvent.UpdateContentAtom:
                    if (response.PartialUpdate.ContentAtom !== undefined) {
                        var currentContentAtomIndex = currentApp.clientData.CaliforniaProject.ContentAtoms.findIndex(function (c) {
                            return c.ContentAtomId == response.PartialUpdate.ContentAtom.ContentAtomId;
                        });
                        (_a = currentApp.clientData.CaliforniaProject.ContentAtoms).splice.apply(_a, [currentContentAtomIndex, 1].concat([response.PartialUpdate.ContentAtom]));
                        currentApp.clientData.CaliforniaProject.LayoutMolecules.find(function (l) {
                            return l.LayoutBaseId == response.PartialUpdate.ContentAtom.InstancedOnLayoutId;
                        }).HostedContentAtom = response.PartialUpdate.ContentAtom;
                        isUpdateSuccess = true;
                    }
                    break;
                default:
                    isFullDataUpdate = true;
                    break;
            }
            if (isFullDataUpdate === true) {
                if (response.CaliforniaProject !== undefined) {
                    currentApp.clientData.CaliforniaProject = response.CaliforniaProject;
                    currentApp.clientData.UrlToReadOnly = response.UrlToReadOnly;
                    currentApp.clientData.UrlToReadAndEdit = response.UrlToReadAndEdit;
                    if (response.CaliforniaProject.ResponsiveDevices.length !== undefined && response.CaliforniaProject.ResponsiveDevices.length > 0) {
                        currentApp.clientData.CaliforniaProject.ResponsiveDevices = currentApp.clientData.CaliforniaProject.ResponsiveDevices.sort(function (r1, r2) {
                            return r1.WidthThreshold !== undefined && r2.WidthThreshold !== undefined ? r1.WidthThreshold < r2.WidthThreshold ? -1 : r1.WidthThreshold == r2.WidthThreshold ? 0 : 1 : 0;
                        });
                        currentApp.state.lowestWidthThresholdResponsiveDeviceId = currentApp.clientData.CaliforniaProject.ResponsiveDevices[1].ResponsiveDeviceId;
                        currentApp.state.highestWidthThresholdResponsiveDeviceId = currentApp.clientData.CaliforniaProject.ResponsiveDevices[currentApp.clientData.CaliforniaProject.ResponsiveDevices.length - 1].ResponsiveDeviceId;
                        currentApp.state.noneResponsiveDeviceId = currentApp.clientData.CaliforniaProject.ResponsiveDevices[0].ResponsiveDeviceId;
                        if (isInitial) {
                            for (var i = 0; i < currentApp.propertyBars.length; i++) {
                                var propertyBar = currentApp.propertyBars[i];
                                propertyBar.viewModel.setSelectedResponsiveDeviceId(currentApp.state.noneResponsiveDeviceId, true);
                            }
                        }
                        if (currentApp.pagePreview.virtualStyleIndex.length == 0) {
                            currentApp.pagePreview.virtualStyleIndex = [];
                            currentApp.pagePreview.virtualPseudoStyleIndex = [];
                            for (var _i = 0, _b = currentApp.clientData.CaliforniaProject.ResponsiveDevices; _i < _b.length; _i++) {
                                var responsiveDevice = _b[_i];
                                currentApp.pagePreview.virtualStyleIndex.push([]);
                                currentApp.pagePreview.virtualPseudoStyleIndex.push({});
                            }
                        }
                    }
                    if (isInitial === true) {
                        currentApp.clientData.AllCssProperties = response.AllCssProperties;
                        currentApp.clientData.StyleAtomCssPropertyMapping = response.StyleAtomCssPropertyMapping;
                        currentApp.clientData.ThirdPartyFonts = response.ThirdPartyFonts;
                    }
                    if (currentApp.clientData.CaliforniaProject.StyleQuantums !== undefined && currentApp.clientData.CaliforniaProject.StyleAtoms !== undefined && currentApp.clientData.CaliforniaProject.StyleMolecules !== undefined && currentApp.clientData.CaliforniaProject.LayoutMolecules !== undefined && currentApp.clientData.CaliforniaProject.CaliforniaViews !== undefined && currentApp.clientData.CaliforniaProject.CaliforniaViews.length > 0) {
                        currentRouter.restoreLayoutMoleculeAndStyleReferences();
                        currentApp.state.specialStyleHolder = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (v) {
                            return v.IsInternal === true && v.Name === "[Internal] Special Styles";
                        });
                        if (currentApp.state.specialStyleHolder === undefined) {
                            console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                            return;
                        }
                        currentApp.clientData.CaliforniaProject.CaliforniaViews.filter(function (v) {
                            return !v.IsInternal;
                        }).map(function (v) {
                            if (currentApp.state.specialStyleHolder !== undefined) {
                                var californiaViewStyleHolderRow = currentApp.state.specialStyleHolder.PlacedLayoutRows.find(function (layoutRow) {
                                    var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                                        return m.StyleForLayoutId == layoutRow.LayoutBaseId;
                                    });
                                    if (styleMolecule.Name === "[Internal] " + v.Name + " View Style") {
                                        v.SpecialStyleViewStyleMoleculeId = styleMolecule.StyleMoleculeId;
                                        return true;
                                    }
                                    return false;
                                });
                                var californiaViewBodyStyleHolderRow = currentApp.state.specialStyleHolder.PlacedLayoutRows.find(function (layoutRow) {
                                    var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                                        return m.StyleForLayoutId == layoutRow.LayoutBaseId;
                                    });
                                    if (styleMolecule.Name === "[Internal] " + v.Name + " Body Style") {
                                        v.SpecialStyleBodyStyleMoleculeId = styleMolecule.StyleMoleculeId;
                                        return true;
                                    }
                                    return false;
                                });
                                var californiaViewHtmlStyleHolderRow = currentApp.state.specialStyleHolder.PlacedLayoutRows.find(function (layoutRow) {
                                    var styleMolecule = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (m) {
                                        return m.StyleForLayoutId == layoutRow.LayoutBaseId;
                                    });
                                    if (styleMolecule.Name === "[Internal] " + v.Name + " Html Style") {
                                        v.SpecialStyleHtmlStyleMoleculeId = styleMolecule.StyleMoleculeId;
                                        return true;
                                    }
                                    return false;
                                });
                                v.SpecialStyleViewStyleMoleculeIdString = v.SpecialStyleViewStyleMoleculeId.toString();
                                v.SpecialStyleViewStyleString = "s" + v.SpecialStyleViewStyleMoleculeIdString;
                                v.SpecialStyleBodyStyleMoleculeIdString = v.SpecialStyleBodyStyleMoleculeId.toString();
                                v.SpecialStyleBodyStyleString = "s" + v.SpecialStyleBodyStyleMoleculeIdString;
                                v.SpecialStyleHtmlStyleMoleculeIdString = v.SpecialStyleHtmlStyleMoleculeId.toString();
                                v.SpecialStyleHtmlStyleString = "s" + v.SpecialStyleHtmlStyleMoleculeIdString;
                            } else {
                                v.SpecialStyleViewStyleString = "";
                                v.SpecialStyleBodyStyleString = "";
                                v.SpecialStyleHtmlStyleString = "";
                            }
                        });
                        var instanceableAtomsView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (view) {
                            return view.IsInternal && view.Name === "[Internal] Instanceable Layout Atoms";
                        });
                        var instanceableRowsView = currentApp.clientData.CaliforniaProject.CaliforniaViews.find(function (view) {
                            return view.IsInternal && view.Name === "[Internal] Instanceable Layout Rows";
                        });
                        currentRouter.setActiveCaliforniaViewId(currentApp.pagePreviewVM.activeCaliforniaViewId != 0 ? currentApp.pagePreviewVM.activeCaliforniaViewId : 0, true, isInitial);
                        for (var i = 0; i < currentApp.propertyBars.length; i++) {
                            currentApp.propertyBars[i].viewModel.updateData(currentApp.clientData.CaliforniaProject.StyleQuantums, currentApp.clientData.CaliforniaProject.StyleAtoms, currentApp.clientData.CaliforniaProject.StyleMolecules, currentApp.clientData.CaliforniaProject.LayoutMolecules, currentApp.clientData.CaliforniaProject.CaliforniaViews, instanceableAtomsView, instanceableRowsView);
                        }
                        var firstRow_1 = instanceableRowsView.PlacedLayoutRows[0];
                        currentApp.state.newBoxStyleMoleculeId = currentApp.clientData.CaliforniaProject.StyleMolecules.find(function (s) {
                            return s.StyleForLayoutId == firstRow_1.AllBoxesBelowRow[0].LayoutBaseId;
                        }).StyleMoleculeId;
                    } else {
                        currentApp.state.specialStyleHolder = undefined;
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                    }
                    if (isInitial === true) {
                        var i = 0;
                        if (i < currentApp.propertyBarCount) {
                            currentApp.propertyBarVMs[i++].currentPropertyBarMode = PropertyBarVM_1.PropertyBarMode.CaliforniaView;
                            if (i < currentApp.propertyBarCount) {
                                currentApp.propertyBarVMs[i++].currentPropertyBarMode = PropertyBarVM_1.PropertyBarMode.AllCaliforniaViews;
                                if (i < currentApp.propertyBarCount) {
                                    currentApp.propertyBarVMs[i++].currentPropertyBarMode = PropertyBarVM_1.PropertyBarMode.StyleMolecule;
                                    if (i < currentApp.propertyBarCount) {
                                        currentApp.propertyBarVMs[i++].currentPropertyBarMode = PropertyBarVM_1.PropertyBarMode.AllStyleQuantums;
                                    }
                                }
                            }
                        }
                    }
                    currentRouter.setupUiForDevice();
                    isUpdateSuccess = true;
                }
            }
            if (isUpdateSuccess === false) {
                console.log("missing client data");
                location.reload();
            }
            currentApp.state.isDataLoaded = true;
            if (!preventRenderChainedCalls) {
                currentApp.projector.scheduleRender();
            }
        };
        this.restoreLayoutMoleculeAndStyleReferences = function () {
            var project = currentApp.clientData.CaliforniaProject;
            var allRows = [];
            var allBoxes = [];
            var allAtoms = [];
            project.LayoutMolecules.map(function (mol) {
                switch (mol.LayoutType) {
                    case CaliforniaGenerated_1.LayoutType.Row:
                        allRows.push(mol);
                        break;
                    case CaliforniaGenerated_1.LayoutType.Box:
                        allBoxes.push(mol);
                        break;
                    case CaliforniaGenerated_1.LayoutType.Atom:
                        allAtoms.push(mol);
                        break;
                    default:
                        console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                        break;
                }
            });
            var allContentAtoms = project.ContentAtoms;
            var allInteractions = project.LayoutStyleInteractions;
            project.CaliforniaViews.map(function (view) {
                view.PlacedLayoutRows = allRows.filter(function (row) {
                    return row.PlacedOnViewId == view.CaliforniaViewId;
                }).sort(function (rowA, rowB) {
                    if (rowA.LayoutSortOrderKey < rowB.LayoutSortOrderKey) {
                        return -1;
                    } else if (rowA.LayoutSortOrderKey == rowB.LayoutSortOrderKey) {
                        return 0;
                    } else {
                        return 1;
                    }
                });
            });
            var deepestLevelCurrentView = 0;
            project.CaliforniaViews.map(function (view) {
                deepestLevelCurrentView = 0;
                var _loop_1 = function _loop_1(iRow) {
                    currentRouter.deepestLevelCurrentRow = 0;
                    var row = view.PlacedLayoutRows[iRow];
                    row.AllBoxesBelowRow = allBoxes.filter(function (box) {
                        return box.BoxOwnerRowId == row.LayoutBaseId && box.PlacedBoxInBoxId == undefined;
                    });
                    row.AllBoxesBelowRow.map(function (box) {
                        currentRouter.restoreLayoutBoxReferencesRecursive(0, box, row, allBoxes, allAtoms, allContentAtoms, allInteractions);
                        box.BoxOwnerRow = row;
                    });
                    row.DeepestLevel = currentRouter.deepestLevelCurrentRow;
                    if (currentRouter.deepestLevelCurrentRow > deepestLevelCurrentView) {
                        deepestLevelCurrentView = currentRouter.deepestLevelCurrentRow;
                    }
                };
                for (var iRow = 0; iRow < view.PlacedLayoutRows.length; iRow++) {
                    _loop_1(iRow);
                }
                view.DeepestLevel = deepestLevelCurrentView;
            });
        };
        this.restoreLayoutBoxReferencesRecursive = function (boxLevel, box, boxOwnerRow, allBoxes, allAtoms, allContentAtoms, allInteractions) {
            var _a;
            box.Level = boxLevel;
            box.PlacedInBoxBoxes = allBoxes.filter(function (subBox) {
                return subBox.PlacedBoxInBoxId !== undefined && subBox.PlacedBoxInBoxId == box.LayoutBaseId;
            });
            box.PlacedInBoxBoxes.map(function (subBox) {
                currentRouter.restoreLayoutBoxReferencesRecursive(boxLevel + 1, subBox, boxOwnerRow, allBoxes, allAtoms, allContentAtoms, allInteractions);
                subBox.BoxOwnerRow = boxOwnerRow;
                subBox.PlacedBoxInBox = box;
            });
            (_a = boxOwnerRow.AllBoxesBelowRow).push.apply(_a, box.PlacedInBoxBoxes);
            box.PlacedInBoxAtoms = allAtoms.filter(function (subAtom) {
                return subAtom.PlacedAtomInBoxId !== undefined && subAtom.PlacedAtomInBoxId == box.LayoutBaseId;
            });
            box.PlacedInBoxAtoms.map(function (subAtom) {
                subAtom.HostedContentAtom = allContentAtoms.find(function (contentAtom) {
                    return contentAtom.InstancedOnLayoutId == subAtom.LayoutBaseId;
                });
                subAtom.PlacedAtomInBox = box;
                subAtom.LayoutStyleInteractions = allInteractions.filter(function (map) {
                    return map.LayoutAtomId == subAtom.LayoutBaseId;
                });
                subAtom.Level = boxLevel + 1;
            });
            if (box.PlacedInBoxAtoms.length > 0) {
                if (boxLevel + 1 > currentRouter.deepestLevelCurrentRow) {
                    currentRouter.deepestLevelCurrentRow = boxLevel + 1;
                }
            } else if (boxLevel > currentRouter.deepestLevelCurrentRow) {
                currentRouter.deepestLevelCurrentRow = boxLevel;
            }
        };
        this.setupUiForDevice = function () {
            var californiaAppHeight = $(window).height();
            if (californiaAppHeight === undefined) {
                console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
                return;
            }
            document.body.style.height = californiaAppHeight + "px";
            if (currentApp.state.isHideUserInterface === true || currentApp.state.editViewMode === ClientState_1.EditViewMode.PagePreviewOnly) {
                currentApp.state.availableSpacePagePreviewPx = currentApp.pagePreviewHolder !== undefined ? window.innerWidth + 2 * currentApp.state.targetPagePreviewHolderMarginPx : 0;
            } else {
                currentApp.state.availableSpacePagePreviewPx = currentApp.pagePreviewHolder !== undefined ? currentApp.pagePreviewHolder.clientWidth + 2 * currentApp.state.targetPagePreviewHolderMarginPx : 0;
            }
            if (currentApp.clientData.CaliforniaProject !== undefined && currentApp.clientData.CaliforniaProject.ResponsiveDevices !== undefined && currentApp.clientData.CaliforniaProject.ResponsiveDevices.length > 0) {
                if (currentApp.pagePreviewVM.editedLayoutAtomId == 0) {
                    currentApp.pagePreview.updatePagePreviewDimensions();
                }
            }
        };
        this.validateResponse = function (response) {
            if (response == null) {
                console.log("invalid client data");
                return false;
            } else if (response.StatusText !== null && response.StatusText !== "") {
                console.log(response.StatusText);
                return false;
            }
            if (currentApp.clientData !== undefined && response.CurrentRevision < currentApp.clientData.CurrentRevision) {
                console.log("Ignoring client data: revision is lower");
                return false;
            }
            return true;
        };
        currentRouter = this;
        currentApp = californiaAppArg;
    }
    ;
    CaliforniaRouter.prototype.clearCaliforniaPropertyBars = function (isClearWhenNonEqual, clearWhenEqualsCaliforniaViewId) {
        for (var i = 0; i < currentApp.propertyBars.length; i++) {
            currentApp.propertyBars[i].viewModel.clearSelectedCaliforniaView(isClearWhenNonEqual, clearWhenEqualsCaliforniaViewId);
        }
    };
    ;
    CaliforniaRouter.prototype.setActiveCaliforniaViewId = function (californiaViewId, isDefaultToHome, isSetAllPropertyBars) {
        var userPages = currentApp.clientData.CaliforniaProject.CaliforniaViews.filter(function (view) {
            return !view.IsInternal;
        });
        var activeView = undefined;
        var activePageIndex = -1;
        if (californiaViewId != 0) {
            activePageIndex = userPages.findIndex(function (v) {
                return v.CaliforniaViewId == californiaViewId;
            });
        }
        if (activePageIndex == -1 && isDefaultToHome === true) {
            activePageIndex = userPages.findIndex(function (v) {
                return v.Name === "Home";
            });
        }
        if (activePageIndex > -1) {
            activeView = userPages[activePageIndex];
            currentRouter.setActiveCaliforniaView(activeView);
            if (isSetAllPropertyBars === true) {
                for (var i = 0; i < currentApp.propertyBars.length; i++) {
                    currentApp.propertyBars[i].viewModel.setSelectedCaliforniaView(activeView, true);
                }
            } else {
                currentApp.propertyBars[0].viewModel.setSelectedCaliforniaView(activeView, true);
                var _loop_2 = function _loop_2(i) {
                    var propertyBarViewId = currentApp.propertyBars[i].viewModel.selectedCaliforniaViewId;
                    if (propertyBarViewId != 0) {
                        var propertyBarView = userPages.find(function (v) {
                            return v.CaliforniaViewId === propertyBarViewId;
                        });
                        currentApp.propertyBars[i].viewModel.setSelectedCaliforniaView(propertyBarView, true);
                    }
                };
                for (var i = 1; i < currentApp.propertyBars.length; i++) {
                    _loop_2(i);
                }
            }
        } else {
            console.log(CaliforniaApp_1.DEFAULT_EXCEPTION);
        }
    };
    ;
    CaliforniaRouter.prototype.setActiveCaliforniaView = function (californiaView) {
        currentApp.pagePreview.viewModel.activeCaliforniaViewId = californiaView.CaliforniaViewId;
        currentApp.pagePreviewVM.californiaViewProjector.map([californiaView]);
        currentApp.pagePreviewVM.fixedLayoutRowsProjector.map(californiaView.PlacedLayoutRows);
    };
    ;
    return CaliforniaRouter;
}();
exports.CaliforniaRouter = CaliforniaRouter;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", { value: true });
var CaliforniaClientPartialData = function () {
    function CaliforniaClientPartialData() {}
    return CaliforniaClientPartialData;
}();
exports.CaliforniaClientPartialData = CaliforniaClientPartialData;

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNDVjYTc4ZTVmYzQyZTE1ZjZmMjkiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFxdWV0dGUvZGlzdC9tYXF1ZXR0ZS5qcyIsIndlYnBhY2s6Ly8vLi9Nb2RlbHMvQ2FsaWZvcm5pYUdlbmVyYXRlZC50cyIsIndlYnBhY2s6Ly8vLi9Nb2RlbHMvQ2FsaWZvcm5pYUFwcC50c3giLCJ3ZWJwYWNrOi8vLy4vTW9kZWxzL0NsaWVudFN0YXRlLnRzeCIsIndlYnBhY2s6Ly8vLi9WaWV3TW9kZWxzL1Byb3BlcnR5QmFyVk0udHN4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wb3BwZXIuanMvZGlzdC9lc20vcG9wcGVyLmpzIiwid2VicGFjazovLy8uL1R5cGV3cml0ZXIvQ29udGVudEF0b21UeXBlLnRzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnktdmFsaWRhdGlvbi9kaXN0L2pxdWVyeS52YWxpZGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXZhbGlkYXRpb24tdW5vYnRydXNpdmUvanF1ZXJ5LnZhbGlkYXRlLnVub2J0cnVzaXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90ZXRoZXIvZGlzdC9qcy90ZXRoZXIuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9zYXNzL21haW4uc2NzcyIsIndlYnBhY2s6Ly8vLi9zaXRlLnRzeCIsIndlYnBhY2s6Ly8vLi9UeXBld3JpdGVyL0NhbGlmb3JuaWFDb250cm9sbGVyLnRzIiwid2VicGFjazovLy8uL1R5cGV3cml0ZXIvdHNnZW5IZWxwZXJzLnRzIiwid2VicGFjazovLy8uL1R5cGV3cml0ZXIvQ2FsaWZvcm5pYUV2ZW50LnRzIiwid2VicGFjazovLy8uL1R5cGV3cml0ZXIvQ2FsaWZvcm5pYVByb2plY3QudHMiLCJ3ZWJwYWNrOi8vLy4vVHlwZXdyaXRlci9DYWxpZm9ybmlhVXNlckRlZmF1bHRzLnRzIiwid2VicGFjazovLy8uL1R5cGV3cml0ZXIvQ2FsaWZvcm5pYUNsaWVudFZpZXdNb2RlbC50cyIsIndlYnBhY2s6Ly8vLi9UeXBld3JpdGVyL1N0eWxlTW9sZWN1bGUudHMiLCJ3ZWJwYWNrOi8vLy4vVHlwZXdyaXRlci9TdHlsZVF1YW50dW0udHMiLCJ3ZWJwYWNrOi8vLy4vVHlwZXdyaXRlci9TdHlsZUF0b20udHMiLCJ3ZWJwYWNrOi8vLy4vVHlwZXdyaXRlci9TdHlsZUF0b21UeXBlLnRzIiwid2VicGFjazovLy8uL1R5cGV3cml0ZXIvU3R5bGVWYWx1ZS50cyIsIndlYnBhY2s6Ly8vLi9UeXBld3JpdGVyL1Jlc3BvbnNpdmVEZXZpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vVHlwZXdyaXRlci9DYWxpZm9ybmlhVmlldy50cyIsIndlYnBhY2s6Ly8vLi9UeXBld3JpdGVyL0xheW91dFJvdy50cyIsIndlYnBhY2s6Ly8vLi9UeXBld3JpdGVyL0xheW91dEJveC50cyIsIndlYnBhY2s6Ly8vLi9UeXBld3JpdGVyL0xheW91dEF0b20udHMiLCJ3ZWJwYWNrOi8vLy4vVHlwZXdyaXRlci9TdHlsZU1vbGVjdWxlQXRvbU1hcHBpbmcudHMiLCJ3ZWJwYWNrOi8vLy4vVHlwZXdyaXRlci9Db250ZW50QXRvbS50cyIsIndlYnBhY2s6Ly8vLi9UeXBld3JpdGVyL0xheW91dEJhc2UudHMiLCJ3ZWJwYWNrOi8vLy4vVHlwZXdyaXRlci9MYXlvdXRUeXBlLnRzIiwid2VicGFjazovLy8uL1R5cGV3cml0ZXIvU3BlY2lhbExheW91dEJveFR5cGUudHMiLCJ3ZWJwYWNrOi8vLy4vVHlwZXdyaXRlci9MYXlvdXRTdHlsZUludGVyYWN0aW9uLnRzIiwid2VicGFjazovLy8uL01vZGVscy9QYWdlUHJldmlldy50c3giLCJ3ZWJwYWNrOi8vLy4vVmlld01vZGVscy9QYWdlUHJldmlld1ZNLnRzeCIsIndlYnBhY2s6Ly8vLi9Nb2RlbHMvUHJvcGVydHlCYXIudHN4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92ZWxvY2l0eS1hbmltYXRlL3ZlbG9jaXR5LmpzIiwid2VicGFjazovLy8uL01vZGVscy9DYWxpZm9ybmlhUm91dGVyLnRzeCIsIndlYnBhY2s6Ly8vLi9UeXBld3JpdGVyL0NhbGlmb3JuaWFDbGllbnRQYXJ0aWFsRGF0YS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsU0FBUztBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsWUFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUEsZ0JBQWdCLElBQUk7O0FBRXBCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVEsNkJBQTZCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlOztBQUVmLFNBQVM7O0FBRVQ7QUFDQSxRQUFRLGlDQUFpQztBQUN6QyxRQUFRLG9CQUFvQjtBQUM1QixRQUFRLHNDQUFzQztBQUM5QyxRQUFRO0FBQ1IsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWEsRUFBRTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxVQUFVO0FBQzNFLHNDQUFzQywyQkFBMkI7QUFDakU7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLHVFQUF1RTtBQUNuRjtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0Esb0ZBQW9GOztBQUVwRjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlEQUFpRDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxVQUFVLHdDQUF3QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBLENBQUM7Ozs7QUFJRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxRQUFRLEdBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQiwwQkFBMEIsd0JBQXdCOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSwwQ0FBMEM7QUFDMUMsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0Msc0NBQXNDO0FBQzlFLG9DQUFvQyx1Q0FBdUM7QUFDM0Usb0NBQW9DLHNDQUFzQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixhQUFhO0FBQ3BDLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGdCQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdCQUFnQjtBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxjQUFjOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQXVEO0FBQzlFOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBK0Q7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUEsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdCQUFnQjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osaURBQWlELDBCQUEwQjtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFD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QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUSxtQkFBbUI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEtBQUs7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFDQUFxQzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYixLQUFLO0FBQ0w7O0FBRUEsV0FBVztBQUNYLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQixnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSxzQkFBc0I7QUFDdEIsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsc0RBQXNEO0FBQ3BFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0EsY0FBYyxtQ0FBbUM7QUFDakQsZUFBZSw2REFBNkQ7QUFDNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7QUFDRixDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFBQTtBQUNGOzs7OztBQUtBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQSxDQUFDOzs7Ozs7O0FDM25VRDtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Es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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwrREFBK0QsMkJBQTJCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFlBQVk7QUFDMUIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxJQUFJO0FBQ0o7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWEsWUFBWTtBQUN6QixhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWM7QUFDZCw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixpREFBaUQsdUNBQXVDLGtEQUFrRDtBQUMxSSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7O0FDcjlFQSxJQUFZLGVBQVo7QUFBQSxXQUFZLGVBQVosRUFBMkI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNILENBTkQsRUFBWSx3RUFBZSxFQUFmLENBQVosRTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFlBQVk7QUFDdkQ7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxjQUFjO0FBQ2QsWUFBWTtBQUNaLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtB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Rzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLCtDQUErQztBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDLFU7Ozs7Ozs7QUMvWkQ7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsaUNBQWlDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFbGpCLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBLG9FQUFvRTs7QUFFcEU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlDQUF5QztBQUMxRTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwRkFBMEYsYUFBYTtBQUN2RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1DQUFtQyxpQ0FBaUMsZUFBZSxlQUFlLGdCQUFnQixvQkFBb0IsTUFBTSwwQ0FBMEMsK0JBQStCLGFBQWEscUJBQXFCLG1DQUFtQyxFQUFFLEVBQUUsY0FBYyxXQUFXLFVBQVUsRUFBRSxVQUFVLE1BQU0seUNBQXlDLEVBQUUsVUFBVSxrQkFBa0IsRUFBRSxFQUFFLGFBQWEsRUFBRSwyQkFBMkIsMEJBQTBCLFlBQVksRUFBRSwyQ0FBMkMsOEJBQThCLEVBQUUsT0FBTyw2RUFBNkUsRUFBRSxHQUFHLEVBQUU7O0FBRXRwQixpQ0FBaUMsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFOztBQUVsakIsd0NBQXdDLG1CQUFtQiw0QkFBNEIsa0RBQWtELGdCQUFnQixrREFBa0QsOERBQThELDBCQUEwQiw0Q0FBNEMsdUJBQXVCLGtCQUFrQixFQUFFLE9BQU8sY0FBYyxnQkFBZ0IsZ0JBQWdCLGVBQWUsMkJBQTJCLG9CQUFvQixFQUFFLEVBQUUsNEJBQTRCLG1CQUFtQixFQUFFLE9BQU8sdUJBQXVCLDRCQUE0QixrQkFBa0IsRUFBRSw4QkFBOEIsRUFBRSxFQUFFOztBQUVscEIsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosMENBQTBDLCtEQUErRCxxR0FBcUcsRUFBRSx5RUFBeUUsZUFBZSx5RUFBeUUsRUFBRSxFQUFFLHVIQUF1SDs7QUFFNWU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjs7QUFFQTtBQUNBLGFBQWE7O0FBRWIsb0VBQW9FLGFBQWE7QUFDakY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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O0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnRkFBZ0Y7O0FBRWhGO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxTQUFTLHFCQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVDQUF1QztBQUN0RCxhQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkJBQTZCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxvRUFBb0U7QUFDOUU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGVBQWUsR0FBRyxlQUFlO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixFQUFFLEVBQUUsSUFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQSxPQUFPO0FBQ1AsNEZBQTRGO0FBQzVGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEUsOERBQThEO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxnSEFBZ0g7O0FBRWhIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOLHdGQUF3RjtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3RkFBd0Y7O0FBRXhGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwwQ0FBMEMsc0JBQXNCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOLHdCQUF3Qjs7QUFFeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUUsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSDtBQUMxSDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSwrR0FBK0c7QUFDL0c7QUFDQSxzSkFBc0o7O0FBRXRKO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHOztBQUV4Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsOERBQThEO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSx5QkFBeUIsMkNBQTJDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsMkNBQTJDO0FBQ3RFO0FBQ0EseUJBQXlCLGdFQUFnRTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSx1S0FBdUs7QUFDdkssMEtBQTBLO0FBQzFLLDZJQUE2STs7QUFFN0k7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RztBQUM1Rzs7QUFFQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFLDhFQUE4RTtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUU7QUFDckU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnREFBZ0QsVUFBVTtBQUMxRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLGdCQUFnQjtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU4sbUNBQW1DLDhCQUE4QjtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZELGlCQUFpQjtBQUM5RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2hxSkE7QUFDQSxJQUFNLElBQUksU0FBUyxDQUFuQjtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUEsSUFBSSxVQUFKO0FBQ0EsSUFBSSxhQUFKO0FBRUE7QUFFSSw4QkFBWSxnQkFBWixFQUEyQztBQURuQyxzQ0FBaUMsQ0FBakM7QUE4Q0QsMEJBQWEsVUFBQyxRQUFELEVBQXNDLFNBQXRDLEVBQXlELHlCQUF6RCxFQUFtRzs7QUFBN0Q7QUFBQTtBQUFpQjtBQUFFO0FBQUE7QUFBMEM7QUFFbkgsZ0JBQUksa0JBQTJCLGNBQWMsZ0JBQWQsQ0FBK0IsUUFBL0IsQ0FBL0I7QUFDQSxnQkFBSSxDQUFDLGVBQUwsRUFBc0I7QUFDbEI7QUFDSDtBQUVELGdCQUFJLG1CQUE0QixLQUFoQztBQUNBLGdCQUFJLGtCQUEyQixLQUEvQjtBQUNBLG9CQUFRLFNBQVMsZUFBakI7QUFDSSxxQkFBSyxzQ0FBZ0IsaUJBQXJCO0FBQ0ksd0JBQUksU0FBUyxhQUFULENBQXVCLFdBQXZCLEtBQXVDLFNBQTNDLEVBQXNEO0FBQ2xELDRCQUFJLDBCQUFrQyxXQUFXLFVBQVgsQ0FBc0IsaUJBQXRCLENBQXdDLFlBQXhDLENBQXFELFNBQXJELENBQStELGFBQUM7QUFBSSxxQ0FBRSxhQUFGLElBQW1CLFNBQVMsYUFBVCxDQUF1QixXQUF2QixDQUFuQjtBQUFtRSx5QkFBdkksQ0FBdEM7QUFFQSx5Q0FBVyxVQUFYLENBQXNCLGlCQUF0QixDQUF3QyxZQUF4QyxFQUFxRCxNQUFyRCxDQUEyRCxLQUEzRCxDQUEyRCxFQUEzRCxFQUEyRCxDQUFDLHVCQUFELEVBQTBCLENBQTFCLEVBQTJCLE1BQTNCLENBQWdDLENBQUMsU0FBUyxhQUFULENBQXVCLFdBQXhCLENBQWhDLENBQTNEO0FBQ0MsbUNBQVcsVUFBWCxDQUFzQixpQkFBdEIsQ0FBd0MsZUFBeEMsQ0FBd0QsSUFBeEQsQ0FBNkQsYUFBQztBQUFJLHFDQUFFLFlBQUYsSUFBa0IsU0FBUyxhQUFULENBQXVCLFdBQXZCLENBQWxCO0FBQXdFLHlCQUExSSxFQUEySixpQkFBM0osR0FBK0ssU0FBUyxhQUFULENBQXVCLFdBQXRNO0FBQ0QsMENBQWtCLElBQWxCO0FBQ0g7QUFDRDtBQUNKO0FBQ0ksdUNBQW1CLElBQW5CO0FBQ0E7QUFaUjtBQWNBLGdCQUFJLHFCQUFxQixJQUF6QixFQUErQjtBQUMzQixvQkFBSSxTQUFTLGlCQUFULEtBQStCLFNBQW5DLEVBQThDO0FBQzFDLCtCQUFXLFVBQVgsQ0FBc0IsaUJBQXRCLEdBQTBDLFNBQVMsaUJBQW5EO0FBRUEsK0JBQVcsVUFBWCxDQUFzQixhQUF0QixHQUFzQyxTQUFTLGFBQS9DO0FBQ0EsK0JBQVcsVUFBWCxDQUFzQixnQkFBdEIsR0FBeUMsU0FBUyxnQkFBbEQ7QUFHQSx3QkFBSSxTQUFTLGlCQUFULENBQTJCLGlCQUEzQixDQUE2QyxNQUE3QyxLQUF3RCxTQUF4RCxJQUFxRSxTQUFTLGlCQUFULENBQTJCLGlCQUEzQixDQUE2QyxNQUE3QyxHQUFzRCxDQUEvSCxFQUFrSTtBQUM5SCxtQ0FBVyxVQUFYLENBQXNCLGlCQUF0QixDQUF3QyxpQkFBeEMsR0FBNEQsV0FBVyxVQUFYLENBQXNCLGlCQUF0QixDQUF3QyxpQkFBeEMsQ0FBMEQsSUFBMUQsQ0FBK0QsVUFBQyxFQUFELEVBQUssRUFBTCxFQUFPO0FBQUssbUNBQUMsR0FBRyxjQUFILEtBQXNCLFNBQXRCLElBQW1DLEdBQUcsY0FBSCxLQUFzQixTQUExRCxHQUF3RSxHQUFHLGNBQUgsR0FBb0IsR0FBRyxjQUF2QixHQUF3QyxDQUFDLENBQXpDLEdBQTZDLEdBQUcsY0FBSCxJQUFxQixHQUFHLGNBQXhCLEdBQXlDLENBQXpDLEdBQTZDLENBQWxLO0FBQXdLLHlCQUFuUCxDQUE1RDtBQUNBLG1DQUFXLEtBQVgsQ0FBaUIsc0NBQWpCLEdBQTBELFdBQVcsVUFBWCxDQUFzQixpQkFBdEIsQ0FBd0MsaUJBQXhDLENBQTBELENBQTFELEVBQTZELGtCQUF2SDtBQUNBLG1DQUFXLEtBQVgsQ0FBaUIsdUNBQWpCLEdBQTJELFdBQVcsVUFBWCxDQUFzQixpQkFBdEIsQ0FBd0MsaUJBQXhDLENBQTBELFdBQVcsVUFBWCxDQUFzQixpQkFBdEIsQ0FBd0MsaUJBQXhDLENBQTBELE1BQTFELEdBQW1FLENBQTdILEVBQWdJLGtCQUEzTDtBQUNBLG1DQUFXLEtBQVgsQ0FBaUIsc0JBQWpCLEdBQTBDLFdBQVcsVUFBWCxDQUFzQixpQkFBdEIsQ0FBd0MsaUJBQXhDLENBQTBELENBQTFELEVBQTZELGtCQUF2RztBQUNBLDRCQUFJLFNBQUosRUFBZTtBQUNYLGlDQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksV0FBVyxZQUFYLENBQXdCLE1BQTVDLEVBQW9ELEdBQXBELEVBQXlEO0FBQ3JELG9DQUFJLGNBQTJCLFdBQVcsWUFBWCxDQUF3QixDQUF4QixDQUEvQjtBQUNBLDRDQUFZLFNBQVosQ0FBc0IsNkJBQXRCLENBQW9ELFdBQVcsS0FBWCxDQUFpQixzQkFBckUsRUFBNkYsSUFBN0Y7QUFDSDtBQUNKO0FBRUQsNEJBQUksV0FBVyxXQUFYLENBQXVCLGlCQUF2QixDQUF5QyxNQUF6QyxJQUFtRCxDQUF2RCxFQUEwRDtBQUN0RCx1Q0FBVyxXQUFYLENBQXVCLGlCQUF2QixHQUEyQyxFQUEzQztBQUNBLHVDQUFXLFdBQVgsQ0FBdUIsdUJBQXZCLEdBQWlELEVBQWpEO0FBQ0EsaUNBQTZCLDRCQUFXLFVBQVgsQ0FBc0IsaUJBQXRCLENBQXdDLGlCQUFyRSxFQUE2QixjQUE3QixFQUE2QixJQUE3QixFQUF3RjtBQUFuRixvQ0FBSSxtQkFBZ0IsTUFBcEI7QUFDRCwyQ0FBVyxXQUFYLENBQXVCLGlCQUF2QixDQUF5QyxJQUF6QyxDQUE4QyxFQUE5QztBQUNBLDJDQUFXLFdBQVgsQ0FBdUIsdUJBQXZCLENBQStDLElBQS9DLENBQW9ELEVBQXBEO0FBQ0g7QUFDSjtBQUNKO0FBQ0Qsd0JBQUksY0FBYyxJQUFsQixFQUF3QjtBQUNwQixtQ0FBVyxVQUFYLENBQXNCLGdCQUF0QixHQUF5QyxTQUFTLGdCQUFsRDtBQUNBLG1DQUFXLFVBQVgsQ0FBc0IsMkJBQXRCLEdBQW9ELFNBQVMsMkJBQTdEO0FBQ0EsbUNBQVcsVUFBWCxDQUFzQixlQUF0QixHQUF3QyxTQUFTLGVBQWpEO0FBQ0g7QUFFRCx3QkFBSSxXQUFXLFVBQVgsQ0FBc0IsaUJBQXRCLENBQXdDLGFBQXhDLEtBQTBELFNBQTFELElBQ0EsV0FBVyxVQUFYLENBQXNCLGlCQUF0QixDQUF3QyxVQUF4QyxLQUF1RCxTQUR2RCxJQUVBLFdBQVcsVUFBWCxDQUFzQixpQkFBdEIsQ0FBd0MsY0FBeEMsS0FBMkQsU0FGM0QsSUFHQSxXQUFXLFVBQVgsQ0FBc0IsaUJBQXRCLENBQXdDLGVBQXhDLEtBQTRELFNBSDVELElBSUEsV0FBVyxVQUFYLENBQXNCLGlCQUF0QixDQUF3QyxlQUF4QyxLQUE0RCxTQUo1RCxJQUtBLFdBQVcsVUFBWCxDQUFzQixpQkFBdEIsQ0FBd0MsZUFBeEMsQ0FBd0QsTUFBeEQsR0FBaUUsQ0FMckUsRUFLd0U7QUFFcEUsc0NBQWMsdUNBQWQ7QUFDQSxtQ0FBVyxLQUFYLENBQWlCLGtCQUFqQixHQUFzQyxXQUFXLFVBQVgsQ0FBc0IsaUJBQXRCLENBQXdDLGVBQXhDLENBQXdELElBQXhELENBQTZELGFBQUM7QUFBSSxxQ0FBRSxVQUFGLEtBQWlCLElBQWpCLElBQXlCLEVBQUUsSUFBRixLQUF6QjtBQUErRCx5QkFBakksQ0FBdEM7QUFDQSw0QkFBSSxXQUFXLEtBQVgsQ0FBaUIsa0JBQWpCLEtBQXdDLFNBQTVDLEVBQXVEO0FBQ25ELG9DQUFRLEdBQVIsQ0FBWSxpQ0FBWjtBQUNBO0FBQ0g7QUFDRCxtQ0FBVyxVQUFYLENBQXNCLGlCQUF0QixDQUF3QyxlQUF4QyxDQUF3RCxNQUF4RCxDQUErRCxhQUFDO0FBQUksb0NBQUMsRUFBRDtBQUFhLHlCQUFqRixFQUFtRixHQUFuRixDQUF1RixhQUFDO0FBQ3BGLGdDQUFJLFdBQVcsS0FBWCxDQUFpQixrQkFBakIsS0FBd0MsU0FBNUMsRUFBdUQ7QUFDbkQsb0NBQUksK0JBQTBDLFdBQVcsS0FBWCxDQUFpQixrQkFBakIsQ0FBb0MsZ0JBQXBDLENBQXFELElBQXJELENBQTBELHFCQUFTO0FBQzdHLHdDQUFJLGdCQUErQixXQUFXLFVBQVgsQ0FBc0IsaUJBQXRCLENBQXdDLGNBQXhDLENBQXVELElBQXZELENBQTRELGFBQUM7QUFBSSxpREFBRSxnQkFBRixJQUFzQixVQUF0QjtBQUE0QyxxQ0FBN0csQ0FBbkM7QUFDQSx3Q0FBSSxjQUFjLElBQWQsS0FBdUIsZ0JBQWMsRUFBRSxJQUFoQixHQUFvQixhQUEvQyxFQUE4RDtBQUMxRCwwQ0FBRSwrQkFBRixHQUFvQyxjQUFjLGVBQWxEO0FBQ0EsK0NBQU8sSUFBUDtBQUNIO0FBQ0QsMkNBQU8sS0FBUDtBQUNILGlDQVA2QyxDQUE5QztBQVFBLG9DQUFJLG1DQUE4QyxXQUFXLEtBQVgsQ0FBaUIsa0JBQWpCLENBQW9DLGdCQUFwQyxDQUFxRCxJQUFyRCxDQUEwRCxxQkFBUztBQUNqSCx3Q0FBSSxnQkFBK0IsV0FBVyxVQUFYLENBQXNCLGlCQUF0QixDQUF3QyxjQUF4QyxDQUF1RCxJQUF2RCxDQUE0RCxhQUFDO0FBQUksaURBQUUsZ0JBQUYsSUFBc0IsVUFBdEI7QUFBNEMscUNBQTdHLENBQW5DO0FBQ0Esd0NBQUksY0FBYyxJQUFkLEtBQXVCLGdCQUFjLEVBQUUsSUFBaEIsR0FBb0IsYUFBL0MsRUFBOEQ7QUFDMUQsMENBQUUsK0JBQUYsR0FBb0MsY0FBYyxlQUFsRDtBQUNBLCtDQUFPLElBQVA7QUFDSDtBQUNELDJDQUFPLEtBQVA7QUFDSCxpQ0FQaUQsQ0FBbEQ7QUFRQSxvQ0FBSSxtQ0FBOEMsV0FBVyxLQUFYLENBQWlCLGtCQUFqQixDQUFvQyxnQkFBcEMsQ0FBcUQsSUFBckQsQ0FBMEQscUJBQVM7QUFDakgsd0NBQUksZ0JBQStCLFdBQVcsVUFBWCxDQUFzQixpQkFBdEIsQ0FBd0MsY0FBeEMsQ0FBdUQsSUFBdkQsQ0FBNEQsYUFBQztBQUFJLGlEQUFFLGdCQUFGLElBQXNCLFVBQXRCO0FBQTRDLHFDQUE3RyxDQUFuQztBQUNBLHdDQUFJLGNBQWMsSUFBZCxLQUF1QixnQkFBYyxFQUFFLElBQWhCLEdBQW9CLGFBQS9DLEVBQThEO0FBQzFELDBDQUFFLCtCQUFGLEdBQW9DLGNBQWMsZUFBbEQ7QUFDQSwrQ0FBTyxJQUFQO0FBQ0g7QUFDRCwyQ0FBTyxLQUFQO0FBQ0gsaUNBUGlELENBQWxEO0FBUUEsa0NBQUUscUNBQUYsR0FBMEMsRUFBRSwrQkFBRixDQUFrQyxRQUFsQyxFQUExQztBQUNBLGtDQUFFLDJCQUFGLEdBQWdDLE1BQUksRUFBRSxxQ0FBdEM7QUFDQSxrQ0FBRSxxQ0FBRixHQUEwQyxFQUFFLCtCQUFGLENBQWtDLFFBQWxDLEVBQTFDO0FBQ0Esa0NBQUUsMkJBQUYsR0FBZ0MsTUFBSSxFQUFFLHFDQUF0QztBQUNBLGtDQUFFLHFDQUFGLEdBQTBDLEVBQUUsK0JBQUYsQ0FBa0MsUUFBbEMsRUFBMUM7QUFDQSxrQ0FBRSwyQkFBRixHQUFnQyxNQUFJLEVBQUUscUNBQXRDO0FBQ0gsNkJBL0JELE1BZ0NLO0FBQ0Qsa0NBQUUsMkJBQUYsR0FBZ0MsRUFBaEM7QUFDQSxrQ0FBRSwyQkFBRixHQUFnQyxFQUFoQztBQUNBLGtDQUFFLDJCQUFGLEdBQWdDLEVBQWhDO0FBQ0g7QUFDSix5QkF0Q0Q7QUF3Q0EsNEJBQUksd0JBQXdDLFdBQVcsVUFBWCxDQUFzQixpQkFBdEIsQ0FBd0MsZUFBeEMsQ0FBd0QsSUFBeEQsQ0FBNkQsZ0JBQUk7QUFBSSx3Q0FBSyxVQUFMLElBQW1CLEtBQUssSUFBTCxLQUFuQjtBQUF1RSx5QkFBNUksQ0FBNUM7QUFDQSw0QkFBSSx1QkFBdUMsV0FBVyxVQUFYLENBQXNCLGlCQUF0QixDQUF3QyxlQUF4QyxDQUF3RCxJQUF4RCxDQUE2RCxnQkFBSTtBQUFJLHdDQUFLLFVBQUwsSUFBbUIsS0FBSyxJQUFMLEtBQW5CO0FBQXNFLHlCQUEzSSxDQUEzQztBQUNBLHNDQUFjLHlCQUFkLENBQXdDLFdBQVcsYUFBWCxDQUF5QixzQkFBekIsSUFBbUQsQ0FBbkQsR0FBdUQsV0FBVyxhQUFYLENBQXlCLHNCQUFoRixHQUF5RyxDQUFqSixFQUFvSixJQUFwSixFQUEwSixTQUExSjtBQUNBLDZCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksV0FBVyxZQUFYLENBQXdCLE1BQTVDLEVBQW9ELEdBQXBELEVBQXlEO0FBQ3JELHVDQUFXLFlBQVgsQ0FBd0IsQ0FBeEIsRUFBMkIsU0FBM0IsQ0FBcUMsVUFBckMsQ0FBZ0QsV0FBVyxVQUFYLENBQXNCLGlCQUF0QixDQUF3QyxhQUF4RixFQUNJLFdBQVcsVUFBWCxDQUFzQixpQkFBdEIsQ0FBd0MsVUFENUMsRUFFSSxXQUFXLFVBQVgsQ0FBc0IsaUJBQXRCLENBQXdDLGNBRjVDLEVBR0ksV0FBVyxVQUFYLENBQXNCLGlCQUF0QixDQUF3QyxlQUg1QyxFQUlJLFdBQVcsVUFBWCxDQUFzQixpQkFBdEIsQ0FBd0MsZUFKNUMsRUFLSSxxQkFMSixFQU1JLG9CQU5KO0FBT0g7QUFDRCw0QkFBSSxhQUFzQixxQkFBcUIsZ0JBQXJCLENBQXNDLENBQXRDLENBQTFCO0FBQ0EsbUNBQVcsS0FBWCxDQUFpQixxQkFBakIsR0FBMEMsV0FBVyxVQUFYLENBQXNCLGlCQUF0QixDQUF3QyxjQUF4QyxDQUF1RCxJQUF2RCxDQUE0RCxhQUFDO0FBQUkscUNBQUUsZ0JBQUYsSUFBc0IsV0FBUyxnQkFBVCxDQUEwQixDQUExQixFQUF0QjtBQUErRCx5QkFBaEksRUFBb0osZUFBOUw7QUFDSCxxQkFuRUQsTUFvRUs7QUFDRCxtQ0FBVyxLQUFYLENBQWlCLGtCQUFqQixHQUFzQyxTQUF0QztBQUNBLGdDQUFRLEdBQVIsQ0FBWSxpQ0FBWjtBQUVIO0FBRUQsd0JBQUksY0FBYyxJQUFsQixFQUF3QjtBQUNwQiw0QkFBSSxJQUFZLENBQWhCO0FBQ0EsNEJBQUksSUFBSSxXQUFXLGdCQUFuQixFQUFxQztBQUNqQyx1Q0FBVyxjQUFYLENBQTBCLEdBQTFCLEVBQStCLHNCQUEvQixHQUF3RCxnQ0FBZ0IsY0FBeEU7QUFDQSxnQ0FBSSxJQUFJLFdBQVcsZ0JBQW5CLEVBQXFDO0FBQ2pDLDJDQUFXLGNBQVgsQ0FBMEIsR0FBMUIsRUFBK0Isc0JBQS9CLEdBQXdELGdDQUFnQixrQkFBeEU7QUFDQSxvQ0FBSSxJQUFJLFdBQVcsZ0JBQW5CLEVBQXFDO0FBQ2pDLCtDQUFXLGNBQVgsQ0FBMEIsR0FBMUIsRUFBK0Isc0JBQS9CLEdBQXdELGdDQUFnQixhQUF4RTtBQUNBLHdDQUFJLElBQUksV0FBVyxnQkFBbkIsRUFBcUM7QUFDakMsbURBQVcsY0FBWCxDQUEwQixHQUExQixFQUErQixzQkFBL0IsR0FBd0QsZ0NBQWdCLGdCQUF4RTtBQUNIO0FBQ0o7QUFDSjtBQUNKO0FBQ0o7QUFFRCxrQ0FBYyxnQkFBZDtBQUVBLHNDQUFrQixJQUFsQjtBQUNIO0FBQ0o7QUFFRCxnQkFBSSxvQkFBb0IsS0FBeEIsRUFBK0I7QUFDM0Isd0JBQVEsR0FBUixDQUFZLHFCQUFaO0FBQ0EseUJBQVMsTUFBVDtBQUNIO0FBQ0QsdUJBQVcsS0FBWCxDQUFpQixZQUFqQixHQUFnQyxJQUFoQztBQUNBLGdCQUFJLENBQUMseUJBQUwsRUFBZ0M7QUFDNUIsMkJBQVcsU0FBWCxDQUFxQixjQUFyQjtBQUNIO0FBQ0osU0FsS007QUFvTkMsdURBQTBDO0FBRTlDLGdCQUFJLFVBQTZCLFdBQVcsVUFBWCxDQUFzQixpQkFBdkQ7QUFDQSxnQkFBSSxVQUF1QixFQUEzQjtBQUNBLGdCQUFJLFdBQXdCLEVBQTVCO0FBQ0EsZ0JBQUksV0FBeUIsRUFBN0I7QUFDQSxvQkFBUSxlQUFSLENBQXdCLEdBQXhCLENBQTRCLGVBQUc7QUFDM0Isd0JBQVEsSUFBSSxVQUFaO0FBQ0kseUJBQUssaUNBQVcsR0FBaEI7QUFDSSxnQ0FBUSxJQUFSLENBQWEsR0FBYjtBQUNBO0FBQ0oseUJBQUssaUNBQVcsR0FBaEI7QUFDSSxpQ0FBUyxJQUFULENBQWMsR0FBZDtBQUNBO0FBQ0oseUJBQUssaUNBQVcsSUFBaEI7QUFDSSxpQ0FBUyxJQUFULENBQWMsR0FBZDtBQUNBO0FBQ0o7QUFDSSxnQ0FBUSxHQUFSLENBQVksaUNBQVo7QUFDQTtBQVpSO0FBY0gsYUFmRDtBQWdCQSxnQkFBSSxrQkFBaUMsUUFBUSxZQUE3QztBQUNBLGdCQUFJLGtCQUE0QyxRQUFRLHVCQUF4RDtBQUdBLG9CQUFRLGVBQVIsQ0FBd0IsR0FBeEIsQ0FBNEIsZ0JBQUk7QUFDNUIscUJBQUssZ0JBQUwsR0FBd0IsUUFBUSxNQUFSLENBQWUsZUFBRztBQUFJLCtCQUFJLGNBQUosSUFBc0IsS0FBdEI7QUFBMkMsaUJBQWpFLEVBQW1FLElBQW5FLENBQXdFLFVBQUMsSUFBRCxFQUFrQixJQUFsQixFQUFpQztBQUM3SCx3QkFBSSxLQUFLLGtCQUFMLEdBQTBCLEtBQUssa0JBQW5DLEVBQXVEO0FBQ25ELCtCQUFPLENBQUMsQ0FBUjtBQUNILHFCQUZELE1BR0ssSUFBSSxLQUFLLGtCQUFMLElBQTJCLEtBQUssa0JBQXBDLEVBQXdEO0FBQ3pELCtCQUFPLENBQVA7QUFDSCxxQkFGSSxNQUdBO0FBQ0QsK0JBQU8sQ0FBUDtBQUNIO0FBQ0osaUJBVnVCLENBQXhCO0FBV0gsYUFaRDtBQWFBLGdCQUFJLDBCQUFrQyxDQUF0QztBQUNBLG9CQUFRLGVBQVIsQ0FBd0IsR0FBeEIsQ0FBNEIsZ0JBQUk7QUFDNUIsMENBQTBCLENBQTFCOytDQUNTLEksRUFBSTtBQUNULGtDQUFjLHNCQUFkLEdBQXVDLENBQXZDO0FBQ0Esd0JBQUksTUFBaUIsS0FBSyxnQkFBTCxDQUFzQixJQUF0QixDQUFyQjtBQUNBLHdCQUFJLGdCQUFKLEdBQXVCLFNBQVMsTUFBVCxDQUFnQixlQUFHO0FBQUksbUNBQUksYUFBSixJQUFxQixJQUFJLFlBQXpCLElBQXlDLElBQUksZ0JBQUosSUFBekM7QUFBMEUscUJBQWpHLENBQXZCO0FBQ0Esd0JBQUksZ0JBQUosQ0FBcUIsR0FBckIsQ0FBeUIsZUFBRztBQUN4QixzQ0FBYyxtQ0FBZCxDQUFrRCxDQUFsRCxFQUFxRCxHQUFyRCxFQUEwRCxHQUExRCxFQUErRCxRQUEvRCxFQUF5RSxRQUF6RSxFQUFtRixlQUFuRixFQUFvRyxlQUFwRztBQUNBLDRCQUFJLFdBQUosR0FBa0IsR0FBbEI7QUFDSCxxQkFIRDtBQUlBLHdCQUFJLFlBQUosR0FBbUIsY0FBYyxzQkFBakM7QUFDQSx3QkFBSSxjQUFjLHNCQUFkLEdBQXVDLHVCQUEzQyxFQUFvRTtBQUNoRSxrREFBMEIsY0FBYyxzQkFBeEM7QUFDSDtBQUNKLGlCO0FBWkQscUJBQUssSUFBSSxPQUFlLENBQXhCLEVBQTJCLE9BQU8sS0FBSyxnQkFBTCxDQUFzQixNQUF4RCxFQUFnRSxNQUFoRSxFQUFzRTs0QkFBN0QsSTtBQVlSO0FBQ0QscUJBQUssWUFBTCxHQUFvQix1QkFBcEI7QUFDSCxhQWhCRDtBQXNCSCxTQTlETztBQWdFQSxtREFBc0MsVUFBQyxRQUFELEVBQW1CLEdBQW5CLEVBQW1DLFdBQW5DLEVBQTJELFFBQTNELEVBQWtGLFFBQWxGLEVBQTBHLGVBQTFHLEVBQTBJLGVBQTFJLEVBQW1MOztBQUM3TixnQkFBSSxLQUFKLEdBQVksUUFBWjtBQUNBLGdCQUFJLGdCQUFKLEdBQXVCLFNBQVMsTUFBVCxDQUFnQixrQkFBTTtBQUFJLDhCQUFPLGdCQUFQLEtBQTRCLFNBQTVCLElBQXlDLE9BQU8sZ0JBQVAsSUFBMkIsSUFBcEU7QUFBb0YsYUFBOUcsQ0FBdkI7QUFDQSxnQkFBSSxnQkFBSixDQUFxQixHQUFyQixDQUF5QixrQkFBTTtBQUMzQiw4QkFBYyxtQ0FBZCxDQUFrRCxXQUFXLENBQTdELEVBQWdFLE1BQWhFLEVBQXdFLFdBQXhFLEVBQXFGLFFBQXJGLEVBQStGLFFBQS9GLEVBQXlHLGVBQXpHLEVBQTBILGVBQTFIO0FBQ0EsdUJBQU8sV0FBUCxHQUFxQixXQUFyQjtBQUNBLHVCQUFPLGNBQVAsR0FBd0IsR0FBeEI7QUFDSCxhQUpEO0FBS0EsOEJBQVksZ0JBQVosRUFBNkIsSUFBN0IsQ0FBaUMsS0FBakMsQ0FBaUMsRUFBakMsRUFBcUMsSUFBSSxnQkFBekM7QUFDQSxnQkFBSSxnQkFBSixHQUF1QixTQUFTLE1BQVQsQ0FBZ0IsbUJBQU87QUFBSSwrQkFBUSxpQkFBUixLQUE4QixTQUE5QixJQUEyQyxRQUFRLGlCQUFSLElBQTZCLElBQXhFO0FBQXdGLGFBQW5ILENBQXZCO0FBQ0EsZ0JBQUksZ0JBQUosQ0FBcUIsR0FBckIsQ0FBeUIsbUJBQU87QUFDNUIsd0JBQVEsaUJBQVIsR0FBNEIsZ0JBQWdCLElBQWhCLENBQXFCLHVCQUFXO0FBQUksdUNBQVksbUJBQVosSUFBbUMsUUFBbkM7QUFBdUQsaUJBQTNGLENBQTVCO0FBQ0Esd0JBQVEsZUFBUixHQUEwQixHQUExQjtBQUNBLHdCQUFRLHVCQUFSLEdBQWtDLGdCQUFnQixNQUFoQixDQUF1QixlQUFHO0FBQUksK0JBQUksWUFBSixJQUFvQixRQUFwQjtBQUF3QyxpQkFBdEUsQ0FBbEM7QUFDQSx3QkFBUSxLQUFSLEdBQWdCLFdBQVcsQ0FBM0I7QUFDSCxhQUxEO0FBTUEsZ0JBQUksSUFBSSxnQkFBSixDQUFxQixNQUFyQixHQUE4QixDQUFsQyxFQUFxQztBQUNqQyxvQkFBSyxXQUFXLENBQVosR0FBaUIsY0FBYyxzQkFBbkMsRUFBMkQ7QUFDdkQsa0NBQWMsc0JBQWQsR0FBdUMsV0FBVyxDQUFsRDtBQUNIO0FBQ0osYUFKRCxNQUtLLElBQUksV0FBVyxjQUFjLHNCQUE3QixFQUFxRDtBQUN0RCw4QkFBYyxzQkFBZCxHQUF1QyxRQUF2QztBQUNIO0FBQ0osU0F4Qk87QUEwQkQsZ0NBQW1CO0FBRXRCLGdCQUFJLHNCQUEwQyxFQUFFLE1BQUYsRUFBVSxNQUFWLEVBQTlDO0FBQ0EsZ0JBQUksd0JBQXdCLFNBQTVCLEVBQXVDO0FBQ25DLHdCQUFRLEdBQVIsQ0FBWSxpQ0FBWjtBQUNBO0FBQ0g7QUFDRCxxQkFBUyxJQUFULENBQWMsS0FBZCxDQUFvQixNQUFwQixHQUFnQyxzQkFBbUIsSUFBbkQ7QUFFQSxnQkFBSSxXQUFXLEtBQVgsQ0FBaUIsbUJBQWpCLEtBQXlDLElBQXpDLElBQWlELFdBQVcsS0FBWCxDQUFpQixZQUFqQixLQUFrQywyQkFBYSxlQUFwRyxFQUFxSDtBQUVqSCwyQkFBVyxLQUFYLENBQWlCLDJCQUFqQixHQUErQyxXQUFXLGlCQUFYLEtBQWlDLFNBQWpDLEdBQTZDLE9BQU8sVUFBUCxHQUFvQixJQUFJLFdBQVcsS0FBWCxDQUFpQiwrQkFBdEYsR0FBd0gsQ0FBdks7QUFDSCxhQUhELE1BSUs7QUFDRCwyQkFBVyxLQUFYLENBQWlCLDJCQUFqQixHQUErQyxXQUFXLGlCQUFYLEtBQWlDLFNBQWpDLEdBQTZDLFdBQVcsaUJBQVgsQ0FBNkIsV0FBN0IsR0FBNEMsSUFBSSxXQUFXLEtBQVgsQ0FBaUIsK0JBQTlHLEdBQWlKLENBQWhNO0FBQ0g7QUFDRCxnQkFBSSxXQUFXLFVBQVgsQ0FBc0IsaUJBQXRCLEtBQTRDLFNBQTVDLElBQXlELFdBQVcsVUFBWCxDQUFzQixpQkFBdEIsQ0FBd0MsaUJBQXhDLEtBQThELFNBQXZILElBQW9JLFdBQVcsVUFBWCxDQUFzQixpQkFBdEIsQ0FBd0MsaUJBQXhDLENBQTBELE1BQTFELEdBQW1FLENBQTNNLEVBQThNO0FBQzFNLG9CQUFJLFdBQVcsYUFBWCxDQUF5QixrQkFBekIsSUFBK0MsQ0FBbkQsRUFBc0Q7QUFFbEQsK0JBQVcsV0FBWCxDQUF1QiwyQkFBdkI7QUFDSDtBQUNKO0FBQ0osU0F0Qk07QUF3QkMsZ0NBQW1CLFVBQUMsUUFBRCxFQUFvQztBQUUzRCxnQkFBSSxZQUFZLElBQWhCLEVBQXNCO0FBQ2xCLHdCQUFRLEdBQVIsQ0FBWSxxQkFBWjtBQUNBLHVCQUFPLEtBQVA7QUFDSCxhQUhELE1BR08sSUFBSSxTQUFTLFVBQVQsS0FBd0IsSUFBeEIsSUFBZ0MsU0FBUyxVQUFULEtBQXdCLEVBQTVELEVBQWdFO0FBQ25FLHdCQUFRLEdBQVIsQ0FBWSxTQUFTLFVBQXJCO0FBQ0EsdUJBQU8sS0FBUDtBQUNIO0FBRUQsZ0JBQUssV0FBVyxVQUFYLEtBQTBCLFNBQTNCLElBQTBDLFNBQVMsZUFBVCxHQUEyQixXQUFXLFVBQVgsQ0FBc0IsZUFBL0YsRUFBaUg7QUFDN0csd0JBQVEsR0FBUixDQUFZLHlDQUFaO0FBRUEsdUJBQU8sS0FBUDtBQUNIO0FBQ0QsbUJBQU8sSUFBUDtBQUNILFNBaEJPO0FBbFhKLHdCQUFnQixJQUFoQjtBQUNBLHFCQUFhLGdCQUFiO0FBQ0g7QUFBQTtBQThNTSw2REFBUCxVQUFtQyxtQkFBbkMsRUFBaUUsK0JBQWpFLEVBQXdHO0FBRXBHLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxXQUFXLFlBQVgsQ0FBd0IsTUFBNUMsRUFBb0QsR0FBcEQsRUFBeUQ7QUFDckQsdUJBQVcsWUFBWCxDQUF3QixDQUF4QixFQUEyQixTQUEzQixDQUFxQywyQkFBckMsQ0FBaUUsbUJBQWpFLEVBQXNGLCtCQUF0RjtBQUNIO0FBQ0osS0FMTTtBQUtOO0FBRU0sMkRBQVAsVUFBaUMsZ0JBQWpDLEVBQTJELGVBQTNELEVBQXFGLG9CQUFyRixFQUFrSDtBQUM5RyxZQUFJLFlBQThCLFdBQVcsVUFBWCxDQUFzQixpQkFBdEIsQ0FBd0MsZUFBeEMsQ0FBd0QsTUFBeEQsQ0FBK0QsZ0JBQUk7QUFBSSxvQkFBQyxLQUFEO0FBQWdCLFNBQXZGLENBQWxDO0FBQ0EsWUFBSSxhQUF5QyxTQUE3QztBQUNBLFlBQUksa0JBQTBCLENBQUMsQ0FBL0I7QUFDQSxZQUFJLG9CQUFvQixDQUF4QixFQUEyQjtBQUN2Qiw4QkFBa0IsVUFBVSxTQUFWLENBQW9CLGFBQUM7QUFBSSx5QkFBRSxnQkFBRjtBQUFzQyxhQUEvRCxDQUFsQjtBQUNIO0FBQ0QsWUFBSSxtQkFBbUIsQ0FBQyxDQUFwQixJQUF5QixvQkFBb0IsSUFBakQsRUFBdUQ7QUFDbkQsOEJBQWtCLFVBQVUsU0FBVixDQUFvQixhQUFDO0FBQUkseUJBQUUsSUFBRjtBQUFpQixhQUExQyxDQUFsQjtBQUNIO0FBQ0QsWUFBSSxrQkFBa0IsQ0FBQyxDQUF2QixFQUEwQjtBQUN0Qix5QkFBYSxVQUFVLGVBQVYsQ0FBYjtBQUNBLDBCQUFjLHVCQUFkLENBQXNDLFVBQXRDO0FBQ0EsZ0JBQUkseUJBQXlCLElBQTdCLEVBQW1DO0FBQy9CLHFCQUFLLElBQUksSUFBWSxDQUFyQixFQUF3QixJQUFJLFdBQVcsWUFBWCxDQUF3QixNQUFwRCxFQUE0RCxHQUE1RCxFQUFpRTtBQUM3RCwrQkFBVyxZQUFYLENBQXdCLENBQXhCLEVBQTJCLFNBQTNCLENBQXFDLHlCQUFyQyxDQUErRCxVQUEvRCxFQUEyRSxJQUEzRTtBQUNIO0FBQ0osYUFKRCxNQUtLO0FBRUQsMkJBQVcsWUFBWCxDQUF3QixDQUF4QixFQUEyQixTQUEzQixDQUFxQyx5QkFBckMsQ0FBK0QsVUFBL0QsRUFBMkUsSUFBM0U7K0NBQ1MsQyxFQUFDO0FBQ04sd0JBQUksb0JBQTRCLFdBQVcsWUFBWCxDQUF3QixDQUF4QixFQUEyQixTQUEzQixDQUFxQyx3QkFBckU7QUFDQSx3QkFBSSxxQkFBcUIsQ0FBekIsRUFBNEI7QUFDeEIsNEJBQUksa0JBQWtDLFVBQVUsSUFBVixDQUFlLGFBQUM7QUFBSSxxQ0FBRSxnQkFBRjtBQUF3Qyx5QkFBNUQsQ0FBdEM7QUFDQSxtQ0FBVyxZQUFYLENBQXdCLENBQXhCLEVBQTJCLFNBQTNCLENBQXFDLHlCQUFyQyxDQUErRCxlQUEvRCxFQUFnRixJQUFoRjtBQUNIO0FBQ0osaUI7QUFORCxxQkFBSyxJQUFJLElBQVksQ0FBckIsRUFBd0IsSUFBSSxXQUFXLFlBQVgsQ0FBd0IsTUFBcEQsRUFBNEQsR0FBNUQsRUFBK0Q7NEJBQXRELEM7QUFNUjtBQUNKO0FBQ0osU0FuQkQsTUFvQks7QUFDRCxvQkFBUSxHQUFSLENBQVksaUNBQVo7QUFDSDtBQUNKLEtBakNNO0FBaUNOO0FBRU0seURBQVAsVUFBK0IsY0FBL0IsRUFBNkQ7QUFDekQsbUJBQVcsV0FBWCxDQUF1QixTQUF2QixDQUFpQyxzQkFBakMsR0FBMEQsZUFBZSxnQkFBekU7QUFDQSxtQkFBVyxhQUFYLENBQXlCLHVCQUF6QixDQUFpRCxHQUFqRCxDQUFxRCxDQUFDLGNBQUQsQ0FBckQ7QUFDQSxtQkFBVyxhQUFYLENBQXlCLHdCQUF6QixDQUFrRCxHQUFsRCxDQUFzRCxlQUFlLGdCQUFyRTtBQUNILEtBSk07QUFJTjtBQXFJTDtBQUFDLENBdFlEO0FBQWEsNEM7Ozs7Ozs7Ozs7O0FDYmI7QUFBQSw0Q0FFQztBQUFEO0FBQUMsQ0FGRDtBQUFhLGtFIiwiZmlsZSI6ImNhbGlmb3JuaWFjbGllbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvYXNzZXRzL1wiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDgpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDQ1Y2E3OGU1ZmM0MmUxNWY2ZjI5IiwiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjMuMVxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTgtMDEtMjBUMTc6MjRaXG4gKi9cbiggZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSApKCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIEVkZ2UgPD0gMTIgLSAxMyssIEZpcmVmb3ggPD0xOCAtIDQ1KywgSUUgMTAgLSAxMSwgU2FmYXJpIDUuMSAtIDkrLCBpT1MgNiAtIDkuMVxuLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG4vLyBhcmd1bWVudHMuY2FsbGVlLmNhbGxlciAodHJhYy0xMzMzNSkuIEJ1dCBhcyBvZiBqUXVlcnkgMy4wICgyMDE2KSwgc3RyaWN0IG1vZGUgc2hvdWxkIGJlIGNvbW1vblxuLy8gZW5vdWdoIHRoYXQgYWxsIHN1Y2ggYXR0ZW1wdHMgYXJlIGd1YXJkZWQgaW4gYSB0cnkgYmxvY2suXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFyciA9IFtdO1xuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgY29uY2F0ID0gYXJyLmNvbmNhdDtcblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oIG9iaiApIHtcblxuICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NTcsIEZpcmVmb3ggPD01MlxuICAgICAgLy8gSW4gc29tZSBicm93c2VycywgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIDxvYmplY3Q+IGVsZW1lbnRzXG4gICAgICAvLyAoaS5lLiwgYHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9iamVjdFwiICkgPT09IFwiZnVuY3Rpb25cImApLlxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBjbGFzc2lmeSAqYW55KiBET00gbm9kZSBhcyBhIGZ1bmN0aW9uLlxuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9PSBcIm51bWJlclwiO1xuICB9O1xuXG5cbnZhciBpc1dpbmRvdyA9IGZ1bmN0aW9uIGlzV2luZG93KCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fTtcblxuXG5cblxuXHR2YXIgcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyA9IHtcblx0XHR0eXBlOiB0cnVlLFxuXHRcdHNyYzogdHJ1ZSxcblx0XHRub01vZHVsZTogdHJ1ZVxuXHR9O1xuXG5cdGZ1bmN0aW9uIERPTUV2YWwoIGNvZGUsIGRvYywgbm9kZSApIHtcblx0XHRkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG5cblx0XHR2YXIgaSxcblx0XHRcdHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCBcInNjcmlwdFwiICk7XG5cblx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0aWYgKCBub2RlICkge1xuXHRcdFx0Zm9yICggaSBpbiBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzICkge1xuXHRcdFx0XHRpZiAoIG5vZGVbIGkgXSApIHtcblx0XHRcdFx0XHRzY3JpcHRbIGkgXSA9IG5vZGVbIGkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRkb2MuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdH1cblxuXG5mdW5jdGlvbiB0b1R5cGUoIG9iaiApIHtcblx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seSAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0dHlwZW9mIG9iajtcbn1cbi8qIGdsb2JhbCBTeW1ib2wgKi9cbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxuXG5cblxudmFyXG5cdHZlcnNpb24gPSBcIjMuMy4xXCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2c7XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cblx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0aWYgKCBudW0gPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdHJldHVybiBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFpc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG5cdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICkge1xuXHRcdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIEFycmF5LmlzQXJyYXkoIHNyYyApID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXG5cdFx0LyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzbGludC9lc2xpbnQvaXNzdWVzLzYxMjVcblx0XHR2YXIgbmFtZTtcblxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSApIHtcblx0XHRET01FdmFsKCBjb2RlICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSB0b1R5cGUoIG9iaiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjNcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTA4LTA4XG4gKi9cbihmdW5jdGlvbiggd2luZG93ICkge1xuXG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cblx0cmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoIFwiPVwiICsgd2hpdGVzcGFjZSArIFwiKihbXlxcXFxdJ1xcXCJdKj8pXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIiwgXCJnXCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXG5cdC8vIENTUyBlc2NhcGVzXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0ZXNjYXBlZCA6XG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcblx0cmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLFxuXHRmY3NzZXNjYXBlID0gZnVuY3Rpb24oIGNoLCBhc0NvZGVQb2ludCApIHtcblx0XHRpZiAoIGFzQ29kZVBvaW50ICkge1xuXG5cdFx0XHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcblx0XHRcdGlmICggY2ggPT09IFwiXFwwXCIgKSB7XG5cdFx0XHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcblx0XHRcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFwiXFxcXFwiICsgY2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuXHRcdHJldHVybiBcIlxcXFxcIiArIGNoO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9LFxuXG5cdGRpc2FibGVkQW5jZXN0b3IgPSBhZGRDb21iaW5hdG9yKFxuXHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgKFwiZm9ybVwiIGluIGVsZW0gfHwgXCJsYWJlbFwiIGluIGVsZW0pO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cblx0XHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHR9XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cblx0XHRcdFx0Ly8gcVNBIGxvb2tzIG91dHNpZGUgRWxlbWVudCBjb250ZXh0LCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50XG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHdvcmthcm91bmQgdGVjaG5pcXVlXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG5cdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAobmlkID0gZXhwYW5kbykgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1tpXSA9IFwiI1wiICsgbmlkICsgXCIgXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggbmV3U2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGVsICk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBlbC5wYXJlbnROb2RlICkge1xuXHRcdFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWwgKTtcblx0XHR9XG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRlbCA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcblx0XHRpID0gYXJyLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBkaXNhYmxlZCB0cnVlIGZvciA6ZGlzYWJsZWQ7IGZhbHNlIGZvciA6ZW5hYmxlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZGlzYWJsZWQgKSB7XG5cblx0Ly8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXG5cdFx0aWYgKCBcImZvcm1cIiBpbiBlbGVtICkge1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XG5cdFx0XHQvLyAqIGxpc3RlZCBmb3JtLWFzc29jaWF0ZWQgZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBmaWVsZHNldFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcblx0XHRcdC8vICogb3B0aW9uIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxuXHRcdFx0Ly8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFwiZm9ybVwiIHByb3BlcnR5LlxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gT3B0aW9uIGVsZW1lbnRzIGRlZmVyIHRvIGEgcGFyZW50IG9wdGdyb3VwIGlmIHByZXNlbnRcblx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDYgLSAxMVxuXHRcdFx0XHQvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fFxuXG5cdFx0XHRcdFx0Ly8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcblx0XHRcdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdFx0XHRlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0ZGlzYWJsZWRBbmNlc3RvciggZWxlbSApID09PSBkaXNhYmxlZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXG5cdFx0Ly8gVHJ5IHRvIHdpbm5vdyBvdXQgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSBkaXNhYmxlZCBiZWZvcmUgdHJ1c3RpbmcgdGhlIGRpc2FibGVkIHByb3BlcnR5LlxuXHRcdC8vIFNvbWUgdmljdGltcyBnZXQgY2F1Z2h0IGluIG91ciBuZXQgKGxhYmVsLCBsZWdlbmQsIG1lbnUsIHRyYWNrKSwgYnV0IGl0IHNob3VsZG4ndFxuXHRcdC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxuXHRcdH0gZWxzZSBpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdH1cblxuXHRcdC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0dmFyIGosXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXG5cdFx0XHRcdGkgPSBtYXRjaEluZGV4ZXMubGVuZ3RoO1xuXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNlZWRbIChqID0gbWF0Y2hJbmRleGVzW2ldKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdC8vIGRvY3VtZW50RWxlbWVudCBpcyB2ZXJpZmllZCBmb3IgY2FzZXMgd2hlcmUgaXQgZG9lc24ndCB5ZXQgZXhpc3Rcblx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXG5cdHZhciBkb2N1bWVudEVsZW1lbnQgPSBlbGVtICYmIChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXHRyZXR1cm4gZG9jdW1lbnRFbGVtZW50ID8gZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lICE9PSBcIkhUTUxcIiA6IGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2Vcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcblx0XHQoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblx0XHRcdFx0XHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1zW2krK10pICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhY29tcGlsZXJDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXNjYXBlID0gZnVuY3Rpb24oIHNlbCApIHtcblx0cmV0dXJuIChzZWwgKyBcIlwiKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuXHRcdFwiZGlzYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0c2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcblx0XHRrZXkgPSBza2lwIHx8IGRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGNsb3Nlc3QgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gZWxlbVsgZXhwYW5kbyBdIHx8IChlbGVtWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHwgKG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0aWYgKCBza2lwICYmIHNraXAgPT09IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCAob2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsga2V5IF0pICYmXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQXNzaWduIHRvIG5ld0NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyBrZXkgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoIChuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkpICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICkge1xuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBpID0gbWF0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggIW1hdGNoZXJzW2ldKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWzBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzW2ldLCByZXN1bHRzICk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGNvbmRlbnNlKCB1bm1hdGNoZWQsIG1hcCwgZmlsdGVyLCBjb250ZXh0LCB4bWwgKSB7XG5cdHZhciBlbGVtLFxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGxlbiA9IHVubWF0Y2hlZC5sZW5ndGgsXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxuXG5cdFx0XHQvLyBQcmVmaWx0ZXIgdG8gZ2V0IG1hdGNoZXIgaW5wdXQsIHByZXNlcnZpbmcgYSBtYXAgZm9yIHNlZWQtcmVzdWx0cyBzeW5jaHJvbml6YXRpb25cblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xuXHRcdFx0XHRjb25kZW5zZSggZWxlbXMsIHByZU1hcCwgcHJlRmlsdGVyLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdGVsZW1zLFxuXG5cdFx0XHRtYXRjaGVyT3V0ID0gbWF0Y2hlciA/XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoZWxlbSA9IHRlbXBbaV0pICkge1xuXHRcdFx0XHRcdG1hdGNoZXJPdXRbIHBvc3RNYXBbaV0gXSA9ICEobWF0Y2hlckluWyBwb3N0TWFwW2ldIF0gPSBlbGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggc2VlZCApIHtcblx0XHRcdGlmICggcG9zdEZpbmRlciB8fCBwcmVGaWx0ZXIgKSB7XG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goIChtYXRjaGVySW5baV0gPSBlbGVtKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCAobWF0Y2hlck91dCA9IFtdKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSAmJlxuXHRcdFx0XHRcdFx0KHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkW3RlbXBdID0gIShyZXN1bHRzW3RlbXBdID0gZWxlbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXG5cdFx0aSA9IGxlYWRpbmdSZWxhdGl2ZSA/IDEgOiAwLFxuXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcblx0XHRtYXRjaENvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBjaGVja0NvbnRleHQ7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoQW55Q29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxuXHRcdG1hdGNoZXJzID0gWyBmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIHJldCA9ICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXG5cdFx0XHRcdChjaGVja0NvbnRleHQgPSBjb250ZXh0KS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAobWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1tpXS50eXBlIF0pICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zW2ldLnR5cGUgXS5hcHBseSggbnVsbCwgdG9rZW5zW2ldLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzZXRNYXRjaGVyKFxuXHRcdFx0XHRcdGkgPiAxICYmIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLFxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXG5cdFx0XHRcdFx0XHQvLyBJZiB0aGUgcHJlY2VkaW5nIHRva2VuIHdhcyBhIGRlc2NlbmRhbnQgY29tYmluYXRvciwgaW5zZXJ0IGFuIGltcGxpY2l0IGFueS1lbGVtZW50IGAqYFxuXHRcdFx0XHRcdFx0dG9rZW5zLnNsaWNlKCAwLCBpIC0gMSApLmNvbmNhdCh7IHZhbHVlOiB0b2tlbnNbIGkgLSAyIF0udHlwZSA9PT0gXCIgXCIgPyBcIipcIiA6IFwiXCIgfSlcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIHRvU2VsZWN0b3IoIHRva2VucyApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVycy5wdXNoKCBtYXRjaGVyICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSB7XG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0YnlFbGVtZW50ID0gZWxlbWVudE1hdGNoZXJzLmxlbmd0aCA+IDAsXG5cdFx0c3VwZXJNYXRjaGVyID0gZnVuY3Rpb24oIHNlZWQsIGNvbnRleHQsIHhtbCwgcmVzdWx0cywgb3V0ZXJtb3N0ICkge1xuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXG5cdFx0XHRcdG1hdGNoZWRDb3VudCA9IDAsXG5cdFx0XHRcdGkgPSBcIjBcIixcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcblx0XHRcdFx0c2V0TWF0Y2hlZCA9IFtdLFxuXHRcdFx0XHRjb250ZXh0QmFja3VwID0gb3V0ZXJtb3N0Q29udGV4dCxcblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFtcIlRBR1wiXSggXCIqXCIsIG91dGVybW9zdCApLFxuXHRcdFx0XHQvLyBVc2UgaW50ZWdlciBkaXJydW5zIGlmZiB0aGlzIGlzIHRoZSBvdXRlcm1vc3QgbWF0Y2hlclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT09IGRvY3VtZW50IHx8IGNvbnRleHQgfHwgb3V0ZXJtb3N0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgZWxlbWVudHMgcGFzc2luZyBlbGVtZW50TWF0Y2hlcnMgZGlyZWN0bHkgdG8gcmVzdWx0c1xuXHRcdFx0Ly8gU3VwcG9ydDogSUU8OSwgU2FmYXJpXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcblx0XHRcdGZvciAoIDsgaSAhPT0gbGVuICYmIChlbGVtID0gZWxlbXNbaV0pICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwpICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHJhY2sgdW5tYXRjaGVkIGVsZW1lbnRzIGZvciBzZXQgZmlsdGVyc1xuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gIW1hdGNoZXIgJiYgZWxlbSkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuXHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuXHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IHNldE1hdGNoZXJzW2orK10pICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEodW5tYXRjaGVkW2ldIHx8IHNldE1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbaV0gPSBwb3AuY2FsbCggcmVzdWx0cyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRGlzY2FyZCBpbmRleCBwbGFjZWhvbGRlciB2YWx1ZXMgdG8gZ2V0IG9ubHkgYWN0dWFsIG1hdGNoZXNcblx0XHRcdFx0XHRzZXRNYXRjaGVkID0gY29uZGVuc2UoIHNldE1hdGNoZWQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFkZCBtYXRjaGVzIHRvIHJlc3VsdHNcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xuXG5cdFx0XHRcdC8vIFNlZWRsZXNzIHNldCBtYXRjaGVzIHN1Y2NlZWRpbmcgbXVsdGlwbGUgc3VjY2Vzc2Z1bCBtYXRjaGVycyBzdGlwdWxhdGUgc29ydGluZ1xuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcblx0XHRcdFx0XHQoIG1hdGNoZWRDb3VudCArIHNldE1hdGNoZXJzLmxlbmd0aCApID4gMSApIHtcblxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gT3ZlcnJpZGUgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbHMgYnkgbmVzdGVkIG1hdGNoZXJzXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0QmFja3VwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5tYXRjaGVkO1xuXHRcdH07XG5cblx0cmV0dXJuIGJ5U2V0ID9cblx0XHRtYXJrRnVuY3Rpb24oIHN1cGVyTWF0Y2hlciApIDpcblx0XHRzdXBlck1hdGNoZXI7XG59XG5cbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XG5cdHZhciBpLFxuXHRcdHNldE1hdGNoZXJzID0gW10sXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggIWNhY2hlZCApIHtcblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbaV0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoIHNlbGVjdG9yLCBtYXRjaGVyRnJvbUdyb3VwTWF0Y2hlcnMoIGVsZW1lbnRNYXRjaGVycywgc2V0TWF0Y2hlcnMgKSApO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAodG9rZW4gPSB0b2tlbnNbMF0pLnR5cGUgPT09IFwiSURcIiAmJlxuXHRcdFx0XHRjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7XG5cblx0XHRcdGNvbnRleHQgPSAoIEV4cHIuZmluZFtcIklEXCJdKCB0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UocnVuZXNjYXBlLCBmdW5lc2NhcGUpLCBjb250ZXh0ICkgfHwgW10gKVswXTtcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXG5cdFx0XHR9IGVsc2UgaWYgKCBjb21waWxlZCApIHtcblx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQucGFyZW50Tm9kZTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSggdG9rZW5zLnNoaWZ0KCkudmFsdWUubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmV0Y2ggYSBzZWVkIHNldCBmb3IgcmlnaHQtdG8tbGVmdCBtYXRjaGluZ1xuXHRcdGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbaV07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKHR5cGUgPSB0b2tlbi50eXBlKSBdICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggKGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSkgKSB7XG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoIChzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWzBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHRcdFx0XHQpKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdChcIlwiKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKFwiXCIpID09PSBleHBhbmRvO1xuXG4vLyBTdXBwb3J0OiBDaHJvbWUgMTQtMzUrXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXG5zdXBwb3J0LmRldGVjdER1cGxpY2F0ZXMgPSAhIWhhc0R1cGxpY2F0ZTtcblxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XG5zZXREb2N1bWVudCgpO1xuXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxuLy8gRGV0YWNoZWQgbm9kZXMgY29uZm91bmRpbmdseSBmb2xsb3cgKmVhY2ggb3RoZXIqXG5zdXBwb3J0LnNvcnREZXRhY2hlZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdC8vIFNob3VsZCByZXR1cm4gMSwgYnV0IHJldHVybnMgNCAoZm9sbG93aW5nKVxuXHRyZXR1cm4gZWwuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKSApICYgMTtcbn0pO1xuXG4vLyBTdXBwb3J0OiBJRTw4XG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxuLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZWwuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ2YWx1ZVwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0cmV0dXJuIGVsLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5cbi8vIERlcHJlY2F0ZWRcbmpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcbmpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IFNpenpsZS5lc2NhcGU7XG5cblxuXG5cbnZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cblxuXG5mdW5jdGlvbiBub2RlTmFtZSggZWxlbSwgbmFtZSApIHtcblxuICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblxufTtcbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSApO1xuXG5cblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNpbmdsZSBlbGVtZW50XG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBBcnJheWxpa2Ugb2YgZWxlbWVudHMgKGpRdWVyeSwgYXJndW1lbnRzLCBBcnJheSlcblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBGaWx0ZXJlZCBkaXJlY3RseSBmb3IgYm90aCBzaW1wbGUgYW5kIGNvbXBsZXggc2VsZWN0b3JzXG5cdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdGlmICggZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCByZXQsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIHJldCApIDogcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdH07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xuXG5cbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHR0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoIHNlbGVjdG9ycyApO1xuXG5cdFx0Ly8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxuXHRcdGlmICggIXJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggdGFyZ2V0cyA/XG5cdFx0XHRcdFx0XHR0YXJnZXRzLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXG5cdFx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cblx0XHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKCB7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHByZXZVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuICAgICAgICBpZiAoIG5vZGVOYW1lKCBlbGVtLCBcImlmcmFtZVwiICkgKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcbiAgICAgICAgLy8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XG4gICAgICAgIC8vIGRvbid0IHN1cHBvcnQgaXQuXG4gICAgICAgIGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuICAgICAgICAgICAgZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3RodG1sd2hpdGUgPSAoIC9bXlxceDIwXFx0XFxyXFxuXFxmXSsvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSwgZnVuY3Rpb24oIF8sIGZsYWcgKSB7XG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xuXHR9ICk7XG5cdHJldHVybiBvYmplY3Q7XG59XG5cbi8qXG4gKiBDcmVhdGUgYSBjYWxsYmFjayBsaXN0IHVzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyczpcbiAqXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xuICpcdFx0XHR0aGUgY2FsbGJhY2sgbGlzdCBiZWhhdmVzIG9yIGEgbW9yZSB0cmFkaXRpb25hbCBvcHRpb24gb2JqZWN0XG4gKlxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcbiAqIFwiZmlyZWRcIiBtdWx0aXBsZSB0aW1lcy5cbiAqXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxuICpcbiAqXHRvbmNlOlx0XHRcdHdpbGwgZW5zdXJlIHRoZSBjYWxsYmFjayBsaXN0IGNhbiBvbmx5IGJlIGZpcmVkIG9uY2UgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0bWVtb3J5Olx0XHRcdHdpbGwga2VlcCB0cmFjayBvZiBwcmV2aW91cyB2YWx1ZXMgYW5kIHdpbGwgY2FsbCBhbnkgY2FsbGJhY2sgYWRkZWRcbiAqXHRcdFx0XHRcdGFmdGVyIHRoZSBsaXN0IGhhcyBiZWVuIGZpcmVkIHJpZ2h0IGF3YXkgd2l0aCB0aGUgbGF0ZXN0IFwibWVtb3JpemVkXCJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHR1bmlxdWU6XHRcdFx0d2lsbCBlbnN1cmUgYSBjYWxsYmFjayBjYW4gb25seSBiZSBhZGRlZCBvbmNlIChubyBkdXBsaWNhdGUgaW4gdGhlIGxpc3QpXG4gKlxuICpcdHN0b3BPbkZhbHNlOlx0aW50ZXJydXB0IGNhbGxpbmdzIHdoZW4gYSBjYWxsYmFjayByZXR1cm5zIGZhbHNlXG4gKlxuICovXG5qUXVlcnkuQ2FsbGJhY2tzID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuXHQvLyAod2UgY2hlY2sgaW4gY2FjaGUgZmlyc3QpXG5cdG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0Y3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIDpcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG5cdHZhciAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXG5cdFx0ZmlyaW5nLFxuXG5cdFx0Ly8gTGFzdCBmaXJlIHZhbHVlIGZvciBub24tZm9yZ2V0dGFibGUgbGlzdHNcblx0XHRtZW1vcnksXG5cblx0XHQvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCB3YXMgYWxyZWFkeSBmaXJlZFxuXHRcdGZpcmVkLFxuXG5cdFx0Ly8gRmxhZyB0byBwcmV2ZW50IGZpcmluZ1xuXHRcdGxvY2tlZCxcblxuXHRcdC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG5cdFx0bGlzdCA9IFtdLFxuXG5cdFx0Ly8gUXVldWUgb2YgZXhlY3V0aW9uIGRhdGEgZm9yIHJlcGVhdGFibGUgbGlzdHNcblx0XHRxdWV1ZSA9IFtdLFxuXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgYWRkL3JlbW92ZSBhcyBuZWVkZWQpXG5cdFx0ZmlyaW5nSW5kZXggPSAtMSxcblxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXG5cdFx0ZmlyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbmZvcmNlIHNpbmdsZS1maXJpbmdcblx0XHRcdGxvY2tlZCA9IGxvY2tlZCB8fCBvcHRpb25zLm9uY2U7XG5cblx0XHRcdC8vIEV4ZWN1dGUgY2FsbGJhY2tzIGZvciBhbGwgcGVuZGluZyBleGVjdXRpb25zLFxuXHRcdFx0Ly8gcmVzcGVjdGluZyBmaXJpbmdJbmRleCBvdmVycmlkZXMgYW5kIHJ1bnRpbWUgY2hhbmdlc1xuXHRcdFx0ZmlyZWQgPSBmaXJpbmcgPSB0cnVlO1xuXHRcdFx0Zm9yICggOyBxdWV1ZS5sZW5ndGg7IGZpcmluZ0luZGV4ID0gLTEgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRcdHdoaWxlICggKytmaXJpbmdJbmRleCA8IGxpc3QubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gUnVuIGNhbGxiYWNrIGFuZCBjaGVjayBmb3IgZWFybHkgdGVybWluYXRpb25cblx0XHRcdFx0XHRpZiAoIGxpc3RbIGZpcmluZ0luZGV4IF0uYXBwbHkoIG1lbW9yeVsgMCBdLCBtZW1vcnlbIDEgXSApID09PSBmYWxzZSAmJlxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zdG9wT25GYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSnVtcCB0byBlbmQgYW5kIGZvcmdldCB0aGUgZGF0YSBzbyAuYWRkIGRvZXNuJ3QgcmUtZmlyZVxuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3JnZXQgdGhlIGRhdGEgaWYgd2UncmUgZG9uZSB3aXRoIGl0XG5cdFx0XHRpZiAoICFvcHRpb25zLm1lbW9yeSApIHtcblx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZpcmluZyA9IGZhbHNlO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBpZiB3ZSdyZSBkb25lIGZpcmluZyBmb3IgZ29vZFxuXHRcdFx0aWYgKCBsb2NrZWQgKSB7XG5cblx0XHRcdFx0Ly8gS2VlcCBhbiBlbXB0eSBsaXN0IGlmIHdlIGhhdmUgZGF0YSBmb3IgZnV0dXJlIGFkZCBjYWxsc1xuXHRcdFx0XHRpZiAoIG1lbW9yeSApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCB0aGlzIG9iamVjdCBpcyBzcGVudFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxpc3QgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG5cdFx0c2VsZiA9IHtcblxuXHRcdFx0Ly8gQWRkIGEgY2FsbGJhY2sgb3IgYSBjb2xsZWN0aW9uIG9mIGNhbGxiYWNrcyB0byB0aGUgbGlzdFxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBtZW1vcnkgZnJvbSBhIHBhc3QgcnVuLCB3ZSBzaG91bGQgZmlyZSBhZnRlciBhZGRpbmdcblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBtZW1vcnkgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQoIGZ1bmN0aW9uIGFkZCggYXJncyApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmdzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggIW9wdGlvbnMudW5pcXVlIHx8ICFzZWxmLmhhcyggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnICYmIGFyZy5sZW5ndGggJiYgdG9UeXBlKCBhcmcgKSAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEluc3BlY3QgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fSApKCBhcmd1bWVudHMgKTtcblxuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3VtZW50cywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG5cdFx0XHRcdFx0XHRsaXN0LnNwbGljZSggaW5kZXgsIDEgKTtcblxuXHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuXHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENoZWNrIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3QuXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cblx0XHRcdGhhczogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRyZXR1cm4gZm4gP1xuXHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBmbiwgbGlzdCApID4gLTEgOlxuXHRcdFx0XHRcdGxpc3QubGVuZ3RoID4gMDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3Rcblx0XHRcdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBsaXN0ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmUgYW5kIC5hZGRcblx0XHRcdC8vIEFib3J0IGFueSBjdXJyZW50L3BlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0Ly8gQ2xlYXIgYWxsIGNhbGxiYWNrcyBhbmQgdmFsdWVzXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGRpc2FibGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZVxuXHRcdFx0Ly8gQWxzbyBkaXNhYmxlIC5hZGQgdW5sZXNzIHdlIGhhdmUgbWVtb3J5IChzaW5jZSBpdCB3b3VsZCBoYXZlIG5vIGVmZmVjdClcblx0XHRcdC8vIEFib3J0IGFueSBwZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRpZiAoICFtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFsb2NrZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG5cdFx0XHRmaXJlV2l0aDogZnVuY3Rpb24oIGNvbnRleHQsIGFyZ3MgKSB7XG5cdFx0XHRcdGlmICggIWxvY2tlZCApIHtcblx0XHRcdFx0XHRhcmdzID0gYXJncyB8fCBbXTtcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGFyZ3MgKTtcblx0XHRcdFx0XHRpZiAoICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHNcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmZpcmVXaXRoKCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2Vcblx0XHRcdGZpcmVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhZmlyZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRyZXR1cm4gc2VsZjtcbn07XG5cblxuZnVuY3Rpb24gSWRlbnRpdHkoIHYgKSB7XG5cdHJldHVybiB2O1xufVxuZnVuY3Rpb24gVGhyb3dlciggZXggKSB7XG5cdHRocm93IGV4O1xufVxuXG5mdW5jdGlvbiBhZG9wdFZhbHVlKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0LCBub1ZhbHVlICkge1xuXHR2YXIgbWV0aG9kO1xuXG5cdHRyeSB7XG5cblx0XHQvLyBDaGVjayBmb3IgcHJvbWlzZSBhc3BlY3QgZmlyc3QgdG8gcHJpdmlsZWdlIHN5bmNocm9ub3VzIGJlaGF2aW9yXG5cdFx0aWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnByb21pc2UgKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlICkuZG9uZSggcmVzb2x2ZSApLmZhaWwoIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgdGhlbmFibGVzXG5cdFx0fSBlbHNlIGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS50aGVuICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciBub24tdGhlbmFibGVzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29udHJvbCBgcmVzb2x2ZWAgYXJndW1lbnRzIGJ5IGxldHRpbmcgQXJyYXkjc2xpY2UgY2FzdCBib29sZWFuIGBub1ZhbHVlYCB0byBpbnRlZ2VyOlxuXHRcdFx0Ly8gKiBmYWxzZTogWyB2YWx1ZSBdLnNsaWNlKCAwICkgPT4gcmVzb2x2ZSggdmFsdWUgKVxuXHRcdFx0Ly8gKiB0cnVlOiBbIHZhbHVlIF0uc2xpY2UoIDEgKSA9PiByZXNvbHZlKClcblx0XHRcdHJlc29sdmUuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdLnNsaWNlKCBub1ZhbHVlICkgKTtcblx0XHR9XG5cblx0Ly8gRm9yIFByb21pc2VzL0ErLCBjb252ZXJ0IGV4Y2VwdGlvbnMgaW50byByZWplY3Rpb25zXG5cdC8vIFNpbmNlIGpRdWVyeS53aGVuIGRvZXNuJ3QgdW53cmFwIHRoZW5hYmxlcywgd2UgY2FuIHNraXAgdGhlIGV4dHJhIGNoZWNrcyBhcHBlYXJpbmcgaW5cblx0Ly8gRGVmZXJyZWQjdGhlbiB0byBjb25kaXRpb25hbGx5IHN1cHByZXNzIHJlamVjdGlvbi5cblx0fSBjYXRjaCAoIHZhbHVlICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgb25seVxuXHRcdC8vIFN0cmljdCBtb2RlIGZ1bmN0aW9ucyBpbnZva2VkIHdpdGhvdXQgLmNhbGwvLmFwcGx5IGdldCBnbG9iYWwtb2JqZWN0IGNvbnRleHRcblx0XHRyZWplY3QuYXBwbHkoIHVuZGVmaW5lZCwgWyB2YWx1ZSBdICk7XG5cdH1cbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdERlZmVycmVkOiBmdW5jdGlvbiggZnVuYyApIHtcblx0XHR2YXIgdHVwbGVzID0gW1xuXG5cdFx0XHRcdC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBjYWxsYmFja3MsXG5cdFx0XHRcdC8vIC4uLiAudGhlbiBoYW5kbGVycywgYXJndW1lbnQgaW5kZXgsIFtmaW5hbCBzdGF0ZV1cblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksIDIgXSxcblx0XHRcdFx0WyBcInJlc29sdmVcIiwgXCJkb25lXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAwLCBcInJlc29sdmVkXCIgXSxcblx0XHRcdFx0WyBcInJlamVjdFwiLCBcImZhaWxcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDEsIFwicmVqZWN0ZWRcIiBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdFwiY2F0Y2hcIjogZnVuY3Rpb24oIGZuICkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9taXNlLnRoZW4oIG51bGwsIGZuICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gS2VlcCBwaXBlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRwaXBlOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG5cdFx0XHRcdFx0dmFyIGZucyA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0gaXNGdW5jdGlvbiggZm5zWyB0dXBsZVsgNCBdIF0gKSAmJiBmbnNbIHR1cGxlWyA0IF0gXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmZhaWwoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVqZWN0IH0pXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0dmFyIG1heERlcHRoID0gMDtcblx0XHRcdFx0XHRmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCwgdGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggPCBtYXhEZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhlbiA9IHJldHVybmVkICYmXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgcmV0dXJuZWQgPT09IFwiZnVuY3Rpb25cIiApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoZW4gKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhEZXB0aCsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGggKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGFsbCBvdGhlciByZXR1cm5lZCB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIHJldHVybmVkIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZhdWx0IHByb2Nlc3MgaXMgcmVzb2x2ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHNwZWNpYWwgfHwgZGVmZXJyZWQucmVzb2x2ZVdpdGggKSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzID0gc3BlY2lhbCA/XG5cdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93IDpcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3coKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soIGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKyAxID49IG1heERlcHRoICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gVGhyb3dlciApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgZSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG5cdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG5cdFx0XHRcdFx0XHRcdC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cblx0XHRcdFx0XHRcdFx0Ly8gc3Vic2VxdWVudCBlcnJvcnNcblx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzKCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDYWxsIGFuIG9wdGlvbmFsIGhvb2sgdG8gcmVjb3JkIHRoZSBzdGFjaywgaW4gY2FzZSBvZiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHQvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBwcm9jZXNzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXG5cdFx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUHJvZ3Jlc3MgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblByb2dyZXNzIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLm5vdGlmeVdpdGhcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkZ1bGZpbGxlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDIgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblJlamVjdGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdFRocm93ZXJcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyA1IF07XG5cblx0XHRcdC8vIHByb21pc2UucHJvZ3Jlc3MgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZmFpbCA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlc29sdmVkXCIgKGkuZS4sIGZ1bGZpbGxlZClcblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZWplY3RlZFwiXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMiBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDMgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMiBdLmxvY2ssXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5sb2NrXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXG5cdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5maXJlXG5cdFx0XHRsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5ub3RpZnlXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmVXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc2luZ2xlVmFsdWUgKSB7XG5cdFx0dmFyXG5cblx0XHRcdC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXG5cdFx0XHRpID0gcmVtYWluaW5nLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBBcnJheSggaSApLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkXG5cdFx0XHRtYXN0ZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJlc29sdmVDb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0bWFzdGVyLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXG5cdFx0Ly8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG5cdFx0aWYgKCByZW1haW5pbmcgPD0gMSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHNpbmdsZVZhbHVlLCBtYXN0ZXIuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgbWFzdGVyLnJlamVjdCxcblx0XHRcdFx0IXJlbWFpbmluZyApO1xuXG5cdFx0XHQvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG5cdFx0XHRpZiAoIG1hc3Rlci5zdGF0ZSgpID09PSBcInBlbmRpbmdcIiB8fFxuXHRcdFx0XHRpc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgcmVzb2x2ZVZhbHVlc1sgaSBdLnRoZW4gKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gbWFzdGVyLnRoZW4oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIG1hc3Rlci5yZWplY3QgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFzdGVyLnByb21pc2UoKTtcblx0fVxufSApO1xuXG5cbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxuLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG52YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcblxualF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiggZXJyb3IsIHN0YWNrICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcblx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcblx0aWYgKCB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoIGVycm9yLm5hbWUgKSApIHtcblx0XHR3aW5kb3cuY29uc29sZS53YXJuKCBcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2ssIHN0YWNrICk7XG5cdH1cbn07XG5cblxuXG5cbmpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdHRocm93IGVycm9yO1xuXHR9ICk7XG59O1xuXG5cblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG5cdHJlYWR5TGlzdFxuXHRcdC50aGVuKCBmbiApXG5cblx0XHQvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuXHRcdC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xuXHRcdC8vIHJlZ2lzdHJhdGlvbi5cblx0XHQuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcblx0XHRcdGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiggZXJyb3IgKTtcblx0XHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XG5cbi8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbi8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG4vLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDEwIG9ubHlcbi8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxufSBlbHNlIHtcblxuXHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xufVxuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIHRvVHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIGNoYWluYWJsZSApIHtcblx0XHRyZXR1cm4gZWxlbXM7XG5cdH1cblxuXHQvLyBHZXRzXG5cdGlmICggYnVsayApIHtcblx0XHRyZXR1cm4gZm4uY2FsbCggZWxlbXMgKTtcblx0fVxuXG5cdHJldHVybiBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG5cblxuLy8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG52YXIgcm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nO1xuXG4vLyBVc2VkIGJ5IGNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcbmZ1bmN0aW9uIGZjYW1lbENhc2UoIGFsbCwgbGV0dGVyICkge1xuXHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8vIENvbnZlcnQgZGFzaGVkIHRvIGNhbWVsQ2FzZTsgdXNlZCBieSB0aGUgY3NzIGFuZCBkYXRhIG1vZHVsZXNcbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcbi8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3MilcbmZ1bmN0aW9uIGNhbWVsQ2FzZSggc3RyaW5nICkge1xuXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHJtc1ByZWZpeCwgXCJtcy1cIiApLnJlcGxhY2UoIHJkYXNoQWxwaGEsIGZjYW1lbENhc2UgKTtcbn1cbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XG59O1xuXG5cblxuXG5mdW5jdGlvbiBEYXRhKCkge1xuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIERhdGEudWlkKys7XG59XG5cbkRhdGEudWlkID0gMTtcblxuRGF0YS5wcm90b3R5cGUgPSB7XG5cblx0Y2FjaGU6IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHRcdC8vIENoZWNrIGlmIHRoZSBvd25lciBvYmplY3QgYWxyZWFkeSBoYXMgYSBjYWNoZVxuXHRcdHZhciB2YWx1ZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdC8vIElmIG5vdCwgY3JlYXRlIG9uZVxuXHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0dmFsdWUgPSB7fTtcblxuXHRcdFx0Ly8gV2UgY2FuIGFjY2VwdCBkYXRhIGZvciBub24tZWxlbWVudCBub2RlcyBpbiBtb2Rlcm4gYnJvd3NlcnMsXG5cdFx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdFx0Ly8gQWx3YXlzIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgaXMgYSBub2RlIHVubGlrZWx5IHRvIGJlIHN0cmluZ2lmeS1lZCBvciBsb29wZWQgb3ZlclxuXHRcdFx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHZhbHVlO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSBwcm9wZXJ0eVxuXHRcdFx0XHQvLyBjb25maWd1cmFibGUgbXVzdCBiZSB0cnVlIHRvIGFsbG93IHRoZSBwcm9wZXJ0eSB0byBiZVxuXHRcdFx0XHQvLyBkZWxldGVkIHdoZW4gZGF0YSBpcyByZW1vdmVkXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvd25lciwgdGhpcy5leHBhbmRvLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcblx0XHR2YXIgcHJvcCxcblx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSggb3duZXIgKTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwga2V5LCB2YWx1ZSBdIGFyZ3Ncblx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIGRhdGEgKSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBjYW1lbENhc2UoIHByb3AgKSBdID0gZGF0YVsgcHJvcCBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2FjaGU7XG5cdH0sXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMuY2FjaGUoIG93bmVyICkgOlxuXG5cdFx0XHQvLyBBbHdheXMgdXNlIGNhbWVsQ2FzZSBrZXkgKGdoLTIyNTcpXG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBjYW1lbENhc2UoIGtleSApIF07XG5cdH0sXG5cdGFjY2VzczogZnVuY3Rpb24oIG93bmVyLCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gSW4gY2FzZXMgd2hlcmUgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxuXHRcdC8vICAgMi4gQSBzdHJpbmcga2V5IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyB2YWx1ZSBwcm92aWRlZFxuXHRcdC8vXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXG5cdFx0Ly8gd2hpY2ggdmFsdWUgdG8gcmV0dXJuLCByZXNwZWN0aXZlbHkgZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxuXHRcdC8vICAgMi4gVGhlIGRhdGEgc3RvcmVkIGF0IHRoZSBrZXlcblx0XHQvL1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcblx0XHRcdFx0KCAoIGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICkgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblx0XHR9XG5cblx0XHQvLyBXaGVuIHRoZSBrZXkgaXMgbm90IGEgc3RyaW5nLCBvciBib3RoIGEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxuXHRcdC8vXG5cdFx0Ly8gICAxLiBBbiBvYmplY3Qgb2YgcHJvcGVydGllc1xuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly9cblx0XHR0aGlzLnNldCggb3duZXIsIGtleSwgdmFsdWUgKTtcblxuXHRcdC8vIFNpbmNlIHRoZSBcInNldFwiIHBhdGggY2FuIGhhdmUgdHdvIHBvc3NpYmxlIGVudHJ5IHBvaW50c1xuXHRcdC8vIHJldHVybiB0aGUgZXhwZWN0ZWQgZGF0YSBiYXNlZCBvbiB3aGljaCBwYXRoIHdhcyB0YWtlblsqXVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XG5cdH0sXG5cdHJlbW92ZTogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0IGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Yga2V5c1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5cy4uLlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc2V0IGNhbWVsQ2FzZSBrZXlzLCBzbyByZW1vdmUgdGhhdC5cblx0XHRcdFx0a2V5ID0ga2V5Lm1hcCggY2FtZWxDYXNlICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXkgPSBjYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBjcmVhdGUgYW4gYXJyYXkgYnkgbWF0Y2hpbmcgbm9uLXdoaXRlc3BhY2Vcblx0XHRcdFx0a2V5ID0ga2V5IGluIGNhY2hlID9cblx0XHRcdFx0XHRbIGtleSBdIDpcblx0XHRcdFx0XHQoIGtleS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdICk7XG5cdFx0XHR9XG5cblx0XHRcdGkgPSBrZXkubGVuZ3RoO1xuXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDVcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzg2MDcgKGJ1ZyByZXN0cmljdGVkKVxuXHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBvd25lciApIHtcblx0XHR2YXIgY2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0cmV0dXJuIGNhY2hlICE9PSB1bmRlZmluZWQgJiYgIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApO1xuXHR9XG59O1xudmFyIGRhdGFQcml2ID0gbmV3IERhdGEoKTtcblxudmFyIGRhdGFVc2VyID0gbmV3IERhdGEoKTtcblxuXG5cbi8vXHRJbXBsZW1lbnRhdGlvbiBTdW1tYXJ5XG4vL1xuLy9cdDEuIEVuZm9yY2UgQVBJIHN1cmZhY2UgYW5kIHNlbWFudGljIGNvbXBhdGliaWxpdHkgd2l0aCAxLjkueCBicmFuY2hcbi8vXHQyLiBJbXByb3ZlIHRoZSBtb2R1bGUncyBtYWludGFpbmFiaWxpdHkgYnkgcmVkdWNpbmcgdGhlIHN0b3JhZ2Vcbi8vXHRcdHBhdGhzIHRvIGEgc2luZ2xlIG1lY2hhbmlzbS5cbi8vXHQzLiBVc2UgdGhlIHNhbWUgc2luZ2xlIG1lY2hhbmlzbSB0byBzdXBwb3J0IFwicHJpdmF0ZVwiIGFuZCBcInVzZXJcIiBkYXRhLlxuLy9cdDQuIF9OZXZlcl8gZXhwb3NlIFwicHJpdmF0ZVwiIGRhdGEgdG8gdXNlciBjb2RlIChUT0RPOiBEcm9wIF9kYXRhLCBfcmVtb3ZlRGF0YSlcbi8vXHQ1LiBBdm9pZCBleHBvc2luZyBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9uIHVzZXIgb2JqZWN0cyAoZWcuIGV4cGFuZG8gcHJvcGVydGllcylcbi8vXHQ2LiBQcm92aWRlIGEgY2xlYXIgcGF0aCBmb3IgaW1wbGVtZW50YXRpb24gdXBncmFkZSB0byBXZWFrTWFwIGluIDIwMTRcblxudmFyIHJicmFjZSA9IC9eKD86XFx7W1xcd1xcV10qXFx9fFxcW1tcXHdcXFddKlxcXSkkLyxcblx0cm11bHRpRGFzaCA9IC9bQS1aXS9nO1xuXG5mdW5jdGlvbiBnZXREYXRhKCBkYXRhICkge1xuXHRpZiAoIGRhdGEgPT09IFwidHJ1ZVwiICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcImZhbHNlXCIgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0aWYgKCBkYXRhID09PSBcIm51bGxcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdGlmICggZGF0YSA9PT0gK2RhdGEgKyBcIlwiICkge1xuXHRcdHJldHVybiArZGF0YTtcblx0fVxuXG5cdGlmICggcmJyYWNlLnRlc3QoIGRhdGEgKSApIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZSggZGF0YSApO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZ2V0RGF0YSggZGF0YSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2Ugc2V0IHRoZSBkYXRhIHNvIGl0IGlzbid0IGNoYW5nZWQgbGF0ZXJcblx0XHRcdGRhdGFVc2VyLnNldCggZWxlbSwga2V5LCBkYXRhICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGhhc0RhdGE6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5oYXNEYXRhKCBlbGVtICkgfHwgZGF0YVByaXYuaGFzRGF0YSggZWxlbSApO1xuXHR9LFxuXG5cdGRhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhVXNlci5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhVXNlci5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fSxcblxuXHQvLyBUT0RPOiBOb3cgdGhhdCBhbGwgY2FsbHMgdG8gX2RhdGEgYW5kIF9yZW1vdmVEYXRhIGhhdmUgYmVlbiByZXBsYWNlZFxuXHQvLyB3aXRoIGRpcmVjdCBjYWxscyB0byBkYXRhUHJpdiBtZXRob2RzLCB0aGVzZSBjYW4gYmUgZGVwcmVjYXRlZC5cblx0X2RhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBkYXRhICkge1xuXHRcdHJldHVybiBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIG5hbWUsIGRhdGEgKTtcblx0fSxcblxuXHRfcmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHR2YXIgaSwgbmFtZSwgZGF0YSxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xuXG5cdFx0Ly8gR2V0cyBhbGwgdmFsdWVzXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdGhpcy5sZW5ndGggKSB7XG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0gKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFQcml2LmdldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiApICkge1xuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGNhbWVsQ2FzZSggbmFtZS5zbGljZSggNSApICk7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH1cblxuXHRcdC8vIFNldHMgbXVsdGlwbGUgdmFsdWVzXG5cdFx0aWYgKCB0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5ICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGRhdGE7XG5cblx0XHRcdC8vIFRoZSBjYWxsaW5nIGpRdWVyeSBvYmplY3QgKGVsZW1lbnQgbWF0Y2hlcykgaXMgbm90IGVtcHR5XG5cdFx0XHQvLyAoYW5kIHRoZXJlZm9yZSBoYXMgYW4gZWxlbWVudCBhcHBlYXJzIGF0IHRoaXNbIDAgXSkgYW5kIHRoZVxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3Rcblx0XHRcdC8vIHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGZvciBlbGVtID0gdGhpc1sgMCBdIHdoaWNoIHdpbGxcblx0XHRcdC8vIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhbiBhdHRlbXB0IHRvIHJlYWQgYSBkYXRhIGNhY2hlIGlzIG1hZGUuXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXG5cdFx0XHRcdC8vIFRoZSBrZXkgd2lsbCBhbHdheXMgYmUgY2FtZWxDYXNlZCBpbiBEYXRhXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gXCJkaXNjb3ZlclwiIHRoZSBkYXRhIGluXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcblx0XHRcdFx0ZGF0YSA9IGRhdGFBdHRyKCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzdG9yZSB0aGUgY2FtZWxDYXNlZCBrZXlcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXksIHZhbHVlICk7XG5cdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRhdGFVc2VyLnJlbW92ZSggdGhpcywga2V5ICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHF1ZXVlO1xuXG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0dHlwZSA9ICggdHlwZSB8fCBcImZ4XCIgKSArIFwicXVldWVcIjtcblx0XHRcdHF1ZXVlID0gZGF0YVByaXYuZ2V0KCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdC8vIFNwZWVkIHVwIGRlcXVldWUgYnkgZ2V0dGluZyBvdXQgcXVpY2tseSBpZiB0aGlzIGlzIGp1c3QgYSBsb29rdXBcblx0XHRcdGlmICggZGF0YSApIHtcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgQXJyYXkuaXNBcnJheSggZGF0YSApICkge1xuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCB0eXBlLCBqUXVlcnkubWFrZUFycmF5KCBkYXRhICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcblx0XHR9XG5cdH0sXG5cblx0ZGVxdWV1ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCBlbGVtLCB0eXBlICksXG5cdFx0XHRzdGFydExlbmd0aCA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcblx0XHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCB0eXBlICksXG5cdFx0XHRuZXh0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XG5cdFx0XHR9O1xuXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxuXHRcdGlmICggZm4gPT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0c3RhcnRMZW5ndGgtLTtcblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXG5cdFx0XHQvLyBBZGQgYSBwcm9ncmVzcyBzZW50aW5lbCB0byBwcmV2ZW50IHRoZSBmeCBxdWV1ZSBmcm9tIGJlaW5nXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiApIHtcblx0XHRcdFx0cXVldWUudW5zaGlmdCggXCJpbnByb2dyZXNzXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2xlYXIgdXAgdGhlIGxhc3QgcXVldWUgc3RvcCBmdW5jdGlvblxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRmbi5jYWxsKCBlbGVtLCBuZXh0LCBob29rcyApO1xuXHRcdH1cblxuXHRcdGlmICggIXN0YXJ0TGVuZ3RoICYmIGhvb2tzICkge1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvLyBOb3QgcHVibGljIC0gZ2VuZXJhdGUgYSBxdWV1ZUhvb2tzIG9iamVjdCwgb3IgcmV0dXJuIHRoZSBjdXJyZW50IG9uZVxuXHRfcXVldWVIb29rczogZnVuY3Rpb24oIGVsZW0sIHR5cGUgKSB7XG5cdFx0dmFyIGtleSA9IHR5cGUgKyBcInF1ZXVlSG9va3NcIjtcblx0XHRyZXR1cm4gZGF0YVByaXYuZ2V0KCBlbGVtLCBrZXkgKSB8fCBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIGtleSwge1xuXHRcdFx0ZW1wdHk6IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLmFkZCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgWyB0eXBlICsgXCJxdWV1ZVwiLCBrZXkgXSApO1xuXHRcdFx0fSApXG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBzZXR0ZXIgPSAyO1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGRhdGEgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IFwiZnhcIjtcblx0XHRcdHNldHRlci0tO1xuXHRcdH1cblxuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA8IHNldHRlciApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucXVldWUoIHRoaXNbIDAgXSwgdHlwZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcyA6XG5cdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIGRhdGEgKTtcblxuXHRcdFx0XHQvLyBFbnN1cmUgYSBob29rcyBmb3IgdGhpcyBxdWV1ZVxuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiZnhcIiAmJiBxdWV1ZVsgMCBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdH0sXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHR9ICk7XG5cdH0sXG5cdGNsZWFyUXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0fSxcblxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXG5cdC8vIGFyZSBlbXB0aWVkIChmeCBpcyB0aGUgdHlwZSBieSBkZWZhdWx0KVxuXHRwcm9taXNlOiBmdW5jdGlvbiggdHlwZSwgb2JqICkge1xuXHRcdHZhciB0bXAsXG5cdFx0XHRjb3VudCA9IDEsXG5cdFx0XHRkZWZlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxuXHRcdFx0aSA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0cmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcblx0XHRcdFx0XHRkZWZlci5yZXNvbHZlV2l0aCggZWxlbWVudHMsIFsgZWxlbWVudHMgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG9iaiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRtcCA9IGRhdGFQcml2LmdldCggZWxlbWVudHNbIGkgXSwgdHlwZSArIFwicXVldWVIb29rc1wiICk7XG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XG5cdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdHRtcC5lbXB0eS5hZGQoIHJlc29sdmUgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmVzb2x2ZSgpO1xuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcblx0fVxufSApO1xudmFyIHBudW0gPSAoIC9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvICkuc291cmNlO1xuXG52YXIgcmNzc051bSA9IG5ldyBSZWdFeHAoIFwiXig/OihbKy1dKT18KShcIiArIHBudW0gKyBcIikoW2EteiVdKikkXCIsIFwiaVwiICk7XG5cblxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xuXG52YXIgaXNIaWRkZW5XaXRoaW5UcmVlID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xuXG5cdFx0Ly8gaXNIaWRkZW5XaXRoaW5UcmVlIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cblx0XHQvLyBJbmxpbmUgc3R5bGUgdHJ1bXBzIGFsbFxuXHRcdHJldHVybiBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiZcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBjaGVjayBjb21wdXRlZCBzdHlsZVxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQzIC0gNDVcblx0XHRcdC8vIERpc2Nvbm5lY3RlZCBlbGVtZW50cyBjYW4gaGF2ZSBjb21wdXRlZCBkaXNwbGF5OiBub25lLCBzbyBmaXJzdCBjb25maXJtIHRoYXQgZWxlbSBpc1xuXHRcdFx0Ly8gaW4gdGhlIGRvY3VtZW50LlxuXHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLCBzY2FsZSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdFx0Ly8gSGFsdmUgdGhlIGl0ZXJhdGlvbiB0YXJnZXQgdmFsdWUgdG8gcHJldmVudCBpbnRlcmZlcmVuY2UgZnJvbSBDU1MgdXBwZXIgYm91bmRzIChnaC0yMTQ0KVxuXHRcdGluaXRpYWwgPSBpbml0aWFsIC8gMjtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0d2hpbGUgKCBtYXhJdGVyYXRpb25zLS0gKSB7XG5cblx0XHRcdC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXG5cdFx0XHQvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cdFx0XHRpZiAoICggMSAtIHNjYWxlICkgKiAoIDEgLSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSApICkgPD0gMCApIHtcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuXHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKykvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBjb250YWlucywgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIHRvVHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBjb250YWlucyApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xufSApKCk7XG52YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBTZWUgIzEzMzkzIGZvciBtb3JlIGluZm9cbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRpZiAoICFlbGVtRGF0YSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXG5cdFx0Ly8gRXZhbHVhdGUgYWdhaW5zdCBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBlbGVtIGlzIGEgbm9uLWVsZW1lbnQgbm9kZSAoZS5nLiwgZG9jdW1lbnQpXG5cdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZG9jdW1lbnRFbGVtZW50LCBzZWxlY3RvciApO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cblx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3Rcblx0XHR2YXIgZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApO1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXG5cdFx0XHRoYW5kbGVycyA9ICggZGF0YVByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbIDAgXSA9IGV2ZW50O1xuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcblx0XHR9XG5cblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuXHRcdFx0XHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRjdXIubm9kZVR5cGUgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHQhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0Y3VyID0gdGhpcztcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBpc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcblx0XHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRvcmlnaW5hbEV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Zm9jdXM6IHtcblxuXHRcdFx0Ly8gRmlyZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzICE9PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuZm9jdXMgKSB7XG5cdFx0XHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcblx0XHR9LFxuXHRcdGJsdXI6IHtcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMgPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5ibHVyICkge1xuXHRcdFx0XHRcdHRoaXMuYmx1cigpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBGb3IgY2hlY2tib3gsIGZpcmUgbmF0aXZlIGV2ZW50IHNvIGNoZWNrZWQgc3RhdGUgd2lsbCBiZSByaWdodFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy50eXBlID09PSBcImNoZWNrYm94XCIgJiYgdGhpcy5jbGljayAmJiBub2RlTmFtZSggdGhpcywgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5jbGljaygpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRyZXR1cm4gbm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seVxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0XHQvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgPD02IC0gNyBvbmx5XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHR0aGlzLnRhcmdldCA9ICggc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkgP1xuXHRcdFx0c3JjLnRhcmdldC5wYXJlbnROb2RlIDpcblx0XHRcdHNyYy50YXJnZXQ7XG5cblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcblx0XHR0aGlzLnJlbGF0ZWRUYXJnZXQgPSBzcmMucmVsYXRlZFRhcmdldDtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc1NpbXVsYXRlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcbmpRdWVyeS5lYWNoKCB7XG5cdGFsdEtleTogdHJ1ZSxcblx0YnViYmxlczogdHJ1ZSxcblx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0Y2hhbmdlZFRvdWNoZXM6IHRydWUsXG5cdGN0cmxLZXk6IHRydWUsXG5cdGRldGFpbDogdHJ1ZSxcblx0ZXZlbnRQaGFzZTogdHJ1ZSxcblx0bWV0YUtleTogdHJ1ZSxcblx0cGFnZVg6IHRydWUsXG5cdHBhZ2VZOiB0cnVlLFxuXHRzaGlmdEtleTogdHJ1ZSxcblx0dmlldzogdHJ1ZSxcblx0XCJjaGFyXCI6IHRydWUsXG5cdGNoYXJDb2RlOiB0cnVlLFxuXHRrZXk6IHRydWUsXG5cdGtleUNvZGU6IHRydWUsXG5cdGJ1dHRvbjogdHJ1ZSxcblx0YnV0dG9uczogdHJ1ZSxcblx0Y2xpZW50WDogdHJ1ZSxcblx0Y2xpZW50WTogdHJ1ZSxcblx0b2Zmc2V0WDogdHJ1ZSxcblx0b2Zmc2V0WTogdHJ1ZSxcblx0cG9pbnRlcklkOiB0cnVlLFxuXHRwb2ludGVyVHlwZTogdHJ1ZSxcblx0c2NyZWVuWDogdHJ1ZSxcblx0c2NyZWVuWTogdHJ1ZSxcblx0dGFyZ2V0VG91Y2hlczogdHJ1ZSxcblx0dG9FbGVtZW50OiB0cnVlLFxuXHR0b3VjaGVzOiB0cnVlLFxuXG5cdHdoaWNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcblxuXHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCAmJiBya2V5RXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0cmV0dXJuIGV2ZW50LmNoYXJDb2RlICE9IG51bGwgPyBldmVudC5jaGFyQ29kZSA6IGV2ZW50LmtleUNvZGU7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIHJtb3VzZUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdGlmICggYnV0dG9uICYgMSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgMiApIHtcblx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgNCApIHtcblx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC53aGljaDtcblx0fVxufSwgalF1ZXJ5LmV2ZW50LmFkZFByb3AgKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8zMjI5XG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLFxuXG5cdC8qIGVzbGludC1lbmFibGUgKi9cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxMyBvbmx5XG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHRpZiAoICggZWxlbS50eXBlIHx8IFwiXCIgKS5zbGljZSggMCwgNSApID09PSBcInRydWUvXCIgKSB7XG5cdFx0ZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBkb2MsIG5vZGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGpRdWVyeS5jb250YWlucyggbm9kZS5vd25lckRvY3VtZW50LCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbC5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxudmFyIHJib3hTdHlsZSA9IG5ldyBSZWdFeHAoIGNzc0V4cGFuZC5qb2luKCBcInxcIiApLCBcImlcIiApO1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblxuXHQvLyBFeGVjdXRpbmcgYm90aCBwaXhlbFBvc2l0aW9uICYgYm94U2l6aW5nUmVsaWFibGUgdGVzdHMgcmVxdWlyZSBvbmx5IG9uZSBsYXlvdXRcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cblx0ZnVuY3Rpb24gY29tcHV0ZVN0eWxlVGVzdHMoKSB7XG5cblx0XHQvLyBUaGlzIGlzIGEgc2luZ2xldG9uLCB3ZSBuZWVkIHRvIGV4ZWN1dGUgaXQgb25seSBvbmNlXG5cdFx0aWYgKCAhZGl2ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4O3dpZHRoOjYwcHg7XCIgK1xuXHRcdFx0XCJtYXJnaW4tdG9wOjFweDtwYWRkaW5nOjA7Ym9yZGVyOjBcIjtcblx0XHRkaXYuc3R5bGUuY3NzVGV4dCA9XG5cdFx0XHRcInBvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O292ZXJmbG93OnNjcm9sbDtcIiArXG5cdFx0XHRcIm1hcmdpbjphdXRvO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7XCIgK1xuXHRcdFx0XCJ3aWR0aDo2MCU7dG9wOjElXCI7XG5cdFx0ZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKCBjb250YWluZXIgKS5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0XHR2YXIgZGl2U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZGl2ICk7XG5cdFx0cGl4ZWxQb3NpdGlvblZhbCA9IGRpdlN0eWxlLnRvcCAhPT0gXCIxJVwiO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgRmlyZWZveCA8PTMgLSA0NFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUubWFyZ2luTGVmdCApID09PSAxMjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIFNhZmFyaSA8PTkuMSAtIDEwLjEsIGlPUyA8PTcuMCAtIDkuM1xuXHRcdC8vIFNvbWUgc3R5bGVzIGNvbWUgYmFjayB3aXRoIHBlcmNlbnRhZ2UgdmFsdWVzLCBldmVuIHRob3VnaCB0aGV5IHNob3VsZG4ndFxuXHRcdGRpdi5zdHlsZS5yaWdodCA9IFwiNjAlXCI7XG5cdFx0cGl4ZWxCb3hTdHlsZXNWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLnJpZ2h0ICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0XHQvLyBEZXRlY3QgbWlzcmVwb3J0aW5nIG9mIGNvbnRlbnQgZGltZW5zaW9ucyBmb3IgYm94LXNpemluZzpib3JkZXItYm94IGVsZW1lbnRzXG5cdFx0Ym94U2l6aW5nUmVsaWFibGVWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLndpZHRoICkgPT09IDM2O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG92ZXJmbG93OnNjcm9sbCBzY3Jld2luZXNzIChnaC0zNjk5KVxuXHRcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzY3JvbGxib3hTaXplVmFsID0gZGl2Lm9mZnNldFdpZHRoID09PSAzNiB8fCBcImFic29sdXRlXCI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0Ly8gTnVsbGlmeSB0aGUgZGl2IHNvIGl0IHdvdWxkbid0IGJlIHN0b3JlZCBpbiB0aGUgbWVtb3J5IGFuZFxuXHRcdC8vIGl0IHdpbGwgYWxzbyBiZSBhIHNpZ24gdGhhdCBjaGVja3MgYWxyZWFkeSBwZXJmb3JtZWRcblx0XHRkaXYgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gcm91bmRQaXhlbE1lYXN1cmVzKCBtZWFzdXJlICkge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKCBwYXJzZUZsb2F0KCBtZWFzdXJlICkgKTtcblx0fVxuXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgc2Nyb2xsYm94U2l6ZVZhbCwgcGl4ZWxCb3hTdHlsZXNWYWwsXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0fSxcblx0XHRwaXhlbEJveFN0eWxlczogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsQm94U3R5bGVzVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fSxcblx0XHRzY3JvbGxib3hTaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gc2Nyb2xsYm94U2l6ZVZhbDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDUxK1xuXHRcdC8vIFJldHJpZXZpbmcgc3R5bGUgYmVmb3JlIGNvbXB1dGVkIHNvbWVob3dcblx0XHQvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXG5cdFx0Ly8gb24gZGV0YWNoZWQgZWxlbWVudHNcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XG5cdC8vICAgLmNzcygnZmlsdGVyJykgKElFIDkgb25seSwgIzEyNTM3KVxuXHQvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpICgjMzE0NClcblx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbEJveFN0eWxlcygpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiByYm94U3R5bGUudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRyY3VzdG9tUHJvcCA9IC9eLS0vLFxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fSxcblxuXHRjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGU7XG5cbi8vIFJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIFNob3J0Y3V0IGZvciBuYW1lcyB0aGF0IGFyZSBub3QgdmVuZG9yIHByZWZpeGVkXG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbi8vIFJldHVybiBhIHByb3BlcnR5IG1hcHBlZCBhbG9uZyB3aGF0IGpRdWVyeS5jc3NQcm9wcyBzdWdnZXN0cyBvciB0b1xuLy8gYSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHkuXG5mdW5jdGlvbiBmaW5hbFByb3BOYW1lKCBuYW1lICkge1xuXHR2YXIgcmV0ID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF07XG5cdGlmICggIXJldCApIHtcblx0XHRyZXQgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBuYW1lICkgfHwgbmFtZTtcblx0fVxuXHRyZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgYm94LCBpc0JvcmRlckJveCwgc3R5bGVzLCBjb21wdXRlZFZhbCApIHtcblx0dmFyIGkgPSBkaW1lbnNpb24gPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXHRcdGV4dHJhID0gMCxcblx0XHRkZWx0YSA9IDA7XG5cblx0Ly8gQWRqdXN0bWVudCBtYXkgbm90IGJlIG5lY2Vzc2FyeVxuXHRpZiAoIGJveCA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApICkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luXG5cdFx0aWYgKCBib3ggPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBib3ggKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGNvbnRlbnQtYm94LCB3ZSdyZSBzZWVraW5nIFwicGFkZGluZ1wiIG9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIlxuXHRcdGlmICggIWlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBBZGQgcGFkZGluZ1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEZvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCIsIGFkZCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQnV0IHN0aWxsIGtlZXAgdHJhY2sgb2YgaXQgb3RoZXJ3aXNlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRleHRyYSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGJvcmRlci1ib3ggKGNvbnRlbnQgKyBwYWRkaW5nICsgYm9yZGVyKSwgd2UncmUgc2Vla2luZyBcImNvbnRlbnRcIiBvclxuXHRcdC8vIFwicGFkZGluZ1wiIG9yIFwibWFyZ2luXCJcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIsIHN1YnRyYWN0IHBhZGRpbmdcblx0XHRcdGlmICggYm94ID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiBvciBcInBhZGRpbmdcIiwgc3VidHJhY3QgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBY2NvdW50IGZvciBwb3NpdGl2ZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyIHdoZW4gcmVxdWVzdGVkIGJ5IHByb3ZpZGluZyBjb21wdXRlZFZhbFxuXHRpZiAoICFpc0JvcmRlckJveCAmJiBjb21wdXRlZFZhbCA+PSAwICkge1xuXG5cdFx0Ly8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIGEgcm91bmRlZCBzdW0gb2YgY29udGVudCwgcGFkZGluZywgc2Nyb2xsIGd1dHRlciwgYW5kIGJvcmRlclxuXHRcdC8vIEFzc3VtaW5nIGludGVnZXIgc2Nyb2xsIGd1dHRlciwgc3VidHJhY3QgdGhlIHJlc3QgYW5kIHJvdW5kIGRvd25cblx0XHRkZWx0YSArPSBNYXRoLm1heCggMCwgTWF0aC5jZWlsKFxuXHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdGNvbXB1dGVkVmFsIC1cblx0XHRcdGRlbHRhIC1cblx0XHRcdGV4dHJhIC1cblx0XHRcdDAuNVxuXHRcdCkgKTtcblx0fVxuXG5cdHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIGRpbWVuc2lvbiwgc3R5bGVzICksXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveDtcblxuXHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0Ly8gUmV0dXJuIGEgY29uZm91bmRpbmcgbm9uLXBpeGVsIHZhbHVlIG9yIGZlaWduIGlnbm9yYW5jZSwgYXMgYXBwcm9wcmlhdGUuXG5cdGlmICggcm51bW5vbnB4LnRlc3QoIHZhbCApICkge1xuXHRcdGlmICggIWV4dHJhICkge1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cdFx0dmFsID0gXCJhdXRvXCI7XG5cdH1cblxuXHQvLyBDaGVjayBmb3Igc3R5bGUgaW4gY2FzZSBhIGJyb3dzZXIgd2hpY2ggcmV0dXJucyB1bnJlbGlhYmxlIHZhbHVlc1xuXHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXG5cdHZhbHVlSXNCb3JkZXJCb3ggPSB2YWx1ZUlzQm9yZGVyQm94ICYmXG5cdFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSApO1xuXG5cdC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxuXHQvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgLSA0LjMgb25seVxuXHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIG1pc3JlcG9ydGVkIGlubGluZSBkaW1lbnNpb25zIChnaC0zNjAyKVxuXHRpZiAoIHZhbCA9PT0gXCJhdXRvXCIgfHxcblx0XHQhcGFyc2VGbG9hdCggdmFsICkgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJpbmxpbmVcIiApIHtcblxuXHRcdHZhbCA9IGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXTtcblxuXHRcdC8vIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBwcm92aWRlIGJvcmRlci1ib3ggdmFsdWVzXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IHRydWU7XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiBhbmQgYXV0b1xuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcblx0cmV0dXJuICggdmFsICtcblx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlcyxcblxuXHRcdFx0Ly8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcblx0XHRcdHZhbFxuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHt9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gcXVlcnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBkaW1lbnNpb24gKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRcdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhICYmIGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdGRpbWVuc2lvbixcblx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRpc0JvcmRlckJveCxcblx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0KTtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdW5yZWxpYWJsZSBib3JkZXItYm94IGRpbWVuc2lvbnMgYnkgY29tcGFyaW5nIG9mZnNldCogdG8gY29tcHV0ZWQgYW5kXG5cdFx0XHQvLyBmYWtpbmcgYSBjb250ZW50LWJveCB0byBnZXQgYm9yZGVyIGFuZCBwYWRkaW5nIChnaC0zNjk5KVxuXHRcdFx0aWYgKCBpc0JvcmRlckJveCAmJiBzdXBwb3J0LnNjcm9sbGJveFNpemUoKSA9PT0gc3R5bGVzLnBvc2l0aW9uICkge1xuXHRcdFx0XHRzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXG5cdFx0XHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdFx0XHRwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBcImJvcmRlclwiLCBmYWxzZSwgc3R5bGVzICkgLVxuXHRcdFx0XHRcdDAuNVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgZGltZW5zaW9uICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBwcmVmaXggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCB0d2Vlbi5lbGVtLnN0eWxlWyBqUXVlcnkuY3NzUHJvcHNbIHR3ZWVuLnByb3AgXSBdICE9IG51bGwgfHxcblx0XHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xuXHRcdC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0cmVzdWx0LnN0b3AuYmluZCggcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0YW5pbWF0aW9uXG5cdFx0LnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHRyZXR1cm4gYW5pbWF0aW9uO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBEYXRlLm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGpRdWVyeS5meC5zdGFydCgpO1xufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRzY2hlZHVsZSgpO1xufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aW5Qcm9ncmVzcyA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblxuXHRcdFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHR9XG5cdHJldHVybiBbXTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsXG5cdFx0XHRpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggaXNWYWxpZFZhbHVlICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0c3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiggZSApIHtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGxhc3RFbGVtZW50ID0gY3VyO1xuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0gRGF0ZS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0gaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKVxuXHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9IClcblx0XHQubWFwKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbnZhclxuXHRyMjAgPSAvJTIwL2csXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRyYW50aUNhY2hlID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0b3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcblx0XHRcdGNvbXBsZXRlZCxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG5cdFx0XHR1bmNhY2hlZCxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuXHRcdFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cblx0XHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG5cdFx0XHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUgYW5kIHNob3VsZCBiZSBwcm9jZXNzZWQsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgJiYgKCBzLnByb2Nlc3NEYXRhIHx8IHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgKSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UrKyApICsgdW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0Y2FjaGU6IHRydWUsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cdFx0XCJ0aHJvd3NcIjogdHJ1ZVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0XHRodG1sID0gaHRtbC5jYWxsKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBodG1sSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbElzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dGhpcy5wYXJlbnQoIHNlbGVjdG9yICkubm90KCBcImJvZHlcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XG59O1xuXG5cblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn07XG5cbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG5cdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID1cblx0XHRcdFx0XHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSB4aHIub250aW1lb3V0ID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcblx0fVxufSApO1xuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApLnByb3AoIHtcblx0XHRcdFx0XHRjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsXG5cdFx0XHRcdFx0c3JjOiBzLnVybFxuXHRcdFx0XHR9ICkub24oXG5cdFx0XHRcdFx0XCJsb2FkIGVycm9yXCIsXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1Jcblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XG5cdC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuXHRcdFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxuXHRcdFx0XHQoIG9mZnNldFBhcmVudCA9PT0gZG9jLmJvZHkgfHwgb2Zmc2V0UGFyZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkgJiZcblx0XHRcdFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblxuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGlmICggb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG4vLyBhcmd1bWVudHMuXG4vLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXG4vLyBIb3dldmVyLCBpdCBpcyBub3Qgc2xhdGVkIGZvciByZW1vdmFsIGFueSB0aW1lIHNvb25cbmpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdGNvbnRleHQgPSBmbjtcblx0XHRmbiA9IHRtcDtcblx0fVxuXG5cdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdGlmICggIWlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNpbXVsYXRlZCBiaW5kXG5cdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0fTtcblxuXHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0cmV0dXJuIHByb3h5O1xufTtcblxualF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuXHRpZiAoIGhvbGQgKSB7XG5cdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHR9XG59O1xualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5qUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcbmpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmpRdWVyeS5pc1dpbmRvdyA9IGlzV2luZG93O1xualF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbmpRdWVyeS50eXBlID0gdG9UeXBlO1xuXG5qUXVlcnkubm93ID0gRGF0ZS5ub3c7XG5cbmpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiggb2JqICkge1xuXG5cdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xufTtcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAgIGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cG9ydHMubm9kZU5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIENvbW1vbkpTXG4gICAgICAgIGZhY3RvcnkoZXhwb3J0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgICAgIGZhY3Rvcnkocm9vdC5tYXF1ZXR0ZSA9IHt9KTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIENvbW1lbnQgdGhhdCBpcyBkaXNwbGF5ZWQgaW4gdGhlIEFQSSBkb2N1bWVudGF0aW9uIGZvciB0aGUgbWFxdWV0dGUgbW9kdWxlOlxuICAgIC8qKlxuICogV2VsY29tZSB0byB0aGUgQVBJIGRvY3VtZW50YXRpb24gb2YgdGhlICoqbWFxdWV0dGUqKiBsaWJyYXJ5LlxuICpcbiAqIFtbaHR0cDovL21hcXVldHRlanMub3JnL3xUbyB0aGUgbWFxdWV0dGUgaG9tZXBhZ2VdXVxuICovXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICB2YXIgTkFNRVNQQUNFX1czID0gJ2h0dHA6Ly93d3cudzMub3JnLyc7XG4gICAgdmFyIE5BTUVTUEFDRV9TVkcgPSBOQU1FU1BBQ0VfVzMgKyAnMjAwMC9zdmcnO1xuICAgIHZhciBOQU1FU1BBQ0VfWExJTksgPSBOQU1FU1BBQ0VfVzMgKyAnMTk5OS94bGluayc7XG4gICAgLy8gVXRpbGl0aWVzXG4gICAgdmFyIGVtcHR5QXJyYXkgPSBbXTtcbiAgICB2YXIgZXh0ZW5kID0gZnVuY3Rpb24gKGJhc2UsIG92ZXJyaWRlcykge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGJhc2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBiYXNlW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvdmVycmlkZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gb3ZlcnJpZGVzW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgLy8gSHlwZXJzY3JpcHQgaGVscGVyIGZ1bmN0aW9uc1xuICAgIHZhciBzYW1lID0gZnVuY3Rpb24gKHZub2RlMSwgdm5vZGUyKSB7XG4gICAgICAgIGlmICh2bm9kZTEudm5vZGVTZWxlY3RvciAhPT0gdm5vZGUyLnZub2RlU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm5vZGUxLnByb3BlcnRpZXMgJiYgdm5vZGUyLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmICh2bm9kZTEucHJvcGVydGllcy5rZXkgIT09IHZub2RlMi5wcm9wZXJ0aWVzLmtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2bm9kZTEucHJvcGVydGllcy5iaW5kID09PSB2bm9kZTIucHJvcGVydGllcy5iaW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhdm5vZGUxLnByb3BlcnRpZXMgJiYgIXZub2RlMi5wcm9wZXJ0aWVzO1xuICAgIH07XG4gICAgdmFyIHRvVGV4dFZOb2RlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZub2RlU2VsZWN0b3I6ICcnLFxuICAgICAgICAgICAgcHJvcGVydGllczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2hpbGRyZW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRleHQ6IGRhdGEudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGRvbU5vZGU6IG51bGxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBhcHBlbmRDaGlsZHJlbiA9IGZ1bmN0aW9uIChwYXJlbnRTZWxlY3RvciwgaW5zZXJ0aW9ucywgbWFpbikge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoXzEgPSBpbnNlcnRpb25zLmxlbmd0aDsgaSA8IGxlbmd0aF8xOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gaW5zZXJ0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kQ2hpbGRyZW4ocGFyZW50U2VsZWN0b3IsIGl0ZW0sIG1haW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAhPT0gbnVsbCAmJiBpdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtLmhhc093blByb3BlcnR5KCd2bm9kZVNlbGVjdG9yJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB0b1RleHRWTm9kZShpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYWluLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBSZW5kZXIgaGVscGVyIGZ1bmN0aW9uc1xuICAgIHZhciBtaXNzaW5nVHJhbnNpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlIGEgdHJhbnNpdGlvbnMgb2JqZWN0IHRvIHRoZSBwcm9qZWN0aW9uT3B0aW9ucyB0byBkbyBhbmltYXRpb25zJyk7XG4gICAgfTtcbiAgICB2YXIgREVGQVVMVF9QUk9KRUNUSU9OX09QVElPTlMgPSB7XG4gICAgICAgIG5hbWVzcGFjZTogdW5kZWZpbmVkLFxuICAgICAgICBldmVudEhhbmRsZXJJbnRlcmNlcHRvcjogdW5kZWZpbmVkLFxuICAgICAgICBzdHlsZUFwcGx5ZXI6IGZ1bmN0aW9uIChkb21Ob2RlLCBzdHlsZU5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBQcm92aWRlcyBhIGhvb2sgdG8gYWRkIHZlbmRvciBwcmVmaXhlcyBmb3IgYnJvd3NlcnMgdGhhdCBzdGlsbCBuZWVkIGl0LlxuICAgICAgICAgICAgZG9tTm9kZS5zdHlsZVtzdHlsZU5hbWVdID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zaXRpb25zOiB7XG4gICAgICAgICAgICBlbnRlcjogbWlzc2luZ1RyYW5zaXRpb24sXG4gICAgICAgICAgICBleGl0OiBtaXNzaW5nVHJhbnNpdGlvblxuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgYXBwbHlEZWZhdWx0UHJvamVjdGlvbk9wdGlvbnMgPSBmdW5jdGlvbiAocHJvamVjdG9yT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKERFRkFVTFRfUFJPSkVDVElPTl9PUFRJT05TLCBwcm9qZWN0b3JPcHRpb25zKTtcbiAgICB9O1xuICAgIHZhciBjaGVja1N0eWxlVmFsdWUgPSBmdW5jdGlvbiAoc3R5bGVWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0eWxlIHZhbHVlcyBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHNldFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZG9tTm9kZSwgcHJvcGVydGllcywgcHJvamVjdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlckludGVyY2VwdG9yID0gcHJvamVjdGlvbk9wdGlvbnMuZXZlbnRIYW5kbGVySW50ZXJjZXB0b3I7XG4gICAgICAgIHZhciBwcm9wTmFtZXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKTtcbiAgICAgICAgdmFyIHByb3BDb3VudCA9IHByb3BOYW1lcy5sZW5ndGg7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BOYW1lc1tpXTtcbiAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLXZhci1rZXl3b3JkOiBlZGdlIGNhc2UgKi9cbiAgICAgICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIC8qIHRzbGludDplbmFibGU6bm8tdmFyLWtleXdvcmQgKi9cbiAgICAgICAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ2NsYXNzTmFtZScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3BlcnR5IFwiY2xhc3NOYW1lXCIgaXMgbm90IHN1cHBvcnRlZCwgdXNlIFwiY2xhc3NcIi4nKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcE5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgICAgICAgICAgICBwcm9wVmFsdWUuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9tTm9kZS5jbGFzc0xpc3QuYWRkKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcE5hbWUgPT09ICdjbGFzc2VzJykge1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdCB3aXRoIHN0cmluZyBrZXlzIGFuZCBib29sZWFuIHZhbHVlc1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWVzID0gT2JqZWN0LmtleXMocHJvcFZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lQ291bnQgPSBjbGFzc05hbWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNsYXNzTmFtZUNvdW50OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wVmFsdWVbY2xhc3NOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BOYW1lID09PSAnc3R5bGVzJykge1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdCB3aXRoIHN0cmluZyBrZXlzIGFuZCBzdHJpbmcgKCEpIHZhbHVlc1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZU5hbWVzID0gT2JqZWN0LmtleXMocHJvcFZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVDb3VudCA9IHN0eWxlTmFtZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3R5bGVDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZU5hbWUgPSBzdHlsZU5hbWVzW2pdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGVWYWx1ZSA9IHByb3BWYWx1ZVtzdHlsZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tTdHlsZVZhbHVlKHN0eWxlVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvamVjdGlvbk9wdGlvbnMuc3R5bGVBcHBseWVyKGRvbU5vZGUsIHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BOYW1lICE9PSAna2V5JyAmJiBwcm9wVmFsdWUgIT09IG51bGwgJiYgcHJvcFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BOYW1lLmxhc3RJbmRleE9mKCdvbicsIDApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRIYW5kbGVySW50ZXJjZXB0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUgPSBldmVudEhhbmRsZXJJbnRlcmNlcHRvcihwcm9wTmFtZSwgcHJvcFZhbHVlLCBkb21Ob2RlLCBwcm9wZXJ0aWVzKTsgICAgLy8gaW50ZXJjZXB0IGV2ZW50aGFuZGxlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ29uaW5wdXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjb3JkIHRoZSBldnQudGFyZ2V0LnZhbHVlLCBiZWNhdXNlIElFIGFuZCBFZGdlIHNvbWV0aW1lcyBkbyBhIHJlcXVlc3RBbmltYXRpb25GcmFtZSBiZXR3ZWVuIGNoYW5naW5nIHZhbHVlIGFuZCBydW5uaW5nIG9uaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFByb3BWYWx1ZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkUHJvcFZhbHVlLmFwcGx5KHRoaXMsIFtldnRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2dC50YXJnZXRbJ29uaW5wdXQtdmFsdWUnXSA9IGV2dC50YXJnZXQudmFsdWU7ICAgIC8vIG1heSBiZSBIVE1MVGV4dEFyZWFFbGVtZW50IGFzIHdlbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZVtwcm9wTmFtZV0gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHByb3BOYW1lICE9PSAndmFsdWUnICYmIHByb3BOYW1lICE9PSAnaW5uZXJIVE1MJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvamVjdGlvbk9wdGlvbnMubmFtZXNwYWNlID09PSBOQU1FU1BBQ0VfU1ZHICYmIHByb3BOYW1lID09PSAnaHJlZicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGUuc2V0QXR0cmlidXRlTlMoTkFNRVNQQUNFX1hMSU5LLCBwcm9wTmFtZSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGUuc2V0QXR0cmlidXRlKHByb3BOYW1lLCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tTm9kZVtwcm9wTmFtZV0gPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBfbG9vcF8xKGkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgdXBkYXRlUHJvcGVydGllcyA9IGZ1bmN0aW9uIChkb21Ob2RlLCBwcmV2aW91c1Byb3BlcnRpZXMsIHByb3BlcnRpZXMsIHByb2plY3Rpb25PcHRpb25zKSB7XG4gICAgICAgIGlmICghcHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzVXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgcHJvcE5hbWVzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyk7XG4gICAgICAgIHZhciBwcm9wQ291bnQgPSBwcm9wTmFtZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wTmFtZXNbaV07XG4gICAgICAgICAgICAvLyBhc3N1bWluZyB0aGF0IHByb3BlcnRpZXMgd2lsbCBiZSBudWxsaWZpZWQgaW5zdGVhZCBvZiBtaXNzaW5nIGlzIGJ5IGRlc2lnblxuICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BlcnRpZXNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzVmFsdWUgPSBwcmV2aW91c1Byb3BlcnRpZXNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgaWYgKHByb3BOYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUgIT09IHByb3BWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY2xhc3NcIiBwcm9wZXJ0eSBtYXkgbm90IGJlIHVwZGF0ZWQuIFVzZSB0aGUgXCJjbGFzc2VzXCIgcHJvcGVydHkgZm9yIGNvbmRpdGlvbmFsIGNzcyBjbGFzc2VzLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcE5hbWUgPT09ICdjbGFzc2VzJykge1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc0xpc3QgPSBkb21Ob2RlLmNsYXNzTGlzdDtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IE9iamVjdC5rZXlzKHByb3BWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZUNvdW50ID0gY2xhc3NOYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjbGFzc05hbWVDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBjbGFzc05hbWVzW2pdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb24gPSAhIXByb3BWYWx1ZVtjbGFzc05hbWVdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNPbiA9ICEhcHJldmlvdXNWYWx1ZVtjbGFzc05hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAob24gPT09IHByZXZpb3VzT24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXNVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BOYW1lID09PSAnc3R5bGVzJykge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZU5hbWVzID0gT2JqZWN0LmtleXMocHJvcFZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVDb3VudCA9IHN0eWxlTmFtZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3R5bGVDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZU5hbWUgPSBzdHlsZU5hbWVzW2pdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U3R5bGVWYWx1ZSA9IHByb3BWYWx1ZVtzdHlsZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2xkU3R5bGVWYWx1ZSA9IHByZXZpb3VzVmFsdWVbc3R5bGVOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1N0eWxlVmFsdWUgPT09IG9sZFN0eWxlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXNVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1N0eWxlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrU3R5bGVWYWx1ZShuZXdTdHlsZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3Rpb25PcHRpb25zLnN0eWxlQXBwbHllcihkb21Ob2RlLCBzdHlsZU5hbWUsIG5ld1N0eWxlVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvamVjdGlvbk9wdGlvbnMuc3R5bGVBcHBseWVyKGRvbU5vZGUsIHN0eWxlTmFtZSwgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BWYWx1ZSAmJiB0eXBlb2YgcHJldmlvdXNWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9tVmFsdWUgPSBkb21Ob2RlW3Byb3BOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbVZhbHVlICE9PSBwcm9wVmFsdWUgICAgLy8gVGhlICd2YWx1ZScgaW4gdGhlIERPTSB0cmVlICE9PSBuZXdWYWx1ZVxuJiYgKGRvbU5vZGVbJ29uaW5wdXQtdmFsdWUnXSA/IGRvbVZhbHVlID09PSBkb21Ob2RlWydvbmlucHV0LXZhbHVlJ10gICAgLy8gSWYgdGhlIGxhc3QgcmVwb3J0ZWQgdmFsdWUgdG8gJ29uaW5wdXQnIGRvZXMgbm90IG1hdGNoIGRvbVZhbHVlLCBkbyBub3RoaW5nIGFuZCB3YWl0IGZvciBvbmlucHV0XG4gOiBwcm9wVmFsdWUgIT09IHByZXZpb3VzVmFsdWUgICAgLy8gT25seSB1cGRhdGUgdGhlIHZhbHVlIGlmIHRoZSB2ZG9tIGNoYW5nZWRcbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGVbcHJvcE5hbWVdID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHZhbHVlLCBldmVuIGlmIHRoZSB2aXJ0dWFsIERPTSBkaWQgbm90IGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZVsnb25pbnB1dC12YWx1ZSddID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgZG8gbm90IHVwZGF0ZSB0aGUgZG9tTm9kZSwgb3RoZXJ3aXNlIHRoZSBjdXJzb3IgcG9zaXRpb24gd291bGQgYmUgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcFZhbHVlICE9PSBwcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzVXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSAhPT0gcHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9ucyBtYXkgbm90IGJlIHVwZGF0ZWQgb24gc3Vic2VxdWVudCByZW5kZXJzIChwcm9wZXJ0eTogJyArIHByb3BOYW1lICsgJykuIEhpbnQ6IGRlY2xhcmUgZXZlbnQgaGFuZGxlciBmdW5jdGlvbnMgb3V0c2lkZSB0aGUgcmVuZGVyKCkgZnVuY3Rpb24uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHByb3BOYW1lICE9PSAnaW5uZXJIVE1MJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2plY3Rpb25PcHRpb25zLm5hbWVzcGFjZSA9PT0gTkFNRVNQQUNFX1NWRyAmJiBwcm9wTmFtZSA9PT0gJ2hyZWYnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5zZXRBdHRyaWJ1dGVOUyhOQU1FU1BBQ0VfWExJTkssIHByb3BOYW1lLCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wTmFtZSA9PT0gJ3JvbGUnICYmIHByb3BWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLnJlbW92ZUF0dHJpYnV0ZShwcm9wTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGUuc2V0QXR0cmlidXRlKHByb3BOYW1lLCBwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbU5vZGVbcHJvcE5hbWVdICE9PSBwcm9wVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlW3Byb3BOYW1lXSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzVXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzVXBkYXRlZDtcbiAgICB9O1xuICAgIHZhciBmaW5kSW5kZXhPZkNoaWxkID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBzYW1lQXMsIHN0YXJ0KSB7XG4gICAgICAgIGlmIChzYW1lQXMudm5vZGVTZWxlY3RvciAhPT0gJycpIHtcbiAgICAgICAgICAgIC8vIE5ldmVyIHNjYW4gZm9yIHRleHQtbm9kZXNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhbWUoY2hpbGRyZW5baV0sIHNhbWVBcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICAgIHZhciBub2RlQWRkZWQgPSBmdW5jdGlvbiAodk5vZGUsIHRyYW5zaXRpb25zKSB7XG4gICAgICAgIGlmICh2Tm9kZS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB2YXIgZW50ZXJBbmltYXRpb24gPSB2Tm9kZS5wcm9wZXJ0aWVzLmVudGVyQW5pbWF0aW9uO1xuICAgICAgICAgICAgaWYgKGVudGVyQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRlckFuaW1hdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBlbnRlckFuaW1hdGlvbih2Tm9kZS5kb21Ob2RlLCB2Tm9kZS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9ucy5lbnRlcih2Tm9kZS5kb21Ob2RlLCB2Tm9kZS5wcm9wZXJ0aWVzLCBlbnRlckFuaW1hdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgbm9kZVRvUmVtb3ZlID0gZnVuY3Rpb24gKHZOb2RlLCB0cmFuc2l0aW9ucykge1xuICAgICAgICB2YXIgZG9tTm9kZSA9IHZOb2RlLmRvbU5vZGU7XG4gICAgICAgIGlmICh2Tm9kZS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB2YXIgZXhpdEFuaW1hdGlvbiA9IHZOb2RlLnByb3BlcnRpZXMuZXhpdEFuaW1hdGlvbjtcbiAgICAgICAgICAgIGlmIChleGl0QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIHZhciByZW1vdmVEb21Ob2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhpdEFuaW1hdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBleGl0QW5pbWF0aW9uKGRvbU5vZGUsIHJlbW92ZURvbU5vZGUsIHZOb2RlLnByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbnMuZXhpdCh2Tm9kZS5kb21Ob2RlLCB2Tm9kZS5wcm9wZXJ0aWVzLCBleGl0QW5pbWF0aW9uLCByZW1vdmVEb21Ob2RlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9tTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBkb21Ob2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tTm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjaGVja0Rpc3Rpbmd1aXNoYWJsZSA9IGZ1bmN0aW9uIChjaGlsZE5vZGVzLCBpbmRleFRvQ2hlY2ssIHBhcmVudFZOb2RlLCBvcGVyYXRpb24pIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaW5kZXhUb0NoZWNrXTtcbiAgICAgICAgaWYgKGNoaWxkTm9kZS52bm9kZVNlbGVjdG9yID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuOyAgICAvLyBUZXh0IG5vZGVzIG5lZWQgbm90IGJlIGRpc3Rpbmd1aXNoYWJsZVxuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gY2hpbGROb2RlLnByb3BlcnRpZXM7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wZXJ0aWVzID8gcHJvcGVydGllcy5rZXkgPT09IHVuZGVmaW5lZCA/IHByb3BlcnRpZXMuYmluZCA6IHByb3BlcnRpZXMua2V5IDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IGluZGV4VG9DaGVjaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzYW1lKG5vZGUsIGNoaWxkTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24gPT09ICdhZGRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocGFyZW50Vk5vZGUudm5vZGVTZWxlY3RvciArICcgaGFkIGEgJyArIGNoaWxkTm9kZS52bm9kZVNlbGVjdG9yICsgJyBjaGlsZCAnICsgJ2FkZGVkLCBidXQgdGhlcmUgaXMgbm93IG1vcmUgdGhhbiBvbmUuIFlvdSBtdXN0IGFkZCB1bmlxdWUga2V5IHByb3BlcnRpZXMgdG8gbWFrZSB0aGVtIGRpc3Rpbmd1aXNoYWJsZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHBhcmVudFZOb2RlLnZub2RlU2VsZWN0b3IgKyAnIGhhZCBhICcgKyBjaGlsZE5vZGUudm5vZGVTZWxlY3RvciArICcgY2hpbGQgJyArICdyZW1vdmVkLCBidXQgdGhlcmUgd2VyZSBtb3JlIHRoYW4gb25lLiBZb3UgbXVzdCBhZGQgdW5pcXVlIGtleSBwcm9wZXJ0aWVzIHRvIG1ha2UgdGhlbSBkaXN0aW5ndWlzaGFibGUuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjcmVhdGVEb207XG4gICAgdmFyIHVwZGF0ZURvbTtcbiAgICB2YXIgdXBkYXRlQ2hpbGRyZW4gPSBmdW5jdGlvbiAodm5vZGUsIGRvbU5vZGUsIG9sZENoaWxkcmVuLCBuZXdDaGlsZHJlbiwgcHJvamVjdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9sZENoaWxkcmVuID09PSBuZXdDaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG9sZENoaWxkcmVuID0gb2xkQ2hpbGRyZW4gfHwgZW1wdHlBcnJheTtcbiAgICAgICAgbmV3Q2hpbGRyZW4gPSBuZXdDaGlsZHJlbiB8fCBlbXB0eUFycmF5O1xuICAgICAgICB2YXIgb2xkQ2hpbGRyZW5MZW5ndGggPSBvbGRDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIHZhciBuZXdDaGlsZHJlbkxlbmd0aCA9IG5ld0NoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25zID0gcHJvamVjdGlvbk9wdGlvbnMudHJhbnNpdGlvbnM7XG4gICAgICAgIHZhciBvbGRJbmRleCA9IDA7XG4gICAgICAgIHZhciBuZXdJbmRleCA9IDA7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgdGV4dFVwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKG5ld0luZGV4IDwgbmV3Q2hpbGRyZW5MZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBvbGRDaGlsZCA9IG9sZEluZGV4IDwgb2xkQ2hpbGRyZW5MZW5ndGggPyBvbGRDaGlsZHJlbltvbGRJbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgbmV3Q2hpbGQgPSBuZXdDaGlsZHJlbltuZXdJbmRleF07XG4gICAgICAgICAgICBpZiAob2xkQ2hpbGQgIT09IHVuZGVmaW5lZCAmJiBzYW1lKG9sZENoaWxkLCBuZXdDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0VXBkYXRlZCA9IHVwZGF0ZURvbShvbGRDaGlsZCwgbmV3Q2hpbGQsIHByb2plY3Rpb25PcHRpb25zKSB8fCB0ZXh0VXBkYXRlZDtcbiAgICAgICAgICAgICAgICBvbGRJbmRleCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZmluZE9sZEluZGV4ID0gZmluZEluZGV4T2ZDaGlsZChvbGRDaGlsZHJlbiwgbmV3Q2hpbGQsIG9sZEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmRPbGRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBwcmVjZWRpbmcgbWlzc2luZyBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBvbGRJbmRleDsgaSA8IGZpbmRPbGRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlVG9SZW1vdmUob2xkQ2hpbGRyZW5baV0sIHRyYW5zaXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRGlzdGluZ3Vpc2hhYmxlKG9sZENoaWxkcmVuLCBpLCB2bm9kZSwgJ3JlbW92ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0ZXh0VXBkYXRlZCA9IHVwZGF0ZURvbShvbGRDaGlsZHJlbltmaW5kT2xkSW5kZXhdLCBuZXdDaGlsZCwgcHJvamVjdGlvbk9wdGlvbnMpIHx8IHRleHRVcGRhdGVkO1xuICAgICAgICAgICAgICAgICAgICBvbGRJbmRleCA9IGZpbmRPbGRJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmV3IGNoaWxkXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZURvbShuZXdDaGlsZCwgZG9tTm9kZSwgb2xkSW5kZXggPCBvbGRDaGlsZHJlbkxlbmd0aCA/IG9sZENoaWxkcmVuW29sZEluZGV4XS5kb21Ob2RlIDogdW5kZWZpbmVkLCBwcm9qZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVBZGRlZChuZXdDaGlsZCwgdHJhbnNpdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBjaGVja0Rpc3Rpbmd1aXNoYWJsZShuZXdDaGlsZHJlbiwgbmV3SW5kZXgsIHZub2RlLCAnYWRkZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRDaGlsZHJlbkxlbmd0aCA+IG9sZEluZGV4KSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgY2hpbGQgZnJhZ21lbnRzXG4gICAgICAgICAgICBmb3IgKGkgPSBvbGRJbmRleDsgaSA8IG9sZENoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBub2RlVG9SZW1vdmUob2xkQ2hpbGRyZW5baV0sIHRyYW5zaXRpb25zKTtcbiAgICAgICAgICAgICAgICBjaGVja0Rpc3Rpbmd1aXNoYWJsZShvbGRDaGlsZHJlbiwgaSwgdm5vZGUsICdyZW1vdmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHRVcGRhdGVkO1xuICAgIH07XG4gICAgdmFyIGFkZENoaWxkcmVuID0gZnVuY3Rpb24gKGRvbU5vZGUsIGNoaWxkcmVuLCBwcm9qZWN0aW9uT3B0aW9ucykge1xuICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3JlYXRlRG9tKGNoaWxkcmVuW2ldLCBkb21Ob2RlLCB1bmRlZmluZWQsIHByb2plY3Rpb25PcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGluaXRQcm9wZXJ0aWVzQW5kQ2hpbGRyZW4gPSBmdW5jdGlvbiAoZG9tTm9kZSwgdm5vZGUsIHByb2plY3Rpb25PcHRpb25zKSB7XG4gICAgICAgIGFkZENoaWxkcmVuKGRvbU5vZGUsIHZub2RlLmNoaWxkcmVuLCBwcm9qZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgIC8vIGNoaWxkcmVuIGJlZm9yZSBwcm9wZXJ0aWVzLCBuZWVkZWQgZm9yIHZhbHVlIHByb3BlcnR5IG9mIDxzZWxlY3Q+LlxuICAgICAgICBpZiAodm5vZGUudGV4dCkge1xuICAgICAgICAgICAgZG9tTm9kZS50ZXh0Q29udGVudCA9IHZub2RlLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgc2V0UHJvcGVydGllcyhkb21Ob2RlLCB2bm9kZS5wcm9wZXJ0aWVzLCBwcm9qZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgIGlmICh2bm9kZS5wcm9wZXJ0aWVzICYmIHZub2RlLnByb3BlcnRpZXMuYWZ0ZXJDcmVhdGUpIHtcbiAgICAgICAgICAgIHZub2RlLnByb3BlcnRpZXMuYWZ0ZXJDcmVhdGUuYXBwbHkodm5vZGUucHJvcGVydGllcy5iaW5kIHx8IHZub2RlLnByb3BlcnRpZXMsIFtcbiAgICAgICAgICAgICAgICBkb21Ob2RlLFxuICAgICAgICAgICAgICAgIHByb2plY3Rpb25PcHRpb25zLFxuICAgICAgICAgICAgICAgIHZub2RlLnZub2RlU2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgdm5vZGUucHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICB2bm9kZS5jaGlsZHJlblxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNyZWF0ZURvbSA9IGZ1bmN0aW9uICh2bm9kZSwgcGFyZW50Tm9kZSwgaW5zZXJ0QmVmb3JlLCBwcm9qZWN0aW9uT3B0aW9ucykge1xuICAgICAgICB2YXIgZG9tTm9kZSwgaSwgYywgc3RhcnQgPSAwLCB0eXBlLCBmb3VuZDtcbiAgICAgICAgdmFyIHZub2RlU2VsZWN0b3IgPSB2bm9kZS52bm9kZVNlbGVjdG9yO1xuICAgICAgICB2YXIgZG9jID0gcGFyZW50Tm9kZS5vd25lckRvY3VtZW50O1xuICAgICAgICBpZiAodm5vZGVTZWxlY3RvciA9PT0gJycpIHtcbiAgICAgICAgICAgIGRvbU5vZGUgPSB2bm9kZS5kb21Ob2RlID0gZG9jLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgICAgICAgaWYgKGluc2VydEJlZm9yZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZG9tTm9kZSwgaW5zZXJ0QmVmb3JlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkb21Ob2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gdm5vZGVTZWxlY3Rvci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGMgPSB2bm9kZVNlbGVjdG9yLmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdm5vZGVTZWxlY3Rvci5sZW5ndGggfHwgYyA9PT0gJy4nIHx8IGMgPT09ICcjJykge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gdm5vZGVTZWxlY3Rvci5jaGFyQXQoc3RhcnQgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB2bm9kZVNlbGVjdG9yLnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5jbGFzc0xpc3QuYWRkKGZvdW5kKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGUuaWQgPSBmb3VuZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9qZWN0aW9uT3B0aW9ucyA9IGV4dGVuZChwcm9qZWN0aW9uT3B0aW9ucywgeyBuYW1lc3BhY2U6IE5BTUVTUEFDRV9TVkcgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvamVjdGlvbk9wdGlvbnMubmFtZXNwYWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlID0gdm5vZGUuZG9tTm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50TlMocHJvamVjdGlvbk9wdGlvbnMubmFtZXNwYWNlLCBmb3VuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGUgPSB2bm9kZS5kb21Ob2RlID0gdm5vZGUuZG9tTm9kZSB8fCBkb2MuY3JlYXRlRWxlbWVudChmb3VuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kID09PSAnaW5wdXQnICYmIHZub2RlLnByb3BlcnRpZXMgJiYgdm5vZGUucHJvcGVydGllcy50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSUU4IGFuZCBvbGRlciBkb24ndCBzdXBwb3J0IHNldHRpbmcgaW5wdXQgdHlwZSBhZnRlciB0aGUgRE9NIE5vZGUgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbU5vZGUuc2V0QXR0cmlidXRlKCd0eXBlJywgdm5vZGUucHJvcGVydGllcy50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0QmVmb3JlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShkb21Ob2RlLCBpbnNlcnRCZWZvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkb21Ob2RlLnBhcmVudE5vZGUgIT09IHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKGRvbU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5pdFByb3BlcnRpZXNBbmRDaGlsZHJlbihkb21Ob2RlLCB2bm9kZSwgcHJvamVjdGlvbk9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB1cGRhdGVEb20gPSBmdW5jdGlvbiAocHJldmlvdXMsIHZub2RlLCBwcm9qZWN0aW9uT3B0aW9ucykge1xuICAgICAgICB2YXIgZG9tTm9kZSA9IHByZXZpb3VzLmRvbU5vZGU7XG4gICAgICAgIHZhciB0ZXh0VXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAocHJldmlvdXMgPT09IHZub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7ICAgIC8vIEJ5IGNvbnRyYWN0LCBWTm9kZSBvYmplY3RzIG1heSBub3QgYmUgbW9kaWZpZWQgYW55bW9yZSBhZnRlciBwYXNzaW5nIHRoZW0gdG8gbWFxdWV0dGVcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXBkYXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodm5vZGUudm5vZGVTZWxlY3RvciA9PT0gJycpIHtcbiAgICAgICAgICAgIGlmICh2bm9kZS50ZXh0ICE9PSBwcmV2aW91cy50ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZOb2RlID0gZG9tTm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgICAgICAgICAgIGRvbU5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Vk5vZGUsIGRvbU5vZGUpO1xuICAgICAgICAgICAgICAgIHZub2RlLmRvbU5vZGUgPSBuZXdWTm9kZTtcbiAgICAgICAgICAgICAgICB0ZXh0VXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHRVcGRhdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZub2RlLnZub2RlU2VsZWN0b3IubGFzdEluZGV4T2YoJ3N2ZycsIDApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdGlvbk9wdGlvbnMgPSBleHRlbmQocHJvamVjdGlvbk9wdGlvbnMsIHsgbmFtZXNwYWNlOiBOQU1FU1BBQ0VfU1ZHIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZpb3VzLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodm5vZGUudGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGUucmVtb3ZlQ2hpbGQoZG9tTm9kZS5maXJzdENoaWxkKTsgICAgLy8gdGhlIG9ubHkgdGV4dG5vZGUgcHJlc3VtYWJseVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGUudGV4dENvbnRlbnQgPSB2bm9kZS50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZWQgPSB1cGRhdGVDaGlsZHJlbih2bm9kZSwgZG9tTm9kZSwgcHJldmlvdXMuY2hpbGRyZW4sIHZub2RlLmNoaWxkcmVuLCBwcm9qZWN0aW9uT3B0aW9ucykgfHwgdXBkYXRlZDtcbiAgICAgICAgICAgIHVwZGF0ZWQgPSB1cGRhdGVQcm9wZXJ0aWVzKGRvbU5vZGUsIHByZXZpb3VzLnByb3BlcnRpZXMsIHZub2RlLnByb3BlcnRpZXMsIHByb2plY3Rpb25PcHRpb25zKSB8fCB1cGRhdGVkO1xuICAgICAgICAgICAgaWYgKHZub2RlLnByb3BlcnRpZXMgJiYgdm5vZGUucHJvcGVydGllcy5hZnRlclVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHZub2RlLnByb3BlcnRpZXMuYWZ0ZXJVcGRhdGUuYXBwbHkodm5vZGUucHJvcGVydGllcy5iaW5kIHx8IHZub2RlLnByb3BlcnRpZXMsIFtcbiAgICAgICAgICAgICAgICAgICAgZG9tTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdGlvbk9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLnZub2RlU2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLnByb3BlcnRpZXMsXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZWQgJiYgdm5vZGUucHJvcGVydGllcyAmJiB2bm9kZS5wcm9wZXJ0aWVzLnVwZGF0ZUFuaW1hdGlvbikge1xuICAgICAgICAgICAgdm5vZGUucHJvcGVydGllcy51cGRhdGVBbmltYXRpb24oZG9tTm9kZSwgdm5vZGUucHJvcGVydGllcywgcHJldmlvdXMucHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgdm5vZGUuZG9tTm9kZSA9IHByZXZpb3VzLmRvbU5vZGU7XG4gICAgICAgIHJldHVybiB0ZXh0VXBkYXRlZDtcbiAgICB9O1xuICAgIHZhciBjcmVhdGVQcm9qZWN0aW9uID0gZnVuY3Rpb24gKHZub2RlLCBwcm9qZWN0aW9uT3B0aW9ucykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAodXBkYXRlZFZub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZub2RlLnZub2RlU2VsZWN0b3IgIT09IHVwZGF0ZWRWbm9kZS52bm9kZVNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNlbGVjdG9yIGZvciB0aGUgcm9vdCBWTm9kZSBtYXkgbm90IGJlIGNoYW5nZWQuIChjb25zaWRlciB1c2luZyBkb20ubWVyZ2UgYW5kIGFkZCBvbmUgZXh0cmEgbGV2ZWwgdG8gdGhlIHZpcnR1YWwgRE9NKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGRhdGVEb20odm5vZGUsIHVwZGF0ZWRWbm9kZSwgcHJvamVjdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHZub2RlID0gdXBkYXRlZFZub2RlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvbU5vZGU6IHZub2RlLmRvbU5vZGVcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8vIFRoZSBvdGhlciB0d28gcGFyYW1ldGVycyBhcmUgbm90IGFkZGVkIGhlcmUsIGJlY2F1c2UgdGhlIFR5cGVzY3JpcHQgY29tcGlsZXIgY3JlYXRlcyBzdXJyb2dhdGUgY29kZSBmb3IgZGVzdHJ1Y3R1cmluZyAnY2hpbGRyZW4nLlxuICAgIGV4cG9ydHMuaCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGlsZEluZGV4ID0gMTtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMgJiYgIXByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoJ3Zub2RlU2VsZWN0b3InKSAmJiAhQXJyYXkuaXNBcnJheShwcm9wZXJ0aWVzKSAmJiB0eXBlb2YgcHJvcGVydGllcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNoaWxkSW5kZXggPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3B0aW9uYWwgcHJvcGVydGllcyBhcmd1bWVudCB3YXMgb21pdHRlZFxuICAgICAgICAgICAgcHJvcGVydGllcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4dDtcbiAgICAgICAgdmFyIGNoaWxkcmVuO1xuICAgICAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIC8vIFJlY29nbml6ZSBhIGNvbW1vbiBzcGVjaWFsIGNhc2Ugd2hlcmUgdGhlcmUgaXMgb25seSBhIHNpbmdsZSB0ZXh0IG5vZGVcbiAgICAgICAgaWYgKGFyZ3NMZW5ndGggPT09IGNoaWxkSW5kZXggKyAxKSB7XG4gICAgICAgICAgICB2YXIgb25seUNoaWxkID0gYXJndW1lbnRzW2NoaWxkSW5kZXhdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbmx5Q2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IG9ubHlDaGlsZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob25seUNoaWxkICE9PSB1bmRlZmluZWQgJiYgb25seUNoaWxkICE9PSBudWxsICYmIG9ubHlDaGlsZC5sZW5ndGggPT09IDEgJiYgdHlwZW9mIG9ubHlDaGlsZFswXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gb25seUNoaWxkWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuID0gW107XG4gICAgICAgICAgICBmb3IgKDsgY2hpbGRJbmRleCA8IGFyZ3NMZW5ndGg7IGNoaWxkSW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGFyZ3VtZW50c1tjaGlsZEluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgPT09IG51bGwgfHwgY2hpbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kQ2hpbGRyZW4oc2VsZWN0b3IsIGNoaWxkLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZC5oYXNPd25Qcm9wZXJ0eSgndm5vZGVTZWxlY3RvcicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godG9UZXh0Vk5vZGUoY2hpbGQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZub2RlU2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgICAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllcyxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgICAgIHRleHQ6IHRleHQgPT09ICcnID8gdW5kZWZpbmVkIDogdGV4dCxcbiAgICAgICAgICAgIGRvbU5vZGU6IG51bGxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICogQ29udGFpbnMgc2ltcGxlIGxvdy1sZXZlbCB1dGlsaXR5IGZ1bmN0aW9ucyB0byBtYW5pcHVsYXRlIHRoZSByZWFsIERPTS5cbiAqL1xuICAgIGV4cG9ydHMuZG9tID0ge1xuICAgICAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcmVhbCBET00gdHJlZSBmcm9tIGB2bm9kZWAuIFRoZSBbW1Byb2plY3Rpb25dXSBvYmplY3QgcmV0dXJuZWQgd2lsbCBjb250YWluIHRoZSByZXN1bHRpbmcgRE9NIE5vZGUgaW5cbiAgICAgKiBpdHMgW1tQcm9qZWN0aW9uLmRvbU5vZGV8ZG9tTm9kZV1dIHByb3BlcnR5LlxuICAgICAqIFRoaXMgaXMgYSBsb3ctbGV2ZWwgbWV0aG9kLiBVc2VycyB3aWxsIHR5cGljYWxseSB1c2UgYSBbW1Byb2plY3Rvcl1dIGluc3RlYWQuXG4gICAgICogQHBhcmFtIHZub2RlIC0gVGhlIHJvb3Qgb2YgdGhlIHZpcnR1YWwgRE9NIHRyZWUgdGhhdCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgW1toXV0gZnVuY3Rpb24uIE5PVEU6IFtbVk5vZGVdXVxuICAgICAqIG9iamVjdHMgbWF5IG9ubHkgYmUgcmVuZGVyZWQgb25jZS5cbiAgICAgKiBAcGFyYW0gcHJvamVjdGlvbk9wdGlvbnMgLSBPcHRpb25zIHRvIGJlIHVzZWQgdG8gY3JlYXRlIGFuZCB1cGRhdGUgdGhlIHByb2plY3Rpb24uXG4gICAgICogQHJldHVybnMgVGhlIFtbUHJvamVjdGlvbl1dIHdoaWNoIGFsc28gY29udGFpbnMgdGhlIERPTSBOb2RlIHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAgICovXG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKHZub2RlLCBwcm9qZWN0aW9uT3B0aW9ucykge1xuICAgICAgICAgICAgcHJvamVjdGlvbk9wdGlvbnMgPSBhcHBseURlZmF1bHRQcm9qZWN0aW9uT3B0aW9ucyhwcm9qZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICBjcmVhdGVEb20odm5vZGUsIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCB1bmRlZmluZWQsIHByb2plY3Rpb25PcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVQcm9qZWN0aW9uKHZub2RlLCBwcm9qZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAqIEFwcGVuZHMgYSBuZXcgY2hpbGQgbm9kZSB0byB0aGUgRE9NIHdoaWNoIGlzIGdlbmVyYXRlZCBmcm9tIGEgW1tWTm9kZV1dLlxuICAgICAqIFRoaXMgaXMgYSBsb3ctbGV2ZWwgbWV0aG9kLiBVc2VycyB3aWxsIHR5cGljYWxseSB1c2UgYSBbW1Byb2plY3Rvcl1dIGluc3RlYWQuXG4gICAgICogQHBhcmFtIHBhcmVudE5vZGUgLSBUaGUgcGFyZW50IG5vZGUgZm9yIHRoZSBuZXcgY2hpbGQgbm9kZS5cbiAgICAgKiBAcGFyYW0gdm5vZGUgLSBUaGUgcm9vdCBvZiB0aGUgdmlydHVhbCBET00gdHJlZSB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBbW2hdXSBmdW5jdGlvbi4gTk9URTogW1tWTm9kZV1dXG4gICAgICogb2JqZWN0cyBtYXkgb25seSBiZSByZW5kZXJlZCBvbmNlLlxuICAgICAqIEBwYXJhbSBwcm9qZWN0aW9uT3B0aW9ucyAtIE9wdGlvbnMgdG8gYmUgdXNlZCB0byBjcmVhdGUgYW5kIHVwZGF0ZSB0aGUgW1tQcm9qZWN0aW9uXV0uXG4gICAgICogQHJldHVybnMgVGhlIFtbUHJvamVjdGlvbl1dIHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAgICovXG4gICAgICAgIGFwcGVuZDogZnVuY3Rpb24gKHBhcmVudE5vZGUsIHZub2RlLCBwcm9qZWN0aW9uT3B0aW9ucykge1xuICAgICAgICAgICAgcHJvamVjdGlvbk9wdGlvbnMgPSBhcHBseURlZmF1bHRQcm9qZWN0aW9uT3B0aW9ucyhwcm9qZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICBjcmVhdGVEb20odm5vZGUsIHBhcmVudE5vZGUsIHVuZGVmaW5lZCwgcHJvamVjdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVByb2plY3Rpb24odm5vZGUsIHByb2plY3Rpb25PcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICogSW5zZXJ0cyBhIG5ldyBET00gbm9kZSB3aGljaCBpcyBnZW5lcmF0ZWQgZnJvbSBhIFtbVk5vZGVdXS5cbiAgICAgKiBUaGlzIGlzIGEgbG93LWxldmVsIG1ldGhvZC4gVXNlcnMgd2lsIHR5cGljYWxseSB1c2UgYSBbW1Byb2plY3Rvcl1dIGluc3RlYWQuXG4gICAgICogQHBhcmFtIGJlZm9yZU5vZGUgLSBUaGUgbm9kZSB0aGF0IHRoZSBET00gTm9kZSBpcyBpbnNlcnRlZCBiZWZvcmUuXG4gICAgICogQHBhcmFtIHZub2RlIC0gVGhlIHJvb3Qgb2YgdGhlIHZpcnR1YWwgRE9NIHRyZWUgdGhhdCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgW1toXV0gZnVuY3Rpb24uXG4gICAgICogTk9URTogW1tWTm9kZV1dIG9iamVjdHMgbWF5IG9ubHkgYmUgcmVuZGVyZWQgb25jZS5cbiAgICAgKiBAcGFyYW0gcHJvamVjdGlvbk9wdGlvbnMgLSBPcHRpb25zIHRvIGJlIHVzZWQgdG8gY3JlYXRlIGFuZCB1cGRhdGUgdGhlIHByb2plY3Rpb24sIHNlZSBbW2NyZWF0ZVByb2plY3Rvcl1dLlxuICAgICAqIEByZXR1cm5zIFRoZSBbW1Byb2plY3Rpb25dXSB0aGF0IHdhcyBjcmVhdGVkLlxuICAgICAqL1xuICAgICAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIChiZWZvcmVOb2RlLCB2bm9kZSwgcHJvamVjdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgICAgIHByb2plY3Rpb25PcHRpb25zID0gYXBwbHlEZWZhdWx0UHJvamVjdGlvbk9wdGlvbnMocHJvamVjdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgY3JlYXRlRG9tKHZub2RlLCBiZWZvcmVOb2RlLnBhcmVudE5vZGUsIGJlZm9yZU5vZGUsIHByb2plY3Rpb25PcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVQcm9qZWN0aW9uKHZub2RlLCBwcm9qZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAqIE1lcmdlcyBhIG5ldyBET00gbm9kZSB3aGljaCBpcyBnZW5lcmF0ZWQgZnJvbSBhIFtbVk5vZGVdXSB3aXRoIGFuIGV4aXN0aW5nIERPTSBOb2RlLlxuICAgICAqIFRoaXMgbWVhbnMgdGhhdCB0aGUgdmlydHVhbCBET00gYW5kIHRoZSByZWFsIERPTSB3aWxsIGhhdmUgb25lIG92ZXJsYXBwaW5nIGVsZW1lbnQuXG4gICAgICogVGhlcmVmb3JlIHRoZSBzZWxlY3RvciBmb3IgdGhlIHJvb3QgW1tWTm9kZV1dIHdpbGwgYmUgaWdub3JlZCwgYnV0IGl0cyBwcm9wZXJ0aWVzIGFuZCBjaGlsZHJlbiB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIEVsZW1lbnQgcHJvdmlkZWQuXG4gICAgICogVGhpcyBpcyBhIGxvdy1sZXZlbCBtZXRob2QuIFVzZXJzIHdpbCB0eXBpY2FsbHkgdXNlIGEgW1tQcm9qZWN0b3JdXSBpbnN0ZWFkLlxuICAgICAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGV4aXN0aW5nIGVsZW1lbnQgdG8gYWRvcHQgYXMgdGhlIHJvb3Qgb2YgdGhlIG5ldyB2aXJ0dWFsIERPTS4gRXhpc3RpbmcgYXR0cmlidXRlcyBhbmQgY2hpbGQgbm9kZXMgYXJlIHByZXNlcnZlZC5cbiAgICAgKiBAcGFyYW0gdm5vZGUgLSBUaGUgcm9vdCBvZiB0aGUgdmlydHVhbCBET00gdHJlZSB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBbW2hdXSBmdW5jdGlvbi4gTk9URTogW1tWTm9kZV1dIG9iamVjdHNcbiAgICAgKiBtYXkgb25seSBiZSByZW5kZXJlZCBvbmNlLlxuICAgICAqIEBwYXJhbSBwcm9qZWN0aW9uT3B0aW9ucyAtIE9wdGlvbnMgdG8gYmUgdXNlZCB0byBjcmVhdGUgYW5kIHVwZGF0ZSB0aGUgcHJvamVjdGlvbiwgc2VlIFtbY3JlYXRlUHJvamVjdG9yXV0uXG4gICAgICogQHJldHVybnMgVGhlIFtbUHJvamVjdGlvbl1dIHRoYXQgd2FzIGNyZWF0ZWQuXG4gICAgICovXG4gICAgICAgIG1lcmdlOiBmdW5jdGlvbiAoZWxlbWVudCwgdm5vZGUsIHByb2plY3Rpb25PcHRpb25zKSB7XG4gICAgICAgICAgICBwcm9qZWN0aW9uT3B0aW9ucyA9IGFwcGx5RGVmYXVsdFByb2plY3Rpb25PcHRpb25zKHByb2plY3Rpb25PcHRpb25zKTtcbiAgICAgICAgICAgIHZub2RlLmRvbU5vZGUgPSBlbGVtZW50O1xuICAgICAgICAgICAgaW5pdFByb3BlcnRpZXNBbmRDaGlsZHJlbihlbGVtZW50LCB2bm9kZSwgcHJvamVjdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVByb2plY3Rpb24odm5vZGUsIHByb2plY3Rpb25PcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW4gZXhpc3RpbmcgRE9NIG5vZGUgd2l0aCBhIG5vZGUgZ2VuZXJhdGVkIGZyb20gYSBbW1ZOb2RlXV0uXG4gICAgICogVGhpcyBpcyBhIGxvdy1sZXZlbCBtZXRob2QuIFVzZXJzIHdpbGwgdHlwaWNhbGx5IHVzZSBhIFtbUHJvamVjdG9yXV0gaW5zdGVhZC5cbiAgICAgKiBAcGFyYW0gZWxlbWVudCAtIFRoZSBub2RlIGZvciB0aGUgW1tWTm9kZV1dIHRvIHJlcGxhY2UuXG4gICAgICogQHBhcmFtIHZub2RlIC0gVGhlIHJvb3Qgb2YgdGhlIHZpcnR1YWwgRE9NIHRyZWUgdGhhdCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgW1toXV0gZnVuY3Rpb24uIE5PVEU6IFtbVk5vZGVdXVxuICAgICAqIG9iamVjdHMgbWF5IG9ubHkgYmUgcmVuZGVyZWQgb25jZS5cbiAgICAgKiBAcGFyYW0gcHJvamVjdGlvbk9wdGlvbnMgLSBPcHRpb25zIHRvIGJlIHVzZWQgdG8gY3JlYXRlIGFuZCB1cGRhdGUgdGhlIFtbUHJvamVjdGlvbl1dLlxuICAgICAqIEByZXR1cm5zIFRoZSBbW1Byb2plY3Rpb25dXSB0aGF0IHdhcyBjcmVhdGVkLlxuICAgICAqL1xuICAgICAgICByZXBsYWNlOiBmdW5jdGlvbiAoZWxlbWVudCwgdm5vZGUsIHByb2plY3Rpb25PcHRpb25zKSB7XG4gICAgICAgICAgICBwcm9qZWN0aW9uT3B0aW9ucyA9IGFwcGx5RGVmYXVsdFByb2plY3Rpb25PcHRpb25zKHByb2plY3Rpb25PcHRpb25zKTtcbiAgICAgICAgICAgIGNyZWF0ZURvbSh2bm9kZSwgZWxlbWVudC5wYXJlbnROb2RlLCBlbGVtZW50LCBwcm9qZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJvamVjdGlvbih2bm9kZSwgcHJvamVjdGlvbk9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAqIENyZWF0ZXMgYSBbW0NhbGN1bGF0aW9uQ2FjaGVdXSBvYmplY3QsIHVzZWZ1bCBmb3IgY2FjaGluZyBbW1ZOb2RlXV0gdHJlZXMuXG4gKiBJbiBwcmFjdGljZSwgY2FjaGluZyBvZiBbW1ZOb2RlXV0gdHJlZXMgaXMgbm90IG5lZWRlZCwgYmVjYXVzZSBhY2hpZXZpbmcgNjAgZnJhbWVzIHBlciBzZWNvbmQgaXMgYWxtb3N0IG5ldmVyIGEgcHJvYmxlbS5cbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgW1tDYWxjdWxhdGlvbkNhY2hlXV0uXG4gKlxuICogQHBhcmFtIDxSZXN1bHQ+IFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0aGF0IGlzIGNhY2hlZC5cbiAqL1xuICAgIGV4cG9ydHMuY3JlYXRlQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYWNoZWRJbnB1dHM7XG4gICAgICAgIHZhciBjYWNoZWRPdXRjb21lO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW52YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNhY2hlZE91dGNvbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY2FjaGVkSW5wdXRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc3VsdDogZnVuY3Rpb24gKGlucHV0cywgY2FsY3VsYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkSW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVkSW5wdXRzW2ldICE9PSBpbnB1dHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZWRPdXRjb21lID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY2FjaGVkT3V0Y29tZSkge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWRPdXRjb21lID0gY2FsY3VsYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkSW5wdXRzID0gaW5wdXRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT3V0Y29tZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBNYXBwaW5nfSBpbnN0YW5jZSB0aGF0IGtlZXBzIGFuIGFycmF5IG9mIHJlc3VsdCBvYmplY3RzIHN5bmNocm9uaXplZCB3aXRoIGFuIGFycmF5IG9mIHNvdXJjZSBvYmplY3RzLlxuICogU2VlIHtAbGluayBodHRwOi8vbWFxdWV0dGVqcy5vcmcvZG9jcy9hcnJheXMuaHRtbHxXb3JraW5nIHdpdGggYXJyYXlzfS5cbiAqXG4gKiBAcGFyYW0gPFNvdXJjZT4gICAgICAgVGhlIHR5cGUgb2Ygc291cmNlIGl0ZW1zLiBBIGRhdGFiYXNlLXJlY29yZCBmb3IgaW5zdGFuY2UuXG4gKiBAcGFyYW0gPFRhcmdldD4gICAgICAgVGhlIHR5cGUgb2YgdGFyZ2V0IGl0ZW1zLiBBIFtbQ29tcG9uZW50XV0gZm9yIGluc3RhbmNlLlxuICogQHBhcmFtIGdldFNvdXJjZUtleSAgIGBmdW5jdGlvbihzb3VyY2UpYCB0aGF0IG11c3QgcmV0dXJuIGEga2V5IHRvIGlkZW50aWZ5IGVhY2ggc291cmNlIG9iamVjdC4gVGhlIHJlc3VsdCBtdXN0IGVpdGhlciBiZSBhIHN0cmluZyBvciBhIG51bWJlci5cbiAqIEBwYXJhbSBjcmVhdGVSZXN1bHQgICBgZnVuY3Rpb24oc291cmNlLCBpbmRleClgIHRoYXQgbXVzdCBjcmVhdGUgYSBuZXcgcmVzdWx0IG9iamVjdCBmcm9tIGEgZ2l2ZW4gc291cmNlLiBUaGlzIGZ1bmN0aW9uIGlzIGlkZW50aWNhbFxuICogICAgICAgICAgICAgICAgICAgICAgIHRvIHRoZSBgY2FsbGJhY2tgIGFyZ3VtZW50IGluIGBBcnJheS5tYXAoY2FsbGJhY2spYC5cbiAqIEBwYXJhbSB1cGRhdGVSZXN1bHQgICBgZnVuY3Rpb24oc291cmNlLCB0YXJnZXQsIGluZGV4KWAgdGhhdCB1cGRhdGVzIGEgcmVzdWx0IHRvIGFuIHVwZGF0ZWQgc291cmNlLlxuICovXG4gICAgZXhwb3J0cy5jcmVhdGVNYXBwaW5nID0gZnVuY3Rpb24gKGdldFNvdXJjZUtleSwgY3JlYXRlUmVzdWx0LCB1cGRhdGVSZXN1bHQpIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdHM6IHJlc3VsdHMsXG4gICAgICAgICAgICBtYXA6IGZ1bmN0aW9uIChuZXdTb3VyY2VzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0tleXMgPSBuZXdTb3VyY2VzLm1hcChnZXRTb3VyY2VLZXkpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRUYXJnZXRzID0gcmVzdWx0cy5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdTb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBuZXdTb3VyY2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlS2V5ID0gbmV3S2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZUtleSA9PT0ga2V5c1tvbGRJbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBvbGRUYXJnZXRzW29sZEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJlc3VsdChzb3VyY2UsIG9sZFRhcmdldHNbb2xkSW5kZXhdLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwga2V5cy5sZW5ndGggKyAxOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VhcmNoSW5kZXggPSAob2xkSW5kZXggKyBqKSAlIGtleXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlzW3NlYXJjaEluZGV4XSA9PT0gc291cmNlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBvbGRUYXJnZXRzW3NlYXJjaEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlUmVzdWx0KG5ld1NvdXJjZXNbaV0sIG9sZFRhcmdldHNbc2VhcmNoSW5kZXhdLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkSW5kZXggPSBzZWFyY2hJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBjcmVhdGVSZXN1bHQoc291cmNlLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLmxlbmd0aCA9IG5ld1NvdXJjZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGtleXMgPSBuZXdLZXlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gKiBDcmVhdGVzIGEgW1tQcm9qZWN0b3JdXSBpbnN0YW5jZSB1c2luZyB0aGUgcHJvdmlkZWQgcHJvamVjdGlvbk9wdGlvbnMuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSBbW1Byb2plY3Rvcl1dLlxuICpcbiAqIEBwYXJhbSBwcm9qZWN0b3JPcHRpb25zICAgT3B0aW9ucyB0aGF0IGluZmx1ZW5jZSBob3cgdGhlIERPTSBpcyByZW5kZXJlZCBhbmQgdXBkYXRlZC5cbiAqL1xuICAgIGV4cG9ydHMuY3JlYXRlUHJvamVjdG9yID0gZnVuY3Rpb24gKHByb2plY3Rvck9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHByb2plY3RvcjtcbiAgICAgICAgdmFyIHByb2plY3Rpb25PcHRpb25zID0gYXBwbHlEZWZhdWx0UHJvamVjdGlvbk9wdGlvbnMocHJvamVjdG9yT3B0aW9ucyk7XG4gICAgICAgIHByb2plY3Rpb25PcHRpb25zLmV2ZW50SGFuZGxlckludGVyY2VwdG9yID0gZnVuY3Rpb24gKHByb3BlcnR5TmFtZSwgZXZlbnRIYW5kbGVyLCBkb21Ob2RlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIGludGVyY2VwdCBmdW5jdGlvbiBjYWxscyAoZXZlbnQgaGFuZGxlcnMpIHRvIGRvIGEgcmVuZGVyIGFmdGVyd2FyZHMuXG4gICAgICAgICAgICAgICAgcHJvamVjdG9yLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50SGFuZGxlci5hcHBseShwcm9wZXJ0aWVzLmJpbmQgfHwgdGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZW5kZXJDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgc2NoZWR1bGVkO1xuICAgICAgICB2YXIgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgcHJvamVjdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHJlbmRlckZ1bmN0aW9ucyA9IFtdO1xuICAgICAgICAvLyBtYXRjaGVzIHRoZSBwcm9qZWN0aW9ucyBhcnJheVxuICAgICAgICB2YXIgZG9SZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzY2hlZHVsZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoIXJlbmRlckNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgICAgLy8gVGhlIGxhc3QgcmVuZGVyIHRocmV3IGFuIGVycm9yLCBpdCBzaG91bGQgYmUgbG9nZ2VkIGluIHRoZSBicm93c2VyIGNvbnNvbGUuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW5kZXJDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvamVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZFZub2RlID0gcmVuZGVyRnVuY3Rpb25zW2ldKCk7XG4gICAgICAgICAgICAgICAgcHJvamVjdGlvbnNbaV0udXBkYXRlKHVwZGF0ZWRWbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW5kZXJDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBwcm9qZWN0b3IgPSB7XG4gICAgICAgICAgICByZW5kZXJOb3c6IGRvUmVuZGVyLFxuICAgICAgICAgICAgc2NoZWR1bGVSZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNjaGVkdWxlZCAmJiAhc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZG9SZW5kZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVkdWxlZCkge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShzY2hlZHVsZWQpO1xuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZW5kZXJDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByb2plY3Rvci5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFwcGVuZDogZnVuY3Rpb24gKHBhcmVudE5vZGUsIHJlbmRlck1hcXVldHRlRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0aW9ucy5wdXNoKGV4cG9ydHMuZG9tLmFwcGVuZChwYXJlbnROb2RlLCByZW5kZXJNYXF1ZXR0ZUZ1bmN0aW9uKCksIHByb2plY3Rpb25PcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgcmVuZGVyRnVuY3Rpb25zLnB1c2gocmVuZGVyTWFxdWV0dGVGdW5jdGlvbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbiAoYmVmb3JlTm9kZSwgcmVuZGVyTWFxdWV0dGVGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHByb2plY3Rpb25zLnB1c2goZXhwb3J0cy5kb20uaW5zZXJ0QmVmb3JlKGJlZm9yZU5vZGUsIHJlbmRlck1hcXVldHRlRnVuY3Rpb24oKSwgcHJvamVjdGlvbk9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICByZW5kZXJGdW5jdGlvbnMucHVzaChyZW5kZXJNYXF1ZXR0ZUZ1bmN0aW9uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXJnZTogZnVuY3Rpb24gKGRvbU5vZGUsIHJlbmRlck1hcXVldHRlRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0aW9ucy5wdXNoKGV4cG9ydHMuZG9tLm1lcmdlKGRvbU5vZGUsIHJlbmRlck1hcXVldHRlRnVuY3Rpb24oKSwgcHJvamVjdGlvbk9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICByZW5kZXJGdW5jdGlvbnMucHVzaChyZW5kZXJNYXF1ZXR0ZUZ1bmN0aW9uKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXBsYWNlOiBmdW5jdGlvbiAoZG9tTm9kZSwgcmVuZGVyTWFxdWV0dGVGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHByb2plY3Rpb25zLnB1c2goZXhwb3J0cy5kb20ucmVwbGFjZShkb21Ob2RlLCByZW5kZXJNYXF1ZXR0ZUZ1bmN0aW9uKCksIHByb2plY3Rpb25PcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgcmVuZGVyRnVuY3Rpb25zLnB1c2gocmVuZGVyTWFxdWV0dGVGdW5jdGlvbik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGV0YWNoOiBmdW5jdGlvbiAocmVuZGVyTWFxdWV0dGVGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVuZGVyRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW5kZXJGdW5jdGlvbnNbaV0gPT09IHJlbmRlck1hcXVldHRlRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlckZ1bmN0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvamVjdGlvbnMuc3BsaWNlKGksIDEpWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVuZGVyTWFxdWV0dGVGdW5jdGlvbiB3YXMgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwcm9qZWN0b3I7XG4gICAgfTtcbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcXVldHRlLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWFxdWV0dGUvZGlzdC9tYXF1ZXR0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgKiBmcm9tIFwiLi8uLi9UeXBld3JpdGVyL0NhbGlmb3JuaWFDb250cm9sbGVyXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuLy4uL1R5cGV3cml0ZXIvQ2FsaWZvcm5pYUV2ZW50XCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuLy4uL1R5cGV3cml0ZXIvQ2FsaWZvcm5pYVByb2plY3RcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vLi4vVHlwZXdyaXRlci9DYWxpZm9ybmlhVXNlckRlZmF1bHRzXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuLy4uL1R5cGV3cml0ZXIvQ2FsaWZvcm5pYUNsaWVudFZpZXdNb2RlbFwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi8uLi9UeXBld3JpdGVyL1N0eWxlTW9sZWN1bGVcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vLi4vVHlwZXdyaXRlci9TdHlsZVF1YW50dW1cIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vLi4vVHlwZXdyaXRlci9TdHlsZUF0b21cIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vLi4vVHlwZXdyaXRlci9TdHlsZUF0b21UeXBlXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuLy4uL1R5cGV3cml0ZXIvU3R5bGVWYWx1ZVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi8uLi9UeXBld3JpdGVyL1Jlc3BvbnNpdmVEZXZpY2VcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vLi4vVHlwZXdyaXRlci9DYWxpZm9ybmlhVmlld1wiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi8uLi9UeXBld3JpdGVyL0xheW91dFJvd1wiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi8uLi9UeXBld3JpdGVyL0xheW91dEJveFwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi8uLi9UeXBld3JpdGVyL0xheW91dEF0b21cIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vLi4vVHlwZXdyaXRlci9TdHlsZU1vbGVjdWxlQXRvbU1hcHBpbmdcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vLi4vVHlwZXdyaXRlci9Db250ZW50QXRvbVwiO1xyXG5leHBvcnQgKiBmcm9tIFwiLi8uLi9UeXBld3JpdGVyL0xheW91dEJhc2VcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vLi4vVHlwZXdyaXRlci9MYXlvdXRUeXBlXCI7XHJcbmV4cG9ydCAqIGZyb20gXCIuLy4uL1R5cGV3cml0ZXIvU3BlY2lhbExheW91dEJveFR5cGVcIjtcclxuZXhwb3J0ICogZnJvbSBcIi4vLi4vVHlwZXdyaXRlci9MYXlvdXRTdHlsZUludGVyYWN0aW9uXCI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vTW9kZWxzL0NhbGlmb3JuaWFHZW5lcmF0ZWQudHMiLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vanN4LnRzXCIgLz5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmltcG9ydCB7IFZOb2RlIH0gZnJvbSBcIm1hcXVldHRlXCI7XHJcbmltcG9ydCAqIGFzIG1hcXVldHRlIGZyb20gXCJtYXF1ZXR0ZVwiO1xyXG5jb25zdCBoID0gbWFxdWV0dGUuaDtcclxuaW1wb3J0IHsgQ2FsaWZvcm5pYUNvbnRyb2xsZXIsIENhbGlmb3JuaWFDbGllbnRWaWV3TW9kZWwsIENhbGlmb3JuaWFFdmVudCwgQ2FsaWZvcm5pYVByb2plY3QgfSBmcm9tIFwiLi9DYWxpZm9ybmlhR2VuZXJhdGVkXCI7XHJcbmltcG9ydCB7IFBhZ2VQcmV2aWV3IH0gZnJvbSBcIi4vUGFnZVByZXZpZXdcIjtcclxuaW1wb3J0IHsgUGFnZVByZXZpZXdWTSB9IGZyb20gXCIuLy4uL1ZpZXdNb2RlbHMvUGFnZVByZXZpZXdWTVwiO1xyXG5pbXBvcnQgeyBQcm9wZXJ0eUJhciB9IGZyb20gXCIuL1Byb3BlcnR5QmFyXCI7XHJcbmltcG9ydCB7IFByb3BlcnR5QmFyVk0sIFBvcHVwTW9kZSB9IGZyb20gXCIuLi9WaWV3TW9kZWxzL1Byb3BlcnR5QmFyVk1cIjtcclxuaW1wb3J0IHsgQ2FsaWZvcm5pYVJvdXRlciB9IGZyb20gXCIuL0NhbGlmb3JuaWFSb3V0ZXJcIjtcclxuaW1wb3J0IHsgQ2xpZW50U3RhdGUsIEVkaXRWaWV3TW9kZSB9IGZyb20gXCIuL0NsaWVudFN0YXRlXCI7XHJcbmltcG9ydCB7IENhbGlmb3JuaWFDbGllbnRQYXJ0aWFsRGF0YSB9IGZyb20gXCIuLi9UeXBld3JpdGVyL0NhbGlmb3JuaWFDbGllbnRQYXJ0aWFsRGF0YVwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfRVhDRVBUSU9OOiBzdHJpbmcgPSBcInVuZXhwZWN0ZWQgZXJyb3JcIjsgLy8gVE9ETyBjb3VsZCByZWRpcmVjdC9vdmVybGF5IGFuIGVycm9yIHBhZ2Ugd2l0aCBpbnN0cnVjdGlvbnM6IHJlbG9hZCBwYWdlLCB3YWl0LCBjbGVhciBoaXN0b3J5LCBjbGVhciBsb2NhbCBzdG9yYWdlLCBjbGVhciBjb29raWVzLCBldGMuXHJcbmV4cG9ydCBjb25zdCBVSV9aX0lOREVYOiBudW1iZXIgPSAxMTtcclxuY29uc3QgUkVTSVpFX0hBTkRMRVJfREVMQVlfTVM6IG51bWJlciA9IDIwMDtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBcnJheUZvckVudW0odGFyZ2V0RW51bTogYW55KTogc3RyaW5nW10ge1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldEVudW0pLm1hcChrZXkgPT4gdGFyZ2V0RW51bVtrZXkgYXMgYW55XSkuZmlsdGVyKHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikgYXMgc3RyaW5nW107XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGVsZW1lbnQ6IEV2ZW50VGFyZ2V0IHwgbnVsbCwgYXR0cmlidXRlTmFtZTogc3RyaW5nKTogbnVtYmVyIHsgLy8gY2FuIHRocm93XHJcbiAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJjYW5ub3QgcmVhZCBhdHRyaWJ1dGU6IGVsZW1lbnQgaXMgbnVsbFwiKTtcclxuICAgIH1cclxuICAgIC8vIFRPRE8gZGlzYWJsZSBkZWJ1ZyB2YXJpYW50XHJcbiAgICBsZXQgYXR0cjogQXR0ciB8IG51bGwgPSAoZWxlbWVudCBhcyBIVE1MRWxlbWVudCkuYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oYXR0cmlidXRlTmFtZSk7XHJcbiAgICBpZiAoYXR0ciA9PT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiY291bGQgbm90IGZpbmQgYXR0cmlidXRlIFwiICsgYXR0cmlidXRlTmFtZSArIFwiIG9uIHRhcmdldFwiKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhlbGVtZW50KTtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBwYXJzZUludChhdHRyLnZhbHVlKTtcclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVN0cmluZ0Zyb21BdHRyaWJ1dGUoZWxlbWVudDogRXZlbnRUYXJnZXQgfCBudWxsLCBhdHRyaWJ1dGVOYW1lOiBzdHJpbmcpOiBzdHJpbmcgeyAvLyBjYW4gdGhyb3dcclxuICAgIGlmIChlbGVtZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcImNhbm5vdCByZWFkIGF0dHJpYnV0ZTogZWxlbWVudCBpcyBudWxsXCIpO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETyBkaXNhYmxlIGRlYnVnIHZhcmlhbnRcclxuICAgIGxldCBhdHRyOiBBdHRyIHwgbnVsbCA9IChlbGVtZW50IGFzIEhUTUxFbGVtZW50KS5hdHRyaWJ1dGVzLmdldE5hbWVkSXRlbShhdHRyaWJ1dGVOYW1lKTtcclxuICAgIGlmIChhdHRyID09PSBudWxsKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJjb3VsZCBub3QgZmluZCBhdHRyaWJ1dGUgXCIgKyBhdHRyaWJ1dGVOYW1lICsgXCIgb24gdGFyZ2V0XCIpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGVsZW1lbnQpO1xyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGF0dHIudmFsdWU7XHJcbiAgICB9XHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgQ2FsaWZvcm5pYUFwcCB7XHJcbiAgICAvLyBzdGF0aWMgaHRtbCByZWZlcmVuY2VzXHJcbiAgICBwdWJsaWMgY2FsaWZvcm5pYU1haW5EaXY6IEhUTUxFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjYWxpZm9ybmlhLW1haW5cIikgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICBwdWJsaWMgc3R5bGVTaGVldDogQ1NTU3R5bGVTaGVldCA9IChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhbGlmb3JuaWEtc3R5bGVzXCIpIGFzIEhUTUxTdHlsZUVsZW1lbnQpLnNoZWV0IGFzIENTU1N0eWxlU2hlZXQ7XHJcbiAgICAvLyByZW5kZXJlZCB2ZG9tIHJlZmVyZW5jZXNcclxuICAgIHB1YmxpYyBwYWdlUHJldmlld0hvbGRlcjogSFRNTEVsZW1lbnQgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAvLyBtb2R1bGUgaW5zdGFuY2VzXHJcbiAgICBwdWJsaWMgc3RhdGljIENhbGlmb3JuaWFBcHBJbnN0YW5jZTogQ2FsaWZvcm5pYUFwcDtcclxuICAgIHB1YmxpYyBwcm9qZWN0b3I6IG1hcXVldHRlLlByb2plY3RvcjtcclxuICAgIHB1YmxpYyBjb250cm9sbGVyOiBDYWxpZm9ybmlhQ29udHJvbGxlcjtcclxuICAgIHB1YmxpYyByb3V0ZXI6IENhbGlmb3JuaWFSb3V0ZXI7XHJcbiAgICBwdWJsaWMgc3RhdGU6IENsaWVudFN0YXRlO1xyXG4gICAgcHVibGljIHBhZ2VQcmV2aWV3OiBQYWdlUHJldmlldztcclxuICAgIHB1YmxpYyBwYWdlUHJldmlld1ZNOiBQYWdlUHJldmlld1ZNO1xyXG4gICAgcHJpdmF0ZSBfcHJvcGVydHlCYXJzOiBQcm9wZXJ0eUJhcltdID0gW107XHJcbiAgICBwcml2YXRlIF9wcm9wZXJ0eUJhclZNczogUHJvcGVydHlCYXJWTVtdID0gW107XHJcbiAgICBwcml2YXRlIF9wcm9wZXJ0eUJhckJveFRyZWVEb21SZWZlcmVuY2VzOiAoSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQpW10gPSBbXTtcclxuICAgIHByaXZhdGUgX3Byb3BlcnR5QmFyQm94VHJlZVNjcm9sbEhhbmRsZWQ6IGJvb2xlYW5bXSA9IFtdO1xyXG4gICAgcHVibGljIGlzQWpheFJlcXVlc3RSdW5uaW5nOiBib29sZWFuID0gZmFsc2U7IC8vIFRPRE8gbmVlZCBhIHZhbHVlIHRoYXQgY29udGFpbnMgdXBkYXRlIGRhdGEgKHNvIHVzZXIgY2FudCBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW52YWxpZCBkYXRhLCB3aGljaCBpcyB0aW1lIGJldHdlZW4gcmVxdWVzdCBmaW5pc2ggYW5kIHVwZGF0ZSByZWZlcmVuY2VzICsgcmVuZGVyKVxyXG4gICAgLy8gc21vb3RoIHJlc2l6ZSBoYW5kbGVyXHJcbiAgICBwdWJsaWMgcmVzaXplUnRpbWU6IERhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgcHVibGljIHJlc2l6ZVRpbWVvdXQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIC8vIFVJIGxheW91dFxyXG4gICAgcHVibGljIG5hdmlnYXRpb25IZWlndGhQeDogbnVtYmVyID0gMzI7Ly8gVE9ETyA2NDtcclxuICAgIHB1YmxpYyBjb250cm9sQXJlYVdpZHRoUHg6IG51bWJlciA9IDUwMDtcclxuICAgIHByaXZhdGUgX3Byb3BlcnR5QmFyQ291bnQ6IG51bWJlciA9IDQ7IC8vIGV4cGVjdGVkIHRvIGJlIGF0IGxlYXN0ID4gMDsgYWxzbyBjb21wYXRpYmxlIHdpdGggdmlzaWJsZVByb3BlcnR5QmFyQ291bnRcclxuXHJcbiAgICBwdWJsaWMgY2xpZW50RGF0YTogQ2FsaWZvcm5pYUNsaWVudFZpZXdNb2RlbCA9IHtcclxuICAgICAgICBDdXJyZW50UmV2aXNpb246IDAsXHJcbiAgICAgICAgU3RhdHVzVGV4dDogXCJcIixcclxuICAgICAgICBDYWxpZm9ybmlhRXZlbnQ6IENhbGlmb3JuaWFFdmVudC5SZWFkSW5pdGlhbENsaWVudERhdGEsXHJcbiAgICAgICAgQ2FsaWZvcm5pYVByb2plY3Q6IG5ldyBDYWxpZm9ybmlhUHJvamVjdCgpLFxyXG4gICAgICAgIEFsbENzc1Byb3BlcnRpZXM6IFtdLFxyXG4gICAgICAgIFN0eWxlQXRvbUNzc1Byb3BlcnR5TWFwcGluZzoge30sXHJcbiAgICAgICAgVXJsVG9SZWFkQW5kRWRpdDogXCJcIixcclxuICAgICAgICBVcmxUb1JlYWRPbmx5OiBcIlwiLFxyXG4gICAgICAgIFBhcnRpYWxVcGRhdGU6IG5ldyBDYWxpZm9ybmlhQ2xpZW50UGFydGlhbERhdGEoKSxcclxuICAgICAgICBUaGlyZFBhcnR5Rm9udHM6IFtdXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9qZWN0b3IgPSBtYXF1ZXR0ZS5jcmVhdGVQcm9qZWN0b3IoKTtcclxuICAgICAgICAvL2lmIChNYXRoSmF4LkhUTUwuQ29va2llICE9PSB1bmRlZmluZWQpIHsgVE9ET1xyXG4gICAgICAgIHRoaXMucGFnZVByZXZpZXcgPSBuZXcgUGFnZVByZXZpZXcodGhpcyk7XHJcbiAgICAgICAgdGhpcy5wYWdlUHJldmlld1ZNID0gdGhpcy5wYWdlUHJldmlldy52aWV3TW9kZWw7XHJcbiAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMDsgaSA8IHRoaXMucHJvcGVydHlCYXJDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eUJhciA9IG5ldyBQcm9wZXJ0eUJhcih0aGlzLCBpKTtcclxuICAgICAgICAgICAgdGhpcy5fcHJvcGVydHlCYXJzLnB1c2gocHJvcGVydHlCYXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eUJhclZNcy5wdXNoKHByb3BlcnR5QmFyLnZpZXdNb2RlbCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5QmFyQm94VHJlZURvbVJlZmVyZW5jZXMucHVzaCh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eUJhckJveFRyZWVTY3JvbGxIYW5kbGVkLnB1c2goZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgQ2FsaWZvcm5pYUNvbnRyb2xsZXIodGhpcyk7XHJcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSBuZXcgQ2FsaWZvcm5pYVJvdXRlcih0aGlzKTtcclxuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IENsaWVudFN0YXRlKHRoaXMpO1xyXG4gICAgICAgIC8vIGdldCBjbGllbnQgZGF0YSBUT0RPIHNlbmQgd2l0aCBpbml0aWFsIHBhZ2VcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXIuSW5pdGlhbENsaWVudERhdGFKc29uKG5ldyBEYXRlKCkudG9TdHJpbmcoKSlcclxuICAgICAgICAgICAgLmRvbmUoZnVuY3Rpb24gKGRhdGE6IGFueSk6IHZvaWQge1xyXG4gICAgICAgICAgICAgICAgQ2FsaWZvcm5pYUFwcC5DYWxpZm9ybmlhQXBwSW5zdGFuY2Uucm91dGVyLnVwZGF0ZURhdGEoZGF0YSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH0pLmZhaWwoZnVuY3Rpb24gKCk6IHZvaWQge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb3VsZCBub3QgZ2V0IGRhdGFcIik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGluaXRpYWxpemUgcHJvamVjdG9yIFxyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGZ1bmN0aW9uICgpOiB2b2lkIHtcclxuICAgICAgICAgICAgQ2FsaWZvcm5pYUFwcC5DYWxpZm9ybmlhQXBwSW5zdGFuY2UucHJvamVjdG9yLmFwcGVuZChDYWxpZm9ybmlhQXBwLkNhbGlmb3JuaWFBcHBJbnN0YW5jZS5jYWxpZm9ybmlhTWFpbkRpdiwgQ2FsaWZvcm5pYUFwcC5DYWxpZm9ybmlhQXBwSW5zdGFuY2UucmVuZGVyQ2FsaWZvcm5pYUFwcCk7IC8vIGNhbGlmb3JuaWFNYWluRGl2IGhhcyBoZWlnaHQ9MTAwJSBmb3IgaVBhZFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGZ1bmN0aW9uICgpOiB2b2lkIHtcclxuICAgICAgICAgICAgLy8gc21vb3RoIHJlc2l6ZVxyXG4gICAgICAgICAgICBDYWxpZm9ybmlhQXBwLkNhbGlmb3JuaWFBcHBJbnN0YW5jZS5yZXNpemVSdGltZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgIGlmIChDYWxpZm9ybmlhQXBwLkNhbGlmb3JuaWFBcHBJbnN0YW5jZS5yZXNpemVUaW1lb3V0ID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgQ2FsaWZvcm5pYUFwcC5DYWxpZm9ybmlhQXBwSW5zdGFuY2UucmVzaXplVGltZW91dCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KENhbGlmb3JuaWFBcHAuQ2FsaWZvcm5pYUFwcEluc3RhbmNlLnJlc2l6ZUNoZWNrSGFuZGxlciwgUkVTSVpFX0hBTkRMRVJfREVMQVlfTVMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBnZXQgcHJvcGVydHlCYXJDb3VudCgpOiBudW1iZXIge1xyXG4gICAgICAgIC8vIGNvbnN0YW50XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnR5QmFyQ291bnQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBnZXQgcHJvcGVydHlCYXJzKCk6IFByb3BlcnR5QmFyW10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9wZXJ0eUJhcnM7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBnZXQgcHJvcGVydHlCYXJWTXMoKTogUHJvcGVydHlCYXJWTVtdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydHlCYXJWTXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBnZXQgcHJvcGVydHlCYXJCb3hUcmVlRG9tUmVmZXJlbmNlcygpOiAoSFRNTERpdkVsZW1lbnR8dW5kZWZpbmVkKVtdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydHlCYXJCb3hUcmVlRG9tUmVmZXJlbmNlcztcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGdldCBwcm9wZXJ0eUJhckJveFRyZWVTY3JvbGxIYW5kbGVkKCk6IGJvb2xlYW5bXSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnR5QmFyQm94VHJlZVNjcm9sbEhhbmRsZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgcmVzaXplQ2hlY2tIYW5kbGVyID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGxldCBjdXJUaW1lOiBudW1iZXIgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGlmICgoY3VyVGltZSAtIENhbGlmb3JuaWFBcHAuQ2FsaWZvcm5pYUFwcEluc3RhbmNlLnJlc2l6ZVJ0aW1lLmdldE1pbGxpc2Vjb25kcygpKSA8IFJFU0laRV9IQU5ETEVSX0RFTEFZX01TKSB7Ly8gaWdub3JlIHJlc2l6ZSBldmVudFxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KENhbGlmb3JuaWFBcHAuQ2FsaWZvcm5pYUFwcEluc3RhbmNlLnJlc2l6ZUNoZWNrSGFuZGxlciwgUkVTSVpFX0hBTkRMRVJfREVMQVlfTVMpO1xyXG4gICAgICAgIH0gZWxzZSB7IC8vIERvbmUgcmVzaXppbmc7cmVzaXplZEJyb3dzZXJcclxuICAgICAgICAgICAgQ2FsaWZvcm5pYUFwcC5DYWxpZm9ybmlhQXBwSW5zdGFuY2UucmVzaXplQ2hhbmdlZEhhbmRsZXIoKTtcclxuICAgICAgICAgICAgQ2FsaWZvcm5pYUFwcC5DYWxpZm9ybmlhQXBwSW5zdGFuY2UucmVzaXplVGltZW91dCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlc2l6ZUNoYW5nZWRIYW5kbGVyID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIENhbGlmb3JuaWFBcHAuQ2FsaWZvcm5pYUFwcEluc3RhbmNlLnN0YXRlLm92ZXJyaWRlUmVzcG9uc2l2ZURldmljZUlkID0gMDtcclxuICAgICAgICBDYWxpZm9ybmlhQXBwLkNhbGlmb3JuaWFBcHBJbnN0YW5jZS5yb3V0ZXIuc2V0dXBVaUZvckRldmljZSgpOyAvLyBUT0RPIGNvc3RzIHRvbyBtdWNoIGVuZXJneSwgbWFrZSBpdCBhbHNvIG1hbnVhbGx5IGF2YWlsYWJsZVxyXG4gICAgICAgIENhbGlmb3JuaWFBcHAuQ2FsaWZvcm5pYUFwcEluc3RhbmNlLnByb2plY3Rvci5zY2hlZHVsZVJlbmRlcigpOyAvLyBUT0RPIG1pZ2h0IGJlIGNhbGxlZCB0b28gb2Z0ZW4gLy8gVE9ETyBkb2N1bWVudCByZW5kZXIgY2FsbHMgYnkgZnVuY3Rpb25cclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSByZW5kZXJDYWxpZm9ybmlhQXBwID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICBsZXQgYXBwU3R5bGVzID0ge1xyXG4gICAgICAgICAgICBcIndpZHRoXCI6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICBcIm1heC13aWR0aFwiOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgXCJoZWlnaHRcIjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgIFwibWF4LWhlaWdodFwiOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiZmxleFwiLFxyXG4gICAgICAgICAgICBcImZsZXgtZmxvd1wiOiBcInJvdyBub3dyYXBcIlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHJlbmRlcmVkUHJvcGVydHlCYXJzOiBWTm9kZVtdID0gW107IC8vIGVxdWFsbHkgc3BhY2VkLCBzZXBhcmF0ZSBvdmVyZmxvdzpzY3JvbGxcclxuICAgICAgICBsZXQgbWF4UmVuZGVyZWRQcm9wZXJ0eUJhckNvdW50OiBudW1iZXIgPSB0aGlzLnN0YXRlLnZpc2libGVQcm9wZXJ0eUJhck1heENvdW50ID4gdGhpcy5fcHJvcGVydHlCYXJDb3VudCA/IHRoaXMuX3Byb3BlcnR5QmFyQ291bnQgOiB0aGlzLnN0YXRlLnZpc2libGVQcm9wZXJ0eUJhck1heENvdW50XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhSZW5kZXJlZFByb3BlcnR5QmFyQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICByZW5kZXJlZFByb3BlcnR5QmFycy5wdXNoKHRoaXMuX3Byb3BlcnR5QmFyc1tpXS5yZW5kZXJQcm9wZXJ0eUJhcigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDxkaXYgc3R5bGVzPXthcHBTdHlsZXN9PlxyXG4gICAgICAgICAgICB7dGhpcy5wYWdlUHJldmlldy5yZW5kZXJQcmV2aWV3QXJlYSgpfVxyXG4gICAgICAgICAgICB7KHRoaXMuc3RhdGUuaXNIaWRlVXNlckludGVyZmFjZSB8fCB0aGlzLnN0YXRlLmVkaXRWaWV3TW9kZSA9PT0gRWRpdFZpZXdNb2RlLlBhZ2VQcmV2aWV3T25seSkgPyB1bmRlZmluZWQgOiByZW5kZXJlZFByb3BlcnR5QmFyc31cclxuICAgICAgICAgICAge3RoaXMuX3Byb3BlcnR5QmFyc1swXS5yZW5kZXJQcm9wZXJ0eUJhclBvcHBlcnNSZW5kZXJPbmNlKCl9XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vTW9kZWxzL0NhbGlmb3JuaWFBcHAudHN4IiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2pzeC50c1wiIC8+XHJcblwidXNlIHN0cmljdFwiO1xyXG5pbXBvcnQgeyBDYWxpZm9ybmlhQXBwLCBERUZBVUxUX0VYQ0VQVElPTiB9IGZyb20gXCIuL0NhbGlmb3JuaWFBcHBcIjtcclxuaW1wb3J0IHsgTGF5b3V0VHlwZSwgQ2FsaWZvcm5pYVZpZXcsIENhbGlmb3JuaWFFdmVudCB9IGZyb20gXCIuL0NhbGlmb3JuaWFHZW5lcmF0ZWRcIjtcclxuaW1wb3J0IHsgVHJhbnNhY3Rpb25Nb2RlIH0gZnJvbSBcIi4uL1ZpZXdNb2RlbHMvUHJvcGVydHlCYXJWTVwiO1xyXG5cclxubGV0IGN1cnJlbnRBcHA6IENhbGlmb3JuaWFBcHA7XHJcbmxldCBjdXJyZW50Q2xpZW50U3RhdGU6IENsaWVudFN0YXRlO1xyXG5cclxuZXhwb3J0IGNvbnN0IFNUQVRJQ19NQVJHSU5fUFg6IG51bWJlciA9IDI1O1xyXG5cclxuZXhwb3J0IGVudW0gU2VsZWN0aW9uTW9kZSB7XHJcbiAgICBTdHlsZXMgPSAwLFxyXG4gICAgQ29udGVudCA9IDEgICAgXHJcbn07XHJcblxyXG5leHBvcnQgZW51bSBSZWFkeVN0YXRlIHtcclxuICAgIE9rID0gMCxcclxuICAgIFBlbmRpbmcgPSAxXHJcbn07XHJcblxyXG5leHBvcnQgZW51bSBFZGl0Vmlld01vZGUge1xyXG4gICAgRGVmYXVsdCA9IDAsXHJcbiAgICBTaWRlYmFyT25seSA9IDEsXHJcbiAgICBQYWdlUHJldmlld09ubHkgPSAyXHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgQ2xpZW50U3RhdGUge1xyXG4gICAgcHVibGljIGlzRGF0YUxvYWRlZDogYm9vbGVhbiA9IGZhbHNlOyAvLyBUT0RPXHJcbiAgICBwdWJsaWMgaXNIaWRlVXNlckludGVyZmFjZTogYm9vbGVhbiA9IGZhbHNlOyAvLyBUT0RPXHJcbiAgICBwdWJsaWMgZWRpdFZpZXdNb2RlOiBFZGl0Vmlld01vZGUgPSBFZGl0Vmlld01vZGUuRGVmYXVsdDsgLy8gVE9ET1xyXG4gICAgcHVibGljIGN1cnJlbnRTZWxlY3Rpb25Nb2RlOiBTZWxlY3Rpb25Nb2RlID0gU2VsZWN0aW9uTW9kZS5Db250ZW50O1xyXG4gICAgcHVibGljIGN1cnJlbnRSZWFkeVN0YXRlOiBSZWFkeVN0YXRlID0gUmVhZHlTdGF0ZS5PazsgLy8gVE9ETyB1c2UgZXZlcnl3aGVyZVxyXG4gICAgcHVibGljIGlzSmF4T246IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIC8vIC0tLSByZXNwb25zaXZlIHNlbGVjdG9yOiBzaG93cyByZXNwb25zaXZlIGRldmljZSBmb3IgY3VycmVudCBjbGllbnQgc2l6ZSAoZS5nLiAxMjAwcHggYnJvd3NlciAtIDM1MHB4IFVJIHdpZHRoIGhpZ2hsaWdodHMgcmVzcF94LCB3aGVyZSByZXNwXyh4LTEpLldpZHRoVGhyZXNob2xkID09IDgwMHB4IDwgcmVzcF8oeCkuV2lkdGhUaHJlc2hvbGQgPT0gMTAwMHB4IDw9IHJlc3BfKHgrMSkuV2lkdGhUaHJlc2hvbGQgPT0gMTIwMHB4KVxyXG4gICAgLy8gdXNlciBjYW4gb3ZlcnJpZGUgdGhlIHRhcmdldCByZXNwb25zaXZlIGRldmljZSwgZm9yIGEgZGV2aWNlIGJldHdlZW4gbG93ZXN0V2lkdGhUaHJlc2hvbGQgYW5kIGhpZ2hlc3RXaWR0aFRocmVzaG9sZDsgaWYgaXQgaXMgc21hbGxlciB0aGFuIGNsaWVudCBzaXplLCBlbXB0eSBzcGFjZSBpcyBmaWxsZWQgd2l0aCBVSSBtYXJnaW47IGlmIGl0IGlzIGxhcmdlciwgdGhlIHByZXZpZXcgc2l6ZSBpcyBpbmNyZWFzZWQgKG92ZXJmbG93PXNjcm9sbClcclxuICAgIHB1YmxpYyBsb3dlc3RXaWR0aFRocmVzaG9sZFJlc3BvbnNpdmVEZXZpY2VJZDogbnVtYmVyID0gMDsgLy8gVE9ETyBpcyBub3QgY2xpZW50IHN0YXRlIGJ1dCBzZXJ2ZXIgZGF0YSBzdGF0ZSwgd2hpY2ggaXMgY2FsY3VsYXRlZCBvbiBjbGllbnRcclxuICAgIHB1YmxpYyBoaWdoZXN0V2lkdGhUaHJlc2hvbGRSZXNwb25zaXZlRGV2aWNlSWQ6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgc3BlY2lhbFN0eWxlSG9sZGVyOiBDYWxpZm9ybmlhVmlldyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuICAgIHB1YmxpYyBjdXJyZW50UmVzcG9uc2l2ZURldmljZUlkOiBudW1iZXIgPSAwO1xyXG4gICAgcHVibGljIG5vbmVSZXNwb25zaXZlRGV2aWNlSWQ6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgZGVmYXVsdFN5bW1ldHJpY1BhZ2VQcmV2aWV3SG9sZGVyTWFyZ2luUHg6IG51bWJlciA9IFNUQVRJQ19NQVJHSU5fUFg7IC8vIHN0YXRpYyBtYXJnaW4sIHVzZWQgaW4gdGhlIGRlZmF1bHQgdmlld1xyXG4gICAgcHVibGljIG92ZXJyaWRlUmVzcG9uc2l2ZURldmljZUlkOiBudW1iZXIgPSAwOyAvLyBjYW4gYmUgMCBmb3Igbm8gc2VsZWN0aW9uLCBvciByZXNwb25zaXZlIGRldmljZSBpZCBmb3IgYSBkZXZpY2U6IGxvd2VzdFdpZHRoVGhyZXNob2xkIDwgc2VsZWN0ZWQgZGV2aWNlIHdpZHRoVGhyZXNob2xkIDwgaGlnaGVzdFdpZHRoVGhyZXNob2xkXHJcbiAgICBwdWJsaWMgYXZhaWxhYmxlU3BhY2VQYWdlUHJldmlld1B4OiBudW1iZXI7XHJcbiAgICBwdWJsaWMgaXNFbm91Z2hBdmFpbGFibGVTcGFjZVBhZ2VQcmV2aWV3OiBib29sZWFuID0gdHJ1ZTtcclxuICAgIHB1YmxpYyB0YXJnZXRQYWdlUHJldmlld0hvbGRlck1hcmdpblB4OiBudW1iZXIgPSBTVEFUSUNfTUFSR0lOX1BYO1xyXG4gICAgcHVibGljIHRhcmdldFBhZ2VQcmV2aWV3V2lkdGhQeDogbnVtYmVyO1xyXG4gICAgcHVibGljIHZpc2libGVQcm9wZXJ0eUJhck1heENvdW50OiBudW1iZXIgPSAyOyAvLyBjYW4gYmUgMSwgMiBvciA0XHJcbiAgICBwdWJsaWMgcG9wdXBUYXJnZXRQcm9wZXJ0eUJhckluZGV4OiBudW1iZXIgPSAwO1xyXG4gICAgcHVibGljIGN1cnJlbnRUcmFuc2FjdGlvbk1vZGU6IFRyYW5zYWN0aW9uTW9kZSA9IFRyYW5zYWN0aW9uTW9kZS5Nb3ZlTGF5b3V0TW9sZWN1bGVJbnRvTGF5b3V0TW9sZWN1bGU7XHJcbiAgICBwdWJsaWMgaGlnaGxpZ2h0ZWRMYXlvdXRCYXNlSWQ6IG51bWJlciA9IDA7IC8vIFRPRE8gaGFuZGxpbmcgd2hlbiBpdGVtIGlzIGRlbGV0ZWQgd2hpbGUgYmVpbmcgaGlnaGxpZ2h0ZWRcclxuICAgIHB1YmxpYyBpc1NlbGVjdEFsbFRleHRBcmVhOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAvLyAtLS0gdW5kby9yZXBlYXQgLS0tXHJcbiAgICBwdWJsaWMgbGFzdENvbW1hbmQ6IENhbGlmb3JuaWFFdmVudCA9IENhbGlmb3JuaWFFdmVudC5SZWFkSW5pdGlhbENsaWVudERhdGE7XHJcbiAgICBwdWJsaWMgbGFzdENhbGlmb3JuaWFFdmVudERhdGE6IChzdHJpbmd8bnVtYmVyKVtdID0gW107XHJcbiAgICAvLyAtLS1cclxuICAgIC8vIC0tLSBob3Zlci9zZWxlY3Rpb24gc3RhdGUgLS0tXHJcbiAgICBwdWJsaWMgc2VsZWN0ZWRMYXlvdXRCYXNlSWQ6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgcHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQ6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgcHJlc2VsZWN0ZWRDYWxpZm9ybmlhVmlld0lkOiBudW1iZXIgPSAwO1xyXG4gICAgcHVibGljIGlzRHJhd0hlbHBlckxpbmVzOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBwdWJsaWMgaG92ZXJlZEJveFRyZWVMYXlvdXRCYXNlSWQ6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgaG92ZXJlZFBhZ2VQcmV2aWV3TGF5b3V0QmFzZUlkOiBudW1iZXIgPSAwO1xyXG4gICAgcHVibGljIGhvdmVyZWRJbnNlcnRMYXlvdXRCYXNlSWQ6IG51bWJlciA9IDA7IC8vIHNlbGVjdGVkTGF5b3V0QmFzZUlkIGlzIHRhcmdldFxyXG4gICAgcHVibGljIGJhY2t1cFNvcnRPcmRlcjogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkOyAvLyBob3ZlcmVkSW5zZXJ0TGF5b3V0QmFzZUlkIGdldHMgdGVtcG9yYXJ5IHNvcnQgb3JkZXIga2V5IChhdG9tIGluIGJveCA9PiBtYXhJbnQgZXRjLilcclxuICAgIHB1YmxpYyBiYWNrdXBPd25lclJvd0lkOiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7IC8vIGhvdmVyZWRJbnNlcnRMYXlvdXRCYXNlSWQgZ2V0cyB0ZW1wb3Jhcnkgb3duZXIgcm93IChzb21ldGltZXMpXHJcbiAgICBwdWJsaWMgYmFja3VwUGxhY2VkQm94SW5Cb3hJZDogbnVtYmVyIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkOyAvLyBob3ZlcmVkSW5zZXJ0TGF5b3V0QmFzZUlkIGdldHMgdGVtcG9yYXJ5IG93bmVyIHJvdyAoc29tZXRpbWVzLCBvbmx5IHdoZW4gYmFja3VwT3duZXJSb3dJZCBpcyBzZXQpXHJcbiAgICAvLyAtLS1cclxuICAgIC8vIC0tLSB1bmlxdWUgc3R5bGVzIC0tLVxyXG4gICAgcHVibGljIG5ld0JveFN0eWxlTW9sZWN1bGVJZDogbnVtYmVyID0gMDtcclxuICAgIC8vIC0tLVxyXG4gICAgY29uc3RydWN0b3IoY2FsaWZvcm5pYUFwcEFyZzogQ2FsaWZvcm5pYUFwcCkge1xyXG4gICAgICAgIGN1cnJlbnRDbGllbnRTdGF0ZSA9IHRoaXM7XHJcbiAgICAgICAgY3VycmVudEFwcCA9IGNhbGlmb3JuaWFBcHBBcmc7XHJcbiAgICB9O1xyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vTW9kZWxzL0NsaWVudFN0YXRlLnRzeCIsIlwidXNlIHN0cmljdFwiO1xyXG5pbXBvcnQgKiBhcyBtYXF1ZXR0ZSBmcm9tIFwibWFxdWV0dGVcIjtcclxuY29uc3QgaCA9IG1hcXVldHRlLmg7XHJcbmltcG9ydCB7IFByb3BlcnR5QmFyIH0gZnJvbSBcIi4vLi4vTW9kZWxzL1Byb3BlcnR5QmFyXCI7XHJcbmltcG9ydCB7IFN0eWxlUXVhbnR1bSwgU3R5bGVBdG9tLCBTdHlsZUF0b21UeXBlLCBTdHlsZU1vbGVjdWxlLCBMYXlvdXRSb3csIExheW91dEJhc2UsIENhbGlmb3JuaWFWaWV3IH0gZnJvbSBcIi4uL01vZGVscy9DYWxpZm9ybmlhR2VuZXJhdGVkXCI7XHJcbmltcG9ydCB7IENhbGlmb3JuaWFBcHAgfSBmcm9tIFwiLi4vTW9kZWxzL0NhbGlmb3JuaWFBcHBcIjtcclxuXHJcbmV4cG9ydCBlbnVtIFByb3BlcnR5QmFyTW9kZSB7XHJcbiAgICBOb25lID0gMCxcclxuICAgIENhbGlmb3JuaWFWaWV3ID0gMSxcclxuICAgIExheW91dE1vbGVjdWxlcyA9IDIsXHJcbiAgICBMYXlvdXRBdG9tcyA9IDMsXHJcbiAgICBBbGxTdHlsZVF1YW50dW1zID0gNCxcclxuICAgIEFsbFN0eWxlQXRvbXMgPSA1LFxyXG4gICAgQWxsU3R5bGVNb2xlY3VsZXMgPSA2LFxyXG4gICAgU3R5bGVNb2xlY3VsZSA9IDcsXHJcbiAgICBBbGxMYXlvdXRNb2xlY3VsZXMgPSA4LFxyXG4gICAgTGF5b3V0QmFzZSA9IDksXHJcbiAgICBBbGxDYWxpZm9ybmlhVmlld3MgPSAxMFxyXG59O1xyXG5cclxuZXhwb3J0IGVudW0gUG9wdXBTZWNvbmRhcnlNb2RlIHtcclxuICAgIE5vbmUgPSAwLFxyXG4gICAgU2VsZWN0Qm94SW50b0JveCA9IDEsXHJcbiAgICBTZWxlY3RCb3hJbnRvQm94QXRvbUluUGxhY2UgPSAyXHJcbn07XHJcblxyXG5leHBvcnQgZW51bSBQb3B1cE1vZGUge1xyXG4gICAgTm9uZSA9IDAsXHJcbiAgICBBZGRDc3NQcm9wZXJ0eSA9IDEsXHJcbiAgICBBbGxDc3NQcm9wZXJ0aWVzID0gMixcclxuICAgIFVwZGF0ZUNzc1ZhbHVlID0gMyxcclxuICAgIE1hdGNoaW5nUXVhbnR1bXMgPSA0LFxyXG4gICAgVXBkYXRlQ3NzUXVhbnR1bSA9IDUsXHJcbiAgICBBbGxDc3NQcm9wZXJ0aWVzRm9yUXVhbnR1bSA9IDYsXHJcbiAgICBJbnNlcnRMYXlvdXRSb3dJbnRvVmlldyA9IDcsXHJcbiAgICBJbnNlcnRMYXlvdXRBdG9tSW50b0JveCA9IDgsXHJcbiAgICBTZWxlY3RCb3ggPSA5LCAvLyBUT0RPIHJlbmFtZSB0byBTZWxlY3RCb3hIYXNTZWNvbmRhcnkgb3IgaG93IHRvIG1ha2Ugc3VyZSBzZWNvbmRhcnkgbW9kZSBpcyBzZXQ/XHJcbiAgICBNb3ZlU3R5bGVBdG9tID0gMTAsXHJcbiAgICBTaGFyZUNhbGlmb3JuaWFQcm9qZWN0ID0gMTEsXHJcbiAgICBTZWxlY3RJbnRlcmFjdGlvblRhcmdldCA9IDEyLFxyXG4gICAgU2VsZWN0SW50ZXJhY3Rpb25UYXJnZXRMYXlvdXRGaWx0ZXIgPSAxMyxcclxuICAgIENhbGlmb3JuaWFWaWV3U2VsZWN0aW9uID0gMTQsXHJcbiAgICBFZGl0VXNlckRlZmluZWRDc3MgPSAxNSxcclxuICAgIFN1Z2dlc3RlZENzc1ZhbHVlcyA9IDE2XHJcbn07XHJcblxyXG5leHBvcnQgZW51bSBUcmFuc2FjdGlvbk1vZGUge1xyXG4gICAgTW92ZUxheW91dE1vbGVjdWxlSW50b0xheW91dE1vbGVjdWxlID0gMCwgLy8gVE9ETyBuZWVkIGRlZmF1bHQgPT09IG5vbmU/XHJcbiAgICBNb3ZlTGF5b3V0TW9sZWN1bGVCZWZvcmVMYXlvdXRNb2xlY3VsZSA9IDEsIC8vIFRPRE8gZGlmZmVyZW50aWF0ZSBtb2RlXHJcbiAgICBTeW5jTGF5b3V0U3R5bGVzSW1pdGF0aW5nID0gMlxyXG59XHJcblxyXG5sZXQgY3VycmVudEFwcDogQ2FsaWZvcm5pYUFwcDtcclxuXHJcbmV4cG9ydCBjbGFzcyBQcm9wZXJ0eUJhclZNIHtcclxuICAgIHByaXZhdGUgcHJvcGVydHlCYXJWTUluZGV4OiBudW1iZXIgPSAtMTtcclxuICAgIHB1YmxpYyBjdXJyZW50UHJvcGVydHlCYXJNb2RlOiBQcm9wZXJ0eUJhck1vZGUgPSBQcm9wZXJ0eUJhck1vZGUuTm9uZTtcclxuICAgIHB1YmxpYyBjdXJyZW50UG9wdXBNb2RlOiBQb3B1cE1vZGUgPSBQb3B1cE1vZGUuTm9uZTtcclxuICAgIHB1YmxpYyBjdXJyZW50U2Vjb25kYXJ5UG9wdXBNb2RlOiBQb3B1cFNlY29uZGFyeU1vZGUgPSBQb3B1cFNlY29uZGFyeU1vZGUuTm9uZTtcclxuICAgIC8vIGRhdGFcclxuICAgIHB1YmxpYyB0ZW1wUXVhbnR1bU5hbWU6IHN0cmluZyA9IFwiUXVhbnR1bVwiO1xyXG4gICAgcHVibGljIHRlbXBDc3NQcm9wZXJ0eU5hbWU6IHN0cmluZyA9IFwiXCI7XHJcbiAgICBwdWJsaWMgdGVtcENzc1ZhbHVlOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHVibGljIGxhc3RVc2VkVGVtcENzc1ZhbHVlOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHVibGljIHRlbXBQc2V1ZG9TZWxlY3Rvcjogc3RyaW5nID0gXCJcIjtcclxuICAgIHB1YmxpYyB0ZW1wQ2FsaWZvcm5pYVZpZXdOYW1lOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHVibGljIHRlbXBDc3NWYWx1ZUZvckludGVyYWN0aW9uOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHVibGljIHNlbGVjdGVkU3R5bGVBdG9tSWQ6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgc2VsZWN0ZWRTdHlsZVZhbHVlSWQ6IG51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgc2VsZWN0ZWRTdHlsZVF1YW50dW1JZDogbnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBzZWxlY3RlZFN0eWxlTW9sZWN1bGVJZDogbnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgX3NlbGVjdGVkQ2FsaWZvcm5pYVZpZXdJZDogbnVtYmVyID0gMDsgLy8gY2FuIGJlIDBcclxuICAgIHB1YmxpYyBzZWxlY3RlZFJlc3BvbnNpdmVEZXZpY2VJZDogbnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBzZWxlY3RlZFN0YXRlTW9kaWZpZXI6IHN0cmluZyA9IFwiXCI7XHJcbiAgICBwdWJsaWMgc2VsZWN0ZWRTdHlsZUF0b21UeXBlOiBTdHlsZUF0b21UeXBlID0gU3R5bGVBdG9tVHlwZS5HZW5lcmljO1xyXG4gICAgcHVibGljIHNlbGVjdGVkTGF5b3V0QmFzZUlkRm9yRmlsdGVyOiBudW1iZXIgPSAwO1xyXG4gICAgcHVibGljIHNlbGVjdGVkTGF5b3V0U3R5bGVJbnRlcmFjdGlvbjogbnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyB0ZW1wT3JpZ2luYWxDb250ZW50OiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHVibGljIHRlbXBDb250ZW50OiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHVibGljIGVkaXRlZExheW91dEF0b21JZDogbnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyB0ZW1wVXNlckRlZmluZWRDc3M6IHN0cmluZyA9IFwiXCI7XHJcbiAgICBwcml2YXRlIF9kZWVwZXN0TGV2ZWxBY3RpdmVWaWV3OiBudW1iZXIgPSAwOyAvLyBzdXBwb3NlZCB0byBiZSBzdHJpY3RseSBsYXJnZXIgZXF1YWwgYW55IGxheW91dCBhdG9tIGxldmVsIGZvciBjdXJyZW50IHZpZXdcclxuICAgIC8vIFRPRE8gZGlmZmVyZW50IHNlbGVjdGlvbnMgb2Ygc2FtZSBvYmplY3QgdHlwZSBwb3NzaWJsZSBkZXBlbmRpbmcgb24gY3VycmVudCBVSSBmdW5jdGlvbmFsaXR5XHJcbiAgICBwdWJsaWMgc2VsZWN0ZWRTdHlsZUF0b21JZEZvclBvcHVwOiBudW1iZXIgPSAwO1xyXG4gICAgLy8gYm94IHRyZWVcclxuICAgIHB1YmxpYyBpc1N5bmNlZFdpdGhCb3hUcmVlVG9UaGVMZWZ0OiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBwdWJsaWMgaXNTeW5jZWRXaXRoUGFnZVByZXZpZXc6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIC8vIGNvbXBvbmVudHNcclxuICAgIHB1YmxpYyBzdHlsZVF1YW50dW1Qcm9qZWN0b3I6IG1hcXVldHRlLk1hcHBpbmc8U3R5bGVRdWFudHVtLCB7IHJlbmRlck1hcXVldHRlOiAoKSA9PiBtYXF1ZXR0ZS5WTm9kZSB9PjtcclxuICAgIHB1YmxpYyBzdHlsZUF0b21Qcm9qZWN0b3I6IG1hcXVldHRlLk1hcHBpbmc8U3R5bGVBdG9tLCB7IHJlbmRlck1hcXVldHRlOiAoKSA9PiBtYXF1ZXR0ZS5WTm9kZSB9PjtcclxuICAgIHB1YmxpYyBzdHlsZU1vbGVjdWxlUHJvamVjdG9yOiBtYXF1ZXR0ZS5NYXBwaW5nPFN0eWxlTW9sZWN1bGUsIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+O1xyXG4gICAgcHVibGljIGluc3RhbmNlYWJsZUF0b21Qcm9qZWN0b3I6IG1hcXVldHRlLk1hcHBpbmc8TGF5b3V0Um93LCB7IHJlbmRlck1hcXVldHRlOiAoKSA9PiBtYXF1ZXR0ZS5WTm9kZSB9PjtcclxuICAgIHB1YmxpYyBpbnN0YW5jZWFibGVNb2xlY3VsZVByb2plY3RvcjogbWFxdWV0dGUuTWFwcGluZzxMYXlvdXRSb3csIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+O1xyXG4gICAgcHVibGljIGFsbExheW91dE1vbGVjdWxlc1Byb2plY3RvcjogbWFxdWV0dGUuTWFwcGluZzxMYXlvdXRCYXNlLCB7IHJlbmRlck1hcXVldHRlOiAoKSA9PiBtYXF1ZXR0ZS5WTm9kZSB9PjtcclxuICAgIHB1YmxpYyBhbGxDYWxpZm9ybmlhVmlld3NQcm9qZWN0b3I6IG1hcXVldHRlLk1hcHBpbmc8Q2FsaWZvcm5pYVZpZXcsIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+O1xyXG4gICAgcHVibGljIGJveFRyZWVQcm9qZWN0b3I6IG1hcXVldHRlLk1hcHBpbmc8Q2FsaWZvcm5pYVZpZXcsIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+O1xyXG4gICAgLy8gY2xpZW50IHNldHRpbmdzXHJcblxyXG4gICAgY29uc3RydWN0b3IocHJvcGVydHlCYXJBcmc6IFByb3BlcnR5QmFyLCB0YXJnZXRJbmRleDogbnVtYmVyLCBjYWxpZm9ybmlhQXBwQXJnOiBDYWxpZm9ybmlhQXBwKSB7XHJcbiAgICAgICAgY3VycmVudEFwcCA9IGNhbGlmb3JuaWFBcHBBcmc7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0eUJhclZNSW5kZXggPSB0YXJnZXRJbmRleDtcclxuICAgICAgICB0aGlzLnN0eWxlUXVhbnR1bVByb2plY3RvciA9IHByb3BlcnR5QmFyQXJnLnJlbmRlclN0eWxlUXVhbnR1bUFycmF5KHByb3BlcnR5QmFyQXJnKTtcclxuICAgICAgICB0aGlzLnN0eWxlQXRvbVByb2plY3RvciA9IHByb3BlcnR5QmFyQXJnLnJlbmRlclN0eWxlQXRvbUFycmF5KHByb3BlcnR5QmFyQXJnKTtcclxuICAgICAgICB0aGlzLnN0eWxlTW9sZWN1bGVQcm9qZWN0b3IgPSBwcm9wZXJ0eUJhckFyZy5yZW5kZXJTdHlsZU1vbGVjdWxlQXJyYXkocHJvcGVydHlCYXJBcmcpO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VhYmxlQXRvbVByb2plY3RvciA9IHByb3BlcnR5QmFyQXJnLnJlbmRlckxheW91dFJvd0FycmF5KHByb3BlcnR5QmFyQXJnKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlYWJsZU1vbGVjdWxlUHJvamVjdG9yID0gcHJvcGVydHlCYXJBcmcucmVuZGVyTGF5b3V0Um93QXJyYXkocHJvcGVydHlCYXJBcmcpOyAvLyBUT0RPXHJcbiAgICAgICAgdGhpcy5hbGxMYXlvdXRNb2xlY3VsZXNQcm9qZWN0b3IgPSBwcm9wZXJ0eUJhckFyZy5yZW5kZXJMYXlvdXRNb2xlY3VsZUFycmF5KHByb3BlcnR5QmFyQXJnKTtcclxuICAgICAgICB0aGlzLmFsbENhbGlmb3JuaWFWaWV3c1Byb2plY3RvciA9IHByb3BlcnR5QmFyQXJnLnJlbmRlckNhbGlmb3JuaWFWaWV3QXJyYXkocHJvcGVydHlCYXJBcmcpO1xyXG4gICAgICAgIHRoaXMuYm94VHJlZVByb2plY3RvciA9IHByb3BlcnR5QmFyQXJnLnJlbmRlckJveFRyZWVGb3JDYWxpZm9ybmlhVmlldyhwcm9wZXJ0eUJhckFyZyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgZ2V0IGN1cnJlbnRWTSgpOiBQcm9wZXJ0eUJhclZNIHtcclxuICAgICAgICByZXR1cm4gY3VycmVudEFwcC5wcm9wZXJ0eUJhclZNc1t0aGlzLnByb3BlcnR5QmFyVk1JbmRleF07XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBnZXQgc2VsZWN0ZWRDYWxpZm9ybmlhVmlld0lkKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkQ2FsaWZvcm5pYVZpZXdJZDtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGdldCBkZWVwZXN0TGV2ZWxBY3RpdmVWaWV3KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZXBlc3RMZXZlbEFjdGl2ZVZpZXc7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzZXRTZWxlY3RlZFJlc3BvbnNpdmVEZXZpY2VJZCA9IChyZXNwb25zaXZlRGV2aWNlSWQ6IG51bWJlciwgaXNGb3JjZTogYm9vbGVhbik6IHZvaWQgPT4ge1xyXG4gICAgICAgIGlmIChpc0ZvcmNlIHx8IHRoaXMuY3VycmVudFZNLnNlbGVjdGVkUmVzcG9uc2l2ZURldmljZUlkID09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Vk0uc2VsZWN0ZWRSZXNwb25zaXZlRGV2aWNlSWQgPSByZXNwb25zaXZlRGV2aWNlSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY2xlYXJTZWxlY3RlZENhbGlmb3JuaWFWaWV3KGlzQ2xlYXJXaGVuTm9uRXF1YWw6IGJvb2xlYW4sIGNsZWFyV2hlbkVxdWFsc0NhbGlmb3JuaWFWaWV3SWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIC8vIHZpZXcgbW9kZWxzIGNhbiBoYXZlIG5vIHNlbGVjdGlvblxyXG4gICAgICAgIGlmIChpc0NsZWFyV2hlbk5vbkVxdWFsID09PSB0cnVlIHx8IHRoaXMuY3VycmVudFZNLnNlbGVjdGVkQ2FsaWZvcm5pYVZpZXdJZCA9PSBjbGVhcldoZW5FcXVhbHNDYWxpZm9ybmlhVmlld0lkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZNLl9zZWxlY3RlZENhbGlmb3JuaWFWaWV3SWQgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWTS5fZGVlcGVzdExldmVsQWN0aXZlVmlldyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZNLmJveFRyZWVQcm9qZWN0b3IubWFwKFtdKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzZXRTZWxlY3RlZENhbGlmb3JuaWFWaWV3ID0gKGNhbGlmb3JuaWFWaWV3OiBDYWxpZm9ybmlhVmlldywgaXNGb3JjZTogYm9vbGVhbik6IHZvaWQgPT4ge1xyXG4gICAgICAgIGlmIChpc0ZvcmNlIHx8IHRoaXMuY3VycmVudFZNLnNlbGVjdGVkQ2FsaWZvcm5pYVZpZXdJZCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZNLl9zZWxlY3RlZENhbGlmb3JuaWFWaWV3SWQgPSBjYWxpZm9ybmlhVmlldy5DYWxpZm9ybmlhVmlld0lkO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWTS5fZGVlcGVzdExldmVsQWN0aXZlVmlldyA9IGNhbGlmb3JuaWFWaWV3LkRlZXBlc3RMZXZlbDtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Vk0uYm94VHJlZVByb2plY3Rvci5tYXAoW2NhbGlmb3JuaWFWaWV3XSk7IC8vIFRPRE8gbWFwIG5vdCBjb21wYXRpYmxlIHdpdGggLi4uID9cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZNLmJveFRyZWVQcm9qZWN0b3IubWFwKFtdKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Vk0uX2RlZXBlc3RMZXZlbEFjdGl2ZVZpZXcgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWTS5fc2VsZWN0ZWRDYWxpZm9ybmlhVmlld0lkID0gMDtcclxuICAgICAgICB9ICAgICAgICBcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHVwZGF0ZURhdGEgPSAoc3R5bGVRdWFudHVtczogU3R5bGVRdWFudHVtW10sIHN0eWxlQXRvbXM6IFN0eWxlQXRvbVtdLCBzdHlsZU1vbGVjdWxlczogU3R5bGVNb2xlY3VsZVtdLCBsYXlvdXRNb2xlY3VsZXM6IExheW91dEJhc2VbXSwgYWxsQ2FsaWZvcm5pYVZpZXdzOiBDYWxpZm9ybmlhVmlld1tdLCBpbnN0YW5jZWFibGVBdG9tc1ZpZXc6IENhbGlmb3JuaWFWaWV3LCBpbnN0YW5jZWFibGVSb3dzVmlldzogQ2FsaWZvcm5pYVZpZXcpOiB2b2lkID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRWTS5zdHlsZVF1YW50dW1Qcm9qZWN0b3IubWFwKHN0eWxlUXVhbnR1bXMpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFZNLnN0eWxlQXRvbVByb2plY3Rvci5tYXAoc3R5bGVBdG9tcyk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Vk0uc3R5bGVNb2xlY3VsZVByb2plY3Rvci5tYXAoc3R5bGVNb2xlY3VsZXMpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFZNLmFsbExheW91dE1vbGVjdWxlc1Byb2plY3Rvci5tYXAobGF5b3V0TW9sZWN1bGVzKTsgLy8gVE9ETyByZXZlcnNlIHNlcnZlciBzaWRlPyAvLyBUT0RPIG9ubHkgcmVxdWlyZWQgb25jZSBmb3IgYWxsIHByb3BlcnR5YmFyc1xyXG4gICAgICAgIHRoaXMuY3VycmVudFZNLmFsbENhbGlmb3JuaWFWaWV3c1Byb2plY3Rvci5tYXAoYWxsQ2FsaWZvcm5pYVZpZXdzKTsgLy8gVE9ETyBubyBpbnRlcm5hbHNcclxuICAgICAgICB0aGlzLmN1cnJlbnRWTS5pbnN0YW5jZWFibGVBdG9tUHJvamVjdG9yLm1hcChpbnN0YW5jZWFibGVBdG9tc1ZpZXcuUGxhY2VkTGF5b3V0Um93cyk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Vk0uaW5zdGFuY2VhYmxlTW9sZWN1bGVQcm9qZWN0b3IubWFwKGluc3RhbmNlYWJsZVJvd3NWaWV3LlBsYWNlZExheW91dFJvd3MpO1xyXG4gICAgfTtcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1ZpZXdNb2RlbHMvUHJvcGVydHlCYXJWTS50c3giLCIvKiohXG4gKiBAZmlsZU92ZXJ2aWV3IEtpY2thc3MgbGlicmFyeSB0byBjcmVhdGUgYW5kIHBsYWNlIHBvcHBlcnMgbmVhciB0aGVpciByZWZlcmVuY2UgZWxlbWVudHMuXG4gKiBAdmVyc2lvbiAxLjE0LjNcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRmVkZXJpY28gWml2b2xvIGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxudmFyIGxvbmdlclRpbWVvdXRCcm93c2VycyA9IFsnRWRnZScsICdUcmlkZW50JywgJ0ZpcmVmb3gnXTtcbnZhciB0aW1lb3V0RHVyYXRpb24gPSAwO1xuZm9yICh2YXIgaSA9IDA7IGkgPCBsb25nZXJUaW1lb3V0QnJvd3NlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgaWYgKGlzQnJvd3NlciAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YobG9uZ2VyVGltZW91dEJyb3dzZXJzW2ldKSA+PSAwKSB7XG4gICAgdGltZW91dER1cmF0aW9uID0gMTtcbiAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBtaWNyb3Rhc2tEZWJvdW5jZShmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIHdpbmRvdy5Qcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgZm4oKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0sIHRpbWVvdXREdXJhdGlvbik7XG4gICAgfVxuICB9O1xufVxuXG52YXIgc3VwcG9ydHNNaWNyb1Rhc2tzID0gaXNCcm93c2VyICYmIHdpbmRvdy5Qcm9taXNlO1xuXG4vKipcbiogQ3JlYXRlIGEgZGVib3VuY2VkIHZlcnNpb24gb2YgYSBtZXRob2QsIHRoYXQncyBhc3luY2hyb25vdXNseSBkZWZlcnJlZFxuKiBidXQgY2FsbGVkIGluIHRoZSBtaW5pbXVtIHRpbWUgcG9zc2libGUuXG4qXG4qIEBtZXRob2RcbiogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuKiBAYXJndW1lbnQge0Z1bmN0aW9ufSBmblxuKiBAcmV0dXJucyB7RnVuY3Rpb259XG4qL1xudmFyIGRlYm91bmNlID0gc3VwcG9ydHNNaWNyb1Rhc2tzID8gbWljcm90YXNrRGVib3VuY2UgOiB0YXNrRGVib3VuY2U7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QW55fSBmdW5jdGlvblRvQ2hlY2sgLSB2YXJpYWJsZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0bzogaXMgYSBmdW5jdGlvbj9cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jdGlvblRvQ2hlY2spIHtcbiAgdmFyIGdldFR5cGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uVG9DaGVjayAmJiBnZXRUeXBlLnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBHZXQgQ1NTIGNvbXB1dGVkIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgcmV0dXJuIHByb3BlcnR5ID8gY3NzW3Byb3BlcnR5XSA6IGNzcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJlbnROb2RlIG9yIHRoZSBob3N0IG9mIHRoZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5wYXJlbnROb2RlIHx8IGVsZW1lbnQuaG9zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY3JvbGxpbmcgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBzY3JvbGwgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChlbGVtZW50KSB7XG4gIC8vIFJldHVybiBib2R5LCBgZ2V0U2Nyb2xsYCB3aWxsIHRha2UgY2FyZSB0byBnZXQgdGhlIGNvcnJlY3QgYHNjcm9sbFRvcGAgZnJvbSBpdFxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIHN3aXRjaCAoZWxlbWVudC5ub2RlTmFtZSkge1xuICAgIGNhc2UgJ0hUTUwnOlxuICAgIGNhc2UgJ0JPRFknOlxuICAgICAgcmV0dXJuIGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICByZXR1cm4gZWxlbWVudC5ib2R5O1xuICB9XG5cbiAgLy8gRmlyZWZveCB3YW50IHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG5cbiAgdmFyIF9nZXRTdHlsZUNvbXB1dGVkUHJvcCA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KSxcbiAgICAgIG92ZXJmbG93ID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1k7XG5cbiAgaWYgKC8oYXV0b3xzY3JvbGx8b3ZlcmxheSkvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xufVxuXG52YXIgaXNJRTExID0gaXNCcm93c2VyICYmICEhKHdpbmRvdy5NU0lucHV0TWV0aG9kQ29udGV4dCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUpO1xudmFyIGlzSUUxMCA9IGlzQnJvd3NlciAmJiAvTVNJRSAxMC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBicm93c2VyIGlzIEludGVybmV0IEV4cGxvcmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge051bWJlcn0gdmVyc2lvbiB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGlzSUVcbiAqL1xuZnVuY3Rpb24gaXNJRSh2ZXJzaW9uKSB7XG4gIGlmICh2ZXJzaW9uID09PSAxMSkge1xuICAgIHJldHVybiBpc0lFMTE7XG4gIH1cbiAgaWYgKHZlcnNpb24gPT09IDEwKSB7XG4gICAgcmV0dXJuIGlzSUUxMDtcbiAgfVxuICByZXR1cm4gaXNJRTExIHx8IGlzSUUxMDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvZmZzZXQgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICB2YXIgbm9PZmZzZXRQYXJlbnQgPSBpc0lFKDEwKSA/IGRvY3VtZW50LmJvZHkgOiBudWxsO1xuXG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcbiAgLy8gU2tpcCBoaWRkZW4gZWxlbWVudHMgd2hpY2ggZG9uJ3QgaGF2ZSBhbiBvZmZzZXRQYXJlbnRcbiAgd2hpbGUgKG9mZnNldFBhcmVudCA9PT0gbm9PZmZzZXRQYXJlbnQgJiYgZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSAoZWxlbWVudCA9IGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKS5vZmZzZXRQYXJlbnQ7XG4gIH1cblxuICB2YXIgbm9kZU5hbWUgPSBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50Lm5vZGVOYW1lO1xuXG4gIGlmICghbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gLm9mZnNldFBhcmVudCB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBURCBvciBUQUJMRSBpbiBjYXNlXG4gIC8vIG5vIG9mZnNldFBhcmVudCBpcyBwcmVzZW50LCBJIGhhdGUgdGhpcyBqb2IuLi5cbiAgaWYgKFsnVEQnLCAnVEFCTEUnXS5pbmRleE9mKG9mZnNldFBhcmVudC5ub2RlTmFtZSkgIT09IC0xICYmIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShvZmZzZXRQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzT2Zmc2V0Q29udGFpbmVyKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gbm9kZU5hbWUgPT09ICdIVE1MJyB8fCBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkgPT09IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIHJvb3Qgbm9kZSAoZG9jdW1lbnQsIHNoYWRvd0RPTSByb290KSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcm9vdCBub2RlXG4gKi9cbmZ1bmN0aW9uIGdldFJvb3Qobm9kZSkge1xuICBpZiAobm9kZS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdldFJvb3Qobm9kZS5wYXJlbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBvZmZzZXQgcGFyZW50IGNvbW1vbiB0byB0aGUgdHdvIHByb3ZpZGVkIG5vZGVzXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQxXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQyXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gY29tbW9uIG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZWxlbWVudDIpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudDEgfHwgIWVsZW1lbnQxLm5vZGVUeXBlIHx8ICFlbGVtZW50MiB8fCAhZWxlbWVudDIubm9kZVR5cGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gSGVyZSB3ZSBtYWtlIHN1cmUgdG8gZ2l2ZSBhcyBcInN0YXJ0XCIgdGhlIGVsZW1lbnQgdGhhdCBjb21lcyBmaXJzdCBpbiB0aGUgRE9NXG4gIHZhciBvcmRlciA9IGVsZW1lbnQxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQyKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xuICB2YXIgc3RhcnQgPSBvcmRlciA/IGVsZW1lbnQxIDogZWxlbWVudDI7XG4gIHZhciBlbmQgPSBvcmRlciA/IGVsZW1lbnQyIDogZWxlbWVudDE7XG5cbiAgLy8gR2V0IGNvbW1vbiBhbmNlc3RvciBjb250YWluZXJcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnQsIDApO1xuICByYW5nZS5zZXRFbmQoZW5kLCAwKTtcbiAgdmFyIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgLy8gQm90aCBub2RlcyBhcmUgaW5zaWRlICNkb2N1bWVudFxuXG4gIGlmIChlbGVtZW50MSAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgJiYgZWxlbWVudDIgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIHx8IHN0YXJ0LmNvbnRhaW5zKGVuZCkpIHtcbiAgICBpZiAoaXNPZmZzZXRDb250YWluZXIoY29tbW9uQW5jZXN0b3JDb250YWluZXIpKSB7XG4gICAgICByZXR1cm4gY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChjb21tb25BbmNlc3RvckNvbnRhaW5lcik7XG4gIH1cblxuICAvLyBvbmUgb2YgdGhlIG5vZGVzIGlzIGluc2lkZSBzaGFkb3dET00sIGZpbmQgd2hpY2ggb25lXG4gIHZhciBlbGVtZW50MXJvb3QgPSBnZXRSb290KGVsZW1lbnQxKTtcbiAgaWYgKGVsZW1lbnQxcm9vdC5ob3N0KSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDFyb290Lmhvc3QsIGVsZW1lbnQyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZ2V0Um9vdChlbGVtZW50MikuaG9zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQgaW4gdGhlIGdpdmVuIHNpZGUgKHRvcCBhbmQgbGVmdClcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHNpZGUgYHRvcGAgb3IgYGxlZnRgXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbW91bnQgb2Ygc2Nyb2xsZWQgcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbChlbGVtZW50KSB7XG4gIHZhciBzaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAndG9wJztcblxuICB2YXIgdXBwZXJTaWRlID0gc2lkZSA9PT0gJ3RvcCcgPyAnc2Nyb2xsVG9wJyA6ICdzY3JvbGxMZWZ0JztcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBzY3JvbGxpbmdFbGVtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgaHRtbDtcbiAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudFt1cHBlclNpZGVdO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRbdXBwZXJTaWRlXTtcbn1cblxuLypcbiAqIFN1bSBvciBzdWJ0cmFjdCB0aGUgZWxlbWVudCBzY3JvbGwgdmFsdWVzIChsZWZ0IGFuZCB0b3ApIGZyb20gYSBnaXZlbiByZWN0IG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY3QgLSBSZWN0IG9iamVjdCB5b3Ugd2FudCB0byBjaGFuZ2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBmcm9tIHRoZSBmdW5jdGlvbiByZWFkcyB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHBhcmFtIHtCb29sZWFufSBzdWJ0cmFjdCAtIHNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIHN1YnRyYWN0IHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY3QgLSBUaGUgbW9kaWZpZXIgcmVjdCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZVNjcm9sbChyZWN0LCBlbGVtZW50KSB7XG4gIHZhciBzdWJ0cmFjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gIHZhciBtb2RpZmllciA9IHN1YnRyYWN0ID8gLTEgOiAxO1xuICByZWN0LnRvcCArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZXR1cm4gcmVjdDtcbn1cblxuLypcbiAqIEhlbHBlciB0byBkZXRlY3QgYm9yZGVycyBvZiBhIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXG4gKiBSZXN1bHQgb2YgYGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eWAgb24gdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBheGlzIC0gYHhgIG9yIGB5YFxuICogQHJldHVybiB7bnVtYmVyfSBib3JkZXJzIC0gVGhlIGJvcmRlcnMgc2l6ZSBvZiB0aGUgZ2l2ZW4gYXhpc1xuICovXG5cbmZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcywgYXhpcykge1xuICB2YXIgc2lkZUEgPSBheGlzID09PSAneCcgPyAnTGVmdCcgOiAnVG9wJztcbiAgdmFyIHNpZGVCID0gc2lkZUEgPT09ICdMZWZ0JyA/ICdSaWdodCcgOiAnQm90dG9tJztcblxuICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQSArICdXaWR0aCddLCAxMCkgKyBwYXJzZUZsb2F0KHN0eWxlc1snYm9yZGVyJyArIHNpZGVCICsgJ1dpZHRoJ10sIDEwKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZShheGlzLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSB7XG4gIHJldHVybiBNYXRoLm1heChib2R5WydvZmZzZXQnICsgYXhpc10sIGJvZHlbJ3Njcm9sbCcgKyBheGlzXSwgaHRtbFsnY2xpZW50JyArIGF4aXNdLCBodG1sWydvZmZzZXQnICsgYXhpc10sIGh0bWxbJ3Njcm9sbCcgKyBheGlzXSwgaXNJRSgxMCkgPyBodG1sWydvZmZzZXQnICsgYXhpc10gKyBjb21wdXRlZFN0eWxlWydtYXJnaW4nICsgKGF4aXMgPT09ICdIZWlnaHQnID8gJ1RvcCcgOiAnTGVmdCcpXSArIGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnQm90dG9tJyA6ICdSaWdodCcpXSA6IDApO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTaXplcygpIHtcbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICB2YXIgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBpc0lFKDEwKSAmJiBnZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBnZXRTaXplKCdIZWlnaHQnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSxcbiAgICB3aWR0aDogZ2V0U2l6ZSgnV2lkdGgnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKVxuICB9O1xufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogR2l2ZW4gZWxlbWVudCBvZmZzZXRzLCBnZW5lcmF0ZSBhbiBvdXRwdXQgc2ltaWxhciB0byBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvZmZzZXRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDbGllbnRSZWN0IGxpa2Ugb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIGdldENsaWVudFJlY3Qob2Zmc2V0cykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIG9mZnNldHMsIHtcbiAgICByaWdodDogb2Zmc2V0cy5sZWZ0ICsgb2Zmc2V0cy53aWR0aCxcbiAgICBib3R0b206IG9mZnNldHMudG9wICsgb2Zmc2V0cy5oZWlnaHRcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge09iamVjdH0gY2xpZW50IHJlY3RcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSB7fTtcblxuICAvLyBJRTEwIDEwIEZJWDogUGxlYXNlLCBkb24ndCBhc2ssIHRoZSBlbGVtZW50IGlzbid0XG4gIC8vIGNvbnNpZGVyZWQgaW4gRE9NIGluIHNvbWUgY2lyY3Vtc3RhbmNlcy4uLlxuICAvLyBUaGlzIGlzbid0IHJlcHJvZHVjaWJsZSBpbiBJRTEwIGNvbXBhdGliaWxpdHkgbW9kZSBvZiBJRTExXG4gIHRyeSB7XG4gICAgaWYgKGlzSUUoMTApKSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICAgICAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgICAgIHJlY3QudG9wICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0O1xuICAgICAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgdG9wOiByZWN0LnRvcCxcbiAgICB3aWR0aDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcbiAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgfTtcblxuICAvLyBzdWJ0cmFjdCBzY3JvbGxiYXIgc2l6ZSBmcm9tIHNpemVzXG4gIHZhciBzaXplcyA9IGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJyA/IGdldFdpbmRvd1NpemVzKCkgOiB7fTtcbiAgdmFyIHdpZHRoID0gc2l6ZXMud2lkdGggfHwgZWxlbWVudC5jbGllbnRXaWR0aCB8fCByZXN1bHQucmlnaHQgLSByZXN1bHQubGVmdDtcbiAgdmFyIGhlaWdodCA9IHNpemVzLmhlaWdodCB8fCBlbGVtZW50LmNsaWVudEhlaWdodCB8fCByZXN1bHQuYm90dG9tIC0gcmVzdWx0LnRvcDtcblxuICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gd2lkdGg7XG4gIHZhciB2ZXJ0U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgLSBoZWlnaHQ7XG5cbiAgLy8gaWYgYW4gaHlwb3RoZXRpY2FsIHNjcm9sbGJhciBpcyBkZXRlY3RlZCwgd2UgbXVzdCBiZSBzdXJlIGl0J3Mgbm90IGEgYGJvcmRlcmBcbiAgLy8gd2UgbWFrZSB0aGlzIGNoZWNrIGNvbmRpdGlvbmFsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gIGlmIChob3JpelNjcm9sbGJhciB8fCB2ZXJ0U2Nyb2xsYmFyKSB7XG4gICAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KTtcbiAgICBob3JpelNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd4Jyk7XG4gICAgdmVydFNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd5Jyk7XG5cbiAgICByZXN1bHQud2lkdGggLT0gaG9yaXpTY3JvbGxiYXI7XG4gICAgcmVzdWx0LmhlaWdodCAtPSB2ZXJ0U2Nyb2xsYmFyO1xuICB9XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3QocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGNoaWxkcmVuLCBwYXJlbnQpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBpc0lFMTAgPSBpc0lFKDEwKTtcbiAgdmFyIGlzSFRNTCA9IHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnO1xuICB2YXIgY2hpbGRyZW5SZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkcmVuKTtcbiAgdmFyIHBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocGFyZW50KTtcbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChjaGlsZHJlbik7XG5cbiAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQpO1xuICB2YXIgYm9yZGVyVG9wV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJUb3BXaWR0aCwgMTApO1xuICB2YXIgYm9yZGVyTGVmdFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoLCAxMCk7XG5cbiAgLy8gSW4gY2FzZXMgd2hlcmUgdGhlIHBhcmVudCBpcyBmaXhlZCwgd2UgbXVzdCBpZ25vcmUgbmVnYXRpdmUgc2Nyb2xsIGluIG9mZnNldCBjYWxjXG4gIGlmIChmaXhlZFBvc2l0aW9uICYmIHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcGFyZW50UmVjdC50b3AgPSBNYXRoLm1heChwYXJlbnRSZWN0LnRvcCwgMCk7XG4gICAgcGFyZW50UmVjdC5sZWZ0ID0gTWF0aC5tYXgocGFyZW50UmVjdC5sZWZ0LCAwKTtcbiAgfVxuICB2YXIgb2Zmc2V0cyA9IGdldENsaWVudFJlY3Qoe1xuICAgIHRvcDogY2hpbGRyZW5SZWN0LnRvcCAtIHBhcmVudFJlY3QudG9wIC0gYm9yZGVyVG9wV2lkdGgsXG4gICAgbGVmdDogY2hpbGRyZW5SZWN0LmxlZnQgLSBwYXJlbnRSZWN0LmxlZnQgLSBib3JkZXJMZWZ0V2lkdGgsXG4gICAgd2lkdGg6IGNoaWxkcmVuUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IGNoaWxkcmVuUmVjdC5oZWlnaHRcbiAgfSk7XG4gIG9mZnNldHMubWFyZ2luVG9wID0gMDtcbiAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gMDtcblxuICAvLyBTdWJ0cmFjdCBtYXJnaW5zIG9mIGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGl0J3MgYmVpbmcgdXNlZCBhcyBwYXJlbnRcbiAgLy8gd2UgZG8gdGhpcyBvbmx5IG9uIEhUTUwgYmVjYXVzZSBpdCdzIHRoZSBvbmx5IGVsZW1lbnQgdGhhdCBiZWhhdmVzXG4gIC8vIGRpZmZlcmVudGx5IHdoZW4gbWFyZ2lucyBhcmUgYXBwbGllZCB0byBpdC4gVGhlIG1hcmdpbnMgYXJlIGluY2x1ZGVkIGluXG4gIC8vIHRoZSBib3ggb2YgdGhlIGRvY3VtZW50RWxlbWVudCwgaW4gdGhlIG90aGVyIGNhc2VzIG5vdC5cbiAgaWYgKCFpc0lFMTAgJiYgaXNIVE1MKSB7XG4gICAgdmFyIG1hcmdpblRvcCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCwgMTApO1xuICAgIHZhciBtYXJnaW5MZWZ0ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCwgMTApO1xuXG4gICAgb2Zmc2V0cy50b3AgLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5ib3R0b20gLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5sZWZ0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG4gICAgb2Zmc2V0cy5yaWdodCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuXG4gICAgLy8gQXR0YWNoIG1hcmdpblRvcCBhbmQgbWFyZ2luTGVmdCBiZWNhdXNlIGluIHNvbWUgY2lyY3Vtc3RhbmNlcyB3ZSBtYXkgbmVlZCB0aGVtXG4gICAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gbWFyZ2luTGVmdDtcbiAgfVxuXG4gIGlmIChpc0lFMTAgJiYgIWZpeGVkUG9zaXRpb24gPyBwYXJlbnQuY29udGFpbnMoc2Nyb2xsUGFyZW50KSA6IHBhcmVudCA9PT0gc2Nyb2xsUGFyZW50ICYmIHNjcm9sbFBhcmVudC5ub2RlTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgb2Zmc2V0cyA9IGluY2x1ZGVTY3JvbGwob2Zmc2V0cywgcGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUoZWxlbWVudCkge1xuICB2YXIgZXhjbHVkZVNjcm9sbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgcmVsYXRpdmVPZmZzZXQgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoZWxlbWVudCwgaHRtbCk7XG4gIHZhciB3aWR0aCA9IE1hdGgubWF4KGh0bWwuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoaHRtbC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcblxuICB2YXIgc2Nyb2xsVG9wID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCkgOiAwO1xuICB2YXIgc2Nyb2xsTGVmdCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwsICdsZWZ0JykgOiAwO1xuXG4gIHZhciBvZmZzZXQgPSB7XG4gICAgdG9wOiBzY3JvbGxUb3AgLSByZWxhdGl2ZU9mZnNldC50b3AgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5Ub3AsXG4gICAgbGVmdDogc2Nyb2xsTGVmdCAtIHJlbGF0aXZlT2Zmc2V0LmxlZnQgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5MZWZ0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KG9mZnNldCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgZml4ZWQgb3IgaXMgaW5zaWRlIGEgZml4ZWQgcGFyZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gY3VzdG9tQ29udGFpbmVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvIFwiaXNGaXhlZD9cIlxuICovXG5mdW5jdGlvbiBpc0ZpeGVkKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IHBhcmVudCBvZiBhbiBlbGVtZW50IHRoYXQgaGFzIGEgdHJhbnNmb3JtZWQgcHJvcGVydHkgZGVmaW5lZFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gZmlyc3QgdHJhbnNmb3JtZWQgcGFyZW50IG9yIGRvY3VtZW50RWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LnBhcmVudEVsZW1lbnQgfHwgaXNJRSgpKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuICB2YXIgZWwgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIHdoaWxlIChlbCAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWwsICd0cmFuc2Zvcm0nKSA9PT0gJ25vbmUnKSB7XG4gICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBlbCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZWQgdGhlIGJvdW5kYXJpZXMgbGltaXRzIGFuZCByZXR1cm4gdGhlbVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudCAtIEVsZW1lbnQgdXNlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZml4ZWRQb3NpdGlvbiAtIElzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBib3VuZGFyaWVzXG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuXG4gIHZhciBib3VuZGFyaWVzID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgcmVmZXJlbmNlKTtcblxuICAvLyBIYW5kbGUgdmlld3BvcnQgY2FzZVxuICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd2aWV3cG9ydCcpIHtcbiAgICBib3VuZGFyaWVzID0gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKG9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gSGFuZGxlIG90aGVyIGNhc2VzIGJhc2VkIG9uIERPTSBlbGVtZW50IHVzZWQgYXMgYm91bmRhcmllc1xuICAgIHZhciBib3VuZGFyaWVzTm9kZSA9IHZvaWQgMDtcbiAgICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICdzY3JvbGxQYXJlbnQnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKHJlZmVyZW5jZSkpO1xuICAgICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGJvdW5kYXJpZXNFbGVtZW50O1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRzID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGJvdW5kYXJpZXNOb2RlLCBvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuXG4gICAgLy8gSW4gY2FzZSBvZiBIVE1MLCB3ZSBuZWVkIGEgZGlmZmVyZW50IGNvbXB1dGF0aW9uXG4gICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnSFRNTCcgJiYgIWlzRml4ZWQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgdmFyIF9nZXRXaW5kb3dTaXplcyA9IGdldFdpbmRvd1NpemVzKCksXG4gICAgICAgICAgaGVpZ2h0ID0gX2dldFdpbmRvd1NpemVzLmhlaWdodCxcbiAgICAgICAgICB3aWR0aCA9IF9nZXRXaW5kb3dTaXplcy53aWR0aDtcblxuICAgICAgYm91bmRhcmllcy50b3AgKz0gb2Zmc2V0cy50b3AgLSBvZmZzZXRzLm1hcmdpblRvcDtcbiAgICAgIGJvdW5kYXJpZXMuYm90dG9tID0gaGVpZ2h0ICsgb2Zmc2V0cy50b3A7XG4gICAgICBib3VuZGFyaWVzLmxlZnQgKz0gb2Zmc2V0cy5sZWZ0IC0gb2Zmc2V0cy5tYXJnaW5MZWZ0O1xuICAgICAgYm91bmRhcmllcy5yaWdodCA9IHdpZHRoICsgb2Zmc2V0cy5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3IgYWxsIHRoZSBvdGhlciBET00gZWxlbWVudHMsIHRoaXMgb25lIGlzIGdvb2RcbiAgICAgIGJvdW5kYXJpZXMgPSBvZmZzZXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBwYWRkaW5nc1xuICBib3VuZGFyaWVzLmxlZnQgKz0gcGFkZGluZztcbiAgYm91bmRhcmllcy50b3AgKz0gcGFkZGluZztcbiAgYm91bmRhcmllcy5yaWdodCAtPSBwYWRkaW5nO1xuICBib3VuZGFyaWVzLmJvdHRvbSAtPSBwYWRkaW5nO1xuXG4gIHJldHVybiBib3VuZGFyaWVzO1xufVxuXG5mdW5jdGlvbiBnZXRBcmVhKF9yZWYpIHtcbiAgdmFyIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0O1xuXG4gIHJldHVybiB3aWR0aCAqIGhlaWdodDtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBgYXV0b2AgcGxhY2VtZW50IHRvIHRoZSBwbGFjZW1lbnQgd2l0aCBtb3JlXG4gKiBhdmFpbGFibGUgc3BhY2UuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChwbGFjZW1lbnQsIHJlZlJlY3QsIHBvcHBlciwgcmVmZXJlbmNlLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcblxuICBpZiAocGxhY2VtZW50LmluZGV4T2YoJ2F1dG8nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCk7XG5cbiAgdmFyIHJlY3RzID0ge1xuICAgIHRvcDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlZlJlY3QudG9wIC0gYm91bmRhcmllcy50b3BcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy5yaWdodCAtIHJlZlJlY3QucmlnaHQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmJvdHRvbSAtIHJlZlJlY3QuYm90dG9tXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB3aWR0aDogcmVmUmVjdC5sZWZ0IC0gYm91bmRhcmllcy5sZWZ0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH1cbiAgfTtcblxuICB2YXIgc29ydGVkQXJlYXMgPSBPYmplY3Qua2V5cyhyZWN0cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBrZXlcbiAgICB9LCByZWN0c1trZXldLCB7XG4gICAgICBhcmVhOiBnZXRBcmVhKHJlY3RzW2tleV0pXG4gICAgfSk7XG4gIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5hcmVhIC0gYS5hcmVhO1xuICB9KTtcblxuICB2YXIgZmlsdGVyZWRBcmVhcyA9IHNvcnRlZEFyZWFzLmZpbHRlcihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgIHJldHVybiB3aWR0aCA+PSBwb3BwZXIuY2xpZW50V2lkdGggJiYgaGVpZ2h0ID49IHBvcHBlci5jbGllbnRIZWlnaHQ7XG4gIH0pO1xuXG4gIHZhciBjb21wdXRlZFBsYWNlbWVudCA9IGZpbHRlcmVkQXJlYXMubGVuZ3RoID4gMCA/IGZpbHRlcmVkQXJlYXNbMF0ua2V5IDogc29ydGVkQXJlYXNbMF0ua2V5O1xuXG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICByZXR1cm4gY29tcHV0ZWRQbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSByZWZlcmVuY2UgLSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHBhcmFtIHtFbGVtZW50fSBmaXhlZFBvc2l0aW9uIC0gaXMgaW4gZml4ZWQgcG9zaXRpb24gbW9kZVxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgdmFyIGNvbW1vbk9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgcmVmZXJlbmNlKTtcbiAgcmV0dXJuIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShyZWZlcmVuY2UsIGNvbW1vbk9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvdXRlciBzaXplcyBvZiB0aGUgZ2l2ZW4gZWxlbWVudCAob2Zmc2V0IHNpemUgKyBtYXJnaW5zKVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyB3aWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJTaXplcyhlbGVtZW50KSB7XG4gIHZhciBzdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICB2YXIgeCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Cb3R0b20pO1xuICB2YXIgeSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQpICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luUmlnaHQpO1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoICsgeSxcbiAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgeFxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICB2YXIgaGFzaCA9IHsgbGVmdDogJ3JpZ2h0JywgcmlnaHQ6ICdsZWZ0JywgYm90dG9tOiAndG9wJywgdG9wOiAnYm90dG9tJyB9O1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSBDU1MgcG9zaXRpb24gdGhlIFBvcHBlciB3aWxsIGdldCBhcHBsaWVkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzIC0gdGhlIHJlZmVyZW5jZSBvZmZzZXRzICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGFjZW1lbnQgLSBvbmUgb2YgdGhlIHZhbGlkIHBsYWNlbWVudCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UG9wcGVyT2Zmc2V0cyhwb3BwZXIsIHJlZmVyZW5jZU9mZnNldHMsIHBsYWNlbWVudCkge1xuICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICAvLyBHZXQgcG9wcGVyIG5vZGUgc2l6ZXNcbiAgdmFyIHBvcHBlclJlY3QgPSBnZXRPdXRlclNpemVzKHBvcHBlcik7XG5cbiAgLy8gQWRkIHBvc2l0aW9uLCB3aWR0aCBhbmQgaGVpZ2h0IHRvIG91ciBvZmZzZXRzIG9iamVjdFxuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHtcbiAgICB3aWR0aDogcG9wcGVyUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHBvcHBlclJlY3QuaGVpZ2h0XG4gIH07XG5cbiAgLy8gZGVwZW5kaW5nIGJ5IHRoZSBwb3BwZXIgcGxhY2VtZW50IHdlIGhhdmUgdG8gY29tcHV0ZSBpdHMgb2Zmc2V0cyBzbGlnaHRseSBkaWZmZXJlbnRseVxuICB2YXIgaXNIb3JpeiA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBtYWluU2lkZSA9IGlzSG9yaXogPyAndG9wJyA6ICdsZWZ0JztcbiAgdmFyIHNlY29uZGFyeVNpZGUgPSBpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBtZWFzdXJlbWVudCA9IGlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzZWNvbmRhcnlNZWFzdXJlbWVudCA9ICFpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIHBvcHBlck9mZnNldHNbbWFpblNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1ttYWluU2lkZV0gKyByZWZlcmVuY2VPZmZzZXRzW21lYXN1cmVtZW50XSAvIDIgLSBwb3BwZXJSZWN0W21lYXN1cmVtZW50XSAvIDI7XG4gIGlmIChwbGFjZW1lbnQgPT09IHNlY29uZGFyeVNpZGUpIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSAtIHBvcHBlclJlY3Rbc2Vjb25kYXJ5TWVhc3VyZW1lbnRdO1xuICB9IGVsc2Uge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW2dldE9wcG9zaXRlUGxhY2VtZW50KHNlY29uZGFyeVNpZGUpXTtcbiAgfVxuXG4gIHJldHVybiBwb3BwZXJPZmZzZXRzO1xufVxuXG4vKipcbiAqIE1pbWljcyB0aGUgYGZpbmRgIG1ldGhvZCBvZiBBcnJheVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kKGFyciwgY2hlY2spIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kIGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICByZXR1cm4gYXJyLmZpbmQoY2hlY2spO1xuICB9XG5cbiAgLy8gdXNlIGBmaWx0ZXJgIHRvIG9idGFpbiB0aGUgc2FtZSBiZWhhdmlvciBvZiBgZmluZGBcbiAgcmV0dXJuIGFyci5maWx0ZXIoY2hlY2spWzBdO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIG1hdGNoaW5nIG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBwcm9wLCB2YWx1ZSkge1xuICAvLyB1c2UgbmF0aXZlIGZpbmRJbmRleCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpIHtcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChmdW5jdGlvbiAoY3VyKSB7XG4gICAgICByZXR1cm4gY3VyW3Byb3BdID09PSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHVzZSBgZmluZGAgKyBgaW5kZXhPZmAgaWYgYGZpbmRJbmRleGAgaXNuJ3Qgc3VwcG9ydGVkXG4gIHZhciBtYXRjaCA9IGZpbmQoYXJyLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9ialtwcm9wXSA9PT0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gYXJyLmluZGV4T2YobWF0Y2gpO1xufVxuXG4vKipcbiAqIExvb3AgdHJvdWdoIHRoZSBsaXN0IG9mIG1vZGlmaWVycyBhbmQgcnVuIHRoZW0gaW4gb3JkZXIsXG4gKiBlYWNoIG9mIHRoZW0gd2lsbCB0aGVuIGVkaXQgdGhlIGRhdGEgb2JqZWN0LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmRzIC0gT3B0aW9uYWwgbW9kaWZpZXIgbmFtZSB1c2VkIGFzIHN0b3BwZXJcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fVxuICovXG5mdW5jdGlvbiBydW5Nb2RpZmllcnMobW9kaWZpZXJzLCBkYXRhLCBlbmRzKSB7XG4gIHZhciBtb2RpZmllcnNUb1J1biA9IGVuZHMgPT09IHVuZGVmaW5lZCA/IG1vZGlmaWVycyA6IG1vZGlmaWVycy5zbGljZSgwLCBmaW5kSW5kZXgobW9kaWZpZXJzLCAnbmFtZScsIGVuZHMpKTtcblxuICBtb2RpZmllcnNUb1J1bi5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmIChtb2RpZmllclsnZnVuY3Rpb24nXSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgIGNvbnNvbGUud2FybignYG1vZGlmaWVyLmZ1bmN0aW9uYCBpcyBkZXByZWNhdGVkLCB1c2UgYG1vZGlmaWVyLmZuYCEnKTtcbiAgICB9XG4gICAgdmFyIGZuID0gbW9kaWZpZXJbJ2Z1bmN0aW9uJ10gfHwgbW9kaWZpZXIuZm47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgaWYgKG1vZGlmaWVyLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihmbikpIHtcbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIHRvIG9mZnNldHMgdG8gbWFrZSB0aGVtIGEgY29tcGxldGUgY2xpZW50UmVjdCBvYmplY3RcbiAgICAgIC8vIHdlIGRvIHRoaXMgYmVmb3JlIGVhY2ggbW9kaWZpZXIgdG8gbWFrZSBzdXJlIHRoZSBwcmV2aW91cyBvbmUgZG9lc24ndFxuICAgICAgLy8gbWVzcyB3aXRoIHRoZXNlIHZhbHVlc1xuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG4gICAgICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucmVmZXJlbmNlKTtcblxuICAgICAgZGF0YSA9IGZuKGRhdGEsIG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIsIGNvbXB1dGluZyB0aGUgbmV3IG9mZnNldHMgYW5kIGFwcGx5aW5nXG4gKiB0aGUgbmV3IHN0eWxlLjxiciAvPlxuICogUHJlZmVyIGBzY2hlZHVsZVVwZGF0ZWAgb3ZlciBgdXBkYXRlYCBiZWNhdXNlIG9mIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgLy8gaWYgcG9wcGVyIGlzIGRlc3Ryb3llZCwgZG9uJ3QgcGVyZm9ybSBhbnkgZnVydGhlciB1cGRhdGVcbiAgaWYgKHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGF0YSA9IHtcbiAgICBpbnN0YW5jZTogdGhpcyxcbiAgICBzdHlsZXM6IHt9LFxuICAgIGFycm93U3R5bGVzOiB7fSxcbiAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICBmbGlwcGVkOiBmYWxzZSxcbiAgICBvZmZzZXRzOiB7fVxuICB9O1xuXG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyh0aGlzLnN0YXRlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgZGF0YS5wbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudCh0aGlzLm9wdGlvbnMucGxhY2VtZW50LCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIC8vIHN0b3JlIHRoZSBjb21wdXRlZCBwbGFjZW1lbnQgaW5zaWRlIGBvcmlnaW5hbFBsYWNlbWVudGBcbiAgZGF0YS5vcmlnaW5hbFBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuXG4gIGRhdGEucG9zaXRpb25GaXhlZCA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkO1xuXG4gIC8vIGNvbXB1dGUgdGhlIHBvcHBlciBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRQb3BwZXJPZmZzZXRzKHRoaXMucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlci5wb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZSc7XG5cbiAgLy8gcnVuIHRoZSBtb2RpZmllcnNcbiAgZGF0YSA9IHJ1bk1vZGlmaWVycyh0aGlzLm1vZGlmaWVycywgZGF0YSk7XG5cbiAgLy8gdGhlIGZpcnN0IGB1cGRhdGVgIHdpbGwgY2FsbCBgb25DcmVhdGVgIGNhbGxiYWNrXG4gIC8vIHRoZSBvdGhlciBvbmVzIHdpbGwgY2FsbCBgb25VcGRhdGVgIGNhbGxiYWNrXG4gIGlmICghdGhpcy5zdGF0ZS5pc0NyZWF0ZWQpIHtcbiAgICB0aGlzLnN0YXRlLmlzQ3JlYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zLm9uQ3JlYXRlKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZShkYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGlzIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllckVuYWJsZWQobW9kaWZpZXJzLCBtb2RpZmllck5hbWUpIHtcbiAgcmV0dXJuIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgIGVuYWJsZWQgPSBfcmVmLmVuYWJsZWQ7XG4gICAgcmV0dXJuIGVuYWJsZWQgJiYgbmFtZSA9PT0gbW9kaWZpZXJOYW1lO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByZWZpeGVkIHN1cHBvcnRlZCBwcm9wZXJ0eSBuYW1lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHkgKGNhbWVsQ2FzZSlcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHByZWZpeGVkIHByb3BlcnR5IChjYW1lbENhc2Ugb3IgUGFzY2FsQ2FzZSwgZGVwZW5kaW5nIG9uIHRoZSB2ZW5kb3IgcHJlZml4KVxuICovXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUocHJvcGVydHkpIHtcbiAgdmFyIHByZWZpeGVzID0gW2ZhbHNlLCAnbXMnLCAnV2Via2l0JywgJ01veicsICdPJ107XG4gIHZhciB1cHBlclByb3AgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV07XG4gICAgdmFyIHRvQ2hlY2sgPSBwcmVmaXggPyAnJyArIHByZWZpeCArIHVwcGVyUHJvcCA6IHByb3BlcnR5O1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuYm9keS5zdHlsZVt0b0NoZWNrXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0b0NoZWNrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBEZXN0cm95IHRoZSBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgdGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgLy8gdG91Y2ggRE9NIG9ubHkgaWYgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGlzIGVuYWJsZWRcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKHRoaXMubW9kaWZpZXJzLCAnYXBwbHlTdHlsZScpKSB7XG4gICAgdGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnBvc2l0aW9uID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUudG9wID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUubGVmdCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlW2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyldID0gJyc7XG4gIH1cblxuICB0aGlzLmRpc2FibGVFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIHJlbW92ZSB0aGUgcG9wcGVyIGlmIHVzZXIgZXhwbGljaXR5IGFza2VkIGZvciB0aGUgZGVsZXRpb24gb24gZGVzdHJveVxuICAvLyBkbyBub3QgdXNlIGByZW1vdmVgIGJlY2F1c2UgSUUxMSBkb2Vzbid0IHN1cHBvcnQgaXRcbiAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVPbkRlc3Ryb3kpIHtcbiAgICB0aGlzLnBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wcGVyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHdpbmRvdyBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge1dpbmRvd31cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KGVsZW1lbnQpIHtcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHdpbmRvdztcbn1cblxuZnVuY3Rpb24gYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbFBhcmVudCwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKSB7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQubm9kZU5hbWUgPT09ICdCT0RZJztcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IHNjcm9sbFBhcmVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogc2Nyb2xsUGFyZW50O1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICBpZiAoIWlzQm9keSkge1xuICAgIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhnZXRTY3JvbGxQYXJlbnQodGFyZ2V0LnBhcmVudE5vZGUpLCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpO1xuICB9XG4gIHNjcm9sbFBhcmVudHMucHVzaCh0YXJnZXQpO1xufVxuXG4vKipcbiAqIFNldHVwIG5lZWRlZCBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIG9wdGlvbnMsIHN0YXRlLCB1cGRhdGVCb3VuZCkge1xuICAvLyBSZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gdXBkYXRlQm91bmQ7XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgLy8gU2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHZhciBzY3JvbGxFbGVtZW50ID0gZ2V0U2Nyb2xsUGFyZW50KHJlZmVyZW5jZSk7XG4gIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxFbGVtZW50LCAnc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQsIHN0YXRlLnNjcm9sbFBhcmVudHMpO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IHRydWU7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgYWRkIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCBzdGFydCByZWNhbGN1bGF0aW5nXG4gKiBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAoIXRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIHRoaXMuc3RhdGUgPSBzZXR1cEV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMsIHRoaXMuc3RhdGUsIHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIHN0YXRlKSB7XG4gIC8vIFJlbW92ZSByZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcblxuICAvLyBSZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHN0YXRlLnNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgc3RhdGVcbiAgc3RhdGUudXBkYXRlQm91bmQgPSBudWxsO1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0gW107XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gZmFsc2U7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIHJlbW92ZSByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgd29uJ3QgcmVjYWxjdWxhdGUgcG9wcGVyIHBvc2l0aW9uXG4gKiB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC4gSXQgYWxzbyB3b24ndCB0cmlnZ2VyIG9uVXBkYXRlIGNhbGxiYWNrIGFueW1vcmUsXG4gKiB1bmxlc3MgeW91IGNhbGwgYHVwZGF0ZWAgbWV0aG9kIG1hbnVhbGx5LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgICB0aGlzLnN0YXRlID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMuc3RhdGUpO1xuICB9XG59XG5cbi8qKlxuICogVGVsbHMgaWYgYSBnaXZlbiBpbnB1dCBpcyBhIG51bWJlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHsqfSBpbnB1dCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcbiAgcmV0dXJuIG4gIT09ICcnICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHN0eWxlIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHN0eWxlIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRTdHlsZXMoZWxlbWVudCwgc3R5bGVzKSB7XG4gIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB1bml0ID0gJyc7XG4gICAgLy8gYWRkIHVuaXQgaWYgdGhlIHZhbHVlIGlzIG51bWVyaWMgYW5kIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nXG4gICAgaWYgKFsnd2lkdGgnLCAnaGVpZ2h0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLmluZGV4T2YocHJvcCkgIT09IC0xICYmIGlzTnVtZXJpYyhzdHlsZXNbcHJvcF0pKSB7XG4gICAgICB1bml0ID0gJ3B4JztcbiAgICB9XG4gICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXSArIHVuaXQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgYXR0cmlidXRlcyB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBhdHRyaWJ1dGVzIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUocHJvcCwgYXR0cmlidXRlc1twcm9wXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5zdHlsZXMgLSBMaXN0IG9mIHN0eWxlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLmF0dHJpYnV0ZXMgLSBMaXN0IG9mIGF0dHJpYnV0ZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc2FtZSBkYXRhIG9iamVjdFxuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlKGRhdGEpIHtcbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuc3R5bGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gaW4gdGhpcyB3YXkgd2UgY2FuIG1ha2UgdGhlIDNyZCBwYXJ0eSBtb2RpZmllcnMgYWRkIGN1c3RvbSBzdHlsZXMgdG8gaXRcbiAgLy8gQmUgYXdhcmUsIG1vZGlmaWVycyBjb3VsZCBvdmVycmlkZSB0aGUgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoZSBwcmV2aW91c1xuICAvLyBsaW5lcyBvZiB0aGlzIG1vZGlmaWVyIVxuICBzZXRTdHlsZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuc3R5bGVzKTtcblxuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5hdHRyaWJ1dGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gdGhleSB3aWxsIGJlIHNldCBhcyBIVE1MIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnRcbiAgc2V0QXR0cmlidXRlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5hdHRyaWJ1dGVzKTtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgZGVmaW5lZCBhbmQgYXJyb3dTdHlsZXMgaGFzIHNvbWUgcHJvcGVydGllc1xuICBpZiAoZGF0YS5hcnJvd0VsZW1lbnQgJiYgT2JqZWN0LmtleXMoZGF0YS5hcnJvd1N0eWxlcykubGVuZ3RoKSB7XG4gICAgc2V0U3R5bGVzKGRhdGEuYXJyb3dFbGVtZW50LCBkYXRhLmFycm93U3R5bGVzKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFNldCB0aGUgeC1wbGFjZW1lbnQgYXR0cmlidXRlIGJlZm9yZSBldmVyeXRoaW5nIGVsc2UgYmVjYXVzZSBpdCBjb3VsZCBiZSB1c2VkXG4gKiB0byBhZGQgbWFyZ2lucyB0byB0aGUgcG9wcGVyIG1hcmdpbnMgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZCB0byBnZXQgdGhlXG4gKiBjb3JyZWN0IHBvcHBlciBvZmZzZXRzLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5tb2RpZmllcnNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUG9wcGVyLmpzIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZU9uTG9hZChyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBzdGF0ZSkge1xuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgdmFyIHJlZmVyZW5jZU9mZnNldHMgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgdmFyIHBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KG9wdGlvbnMucGxhY2VtZW50LCByZWZlcmVuY2VPZmZzZXRzLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICBwb3BwZXIuc2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcsIHBsYWNlbWVudCk7XG5cbiAgLy8gQXBwbHkgYHBvc2l0aW9uYCB0byBwb3BwZXIgYmVmb3JlIGFueXRoaW5nIGVsc2UgYmVjYXVzZVxuICAvLyB3aXRob3V0IHRoZSBwb3NpdGlvbiBhcHBsaWVkIHdlIGNhbid0IGd1YXJhbnRlZSBjb3JyZWN0IGNvbXB1dGF0aW9uc1xuICBzZXRTdHlsZXMocG9wcGVyLCB7IHBvc2l0aW9uOiBvcHRpb25zLnBvc2l0aW9uRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJyB9KTtcblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVN0eWxlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIHggPSBvcHRpb25zLngsXG4gICAgICB5ID0gb3B0aW9ucy55O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICAvLyBSZW1vdmUgdGhpcyBsZWdhY3kgc3VwcG9ydCBpbiBQb3BwZXIuanMgdjJcblxuICB2YXIgbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdhcHBseVN0eWxlJztcbiAgfSkuZ3B1QWNjZWxlcmF0aW9uO1xuICBpZiAobGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBncHVBY2NlbGVyYXRpb25gIG9wdGlvbiBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllciBhbmQgd2lsbCBub3QgYmUgc3VwcG9ydGVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBQb3BwZXIuanMhJyk7XG4gIH1cbiAgdmFyIGdwdUFjY2VsZXJhdGlvbiA9IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkID8gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uIDogb3B0aW9ucy5ncHVBY2NlbGVyYXRpb247XG5cbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBvZmZzZXRQYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG5cbiAgLy8gU3R5bGVzXG4gIHZhciBzdHlsZXMgPSB7XG4gICAgcG9zaXRpb246IHBvcHBlci5wb3NpdGlvblxuICB9O1xuXG4gIC8vIEF2b2lkIGJsdXJyeSB0ZXh0IGJ5IHVzaW5nIGZ1bGwgcGl4ZWwgaW50ZWdlcnMuXG4gIC8vIEZvciBwaXhlbC1wZXJmZWN0IHBvc2l0aW9uaW5nLCB0b3AvYm90dG9tIHByZWZlcnMgcm91bmRlZFxuICAvLyB2YWx1ZXMsIHdoaWxlIGxlZnQvcmlnaHQgcHJlZmVycyBmbG9vcmVkIHZhbHVlcy5cbiAgdmFyIG9mZnNldHMgPSB7XG4gICAgbGVmdDogTWF0aC5mbG9vcihwb3BwZXIubGVmdCksXG4gICAgdG9wOiBNYXRoLnJvdW5kKHBvcHBlci50b3ApLFxuICAgIGJvdHRvbTogTWF0aC5yb3VuZChwb3BwZXIuYm90dG9tKSxcbiAgICByaWdodDogTWF0aC5mbG9vcihwb3BwZXIucmlnaHQpXG4gIH07XG5cbiAgdmFyIHNpZGVBID0geCA9PT0gJ2JvdHRvbScgPyAndG9wJyA6ICdib3R0b20nO1xuICB2YXIgc2lkZUIgPSB5ID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcblxuICAvLyBpZiBncHVBY2NlbGVyYXRpb24gaXMgc2V0IHRvIGB0cnVlYCBhbmQgdHJhbnNmb3JtIGlzIHN1cHBvcnRlZCxcbiAgLy8gIHdlIHVzZSBgdHJhbnNsYXRlM2RgIHRvIGFwcGx5IHRoZSBwb3NpdGlvbiB0byB0aGUgcG9wcGVyIHdlXG4gIC8vIGF1dG9tYXRpY2FsbHkgdXNlIHRoZSBzdXBwb3J0ZWQgcHJlZml4ZWQgdmVyc2lvbiBpZiBuZWVkZWRcbiAgdmFyIHByZWZpeGVkUHJvcGVydHkgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuXG4gIC8vIG5vdywgbGV0J3MgbWFrZSBhIHN0ZXAgYmFjayBhbmQgbG9vayBhdCB0aGlzIGNvZGUgY2xvc2VseSAod3RmPylcbiAgLy8gSWYgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHBlciBncm93cyBvbmNlIGl0J3MgYmVlbiBwb3NpdGlvbmVkLCBpdFxuICAvLyBtYXkgaGFwcGVuIHRoYXQgdGhlIHBvcHBlciBnZXRzIG1pc3BsYWNlZCBiZWNhdXNlIG9mIHRoZSBuZXcgY29udGVudFxuICAvLyBvdmVyZmxvd2luZyBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVG8gYXZvaWQgdGhpcyBwcm9ibGVtLCB3ZSBwcm92aWRlIHR3byBvcHRpb25zICh4IGFuZCB5KSwgd2hpY2ggYWxsb3dcbiAgLy8gdGhlIGNvbnN1bWVyIHRvIGRlZmluZSB0aGUgb2Zmc2V0IG9yaWdpbi5cbiAgLy8gSWYgd2UgcG9zaXRpb24gYSBwb3BwZXIgb24gdG9wIG9mIGEgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIGNhbiBzZXRcbiAgLy8gYHhgIHRvIGB0b3BgIHRvIG1ha2UgdGhlIHBvcHBlciBncm93IHRvd2FyZHMgaXRzIHRvcCBpbnN0ZWFkIG9mXG4gIC8vIGl0cyBib3R0b20uXG4gIHZhciBsZWZ0ID0gdm9pZCAwLFxuICAgICAgdG9wID0gdm9pZCAwO1xuICBpZiAoc2lkZUEgPT09ICdib3R0b20nKSB7XG4gICAgdG9wID0gLW9mZnNldFBhcmVudFJlY3QuaGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gb2Zmc2V0cy50b3A7XG4gIH1cbiAgaWYgKHNpZGVCID09PSAncmlnaHQnKSB7XG4gICAgbGVmdCA9IC1vZmZzZXRQYXJlbnRSZWN0LndpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgfSBlbHNlIHtcbiAgICBsZWZ0ID0gb2Zmc2V0cy5sZWZ0O1xuICB9XG4gIGlmIChncHVBY2NlbGVyYXRpb24gJiYgcHJlZml4ZWRQcm9wZXJ0eSkge1xuICAgIHN0eWxlc1twcmVmaXhlZFByb3BlcnR5XSA9ICd0cmFuc2xhdGUzZCgnICsgbGVmdCArICdweCwgJyArIHRvcCArICdweCwgMCknO1xuICAgIHN0eWxlc1tzaWRlQV0gPSAwO1xuICAgIHN0eWxlc1tzaWRlQl0gPSAwO1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3Rod2VyaXNlLCB3ZSB1c2UgdGhlIHN0YW5kYXJkIGB0b3BgLCBgbGVmdGAsIGBib3R0b21gIGFuZCBgcmlnaHRgIHByb3BlcnRpZXNcbiAgICB2YXIgaW52ZXJ0VG9wID0gc2lkZUEgPT09ICdib3R0b20nID8gLTEgOiAxO1xuICAgIHZhciBpbnZlcnRMZWZ0ID0gc2lkZUIgPT09ICdyaWdodCcgPyAtMSA6IDE7XG4gICAgc3R5bGVzW3NpZGVBXSA9IHRvcCAqIGludmVydFRvcDtcbiAgICBzdHlsZXNbc2lkZUJdID0gbGVmdCAqIGludmVydExlZnQ7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSBzaWRlQSArICcsICcgKyBzaWRlQjtcbiAgfVxuXG4gIC8vIEF0dHJpYnV0ZXNcbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ3gtcGxhY2VtZW50JzogZGF0YS5wbGFjZW1lbnRcbiAgfTtcblxuICAvLyBVcGRhdGUgYGRhdGFgIGF0dHJpYnV0ZXMsIHN0eWxlcyBhbmQgYXJyb3dTdHlsZXNcbiAgZGF0YS5hdHRyaWJ1dGVzID0gX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIGRhdGEuYXR0cmlidXRlcyk7XG4gIGRhdGEuc3R5bGVzID0gX2V4dGVuZHMoe30sIHN0eWxlcywgZGF0YS5zdHlsZXMpO1xuICBkYXRhLmFycm93U3R5bGVzID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5hcnJvdywgZGF0YS5hcnJvd1N0eWxlcyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgZGVwZW5kcyBmcm9tIGFub3RoZXIgb25lLjxiciAvPlxuICogSXQgY2hlY2tzIGlmIHRoZSBuZWVkZWQgbW9kaWZpZXIgaXMgbGlzdGVkIGFuZCBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzIC0gbGlzdCBvZiBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0aW5nTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGluZyBtb2RpZmllclxuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RlZE5hbWUgLSBuYW1lIG9mIHJlcXVlc3RlZCBtb2RpZmllclxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJSZXF1aXJlZChtb2RpZmllcnMsIHJlcXVlc3RpbmdOYW1lLCByZXF1ZXN0ZWROYW1lKSB7XG4gIHZhciByZXF1ZXN0aW5nID0gZmluZChtb2RpZmllcnMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgcmV0dXJuIG5hbWUgPT09IHJlcXVlc3RpbmdOYW1lO1xuICB9KTtcblxuICB2YXIgaXNSZXF1aXJlZCA9ICEhcmVxdWVzdGluZyAmJiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gcmVxdWVzdGVkTmFtZSAmJiBtb2RpZmllci5lbmFibGVkICYmIG1vZGlmaWVyLm9yZGVyIDwgcmVxdWVzdGluZy5vcmRlcjtcbiAgfSk7XG5cbiAgaWYgKCFpc1JlcXVpcmVkKSB7XG4gICAgdmFyIF9yZXF1ZXN0aW5nID0gJ2AnICsgcmVxdWVzdGluZ05hbWUgKyAnYCc7XG4gICAgdmFyIHJlcXVlc3RlZCA9ICdgJyArIHJlcXVlc3RlZE5hbWUgKyAnYCc7XG4gICAgY29uc29sZS53YXJuKHJlcXVlc3RlZCArICcgbW9kaWZpZXIgaXMgcmVxdWlyZWQgYnkgJyArIF9yZXF1ZXN0aW5nICsgJyBtb2RpZmllciBpbiBvcmRlciB0byB3b3JrLCBiZSBzdXJlIHRvIGluY2x1ZGUgaXQgYmVmb3JlICcgKyBfcmVxdWVzdGluZyArICchJyk7XG4gIH1cbiAgcmV0dXJuIGlzUmVxdWlyZWQ7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBhcnJvdyhkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzJGFycm93O1xuXG4gIC8vIGFycm93IGRlcGVuZHMgb24ga2VlcFRvZ2V0aGVyIGluIG9yZGVyIHRvIHdvcmtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdhcnJvdycsICdrZWVwVG9nZXRoZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGFycm93RWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgYSBzdHJpbmcsIHN1cHBvc2UgaXQncyBhIENTUyBzZWxlY3RvclxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgbm90IGZvdW5kLCBkb24ndCBydW4gdGhlIG1vZGlmaWVyXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpZiB0aGUgYXJyb3dFbGVtZW50IGlzbid0IGEgcXVlcnkgc2VsZWN0b3Igd2UgbXVzdCBjaGVjayB0aGF0IHRoZVxuICAgIC8vIHByb3ZpZGVkIERPTSBub2RlIGlzIGNoaWxkIG9mIGl0cyBwb3BwZXIgbm9kZVxuICAgIGlmICghZGF0YS5pbnN0YW5jZS5wb3BwZXIuY29udGFpbnMoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgYXJyb3cuZWxlbWVudGAgbXVzdCBiZSBjaGlsZCBvZiBpdHMgcG9wcGVyIGVsZW1lbnQhJyk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNpZGVDYXBpdGFsaXplZCA9IGlzVmVydGljYWwgPyAnVG9wJyA6ICdMZWZ0JztcbiAgdmFyIHNpZGUgPSBzaWRlQ2FwaXRhbGl6ZWQudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGFsdFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICB2YXIgYXJyb3dFbGVtZW50U2l6ZSA9IGdldE91dGVyU2l6ZXMoYXJyb3dFbGVtZW50KVtsZW5dO1xuXG4gIC8vXG4gIC8vIGV4dGVuZHMga2VlcFRvZ2V0aGVyIGJlaGF2aW9yIG1ha2luZyBzdXJlIHRoZSBwb3BwZXIgYW5kIGl0c1xuICAvLyByZWZlcmVuY2UgaGF2ZSBlbm91Z2ggcGl4ZWxzIGluIGNvbmp1Y3Rpb25cbiAgLy9cblxuICAvLyB0b3AvbGVmdCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUgPCBwb3BwZXJbc2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC09IHBvcHBlcltzaWRlXSAtIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUpO1xuICB9XG4gIC8vIGJvdHRvbS9yaWdodCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplID4gcG9wcGVyW29wU2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdICs9IHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgLSBwb3BwZXJbb3BTaWRlXTtcbiAgfVxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcblxuICAvLyBjb21wdXRlIGNlbnRlciBvZiB0aGUgcG9wcGVyXG4gIHZhciBjZW50ZXIgPSByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbGVuXSAvIDIgLSBhcnJvd0VsZW1lbnRTaXplIC8gMjtcblxuICAvLyBDb21wdXRlIHRoZSBzaWRlVmFsdWUgdXNpbmcgdGhlIHVwZGF0ZWQgcG9wcGVyIG9mZnNldHNcbiAgLy8gdGFrZSBwb3BwZXIgbWFyZ2luIGluIGFjY291bnQgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHRoaXMgaW5mbyBhdmFpbGFibGVcbiAgdmFyIGNzcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBwb3BwZXJNYXJnaW5TaWRlID0gcGFyc2VGbG9hdChjc3NbJ21hcmdpbicgKyBzaWRlQ2FwaXRhbGl6ZWRdLCAxMCk7XG4gIHZhciBwb3BwZXJCb3JkZXJTaWRlID0gcGFyc2VGbG9hdChjc3NbJ2JvcmRlcicgKyBzaWRlQ2FwaXRhbGl6ZWQgKyAnV2lkdGgnXSwgMTApO1xuICB2YXIgc2lkZVZhbHVlID0gY2VudGVyIC0gZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtIHBvcHBlck1hcmdpblNpZGUgLSBwb3BwZXJCb3JkZXJTaWRlO1xuXG4gIC8vIHByZXZlbnQgYXJyb3dFbGVtZW50IGZyb20gYmVpbmcgcGxhY2VkIG5vdCBjb250aWd1b3VzbHkgdG8gaXRzIHBvcHBlclxuICBzaWRlVmFsdWUgPSBNYXRoLm1heChNYXRoLm1pbihwb3BwZXJbbGVuXSAtIGFycm93RWxlbWVudFNpemUsIHNpZGVWYWx1ZSksIDApO1xuXG4gIGRhdGEuYXJyb3dFbGVtZW50ID0gYXJyb3dFbGVtZW50O1xuICBkYXRhLm9mZnNldHMuYXJyb3cgPSAoX2RhdGEkb2Zmc2V0cyRhcnJvdyA9IHt9LCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBzaWRlLCBNYXRoLnJvdW5kKHNpZGVWYWx1ZSkpLCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBhbHRTaWRlLCAnJyksIF9kYXRhJG9mZnNldHMkYXJyb3cpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IHZhcmlhdGlvbiBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IHZhcmlhdGlvblxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uKHZhcmlhdGlvbikge1xuICBpZiAodmFyaWF0aW9uID09PSAnZW5kJykge1xuICAgIHJldHVybiAnc3RhcnQnO1xuICB9IGVsc2UgaWYgKHZhcmlhdGlvbiA9PT0gJ3N0YXJ0Jykge1xuICAgIHJldHVybiAnZW5kJztcbiAgfVxuICByZXR1cm4gdmFyaWF0aW9uO1xufVxuXG4vKipcbiAqIExpc3Qgb2YgYWNjZXB0ZWQgcGxhY2VtZW50cyB0byB1c2UgYXMgdmFsdWVzIG9mIHRoZSBgcGxhY2VtZW50YCBvcHRpb24uPGJyIC8+XG4gKiBWYWxpZCBwbGFjZW1lbnRzIGFyZTpcbiAqIC0gYGF1dG9gXG4gKiAtIGB0b3BgXG4gKiAtIGByaWdodGBcbiAqIC0gYGJvdHRvbWBcbiAqIC0gYGxlZnRgXG4gKlxuICogRWFjaCBwbGFjZW1lbnQgY2FuIGhhdmUgYSB2YXJpYXRpb24gZnJvbSB0aGlzIGxpc3Q6XG4gKiAtIGAtc3RhcnRgXG4gKiAtIGAtZW5kYFxuICpcbiAqIFZhcmlhdGlvbnMgYXJlIGludGVycHJldGVkIGVhc2lseSBpZiB5b3UgdGhpbmsgb2YgdGhlbSBhcyB0aGUgbGVmdCB0byByaWdodFxuICogd3JpdHRlbiBsYW5ndWFnZXMuIEhvcml6b250YWxseSAoYHRvcGAgYW5kIGBib3R0b21gKSwgYHN0YXJ0YCBpcyBsZWZ0IGFuZCBgZW5kYFxuICogaXMgcmlnaHQuPGJyIC8+XG4gKiBWZXJ0aWNhbGx5IChgbGVmdGAgYW5kIGByaWdodGApLCBgc3RhcnRgIGlzIHRvcCBhbmQgYGVuZGAgaXMgYm90dG9tLlxuICpcbiAqIFNvbWUgdmFsaWQgZXhhbXBsZXMgYXJlOlxuICogLSBgdG9wLWVuZGAgKG9uIHRvcCBvZiByZWZlcmVuY2UsIHJpZ2h0IGFsaWduZWQpXG4gKiAtIGByaWdodC1zdGFydGAgKG9uIHJpZ2h0IG9mIHJlZmVyZW5jZSwgdG9wIGFsaWduZWQpXG4gKiAtIGBib3R0b21gIChvbiBib3R0b20sIGNlbnRlcmVkKVxuICogLSBgYXV0by1yaWdodGAgKG9uIHRoZSBzaWRlIHdpdGggbW9yZSBzcGFjZSBhdmFpbGFibGUsIGFsaWdubWVudCBkZXBlbmRzIGJ5IHBsYWNlbWVudClcbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAZW51bSB7U3RyaW5nfVxuICogQHJlYWRvbmx5XG4gKiBAbWV0aG9kIHBsYWNlbWVudHNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIHBsYWNlbWVudHMgPSBbJ2F1dG8tc3RhcnQnLCAnYXV0bycsICdhdXRvLWVuZCcsICd0b3Atc3RhcnQnLCAndG9wJywgJ3RvcC1lbmQnLCAncmlnaHQtc3RhcnQnLCAncmlnaHQnLCAncmlnaHQtZW5kJywgJ2JvdHRvbS1lbmQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdsZWZ0LWVuZCcsICdsZWZ0JywgJ2xlZnQtc3RhcnQnXTtcblxuLy8gR2V0IHJpZCBvZiBgYXV0b2AgYGF1dG8tc3RhcnRgIGFuZCBgYXV0by1lbmRgXG52YXIgdmFsaWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5zbGljZSgzKTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbml0aWFsIHBsYWNlbWVudCwgcmV0dXJucyBhbGwgdGhlIHN1YnNlcXVlbnQgcGxhY2VtZW50c1xuICogY2xvY2t3aXNlIChvciBjb3VudGVyLWNsb2Nrd2lzZSkuXG4gKlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCAtIEEgdmFsaWQgcGxhY2VtZW50IChpdCBhY2NlcHRzIHZhcmlhdGlvbnMpXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IGNvdW50ZXIgLSBTZXQgdG8gdHJ1ZSB0byB3YWxrIHRoZSBwbGFjZW1lbnRzIGNvdW50ZXJjbG9ja3dpc2VcbiAqIEByZXR1cm5zIHtBcnJheX0gcGxhY2VtZW50cyBpbmNsdWRpbmcgdGhlaXIgdmFyaWF0aW9uc1xuICovXG5mdW5jdGlvbiBjbG9ja3dpc2UocGxhY2VtZW50KSB7XG4gIHZhciBjb3VudGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaW5kZXggPSB2YWxpZFBsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpO1xuICB2YXIgYXJyID0gdmFsaWRQbGFjZW1lbnRzLnNsaWNlKGluZGV4ICsgMSkuY29uY2F0KHZhbGlkUGxhY2VtZW50cy5zbGljZSgwLCBpbmRleCkpO1xuICByZXR1cm4gY291bnRlciA/IGFyci5yZXZlcnNlKCkgOiBhcnI7XG59XG5cbnZhciBCRUhBVklPUlMgPSB7XG4gIEZMSVA6ICdmbGlwJyxcbiAgQ0xPQ0tXSVNFOiAnY2xvY2t3aXNlJyxcbiAgQ09VTlRFUkNMT0NLV0lTRTogJ2NvdW50ZXJjbG9ja3dpc2UnXG59O1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gZmxpcChkYXRhLCBvcHRpb25zKSB7XG4gIC8vIGlmIGBpbm5lcmAgbW9kaWZpZXIgaXMgZW5hYmxlZCwgd2UgY2FuJ3QgdXNlIHRoZSBgZmxpcGAgbW9kaWZpZXJcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaW5uZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgaWYgKGRhdGEuZmxpcHBlZCAmJiBkYXRhLnBsYWNlbWVudCA9PT0gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCkge1xuICAgIC8vIHNlZW1zIGxpa2UgZmxpcCBpcyB0cnlpbmcgdG8gbG9vcCwgcHJvYmFibHkgdGhlcmUncyBub3QgZW5vdWdoIHNwYWNlIG9uIGFueSBvZiB0aGUgZmxpcHBhYmxlIHNpZGVzXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQsIGRhdGEucG9zaXRpb25GaXhlZCk7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzFdIHx8ICcnO1xuXG4gIHZhciBmbGlwT3JkZXIgPSBbXTtcblxuICBzd2l0Y2ggKG9wdGlvbnMuYmVoYXZpb3IpIHtcbiAgICBjYXNlIEJFSEFWSU9SUy5GTElQOlxuICAgICAgZmxpcE9yZGVyID0gW3BsYWNlbWVudCwgcGxhY2VtZW50T3Bwb3NpdGVdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DT1VOVEVSQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCwgdHJ1ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZmxpcE9yZGVyID0gb3B0aW9ucy5iZWhhdmlvcjtcbiAgfVxuXG4gIGZsaXBPcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChzdGVwLCBpbmRleCkge1xuICAgIGlmIChwbGFjZW1lbnQgIT09IHN0ZXAgfHwgZmxpcE9yZGVyLmxlbmd0aCA9PT0gaW5kZXggKyAxKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBwb3BwZXJPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcbiAgICB2YXIgcmVmT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgICAvLyB1c2luZyBmbG9vciBiZWNhdXNlIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyBtYXkgY29udGFpbiBkZWNpbWFscyB3ZSBhcmUgbm90IGdvaW5nIHRvIGNvbnNpZGVyIGhlcmVcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBvdmVybGFwc1JlZiA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IocmVmT2Zmc2V0cy5sZWZ0KSB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKHJlZk9mZnNldHMucmlnaHQpIHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IocmVmT2Zmc2V0cy50b3ApIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IocmVmT2Zmc2V0cy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0xlZnQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IoYm91bmRhcmllcy5sZWZ0KTtcbiAgICB2YXIgb3ZlcmZsb3dzUmlnaHQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKGJvdW5kYXJpZXMucmlnaHQpO1xuICAgIHZhciBvdmVyZmxvd3NUb3AgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihib3VuZGFyaWVzLnRvcCk7XG4gICAgdmFyIG92ZXJmbG93c0JvdHRvbSA9IGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKGJvdW5kYXJpZXMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NCb3VuZGFyaWVzID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBvdmVyZmxvd3NUb3AgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBvdmVyZmxvd3NCb3R0b207XG5cbiAgICAvLyBmbGlwIHRoZSB2YXJpYXRpb24gaWYgcmVxdWlyZWRcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb24gPSAhIW9wdGlvbnMuZmxpcFZhcmlhdGlvbnMgJiYgKGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c0xlZnQgfHwgaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1JpZ2h0IHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NUb3AgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NCb3R0b20pO1xuXG4gICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMgfHwgZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgLy8gdGhpcyBib29sZWFuIHRvIGRldGVjdCBhbnkgZmxpcCBsb29wXG4gICAgICBkYXRhLmZsaXBwZWQgPSB0cnVlO1xuXG4gICAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcykge1xuICAgICAgICBwbGFjZW1lbnQgPSBmbGlwT3JkZXJbaW5kZXggKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgICAgdmFyaWF0aW9uID0gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5wbGFjZW1lbnQgPSBwbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xuXG4gICAgICAvLyB0aGlzIG9iamVjdCBjb250YWlucyBgcG9zaXRpb25gLCB3ZSB3YW50IHRvIHByZXNlcnZlIGl0IGFsb25nIHdpdGhcbiAgICAgIC8vIGFueSBhZGRpdGlvbmFsIHByb3BlcnR5IHdlIG1heSBhZGQgaW4gdGhlIGZ1dHVyZVxuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMucG9wcGVyLCBnZXRQb3BwZXJPZmZzZXRzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCkpO1xuXG4gICAgICBkYXRhID0gcnVuTW9kaWZpZXJzKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBkYXRhLCAnZmxpcCcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24ga2VlcFRvZ2V0aGVyKGRhdGEpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdyaWdodCcgOiAnYm90dG9tJztcbiAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICBpZiAocG9wcGVyW3NpZGVdIDwgZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pIC0gcG9wcGVyW21lYXN1cmVtZW50XTtcbiAgfVxuICBpZiAocG9wcGVyW29wU2lkZV0gPiBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW3NpZGVdKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGNvbnRhaW5pbmcgdmFsdWUgKyB1bml0IGludG8gYSBweCB2YWx1ZSBudW1iZXJcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzdHIgLSBWYWx1ZSArIHVuaXQgc3RyaW5nXG4gKiBAYXJndW1lbnQge1N0cmluZ30gbWVhc3VyZW1lbnQgLSBgaGVpZ2h0YCBvciBgd2lkdGhgXG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEByZXR1cm5zIHtOdW1iZXJ8U3RyaW5nfVxuICogVmFsdWUgaW4gcGl4ZWxzLCBvciBvcmlnaW5hbCBzdHJpbmcgaWYgbm8gdmFsdWVzIHdlcmUgZXh0cmFjdGVkXG4gKi9cbmZ1bmN0aW9uIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cykge1xuICAvLyBzZXBhcmF0ZSB2YWx1ZSBmcm9tIHVuaXRcbiAgdmFyIHNwbGl0ID0gc3RyLm1hdGNoKC8oKD86XFwtfFxcKyk/XFxkKlxcLj9cXGQqKSguKikvKTtcbiAgdmFyIHZhbHVlID0gK3NwbGl0WzFdO1xuICB2YXIgdW5pdCA9IHNwbGl0WzJdO1xuXG4gIC8vIElmIGl0J3Mgbm90IGEgbnVtYmVyIGl0J3MgYW4gb3BlcmF0b3IsIEkgZ3Vlc3NcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBpZiAodW5pdC5pbmRleE9mKCclJykgPT09IDApIHtcbiAgICB2YXIgZWxlbWVudCA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgIGNhc2UgJyVwJzpcbiAgICAgICAgZWxlbWVudCA9IHBvcHBlck9mZnNldHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnJSc6XG4gICAgICBjYXNlICclcic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBlbGVtZW50ID0gcmVmZXJlbmNlT2Zmc2V0cztcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3QoZWxlbWVudCk7XG4gICAgcmV0dXJuIHJlY3RbbWVhc3VyZW1lbnRdIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3ZoJyB8fCB1bml0ID09PSAndncnKSB7XG4gICAgLy8gaWYgaXMgYSB2aCBvciB2dywgd2UgY2FsY3VsYXRlIHRoZSBzaXplIGJhc2VkIG9uIHRoZSB2aWV3cG9ydFxuICAgIHZhciBzaXplID0gdm9pZCAwO1xuICAgIGlmICh1bml0ID09PSAndmgnKSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemUgLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBpcyBhbiBleHBsaWNpdCBwaXhlbCB1bml0LCB3ZSBnZXQgcmlkIG9mIHRoZSB1bml0IGFuZCBrZWVwIHRoZSB2YWx1ZVxuICAgIC8vIGlmIGlzIGFuIGltcGxpY2l0IHVuaXQsIGl0J3MgcHgsIGFuZCB3ZSByZXR1cm4ganVzdCB0aGUgdmFsdWVcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBgb2Zmc2V0YCBzdHJpbmcgdG8gZXh0cmFwb2xhdGUgYHhgIGFuZCBgeWAgbnVtZXJpYyBvZmZzZXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IG9mZnNldFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gYmFzZVBsYWNlbWVudFxuICogQHJldHVybnMge0FycmF5fSBhIHR3byBjZWxscyBhcnJheSB3aXRoIHggYW5kIHkgb2Zmc2V0cyBpbiBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cywgYmFzZVBsYWNlbWVudCkge1xuICB2YXIgb2Zmc2V0cyA9IFswLCAwXTtcblxuICAvLyBVc2UgaGVpZ2h0IGlmIHBsYWNlbWVudCBpcyBsZWZ0IG9yIHJpZ2h0IGFuZCBpbmRleCBpcyAwIG90aGVyd2lzZSB1c2Ugd2lkdGhcbiAgLy8gaW4gdGhpcyB3YXkgdGhlIGZpcnN0IG9mZnNldCB3aWxsIHVzZSBhbiBheGlzIGFuZCB0aGUgc2Vjb25kIG9uZVxuICAvLyB3aWxsIHVzZSB0aGUgb3RoZXIgb25lXG4gIHZhciB1c2VIZWlnaHQgPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAvLyBTcGxpdCB0aGUgb2Zmc2V0IHN0cmluZyB0byBvYnRhaW4gYSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHNcbiAgLy8gVGhlIHJlZ2V4IGFkZHJlc3NlcyB2YWx1ZXMgd2l0aCB0aGUgcGx1cyBvciBtaW51cyBzaWduIGluIGZyb250ICgrMTAsIC0yMCwgZXRjKVxuICB2YXIgZnJhZ21lbnRzID0gb2Zmc2V0LnNwbGl0KC8oXFwrfFxcLSkvKS5tYXAoZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy50cmltKCk7XG4gIH0pO1xuXG4gIC8vIERldGVjdCBpZiB0aGUgb2Zmc2V0IHN0cmluZyBjb250YWlucyBhIHBhaXIgb2YgdmFsdWVzIG9yIGEgc2luZ2xlIG9uZVxuICAvLyB0aGV5IGNvdWxkIGJlIHNlcGFyYXRlZCBieSBjb21tYSBvciBzcGFjZVxuICB2YXIgZGl2aWRlciA9IGZyYWdtZW50cy5pbmRleE9mKGZpbmQoZnJhZ21lbnRzLCBmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnNlYXJjaCgvLHxcXHMvKSAhPT0gLTE7XG4gIH0pKTtcblxuICBpZiAoZnJhZ21lbnRzW2RpdmlkZXJdICYmIGZyYWdtZW50c1tkaXZpZGVyXS5pbmRleE9mKCcsJykgPT09IC0xKSB7XG4gICAgY29uc29sZS53YXJuKCdPZmZzZXRzIHNlcGFyYXRlZCBieSB3aGl0ZSBzcGFjZShzKSBhcmUgZGVwcmVjYXRlZCwgdXNlIGEgY29tbWEgKCwpIGluc3RlYWQuJyk7XG4gIH1cblxuICAvLyBJZiBkaXZpZGVyIGlzIGZvdW5kLCB3ZSBkaXZpZGUgdGhlIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kcyB0byBkaXZpZGVcbiAgLy8gdGhlbSBieSBvZnNldCBYIGFuZCBZLlxuICB2YXIgc3BsaXRSZWdleCA9IC9cXHMqLFxccyp8XFxzKy87XG4gIHZhciBvcHMgPSBkaXZpZGVyICE9PSAtMSA/IFtmcmFnbWVudHMuc2xpY2UoMCwgZGl2aWRlcikuY29uY2F0KFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMF1dKSwgW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVsxXV0uY29uY2F0KGZyYWdtZW50cy5zbGljZShkaXZpZGVyICsgMSkpXSA6IFtmcmFnbWVudHNdO1xuXG4gIC8vIENvbnZlcnQgdGhlIHZhbHVlcyB3aXRoIHVuaXRzIHRvIGFic29sdXRlIHBpeGVscyB0byBhbGxvdyBvdXIgY29tcHV0YXRpb25zXG4gIG9wcyA9IG9wcy5tYXAoZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIC8vIE1vc3Qgb2YgdGhlIHVuaXRzIHJlbHkgb24gdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBwb3BwZXJcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSAoaW5kZXggPT09IDEgPyAhdXNlSGVpZ2h0IDogdXNlSGVpZ2h0KSA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICByZXR1cm4gb3BcbiAgICAvLyBUaGlzIGFnZ3JlZ2F0ZXMgYW55IGArYCBvciBgLWAgc2lnbiB0aGF0IGFyZW4ndCBjb25zaWRlcmVkIG9wZXJhdG9yc1xuICAgIC8vIGUuZy46IDEwICsgKzUgPT4gWzEwLCArLCArNV1cbiAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYVthLmxlbmd0aCAtIDFdID09PSAnJyAmJiBbJysnLCAnLSddLmluZGV4T2YoYikgIT09IC0xKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSA9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2UgaWYgKG1lcmdlV2l0aFByZXZpb3VzKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSArPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICAgIH1cbiAgICB9LCBbXSlcbiAgICAvLyBIZXJlIHdlIGNvbnZlcnQgdGhlIHN0cmluZyB2YWx1ZXMgaW50byBudW1iZXIgdmFsdWVzIChpbiBweClcbiAgICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBMb29wIHRyb3VnaCB0aGUgb2Zmc2V0cyBhcnJheXMgYW5kIGV4ZWN1dGUgdGhlIG9wZXJhdGlvbnNcbiAgb3BzLmZvckVhY2goZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIG9wLmZvckVhY2goZnVuY3Rpb24gKGZyYWcsIGluZGV4Mikge1xuICAgICAgaWYgKGlzTnVtZXJpYyhmcmFnKSkge1xuICAgICAgICBvZmZzZXRzW2luZGV4XSArPSBmcmFnICogKG9wW2luZGV4MiAtIDFdID09PSAnLScgPyAtMSA6IDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQGFyZ3VtZW50IHtOdW1iZXJ8U3RyaW5nfSBvcHRpb25zLm9mZnNldD0wXG4gKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gb2Zmc2V0KGRhdGEsIF9yZWYpIHtcbiAgdmFyIG9mZnNldCA9IF9yZWYub2Zmc2V0O1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQsXG4gICAgICBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIHZhciBvZmZzZXRzID0gdm9pZCAwO1xuICBpZiAoaXNOdW1lcmljKCtvZmZzZXQpKSB7XG4gICAgb2Zmc2V0cyA9IFsrb2Zmc2V0LCAwXTtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXRzID0gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYmFzZVBsYWNlbWVudCk7XG4gIH1cblxuICBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0IC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3JpZ2h0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICd0b3AnKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wIC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2JvdHRvbScpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1sxXTtcbiAgfVxuXG4gIGRhdGEucG9wcGVyID0gcG9wcGVyO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGJvdW5kYXJpZXNFbGVtZW50ID0gb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCB8fCBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuXG4gIC8vIElmIG9mZnNldFBhcmVudCBpcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIHJlYWxseSB3YW50IHRvXG4gIC8vIGdvIG9uZSBzdGVwIHVwIGFuZCB1c2UgdGhlIG5leHQgb2Zmc2V0UGFyZW50IGFzIHJlZmVyZW5jZSB0b1xuICAvLyBhdm9pZCB0byBtYWtlIHRoaXMgbW9kaWZpZXIgY29tcGxldGVseSB1c2VsZXNzIGFuZCBsb29rIGxpa2UgYnJva2VuXG4gIGlmIChkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSA9PT0gYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgICBib3VuZGFyaWVzRWxlbWVudCA9IGdldE9mZnNldFBhcmVudChib3VuZGFyaWVzRWxlbWVudCk7XG4gIH1cblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzZXRzIHRoZSBwb3BwZXIncyBwb3NpdGlvbiBzbyB0aGF0IHRoZSBkb2N1bWVudCBzaXplIGNhbiBiZSBjYWxjdWxhdGVkIGV4Y2x1ZGluZ1xuICAvLyB0aGUgc2l6ZSBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgaXRzZWxmXG4gIHZhciB0cmFuc2Zvcm1Qcm9wID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcbiAgdmFyIHBvcHBlclN0eWxlcyA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnN0eWxlOyAvLyBhc3NpZ25tZW50IHRvIGhlbHAgbWluaWZpY2F0aW9uXG4gIHZhciB0b3AgPSBwb3BwZXJTdHlsZXMudG9wLFxuICAgICAgbGVmdCA9IHBvcHBlclN0eWxlcy5sZWZ0LFxuICAgICAgdHJhbnNmb3JtID0gcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdO1xuXG4gIHBvcHBlclN0eWxlcy50b3AgPSAnJztcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSAnJztcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gJyc7XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCwgZGF0YS5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzdG9yZXMgdGhlIG9yaWdpbmFsIHN0eWxlIHByb3BlcnRpZXMgYWZ0ZXIgdGhlIG9mZnNldHMgaGF2ZSBiZWVuIGNvbXB1dGVkXG4gIHBvcHBlclN0eWxlcy50b3AgPSB0b3A7XG4gIHBvcHBlclN0eWxlcy5sZWZ0ID0gbGVmdDtcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtO1xuXG4gIG9wdGlvbnMuYm91bmRhcmllcyA9IGJvdW5kYXJpZXM7XG5cbiAgdmFyIG9yZGVyID0gb3B0aW9ucy5wcmlvcml0eTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgdmFyIGNoZWNrID0ge1xuICAgIHByaW1hcnk6IGZ1bmN0aW9uIHByaW1hcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbcGxhY2VtZW50XTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA8IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5tYXgocG9wcGVyW3BsYWNlbWVudF0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIHBsYWNlbWVudCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2Vjb25kYXJ5OiBmdW5jdGlvbiBzZWNvbmRhcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgbWFpblNpZGUgPSBwbGFjZW1lbnQgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlclttYWluU2lkZV07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPiBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWluKHBvcHBlclttYWluU2lkZV0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSAtIChwbGFjZW1lbnQgPT09ICdyaWdodCcgPyBwb3BwZXIud2lkdGggOiBwb3BwZXIuaGVpZ2h0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIG1haW5TaWRlLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHZhciBzaWRlID0gWydsZWZ0JywgJ3RvcCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTEgPyAncHJpbWFyeScgOiAnc2Vjb25kYXJ5JztcbiAgICBwb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBjaGVja1tzaWRlXShwbGFjZW1lbnQpKTtcbiAgfSk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IHBvcHBlcjtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gc2hpZnQoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBzaGlmdHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIC8vIGlmIHNoaWZ0IHNoaWZ0dmFyaWF0aW9uIGlzIHNwZWNpZmllZCwgcnVuIHRoZSBtb2RpZmllclxuICBpZiAoc2hpZnR2YXJpYXRpb24pIHtcbiAgICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyO1xuXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ2JvdHRvbScsICd0b3AnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gICAgdmFyIHNoaWZ0T2Zmc2V0cyA9IHtcbiAgICAgIHN0YXJ0OiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdKSxcbiAgICAgIGVuZDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVttZWFzdXJlbWVudF0gLSBwb3BwZXJbbWVhc3VyZW1lbnRdKVxuICAgIH07XG5cbiAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgc2hpZnRPZmZzZXRzW3NoaWZ0dmFyaWF0aW9uXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGhpZGUoZGF0YSkge1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2hpZGUnLCAncHJldmVudE92ZXJmbG93JykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciByZWZSZWN0ID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIGJvdW5kID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdwcmV2ZW50T3ZlcmZsb3cnO1xuICB9KS5ib3VuZGFyaWVzO1xuXG4gIGlmIChyZWZSZWN0LmJvdHRvbSA8IGJvdW5kLnRvcCB8fCByZWZSZWN0LmxlZnQgPiBib3VuZC5yaWdodCB8fCByZWZSZWN0LnRvcCA+IGJvdW5kLmJvdHRvbSB8fCByZWZSZWN0LnJpZ2h0IDwgYm91bmQubGVmdCkge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IHRydWU7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gZmFsc2U7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBpbm5lcihkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc0hvcml6ID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIHN1YnRyYWN0TGVuZ3RoID0gWyd0b3AnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPT09IC0xO1xuXG4gIHBvcHBlcltpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCddID0gcmVmZXJlbmNlW2Jhc2VQbGFjZW1lbnRdIC0gKHN1YnRyYWN0TGVuZ3RoID8gcG9wcGVyW2lzSG9yaXogPyAnd2lkdGgnIDogJ2hlaWdodCddIDogMCk7XG5cbiAgZGF0YS5wbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChwb3BwZXIpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIE1vZGlmaWVyIGZ1bmN0aW9uLCBlYWNoIG1vZGlmaWVyIGNhbiBoYXZlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIGFzc2lnbmVkXG4gKiB0byBpdHMgYGZuYCBwcm9wZXJ0eS48YnIgLz5cbiAqIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZSwgdGhpcyBtZWFucyB0aGF0IHlvdSBtdXN0XG4gKiBtYWtlIHN1cmUgdGhleSBhcmUgcGVyZm9ybWFudCBlbm91Z2ggdG8gYXZvaWQgcGVyZm9ybWFuY2UgYm90dGxlbmVja3MuXG4gKlxuICogQGZ1bmN0aW9uIE1vZGlmaWVyRm5cbiAqIEBhcmd1bWVudCB7ZGF0YU9iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5cbi8qKlxuICogTW9kaWZpZXJzIGFyZSBwbHVnaW5zIHVzZWQgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHlvdXIgcG9wcGVycy48YnIgLz5cbiAqIFBvcHBlci5qcyB1c2VzIGEgc2V0IG9mIDkgbW9kaWZpZXJzIHRvIHByb3ZpZGUgYWxsIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXRpZXNcbiAqIG5lZWRlZCBieSB0aGUgbGlicmFyeS5cbiAqXG4gKiBVc3VhbGx5IHlvdSBkb24ndCB3YW50IHRvIG92ZXJyaWRlIHRoZSBgb3JkZXJgLCBgZm5gIGFuZCBgb25Mb2FkYCBwcm9wcy5cbiAqIEFsbCB0aGUgb3RoZXIgcHJvcGVydGllcyBhcmUgY29uZmlndXJhdGlvbnMgdGhhdCBjb3VsZCBiZSB0d2Vha2VkLlxuICogQG5hbWVzcGFjZSBtb2RpZmllcnNcbiAqL1xudmFyIG1vZGlmaWVycyA9IHtcbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gc2hpZnQgdGhlIHBvcHBlciBvbiB0aGUgc3RhcnQgb3IgZW5kIG9mIGl0cyByZWZlcmVuY2VcbiAgICogZWxlbWVudC48YnIgLz5cbiAgICogSXQgd2lsbCByZWFkIHRoZSB2YXJpYXRpb24gb2YgdGhlIGBwbGFjZW1lbnRgIHByb3BlcnR5LjxiciAvPlxuICAgKiBJdCBjYW4gYmUgb25lIGVpdGhlciBgLWVuZGAgb3IgYC1zdGFydGAuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBzaGlmdDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0xMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDEwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHNoaWZ0XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBgb2Zmc2V0YCBtb2RpZmllciBjYW4gc2hpZnQgeW91ciBwb3BwZXIgb24gYm90aCBpdHMgYXhpcy5cbiAgICpcbiAgICogSXQgYWNjZXB0cyB0aGUgZm9sbG93aW5nIHVuaXRzOlxuICAgKiAtIGBweGAgb3IgdW5pdGxlc3MsIGludGVycHJldGVkIGFzIHBpeGVsc1xuICAgKiAtIGAlYCBvciBgJXJgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAqIC0gYCVwYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiAtIGB2d2AsIENTUyB2aWV3cG9ydCB3aWR0aCB1bml0XG4gICAqIC0gYHZoYCwgQ1NTIHZpZXdwb3J0IGhlaWdodCB1bml0XG4gICAqXG4gICAqIEZvciBsZW5ndGggaXMgaW50ZW5kZWQgdGhlIG1haW4gYXhpcyByZWxhdGl2ZSB0byB0aGUgcGxhY2VtZW50IG9mIHRoZSBwb3BwZXIuPGJyIC8+XG4gICAqIFRoaXMgbWVhbnMgdGhhdCBpZiB0aGUgcGxhY2VtZW50IGlzIGB0b3BgIG9yIGBib3R0b21gLCB0aGUgbGVuZ3RoIHdpbGwgYmUgdGhlXG4gICAqIGB3aWR0aGAuIEluIGNhc2Ugb2YgYGxlZnRgIG9yIGByaWdodGAsIGl0IHdpbGwgYmUgdGhlIGhlaWdodC5cbiAgICpcbiAgICogWW91IGNhbiBwcm92aWRlIGEgc2luZ2xlIHZhbHVlIChhcyBgTnVtYmVyYCBvciBgU3RyaW5nYCksIG9yIGEgcGFpciBvZiB2YWx1ZXNcbiAgICogYXMgYFN0cmluZ2AgZGl2aWRlZCBieSBhIGNvbW1hIG9yIG9uZSAob3IgbW9yZSkgd2hpdGUgc3BhY2VzLjxiciAvPlxuICAgKiBUaGUgbGF0dGVyIGlzIGEgZGVwcmVjYXRlZCBtZXRob2QgYmVjYXVzZSBpdCBsZWFkcyB0byBjb25mdXNpb24gYW5kIHdpbGwgYmVcbiAgICogcmVtb3ZlZCBpbiB2Mi48YnIgLz5cbiAgICogQWRkaXRpb25hbGx5LCBpdCBhY2NlcHRzIGFkZGl0aW9ucyBhbmQgc3VidHJhY3Rpb25zIGJldHdlZW4gZGlmZmVyZW50IHVuaXRzLlxuICAgKiBOb3RlIHRoYXQgbXVsdGlwbGljYXRpb25zIGFuZCBkaXZpc2lvbnMgYXJlbid0IHN1cHBvcnRlZC5cbiAgICpcbiAgICogVmFsaWQgZXhhbXBsZXMgYXJlOlxuICAgKiBgYGBcbiAgICogMTBcbiAgICogJzEwJSdcbiAgICogJzEwLCAxMCdcbiAgICogJzEwJSwgMTAnXG4gICAqICcxMCArIDEwJSdcbiAgICogJzEwIC0gNXZoICsgMyUnXG4gICAqICctMTBweCArIDV2aCwgNXB4IC0gNiUnXG4gICAqIGBgYFxuICAgKiA+ICoqTkIqKjogSWYgeW91IGRlc2lyZSB0byBhcHBseSBvZmZzZXRzIHRvIHlvdXIgcG9wcGVycyBpbiBhIHdheSB0aGF0IG1heSBtYWtlIHRoZW0gb3ZlcmxhcFxuICAgKiA+IHdpdGggdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnQsIHVuZm9ydHVuYXRlbHksIHlvdSB3aWxsIGhhdmUgdG8gZGlzYWJsZSB0aGUgYGZsaXBgIG1vZGlmaWVyLlxuICAgKiA+IE1vcmUgb24gdGhpcyBbcmVhZGluZyB0aGlzIGlzc3VlXShodHRwczovL2dpdGh1Yi5jb20vRmV6VnJhc3RhL3BvcHBlci5qcy9pc3N1ZXMvMzczKVxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgb2Zmc2V0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTIwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogb2Zmc2V0LFxuICAgIC8qKiBAcHJvcCB7TnVtYmVyfFN0cmluZ30gb2Zmc2V0PTBcbiAgICAgKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBvZmZzZXQ6IDBcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBwcmV2ZW50IHRoZSBwb3BwZXIgZnJvbSBiZWluZyBwb3NpdGlvbmVkIG91dHNpZGUgdGhlIGJvdW5kYXJ5LlxuICAgKlxuICAgKiBBbiBzY2VuYXJpbyBleGlzdHMgd2hlcmUgdGhlIHJlZmVyZW5jZSBpdHNlbGYgaXMgbm90IHdpdGhpbiB0aGUgYm91bmRhcmllcy48YnIgLz5cbiAgICogV2UgY2FuIHNheSBpdCBoYXMgXCJlc2NhcGVkIHRoZSBib3VuZGFyaWVzXCIg4oCUIG9yIGp1c3QgXCJlc2NhcGVkXCIuPGJyIC8+XG4gICAqIEluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIGRlY2lkZSB3aGV0aGVyIHRoZSBwb3BwZXIgc2hvdWxkIGVpdGhlcjpcbiAgICpcbiAgICogLSBkZXRhY2ggZnJvbSB0aGUgcmVmZXJlbmNlIGFuZCByZW1haW4gXCJ0cmFwcGVkXCIgaW4gdGhlIGJvdW5kYXJpZXMsIG9yXG4gICAqIC0gaWYgaXQgc2hvdWxkIGlnbm9yZSB0aGUgYm91bmRhcnkgYW5kIFwiZXNjYXBlIHdpdGggaXRzIHJlZmVyZW5jZVwiXG4gICAqXG4gICAqIFdoZW4gYGVzY2FwZVdpdGhSZWZlcmVuY2VgIGlzIHNldCB0b2B0cnVlYCBhbmQgcmVmZXJlbmNlIGlzIGNvbXBsZXRlbHlcbiAgICogb3V0c2lkZSBpdHMgYm91bmRhcmllcywgdGhlIHBvcHBlciB3aWxsIG92ZXJmbG93IChvciBjb21wbGV0ZWx5IGxlYXZlKVxuICAgKiB0aGUgYm91bmRhcmllcyBpbiBvcmRlciB0byByZW1haW4gYXR0YWNoZWQgdG8gdGhlIGVkZ2Ugb2YgdGhlIHJlZmVyZW5jZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHByZXZlbnRPdmVyZmxvdzoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0zMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDMwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7QXJyYXl9IFtwcmlvcml0eT1bJ2xlZnQnLCdyaWdodCcsJ3RvcCcsJ2JvdHRvbSddXVxuICAgICAqIFBvcHBlciB3aWxsIHRyeSB0byBwcmV2ZW50IG92ZXJmbG93IGZvbGxvd2luZyB0aGVzZSBwcmlvcml0aWVzIGJ5IGRlZmF1bHQsXG4gICAgICogdGhlbiwgaXQgY291bGQgb3ZlcmZsb3cgb24gdGhlIGxlZnQgYW5kIG9uIHRvcCBvZiB0aGUgYGJvdW5kYXJpZXNFbGVtZW50YFxuICAgICAqL1xuICAgIHByaW9yaXR5OiBbJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSddLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIEFtb3VudCBvZiBwaXhlbCB1c2VkIHRvIGRlZmluZSBhIG1pbmltdW0gZGlzdGFuY2UgYmV0d2VlbiB0aGUgYm91bmRhcmllc1xuICAgICAqIGFuZCB0aGUgcG9wcGVyIHRoaXMgbWFrZXMgc3VyZSB0aGUgcG9wcGVyIGhhcyBhbHdheXMgYSBsaXR0bGUgcGFkZGluZ1xuICAgICAqIGJldHdlZW4gdGhlIGVkZ2VzIG9mIGl0cyBjb250YWluZXJcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSdzY3JvbGxQYXJlbnQnXG4gICAgICogQm91bmRhcmllcyB1c2VkIGJ5IHRoZSBtb2RpZmllciwgY2FuIGJlIGBzY3JvbGxQYXJlbnRgLCBgd2luZG93YCxcbiAgICAgKiBgdmlld3BvcnRgIG9yIGFueSBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3Njcm9sbFBhcmVudCdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHN1cmUgdGhlIHJlZmVyZW5jZSBhbmQgaXRzIHBvcHBlciBzdGF5IG5lYXIgZWFjaG90aGVyc1xuICAgKiB3aXRob3V0IGxlYXZpbmcgYW55IGdhcCBiZXR3ZWVuIHRoZSB0d28uIEV4cGVjaWFsbHkgdXNlZnVsIHdoZW4gdGhlIGFycm93IGlzXG4gICAqIGVuYWJsZWQgYW5kIHlvdSB3YW50IHRvIGFzc3VyZSBpdCB0byBwb2ludCB0byBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEl0IGNhcmVzIG9ubHkgYWJvdXQgdGhlIGZpcnN0IGF4aXMsIHlvdSBjYW4gc3RpbGwgaGF2ZSBwb3BwZXJzIHdpdGggbWFyZ2luXG4gICAqIGJldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAga2VlcFRvZ2V0aGVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTQwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNDAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjoga2VlcFRvZ2V0aGVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgbW9kaWZpZXIgaXMgdXNlZCB0byBtb3ZlIHRoZSBgYXJyb3dFbGVtZW50YCBvZiB0aGUgcG9wcGVyIHRvIG1ha2VcbiAgICogc3VyZSBpdCBpcyBwb3NpdGlvbmVkIGJldHdlZW4gdGhlIHJlZmVyZW5jZSBlbGVtZW50IGFuZCBpdHMgcG9wcGVyIGVsZW1lbnQuXG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgb3V0ZXIgc2l6ZSBvZiB0aGUgYGFycm93RWxlbWVudGAgbm9kZSB0byBkZXRlY3QgaG93IG1hbnlcbiAgICogcGl4ZWxzIG9mIGNvbmp1Y3Rpb24gYXJlIG5lZWRlZC5cbiAgICpcbiAgICogSXQgaGFzIG5vIGVmZmVjdCBpZiBubyBgYXJyb3dFbGVtZW50YCBpcyBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFycm93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTUwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXJyb3csXG4gICAgLyoqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGVsZW1lbnQ9J1t4LWFycm93XScgLSBTZWxlY3RvciBvciBub2RlIHVzZWQgYXMgYXJyb3cgKi9cbiAgICBlbGVtZW50OiAnW3gtYXJyb3ddJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGZsaXAgdGhlIHBvcHBlcidzIHBsYWNlbWVudCB3aGVuIGl0IHN0YXJ0cyB0byBvdmVybGFwIGl0c1xuICAgKiByZWZlcmVuY2UgZWxlbWVudC5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKlxuICAgKiAqKk5PVEU6KiogdGhpcyBtb2RpZmllciB3aWxsIGludGVycnVwdCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUgYW5kIHdpbGxcbiAgICogcmVzdGFydCBpdCBpZiBpdCBkZXRlY3RzIHRoZSBuZWVkIHRvIGZsaXAgdGhlIHBsYWNlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGZsaXA6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA2MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBmbGlwLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8QXJyYXl9IGJlaGF2aW9yPSdmbGlwJ1xuICAgICAqIFRoZSBiZWhhdmlvciB1c2VkIHRvIGNoYW5nZSB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50LiBJdCBjYW4gYmUgb25lIG9mXG4gICAgICogYGZsaXBgLCBgY2xvY2t3aXNlYCwgYGNvdW50ZXJjbG9ja3dpc2VgIG9yIGFuIGFycmF5IHdpdGggYSBsaXN0IG9mIHZhbGlkXG4gICAgICogcGxhY2VtZW50cyAod2l0aCBvcHRpb25hbCB2YXJpYXRpb25zKS5cbiAgICAgKi9cbiAgICBiZWhhdmlvcjogJ2ZsaXAnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBmbGlwIGlmIGl0IGhpdHMgdGhlIGVkZ2VzIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0ndmlld3BvcnQnXG4gICAgICogVGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBkZWZpbmUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHBvcHBlciBwb3NpdGlvbixcbiAgICAgKiB0aGUgcG9wcGVyIHdpbGwgbmV2ZXIgYmUgcGxhY2VkIG91dHNpZGUgb2YgdGhlIGRlZmluZWQgYm91bmRhcmllc1xuICAgICAqIChleGNlcHQgaWYga2VlcFRvZ2V0aGVyIGlzIGVuYWJsZWQpXG4gICAgICovXG4gICAgYm91bmRhcmllc0VsZW1lbnQ6ICd2aWV3cG9ydCdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHRoZSBwb3BwZXIgZmxvdyB0b3dhcmQgdGhlIGlubmVyIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQnkgZGVmYXVsdCwgd2hlbiB0aGlzIG1vZGlmaWVyIGlzIGRpc2FibGVkLCB0aGUgcG9wcGVyIHdpbGwgYmUgcGxhY2VkIG91dHNpZGVcbiAgICogdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaW5uZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA3MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPWZhbHNlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGlubmVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gaGlkZSB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBlbGVtZW50IGlzIG91dHNpZGUgb2YgdGhlXG4gICAqIHBvcHBlciBib3VuZGFyaWVzLiBJdCB3aWxsIHNldCBhIGB4LW91dC1vZi1ib3VuZGFyaWVzYCBhdHRyaWJ1dGUgd2hpY2ggY2FuXG4gICAqIGJlIHVzZWQgdG8gaGlkZSB3aXRoIGEgQ1NTIHNlbGVjdG9yIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGlzXG4gICAqIG91dCBvZiBib3VuZGFyaWVzLlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBoaWRlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTgwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaGlkZVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgc3R5bGUgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBlbGVtZW50IHRvIGdldHNcbiAgICogcHJvcGVybHkgcG9zaXRpb25lZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgbW9kaWZpZXIgd2lsbCBub3QgdG91Y2ggdGhlIERPTSwgaXQganVzdCBwcmVwYXJlcyB0aGUgc3R5bGVzXG4gICAqIHNvIHRoYXQgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGNhbiBhcHBseSBpdC4gVGhpcyBzZXBhcmF0aW9uIGlzIHVzZWZ1bFxuICAgKiBpbiBjYXNlIHlvdSBuZWVkIHRvIHJlcGxhY2UgYGFwcGx5U3R5bGVgIHdpdGggYSBjdXN0b20gaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIFRoaXMgbW9kaWZpZXIgaGFzIGA4NTBgIGFzIGBvcmRlcmAgdmFsdWUgdG8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgKiB3aXRoIHByZXZpb3VzIHZlcnNpb25zIG9mIFBvcHBlci5qcy4gRXhwZWN0IHRoZSBtb2RpZmllcnMgb3JkZXJpbmcgbWV0aG9kXG4gICAqIHRvIGNoYW5nZSBpbiBmdXR1cmUgbWFqb3IgdmVyc2lvbnMgb2YgdGhlIGxpYnJhcnkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBjb21wdXRlU3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODUwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4NTAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBjb21wdXRlU3R5bGUsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNkIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nYm90dG9tJ11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFggYXhpcyAoYGJvdHRvbWAgb3IgYHRvcGApLiBBS0EgWCBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGBib3R0b21gXG4gICAgICovXG4gICAgeDogJ2JvdHRvbScsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2xlZnQnXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWSBheGlzIChgbGVmdGAgb3IgYHJpZ2h0YCkuIEFLQSBZIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYHJpZ2h0YFxuICAgICAqL1xuICAgIHk6ICdyaWdodCdcbiAgfSxcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgY29tcHV0ZWQgc3R5bGVzIHRvIHRoZSBwb3BwZXIgZWxlbWVudC5cbiAgICpcbiAgICogQWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyBhcmUgbGltaXRlZCB0byB0aGlzIG1vZGlmaWVyLiBUaGlzIGlzIHVzZWZ1bCBpbiBjYXNlXG4gICAqIHlvdSB3YW50IHRvIGludGVncmF0ZSBQb3BwZXIuanMgaW5zaWRlIGEgZnJhbWV3b3JrIG9yIHZpZXcgbGlicmFyeSBhbmQgeW91XG4gICAqIHdhbnQgdG8gZGVsZWdhdGUgYWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyB0byBpdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHlvdSBkaXNhYmxlIHRoaXMgbW9kaWZpZXIsIHlvdSBtdXN0IG1ha2Ugc3VyZSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogaGFzIGl0cyBwb3NpdGlvbiBzZXQgdG8gYGFic29sdXRlYCBiZWZvcmUgUG9wcGVyLmpzIGNhbiBkbyBpdHMgd29yayFcbiAgICpcbiAgICogSnVzdCBkaXNhYmxlIHRoaXMgbW9kaWZpZXIgYW5kIGRlZmluZSB5b3Ugb3duIHRvIGFjaGlldmUgdGhlIGRlc2lyZWQgZWZmZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXBwbHlTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj05MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDkwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFwcGx5U3R5bGUsXG4gICAgLyoqIEBwcm9wIHtGdW5jdGlvbn0gKi9cbiAgICBvbkxvYWQ6IGFwcGx5U3R5bGVPbkxvYWQsXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjEwLjAsIHRoZSBwcm9wZXJ0eSBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllclxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzZCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHVuZGVmaW5lZFxuICB9XG59O1xuXG4vKipcbiAqIFRoZSBgZGF0YU9iamVjdGAgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBpbmZvcm1hdGlvbnMgdXNlZCBieSBQb3BwZXIuanNcbiAqIHRoaXMgb2JqZWN0IGdldCBwYXNzZWQgdG8gbW9kaWZpZXJzIGFuZCB0byB0aGUgYG9uQ3JlYXRlYCBhbmQgYG9uVXBkYXRlYCBjYWxsYmFja3MuXG4gKiBAbmFtZSBkYXRhT2JqZWN0XG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5pbnN0YW5jZSBUaGUgUG9wcGVyLmpzIGluc3RhbmNlXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5wbGFjZW1lbnQgUGxhY2VtZW50IGFwcGxpZWQgdG8gcG9wcGVyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCBQbGFjZW1lbnQgb3JpZ2luYWxseSBkZWZpbmVkIG9uIGluaXRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5mbGlwcGVkIFRydWUgaWYgcG9wcGVyIGhhcyBiZWVuIGZsaXBwZWQgYnkgZmxpcCBtb2RpZmllclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmhpZGUgVHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0IG9mIGJvdW5kYXJpZXMsIHVzZWZ1bCB0byBrbm93IHdoZW4gdG8gaGlkZSB0aGUgcG9wcGVyLlxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gZGF0YS5hcnJvd0VsZW1lbnQgTm9kZSB1c2VkIGFzIGFycm93IGJ5IGFycm93IG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5zdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsIGl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5hcnJvd1N0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBhcnJvdywgaXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmJvdW5kYXJpZXMgT2Zmc2V0cyBvZiB0aGUgcG9wcGVyIGJvdW5kYXJpZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMgVGhlIG1lYXN1cmVtZW50cyBvZiBwb3BwZXIsIHJlZmVyZW5jZSBhbmQgYXJyb3cgZWxlbWVudHMuXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnBvcHBlciBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucmVmZXJlbmNlIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5hcnJvd10gYHRvcGAgYW5kIGBsZWZ0YCBvZmZzZXRzLCBvbmx5IG9uZSBvZiB0aGVtIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gMFxuICovXG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIHByb3ZpZGVkIHRvIFBvcHBlci5qcyBjb25zdHJ1Y3Rvci48YnIgLz5cbiAqIFRoZXNlIGNhbiBiZSBvdmVycmlkZW4gdXNpbmcgdGhlIGBvcHRpb25zYCBhcmd1bWVudCBvZiBQb3BwZXIuanMuPGJyIC8+XG4gKiBUbyBvdmVycmlkZSBhbiBvcHRpb24sIHNpbXBseSBwYXNzIGFzIDNyZCBhcmd1bWVudCBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZVxuICogc3RydWN0dXJlIG9mIHRoaXMgb2JqZWN0LCBleGFtcGxlOlxuICogYGBgXG4gKiBuZXcgUG9wcGVyKHJlZiwgcG9wLCB7XG4gKiAgIG1vZGlmaWVyczoge1xuICogICAgIHByZXZlbnRPdmVyZmxvdzogeyBlbmFibGVkOiBmYWxzZSB9XG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbnZhciBEZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIFBvcHBlcidzIHBsYWNlbWVudFxuICAgKiBAcHJvcCB7UG9wcGVyLnBsYWNlbWVudHN9IHBsYWNlbWVudD0nYm90dG9tJ1xuICAgKi9cbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcblxuICAvKipcbiAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3Ugd2FudCBwb3BwZXIgdG8gcG9zaXRpb24gaXQgc2VsZiBpbiAnZml4ZWQnIG1vZGVcbiAgICogQHByb3Age0Jvb2xlYW59IHBvc2l0aW9uRml4ZWQ9ZmFsc2VcbiAgICovXG4gIHBvc2l0aW9uRml4ZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGV2ZW50cyAocmVzaXplLCBzY3JvbGwpIGFyZSBpbml0aWFsbHkgZW5hYmxlZFxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gZXZlbnRzRW5hYmxlZD10cnVlXG4gICAqL1xuICBldmVudHNFbmFibGVkOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlbW92ZSB0aGUgcG9wcGVyIHdoZW5cbiAgICogeW91IGNhbGwgdGhlIGBkZXN0cm95YCBtZXRob2QuXG4gICAqIEBwcm9wIHtCb29sZWFufSByZW1vdmVPbkRlc3Ryb3k9ZmFsc2VcbiAgICovXG4gIHJlbW92ZU9uRGVzdHJveTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgY3JlYXRlZC48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25DcmVhdGV9XG4gICAqL1xuICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoKSB7fSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyB1cGRhdGVkLCB0aGlzIGNhbGxiYWNrIGlzIG5vdCBjYWxsZWRcbiAgICogb24gdGhlIGluaXRpYWxpemF0aW9uL2NyZWF0aW9uIG9mIHRoZSBwb3BwZXIsIGJ1dCBvbmx5IG9uIHN1YnNlcXVlbnRcbiAgICogdXBkYXRlcy48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25VcGRhdGV9XG4gICAqL1xuICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoKSB7fSxcblxuICAvKipcbiAgICogTGlzdCBvZiBtb2RpZmllcnMgdXNlZCB0byBtb2RpZnkgdGhlIG9mZnNldHMgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci5cbiAgICogVGhleSBwcm92aWRlIG1vc3Qgb2YgdGhlIGZ1bmN0aW9uYWxpdGllcyBvZiBQb3BwZXIuanNcbiAgICogQHByb3Age21vZGlmaWVyc31cbiAgICovXG4gIG1vZGlmaWVyczogbW9kaWZpZXJzXG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayBvbkNyZWF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgb25VcGRhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8vIFV0aWxzXG4vLyBNZXRob2RzXG52YXIgUG9wcGVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFBvcHBlci5qcyBpbnN0YW5jZVxuICAgKiBAY2xhc3MgUG9wcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8cmVmZXJlbmNlT2JqZWN0fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gWW91ciBjdXN0b20gb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgb25lcyBkZWZpbmVkIGluIFtEZWZhdWx0c10oI2RlZmF1bHRzKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGluc3RhbmNlIC0gVGhlIGdlbmVyYXRlZCBQb3BwZXIuanMgaW5zdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIFBvcHBlcihyZWZlcmVuY2UsIHBvcHBlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wcGVyKTtcblxuICAgIHRoaXMuc2NoZWR1bGVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aGlzLnVwZGF0ZSk7XG4gICAgfTtcblxuICAgIC8vIG1ha2UgdXBkYXRlKCkgZGVib3VuY2VkLCBzbyB0aGF0IGl0IG9ubHkgcnVucyBhdCBtb3N0IG9uY2UtcGVyLXRpY2tcbiAgICB0aGlzLnVwZGF0ZSA9IGRlYm91bmNlKHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuXG4gICAgLy8gd2l0aCB7fSB3ZSBjcmVhdGUgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG9wdGlvbnMgaW5zaWRlIGl0XG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAvLyBpbml0IHN0YXRlXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzRGVzdHJveWVkOiBmYWxzZSxcbiAgICAgIGlzQ3JlYXRlZDogZmFsc2UsXG4gICAgICBzY3JvbGxQYXJlbnRzOiBbXVxuICAgIH07XG5cbiAgICAvLyBnZXQgcmVmZXJlbmNlIGFuZCBwb3BwZXIgZWxlbWVudHMgKGFsbG93IGpRdWVyeSB3cmFwcGVycylcbiAgICB0aGlzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZSAmJiByZWZlcmVuY2UuanF1ZXJ5ID8gcmVmZXJlbmNlWzBdIDogcmVmZXJlbmNlO1xuICAgIHRoaXMucG9wcGVyID0gcG9wcGVyICYmIHBvcHBlci5qcXVlcnkgPyBwb3BwZXJbMF0gOiBwb3BwZXI7XG5cbiAgICAvLyBEZWVwIG1lcmdlIG1vZGlmaWVycyBvcHRpb25zXG4gICAgdGhpcy5vcHRpb25zLm1vZGlmaWVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzLCBvcHRpb25zLm1vZGlmaWVycykpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnNbbmFtZV0gfHwge30sIG9wdGlvbnMubW9kaWZpZXJzID8gb3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gOiB7fSk7XG4gICAgfSk7XG5cbiAgICAvLyBSZWZhY3RvcmluZyBtb2RpZmllcnMnIGxpc3QgKE9iamVjdCA9PiBBcnJheSlcbiAgICB0aGlzLm1vZGlmaWVycyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5tb2RpZmllcnMpLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSwgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0pO1xuICAgIH0pXG4gICAgLy8gc29ydCB0aGUgbW9kaWZpZXJzIGJ5IG9yZGVyXG4gICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLm9yZGVyIC0gYi5vcmRlcjtcbiAgICB9KTtcblxuICAgIC8vIG1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgd2hlbiBQb3BwZXIuanMgZ2V0IGluaXRlZFxuICAgIC8vIHN1Y2ggY29kZSBpcyBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBvZiBpdHMgbW9kaWZpZXJcbiAgICAvLyB0aGV5IGNvdWxkIGFkZCBuZXcgcHJvcGVydGllcyB0byB0aGVpciBvcHRpb25zIGNvbmZpZ3VyYXRpb25cbiAgICAvLyBCRSBBV0FSRTogZG9uJ3QgYWRkIG9wdGlvbnMgdG8gYG9wdGlvbnMubW9kaWZpZXJzLm5hbWVgIGJ1dCB0byBgbW9kaWZpZXJPcHRpb25zYCFcbiAgICB0aGlzLm1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllck9wdGlvbnMpIHtcbiAgICAgIGlmIChtb2RpZmllck9wdGlvbnMuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQpKSB7XG4gICAgICAgIG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQoX3RoaXMucmVmZXJlbmNlLCBfdGhpcy5wb3BwZXIsIF90aGlzLm9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgX3RoaXMuc3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZmlyZSB0aGUgZmlyc3QgdXBkYXRlIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIgaW4gdGhlIHJpZ2h0IHBsYWNlXG4gICAgdGhpcy51cGRhdGUoKTtcblxuICAgIHZhciBldmVudHNFbmFibGVkID0gdGhpcy5vcHRpb25zLmV2ZW50c0VuYWJsZWQ7XG4gICAgaWYgKGV2ZW50c0VuYWJsZWQpIHtcbiAgICAgIC8vIHNldHVwIGV2ZW50IGxpc3RlbmVycywgdGhleSB3aWxsIHRha2UgY2FyZSBvZiB1cGRhdGUgdGhlIHBvc2l0aW9uIGluIHNwZWNpZmljIHNpdHVhdGlvbnNcbiAgICAgIHRoaXMuZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQgPSBldmVudHNFbmFibGVkO1xuICB9XG5cbiAgLy8gV2UgY2FuJ3QgdXNlIGNsYXNzIHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGRvbid0IGdldCBsaXN0ZWQgaW4gdGhlXG4gIC8vIGNsYXNzIHByb3RvdHlwZSBhbmQgYnJlYWsgc3R1ZmYgbGlrZSBTaW5vbiBzdHVic1xuXG5cbiAgY3JlYXRlQ2xhc3MoUG9wcGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSQkMSgpIHtcbiAgICAgIHJldHVybiB1cGRhdGUuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSQkMSgpIHtcbiAgICAgIHJldHVybiBkZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBlbmFibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZSBhbiB1cGRhdGUsIGl0IHdpbGwgcnVuIG9uIHRoZSBuZXh0IFVJIHVwZGF0ZSBhdmFpbGFibGVcbiAgICAgKiBAbWV0aG9kIHNjaGVkdWxlVXBkYXRlXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIG9mIHV0aWxpdGllcyB1c2VmdWwgd2hlbiB3cml0aW5nIGN1c3RvbSBtb2RpZmllcnMuXG4gICAgICogU3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDEuNywgdGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIG9ubHkgaWYgeW91XG4gICAgICogaW5jbHVkZSBgcG9wcGVyLXV0aWxzLmpzYCBiZWZvcmUgYHBvcHBlci5qc2AuXG4gICAgICpcbiAgICAgKiAqKkRFUFJFQ0FUSU9OKio6IFRoaXMgd2F5IHRvIGFjY2VzcyBQb3BwZXJVdGlscyBpcyBkZXByZWNhdGVkXG4gICAgICogYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MiEgVXNlIHRoZSBQb3BwZXJVdGlscyBtb2R1bGUgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKiBEdWUgdG8gdGhlIGhpZ2ggaW5zdGFiaWxpdHkgb2YgdGhlIG1ldGhvZHMgY29udGFpbmVkIGluIFV0aWxzLCB3ZSBjYW4ndFxuICAgICAqIGd1YXJhbnRlZSB0aGVtIHRvIGZvbGxvdyBzZW12ZXIuIFVzZSB0aGVtIGF0IHlvdXIgb3duIHJpc2shXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuOFxuICAgICAqIEBtZW1iZXIgVXRpbHNcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cbiAgfV0pO1xuICByZXR1cm4gUG9wcGVyO1xufSgpO1xuXG4vKipcbiAqIFRoZSBgcmVmZXJlbmNlT2JqZWN0YCBpcyBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgY29tcGF0aWJsZSB3aXRoIFBvcHBlci5qc1xuICogYW5kIGxldHMgeW91IHVzZSBpdCBhcyByZXBsYWNlbWVudCBvZiBhIHJlYWwgRE9NIG5vZGUuPGJyIC8+XG4gKiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byBwb3NpdGlvbiBhIHBvcHBlciByZWxhdGl2ZWx5IHRvIGEgc2V0IG9mIGNvb3JkaW5hdGVzXG4gKiBpbiBjYXNlIHlvdSBkb24ndCBoYXZlIGEgRE9NIG5vZGUgdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAqXG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmZXJlbmNlT2JqZWN0LCBwb3BwZXJOb2RlKTtcbiAqIGBgYFxuICpcbiAqIE5COiBUaGlzIGZlYXR1cmUgaXNuJ3Qgc3VwcG9ydGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwXG4gKiBAbmFtZSByZWZlcmVuY2VPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRhdGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNldCBvZiBjb29yZGluYXRlcyBjb21wYXRpYmxlIHdpdGggdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBtZXRob2QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRXaWR0aFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudEhlaWdodFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cblxuXG5Qb3BwZXIuVXRpbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpLlBvcHBlclV0aWxzO1xuUG9wcGVyLnBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuUG9wcGVyLkRlZmF1bHRzID0gRGVmYXVsdHM7XG5cbmV4cG9ydCBkZWZhdWx0IFBvcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcHBlci5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3BvcHBlci5qcy9kaXN0L2VzbS9wb3BwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXHJcblxyXG5leHBvcnQgZW51bSBDb250ZW50QXRvbVR5cGUge1xyXG4gICAgVGV4dCA9IDAsXHJcbiAgICBIdG1sID0gMSxcclxuICAgIFBpY3R1cmUgPSAyLFxyXG4gICAgTGluayA9IDMsXHJcbiAgICBOYXZMaW5rID0gNCxcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvQ29udGVudEF0b21UeXBlLnRzIiwiLyohXHJcbiAqIGpRdWVyeSBWYWxpZGF0aW9uIFBsdWdpbiB2MS4xNy4wXHJcbiAqXHJcbiAqIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyBKw7ZybiBaYWVmZmVyZXJcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4oZnVuY3Rpb24oIGZhY3RvcnkgKSB7XHJcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcclxuXHRcdGRlZmluZSggW1wianF1ZXJ5XCJdLCBmYWN0b3J5ICk7XHJcblx0fSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoIHJlcXVpcmUoIFwianF1ZXJ5XCIgKSApO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRmYWN0b3J5KCBqUXVlcnkgKTtcclxuXHR9XHJcbn0oZnVuY3Rpb24oICQgKSB7XHJcblxyXG4kLmV4dGVuZCggJC5mbiwge1xuXG5cdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvdmFsaWRhdGUvXG5cdHZhbGlkYXRlOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIG5vdGhpbmcgaXMgc2VsZWN0ZWQsIHJldHVybiBub3RoaW5nOyBjYW4ndCBjaGFpbiBhbnl3YXlcblx0XHRpZiAoICF0aGlzLmxlbmd0aCApIHtcblx0XHRcdGlmICggb3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnICYmIHdpbmRvdy5jb25zb2xlICkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oIFwiTm90aGluZyBzZWxlY3RlZCwgY2FuJ3QgdmFsaWRhdGUsIHJldHVybmluZyBub3RoaW5nLlwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgaWYgYSB2YWxpZGF0b3IgZm9yIHRoaXMgZm9ybSB3YXMgYWxyZWFkeSBjcmVhdGVkXG5cdFx0dmFyIHZhbGlkYXRvciA9ICQuZGF0YSggdGhpc1sgMCBdLCBcInZhbGlkYXRvclwiICk7XG5cdFx0aWYgKCB2YWxpZGF0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdmFsaWRhdG9yO1xuXHRcdH1cblxuXHRcdC8vIEFkZCBub3ZhbGlkYXRlIHRhZyBpZiBIVE1MNS5cblx0XHR0aGlzLmF0dHIoIFwibm92YWxpZGF0ZVwiLCBcIm5vdmFsaWRhdGVcIiApO1xuXG5cdFx0dmFsaWRhdG9yID0gbmV3ICQudmFsaWRhdG9yKCBvcHRpb25zLCB0aGlzWyAwIF0gKTtcblx0XHQkLmRhdGEoIHRoaXNbIDAgXSwgXCJ2YWxpZGF0b3JcIiwgdmFsaWRhdG9yICk7XG5cblx0XHRpZiAoIHZhbGlkYXRvci5zZXR0aW5ncy5vbnN1Ym1pdCApIHtcblxuXHRcdFx0dGhpcy5vbiggXCJjbGljay52YWxpZGF0ZVwiLCBcIjpzdWJtaXRcIiwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFRyYWNrIHRoZSB1c2VkIHN1Ym1pdCBidXR0b24gdG8gcHJvcGVybHkgaGFuZGxlIHNjcmlwdGVkXG5cdFx0XHRcdC8vIHN1Ym1pdHMgbGF0ZXIuXG5cdFx0XHRcdHZhbGlkYXRvci5zdWJtaXRCdXR0b24gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuXG5cdFx0XHRcdC8vIEFsbG93IHN1cHByZXNzaW5nIHZhbGlkYXRpb24gYnkgYWRkaW5nIGEgY2FuY2VsIGNsYXNzIHRvIHRoZSBzdWJtaXQgYnV0dG9uXG5cdFx0XHRcdGlmICggJCggdGhpcyApLmhhc0NsYXNzKCBcImNhbmNlbFwiICkgKSB7XG5cdFx0XHRcdFx0dmFsaWRhdG9yLmNhbmNlbFN1Ym1pdCA9IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBbGxvdyBzdXBwcmVzc2luZyB2YWxpZGF0aW9uIGJ5IGFkZGluZyB0aGUgaHRtbDUgZm9ybW5vdmFsaWRhdGUgYXR0cmlidXRlIHRvIHRoZSBzdWJtaXQgYnV0dG9uXG5cdFx0XHRcdGlmICggJCggdGhpcyApLmF0dHIoIFwiZm9ybW5vdmFsaWRhdGVcIiApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dmFsaWRhdG9yLmNhbmNlbFN1Ym1pdCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblxuXHRcdFx0Ly8gVmFsaWRhdGUgdGhlIGZvcm0gb24gc3VibWl0XG5cdFx0XHR0aGlzLm9uKCBcInN1Ym1pdC52YWxpZGF0ZVwiLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdGlmICggdmFsaWRhdG9yLnNldHRpbmdzLmRlYnVnICkge1xuXG5cdFx0XHRcdFx0Ly8gUHJldmVudCBmb3JtIHN1Ym1pdCB0byBiZSBhYmxlIHRvIHNlZSBjb25zb2xlIG91dHB1dFxuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnVuY3Rpb24gaGFuZGxlKCkge1xuXHRcdFx0XHRcdHZhciBoaWRkZW4sIHJlc3VsdDtcblxuXHRcdFx0XHRcdC8vIEluc2VydCBhIGhpZGRlbiBpbnB1dCBhcyBhIHJlcGxhY2VtZW50IGZvciB0aGUgbWlzc2luZyBzdWJtaXQgYnV0dG9uXG5cdFx0XHRcdFx0Ly8gVGhlIGhpZGRlbiBpbnB1dCBpcyBpbnNlcnRlZCBpbiB0d28gY2FzZXM6XG5cdFx0XHRcdFx0Ly8gICAtIEEgdXNlciBkZWZpbmVkIGEgYHN1Ym1pdEhhbmRsZXJgXG5cdFx0XHRcdFx0Ly8gICAtIFRoZXJlIHdhcyBhIHBlbmRpbmcgcmVxdWVzdCBkdWUgdG8gYHJlbW90ZWAgbWV0aG9kIGFuZCBgc3RvcFJlcXVlc3QoKWBcblx0XHRcdFx0XHQvLyAgICAgd2FzIGNhbGxlZCB0byBzdWJtaXQgdGhlIGZvcm0gaW4gY2FzZSBpdCdzIHZhbGlkXG5cdFx0XHRcdFx0aWYgKCB2YWxpZGF0b3Iuc3VibWl0QnV0dG9uICYmICggdmFsaWRhdG9yLnNldHRpbmdzLnN1Ym1pdEhhbmRsZXIgfHwgdmFsaWRhdG9yLmZvcm1TdWJtaXR0ZWQgKSApIHtcblx0XHRcdFx0XHRcdGhpZGRlbiA9ICQoIFwiPGlucHV0IHR5cGU9J2hpZGRlbicvPlwiIClcblx0XHRcdFx0XHRcdFx0LmF0dHIoIFwibmFtZVwiLCB2YWxpZGF0b3Iuc3VibWl0QnV0dG9uLm5hbWUgKVxuXHRcdFx0XHRcdFx0XHQudmFsKCAkKCB2YWxpZGF0b3Iuc3VibWl0QnV0dG9uICkudmFsKCkgKVxuXHRcdFx0XHRcdFx0XHQuYXBwZW5kVG8oIHZhbGlkYXRvci5jdXJyZW50Rm9ybSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggdmFsaWRhdG9yLnNldHRpbmdzLnN1Ym1pdEhhbmRsZXIgKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB2YWxpZGF0b3Iuc2V0dGluZ3Muc3VibWl0SGFuZGxlci5jYWxsKCB2YWxpZGF0b3IsIHZhbGlkYXRvci5jdXJyZW50Rm9ybSwgZXZlbnQgKTtcblx0XHRcdFx0XHRcdGlmICggaGlkZGVuICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFuZCBjbGVhbiB1cCBhZnRlcndhcmRzOyB0aGFua3MgdG8gbm8tYmxvY2stc2NvcGUsIGhpZGRlbiBjYW4gYmUgcmVmZXJlbmNlZFxuXHRcdFx0XHRcdFx0XHRoaWRkZW4ucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIHJlc3VsdCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByZXZlbnQgc3VibWl0IGZvciBpbnZhbGlkIGZvcm1zIG9yIGN1c3RvbSBzdWJtaXQgaGFuZGxlcnNcblx0XHRcdFx0aWYgKCB2YWxpZGF0b3IuY2FuY2VsU3VibWl0ICkge1xuXHRcdFx0XHRcdHZhbGlkYXRvci5jYW5jZWxTdWJtaXQgPSBmYWxzZTtcblx0XHRcdFx0XHRyZXR1cm4gaGFuZGxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB2YWxpZGF0b3IuZm9ybSgpICkge1xuXHRcdFx0XHRcdGlmICggdmFsaWRhdG9yLnBlbmRpbmdSZXF1ZXN0ICkge1xuXHRcdFx0XHRcdFx0dmFsaWRhdG9yLmZvcm1TdWJtaXR0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gaGFuZGxlKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsaWRhdG9yLmZvY3VzSW52YWxpZCgpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWxpZGF0b3I7XG5cdH0sXG5cblx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy92YWxpZC9cblx0dmFsaWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB2YWxpZCwgdmFsaWRhdG9yLCBlcnJvckxpc3Q7XG5cblx0XHRpZiAoICQoIHRoaXNbIDAgXSApLmlzKCBcImZvcm1cIiApICkge1xuXHRcdFx0dmFsaWQgPSB0aGlzLnZhbGlkYXRlKCkuZm9ybSgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlcnJvckxpc3QgPSBbXTtcblx0XHRcdHZhbGlkID0gdHJ1ZTtcblx0XHRcdHZhbGlkYXRvciA9ICQoIHRoaXNbIDAgXS5mb3JtICkudmFsaWRhdGUoKTtcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhbGlkID0gdmFsaWRhdG9yLmVsZW1lbnQoIHRoaXMgKSAmJiB2YWxpZDtcblx0XHRcdFx0aWYgKCAhdmFsaWQgKSB7XG5cdFx0XHRcdFx0ZXJyb3JMaXN0ID0gZXJyb3JMaXN0LmNvbmNhdCggdmFsaWRhdG9yLmVycm9yTGlzdCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHR2YWxpZGF0b3IuZXJyb3JMaXN0ID0gZXJyb3JMaXN0O1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsaWQ7XG5cdH0sXG5cblx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9ydWxlcy9cblx0cnVsZXM6IGZ1bmN0aW9uKCBjb21tYW5kLCBhcmd1bWVudCApIHtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXNbIDAgXSxcblx0XHRcdHNldHRpbmdzLCBzdGF0aWNSdWxlcywgZXhpc3RpbmdSdWxlcywgZGF0YSwgcGFyYW0sIGZpbHRlcmVkO1xuXG5cdFx0Ly8gSWYgbm90aGluZyBpcyBzZWxlY3RlZCwgcmV0dXJuIGVtcHR5IG9iamVjdDsgY2FuJ3QgY2hhaW4gYW55d2F5XG5cdFx0aWYgKCBlbGVtZW50ID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCAhZWxlbWVudC5mb3JtICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCBcImNvbnRlbnRlZGl0YWJsZVwiICkgKSB7XG5cdFx0XHRlbGVtZW50LmZvcm0gPSB0aGlzLmNsb3Nlc3QoIFwiZm9ybVwiIClbIDAgXTtcblx0XHRcdGVsZW1lbnQubmFtZSA9IHRoaXMuYXR0ciggXCJuYW1lXCIgKTtcblx0XHR9XG5cblx0XHRpZiAoIGVsZW1lbnQuZm9ybSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggY29tbWFuZCApIHtcblx0XHRcdHNldHRpbmdzID0gJC5kYXRhKCBlbGVtZW50LmZvcm0sIFwidmFsaWRhdG9yXCIgKS5zZXR0aW5ncztcblx0XHRcdHN0YXRpY1J1bGVzID0gc2V0dGluZ3MucnVsZXM7XG5cdFx0XHRleGlzdGluZ1J1bGVzID0gJC52YWxpZGF0b3Iuc3RhdGljUnVsZXMoIGVsZW1lbnQgKTtcblx0XHRcdHN3aXRjaCAoIGNvbW1hbmQgKSB7XG5cdFx0XHRjYXNlIFwiYWRkXCI6XG5cdFx0XHRcdCQuZXh0ZW5kKCBleGlzdGluZ1J1bGVzLCAkLnZhbGlkYXRvci5ub3JtYWxpemVSdWxlKCBhcmd1bWVudCApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIG1lc3NhZ2VzIGZyb20gcnVsZXMsIGJ1dCBhbGxvdyB0aGVtIHRvIGJlIHNldCBzZXBhcmF0ZWx5XG5cdFx0XHRcdGRlbGV0ZSBleGlzdGluZ1J1bGVzLm1lc3NhZ2VzO1xuXHRcdFx0XHRzdGF0aWNSdWxlc1sgZWxlbWVudC5uYW1lIF0gPSBleGlzdGluZ1J1bGVzO1xuXHRcdFx0XHRpZiAoIGFyZ3VtZW50Lm1lc3NhZ2VzICkge1xuXHRcdFx0XHRcdHNldHRpbmdzLm1lc3NhZ2VzWyBlbGVtZW50Lm5hbWUgXSA9ICQuZXh0ZW5kKCBzZXR0aW5ncy5tZXNzYWdlc1sgZWxlbWVudC5uYW1lIF0sIGFyZ3VtZW50Lm1lc3NhZ2VzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIFwicmVtb3ZlXCI6XG5cdFx0XHRcdGlmICggIWFyZ3VtZW50ICkge1xuXHRcdFx0XHRcdGRlbGV0ZSBzdGF0aWNSdWxlc1sgZWxlbWVudC5uYW1lIF07XG5cdFx0XHRcdFx0cmV0dXJuIGV4aXN0aW5nUnVsZXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZmlsdGVyZWQgPSB7fTtcblx0XHRcdFx0JC5lYWNoKCBhcmd1bWVudC5zcGxpdCggL1xccy8gKSwgZnVuY3Rpb24oIGluZGV4LCBtZXRob2QgKSB7XG5cdFx0XHRcdFx0ZmlsdGVyZWRbIG1ldGhvZCBdID0gZXhpc3RpbmdSdWxlc1sgbWV0aG9kIF07XG5cdFx0XHRcdFx0ZGVsZXRlIGV4aXN0aW5nUnVsZXNbIG1ldGhvZCBdO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiBmaWx0ZXJlZDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRkYXRhID0gJC52YWxpZGF0b3Iubm9ybWFsaXplUnVsZXMoXG5cdFx0JC5leHRlbmQoXG5cdFx0XHR7fSxcblx0XHRcdCQudmFsaWRhdG9yLmNsYXNzUnVsZXMoIGVsZW1lbnQgKSxcblx0XHRcdCQudmFsaWRhdG9yLmF0dHJpYnV0ZVJ1bGVzKCBlbGVtZW50ICksXG5cdFx0XHQkLnZhbGlkYXRvci5kYXRhUnVsZXMoIGVsZW1lbnQgKSxcblx0XHRcdCQudmFsaWRhdG9yLnN0YXRpY1J1bGVzKCBlbGVtZW50IClcblx0XHQpLCBlbGVtZW50ICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgcmVxdWlyZWQgaXMgYXQgZnJvbnRcblx0XHRpZiAoIGRhdGEucmVxdWlyZWQgKSB7XG5cdFx0XHRwYXJhbSA9IGRhdGEucmVxdWlyZWQ7XG5cdFx0XHRkZWxldGUgZGF0YS5yZXF1aXJlZDtcblx0XHRcdGRhdGEgPSAkLmV4dGVuZCggeyByZXF1aXJlZDogcGFyYW0gfSwgZGF0YSApO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSByZW1vdGUgaXMgYXQgYmFja1xuXHRcdGlmICggZGF0YS5yZW1vdGUgKSB7XG5cdFx0XHRwYXJhbSA9IGRhdGEucmVtb3RlO1xuXHRcdFx0ZGVsZXRlIGRhdGEucmVtb3RlO1xuXHRcdFx0ZGF0YSA9ICQuZXh0ZW5kKCBkYXRhLCB7IHJlbW90ZTogcGFyYW0gfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhO1xuXHR9XG59ICk7XG5cbi8vIEN1c3RvbSBzZWxlY3RvcnNcbiQuZXh0ZW5kKCAkLmV4cHIucHNldWRvcyB8fCAkLmV4cHJbIFwiOlwiIF0sIHtcdFx0Ly8gJ3x8ICQuZXhwclsgXCI6XCIgXScgaGVyZSBlbmFibGVzIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHRvIGpRdWVyeSAxLjcuIENhbiBiZSByZW1vdmVkIHdoZW4gZHJvcHBpbmcgalEgMS43Lnggc3VwcG9ydFxuXG5cdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvYmxhbmstc2VsZWN0b3IvXG5cdGJsYW5rOiBmdW5jdGlvbiggYSApIHtcblx0XHRyZXR1cm4gISQudHJpbSggXCJcIiArICQoIGEgKS52YWwoKSApO1xuXHR9LFxuXG5cdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvZmlsbGVkLXNlbGVjdG9yL1xuXHRmaWxsZWQ6IGZ1bmN0aW9uKCBhICkge1xuXHRcdHZhciB2YWwgPSAkKCBhICkudmFsKCk7XG5cdFx0cmV0dXJuIHZhbCAhPT0gbnVsbCAmJiAhISQudHJpbSggXCJcIiArIHZhbCApO1xuXHR9LFxuXG5cdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvdW5jaGVja2VkLXNlbGVjdG9yL1xuXHR1bmNoZWNrZWQ6IGZ1bmN0aW9uKCBhICkge1xuXHRcdHJldHVybiAhJCggYSApLnByb3AoIFwiY2hlY2tlZFwiICk7XG5cdH1cbn0gKTtcblxuLy8gQ29uc3RydWN0b3IgZm9yIHZhbGlkYXRvclxuJC52YWxpZGF0b3IgPSBmdW5jdGlvbiggb3B0aW9ucywgZm9ybSApIHtcblx0dGhpcy5zZXR0aW5ncyA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgJC52YWxpZGF0b3IuZGVmYXVsdHMsIG9wdGlvbnMgKTtcblx0dGhpcy5jdXJyZW50Rm9ybSA9IGZvcm07XG5cdHRoaXMuaW5pdCgpO1xufTtcblxuLy8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9qUXVlcnkudmFsaWRhdG9yLmZvcm1hdC9cbiQudmFsaWRhdG9yLmZvcm1hdCA9IGZ1bmN0aW9uKCBzb3VyY2UsIHBhcmFtcyApIHtcblx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAxICkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBhcmdzID0gJC5tYWtlQXJyYXkoIGFyZ3VtZW50cyApO1xuXHRcdFx0YXJncy51bnNoaWZ0KCBzb3VyY2UgKTtcblx0XHRcdHJldHVybiAkLnZhbGlkYXRvci5mb3JtYXQuYXBwbHkoIHRoaXMsIGFyZ3MgKTtcblx0XHR9O1xuXHR9XG5cdGlmICggcGFyYW1zID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIHNvdXJjZTtcblx0fVxuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIHBhcmFtcy5jb25zdHJ1Y3RvciAhPT0gQXJyYXkgICkge1xuXHRcdHBhcmFtcyA9ICQubWFrZUFycmF5KCBhcmd1bWVudHMgKS5zbGljZSggMSApO1xuXHR9XG5cdGlmICggcGFyYW1zLmNvbnN0cnVjdG9yICE9PSBBcnJheSApIHtcblx0XHRwYXJhbXMgPSBbIHBhcmFtcyBdO1xuXHR9XG5cdCQuZWFjaCggcGFyYW1zLCBmdW5jdGlvbiggaSwgbiApIHtcblx0XHRzb3VyY2UgPSBzb3VyY2UucmVwbGFjZSggbmV3IFJlZ0V4cCggXCJcXFxce1wiICsgaSArIFwiXFxcXH1cIiwgXCJnXCIgKSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbjtcblx0XHR9ICk7XG5cdH0gKTtcblx0cmV0dXJuIHNvdXJjZTtcbn07XG5cbiQuZXh0ZW5kKCAkLnZhbGlkYXRvciwge1xuXG5cdGRlZmF1bHRzOiB7XG5cdFx0bWVzc2FnZXM6IHt9LFxuXHRcdGdyb3Vwczoge30sXG5cdFx0cnVsZXM6IHt9LFxuXHRcdGVycm9yQ2xhc3M6IFwiZXJyb3JcIixcblx0XHRwZW5kaW5nQ2xhc3M6IFwicGVuZGluZ1wiLFxuXHRcdHZhbGlkQ2xhc3M6IFwidmFsaWRcIixcblx0XHRlcnJvckVsZW1lbnQ6IFwibGFiZWxcIixcblx0XHRmb2N1c0NsZWFudXA6IGZhbHNlLFxuXHRcdGZvY3VzSW52YWxpZDogdHJ1ZSxcblx0XHRlcnJvckNvbnRhaW5lcjogJCggW10gKSxcblx0XHRlcnJvckxhYmVsQ29udGFpbmVyOiAkKCBbXSApLFxuXHRcdG9uc3VibWl0OiB0cnVlLFxuXHRcdGlnbm9yZTogXCI6aGlkZGVuXCIsXG5cdFx0aWdub3JlVGl0bGU6IGZhbHNlLFxuXHRcdG9uZm9jdXNpbjogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHR0aGlzLmxhc3RBY3RpdmUgPSBlbGVtZW50O1xuXG5cdFx0XHQvLyBIaWRlIGVycm9yIGxhYmVsIGFuZCByZW1vdmUgZXJyb3IgY2xhc3Mgb24gZm9jdXMgaWYgZW5hYmxlZFxuXHRcdFx0aWYgKCB0aGlzLnNldHRpbmdzLmZvY3VzQ2xlYW51cCApIHtcblx0XHRcdFx0aWYgKCB0aGlzLnNldHRpbmdzLnVuaGlnaGxpZ2h0ICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQuY2FsbCggdGhpcywgZWxlbWVudCwgdGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzLCB0aGlzLnNldHRpbmdzLnZhbGlkQ2xhc3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmhpZGVUaGVzZSggdGhpcy5lcnJvcnNGb3IoIGVsZW1lbnQgKSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0b25mb2N1c291dDogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHRpZiAoICF0aGlzLmNoZWNrYWJsZSggZWxlbWVudCApICYmICggZWxlbWVudC5uYW1lIGluIHRoaXMuc3VibWl0dGVkIHx8ICF0aGlzLm9wdGlvbmFsKCBlbGVtZW50ICkgKSApIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50KCBlbGVtZW50ICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvbmtleXVwOiBmdW5jdGlvbiggZWxlbWVudCwgZXZlbnQgKSB7XG5cblx0XHRcdC8vIEF2b2lkIHJldmFsaWRhdGUgdGhlIGZpZWxkIHdoZW4gcHJlc3Npbmcgb25lIG9mIHRoZSBmb2xsb3dpbmcga2V5c1xuXHRcdFx0Ly8gU2hpZnQgICAgICAgPT4gMTZcblx0XHRcdC8vIEN0cmwgICAgICAgID0+IDE3XG5cdFx0XHQvLyBBbHQgICAgICAgICA9PiAxOFxuXHRcdFx0Ly8gQ2FwcyBsb2NrICAgPT4gMjBcblx0XHRcdC8vIEVuZCAgICAgICAgID0+IDM1XG5cdFx0XHQvLyBIb21lICAgICAgICA9PiAzNlxuXHRcdFx0Ly8gTGVmdCBhcnJvdyAgPT4gMzdcblx0XHRcdC8vIFVwIGFycm93ICAgID0+IDM4XG5cdFx0XHQvLyBSaWdodCBhcnJvdyA9PiAzOVxuXHRcdFx0Ly8gRG93biBhcnJvdyAgPT4gNDBcblx0XHRcdC8vIEluc2VydCAgICAgID0+IDQ1XG5cdFx0XHQvLyBOdW0gbG9jayAgICA9PiAxNDRcblx0XHRcdC8vIEFsdEdyIGtleSAgID0+IDIyNVxuXHRcdFx0dmFyIGV4Y2x1ZGVkS2V5cyA9IFtcblx0XHRcdFx0MTYsIDE3LCAxOCwgMjAsIDM1LCAzNiwgMzcsXG5cdFx0XHRcdDM4LCAzOSwgNDAsIDQ1LCAxNDQsIDIyNVxuXHRcdFx0XTtcblxuXHRcdFx0aWYgKCBldmVudC53aGljaCA9PT0gOSAmJiB0aGlzLmVsZW1lbnRWYWx1ZSggZWxlbWVudCApID09PSBcIlwiIHx8ICQuaW5BcnJheSggZXZlbnQua2V5Q29kZSwgZXhjbHVkZWRLZXlzICkgIT09IC0xICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50Lm5hbWUgaW4gdGhpcy5zdWJtaXR0ZWQgfHwgZWxlbWVudC5uYW1lIGluIHRoaXMuaW52YWxpZCApIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50KCBlbGVtZW50ICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvbmNsaWNrOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblxuXHRcdFx0Ly8gQ2xpY2sgb24gc2VsZWN0cywgcmFkaW9idXR0b25zIGFuZCBjaGVja2JveGVzXG5cdFx0XHRpZiAoIGVsZW1lbnQubmFtZSBpbiB0aGlzLnN1Ym1pdHRlZCApIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50KCBlbGVtZW50ICk7XG5cblx0XHRcdC8vIE9yIG9wdGlvbiBlbGVtZW50cywgY2hlY2sgcGFyZW50IHNlbGVjdCBpbiB0aGF0IGNhc2Vcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQucGFyZW50Tm9kZS5uYW1lIGluIHRoaXMuc3VibWl0dGVkICkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQoIGVsZW1lbnQucGFyZW50Tm9kZSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aGlnaGxpZ2h0OiBmdW5jdGlvbiggZWxlbWVudCwgZXJyb3JDbGFzcywgdmFsaWRDbGFzcyApIHtcblx0XHRcdGlmICggZWxlbWVudC50eXBlID09PSBcInJhZGlvXCIgKSB7XG5cdFx0XHRcdHRoaXMuZmluZEJ5TmFtZSggZWxlbWVudC5uYW1lICkuYWRkQ2xhc3MoIGVycm9yQ2xhc3MgKS5yZW1vdmVDbGFzcyggdmFsaWRDbGFzcyApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JCggZWxlbWVudCApLmFkZENsYXNzKCBlcnJvckNsYXNzICkucmVtb3ZlQ2xhc3MoIHZhbGlkQ2xhc3MgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHVuaGlnaGxpZ2h0OiBmdW5jdGlvbiggZWxlbWVudCwgZXJyb3JDbGFzcywgdmFsaWRDbGFzcyApIHtcblx0XHRcdGlmICggZWxlbWVudC50eXBlID09PSBcInJhZGlvXCIgKSB7XG5cdFx0XHRcdHRoaXMuZmluZEJ5TmFtZSggZWxlbWVudC5uYW1lICkucmVtb3ZlQ2xhc3MoIGVycm9yQ2xhc3MgKS5hZGRDbGFzcyggdmFsaWRDbGFzcyApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0JCggZWxlbWVudCApLnJlbW92ZUNsYXNzKCBlcnJvckNsYXNzICkuYWRkQ2xhc3MoIHZhbGlkQ2xhc3MgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9qUXVlcnkudmFsaWRhdG9yLnNldERlZmF1bHRzL1xuXHRzZXREZWZhdWx0czogZnVuY3Rpb24oIHNldHRpbmdzICkge1xuXHRcdCQuZXh0ZW5kKCAkLnZhbGlkYXRvci5kZWZhdWx0cywgc2V0dGluZ3MgKTtcblx0fSxcblxuXHRtZXNzYWdlczoge1xuXHRcdHJlcXVpcmVkOiBcIlRoaXMgZmllbGQgaXMgcmVxdWlyZWQuXCIsXG5cdFx0cmVtb3RlOiBcIlBsZWFzZSBmaXggdGhpcyBmaWVsZC5cIixcblx0XHRlbWFpbDogXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLlwiLFxuXHRcdHVybDogXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBVUkwuXCIsXG5cdFx0ZGF0ZTogXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBkYXRlLlwiLFxuXHRcdGRhdGVJU086IFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgZGF0ZSAoSVNPKS5cIixcblx0XHRudW1iZXI6IFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgbnVtYmVyLlwiLFxuXHRcdGRpZ2l0czogXCJQbGVhc2UgZW50ZXIgb25seSBkaWdpdHMuXCIsXG5cdFx0ZXF1YWxUbzogXCJQbGVhc2UgZW50ZXIgdGhlIHNhbWUgdmFsdWUgYWdhaW4uXCIsXG5cdFx0bWF4bGVuZ3RoOiAkLnZhbGlkYXRvci5mb3JtYXQoIFwiUGxlYXNlIGVudGVyIG5vIG1vcmUgdGhhbiB7MH0gY2hhcmFjdGVycy5cIiApLFxuXHRcdG1pbmxlbmd0aDogJC52YWxpZGF0b3IuZm9ybWF0KCBcIlBsZWFzZSBlbnRlciBhdCBsZWFzdCB7MH0gY2hhcmFjdGVycy5cIiApLFxuXHRcdHJhbmdlbGVuZ3RoOiAkLnZhbGlkYXRvci5mb3JtYXQoIFwiUGxlYXNlIGVudGVyIGEgdmFsdWUgYmV0d2VlbiB7MH0gYW5kIHsxfSBjaGFyYWN0ZXJzIGxvbmcuXCIgKSxcblx0XHRyYW5nZTogJC52YWxpZGF0b3IuZm9ybWF0KCBcIlBsZWFzZSBlbnRlciBhIHZhbHVlIGJldHdlZW4gezB9IGFuZCB7MX0uXCIgKSxcblx0XHRtYXg6ICQudmFsaWRhdG9yLmZvcm1hdCggXCJQbGVhc2UgZW50ZXIgYSB2YWx1ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gezB9LlwiICksXG5cdFx0bWluOiAkLnZhbGlkYXRvci5mb3JtYXQoIFwiUGxlYXNlIGVudGVyIGEgdmFsdWUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHswfS5cIiApLFxuXHRcdHN0ZXA6ICQudmFsaWRhdG9yLmZvcm1hdCggXCJQbGVhc2UgZW50ZXIgYSBtdWx0aXBsZSBvZiB7MH0uXCIgKVxuXHR9LFxuXG5cdGF1dG9DcmVhdGVSYW5nZXM6IGZhbHNlLFxuXG5cdHByb3RvdHlwZToge1xuXG5cdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmxhYmVsQ29udGFpbmVyID0gJCggdGhpcy5zZXR0aW5ncy5lcnJvckxhYmVsQ29udGFpbmVyICk7XG5cdFx0XHR0aGlzLmVycm9yQ29udGV4dCA9IHRoaXMubGFiZWxDb250YWluZXIubGVuZ3RoICYmIHRoaXMubGFiZWxDb250YWluZXIgfHwgJCggdGhpcy5jdXJyZW50Rm9ybSApO1xuXHRcdFx0dGhpcy5jb250YWluZXJzID0gJCggdGhpcy5zZXR0aW5ncy5lcnJvckNvbnRhaW5lciApLmFkZCggdGhpcy5zZXR0aW5ncy5lcnJvckxhYmVsQ29udGFpbmVyICk7XG5cdFx0XHR0aGlzLnN1Ym1pdHRlZCA9IHt9O1xuXHRcdFx0dGhpcy52YWx1ZUNhY2hlID0ge307XG5cdFx0XHR0aGlzLnBlbmRpbmdSZXF1ZXN0ID0gMDtcblx0XHRcdHRoaXMucGVuZGluZyA9IHt9O1xuXHRcdFx0dGhpcy5pbnZhbGlkID0ge307XG5cdFx0XHR0aGlzLnJlc2V0KCk7XG5cblx0XHRcdHZhciBncm91cHMgPSAoIHRoaXMuZ3JvdXBzID0ge30gKSxcblx0XHRcdFx0cnVsZXM7XG5cdFx0XHQkLmVhY2goIHRoaXMuc2V0dGluZ3MuZ3JvdXBzLCBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5zcGxpdCggL1xccy8gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQkLmVhY2goIHZhbHVlLCBmdW5jdGlvbiggaW5kZXgsIG5hbWUgKSB7XG5cdFx0XHRcdFx0Z3JvdXBzWyBuYW1lIF0gPSBrZXk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0gKTtcblx0XHRcdHJ1bGVzID0gdGhpcy5zZXR0aW5ncy5ydWxlcztcblx0XHRcdCQuZWFjaCggcnVsZXMsIGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRydWxlc1sga2V5IF0gPSAkLnZhbGlkYXRvci5ub3JtYWxpemVSdWxlKCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXG5cdFx0XHRmdW5jdGlvbiBkZWxlZ2F0ZSggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2V0IGZvcm0gZXhwYW5kbyBvbiBjb250ZW50ZWRpdGFibGVcblx0XHRcdFx0aWYgKCAhdGhpcy5mb3JtICYmIHRoaXMuaGFzQXR0cmlidXRlKCBcImNvbnRlbnRlZGl0YWJsZVwiICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5mb3JtID0gJCggdGhpcyApLmNsb3Nlc3QoIFwiZm9ybVwiIClbIDAgXTtcblx0XHRcdFx0XHR0aGlzLm5hbWUgPSAkKCB0aGlzICkuYXR0ciggXCJuYW1lXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB2YWxpZGF0b3IgPSAkLmRhdGEoIHRoaXMuZm9ybSwgXCJ2YWxpZGF0b3JcIiApLFxuXHRcdFx0XHRcdGV2ZW50VHlwZSA9IFwib25cIiArIGV2ZW50LnR5cGUucmVwbGFjZSggL152YWxpZGF0ZS8sIFwiXCIgKSxcblx0XHRcdFx0XHRzZXR0aW5ncyA9IHZhbGlkYXRvci5zZXR0aW5ncztcblx0XHRcdFx0aWYgKCBzZXR0aW5nc1sgZXZlbnRUeXBlIF0gJiYgISQoIHRoaXMgKS5pcyggc2V0dGluZ3MuaWdub3JlICkgKSB7XG5cdFx0XHRcdFx0c2V0dGluZ3NbIGV2ZW50VHlwZSBdLmNhbGwoIHZhbGlkYXRvciwgdGhpcywgZXZlbnQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQkKCB0aGlzLmN1cnJlbnRGb3JtIClcblx0XHRcdFx0Lm9uKCBcImZvY3VzaW4udmFsaWRhdGUgZm9jdXNvdXQudmFsaWRhdGUga2V5dXAudmFsaWRhdGVcIixcblx0XHRcdFx0XHRcIjp0ZXh0LCBbdHlwZT0ncGFzc3dvcmQnXSwgW3R5cGU9J2ZpbGUnXSwgc2VsZWN0LCB0ZXh0YXJlYSwgW3R5cGU9J251bWJlciddLCBbdHlwZT0nc2VhcmNoJ10sIFwiICtcblx0XHRcdFx0XHRcIlt0eXBlPSd0ZWwnXSwgW3R5cGU9J3VybCddLCBbdHlwZT0nZW1haWwnXSwgW3R5cGU9J2RhdGV0aW1lJ10sIFt0eXBlPSdkYXRlJ10sIFt0eXBlPSdtb250aCddLCBcIiArXG5cdFx0XHRcdFx0XCJbdHlwZT0nd2VlayddLCBbdHlwZT0ndGltZSddLCBbdHlwZT0nZGF0ZXRpbWUtbG9jYWwnXSwgW3R5cGU9J3JhbmdlJ10sIFt0eXBlPSdjb2xvciddLCBcIiArXG5cdFx0XHRcdFx0XCJbdHlwZT0ncmFkaW8nXSwgW3R5cGU9J2NoZWNrYm94J10sIFtjb250ZW50ZWRpdGFibGVdLCBbdHlwZT0nYnV0dG9uJ11cIiwgZGVsZWdhdGUgKVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSwgb2xkSUVcblx0XHRcdFx0Ly8gXCJzZWxlY3RcIiBpcyBwcm92aWRlZCBhcyBldmVudC50YXJnZXQgd2hlbiBjbGlja2luZyBhIG9wdGlvblxuXHRcdFx0XHQub24oIFwiY2xpY2sudmFsaWRhdGVcIiwgXCJzZWxlY3QsIG9wdGlvbiwgW3R5cGU9J3JhZGlvJ10sIFt0eXBlPSdjaGVja2JveCddXCIsIGRlbGVnYXRlICk7XG5cblx0XHRcdGlmICggdGhpcy5zZXR0aW5ncy5pbnZhbGlkSGFuZGxlciApIHtcblx0XHRcdFx0JCggdGhpcy5jdXJyZW50Rm9ybSApLm9uKCBcImludmFsaWQtZm9ybS52YWxpZGF0ZVwiLCB0aGlzLnNldHRpbmdzLmludmFsaWRIYW5kbGVyICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvVmFsaWRhdG9yLmZvcm0vXG5cdFx0Zm9ybTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmNoZWNrRm9ybSgpO1xuXHRcdFx0JC5leHRlbmQoIHRoaXMuc3VibWl0dGVkLCB0aGlzLmVycm9yTWFwICk7XG5cdFx0XHR0aGlzLmludmFsaWQgPSAkLmV4dGVuZCgge30sIHRoaXMuZXJyb3JNYXAgKTtcblx0XHRcdGlmICggIXRoaXMudmFsaWQoKSApIHtcblx0XHRcdFx0JCggdGhpcy5jdXJyZW50Rm9ybSApLnRyaWdnZXJIYW5kbGVyKCBcImludmFsaWQtZm9ybVwiLCBbIHRoaXMgXSApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zaG93RXJyb3JzKCk7XG5cdFx0XHRyZXR1cm4gdGhpcy52YWxpZCgpO1xuXHRcdH0sXG5cblx0XHRjaGVja0Zvcm06IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5wcmVwYXJlRm9ybSgpO1xuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBlbGVtZW50cyA9ICggdGhpcy5jdXJyZW50RWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzKCkgKTsgZWxlbWVudHNbIGkgXTsgaSsrICkge1xuXHRcdFx0XHR0aGlzLmNoZWNrKCBlbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy52YWxpZCgpO1xuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL1ZhbGlkYXRvci5lbGVtZW50L1xuXHRcdGVsZW1lbnQ6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIGNsZWFuRWxlbWVudCA9IHRoaXMuY2xlYW4oIGVsZW1lbnQgKSxcblx0XHRcdFx0Y2hlY2tFbGVtZW50ID0gdGhpcy52YWxpZGF0aW9uVGFyZ2V0Rm9yKCBjbGVhbkVsZW1lbnQgKSxcblx0XHRcdFx0diA9IHRoaXMsXG5cdFx0XHRcdHJlc3VsdCA9IHRydWUsXG5cdFx0XHRcdHJzLCBncm91cDtcblxuXHRcdFx0aWYgKCBjaGVja0VsZW1lbnQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuaW52YWxpZFsgY2xlYW5FbGVtZW50Lm5hbWUgXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMucHJlcGFyZUVsZW1lbnQoIGNoZWNrRWxlbWVudCApO1xuXHRcdFx0XHR0aGlzLmN1cnJlbnRFbGVtZW50cyA9ICQoIGNoZWNrRWxlbWVudCApO1xuXG5cdFx0XHRcdC8vIElmIHRoaXMgZWxlbWVudCBpcyBncm91cGVkLCB0aGVuIHZhbGlkYXRlIGFsbCBncm91cCBlbGVtZW50cyBhbHJlYWR5XG5cdFx0XHRcdC8vIGNvbnRhaW5pbmcgYSB2YWx1ZVxuXHRcdFx0XHRncm91cCA9IHRoaXMuZ3JvdXBzWyBjaGVja0VsZW1lbnQubmFtZSBdO1xuXHRcdFx0XHRpZiAoIGdyb3VwICkge1xuXHRcdFx0XHRcdCQuZWFjaCggdGhpcy5ncm91cHMsIGZ1bmN0aW9uKCBuYW1lLCB0ZXN0Z3JvdXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHRlc3Rncm91cCA9PT0gZ3JvdXAgJiYgbmFtZSAhPT0gY2hlY2tFbGVtZW50Lm5hbWUgKSB7XG5cdFx0XHRcdFx0XHRcdGNsZWFuRWxlbWVudCA9IHYudmFsaWRhdGlvblRhcmdldEZvciggdi5jbGVhbiggdi5maW5kQnlOYW1lKCBuYW1lICkgKSApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNsZWFuRWxlbWVudCAmJiBjbGVhbkVsZW1lbnQubmFtZSBpbiB2LmludmFsaWQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0di5jdXJyZW50RWxlbWVudHMucHVzaCggY2xlYW5FbGVtZW50ICk7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0ID0gdi5jaGVjayggY2xlYW5FbGVtZW50ICkgJiYgcmVzdWx0O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cnMgPSB0aGlzLmNoZWNrKCBjaGVja0VsZW1lbnQgKSAhPT0gZmFsc2U7XG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdCAmJiBycztcblx0XHRcdFx0aWYgKCBycyApIHtcblx0XHRcdFx0XHR0aGlzLmludmFsaWRbIGNoZWNrRWxlbWVudC5uYW1lIF0gPSBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmludmFsaWRbIGNoZWNrRWxlbWVudC5uYW1lIF0gPSB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCAhdGhpcy5udW1iZXJPZkludmFsaWRzKCkgKSB7XG5cblx0XHRcdFx0XHQvLyBIaWRlIGVycm9yIGNvbnRhaW5lcnMgb24gbGFzdCBlcnJvclxuXHRcdFx0XHRcdHRoaXMudG9IaWRlID0gdGhpcy50b0hpZGUuYWRkKCB0aGlzLmNvbnRhaW5lcnMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnNob3dFcnJvcnMoKTtcblxuXHRcdFx0XHQvLyBBZGQgYXJpYS1pbnZhbGlkIHN0YXR1cyBmb3Igc2NyZWVuIHJlYWRlcnNcblx0XHRcdFx0JCggZWxlbWVudCApLmF0dHIoIFwiYXJpYS1pbnZhbGlkXCIsICFycyApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL1ZhbGlkYXRvci5zaG93RXJyb3JzL1xuXHRcdHNob3dFcnJvcnM6IGZ1bmN0aW9uKCBlcnJvcnMgKSB7XG5cdFx0XHRpZiAoIGVycm9ycyApIHtcblx0XHRcdFx0dmFyIHZhbGlkYXRvciA9IHRoaXM7XG5cblx0XHRcdFx0Ly8gQWRkIGl0ZW1zIHRvIGVycm9yIGxpc3QgYW5kIG1hcFxuXHRcdFx0XHQkLmV4dGVuZCggdGhpcy5lcnJvck1hcCwgZXJyb3JzICk7XG5cdFx0XHRcdHRoaXMuZXJyb3JMaXN0ID0gJC5tYXAoIHRoaXMuZXJyb3JNYXAsIGZ1bmN0aW9uKCBtZXNzYWdlLCBuYW1lICkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRtZXNzYWdlOiBtZXNzYWdlLFxuXHRcdFx0XHRcdFx0ZWxlbWVudDogdmFsaWRhdG9yLmZpbmRCeU5hbWUoIG5hbWUgKVsgMCBdXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBpdGVtcyBmcm9tIHN1Y2Nlc3MgbGlzdFxuXHRcdFx0XHR0aGlzLnN1Y2Nlc3NMaXN0ID0gJC5ncmVwKCB0aGlzLnN1Y2Nlc3NMaXN0LCBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdFx0XHRyZXR1cm4gISggZWxlbWVudC5uYW1lIGluIGVycm9ycyApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuc2V0dGluZ3Muc2hvd0Vycm9ycyApIHtcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5zaG93RXJyb3JzLmNhbGwoIHRoaXMsIHRoaXMuZXJyb3JNYXAsIHRoaXMuZXJyb3JMaXN0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmRlZmF1bHRTaG93RXJyb3JzKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvVmFsaWRhdG9yLnJlc2V0Rm9ybS9cblx0XHRyZXNldEZvcm06IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAkLmZuLnJlc2V0Rm9ybSApIHtcblx0XHRcdFx0JCggdGhpcy5jdXJyZW50Rm9ybSApLnJlc2V0Rm9ybSgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5pbnZhbGlkID0ge307XG5cdFx0XHR0aGlzLnN1Ym1pdHRlZCA9IHt9O1xuXHRcdFx0dGhpcy5wcmVwYXJlRm9ybSgpO1xuXHRcdFx0dGhpcy5oaWRlRXJyb3JzKCk7XG5cdFx0XHR2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzKClcblx0XHRcdFx0LnJlbW92ZURhdGEoIFwicHJldmlvdXNWYWx1ZVwiIClcblx0XHRcdFx0LnJlbW92ZUF0dHIoIFwiYXJpYS1pbnZhbGlkXCIgKTtcblxuXHRcdFx0dGhpcy5yZXNldEVsZW1lbnRzKCBlbGVtZW50cyApO1xuXHRcdH0sXG5cblx0XHRyZXNldEVsZW1lbnRzOiBmdW5jdGlvbiggZWxlbWVudHMgKSB7XG5cdFx0XHR2YXIgaTtcblxuXHRcdFx0aWYgKCB0aGlzLnNldHRpbmdzLnVuaGlnaGxpZ2h0ICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgZWxlbWVudHNbIGkgXTsgaSsrICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQuY2FsbCggdGhpcywgZWxlbWVudHNbIGkgXSxcblx0XHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuZXJyb3JDbGFzcywgXCJcIiApO1xuXHRcdFx0XHRcdHRoaXMuZmluZEJ5TmFtZSggZWxlbWVudHNbIGkgXS5uYW1lICkucmVtb3ZlQ2xhc3MoIHRoaXMuc2V0dGluZ3MudmFsaWRDbGFzcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50c1xuXHRcdFx0XHRcdC5yZW1vdmVDbGFzcyggdGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzIClcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIHRoaXMuc2V0dGluZ3MudmFsaWRDbGFzcyApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRudW1iZXJPZkludmFsaWRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLm9iamVjdExlbmd0aCggdGhpcy5pbnZhbGlkICk7XG5cdFx0fSxcblxuXHRcdG9iamVjdExlbmd0aDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdC8qIGpzaGludCB1bnVzZWQ6IGZhbHNlICovXG5cdFx0XHR2YXIgY291bnQgPSAwLFxuXHRcdFx0XHRpO1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cblx0XHRcdFx0Ly8gVGhpcyBjaGVjayBhbGxvd3MgY291bnRpbmcgZWxlbWVudHMgd2l0aCBlbXB0eSBlcnJvclxuXHRcdFx0XHQvLyBtZXNzYWdlIGFzIGludmFsaWQgZWxlbWVudHNcblx0XHRcdFx0aWYgKCBvYmpbIGkgXSAhPT0gdW5kZWZpbmVkICYmIG9ialsgaSBdICE9PSBudWxsICYmIG9ialsgaSBdICE9PSBmYWxzZSApIHtcblx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY291bnQ7XG5cdFx0fSxcblxuXHRcdGhpZGVFcnJvcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5oaWRlVGhlc2UoIHRoaXMudG9IaWRlICk7XG5cdFx0fSxcblxuXHRcdGhpZGVUaGVzZTogZnVuY3Rpb24oIGVycm9ycyApIHtcblx0XHRcdGVycm9ycy5ub3QoIHRoaXMuY29udGFpbmVycyApLnRleHQoIFwiXCIgKTtcblx0XHRcdHRoaXMuYWRkV3JhcHBlciggZXJyb3JzICkuaGlkZSgpO1xuXHRcdH0sXG5cblx0XHR2YWxpZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zaXplKCkgPT09IDA7XG5cdFx0fSxcblxuXHRcdHNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZXJyb3JMaXN0Lmxlbmd0aDtcblx0XHR9LFxuXG5cdFx0Zm9jdXNJbnZhbGlkOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggdGhpcy5zZXR0aW5ncy5mb2N1c0ludmFsaWQgKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0JCggdGhpcy5maW5kTGFzdEFjdGl2ZSgpIHx8IHRoaXMuZXJyb3JMaXN0Lmxlbmd0aCAmJiB0aGlzLmVycm9yTGlzdFsgMCBdLmVsZW1lbnQgfHwgW10gKVxuXHRcdFx0XHRcdC5maWx0ZXIoIFwiOnZpc2libGVcIiApXG5cdFx0XHRcdFx0LmZvY3VzKClcblxuXHRcdFx0XHRcdC8vIE1hbnVhbGx5IHRyaWdnZXIgZm9jdXNpbiBldmVudDsgd2l0aG91dCBpdCwgZm9jdXNpbiBoYW5kbGVyIGlzbid0IGNhbGxlZCwgZmluZExhc3RBY3RpdmUgd29uJ3QgaGF2ZSBhbnl0aGluZyB0byBmaW5kXG5cdFx0XHRcdFx0LnRyaWdnZXIoIFwiZm9jdXNpblwiICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gSWdub3JlIElFIHRocm93aW5nIGVycm9ycyB3aGVuIGZvY3VzaW5nIGhpZGRlbiBlbGVtZW50c1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGZpbmRMYXN0QWN0aXZlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBsYXN0QWN0aXZlID0gdGhpcy5sYXN0QWN0aXZlO1xuXHRcdFx0cmV0dXJuIGxhc3RBY3RpdmUgJiYgJC5ncmVwKCB0aGlzLmVycm9yTGlzdCwgZnVuY3Rpb24oIG4gKSB7XG5cdFx0XHRcdHJldHVybiBuLmVsZW1lbnQubmFtZSA9PT0gbGFzdEFjdGl2ZS5uYW1lO1xuXHRcdFx0fSApLmxlbmd0aCA9PT0gMSAmJiBsYXN0QWN0aXZlO1xuXHRcdH0sXG5cblx0XHRlbGVtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdmFsaWRhdG9yID0gdGhpcyxcblx0XHRcdFx0cnVsZXNDYWNoZSA9IHt9O1xuXG5cdFx0XHQvLyBTZWxlY3QgYWxsIHZhbGlkIGlucHV0cyBpbnNpZGUgdGhlIGZvcm0gKG5vIHN1Ym1pdCBvciByZXNldCBidXR0b25zKVxuXHRcdFx0cmV0dXJuICQoIHRoaXMuY3VycmVudEZvcm0gKVxuXHRcdFx0LmZpbmQoIFwiaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIFtjb250ZW50ZWRpdGFibGVdXCIgKVxuXHRcdFx0Lm5vdCggXCI6c3VibWl0LCA6cmVzZXQsIDppbWFnZSwgOmRpc2FibGVkXCIgKVxuXHRcdFx0Lm5vdCggdGhpcy5zZXR0aW5ncy5pZ25vcmUgKVxuXHRcdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBuYW1lID0gdGhpcy5uYW1lIHx8ICQoIHRoaXMgKS5hdHRyKCBcIm5hbWVcIiApOyAvLyBGb3IgY29udGVudGVkaXRhYmxlXG5cdFx0XHRcdGlmICggIW5hbWUgJiYgdmFsaWRhdG9yLnNldHRpbmdzLmRlYnVnICYmIHdpbmRvdy5jb25zb2xlICkge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiJW8gaGFzIG5vIG5hbWUgYXNzaWduZWRcIiwgdGhpcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGZvcm0gZXhwYW5kbyBvbiBjb250ZW50ZWRpdGFibGVcblx0XHRcdFx0aWYgKCB0aGlzLmhhc0F0dHJpYnV0ZSggXCJjb250ZW50ZWRpdGFibGVcIiApICkge1xuXHRcdFx0XHRcdHRoaXMuZm9ybSA9ICQoIHRoaXMgKS5jbG9zZXN0KCBcImZvcm1cIiApWyAwIF07XG5cdFx0XHRcdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNlbGVjdCBvbmx5IHRoZSBmaXJzdCBlbGVtZW50IGZvciBlYWNoIG5hbWUsIGFuZCBvbmx5IHRob3NlIHdpdGggcnVsZXMgc3BlY2lmaWVkXG5cdFx0XHRcdGlmICggbmFtZSBpbiBydWxlc0NhY2hlIHx8ICF2YWxpZGF0b3Iub2JqZWN0TGVuZ3RoKCAkKCB0aGlzICkucnVsZXMoKSApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJ1bGVzQ2FjaGVbIG5hbWUgXSA9IHRydWU7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSApO1xuXHRcdH0sXG5cblx0XHRjbGVhbjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuICQoIHNlbGVjdG9yIClbIDAgXTtcblx0XHR9LFxuXG5cdFx0ZXJyb3JzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBlcnJvckNsYXNzID0gdGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzLnNwbGl0KCBcIiBcIiApLmpvaW4oIFwiLlwiICk7XG5cdFx0XHRyZXR1cm4gJCggdGhpcy5zZXR0aW5ncy5lcnJvckVsZW1lbnQgKyBcIi5cIiArIGVycm9yQ2xhc3MsIHRoaXMuZXJyb3JDb250ZXh0ICk7XG5cdFx0fSxcblxuXHRcdHJlc2V0SW50ZXJuYWxzOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuc3VjY2Vzc0xpc3QgPSBbXTtcblx0XHRcdHRoaXMuZXJyb3JMaXN0ID0gW107XG5cdFx0XHR0aGlzLmVycm9yTWFwID0ge307XG5cdFx0XHR0aGlzLnRvU2hvdyA9ICQoIFtdICk7XG5cdFx0XHR0aGlzLnRvSGlkZSA9ICQoIFtdICk7XG5cdFx0fSxcblxuXHRcdHJlc2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMucmVzZXRJbnRlcm5hbHMoKTtcblx0XHRcdHRoaXMuY3VycmVudEVsZW1lbnRzID0gJCggW10gKTtcblx0XHR9LFxuXG5cdFx0cHJlcGFyZUZvcm06IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZXNldCgpO1xuXHRcdFx0dGhpcy50b0hpZGUgPSB0aGlzLmVycm9ycygpLmFkZCggdGhpcy5jb250YWluZXJzICk7XG5cdFx0fSxcblxuXHRcdHByZXBhcmVFbGVtZW50OiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHRcdHRoaXMudG9IaWRlID0gdGhpcy5lcnJvcnNGb3IoIGVsZW1lbnQgKTtcblx0XHR9LFxuXG5cdFx0ZWxlbWVudFZhbHVlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdHZhciAkZWxlbWVudCA9ICQoIGVsZW1lbnQgKSxcblx0XHRcdFx0dHlwZSA9IGVsZW1lbnQudHlwZSxcblx0XHRcdFx0dmFsLCBpZHg7XG5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJyYWRpb1wiIHx8IHR5cGUgPT09IFwiY2hlY2tib3hcIiApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZmluZEJ5TmFtZSggZWxlbWVudC5uYW1lICkuZmlsdGVyKCBcIjpjaGVja2VkXCIgKS52YWwoKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIGVsZW1lbnQudmFsaWRpdHkgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtZW50LnZhbGlkaXR5LmJhZElucHV0ID8gXCJOYU5cIiA6ICRlbGVtZW50LnZhbCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW1lbnQuaGFzQXR0cmlidXRlKCBcImNvbnRlbnRlZGl0YWJsZVwiICkgKSB7XG5cdFx0XHRcdHZhbCA9ICRlbGVtZW50LnRleHQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9ICRlbGVtZW50LnZhbCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwiZmlsZVwiICkge1xuXG5cdFx0XHRcdC8vIE1vZGVybiBicm93c2VyIChjaHJvbWUgJiBzYWZhcmkpXG5cdFx0XHRcdGlmICggdmFsLnN1YnN0ciggMCwgMTIgKSA9PT0gXCJDOlxcXFxmYWtlcGF0aFxcXFxcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsLnN1YnN0ciggMTIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExlZ2FjeSBicm93c2Vyc1xuXHRcdFx0XHQvLyBVbml4LWJhc2VkIHBhdGhcblx0XHRcdFx0aWR4ID0gdmFsLmxhc3RJbmRleE9mKCBcIi9cIiApO1xuXHRcdFx0XHRpZiAoIGlkeCA+PSAwICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWwuc3Vic3RyKCBpZHggKyAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXaW5kb3dzLWJhc2VkIHBhdGhcblx0XHRcdFx0aWR4ID0gdmFsLmxhc3RJbmRleE9mKCBcIlxcXFxcIiApO1xuXHRcdFx0XHRpZiAoIGlkeCA+PSAwICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWwuc3Vic3RyKCBpZHggKyAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBKdXN0IHRoZSBmaWxlIG5hbWVcblx0XHRcdFx0cmV0dXJuIHZhbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRyZXR1cm4gdmFsLnJlcGxhY2UoIC9cXHIvZywgXCJcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9LFxuXG5cdFx0Y2hlY2s6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0ZWxlbWVudCA9IHRoaXMudmFsaWRhdGlvblRhcmdldEZvciggdGhpcy5jbGVhbiggZWxlbWVudCApICk7XG5cblx0XHRcdHZhciBydWxlcyA9ICQoIGVsZW1lbnQgKS5ydWxlcygpLFxuXHRcdFx0XHRydWxlc0NvdW50ID0gJC5tYXAoIHJ1bGVzLCBmdW5jdGlvbiggbiwgaSApIHtcblx0XHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdFx0fSApLmxlbmd0aCxcblx0XHRcdFx0ZGVwZW5kZW5jeU1pc21hdGNoID0gZmFsc2UsXG5cdFx0XHRcdHZhbCA9IHRoaXMuZWxlbWVudFZhbHVlKCBlbGVtZW50ICksXG5cdFx0XHRcdHJlc3VsdCwgbWV0aG9kLCBydWxlLCBub3JtYWxpemVyO1xuXG5cdFx0XHQvLyBQcmlvcml0aXplIHRoZSBsb2NhbCBub3JtYWxpemVyIGRlZmluZWQgZm9yIHRoaXMgZWxlbWVudCBvdmVyIHRoZSBnbG9iYWwgb25lXG5cdFx0XHQvLyBpZiB0aGUgZm9ybWVyIGV4aXN0cywgb3RoZXJ3aXNlIHVzZXIgdGhlIGdsb2JhbCBvbmUgaW4gY2FzZSBpdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR5cGVvZiBydWxlcy5ub3JtYWxpemVyID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHRcdG5vcm1hbGl6ZXIgPSBydWxlcy5ub3JtYWxpemVyO1xuXHRcdFx0fSBlbHNlIGlmIChcdHR5cGVvZiB0aGlzLnNldHRpbmdzLm5vcm1hbGl6ZXIgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0XHRcdFx0bm9ybWFsaXplciA9IHRoaXMuc2V0dGluZ3Mubm9ybWFsaXplcjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgbm9ybWFsaXplciBpcyBkZWZpbmVkLCB0aGVuIGNhbGwgaXQgdG8gcmV0cmVpdmUgdGhlIGNoYW5nZWQgdmFsdWUgaW5zdGVhZFxuXHRcdFx0Ly8gb2YgdXNpbmcgdGhlIHJlYWwgb25lLlxuXHRcdFx0Ly8gTm90ZSB0aGF0IGB0aGlzYCBpbiB0aGUgbm9ybWFsaXplciBpcyBgZWxlbWVudGAuXG5cdFx0XHRpZiAoIG5vcm1hbGl6ZXIgKSB7XG5cdFx0XHRcdHZhbCA9IG5vcm1hbGl6ZXIuY2FsbCggZWxlbWVudCwgdmFsICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlb2YgdmFsICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlIG5vcm1hbGl6ZXIgc2hvdWxkIHJldHVybiBhIHN0cmluZyB2YWx1ZS5cIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRGVsZXRlIHRoZSBub3JtYWxpemVyIGZyb20gcnVsZXMgdG8gYXZvaWQgdHJlYXRpbmcgaXQgYXMgYSBwcmUtZGVmaW5lZCBtZXRob2QuXG5cdFx0XHRcdGRlbGV0ZSBydWxlcy5ub3JtYWxpemVyO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBtZXRob2QgaW4gcnVsZXMgKSB7XG5cdFx0XHRcdHJ1bGUgPSB7IG1ldGhvZDogbWV0aG9kLCBwYXJhbWV0ZXJzOiBydWxlc1sgbWV0aG9kIF0gfTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXN1bHQgPSAkLnZhbGlkYXRvci5tZXRob2RzWyBtZXRob2QgXS5jYWxsKCB0aGlzLCB2YWwsIGVsZW1lbnQsIHJ1bGUucGFyYW1ldGVycyApO1xuXG5cdFx0XHRcdFx0Ly8gSWYgYSBtZXRob2QgaW5kaWNhdGVzIHRoYXQgdGhlIGZpZWxkIGlzIG9wdGlvbmFsIGFuZCB0aGVyZWZvcmUgdmFsaWQsXG5cdFx0XHRcdFx0Ly8gZG9uJ3QgbWFyayBpdCBhcyB2YWxpZCB3aGVuIHRoZXJlIGFyZSBubyBvdGhlciBydWxlc1xuXHRcdFx0XHRcdGlmICggcmVzdWx0ID09PSBcImRlcGVuZGVuY3ktbWlzbWF0Y2hcIiAmJiBydWxlc0NvdW50ID09PSAxICkge1xuXHRcdFx0XHRcdFx0ZGVwZW5kZW5jeU1pc21hdGNoID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkZXBlbmRlbmN5TWlzbWF0Y2ggPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcmVzdWx0ID09PSBcInBlbmRpbmdcIiApIHtcblx0XHRcdFx0XHRcdHRoaXMudG9IaWRlID0gdGhpcy50b0hpZGUubm90KCB0aGlzLmVycm9yc0ZvciggZWxlbWVudCApICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCAhcmVzdWx0ICkge1xuXHRcdFx0XHRcdFx0dGhpcy5mb3JtYXRBbmRBZGQoIGVsZW1lbnQsIHJ1bGUgKTtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5zZXR0aW5ncy5kZWJ1ZyAmJiB3aW5kb3cuY29uc29sZSApIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCBcIkV4Y2VwdGlvbiBvY2N1cnJlZCB3aGVuIGNoZWNraW5nIGVsZW1lbnQgXCIgKyBlbGVtZW50LmlkICsgXCIsIGNoZWNrIHRoZSAnXCIgKyBydWxlLm1ldGhvZCArIFwiJyBtZXRob2QuXCIsIGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBlIGluc3RhbmNlb2YgVHlwZUVycm9yICkge1xuXHRcdFx0XHRcdFx0ZS5tZXNzYWdlICs9IFwiLiAgRXhjZXB0aW9uIG9jY3VycmVkIHdoZW4gY2hlY2tpbmcgZWxlbWVudCBcIiArIGVsZW1lbnQuaWQgKyBcIiwgY2hlY2sgdGhlICdcIiArIHJ1bGUubWV0aG9kICsgXCInIG1ldGhvZC5cIjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGRlcGVuZGVuY3lNaXNtYXRjaCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLm9iamVjdExlbmd0aCggcnVsZXMgKSApIHtcblx0XHRcdFx0dGhpcy5zdWNjZXNzTGlzdC5wdXNoKCBlbGVtZW50ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjdXN0b20gbWVzc2FnZSBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgYW5kIHZhbGlkYXRpb24gbWV0aG9kXG5cdFx0Ly8gc3BlY2lmaWVkIGluIHRoZSBlbGVtZW50J3MgSFRNTDUgZGF0YSBhdHRyaWJ1dGVcblx0XHQvLyByZXR1cm4gdGhlIGdlbmVyaWMgbWVzc2FnZSBpZiBwcmVzZW50IGFuZCBubyBtZXRob2Qgc3BlY2lmaWMgbWVzc2FnZSBpcyBwcmVzZW50XG5cdFx0Y3VzdG9tRGF0YU1lc3NhZ2U6IGZ1bmN0aW9uKCBlbGVtZW50LCBtZXRob2QgKSB7XG5cdFx0XHRyZXR1cm4gJCggZWxlbWVudCApLmRhdGEoIFwibXNnXCIgKyBtZXRob2QuY2hhckF0KCAwICkudG9VcHBlckNhc2UoKSArXG5cdFx0XHRcdG1ldGhvZC5zdWJzdHJpbmcoIDEgKS50b0xvd2VyQ2FzZSgpICkgfHwgJCggZWxlbWVudCApLmRhdGEoIFwibXNnXCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjdXN0b20gbWVzc2FnZSBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgbmFtZSBhbmQgdmFsaWRhdGlvbiBtZXRob2Rcblx0XHRjdXN0b21NZXNzYWdlOiBmdW5jdGlvbiggbmFtZSwgbWV0aG9kICkge1xuXHRcdFx0dmFyIG0gPSB0aGlzLnNldHRpbmdzLm1lc3NhZ2VzWyBuYW1lIF07XG5cdFx0XHRyZXR1cm4gbSAmJiAoIG0uY29uc3RydWN0b3IgPT09IFN0cmluZyA/IG0gOiBtWyBtZXRob2QgXSApO1xuXHRcdH0sXG5cblx0XHQvLyBSZXR1cm4gdGhlIGZpcnN0IGRlZmluZWQgYXJndW1lbnQsIGFsbG93aW5nIGVtcHR5IHN0cmluZ3Ncblx0XHRmaW5kRGVmaW5lZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYXJndW1lbnRzWyBpIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gYXJndW1lbnRzWyBpIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fSxcblxuXHRcdC8vIFRoZSBzZWNvbmQgcGFyYW1ldGVyICdydWxlJyB1c2VkIHRvIGJlIGEgc3RyaW5nLCBhbmQgZXh0ZW5kZWQgdG8gYW4gb2JqZWN0IGxpdGVyYWxcblx0XHQvLyBvZiB0aGUgZm9sbG93aW5nIGZvcm06XG5cdFx0Ly8gcnVsZSA9IHtcblx0XHQvLyAgICAgbWV0aG9kOiBcIm1ldGhvZCBuYW1lXCIsXG5cdFx0Ly8gICAgIHBhcmFtZXRlcnM6IFwidGhlIGdpdmVuIG1ldGhvZCBwYXJhbWV0ZXJzXCJcblx0XHQvLyB9XG5cdFx0Ly9cblx0XHQvLyBUaGUgb2xkIGJlaGF2aW9yIHN0aWxsIHN1cHBvcnRlZCwga2VwdCB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGhcblx0XHQvLyBvbGQgY29kZSwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHRcdGRlZmF1bHRNZXNzYWdlOiBmdW5jdGlvbiggZWxlbWVudCwgcnVsZSApIHtcblx0XHRcdGlmICggdHlwZW9mIHJ1bGUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdHJ1bGUgPSB7IG1ldGhvZDogcnVsZSB9O1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbWVzc2FnZSA9IHRoaXMuZmluZERlZmluZWQoXG5cdFx0XHRcdFx0dGhpcy5jdXN0b21NZXNzYWdlKCBlbGVtZW50Lm5hbWUsIHJ1bGUubWV0aG9kICksXG5cdFx0XHRcdFx0dGhpcy5jdXN0b21EYXRhTWVzc2FnZSggZWxlbWVudCwgcnVsZS5tZXRob2QgKSxcblxuXHRcdFx0XHRcdC8vICd0aXRsZScgaXMgbmV2ZXIgdW5kZWZpbmVkLCBzbyBoYW5kbGUgZW1wdHkgc3RyaW5nIGFzIHVuZGVmaW5lZFxuXHRcdFx0XHRcdCF0aGlzLnNldHRpbmdzLmlnbm9yZVRpdGxlICYmIGVsZW1lbnQudGl0bGUgfHwgdW5kZWZpbmVkLFxuXHRcdFx0XHRcdCQudmFsaWRhdG9yLm1lc3NhZ2VzWyBydWxlLm1ldGhvZCBdLFxuXHRcdFx0XHRcdFwiPHN0cm9uZz5XYXJuaW5nOiBObyBtZXNzYWdlIGRlZmluZWQgZm9yIFwiICsgZWxlbWVudC5uYW1lICsgXCI8L3N0cm9uZz5cIlxuXHRcdFx0XHQpLFxuXHRcdFx0XHR0aGVyZWdleCA9IC9cXCQ/XFx7KFxcZCspXFx9L2c7XG5cdFx0XHRpZiAoIHR5cGVvZiBtZXNzYWdlID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdFx0XHRcdG1lc3NhZ2UgPSBtZXNzYWdlLmNhbGwoIHRoaXMsIHJ1bGUucGFyYW1ldGVycywgZWxlbWVudCApO1xuXHRcdFx0fSBlbHNlIGlmICggdGhlcmVnZXgudGVzdCggbWVzc2FnZSApICkge1xuXHRcdFx0XHRtZXNzYWdlID0gJC52YWxpZGF0b3IuZm9ybWF0KCBtZXNzYWdlLnJlcGxhY2UoIHRoZXJlZ2V4LCBcInskMX1cIiApLCBydWxlLnBhcmFtZXRlcnMgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1lc3NhZ2U7XG5cdFx0fSxcblxuXHRcdGZvcm1hdEFuZEFkZDogZnVuY3Rpb24oIGVsZW1lbnQsIHJ1bGUgKSB7XG5cdFx0XHR2YXIgbWVzc2FnZSA9IHRoaXMuZGVmYXVsdE1lc3NhZ2UoIGVsZW1lbnQsIHJ1bGUgKTtcblxuXHRcdFx0dGhpcy5lcnJvckxpc3QucHVzaCgge1xuXHRcdFx0XHRtZXNzYWdlOiBtZXNzYWdlLFxuXHRcdFx0XHRlbGVtZW50OiBlbGVtZW50LFxuXHRcdFx0XHRtZXRob2Q6IHJ1bGUubWV0aG9kXG5cdFx0XHR9ICk7XG5cblx0XHRcdHRoaXMuZXJyb3JNYXBbIGVsZW1lbnQubmFtZSBdID0gbWVzc2FnZTtcblx0XHRcdHRoaXMuc3VibWl0dGVkWyBlbGVtZW50Lm5hbWUgXSA9IG1lc3NhZ2U7XG5cdFx0fSxcblxuXHRcdGFkZFdyYXBwZXI6IGZ1bmN0aW9uKCB0b1RvZ2dsZSApIHtcblx0XHRcdGlmICggdGhpcy5zZXR0aW5ncy53cmFwcGVyICkge1xuXHRcdFx0XHR0b1RvZ2dsZSA9IHRvVG9nZ2xlLmFkZCggdG9Ub2dnbGUucGFyZW50KCB0aGlzLnNldHRpbmdzLndyYXBwZXIgKSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRvVG9nZ2xlO1xuXHRcdH0sXG5cblx0XHRkZWZhdWx0U2hvd0Vycm9yczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSwgZWxlbWVudHMsIGVycm9yO1xuXHRcdFx0Zm9yICggaSA9IDA7IHRoaXMuZXJyb3JMaXN0WyBpIF07IGkrKyApIHtcblx0XHRcdFx0ZXJyb3IgPSB0aGlzLmVycm9yTGlzdFsgaSBdO1xuXHRcdFx0XHRpZiAoIHRoaXMuc2V0dGluZ3MuaGlnaGxpZ2h0ICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuaGlnaGxpZ2h0LmNhbGwoIHRoaXMsIGVycm9yLmVsZW1lbnQsIHRoaXMuc2V0dGluZ3MuZXJyb3JDbGFzcywgdGhpcy5zZXR0aW5ncy52YWxpZENsYXNzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5zaG93TGFiZWwoIGVycm9yLmVsZW1lbnQsIGVycm9yLm1lc3NhZ2UgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5lcnJvckxpc3QubGVuZ3RoICkge1xuXHRcdFx0XHR0aGlzLnRvU2hvdyA9IHRoaXMudG9TaG93LmFkZCggdGhpcy5jb250YWluZXJzICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuc2V0dGluZ3Muc3VjY2VzcyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IHRoaXMuc3VjY2Vzc0xpc3RbIGkgXTsgaSsrICkge1xuXHRcdFx0XHRcdHRoaXMuc2hvd0xhYmVsKCB0aGlzLnN1Y2Nlc3NMaXN0WyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLnNldHRpbmdzLnVuaGlnaGxpZ2h0ICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgZWxlbWVudHMgPSB0aGlzLnZhbGlkRWxlbWVudHMoKTsgZWxlbWVudHNbIGkgXTsgaSsrICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MudW5oaWdobGlnaHQuY2FsbCggdGhpcywgZWxlbWVudHNbIGkgXSwgdGhpcy5zZXR0aW5ncy5lcnJvckNsYXNzLCB0aGlzLnNldHRpbmdzLnZhbGlkQ2xhc3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy50b0hpZGUgPSB0aGlzLnRvSGlkZS5ub3QoIHRoaXMudG9TaG93ICk7XG5cdFx0XHR0aGlzLmhpZGVFcnJvcnMoKTtcblx0XHRcdHRoaXMuYWRkV3JhcHBlciggdGhpcy50b1Nob3cgKS5zaG93KCk7XG5cdFx0fSxcblxuXHRcdHZhbGlkRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY3VycmVudEVsZW1lbnRzLm5vdCggdGhpcy5pbnZhbGlkRWxlbWVudHMoKSApO1xuXHRcdH0sXG5cblx0XHRpbnZhbGlkRWxlbWVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICQoIHRoaXMuZXJyb3JMaXN0ICkubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudDtcblx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0c2hvd0xhYmVsOiBmdW5jdGlvbiggZWxlbWVudCwgbWVzc2FnZSApIHtcblx0XHRcdHZhciBwbGFjZSwgZ3JvdXAsIGVycm9ySUQsIHYsXG5cdFx0XHRcdGVycm9yID0gdGhpcy5lcnJvcnNGb3IoIGVsZW1lbnQgKSxcblx0XHRcdFx0ZWxlbWVudElEID0gdGhpcy5pZE9yTmFtZSggZWxlbWVudCApLFxuXHRcdFx0XHRkZXNjcmliZWRCeSA9ICQoIGVsZW1lbnQgKS5hdHRyKCBcImFyaWEtZGVzY3JpYmVkYnlcIiApO1xuXG5cdFx0XHRpZiAoIGVycm9yLmxlbmd0aCApIHtcblxuXHRcdFx0XHQvLyBSZWZyZXNoIGVycm9yL3N1Y2Nlc3MgY2xhc3Ncblx0XHRcdFx0ZXJyb3IucmVtb3ZlQ2xhc3MoIHRoaXMuc2V0dGluZ3MudmFsaWRDbGFzcyApLmFkZENsYXNzKCB0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MgKTtcblxuXHRcdFx0XHQvLyBSZXBsYWNlIG1lc3NhZ2Ugb24gZXhpc3RpbmcgbGFiZWxcblx0XHRcdFx0ZXJyb3IuaHRtbCggbWVzc2FnZSApO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBDcmVhdGUgZXJyb3IgZWxlbWVudFxuXHRcdFx0XHRlcnJvciA9ICQoIFwiPFwiICsgdGhpcy5zZXR0aW5ncy5lcnJvckVsZW1lbnQgKyBcIj5cIiApXG5cdFx0XHRcdFx0LmF0dHIoIFwiaWRcIiwgZWxlbWVudElEICsgXCItZXJyb3JcIiApXG5cdFx0XHRcdFx0LmFkZENsYXNzKCB0aGlzLnNldHRpbmdzLmVycm9yQ2xhc3MgKVxuXHRcdFx0XHRcdC5odG1sKCBtZXNzYWdlIHx8IFwiXCIgKTtcblxuXHRcdFx0XHQvLyBNYWludGFpbiByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgdG8gYmUgcGxhY2VkIGludG8gdGhlIERPTVxuXHRcdFx0XHRwbGFjZSA9IGVycm9yO1xuXHRcdFx0XHRpZiAoIHRoaXMuc2V0dGluZ3Mud3JhcHBlciApIHtcblxuXHRcdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGUgZWxlbWVudCBpcyB2aXNpYmxlLCBldmVuIGluIElFXG5cdFx0XHRcdFx0Ly8gYWN0dWFsbHkgc2hvd2luZyB0aGUgd3JhcHBlZCBlbGVtZW50IGlzIGhhbmRsZWQgZWxzZXdoZXJlXG5cdFx0XHRcdFx0cGxhY2UgPSBlcnJvci5oaWRlKCkuc2hvdygpLndyYXAoIFwiPFwiICsgdGhpcy5zZXR0aW5ncy53cmFwcGVyICsgXCIvPlwiICkucGFyZW50KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0aGlzLmxhYmVsQ29udGFpbmVyLmxlbmd0aCApIHtcblx0XHRcdFx0XHR0aGlzLmxhYmVsQ29udGFpbmVyLmFwcGVuZCggcGxhY2UgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggdGhpcy5zZXR0aW5ncy5lcnJvclBsYWNlbWVudCApIHtcblx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLmVycm9yUGxhY2VtZW50LmNhbGwoIHRoaXMsIHBsYWNlLCAkKCBlbGVtZW50ICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwbGFjZS5pbnNlcnRBZnRlciggZWxlbWVudCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTGluayBlcnJvciBiYWNrIHRvIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggZXJyb3IuaXMoIFwibGFiZWxcIiApICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIGVycm9yIGlzIGEgbGFiZWwsIHRoZW4gYXNzb2NpYXRlIHVzaW5nICdmb3InXG5cdFx0XHRcdFx0ZXJyb3IuYXR0ciggXCJmb3JcIiwgZWxlbWVudElEICk7XG5cblx0XHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBpcyBub3QgYSBjaGlsZCBvZiBhbiBhc3NvY2lhdGVkIGxhYmVsLCB0aGVuIGl0J3MgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0Ly8gdG8gZXhwbGljaXRseSBhcHBseSBhcmlhLWRlc2NyaWJlZGJ5XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGVycm9yLnBhcmVudHMoIFwibGFiZWxbZm9yPSdcIiArIHRoaXMuZXNjYXBlQ3NzTWV0YSggZWxlbWVudElEICkgKyBcIiddXCIgKS5sZW5ndGggPT09IDAgKSB7XG5cdFx0XHRcdFx0ZXJyb3JJRCA9IGVycm9yLmF0dHIoIFwiaWRcIiApO1xuXG5cdFx0XHRcdFx0Ly8gUmVzcGVjdCBleGlzdGluZyBub24tZXJyb3IgYXJpYS1kZXNjcmliZWRieVxuXHRcdFx0XHRcdGlmICggIWRlc2NyaWJlZEJ5ICkge1xuXHRcdFx0XHRcdFx0ZGVzY3JpYmVkQnkgPSBlcnJvcklEO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICFkZXNjcmliZWRCeS5tYXRjaCggbmV3IFJlZ0V4cCggXCJcXFxcYlwiICsgdGhpcy5lc2NhcGVDc3NNZXRhKCBlcnJvcklEICkgKyBcIlxcXFxiXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBBZGQgdG8gZW5kIG9mIGxpc3QgaWYgbm90IGFscmVhZHkgcHJlc2VudFxuXHRcdFx0XHRcdFx0ZGVzY3JpYmVkQnkgKz0gXCIgXCIgKyBlcnJvcklEO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQkKCBlbGVtZW50ICkuYXR0ciggXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIGRlc2NyaWJlZEJ5ICk7XG5cblx0XHRcdFx0XHQvLyBJZiB0aGlzIGVsZW1lbnQgaXMgZ3JvdXBlZCwgdGhlbiBhc3NpZ24gdG8gYWxsIGVsZW1lbnRzIGluIHRoZSBzYW1lIGdyb3VwXG5cdFx0XHRcdFx0Z3JvdXAgPSB0aGlzLmdyb3Vwc1sgZWxlbWVudC5uYW1lIF07XG5cdFx0XHRcdFx0aWYgKCBncm91cCApIHtcblx0XHRcdFx0XHRcdHYgPSB0aGlzO1xuXHRcdFx0XHRcdFx0JC5lYWNoKCB2Lmdyb3VwcywgZnVuY3Rpb24oIG5hbWUsIHRlc3Rncm91cCApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCB0ZXN0Z3JvdXAgPT09IGdyb3VwICkge1xuXHRcdFx0XHRcdFx0XHRcdCQoIFwiW25hbWU9J1wiICsgdi5lc2NhcGVDc3NNZXRhKCBuYW1lICkgKyBcIiddXCIsIHYuY3VycmVudEZvcm0gKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmF0dHIoIFwiYXJpYS1kZXNjcmliZWRieVwiLCBlcnJvci5hdHRyKCBcImlkXCIgKSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFtZXNzYWdlICYmIHRoaXMuc2V0dGluZ3Muc3VjY2VzcyApIHtcblx0XHRcdFx0ZXJyb3IudGV4dCggXCJcIiApO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiB0aGlzLnNldHRpbmdzLnN1Y2Nlc3MgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0ZXJyb3IuYWRkQ2xhc3MoIHRoaXMuc2V0dGluZ3Muc3VjY2VzcyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuc2V0dGluZ3Muc3VjY2VzcyggZXJyb3IsIGVsZW1lbnQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy50b1Nob3cgPSB0aGlzLnRvU2hvdy5hZGQoIGVycm9yICk7XG5cdFx0fSxcblxuXHRcdGVycm9yc0ZvcjogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgbmFtZSA9IHRoaXMuZXNjYXBlQ3NzTWV0YSggdGhpcy5pZE9yTmFtZSggZWxlbWVudCApICksXG5cdFx0XHRcdGRlc2NyaWJlciA9ICQoIGVsZW1lbnQgKS5hdHRyKCBcImFyaWEtZGVzY3JpYmVkYnlcIiApLFxuXHRcdFx0XHRzZWxlY3RvciA9IFwibGFiZWxbZm9yPSdcIiArIG5hbWUgKyBcIiddLCBsYWJlbFtmb3I9J1wiICsgbmFtZSArIFwiJ10gKlwiO1xuXG5cdFx0XHQvLyAnYXJpYS1kZXNjcmliZWRieScgc2hvdWxkIGRpcmVjdGx5IHJlZmVyZW5jZSB0aGUgZXJyb3IgZWxlbWVudFxuXHRcdFx0aWYgKCBkZXNjcmliZXIgKSB7XG5cdFx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3IgKyBcIiwgI1wiICsgdGhpcy5lc2NhcGVDc3NNZXRhKCBkZXNjcmliZXIgKVxuXHRcdFx0XHRcdC5yZXBsYWNlKCAvXFxzKy9nLCBcIiwgI1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzXG5cdFx0XHRcdC5lcnJvcnMoKVxuXHRcdFx0XHQuZmlsdGVyKCBzZWxlY3RvciApO1xuXHRcdH0sXG5cblx0XHQvLyBTZWUgaHR0cHM6Ly9hcGkuanF1ZXJ5LmNvbS9jYXRlZ29yeS9zZWxlY3RvcnMvLCBmb3IgQ1NTXG5cdFx0Ly8gbWV0YS1jaGFyYWN0ZXJzIHRoYXQgc2hvdWxkIGJlIGVzY2FwZWQgaW4gb3JkZXIgdG8gYmUgdXNlZCB3aXRoIEpRdWVyeVxuXHRcdC8vIGFzIGEgbGl0ZXJhbCBwYXJ0IG9mIGEgbmFtZS9pZCBvciBhbnkgc2VsZWN0b3IuXG5cdFx0ZXNjYXBlQ3NzTWV0YTogZnVuY3Rpb24oIHN0cmluZyApIHtcblx0XHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggLyhbXFxcXCFcIiMkJSYnKCkqKywuLzo7PD0+P0BcXFtcXF1eYHt8fX5dKS9nLCBcIlxcXFwkMVwiICk7XG5cdFx0fSxcblxuXHRcdGlkT3JOYW1lOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdHJldHVybiB0aGlzLmdyb3Vwc1sgZWxlbWVudC5uYW1lIF0gfHwgKCB0aGlzLmNoZWNrYWJsZSggZWxlbWVudCApID8gZWxlbWVudC5uYW1lIDogZWxlbWVudC5pZCB8fCBlbGVtZW50Lm5hbWUgKTtcblx0XHR9LFxuXG5cdFx0dmFsaWRhdGlvblRhcmdldEZvcjogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cblx0XHRcdC8vIElmIHJhZGlvL2NoZWNrYm94LCB2YWxpZGF0ZSBmaXJzdCBlbGVtZW50IGluIGdyb3VwIGluc3RlYWRcblx0XHRcdGlmICggdGhpcy5jaGVja2FibGUoIGVsZW1lbnQgKSApIHtcblx0XHRcdFx0ZWxlbWVudCA9IHRoaXMuZmluZEJ5TmFtZSggZWxlbWVudC5uYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFsd2F5cyBhcHBseSBpZ25vcmUgZmlsdGVyXG5cdFx0XHRyZXR1cm4gJCggZWxlbWVudCApLm5vdCggdGhpcy5zZXR0aW5ncy5pZ25vcmUgKVsgMCBdO1xuXHRcdH0sXG5cblx0XHRjaGVja2FibGU6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0cmV0dXJuICggL3JhZGlvfGNoZWNrYm94L2kgKS50ZXN0KCBlbGVtZW50LnR5cGUgKTtcblx0XHR9LFxuXG5cdFx0ZmluZEJ5TmFtZTogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0XHRyZXR1cm4gJCggdGhpcy5jdXJyZW50Rm9ybSApLmZpbmQoIFwiW25hbWU9J1wiICsgdGhpcy5lc2NhcGVDc3NNZXRhKCBuYW1lICkgKyBcIiddXCIgKTtcblx0XHR9LFxuXG5cdFx0Z2V0TGVuZ3RoOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQgKSB7XG5cdFx0XHRzd2l0Y2ggKCBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRjYXNlIFwic2VsZWN0XCI6XG5cdFx0XHRcdHJldHVybiAkKCBcIm9wdGlvbjpzZWxlY3RlZFwiLCBlbGVtZW50ICkubGVuZ3RoO1xuXHRcdFx0Y2FzZSBcImlucHV0XCI6XG5cdFx0XHRcdGlmICggdGhpcy5jaGVja2FibGUoIGVsZW1lbnQgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5maW5kQnlOYW1lKCBlbGVtZW50Lm5hbWUgKS5maWx0ZXIoIFwiOmNoZWNrZWRcIiApLmxlbmd0aDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlLmxlbmd0aDtcblx0XHR9LFxuXG5cdFx0ZGVwZW5kOiBmdW5jdGlvbiggcGFyYW0sIGVsZW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kZXBlbmRUeXBlc1sgdHlwZW9mIHBhcmFtIF0gPyB0aGlzLmRlcGVuZFR5cGVzWyB0eXBlb2YgcGFyYW0gXSggcGFyYW0sIGVsZW1lbnQgKSA6IHRydWU7XG5cdFx0fSxcblxuXHRcdGRlcGVuZFR5cGVzOiB7XG5cdFx0XHRcImJvb2xlYW5cIjogZnVuY3Rpb24oIHBhcmFtICkge1xuXHRcdFx0XHRyZXR1cm4gcGFyYW07XG5cdFx0XHR9LFxuXHRcdFx0XCJzdHJpbmdcIjogZnVuY3Rpb24oIHBhcmFtLCBlbGVtZW50ICkge1xuXHRcdFx0XHRyZXR1cm4gISEkKCBwYXJhbSwgZWxlbWVudC5mb3JtICkubGVuZ3RoO1xuXHRcdFx0fSxcblx0XHRcdFwiZnVuY3Rpb25cIjogZnVuY3Rpb24oIHBhcmFtLCBlbGVtZW50ICkge1xuXHRcdFx0XHRyZXR1cm4gcGFyYW0oIGVsZW1lbnQgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0b3B0aW9uYWw6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIHZhbCA9IHRoaXMuZWxlbWVudFZhbHVlKCBlbGVtZW50ICk7XG5cdFx0XHRyZXR1cm4gISQudmFsaWRhdG9yLm1ldGhvZHMucmVxdWlyZWQuY2FsbCggdGhpcywgdmFsLCBlbGVtZW50ICkgJiYgXCJkZXBlbmRlbmN5LW1pc21hdGNoXCI7XG5cdFx0fSxcblxuXHRcdHN0YXJ0UmVxdWVzdDogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHRpZiAoICF0aGlzLnBlbmRpbmdbIGVsZW1lbnQubmFtZSBdICkge1xuXHRcdFx0XHR0aGlzLnBlbmRpbmdSZXF1ZXN0Kys7XG5cdFx0XHRcdCQoIGVsZW1lbnQgKS5hZGRDbGFzcyggdGhpcy5zZXR0aW5ncy5wZW5kaW5nQ2xhc3MgKTtcblx0XHRcdFx0dGhpcy5wZW5kaW5nWyBlbGVtZW50Lm5hbWUgXSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHN0b3BSZXF1ZXN0OiBmdW5jdGlvbiggZWxlbWVudCwgdmFsaWQgKSB7XG5cdFx0XHR0aGlzLnBlbmRpbmdSZXF1ZXN0LS07XG5cblx0XHRcdC8vIFNvbWV0aW1lcyBzeW5jaHJvbml6YXRpb24gZmFpbHMsIG1ha2Ugc3VyZSBwZW5kaW5nUmVxdWVzdCBpcyBuZXZlciA8IDBcblx0XHRcdGlmICggdGhpcy5wZW5kaW5nUmVxdWVzdCA8IDAgKSB7XG5cdFx0XHRcdHRoaXMucGVuZGluZ1JlcXVlc3QgPSAwO1xuXHRcdFx0fVxuXHRcdFx0ZGVsZXRlIHRoaXMucGVuZGluZ1sgZWxlbWVudC5uYW1lIF07XG5cdFx0XHQkKCBlbGVtZW50ICkucmVtb3ZlQ2xhc3MoIHRoaXMuc2V0dGluZ3MucGVuZGluZ0NsYXNzICk7XG5cdFx0XHRpZiAoIHZhbGlkICYmIHRoaXMucGVuZGluZ1JlcXVlc3QgPT09IDAgJiYgdGhpcy5mb3JtU3VibWl0dGVkICYmIHRoaXMuZm9ybSgpICkge1xuXHRcdFx0XHQkKCB0aGlzLmN1cnJlbnRGb3JtICkuc3VibWl0KCk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSBoaWRkZW4gaW5wdXQgdGhhdCB3YXMgdXNlZCBhcyBhIHJlcGxhY2VtZW50IGZvciB0aGVcblx0XHRcdFx0Ly8gbWlzc2luZyBzdWJtaXQgYnV0dG9uLiBUaGUgaGlkZGVuIGlucHV0IGlzIGFkZGVkIGJ5IGBoYW5kbGUoKWBcblx0XHRcdFx0Ly8gdG8gZW5zdXJlIHRoYXQgdGhlIHZhbHVlIG9mIHRoZSB1c2VkIHN1Ym1pdCBidXR0b24gaXMgcGFzc2VkIG9uXG5cdFx0XHRcdC8vIGZvciBzY3JpcHRlZCBzdWJtaXRzIHRyaWdnZXJlZCBieSB0aGlzIG1ldGhvZFxuXHRcdFx0XHRpZiAoIHRoaXMuc3VibWl0QnV0dG9uICkge1xuXHRcdFx0XHRcdCQoIFwiaW5wdXQ6aGlkZGVuW25hbWU9J1wiICsgdGhpcy5zdWJtaXRCdXR0b24ubmFtZSArIFwiJ11cIiwgdGhpcy5jdXJyZW50Rm9ybSApLnJlbW92ZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5mb3JtU3VibWl0dGVkID0gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCAhdmFsaWQgJiYgdGhpcy5wZW5kaW5nUmVxdWVzdCA9PT0gMCAmJiB0aGlzLmZvcm1TdWJtaXR0ZWQgKSB7XG5cdFx0XHRcdCQoIHRoaXMuY3VycmVudEZvcm0gKS50cmlnZ2VySGFuZGxlciggXCJpbnZhbGlkLWZvcm1cIiwgWyB0aGlzIF0gKTtcblx0XHRcdFx0dGhpcy5mb3JtU3VibWl0dGVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHByZXZpb3VzVmFsdWU6IGZ1bmN0aW9uKCBlbGVtZW50LCBtZXRob2QgKSB7XG5cdFx0XHRtZXRob2QgPSB0eXBlb2YgbWV0aG9kID09PSBcInN0cmluZ1wiICYmIG1ldGhvZCB8fCBcInJlbW90ZVwiO1xuXG5cdFx0XHRyZXR1cm4gJC5kYXRhKCBlbGVtZW50LCBcInByZXZpb3VzVmFsdWVcIiApIHx8ICQuZGF0YSggZWxlbWVudCwgXCJwcmV2aW91c1ZhbHVlXCIsIHtcblx0XHRcdFx0b2xkOiBudWxsLFxuXHRcdFx0XHR2YWxpZDogdHJ1ZSxcblx0XHRcdFx0bWVzc2FnZTogdGhpcy5kZWZhdWx0TWVzc2FnZSggZWxlbWVudCwgeyBtZXRob2Q6IG1ldGhvZCB9IClcblx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gQ2xlYW5zIHVwIGFsbCBmb3JtcyBhbmQgZWxlbWVudHMsIHJlbW92ZXMgdmFsaWRhdG9yLXNwZWNpZmljIGV2ZW50c1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5yZXNldEZvcm0oKTtcblxuXHRcdFx0JCggdGhpcy5jdXJyZW50Rm9ybSApXG5cdFx0XHRcdC5vZmYoIFwiLnZhbGlkYXRlXCIgKVxuXHRcdFx0XHQucmVtb3ZlRGF0YSggXCJ2YWxpZGF0b3JcIiApXG5cdFx0XHRcdC5maW5kKCBcIi52YWxpZGF0ZS1lcXVhbFRvLWJsdXJcIiApXG5cdFx0XHRcdFx0Lm9mZiggXCIudmFsaWRhdGUtZXF1YWxUb1wiIClcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIFwidmFsaWRhdGUtZXF1YWxUby1ibHVyXCIgKTtcblx0XHR9XG5cblx0fSxcblxuXHRjbGFzc1J1bGVTZXR0aW5nczoge1xuXHRcdHJlcXVpcmVkOiB7IHJlcXVpcmVkOiB0cnVlIH0sXG5cdFx0ZW1haWw6IHsgZW1haWw6IHRydWUgfSxcblx0XHR1cmw6IHsgdXJsOiB0cnVlIH0sXG5cdFx0ZGF0ZTogeyBkYXRlOiB0cnVlIH0sXG5cdFx0ZGF0ZUlTTzogeyBkYXRlSVNPOiB0cnVlIH0sXG5cdFx0bnVtYmVyOiB7IG51bWJlcjogdHJ1ZSB9LFxuXHRcdGRpZ2l0czogeyBkaWdpdHM6IHRydWUgfSxcblx0XHRjcmVkaXRjYXJkOiB7IGNyZWRpdGNhcmQ6IHRydWUgfVxuXHR9LFxuXG5cdGFkZENsYXNzUnVsZXM6IGZ1bmN0aW9uKCBjbGFzc05hbWUsIHJ1bGVzICkge1xuXHRcdGlmICggY2xhc3NOYW1lLmNvbnN0cnVjdG9yID09PSBTdHJpbmcgKSB7XG5cdFx0XHR0aGlzLmNsYXNzUnVsZVNldHRpbmdzWyBjbGFzc05hbWUgXSA9IHJ1bGVzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQkLmV4dGVuZCggdGhpcy5jbGFzc1J1bGVTZXR0aW5ncywgY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9LFxuXG5cdGNsYXNzUnVsZXM6IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdHZhciBydWxlcyA9IHt9LFxuXHRcdFx0Y2xhc3NlcyA9ICQoIGVsZW1lbnQgKS5hdHRyKCBcImNsYXNzXCIgKTtcblxuXHRcdGlmICggY2xhc3NlcyApIHtcblx0XHRcdCQuZWFjaCggY2xhc3Nlcy5zcGxpdCggXCIgXCIgKSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyBpbiAkLnZhbGlkYXRvci5jbGFzc1J1bGVTZXR0aW5ncyApIHtcblx0XHRcdFx0XHQkLmV4dGVuZCggcnVsZXMsICQudmFsaWRhdG9yLmNsYXNzUnVsZVNldHRpbmdzWyB0aGlzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcnVsZXM7XG5cdH0sXG5cblx0bm9ybWFsaXplQXR0cmlidXRlUnVsZTogZnVuY3Rpb24oIHJ1bGVzLCB0eXBlLCBtZXRob2QsIHZhbHVlICkge1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgdmFsdWUgdG8gYSBudW1iZXIgZm9yIG51bWJlciBpbnB1dHMsIGFuZCBmb3IgdGV4dCBmb3IgYmFja3dhcmRzIGNvbXBhYmlsaXR5XG5cdFx0Ly8gYWxsb3dzIHR5cGU9XCJkYXRlXCIgYW5kIG90aGVycyB0byBiZSBjb21wYXJlZCBhcyBzdHJpbmdzXG5cdFx0aWYgKCAvbWlufG1heHxzdGVwLy50ZXN0KCBtZXRob2QgKSAmJiAoIHR5cGUgPT09IG51bGwgfHwgL251bWJlcnxyYW5nZXx0ZXh0Ly50ZXN0KCB0eXBlICkgKSApIHtcblx0XHRcdHZhbHVlID0gTnVtYmVyKCB2YWx1ZSApO1xuXG5cdFx0XHQvLyBTdXBwb3J0IE9wZXJhIE1pbmksIHdoaWNoIHJldHVybnMgTmFOIGZvciB1bmRlZmluZWQgbWlubGVuZ3RoXG5cdFx0XHRpZiAoIGlzTmFOKCB2YWx1ZSApICkge1xuXHRcdFx0XHR2YWx1ZSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlIHx8IHZhbHVlID09PSAwICkge1xuXHRcdFx0cnVsZXNbIG1ldGhvZCBdID0gdmFsdWU7XG5cdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gbWV0aG9kICYmIHR5cGUgIT09IFwicmFuZ2VcIiApIHtcblxuXHRcdFx0Ly8gRXhjZXB0aW9uOiB0aGUganF1ZXJ5IHZhbGlkYXRlICdyYW5nZScgbWV0aG9kXG5cdFx0XHQvLyBkb2VzIG5vdCB0ZXN0IGZvciB0aGUgaHRtbDUgJ3JhbmdlJyB0eXBlXG5cdFx0XHRydWxlc1sgbWV0aG9kIF0gPSB0cnVlO1xuXHRcdH1cblx0fSxcblxuXHRhdHRyaWJ1dGVSdWxlczogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dmFyIHJ1bGVzID0ge30sXG5cdFx0XHQkZWxlbWVudCA9ICQoIGVsZW1lbnQgKSxcblx0XHRcdHR5cGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSxcblx0XHRcdG1ldGhvZCwgdmFsdWU7XG5cblx0XHRmb3IgKCBtZXRob2QgaW4gJC52YWxpZGF0b3IubWV0aG9kcyApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBmb3IgPGlucHV0IHJlcXVpcmVkPiBpbiBib3RoIGh0bWw1IGFuZCBvbGRlciBicm93c2Vyc1xuXHRcdFx0aWYgKCBtZXRob2QgPT09IFwicmVxdWlyZWRcIiApIHtcblx0XHRcdFx0dmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggbWV0aG9kICk7XG5cblx0XHRcdFx0Ly8gU29tZSBicm93c2VycyByZXR1cm4gYW4gZW1wdHkgc3RyaW5nIGZvciB0aGUgcmVxdWlyZWQgYXR0cmlidXRlXG5cdFx0XHRcdC8vIGFuZCBub24tSFRNTDUgYnJvd3NlcnMgbWlnaHQgaGF2ZSByZXF1aXJlZD1cIlwiIG1hcmt1cFxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcIlwiICkge1xuXHRcdFx0XHRcdHZhbHVlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEZvcmNlIG5vbi1IVE1MNSBicm93c2VycyB0byByZXR1cm4gYm9vbFxuXHRcdFx0XHR2YWx1ZSA9ICEhdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWx1ZSA9ICRlbGVtZW50LmF0dHIoIG1ldGhvZCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm5vcm1hbGl6ZUF0dHJpYnV0ZVJ1bGUoIHJ1bGVzLCB0eXBlLCBtZXRob2QsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gJ21heGxlbmd0aCcgbWF5IGJlIHJldHVybmVkIGFzIC0xLCAyMTQ3NDgzNjQ3ICggSUUgKSBhbmQgNTI0Mjg4ICggc2FmYXJpICkgZm9yIHRleHQgaW5wdXRzXG5cdFx0aWYgKCBydWxlcy5tYXhsZW5ndGggJiYgLy0xfDIxNDc0ODM2NDd8NTI0Mjg4Ly50ZXN0KCBydWxlcy5tYXhsZW5ndGggKSApIHtcblx0XHRcdGRlbGV0ZSBydWxlcy5tYXhsZW5ndGg7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJ1bGVzO1xuXHR9LFxuXG5cdGRhdGFSdWxlczogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dmFyIHJ1bGVzID0ge30sXG5cdFx0XHQkZWxlbWVudCA9ICQoIGVsZW1lbnQgKSxcblx0XHRcdHR5cGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSxcblx0XHRcdG1ldGhvZCwgdmFsdWU7XG5cblx0XHRmb3IgKCBtZXRob2QgaW4gJC52YWxpZGF0b3IubWV0aG9kcyApIHtcblx0XHRcdHZhbHVlID0gJGVsZW1lbnQuZGF0YSggXCJydWxlXCIgKyBtZXRob2QuY2hhckF0KCAwICkudG9VcHBlckNhc2UoKSArIG1ldGhvZC5zdWJzdHJpbmcoIDEgKS50b0xvd2VyQ2FzZSgpICk7XG5cdFx0XHR0aGlzLm5vcm1hbGl6ZUF0dHJpYnV0ZVJ1bGUoIHJ1bGVzLCB0eXBlLCBtZXRob2QsIHZhbHVlICk7XG5cdFx0fVxuXHRcdHJldHVybiBydWxlcztcblx0fSxcblxuXHRzdGF0aWNSdWxlczogZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0dmFyIHJ1bGVzID0ge30sXG5cdFx0XHR2YWxpZGF0b3IgPSAkLmRhdGEoIGVsZW1lbnQuZm9ybSwgXCJ2YWxpZGF0b3JcIiApO1xuXG5cdFx0aWYgKCB2YWxpZGF0b3Iuc2V0dGluZ3MucnVsZXMgKSB7XG5cdFx0XHRydWxlcyA9ICQudmFsaWRhdG9yLm5vcm1hbGl6ZVJ1bGUoIHZhbGlkYXRvci5zZXR0aW5ncy5ydWxlc1sgZWxlbWVudC5uYW1lIF0gKSB8fCB7fTtcblx0XHR9XG5cdFx0cmV0dXJuIHJ1bGVzO1xuXHR9LFxuXG5cdG5vcm1hbGl6ZVJ1bGVzOiBmdW5jdGlvbiggcnVsZXMsIGVsZW1lbnQgKSB7XG5cblx0XHQvLyBIYW5kbGUgZGVwZW5kZW5jeSBjaGVja1xuXHRcdCQuZWFjaCggcnVsZXMsIGZ1bmN0aW9uKCBwcm9wLCB2YWwgKSB7XG5cblx0XHRcdC8vIElnbm9yZSBydWxlIHdoZW4gcGFyYW0gaXMgZXhwbGljaXRseSBmYWxzZSwgZWcuIHJlcXVpcmVkOmZhbHNlXG5cdFx0XHRpZiAoIHZhbCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGRlbGV0ZSBydWxlc1sgcHJvcCBdO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZhbC5wYXJhbSB8fCB2YWwuZGVwZW5kcyApIHtcblx0XHRcdFx0dmFyIGtlZXBSdWxlID0gdHJ1ZTtcblx0XHRcdFx0c3dpdGNoICggdHlwZW9mIHZhbC5kZXBlbmRzICkge1xuXHRcdFx0XHRjYXNlIFwic3RyaW5nXCI6XG5cdFx0XHRcdFx0a2VlcFJ1bGUgPSAhISQoIHZhbC5kZXBlbmRzLCBlbGVtZW50LmZvcm0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJmdW5jdGlvblwiOlxuXHRcdFx0XHRcdGtlZXBSdWxlID0gdmFsLmRlcGVuZHMuY2FsbCggZWxlbWVudCwgZWxlbWVudCApO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICgga2VlcFJ1bGUgKSB7XG5cdFx0XHRcdFx0cnVsZXNbIHByb3AgXSA9IHZhbC5wYXJhbSAhPT0gdW5kZWZpbmVkID8gdmFsLnBhcmFtIDogdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQkLmRhdGEoIGVsZW1lbnQuZm9ybSwgXCJ2YWxpZGF0b3JcIiApLnJlc2V0RWxlbWVudHMoICQoIGVsZW1lbnQgKSApO1xuXHRcdFx0XHRcdGRlbGV0ZSBydWxlc1sgcHJvcCBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0Ly8gRXZhbHVhdGUgcGFyYW1ldGVyc1xuXHRcdCQuZWFjaCggcnVsZXMsIGZ1bmN0aW9uKCBydWxlLCBwYXJhbWV0ZXIgKSB7XG5cdFx0XHRydWxlc1sgcnVsZSBdID0gJC5pc0Z1bmN0aW9uKCBwYXJhbWV0ZXIgKSAmJiBydWxlICE9PSBcIm5vcm1hbGl6ZXJcIiA/IHBhcmFtZXRlciggZWxlbWVudCApIDogcGFyYW1ldGVyO1xuXHRcdH0gKTtcblxuXHRcdC8vIENsZWFuIG51bWJlciBwYXJhbWV0ZXJzXG5cdFx0JC5lYWNoKCBbIFwibWlubGVuZ3RoXCIsIFwibWF4bGVuZ3RoXCIgXSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHJ1bGVzWyB0aGlzIF0gKSB7XG5cdFx0XHRcdHJ1bGVzWyB0aGlzIF0gPSBOdW1iZXIoIHJ1bGVzWyB0aGlzIF0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0JC5lYWNoKCBbIFwicmFuZ2VsZW5ndGhcIiwgXCJyYW5nZVwiIF0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHBhcnRzO1xuXHRcdFx0aWYgKCBydWxlc1sgdGhpcyBdICkge1xuXHRcdFx0XHRpZiAoICQuaXNBcnJheSggcnVsZXNbIHRoaXMgXSApICkge1xuXHRcdFx0XHRcdHJ1bGVzWyB0aGlzIF0gPSBbIE51bWJlciggcnVsZXNbIHRoaXMgXVsgMCBdICksIE51bWJlciggcnVsZXNbIHRoaXMgXVsgMSBdICkgXTtcblx0XHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHJ1bGVzWyB0aGlzIF0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0cGFydHMgPSBydWxlc1sgdGhpcyBdLnJlcGxhY2UoIC9bXFxbXFxdXS9nLCBcIlwiICkuc3BsaXQoIC9bXFxzLF0rLyApO1xuXHRcdFx0XHRcdHJ1bGVzWyB0aGlzIF0gPSBbIE51bWJlciggcGFydHNbIDAgXSApLCBOdW1iZXIoIHBhcnRzWyAxIF0gKSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0aWYgKCAkLnZhbGlkYXRvci5hdXRvQ3JlYXRlUmFuZ2VzICkge1xuXG5cdFx0XHQvLyBBdXRvLWNyZWF0ZSByYW5nZXNcblx0XHRcdGlmICggcnVsZXMubWluICE9IG51bGwgJiYgcnVsZXMubWF4ICE9IG51bGwgKSB7XG5cdFx0XHRcdHJ1bGVzLnJhbmdlID0gWyBydWxlcy5taW4sIHJ1bGVzLm1heCBdO1xuXHRcdFx0XHRkZWxldGUgcnVsZXMubWluO1xuXHRcdFx0XHRkZWxldGUgcnVsZXMubWF4O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBydWxlcy5taW5sZW5ndGggIT0gbnVsbCAmJiBydWxlcy5tYXhsZW5ndGggIT0gbnVsbCApIHtcblx0XHRcdFx0cnVsZXMucmFuZ2VsZW5ndGggPSBbIHJ1bGVzLm1pbmxlbmd0aCwgcnVsZXMubWF4bGVuZ3RoIF07XG5cdFx0XHRcdGRlbGV0ZSBydWxlcy5taW5sZW5ndGg7XG5cdFx0XHRcdGRlbGV0ZSBydWxlcy5tYXhsZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJ1bGVzO1xuXHR9LFxuXG5cdC8vIENvbnZlcnRzIGEgc2ltcGxlIHN0cmluZyB0byBhIHtzdHJpbmc6IHRydWV9IHJ1bGUsIGUuZy4sIFwicmVxdWlyZWRcIiB0byB7cmVxdWlyZWQ6dHJ1ZX1cblx0bm9ybWFsaXplUnVsZTogZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHZhciB0cmFuc2Zvcm1lZCA9IHt9O1xuXHRcdFx0JC5lYWNoKCBkYXRhLnNwbGl0KCAvXFxzLyApLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dHJhbnNmb3JtZWRbIHRoaXMgXSA9IHRydWU7XG5cdFx0XHR9ICk7XG5cdFx0XHRkYXRhID0gdHJhbnNmb3JtZWQ7XG5cdFx0fVxuXHRcdHJldHVybiBkYXRhO1xuXHR9LFxuXG5cdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvalF1ZXJ5LnZhbGlkYXRvci5hZGRNZXRob2QvXG5cdGFkZE1ldGhvZDogZnVuY3Rpb24oIG5hbWUsIG1ldGhvZCwgbWVzc2FnZSApIHtcblx0XHQkLnZhbGlkYXRvci5tZXRob2RzWyBuYW1lIF0gPSBtZXRob2Q7XG5cdFx0JC52YWxpZGF0b3IubWVzc2FnZXNbIG5hbWUgXSA9IG1lc3NhZ2UgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UgOiAkLnZhbGlkYXRvci5tZXNzYWdlc1sgbmFtZSBdO1xuXHRcdGlmICggbWV0aG9kLmxlbmd0aCA8IDMgKSB7XG5cdFx0XHQkLnZhbGlkYXRvci5hZGRDbGFzc1J1bGVzKCBuYW1lLCAkLnZhbGlkYXRvci5ub3JtYWxpemVSdWxlKCBuYW1lICkgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9qUXVlcnkudmFsaWRhdG9yLm1ldGhvZHMvXG5cdG1ldGhvZHM6IHtcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvcmVxdWlyZWQtbWV0aG9kL1xuXHRcdHJlcXVpcmVkOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQsIHBhcmFtICkge1xuXG5cdFx0XHQvLyBDaGVjayBpZiBkZXBlbmRlbmN5IGlzIG1ldFxuXHRcdFx0aWYgKCAhdGhpcy5kZXBlbmQoIHBhcmFtLCBlbGVtZW50ICkgKSB7XG5cdFx0XHRcdHJldHVybiBcImRlcGVuZGVuY3ktbWlzbWF0Y2hcIjtcblx0XHRcdH1cblx0XHRcdGlmICggZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInNlbGVjdFwiICkge1xuXG5cdFx0XHRcdC8vIENvdWxkIGJlIGFuIGFycmF5IGZvciBzZWxlY3QtbXVsdGlwbGUgb3IgYSBzdHJpbmcsIGJvdGggYXJlIGZpbmUgdGhpcyB3YXlcblx0XHRcdFx0dmFyIHZhbCA9ICQoIGVsZW1lbnQgKS52YWwoKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAmJiB2YWwubGVuZ3RoID4gMDtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5jaGVja2FibGUoIGVsZW1lbnQgKSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0TGVuZ3RoKCB2YWx1ZSwgZWxlbWVudCApID4gMDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZS5sZW5ndGggPiAwO1xuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL2VtYWlsLW1ldGhvZC9cblx0XHRlbWFpbDogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50ICkge1xuXG5cdFx0XHQvLyBGcm9tIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjdmFsaWQtZS1tYWlsLWFkZHJlc3Ncblx0XHRcdC8vIFJldHJpZXZlZCAyMDE0LTAxLTE0XG5cdFx0XHQvLyBJZiB5b3UgaGF2ZSBhIHByb2JsZW0gd2l0aCB0aGlzIGltcGxlbWVudGF0aW9uLCByZXBvcnQgYSBidWcgYWdhaW5zdCB0aGUgYWJvdmUgc3BlY1xuXHRcdFx0Ly8gT3IgdXNlIGN1c3RvbSBtZXRob2RzIHRvIGltcGxlbWVudCB5b3VyIG93biBlbWFpbCB2YWxpZGF0aW9uXG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25hbCggZWxlbWVudCApIHx8IC9eW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvLnRlc3QoIHZhbHVlICk7XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvdXJsLW1ldGhvZC9cblx0XHR1cmw6IGZ1bmN0aW9uKCB2YWx1ZSwgZWxlbWVudCApIHtcblxuXHRcdFx0Ly8gQ29weXJpZ2h0IChjKSAyMDEwLTIwMTMgRGllZ28gUGVyaW5pLCBNSVQgbGljZW5zZWRcblx0XHRcdC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2RwZXJpbmkvNzI5Mjk0XG5cdFx0XHQvLyBzZWUgYWxzbyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvZGVtby91cmwtcmVnZXhcblx0XHRcdC8vIG1vZGlmaWVkIHRvIGFsbG93IHByb3RvY29sLXJlbGF0aXZlIFVSTHNcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbmFsKCBlbGVtZW50ICkgfHwgL14oPzooPzooPzpodHRwcz98ZnRwKTopP1xcL1xcLykoPzpcXFMrKD86OlxcUyopP0ApPyg/Oig/ISg/OjEwfDEyNykoPzpcXC5cXGR7MSwzfSl7M30pKD8hKD86MTY5XFwuMjU0fDE5MlxcLjE2OCkoPzpcXC5cXGR7MSwzfSl7Mn0pKD8hMTcyXFwuKD86MVs2LTldfDJcXGR8M1swLTFdKSg/OlxcLlxcZHsxLDN9KXsyfSkoPzpbMS05XVxcZD98MVxcZFxcZHwyWzAxXVxcZHwyMlswLTNdKSg/OlxcLig/OjE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pKXsyfSg/OlxcLig/OlsxLTldXFxkP3wxXFxkXFxkfDJbMC00XVxcZHwyNVswLTRdKSl8KD86KD86W2EtelxcdTAwYTEtXFx1ZmZmZjAtOV0tKikqW2EtelxcdTAwYTEtXFx1ZmZmZjAtOV0rKSg/OlxcLig/OlthLXpcXHUwMGExLVxcdWZmZmYwLTldLSopKlthLXpcXHUwMGExLVxcdWZmZmYwLTldKykqKD86XFwuKD86W2EtelxcdTAwYTEtXFx1ZmZmZl17Mix9KSkuPykoPzo6XFxkezIsNX0pPyg/OlsvPyNdXFxTKik/JC9pLnRlc3QoIHZhbHVlICk7XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvZGF0ZS1tZXRob2QvXG5cdFx0ZGF0ZTogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50ICkge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSB8fCAhL0ludmFsaWR8TmFOLy50ZXN0KCBuZXcgRGF0ZSggdmFsdWUgKS50b1N0cmluZygpICk7XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvZGF0ZUlTTy1tZXRob2QvXG5cdFx0ZGF0ZUlTTzogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50ICkge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSB8fCAvXlxcZHs0fVtcXC9cXC1dKDA/WzEtOV18MVswMTJdKVtcXC9cXC1dKDA/WzEtOV18WzEyXVswLTldfDNbMDFdKSQvLnRlc3QoIHZhbHVlICk7XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvbnVtYmVyLW1ldGhvZC9cblx0XHRudW1iZXI6IGZ1bmN0aW9uKCB2YWx1ZSwgZWxlbWVudCApIHtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbmFsKCBlbGVtZW50ICkgfHwgL14oPzotP1xcZCt8LT9cXGR7MSwzfSg/OixcXGR7M30pKyk/KD86XFwuXFxkKyk/JC8udGVzdCggdmFsdWUgKTtcblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9kaWdpdHMtbWV0aG9kL1xuXHRcdGRpZ2l0czogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50ICkge1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSB8fCAvXlxcZCskLy50ZXN0KCB2YWx1ZSApO1xuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL21pbmxlbmd0aC1tZXRob2QvXG5cdFx0bWlubGVuZ3RoOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQsIHBhcmFtICkge1xuXHRcdFx0dmFyIGxlbmd0aCA9ICQuaXNBcnJheSggdmFsdWUgKSA/IHZhbHVlLmxlbmd0aCA6IHRoaXMuZ2V0TGVuZ3RoKCB2YWx1ZSwgZWxlbWVudCApO1xuXHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSB8fCBsZW5ndGggPj0gcGFyYW07XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvbWF4bGVuZ3RoLW1ldGhvZC9cblx0XHRtYXhsZW5ndGg6IGZ1bmN0aW9uKCB2YWx1ZSwgZWxlbWVudCwgcGFyYW0gKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gJC5pc0FycmF5KCB2YWx1ZSApID8gdmFsdWUubGVuZ3RoIDogdGhpcy5nZXRMZW5ndGgoIHZhbHVlLCBlbGVtZW50ICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25hbCggZWxlbWVudCApIHx8IGxlbmd0aCA8PSBwYXJhbTtcblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9yYW5nZWxlbmd0aC1tZXRob2QvXG5cdFx0cmFuZ2VsZW5ndGg6IGZ1bmN0aW9uKCB2YWx1ZSwgZWxlbWVudCwgcGFyYW0gKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gJC5pc0FycmF5KCB2YWx1ZSApID8gdmFsdWUubGVuZ3RoIDogdGhpcy5nZXRMZW5ndGgoIHZhbHVlLCBlbGVtZW50ICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25hbCggZWxlbWVudCApIHx8ICggbGVuZ3RoID49IHBhcmFtWyAwIF0gJiYgbGVuZ3RoIDw9IHBhcmFtWyAxIF0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9taW4tbWV0aG9kL1xuXHRcdG1pbjogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50LCBwYXJhbSApIHtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbmFsKCBlbGVtZW50ICkgfHwgdmFsdWUgPj0gcGFyYW07XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvbWF4LW1ldGhvZC9cblx0XHRtYXg6IGZ1bmN0aW9uKCB2YWx1ZSwgZWxlbWVudCwgcGFyYW0gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25hbCggZWxlbWVudCApIHx8IHZhbHVlIDw9IHBhcmFtO1xuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL3JhbmdlLW1ldGhvZC9cblx0XHRyYW5nZTogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50LCBwYXJhbSApIHtcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbmFsKCBlbGVtZW50ICkgfHwgKCB2YWx1ZSA+PSBwYXJhbVsgMCBdICYmIHZhbHVlIDw9IHBhcmFtWyAxIF0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gaHR0cHM6Ly9qcXVlcnl2YWxpZGF0aW9uLm9yZy9zdGVwLW1ldGhvZC9cblx0XHRzdGVwOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQsIHBhcmFtICkge1xuXHRcdFx0dmFyIHR5cGUgPSAkKCBlbGVtZW50ICkuYXR0ciggXCJ0eXBlXCIgKSxcblx0XHRcdFx0ZXJyb3JNZXNzYWdlID0gXCJTdGVwIGF0dHJpYnV0ZSBvbiBpbnB1dCB0eXBlIFwiICsgdHlwZSArIFwiIGlzIG5vdCBzdXBwb3J0ZWQuXCIsXG5cdFx0XHRcdHN1cHBvcnRlZFR5cGVzID0gWyBcInRleHRcIiwgXCJudW1iZXJcIiwgXCJyYW5nZVwiIF0sXG5cdFx0XHRcdHJlID0gbmV3IFJlZ0V4cCggXCJcXFxcYlwiICsgdHlwZSArIFwiXFxcXGJcIiApLFxuXHRcdFx0XHRub3RTdXBwb3J0ZWQgPSB0eXBlICYmICFyZS50ZXN0KCBzdXBwb3J0ZWRUeXBlcy5qb2luKCkgKSxcblx0XHRcdFx0ZGVjaW1hbFBsYWNlcyA9IGZ1bmN0aW9uKCBudW0gKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoID0gKCBcIlwiICsgbnVtICkubWF0Y2goIC8oPzpcXC4oXFxkKykpPyQvICk7XG5cdFx0XHRcdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBOdW1iZXIgb2YgZGlnaXRzIHJpZ2h0IG9mIGRlY2ltYWwgcG9pbnQuXG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoWyAxIF0gPyBtYXRjaFsgMSBdLmxlbmd0aCA6IDA7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRvSW50ID0gZnVuY3Rpb24oIG51bSApIHtcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCggbnVtICogTWF0aC5wb3coIDEwLCBkZWNpbWFscyApICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHZhbGlkID0gdHJ1ZSxcblx0XHRcdFx0ZGVjaW1hbHM7XG5cblx0XHRcdC8vIFdvcmtzIG9ubHkgZm9yIHRleHQsIG51bWJlciBhbmQgcmFuZ2UgaW5wdXQgdHlwZXNcblx0XHRcdC8vIFRPRE8gZmluZCBhIHdheSB0byBzdXBwb3J0IGlucHV0IHR5cGVzIGRhdGUsIGRhdGV0aW1lLCBkYXRldGltZS1sb2NhbCwgbW9udGgsIHRpbWUgYW5kIHdlZWtcblx0XHRcdGlmICggbm90U3VwcG9ydGVkICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGVycm9yTWVzc2FnZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWNpbWFscyA9IGRlY2ltYWxQbGFjZXMoIHBhcmFtICk7XG5cblx0XHRcdC8vIFZhbHVlIGNhbid0IGhhdmUgdG9vIG1hbnkgZGVjaW1hbHNcblx0XHRcdGlmICggZGVjaW1hbFBsYWNlcyggdmFsdWUgKSA+IGRlY2ltYWxzIHx8IHRvSW50KCB2YWx1ZSApICUgdG9JbnQoIHBhcmFtICkgIT09IDAgKSB7XG5cdFx0XHRcdHZhbGlkID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbmFsKCBlbGVtZW50ICkgfHwgdmFsaWQ7XG5cdFx0fSxcblxuXHRcdC8vIGh0dHBzOi8vanF1ZXJ5dmFsaWRhdGlvbi5vcmcvZXF1YWxUby1tZXRob2QvXG5cdFx0ZXF1YWxUbzogZnVuY3Rpb24oIHZhbHVlLCBlbGVtZW50LCBwYXJhbSApIHtcblxuXHRcdFx0Ly8gQmluZCB0byB0aGUgYmx1ciBldmVudCBvZiB0aGUgdGFyZ2V0IGluIG9yZGVyIHRvIHJldmFsaWRhdGUgd2hlbmV2ZXIgdGhlIHRhcmdldCBmaWVsZCBpcyB1cGRhdGVkXG5cdFx0XHR2YXIgdGFyZ2V0ID0gJCggcGFyYW0gKTtcblx0XHRcdGlmICggdGhpcy5zZXR0aW5ncy5vbmZvY3Vzb3V0ICYmIHRhcmdldC5ub3QoIFwiLnZhbGlkYXRlLWVxdWFsVG8tYmx1clwiICkubGVuZ3RoICkge1xuXHRcdFx0XHR0YXJnZXQuYWRkQ2xhc3MoIFwidmFsaWRhdGUtZXF1YWxUby1ibHVyXCIgKS5vbiggXCJibHVyLnZhbGlkYXRlLWVxdWFsVG9cIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0JCggZWxlbWVudCApLnZhbGlkKCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdGFyZ2V0LnZhbCgpO1xuXHRcdH0sXG5cblx0XHQvLyBodHRwczovL2pxdWVyeXZhbGlkYXRpb24ub3JnL3JlbW90ZS1tZXRob2QvXG5cdFx0cmVtb3RlOiBmdW5jdGlvbiggdmFsdWUsIGVsZW1lbnQsIHBhcmFtLCBtZXRob2QgKSB7XG5cdFx0XHRpZiAoIHRoaXMub3B0aW9uYWwoIGVsZW1lbnQgKSApIHtcblx0XHRcdFx0cmV0dXJuIFwiZGVwZW5kZW5jeS1taXNtYXRjaFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRtZXRob2QgPSB0eXBlb2YgbWV0aG9kID09PSBcInN0cmluZ1wiICYmIG1ldGhvZCB8fCBcInJlbW90ZVwiO1xuXG5cdFx0XHR2YXIgcHJldmlvdXMgPSB0aGlzLnByZXZpb3VzVmFsdWUoIGVsZW1lbnQsIG1ldGhvZCApLFxuXHRcdFx0XHR2YWxpZGF0b3IsIGRhdGEsIG9wdGlvbkRhdGFTdHJpbmc7XG5cblx0XHRcdGlmICggIXRoaXMuc2V0dGluZ3MubWVzc2FnZXNbIGVsZW1lbnQubmFtZSBdICkge1xuXHRcdFx0XHR0aGlzLnNldHRpbmdzLm1lc3NhZ2VzWyBlbGVtZW50Lm5hbWUgXSA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0cHJldmlvdXMub3JpZ2luYWxNZXNzYWdlID0gcHJldmlvdXMub3JpZ2luYWxNZXNzYWdlIHx8IHRoaXMuc2V0dGluZ3MubWVzc2FnZXNbIGVsZW1lbnQubmFtZSBdWyBtZXRob2QgXTtcblx0XHRcdHRoaXMuc2V0dGluZ3MubWVzc2FnZXNbIGVsZW1lbnQubmFtZSBdWyBtZXRob2QgXSA9IHByZXZpb3VzLm1lc3NhZ2U7XG5cblx0XHRcdHBhcmFtID0gdHlwZW9mIHBhcmFtID09PSBcInN0cmluZ1wiICYmIHsgdXJsOiBwYXJhbSB9IHx8IHBhcmFtO1xuXHRcdFx0b3B0aW9uRGF0YVN0cmluZyA9ICQucGFyYW0oICQuZXh0ZW5kKCB7IGRhdGE6IHZhbHVlIH0sIHBhcmFtLmRhdGEgKSApO1xuXHRcdFx0aWYgKCBwcmV2aW91cy5vbGQgPT09IG9wdGlvbkRhdGFTdHJpbmcgKSB7XG5cdFx0XHRcdHJldHVybiBwcmV2aW91cy52YWxpZDtcblx0XHRcdH1cblxuXHRcdFx0cHJldmlvdXMub2xkID0gb3B0aW9uRGF0YVN0cmluZztcblx0XHRcdHZhbGlkYXRvciA9IHRoaXM7XG5cdFx0XHR0aGlzLnN0YXJ0UmVxdWVzdCggZWxlbWVudCApO1xuXHRcdFx0ZGF0YSA9IHt9O1xuXHRcdFx0ZGF0YVsgZWxlbWVudC5uYW1lIF0gPSB2YWx1ZTtcblx0XHRcdCQuYWpheCggJC5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0bW9kZTogXCJhYm9ydFwiLFxuXHRcdFx0XHRwb3J0OiBcInZhbGlkYXRlXCIgKyBlbGVtZW50Lm5hbWUsXG5cdFx0XHRcdGRhdGFUeXBlOiBcImpzb25cIixcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0Y29udGV4dDogdmFsaWRhdG9yLmN1cnJlbnRGb3JtLFxuXHRcdFx0XHRzdWNjZXNzOiBmdW5jdGlvbiggcmVzcG9uc2UgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbGlkID0gcmVzcG9uc2UgPT09IHRydWUgfHwgcmVzcG9uc2UgPT09IFwidHJ1ZVwiLFxuXHRcdFx0XHRcdFx0ZXJyb3JzLCBtZXNzYWdlLCBzdWJtaXR0ZWQ7XG5cblx0XHRcdFx0XHR2YWxpZGF0b3Iuc2V0dGluZ3MubWVzc2FnZXNbIGVsZW1lbnQubmFtZSBdWyBtZXRob2QgXSA9IHByZXZpb3VzLm9yaWdpbmFsTWVzc2FnZTtcblx0XHRcdFx0XHRpZiAoIHZhbGlkICkge1xuXHRcdFx0XHRcdFx0c3VibWl0dGVkID0gdmFsaWRhdG9yLmZvcm1TdWJtaXR0ZWQ7XG5cdFx0XHRcdFx0XHR2YWxpZGF0b3IucmVzZXRJbnRlcm5hbHMoKTtcblx0XHRcdFx0XHRcdHZhbGlkYXRvci50b0hpZGUgPSB2YWxpZGF0b3IuZXJyb3JzRm9yKCBlbGVtZW50ICk7XG5cdFx0XHRcdFx0XHR2YWxpZGF0b3IuZm9ybVN1Ym1pdHRlZCA9IHN1Ym1pdHRlZDtcblx0XHRcdFx0XHRcdHZhbGlkYXRvci5zdWNjZXNzTGlzdC5wdXNoKCBlbGVtZW50ICk7XG5cdFx0XHRcdFx0XHR2YWxpZGF0b3IuaW52YWxpZFsgZWxlbWVudC5uYW1lIF0gPSBmYWxzZTtcblx0XHRcdFx0XHRcdHZhbGlkYXRvci5zaG93RXJyb3JzKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGVycm9ycyA9IHt9O1xuXHRcdFx0XHRcdFx0bWVzc2FnZSA9IHJlc3BvbnNlIHx8IHZhbGlkYXRvci5kZWZhdWx0TWVzc2FnZSggZWxlbWVudCwgeyBtZXRob2Q6IG1ldGhvZCwgcGFyYW1ldGVyczogdmFsdWUgfSApO1xuXHRcdFx0XHRcdFx0ZXJyb3JzWyBlbGVtZW50Lm5hbWUgXSA9IHByZXZpb3VzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXHRcdFx0XHRcdFx0dmFsaWRhdG9yLmludmFsaWRbIGVsZW1lbnQubmFtZSBdID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHZhbGlkYXRvci5zaG93RXJyb3JzKCBlcnJvcnMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHJldmlvdXMudmFsaWQgPSB2YWxpZDtcblx0XHRcdFx0XHR2YWxpZGF0b3Iuc3RvcFJlcXVlc3QoIGVsZW1lbnQsIHZhbGlkICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHBhcmFtICkgKTtcblx0XHRcdHJldHVybiBcInBlbmRpbmdcIjtcblx0XHR9XG5cdH1cblxufSApO1xuXHJcbi8vIEFqYXggbW9kZTogYWJvcnRcbi8vIHVzYWdlOiAkLmFqYXgoeyBtb2RlOiBcImFib3J0XCJbLCBwb3J0OiBcInVuaXF1ZXBvcnRcIl19KTtcbi8vIGlmIG1vZGU6XCJhYm9ydFwiIGlzIHVzZWQsIHRoZSBwcmV2aW91cyByZXF1ZXN0IG9uIHRoYXQgcG9ydCAocG9ydCBjYW4gYmUgdW5kZWZpbmVkKSBpcyBhYm9ydGVkIHZpYSBYTUxIdHRwUmVxdWVzdC5hYm9ydCgpXG5cbnZhciBwZW5kaW5nUmVxdWVzdHMgPSB7fSxcblx0YWpheDtcblxuLy8gVXNlIGEgcHJlZmlsdGVyIGlmIGF2YWlsYWJsZSAoMS41KylcbmlmICggJC5hamF4UHJlZmlsdGVyICkge1xuXHQkLmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzZXR0aW5ncywgXywgeGhyICkge1xuXHRcdHZhciBwb3J0ID0gc2V0dGluZ3MucG9ydDtcblx0XHRpZiAoIHNldHRpbmdzLm1vZGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdGlmICggcGVuZGluZ1JlcXVlc3RzWyBwb3J0IF0gKSB7XG5cdFx0XHRcdHBlbmRpbmdSZXF1ZXN0c1sgcG9ydCBdLmFib3J0KCk7XG5cdFx0XHR9XG5cdFx0XHRwZW5kaW5nUmVxdWVzdHNbIHBvcnQgXSA9IHhocjtcblx0XHR9XG5cdH0gKTtcbn0gZWxzZSB7XG5cblx0Ly8gUHJveHkgYWpheFxuXHRhamF4ID0gJC5hamF4O1xuXHQkLmFqYXggPSBmdW5jdGlvbiggc2V0dGluZ3MgKSB7XG5cdFx0dmFyIG1vZGUgPSAoIFwibW9kZVwiIGluIHNldHRpbmdzID8gc2V0dGluZ3MgOiAkLmFqYXhTZXR0aW5ncyApLm1vZGUsXG5cdFx0XHRwb3J0ID0gKCBcInBvcnRcIiBpbiBzZXR0aW5ncyA/IHNldHRpbmdzIDogJC5hamF4U2V0dGluZ3MgKS5wb3J0O1xuXHRcdGlmICggbW9kZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0aWYgKCBwZW5kaW5nUmVxdWVzdHNbIHBvcnQgXSApIHtcblx0XHRcdFx0cGVuZGluZ1JlcXVlc3RzWyBwb3J0IF0uYWJvcnQoKTtcblx0XHRcdH1cblx0XHRcdHBlbmRpbmdSZXF1ZXN0c1sgcG9ydCBdID0gYWpheC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRyZXR1cm4gcGVuZGluZ1JlcXVlc3RzWyBwb3J0IF07XG5cdFx0fVxuXHRcdHJldHVybiBhamF4LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0fTtcbn1cbnJldHVybiAkO1xyXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvanF1ZXJ5LXZhbGlkYXRpb24vZGlzdC9qcXVlcnkudmFsaWRhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXHJcbioqIFVub2J0cnVzaXZlIHZhbGlkYXRpb24gc3VwcG9ydCBsaWJyYXJ5IGZvciBqUXVlcnkgYW5kIGpRdWVyeSBWYWxpZGF0ZVxyXG4qKiBDb3B5cmlnaHQgKEMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuKi9cclxuXHJcbi8qanNsaW50IHdoaXRlOiB0cnVlLCBicm93c2VyOiB0cnVlLCBvbmV2YXI6IHRydWUsIHVuZGVmOiB0cnVlLCBub21lbjogdHJ1ZSwgZXFlcWVxOiB0cnVlLCBwbHVzcGx1czogdHJ1ZSwgYml0d2lzZTogdHJ1ZSwgcmVnZXhwOiB0cnVlLCBuZXdjYXA6IHRydWUsIGltbWVkOiB0cnVlLCBzdHJpY3Q6IGZhbHNlICovXHJcbi8qZ2xvYmFsIGRvY3VtZW50OiBmYWxzZSwgalF1ZXJ5OiBmYWxzZSAqL1xyXG5cclxuKGZ1bmN0aW9uICgkKSB7XHJcbiAgICB2YXIgJGpRdmFsID0gJC52YWxpZGF0b3IsXHJcbiAgICAgICAgYWRhcHRlcnMsXHJcbiAgICAgICAgZGF0YV92YWxpZGF0aW9uID0gXCJ1bm9idHJ1c2l2ZVZhbGlkYXRpb25cIjtcclxuXHJcbiAgICBmdW5jdGlvbiBzZXRWYWxpZGF0aW9uVmFsdWVzKG9wdGlvbnMsIHJ1bGVOYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIG9wdGlvbnMucnVsZXNbcnVsZU5hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMubWVzc2FnZSkge1xyXG4gICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2VzW3J1bGVOYW1lXSA9IG9wdGlvbnMubWVzc2FnZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3BsaXRBbmRUcmltKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpLnNwbGl0KC9cXHMqLFxccyovZyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZXNjYXBlQXR0cmlidXRlVmFsdWUodmFsdWUpIHtcclxuICAgICAgICAvLyBBcyBtZW50aW9uZWQgb24gaHR0cDovL2FwaS5qcXVlcnkuY29tL2NhdGVnb3J5L3NlbGVjdG9ycy9cclxuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvKFshXCIjJCUmJygpKissLi86Ozw9Pj9AXFxbXFxcXFxcXV5ge3x9fl0pL2csIFwiXFxcXCQxXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldE1vZGVsUHJlZml4KGZpZWxkTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBmaWVsZE5hbWUuc3Vic3RyKDAsIGZpZWxkTmFtZS5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcHBlbmRNb2RlbFByZWZpeCh2YWx1ZSwgcHJlZml4KSB7XHJcbiAgICAgICAgaWYgKHZhbHVlLmluZGV4T2YoXCIqLlwiKSA9PT0gMCkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoXCIqLlwiLCBwcmVmaXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gb25FcnJvcihlcnJvciwgaW5wdXRFbGVtZW50KSB7ICAvLyAndGhpcycgaXMgdGhlIGZvcm0gZWxlbWVudFxyXG4gICAgICAgIHZhciBjb250YWluZXIgPSAkKHRoaXMpLmZpbmQoXCJbZGF0YS12YWxtc2ctZm9yPSdcIiArIGVzY2FwZUF0dHJpYnV0ZVZhbHVlKGlucHV0RWxlbWVudFswXS5uYW1lKSArIFwiJ11cIiksXHJcbiAgICAgICAgICAgIHJlcGxhY2VBdHRyVmFsdWUgPSBjb250YWluZXIuYXR0cihcImRhdGEtdmFsbXNnLXJlcGxhY2VcIiksXHJcbiAgICAgICAgICAgIHJlcGxhY2UgPSByZXBsYWNlQXR0clZhbHVlID8gJC5wYXJzZUpTT04ocmVwbGFjZUF0dHJWYWx1ZSkgIT09IGZhbHNlIDogbnVsbDtcclxuXHJcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNsYXNzKFwiZmllbGQtdmFsaWRhdGlvbi12YWxpZFwiKS5hZGRDbGFzcyhcImZpZWxkLXZhbGlkYXRpb24tZXJyb3JcIik7XHJcbiAgICAgICAgZXJyb3IuZGF0YShcInVub2J0cnVzaXZlQ29udGFpbmVyXCIsIGNvbnRhaW5lcik7XHJcblxyXG4gICAgICAgIGlmIChyZXBsYWNlKSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5lbXB0eSgpO1xyXG4gICAgICAgICAgICBlcnJvci5yZW1vdmVDbGFzcyhcImlucHV0LXZhbGlkYXRpb24tZXJyb3JcIikuYXBwZW5kVG8oY29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVycm9yLmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gb25FcnJvcnMoZXZlbnQsIHZhbGlkYXRvcikgeyAgLy8gJ3RoaXMnIGlzIHRoZSBmb3JtIGVsZW1lbnRcclxuICAgICAgICB2YXIgY29udGFpbmVyID0gJCh0aGlzKS5maW5kKFwiW2RhdGEtdmFsbXNnLXN1bW1hcnk9dHJ1ZV1cIiksXHJcbiAgICAgICAgICAgIGxpc3QgPSBjb250YWluZXIuZmluZChcInVsXCIpO1xyXG5cclxuICAgICAgICBpZiAobGlzdCAmJiBsaXN0Lmxlbmd0aCAmJiB2YWxpZGF0b3IuZXJyb3JMaXN0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsaXN0LmVtcHR5KCk7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGRDbGFzcyhcInZhbGlkYXRpb24tc3VtbWFyeS1lcnJvcnNcIikucmVtb3ZlQ2xhc3MoXCJ2YWxpZGF0aW9uLXN1bW1hcnktdmFsaWRcIik7XHJcblxyXG4gICAgICAgICAgICAkLmVhY2godmFsaWRhdG9yLmVycm9yTGlzdCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgJChcIjxsaSAvPlwiKS5odG1sKHRoaXMubWVzc2FnZSkuYXBwZW5kVG8obGlzdCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvblN1Y2Nlc3MoZXJyb3IpIHsgIC8vICd0aGlzJyBpcyB0aGUgZm9ybSBlbGVtZW50XHJcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGVycm9yLmRhdGEoXCJ1bm9idHJ1c2l2ZUNvbnRhaW5lclwiKTtcclxuXHJcbiAgICAgICAgaWYgKGNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICB2YXIgcmVwbGFjZUF0dHJWYWx1ZSA9IGNvbnRhaW5lci5hdHRyKFwiZGF0YS12YWxtc2ctcmVwbGFjZVwiKSxcclxuICAgICAgICAgICAgICAgIHJlcGxhY2UgPSByZXBsYWNlQXR0clZhbHVlID8gJC5wYXJzZUpTT04ocmVwbGFjZUF0dHJWYWx1ZSkgOiBudWxsO1xyXG5cclxuICAgICAgICAgICAgY29udGFpbmVyLmFkZENsYXNzKFwiZmllbGQtdmFsaWRhdGlvbi12YWxpZFwiKS5yZW1vdmVDbGFzcyhcImZpZWxkLXZhbGlkYXRpb24tZXJyb3JcIik7XHJcbiAgICAgICAgICAgIGVycm9yLnJlbW92ZURhdGEoXCJ1bm9idHJ1c2l2ZUNvbnRhaW5lclwiKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChyZXBsYWNlKSB7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIuZW1wdHkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvblJlc2V0KGV2ZW50KSB7ICAvLyAndGhpcycgaXMgdGhlIGZvcm0gZWxlbWVudFxyXG4gICAgICAgIHZhciAkZm9ybSA9ICQodGhpcyksXHJcbiAgICAgICAgICAgIGtleSA9ICdfX2pxdWVyeV91bm9idHJ1c2l2ZV92YWxpZGF0aW9uX2Zvcm1fcmVzZXQnO1xyXG4gICAgICAgIGlmICgkZm9ybS5kYXRhKGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTZXQgYSBmbGFnIHRoYXQgaW5kaWNhdGVzIHdlJ3JlIGN1cnJlbnRseSByZXNldHRpbmcgdGhlIGZvcm0uXHJcbiAgICAgICAgJGZvcm0uZGF0YShrZXksIHRydWUpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICRmb3JtLmRhdGEoXCJ2YWxpZGF0b3JcIikucmVzZXRGb3JtKCk7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgJGZvcm0ucmVtb3ZlRGF0YShrZXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgJGZvcm0uZmluZChcIi52YWxpZGF0aW9uLXN1bW1hcnktZXJyb3JzXCIpXHJcbiAgICAgICAgICAgIC5hZGRDbGFzcyhcInZhbGlkYXRpb24tc3VtbWFyeS12YWxpZFwiKVxyXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3MoXCJ2YWxpZGF0aW9uLXN1bW1hcnktZXJyb3JzXCIpO1xyXG4gICAgICAgICRmb3JtLmZpbmQoXCIuZmllbGQtdmFsaWRhdGlvbi1lcnJvclwiKVxyXG4gICAgICAgICAgICAuYWRkQ2xhc3MoXCJmaWVsZC12YWxpZGF0aW9uLXZhbGlkXCIpXHJcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhcImZpZWxkLXZhbGlkYXRpb24tZXJyb3JcIilcclxuICAgICAgICAgICAgLnJlbW92ZURhdGEoXCJ1bm9idHJ1c2l2ZUNvbnRhaW5lclwiKVxyXG4gICAgICAgICAgICAuZmluZChcIj4qXCIpICAvLyBJZiB3ZSB3ZXJlIHVzaW5nIHZhbG1zZy1yZXBsYWNlLCBnZXQgdGhlIHVuZGVybHlpbmcgZXJyb3JcclxuICAgICAgICAgICAgICAgIC5yZW1vdmVEYXRhKFwidW5vYnRydXNpdmVDb250YWluZXJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdmFsaWRhdGlvbkluZm8oZm9ybSkge1xyXG4gICAgICAgIHZhciAkZm9ybSA9ICQoZm9ybSksXHJcbiAgICAgICAgICAgIHJlc3VsdCA9ICRmb3JtLmRhdGEoZGF0YV92YWxpZGF0aW9uKSxcclxuICAgICAgICAgICAgb25SZXNldFByb3h5ID0gJC5wcm94eShvblJlc2V0LCBmb3JtKSxcclxuICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnMgPSAkalF2YWwudW5vYnRydXNpdmUub3B0aW9ucyB8fCB7fSxcclxuICAgICAgICAgICAgZXhlY0luQ29udGV4dCA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnVuYyA9IGRlZmF1bHRPcHRpb25zW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgZnVuYyAmJiAkLmlzRnVuY3Rpb24oZnVuYykgJiYgZnVuYy5hcHBseShmb3JtLCBhcmdzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB7ICAvLyBvcHRpb25zIHN0cnVjdHVyZSBwYXNzZWQgdG8galF1ZXJ5IFZhbGlkYXRlJ3MgdmFsaWRhdGUoKSBtZXRob2RcclxuICAgICAgICAgICAgICAgICAgICBlcnJvckNsYXNzOiBkZWZhdWx0T3B0aW9ucy5lcnJvckNsYXNzIHx8IFwiaW5wdXQtdmFsaWRhdGlvbi1lcnJvclwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yRWxlbWVudDogZGVmYXVsdE9wdGlvbnMuZXJyb3JFbGVtZW50IHx8IFwic3BhblwiLFxyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yUGxhY2VtZW50OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IuYXBwbHkoZm9ybSwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY0luQ29udGV4dChcImVycm9yUGxhY2VtZW50XCIsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkSGFuZGxlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9ycy5hcHBseShmb3JtLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjSW5Db250ZXh0KFwiaW52YWxpZEhhbmRsZXJcIiwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICBydWxlczoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3MuYXBwbHkoZm9ybSwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY0luQ29udGV4dChcInN1Y2Nlc3NcIiwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYXR0YWNoVmFsaWRhdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICRmb3JtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vZmYoXCJyZXNldC5cIiArIGRhdGFfdmFsaWRhdGlvbiwgb25SZXNldFByb3h5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oXCJyZXNldC5cIiArIGRhdGFfdmFsaWRhdGlvbiwgb25SZXNldFByb3h5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudmFsaWRhdGUodGhpcy5vcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkgeyAgLy8gYSB2YWxpZGF0aW9uIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIGJ5IHVub2J0cnVzaXZlIEFqYXhcclxuICAgICAgICAgICAgICAgICAgICAkZm9ybS52YWxpZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkZm9ybS52YWxpZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAkZm9ybS5kYXRhKGRhdGFfdmFsaWRhdGlvbiwgcmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgJGpRdmFsLnVub2J0cnVzaXZlID0ge1xyXG4gICAgICAgIGFkYXB0ZXJzOiBbXSxcclxuXHJcbiAgICAgICAgcGFyc2VFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCwgc2tpcEF0dGFjaCkge1xyXG4gICAgICAgICAgICAvLy8gPHN1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyBQYXJzZXMgYSBzaW5nbGUgSFRNTCBlbGVtZW50IGZvciB1bm9idHJ1c2l2ZSB2YWxpZGF0aW9uIGF0dHJpYnV0ZXMuXHJcbiAgICAgICAgICAgIC8vLyA8L3N1bW1hcnk+XHJcbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImVsZW1lbnRcIiBkb21FbGVtZW50PVwidHJ1ZVwiPlRoZSBIVE1MIGVsZW1lbnQgdG8gYmUgcGFyc2VkLjwvcGFyYW0+XHJcbiAgICAgICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInNraXBBdHRhY2hcIiB0eXBlPVwiQm9vbGVhblwiPltPcHRpb25hbF0gdHJ1ZSB0byBza2lwIGF0dGFjaGluZyB0aGVcclxuICAgICAgICAgICAgLy8vIHZhbGlkYXRpb24gdG8gdGhlIGZvcm0uIElmIHBhcnNpbmcganVzdCB0aGlzIHNpbmdsZSBlbGVtZW50LCB5b3Ugc2hvdWxkIHNwZWNpZnkgdHJ1ZS5cclxuICAgICAgICAgICAgLy8vIElmIHBhcnNpbmcgc2V2ZXJhbCBlbGVtZW50cywgeW91IHNob3VsZCBzcGVjaWZ5IGZhbHNlLCBhbmQgbWFudWFsbHkgYXR0YWNoIHRoZSB2YWxpZGF0aW9uXHJcbiAgICAgICAgICAgIC8vLyB0byB0aGUgZm9ybSB3aGVuIHlvdSBhcmUgZmluaXNoZWQuIFRoZSBkZWZhdWx0IGlzIGZhbHNlLjwvcGFyYW0+XHJcbiAgICAgICAgICAgIHZhciAkZWxlbWVudCA9ICQoZWxlbWVudCksXHJcbiAgICAgICAgICAgICAgICBmb3JtID0gJGVsZW1lbnQucGFyZW50cyhcImZvcm1cIilbMF0sXHJcbiAgICAgICAgICAgICAgICB2YWxJbmZvLCBydWxlcywgbWVzc2FnZXM7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWZvcm0pIHsgIC8vIENhbm5vdCBkbyBjbGllbnQtc2lkZSB2YWxpZGF0aW9uIHdpdGhvdXQgYSBmb3JtXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhbEluZm8gPSB2YWxpZGF0aW9uSW5mbyhmb3JtKTtcclxuICAgICAgICAgICAgdmFsSW5mby5vcHRpb25zLnJ1bGVzW2VsZW1lbnQubmFtZV0gPSBydWxlcyA9IHt9O1xyXG4gICAgICAgICAgICB2YWxJbmZvLm9wdGlvbnMubWVzc2FnZXNbZWxlbWVudC5uYW1lXSA9IG1lc3NhZ2VzID0ge307XHJcblxyXG4gICAgICAgICAgICAkLmVhY2godGhpcy5hZGFwdGVycywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9IFwiZGF0YS12YWwtXCIgKyB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9ICRlbGVtZW50LmF0dHIocHJlZml4KSxcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbVZhbHVlcyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlICE9PSB1bmRlZmluZWQpIHsgIC8vIENvbXBhcmUgYWdhaW5zdCB1bmRlZmluZWQsIGJlY2F1c2UgYW4gZW1wdHkgbWVzc2FnZSBpcyBsZWdhbCAoYW5kIGZhbHN5KVxyXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCArPSBcIi1cIjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHRoaXMucGFyYW1zLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtVmFsdWVzW3RoaXNdID0gJGVsZW1lbnQuYXR0cihwcmVmaXggKyB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGFwdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm06IGZvcm0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1WYWx1ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzOiBydWxlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgJC5leHRlbmQocnVsZXMsIHsgXCJfX2R1bW15X19cIjogdHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmICghc2tpcEF0dGFjaCkge1xyXG4gICAgICAgICAgICAgICAgdmFsSW5mby5hdHRhY2hWYWxpZGF0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIC8vLyA8c3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIFBhcnNlcyBhbGwgdGhlIEhUTUwgZWxlbWVudHMgaW4gdGhlIHNwZWNpZmllZCBzZWxlY3Rvci4gSXQgbG9va3MgZm9yIGlucHV0IGVsZW1lbnRzIGRlY29yYXRlZFxyXG4gICAgICAgICAgICAvLy8gd2l0aCB0aGUgW2RhdGEtdmFsPXRydWVdIGF0dHJpYnV0ZSB2YWx1ZSBhbmQgZW5hYmxlcyB2YWxpZGF0aW9uIGFjY29yZGluZyB0byB0aGUgZGF0YS12YWwtKlxyXG4gICAgICAgICAgICAvLy8gYXR0cmlidXRlIHZhbHVlcy5cclxuICAgICAgICAgICAgLy8vIDwvc3VtbWFyeT5cclxuICAgICAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwic2VsZWN0b3JcIiB0eXBlPVwiU3RyaW5nXCI+QW55IHZhbGlkIGpRdWVyeSBzZWxlY3Rvci48L3BhcmFtPlxyXG5cclxuICAgICAgICAgICAgLy8gJGZvcm1zIGluY2x1ZGVzIGFsbCBmb3JtcyBpbiBzZWxlY3RvcidzIERPTSBoaWVyYXJjaHkgKHBhcmVudCwgY2hpbGRyZW4gYW5kIHNlbGYpIHRoYXQgaGF2ZSBhdCBsZWFzdCBvbmVcclxuICAgICAgICAgICAgLy8gZWxlbWVudCB3aXRoIGRhdGEtdmFsPXRydWVcclxuICAgICAgICAgICAgdmFyICRzZWxlY3RvciA9ICQoc2VsZWN0b3IpLFxyXG4gICAgICAgICAgICAgICAgJGZvcm1zID0gJHNlbGVjdG9yLnBhcmVudHMoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZEJhY2soKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihcImZvcm1cIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGQoJHNlbGVjdG9yLmZpbmQoXCJmb3JtXCIpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmhhcyhcIltkYXRhLXZhbD10cnVlXVwiKTtcclxuXHJcbiAgICAgICAgICAgICRzZWxlY3Rvci5maW5kKFwiW2RhdGEtdmFsPXRydWVdXCIpLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgJGpRdmFsLnVub2J0cnVzaXZlLnBhcnNlRWxlbWVudCh0aGlzLCB0cnVlKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAkZm9ybXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IHZhbGlkYXRpb25JbmZvKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZm8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmZvLmF0dGFjaFZhbGlkYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBhZGFwdGVycyA9ICRqUXZhbC51bm9idHJ1c2l2ZS5hZGFwdGVycztcclxuXHJcbiAgICBhZGFwdGVycy5hZGQgPSBmdW5jdGlvbiAoYWRhcHRlck5hbWUsIHBhcmFtcywgZm4pIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+QWRkcyBhIG5ldyBhZGFwdGVyIHRvIGNvbnZlcnQgdW5vYnRydXNpdmUgSFRNTCBpbnRvIGEgalF1ZXJ5IFZhbGlkYXRlIHZhbGlkYXRpb24uPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFkYXB0ZXJOYW1lXCIgdHlwZT1cIlN0cmluZ1wiPlRoZSBuYW1lIG9mIHRoZSBhZGFwdGVyIHRvIGJlIGFkZGVkLiBUaGlzIG1hdGNoZXMgdGhlIG5hbWUgdXNlZFxyXG4gICAgICAgIC8vLyBpbiB0aGUgZGF0YS12YWwtbm5ubiBIVE1MIGF0dHJpYnV0ZSAod2hlcmUgbm5ubiBpcyB0aGUgYWRhcHRlciBuYW1lKS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInBhcmFtc1wiIHR5cGU9XCJBcnJheVwiIG9wdGlvbmFsPVwidHJ1ZVwiPltPcHRpb25hbF0gQW4gYXJyYXkgb2YgcGFyYW1ldGVyIG5hbWVzIChzdHJpbmdzKSB0aGF0IHdpbGxcclxuICAgICAgICAvLy8gYmUgZXh0cmFjdGVkIGZyb20gdGhlIGRhdGEtdmFsLW5ubm4tbW1tbSBIVE1MIGF0dHJpYnV0ZXMgKHdoZXJlIG5ubm4gaXMgdGhlIGFkYXB0ZXIgbmFtZSwgYW5kXHJcbiAgICAgICAgLy8vIG1tbW0gaXMgdGhlIHBhcmFtZXRlciBuYW1lKS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImZuXCIgdHlwZT1cIkZ1bmN0aW9uXCI+VGhlIGZ1bmN0aW9uIHRvIGNhbGwsIHdoaWNoIGFkYXB0cyB0aGUgdmFsdWVzIGZyb20gdGhlIEhUTUxcclxuICAgICAgICAvLy8gYXR0cmlidXRlcyBpbnRvIGpRdWVyeSBWYWxpZGF0ZSBydWxlcyBhbmQvb3IgbWVzc2FnZXMuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHJldHVybnMgdHlwZT1cImpRdWVyeS52YWxpZGF0b3IudW5vYnRydXNpdmUuYWRhcHRlcnNcIiAvPlxyXG4gICAgICAgIGlmICghZm4pIHsgIC8vIENhbGxlZCB3aXRoIG5vIHBhcmFtcywganVzdCBhIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIGZuID0gcGFyYW1zO1xyXG4gICAgICAgICAgICBwYXJhbXMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wdXNoKHsgbmFtZTogYWRhcHRlck5hbWUsIHBhcmFtczogcGFyYW1zLCBhZGFwdDogZm4gfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG5cclxuICAgIGFkYXB0ZXJzLmFkZEJvb2wgPSBmdW5jdGlvbiAoYWRhcHRlck5hbWUsIHJ1bGVOYW1lKSB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PkFkZHMgYSBuZXcgYWRhcHRlciB0byBjb252ZXJ0IHVub2J0cnVzaXZlIEhUTUwgaW50byBhIGpRdWVyeSBWYWxpZGF0ZSB2YWxpZGF0aW9uLCB3aGVyZVxyXG4gICAgICAgIC8vLyB0aGUgalF1ZXJ5IFZhbGlkYXRlIHZhbGlkYXRpb24gcnVsZSBoYXMgbm8gcGFyYW1ldGVyIHZhbHVlcy48L3N1bW1hcnk+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYWRhcHRlck5hbWVcIiB0eXBlPVwiU3RyaW5nXCI+VGhlIG5hbWUgb2YgdGhlIGFkYXB0ZXIgdG8gYmUgYWRkZWQuIFRoaXMgbWF0Y2hlcyB0aGUgbmFtZSB1c2VkXHJcbiAgICAgICAgLy8vIGluIHRoZSBkYXRhLXZhbC1ubm5uIEhUTUwgYXR0cmlidXRlICh3aGVyZSBubm5uIGlzIHRoZSBhZGFwdGVyIG5hbWUpLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicnVsZU5hbWVcIiB0eXBlPVwiU3RyaW5nXCIgb3B0aW9uYWw9XCJ0cnVlXCI+W09wdGlvbmFsXSBUaGUgbmFtZSBvZiB0aGUgalF1ZXJ5IFZhbGlkYXRlIHJ1bGUuIElmIG5vdCBwcm92aWRlZCwgdGhlIHZhbHVlXHJcbiAgICAgICAgLy8vIG9mIGFkYXB0ZXJOYW1lIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zIHR5cGU9XCJqUXVlcnkudmFsaWRhdG9yLnVub2J0cnVzaXZlLmFkYXB0ZXJzXCIgLz5cclxuICAgICAgICByZXR1cm4gdGhpcy5hZGQoYWRhcHRlck5hbWUsIGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHNldFZhbGlkYXRpb25WYWx1ZXMob3B0aW9ucywgcnVsZU5hbWUgfHwgYWRhcHRlck5hbWUsIHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBhZGFwdGVycy5hZGRNaW5NYXggPSBmdW5jdGlvbiAoYWRhcHRlck5hbWUsIG1pblJ1bGVOYW1lLCBtYXhSdWxlTmFtZSwgbWluTWF4UnVsZU5hbWUsIG1pbkF0dHJpYnV0ZSwgbWF4QXR0cmlidXRlKSB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PkFkZHMgYSBuZXcgYWRhcHRlciB0byBjb252ZXJ0IHVub2J0cnVzaXZlIEhUTUwgaW50byBhIGpRdWVyeSBWYWxpZGF0ZSB2YWxpZGF0aW9uLCB3aGVyZVxyXG4gICAgICAgIC8vLyB0aGUgalF1ZXJ5IFZhbGlkYXRlIHZhbGlkYXRpb24gaGFzIHRocmVlIHBvdGVudGlhbCBydWxlcyAob25lIGZvciBtaW4tb25seSwgb25lIGZvciBtYXgtb25seSwgYW5kXHJcbiAgICAgICAgLy8vIG9uZSBmb3IgbWluLWFuZC1tYXgpLiBUaGUgSFRNTCBwYXJhbWV0ZXJzIGFyZSBleHBlY3RlZCB0byBiZSBuYW1lZCAtbWluIGFuZCAtbWF4Ljwvc3VtbWFyeT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhZGFwdGVyTmFtZVwiIHR5cGU9XCJTdHJpbmdcIj5UaGUgbmFtZSBvZiB0aGUgYWRhcHRlciB0byBiZSBhZGRlZC4gVGhpcyBtYXRjaGVzIHRoZSBuYW1lIHVzZWRcclxuICAgICAgICAvLy8gaW4gdGhlIGRhdGEtdmFsLW5ubm4gSFRNTCBhdHRyaWJ1dGUgKHdoZXJlIG5ubm4gaXMgdGhlIGFkYXB0ZXIgbmFtZSkuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJtaW5SdWxlTmFtZVwiIHR5cGU9XCJTdHJpbmdcIj5UaGUgbmFtZSBvZiB0aGUgalF1ZXJ5IFZhbGlkYXRlIHJ1bGUgdG8gYmUgdXNlZCB3aGVuIHlvdSBvbmx5XHJcbiAgICAgICAgLy8vIGhhdmUgYSBtaW5pbXVtIHZhbHVlLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwibWF4UnVsZU5hbWVcIiB0eXBlPVwiU3RyaW5nXCI+VGhlIG5hbWUgb2YgdGhlIGpRdWVyeSBWYWxpZGF0ZSBydWxlIHRvIGJlIHVzZWQgd2hlbiB5b3Ugb25seVxyXG4gICAgICAgIC8vLyBoYXZlIGEgbWF4aW11bSB2YWx1ZS48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1pbk1heFJ1bGVOYW1lXCIgdHlwZT1cIlN0cmluZ1wiPlRoZSBuYW1lIG9mIHRoZSBqUXVlcnkgVmFsaWRhdGUgcnVsZSB0byBiZSB1c2VkIHdoZW4geW91XHJcbiAgICAgICAgLy8vIGhhdmUgYm90aCBhIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWUuPC9wYXJhbT5cclxuICAgICAgICAvLy8gPHBhcmFtIG5hbWU9XCJtaW5BdHRyaWJ1dGVcIiB0eXBlPVwiU3RyaW5nXCIgb3B0aW9uYWw9XCJ0cnVlXCI+W09wdGlvbmFsXSBUaGUgbmFtZSBvZiB0aGUgSFRNTCBhdHRyaWJ1dGUgdGhhdFxyXG4gICAgICAgIC8vLyBjb250YWlucyB0aGUgbWluaW11bSB2YWx1ZS4gVGhlIGRlZmF1bHQgaXMgXCJtaW5cIi48L3BhcmFtPlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cIm1heEF0dHJpYnV0ZVwiIHR5cGU9XCJTdHJpbmdcIiBvcHRpb25hbD1cInRydWVcIj5bT3B0aW9uYWxdIFRoZSBuYW1lIG9mIHRoZSBIVE1MIGF0dHJpYnV0ZSB0aGF0XHJcbiAgICAgICAgLy8vIGNvbnRhaW5zIHRoZSBtYXhpbXVtIHZhbHVlLiBUaGUgZGVmYXVsdCBpcyBcIm1heFwiLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zIHR5cGU9XCJqUXVlcnkudmFsaWRhdG9yLnVub2J0cnVzaXZlLmFkYXB0ZXJzXCIgLz5cclxuICAgICAgICByZXR1cm4gdGhpcy5hZGQoYWRhcHRlck5hbWUsIFttaW5BdHRyaWJ1dGUgfHwgXCJtaW5cIiwgbWF4QXR0cmlidXRlIHx8IFwibWF4XCJdLCBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgbWluID0gb3B0aW9ucy5wYXJhbXMubWluLFxyXG4gICAgICAgICAgICAgICAgbWF4ID0gb3B0aW9ucy5wYXJhbXMubWF4O1xyXG5cclxuICAgICAgICAgICAgaWYgKG1pbiAmJiBtYXgpIHtcclxuICAgICAgICAgICAgICAgIHNldFZhbGlkYXRpb25WYWx1ZXMob3B0aW9ucywgbWluTWF4UnVsZU5hbWUsIFttaW4sIG1heF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG1pbikge1xyXG4gICAgICAgICAgICAgICAgc2V0VmFsaWRhdGlvblZhbHVlcyhvcHRpb25zLCBtaW5SdWxlTmFtZSwgbWluKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChtYXgpIHtcclxuICAgICAgICAgICAgICAgIHNldFZhbGlkYXRpb25WYWx1ZXMob3B0aW9ucywgbWF4UnVsZU5hbWUsIG1heCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgYWRhcHRlcnMuYWRkU2luZ2xlVmFsID0gZnVuY3Rpb24gKGFkYXB0ZXJOYW1lLCBhdHRyaWJ1dGUsIHJ1bGVOYW1lKSB7XHJcbiAgICAgICAgLy8vIDxzdW1tYXJ5PkFkZHMgYSBuZXcgYWRhcHRlciB0byBjb252ZXJ0IHVub2J0cnVzaXZlIEhUTUwgaW50byBhIGpRdWVyeSBWYWxpZGF0ZSB2YWxpZGF0aW9uLCB3aGVyZVxyXG4gICAgICAgIC8vLyB0aGUgalF1ZXJ5IFZhbGlkYXRlIHZhbGlkYXRpb24gcnVsZSBoYXMgYSBzaW5nbGUgdmFsdWUuPC9zdW1tYXJ5PlxyXG4gICAgICAgIC8vLyA8cGFyYW0gbmFtZT1cImFkYXB0ZXJOYW1lXCIgdHlwZT1cIlN0cmluZ1wiPlRoZSBuYW1lIG9mIHRoZSBhZGFwdGVyIHRvIGJlIGFkZGVkLiBUaGlzIG1hdGNoZXMgdGhlIG5hbWUgdXNlZFxyXG4gICAgICAgIC8vLyBpbiB0aGUgZGF0YS12YWwtbm5ubiBIVE1MIGF0dHJpYnV0ZSh3aGVyZSBubm5uIGlzIHRoZSBhZGFwdGVyIG5hbWUpLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiYXR0cmlidXRlXCIgdHlwZT1cIlN0cmluZ1wiPltPcHRpb25hbF0gVGhlIG5hbWUgb2YgdGhlIEhUTUwgYXR0cmlidXRlIHRoYXQgY29udGFpbnMgdGhlIHZhbHVlLlxyXG4gICAgICAgIC8vLyBUaGUgZGVmYXVsdCBpcyBcInZhbFwiLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxwYXJhbSBuYW1lPVwicnVsZU5hbWVcIiB0eXBlPVwiU3RyaW5nXCIgb3B0aW9uYWw9XCJ0cnVlXCI+W09wdGlvbmFsXSBUaGUgbmFtZSBvZiB0aGUgalF1ZXJ5IFZhbGlkYXRlIHJ1bGUuIElmIG5vdCBwcm92aWRlZCwgdGhlIHZhbHVlXHJcbiAgICAgICAgLy8vIG9mIGFkYXB0ZXJOYW1lIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLjwvcGFyYW0+XHJcbiAgICAgICAgLy8vIDxyZXR1cm5zIHR5cGU9XCJqUXVlcnkudmFsaWRhdG9yLnVub2J0cnVzaXZlLmFkYXB0ZXJzXCIgLz5cclxuICAgICAgICByZXR1cm4gdGhpcy5hZGQoYWRhcHRlck5hbWUsIFthdHRyaWJ1dGUgfHwgXCJ2YWxcIl0sIGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHNldFZhbGlkYXRpb25WYWx1ZXMob3B0aW9ucywgcnVsZU5hbWUgfHwgYWRhcHRlck5hbWUsIG9wdGlvbnMucGFyYW1zW2F0dHJpYnV0ZV0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAkalF2YWwuYWRkTWV0aG9kKFwiX19kdW1teV9fXCIsIGZ1bmN0aW9uICh2YWx1ZSwgZWxlbWVudCwgcGFyYW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9KTtcclxuXHJcbiAgICAkalF2YWwuYWRkTWV0aG9kKFwicmVnZXhcIiwgZnVuY3Rpb24gKHZhbHVlLCBlbGVtZW50LCBwYXJhbXMpIHtcclxuICAgICAgICB2YXIgbWF0Y2g7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWwoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtYXRjaCA9IG5ldyBSZWdFeHAocGFyYW1zKS5leGVjKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gKG1hdGNoICYmIChtYXRjaC5pbmRleCA9PT0gMCkgJiYgKG1hdGNoWzBdLmxlbmd0aCA9PT0gdmFsdWUubGVuZ3RoKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAkalF2YWwuYWRkTWV0aG9kKFwibm9uYWxwaGFtaW5cIiwgZnVuY3Rpb24gKHZhbHVlLCBlbGVtZW50LCBub25hbHBoYW1pbikge1xyXG4gICAgICAgIHZhciBtYXRjaDtcclxuICAgICAgICBpZiAobm9uYWxwaGFtaW4pIHtcclxuICAgICAgICAgICAgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXFxXL2cpO1xyXG4gICAgICAgICAgICBtYXRjaCA9IG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+PSBub25hbHBoYW1pbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCRqUXZhbC5tZXRob2RzLmV4dGVuc2lvbikge1xyXG4gICAgICAgIGFkYXB0ZXJzLmFkZFNpbmdsZVZhbChcImFjY2VwdFwiLCBcIm1pbXR5cGVcIik7XHJcbiAgICAgICAgYWRhcHRlcnMuYWRkU2luZ2xlVmFsKFwiZXh0ZW5zaW9uXCIsIFwiZXh0ZW5zaW9uXCIpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgd2hlbiB0aGUgJ2V4dGVuc2lvbicgdmFsaWRhdGlvbiBtZXRob2QgZG9lcyBub3QgZXhpc3QsIHN1Y2ggYXMgd2l0aCB2ZXJzaW9uc1xyXG4gICAgICAgIC8vIG9mIEpRdWVyeSBWYWxpZGF0aW9uIHBsdWdpbiBwcmlvciB0byAxLjEwLCB3ZSBzaG91bGQgdXNlIHRoZSAnYWNjZXB0JyBtZXRob2QgZm9yXHJcbiAgICAgICAgLy8gdmFsaWRhdGluZyB0aGUgZXh0ZW5zaW9uLCBhbmQgaWdub3JlIG1pbWUtdHlwZSB2YWxpZGF0aW9ucyBhcyB0aGV5IGFyZSBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICAgIGFkYXB0ZXJzLmFkZFNpbmdsZVZhbChcImV4dGVuc2lvblwiLCBcImV4dGVuc2lvblwiLCBcImFjY2VwdFwiKTtcclxuICAgIH1cclxuXHJcbiAgICBhZGFwdGVycy5hZGRTaW5nbGVWYWwoXCJyZWdleFwiLCBcInBhdHRlcm5cIik7XHJcbiAgICBhZGFwdGVycy5hZGRCb29sKFwiY3JlZGl0Y2FyZFwiKS5hZGRCb29sKFwiZGF0ZVwiKS5hZGRCb29sKFwiZGlnaXRzXCIpLmFkZEJvb2woXCJlbWFpbFwiKS5hZGRCb29sKFwibnVtYmVyXCIpLmFkZEJvb2woXCJ1cmxcIik7XHJcbiAgICBhZGFwdGVycy5hZGRNaW5NYXgoXCJsZW5ndGhcIiwgXCJtaW5sZW5ndGhcIiwgXCJtYXhsZW5ndGhcIiwgXCJyYW5nZWxlbmd0aFwiKS5hZGRNaW5NYXgoXCJyYW5nZVwiLCBcIm1pblwiLCBcIm1heFwiLCBcInJhbmdlXCIpO1xyXG4gICAgYWRhcHRlcnMuYWRkTWluTWF4KFwibWlubGVuZ3RoXCIsIFwibWlubGVuZ3RoXCIpLmFkZE1pbk1heChcIm1heGxlbmd0aFwiLCBcIm1pbmxlbmd0aFwiLCBcIm1heGxlbmd0aFwiKTtcclxuICAgIGFkYXB0ZXJzLmFkZChcImVxdWFsdG9cIiwgW1wib3RoZXJcIl0sIGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHByZWZpeCA9IGdldE1vZGVsUHJlZml4KG9wdGlvbnMuZWxlbWVudC5uYW1lKSxcclxuICAgICAgICAgICAgb3RoZXIgPSBvcHRpb25zLnBhcmFtcy5vdGhlcixcclxuICAgICAgICAgICAgZnVsbE90aGVyTmFtZSA9IGFwcGVuZE1vZGVsUHJlZml4KG90aGVyLCBwcmVmaXgpLFxyXG4gICAgICAgICAgICBlbGVtZW50ID0gJChvcHRpb25zLmZvcm0pLmZpbmQoXCI6aW5wdXRcIikuZmlsdGVyKFwiW25hbWU9J1wiICsgZXNjYXBlQXR0cmlidXRlVmFsdWUoZnVsbE90aGVyTmFtZSkgKyBcIiddXCIpWzBdO1xyXG5cclxuICAgICAgICBzZXRWYWxpZGF0aW9uVmFsdWVzKG9wdGlvbnMsIFwiZXF1YWxUb1wiLCBlbGVtZW50KTtcclxuICAgIH0pO1xyXG4gICAgYWRhcHRlcnMuYWRkKFwicmVxdWlyZWRcIiwgZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAvLyBqUXVlcnkgVmFsaWRhdGUgZXF1YXRlcyBcInJlcXVpcmVkXCIgd2l0aCBcIm1hbmRhdG9yeVwiIGZvciBjaGVja2JveCBlbGVtZW50c1xyXG4gICAgICAgIGlmIChvcHRpb25zLmVsZW1lbnQudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSBcIklOUFVUXCIgfHwgb3B0aW9ucy5lbGVtZW50LnR5cGUudG9VcHBlckNhc2UoKSAhPT0gXCJDSEVDS0JPWFwiKSB7XHJcbiAgICAgICAgICAgIHNldFZhbGlkYXRpb25WYWx1ZXMob3B0aW9ucywgXCJyZXF1aXJlZFwiLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGFkYXB0ZXJzLmFkZChcInJlbW90ZVwiLCBbXCJ1cmxcIiwgXCJ0eXBlXCIsIFwiYWRkaXRpb25hbGZpZWxkc1wiXSwgZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSB7XHJcbiAgICAgICAgICAgIHVybDogb3B0aW9ucy5wYXJhbXMudXJsLFxyXG4gICAgICAgICAgICB0eXBlOiBvcHRpb25zLnBhcmFtcy50eXBlIHx8IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIGRhdGE6IHt9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAgICAgcHJlZml4ID0gZ2V0TW9kZWxQcmVmaXgob3B0aW9ucy5lbGVtZW50Lm5hbWUpO1xyXG5cclxuICAgICAgICAkLmVhY2goc3BsaXRBbmRUcmltKG9wdGlvbnMucGFyYW1zLmFkZGl0aW9uYWxmaWVsZHMgfHwgb3B0aW9ucy5lbGVtZW50Lm5hbWUpLCBmdW5jdGlvbiAoaSwgZmllbGROYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbU5hbWUgPSBhcHBlbmRNb2RlbFByZWZpeChmaWVsZE5hbWUsIHByZWZpeCk7XHJcbiAgICAgICAgICAgIHZhbHVlLmRhdGFbcGFyYW1OYW1lXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9ICQob3B0aW9ucy5mb3JtKS5maW5kKFwiOmlucHV0XCIpLmZpbHRlcihcIltuYW1lPSdcIiArIGVzY2FwZUF0dHJpYnV0ZVZhbHVlKHBhcmFtTmFtZSkgKyBcIiddXCIpO1xyXG4gICAgICAgICAgICAgICAgLy8gRm9yIGNoZWNrYm94ZXMgYW5kIHJhZGlvIGJ1dHRvbnMsIG9ubHkgcGljayB1cCB2YWx1ZXMgZnJvbSBjaGVja2VkIGZpZWxkcy5cclxuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5pcyhcIjpjaGVja2JveFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZC5maWx0ZXIoXCI6Y2hlY2tlZFwiKS52YWwoKSB8fCBmaWVsZC5maWx0ZXIoXCI6aGlkZGVuXCIpLnZhbCgpIHx8ICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmllbGQuaXMoXCI6cmFkaW9cIikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmllbGQuZmlsdGVyKFwiOmNoZWNrZWRcIikudmFsKCkgfHwgJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmllbGQudmFsKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHNldFZhbGlkYXRpb25WYWx1ZXMob3B0aW9ucywgXCJyZW1vdGVcIiwgdmFsdWUpO1xyXG4gICAgfSk7XHJcbiAgICBhZGFwdGVycy5hZGQoXCJwYXNzd29yZFwiLCBbXCJtaW5cIiwgXCJub25hbHBoYW1pblwiLCBcInJlZ2V4XCJdLCBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIGlmIChvcHRpb25zLnBhcmFtcy5taW4pIHtcclxuICAgICAgICAgICAgc2V0VmFsaWRhdGlvblZhbHVlcyhvcHRpb25zLCBcIm1pbmxlbmd0aFwiLCBvcHRpb25zLnBhcmFtcy5taW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5wYXJhbXMubm9uYWxwaGFtaW4pIHtcclxuICAgICAgICAgICAgc2V0VmFsaWRhdGlvblZhbHVlcyhvcHRpb25zLCBcIm5vbmFscGhhbWluXCIsIG9wdGlvbnMucGFyYW1zLm5vbmFscGhhbWluKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMucGFyYW1zLnJlZ2V4KSB7XHJcbiAgICAgICAgICAgIHNldFZhbGlkYXRpb25WYWx1ZXMob3B0aW9ucywgXCJyZWdleFwiLCBvcHRpb25zLnBhcmFtcy5yZWdleCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgJChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgJGpRdmFsLnVub2J0cnVzaXZlLnBhcnNlKGRvY3VtZW50KTtcclxuICAgIH0pO1xyXG59KGpRdWVyeSkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2pxdWVyeS12YWxpZGF0aW9uLXVub2J0cnVzaXZlL2pxdWVyeS52YWxpZGF0ZS51bm9idHJ1c2l2ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohIHRldGhlciAxLjQuMyAqL1xuXG4oZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuVGV0aGVyID0gZmFjdG9yeSgpO1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG52YXIgVGV0aGVyQmFzZSA9IHVuZGVmaW5lZDtcbmlmICh0eXBlb2YgVGV0aGVyQmFzZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgVGV0aGVyQmFzZSA9IHsgbW9kdWxlczogW10gfTtcbn1cblxudmFyIHplcm9FbGVtZW50ID0gbnVsbDtcblxuLy8gU2FtZSBhcyBuYXRpdmUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0LCBleGNlcHQgaXQgdGFrZXMgaW50byBhY2NvdW50IHBhcmVudCA8ZnJhbWU+IG9mZnNldHNcbi8vIGlmIHRoZSBlbGVtZW50IGxpZXMgd2l0aGluIGEgbmVzdGVkIGRvY3VtZW50ICg8ZnJhbWU+IG9yIDxpZnJhbWU+LWxpa2UpLlxuZnVuY3Rpb24gZ2V0QWN0dWFsQm91bmRpbmdDbGllbnRSZWN0KG5vZGUpIHtcbiAgdmFyIGJvdW5kaW5nUmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgLy8gVGhlIG9yaWdpbmFsIG9iamVjdCByZXR1cm5lZCBieSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgaW1tdXRhYmxlLCBzbyB3ZSBjbG9uZSBpdFxuICAvLyBXZSBjYW4ndCB1c2UgZXh0ZW5kIGJlY2F1c2UgdGhlIHByb3BlcnRpZXMgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIG9iamVjdCBieSBoYXNPd25Qcm9wZXJ0eSBpbiBJRTlcbiAgdmFyIHJlY3QgPSB7fTtcbiAgZm9yICh2YXIgayBpbiBib3VuZGluZ1JlY3QpIHtcbiAgICByZWN0W2tdID0gYm91bmRpbmdSZWN0W2tdO1xuICB9XG5cbiAgaWYgKG5vZGUub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICB2YXIgX2ZyYW1lRWxlbWVudCA9IG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5mcmFtZUVsZW1lbnQ7XG4gICAgaWYgKF9mcmFtZUVsZW1lbnQpIHtcbiAgICAgIHZhciBmcmFtZVJlY3QgPSBnZXRBY3R1YWxCb3VuZGluZ0NsaWVudFJlY3QoX2ZyYW1lRWxlbWVudCk7XG4gICAgICByZWN0LnRvcCArPSBmcmFtZVJlY3QudG9wO1xuICAgICAgcmVjdC5ib3R0b20gKz0gZnJhbWVSZWN0LnRvcDtcbiAgICAgIHJlY3QubGVmdCArPSBmcmFtZVJlY3QubGVmdDtcbiAgICAgIHJlY3QucmlnaHQgKz0gZnJhbWVSZWN0LmxlZnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudHMoZWwpIHtcbiAgLy8gSW4gZmlyZWZveCBpZiB0aGUgZWwgaXMgaW5zaWRlIGFuIGlmcmFtZSB3aXRoIGRpc3BsYXk6IG5vbmU7IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCkgd2lsbCByZXR1cm4gbnVsbDtcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gIHZhciBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCkgfHwge307XG4gIHZhciBwb3NpdGlvbiA9IGNvbXB1dGVkU3R5bGUucG9zaXRpb247XG4gIHZhciBwYXJlbnRzID0gW107XG5cbiAgaWYgKHBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIFtlbF07XG4gIH1cblxuICB2YXIgcGFyZW50ID0gZWw7XG4gIHdoaWxlICgocGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUpICYmIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT09IDEpIHtcbiAgICB2YXIgc3R5bGUgPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpO1xuICAgIH0gY2F0Y2ggKGVycikge31cblxuICAgIGlmICh0eXBlb2Ygc3R5bGUgPT09ICd1bmRlZmluZWQnIHx8IHN0eWxlID09PSBudWxsKSB7XG4gICAgICBwYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICAgIHJldHVybiBwYXJlbnRzO1xuICAgIH1cblxuICAgIHZhciBfc3R5bGUgPSBzdHlsZTtcbiAgICB2YXIgb3ZlcmZsb3cgPSBfc3R5bGUub3ZlcmZsb3c7XG4gICAgdmFyIG92ZXJmbG93WCA9IF9zdHlsZS5vdmVyZmxvd1g7XG4gICAgdmFyIG92ZXJmbG93WSA9IF9zdHlsZS5vdmVyZmxvd1k7XG5cbiAgICBpZiAoLyhhdXRvfHNjcm9sbHxvdmVybGF5KS8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkpIHtcbiAgICAgIGlmIChwb3NpdGlvbiAhPT0gJ2Fic29sdXRlJyB8fCBbJ3JlbGF0aXZlJywgJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5kZXhPZihzdHlsZS5wb3NpdGlvbikgPj0gMCkge1xuICAgICAgICBwYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwYXJlbnRzLnB1c2goZWwub3duZXJEb2N1bWVudC5ib2R5KTtcblxuICAvLyBJZiB0aGUgbm9kZSBpcyB3aXRoaW4gYSBmcmFtZSwgYWNjb3VudCBmb3IgdGhlIHBhcmVudCB3aW5kb3cgc2Nyb2xsXG4gIGlmIChlbC5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCkge1xuICAgIHBhcmVudHMucHVzaChlbC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KTtcbiAgfVxuXG4gIHJldHVybiBwYXJlbnRzO1xufVxuXG52YXIgdW5pcXVlSWQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgaWQgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiArK2lkO1xuICB9O1xufSkoKTtcblxudmFyIHplcm9Qb3NDYWNoZSA9IHt9O1xudmFyIGdldE9yaWdpbiA9IGZ1bmN0aW9uIGdldE9yaWdpbigpIHtcbiAgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIHVuZm9ydHVuYXRlbHkgdG9vIGFjY3VyYXRlLiAgSXQgaW50cm9kdWNlcyBhIHBpeGVsIG9yIHR3byBvZlxuICAvLyBqaXR0ZXIgYXMgdGhlIHVzZXIgc2Nyb2xscyB0aGF0IG1lc3NlcyB3aXRoIG91ciBhYmlsaXR5IHRvIGRldGVjdCBpZiB0d28gcG9zaXRpb25zXG4gIC8vIGFyZSBlcXVpdmlsYW50IG9yIG5vdC4gIFdlIHBsYWNlIGFuIGVsZW1lbnQgYXQgdGhlIHRvcCBsZWZ0IG9mIHRoZSBwYWdlIHRoYXQgd2lsbFxuICAvLyBnZXQgdGhlIHNhbWUgaml0dGVyLCBzbyB3ZSBjYW4gY2FuY2VsIHRoZSB0d28gb3V0LlxuICB2YXIgbm9kZSA9IHplcm9FbGVtZW50O1xuICBpZiAoIW5vZGUgfHwgIWRvY3VtZW50LmJvZHkuY29udGFpbnMobm9kZSkpIHtcbiAgICBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGV0aGVyLWlkJywgdW5pcXVlSWQoKSk7XG4gICAgZXh0ZW5kKG5vZGUuc3R5bGUsIHtcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0pO1xuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub2RlKTtcblxuICAgIHplcm9FbGVtZW50ID0gbm9kZTtcbiAgfVxuXG4gIHZhciBpZCA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXRldGhlci1pZCcpO1xuICBpZiAodHlwZW9mIHplcm9Qb3NDYWNoZVtpZF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgemVyb1Bvc0NhY2hlW2lkXSA9IGdldEFjdHVhbEJvdW5kaW5nQ2xpZW50UmVjdChub2RlKTtcblxuICAgIC8vIENsZWFyIHRoZSBjYWNoZSB3aGVuIHRoaXMgcG9zaXRpb24gY2FsbCBpcyBkb25lXG4gICAgZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgZGVsZXRlIHplcm9Qb3NDYWNoZVtpZF07XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gemVyb1Bvc0NhY2hlW2lkXTtcbn07XG5cbmZ1bmN0aW9uIHJlbW92ZVV0aWxFbGVtZW50cygpIHtcbiAgaWYgKHplcm9FbGVtZW50KSB7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh6ZXJvRWxlbWVudCk7XG4gIH1cbiAgemVyb0VsZW1lbnQgPSBudWxsO1xufTtcblxuZnVuY3Rpb24gZ2V0Qm91bmRzKGVsKSB7XG4gIHZhciBkb2MgPSB1bmRlZmluZWQ7XG4gIGlmIChlbCA9PT0gZG9jdW1lbnQpIHtcbiAgICBkb2MgPSBkb2N1bWVudDtcbiAgICBlbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICBkb2MgPSBlbC5vd25lckRvY3VtZW50O1xuICB9XG5cbiAgdmFyIGRvY0VsID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuICB2YXIgYm94ID0gZ2V0QWN0dWFsQm91bmRpbmdDbGllbnRSZWN0KGVsKTtcblxuICB2YXIgb3JpZ2luID0gZ2V0T3JpZ2luKCk7XG5cbiAgYm94LnRvcCAtPSBvcmlnaW4udG9wO1xuICBib3gubGVmdCAtPSBvcmlnaW4ubGVmdDtcblxuICBpZiAodHlwZW9mIGJveC53aWR0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBib3gud2lkdGggPSBkb2N1bWVudC5ib2R5LnNjcm9sbFdpZHRoIC0gYm94LmxlZnQgLSBib3gucmlnaHQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBib3guaGVpZ2h0ID09PSAndW5kZWZpbmVkJykge1xuICAgIGJveC5oZWlnaHQgPSBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCAtIGJveC50b3AgLSBib3guYm90dG9tO1xuICB9XG5cbiAgYm94LnRvcCA9IGJveC50b3AgLSBkb2NFbC5jbGllbnRUb3A7XG4gIGJveC5sZWZ0ID0gYm94LmxlZnQgLSBkb2NFbC5jbGllbnRMZWZ0O1xuICBib3gucmlnaHQgPSBkb2MuYm9keS5jbGllbnRXaWR0aCAtIGJveC53aWR0aCAtIGJveC5sZWZ0O1xuICBib3guYm90dG9tID0gZG9jLmJvZHkuY2xpZW50SGVpZ2h0IC0gYm94LmhlaWdodCAtIGJveC50b3A7XG5cbiAgcmV0dXJuIGJveDtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsKSB7XG4gIHJldHVybiBlbC5vZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xufVxuXG52YXIgX3Njcm9sbEJhclNpemUgPSBudWxsO1xuZnVuY3Rpb24gZ2V0U2Nyb2xsQmFyU2l6ZSgpIHtcbiAgaWYgKF9zY3JvbGxCYXJTaXplKSB7XG4gICAgcmV0dXJuIF9zY3JvbGxCYXJTaXplO1xuICB9XG4gIHZhciBpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBpbm5lci5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgaW5uZXIuc3R5bGUuaGVpZ2h0ID0gJzIwMHB4JztcblxuICB2YXIgb3V0ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZXh0ZW5kKG91dGVyLnN0eWxlLCB7XG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgIHZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgIHdpZHRoOiAnMjAwcHgnLFxuICAgIGhlaWdodDogJzE1MHB4JyxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbidcbiAgfSk7XG5cbiAgb3V0ZXIuYXBwZW5kQ2hpbGQoaW5uZXIpO1xuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXIpO1xuXG4gIHZhciB3aWR0aENvbnRhaW5lZCA9IGlubmVyLm9mZnNldFdpZHRoO1xuICBvdXRlci5zdHlsZS5vdmVyZmxvdyA9ICdzY3JvbGwnO1xuICB2YXIgd2lkdGhTY3JvbGwgPSBpbm5lci5vZmZzZXRXaWR0aDtcblxuICBpZiAod2lkdGhDb250YWluZWQgPT09IHdpZHRoU2Nyb2xsKSB7XG4gICAgd2lkdGhTY3JvbGwgPSBvdXRlci5jbGllbnRXaWR0aDtcbiAgfVxuXG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQob3V0ZXIpO1xuXG4gIHZhciB3aWR0aCA9IHdpZHRoQ29udGFpbmVkIC0gd2lkdGhTY3JvbGw7XG5cbiAgX3Njcm9sbEJhclNpemUgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiB3aWR0aCB9O1xuICByZXR1cm4gX3Njcm9sbEJhclNpemU7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgdmFyIG91dCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gIHZhciBhcmdzID0gW107XG5cbiAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcblxuICBhcmdzLnNsaWNlKDEpLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChvYmopIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKCh7fSkuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICBvdXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgbmFtZSkge1xuICBpZiAodHlwZW9mIGVsLmNsYXNzTGlzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBuYW1lLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XG4gICAgICBpZiAoY2xzLnRyaW0oKSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnKF58ICknICsgbmFtZS5zcGxpdCgnICcpLmpvaW4oJ3wnKSArICcoIHwkKScsICdnaScpO1xuICAgIHZhciBjbGFzc05hbWUgPSBnZXRDbGFzc05hbWUoZWwpLnJlcGxhY2UocmVnZXgsICcgJyk7XG4gICAgc2V0Q2xhc3NOYW1lKGVsLCBjbGFzc05hbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZENsYXNzKGVsLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgZWwuY2xhc3NMaXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIG5hbWUuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgIGlmIChjbHMudHJpbSgpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZW1vdmVDbGFzcyhlbCwgbmFtZSk7XG4gICAgdmFyIGNscyA9IGdldENsYXNzTmFtZShlbCkgKyAoJyAnICsgbmFtZSk7XG4gICAgc2V0Q2xhc3NOYW1lKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc0NsYXNzKGVsLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgZWwuY2xhc3NMaXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSk7XG4gIH1cbiAgdmFyIGNsYXNzTmFtZSA9IGdldENsYXNzTmFtZShlbCk7XG4gIHJldHVybiBuZXcgUmVnRXhwKCcoXnwgKScgKyBuYW1lICsgJyggfCQpJywgJ2dpJykudGVzdChjbGFzc05hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDbGFzc05hbWUoZWwpIHtcbiAgLy8gQ2FuJ3QgdXNlIGp1c3QgU1ZHQW5pbWF0ZWRTdHJpbmcgaGVyZSBzaW5jZSBub2RlcyB3aXRoaW4gYSBGcmFtZSBpbiBJRSBoYXZlXG4gIC8vIGNvbXBsZXRlbHkgc2VwYXJhdGVseSBTVkdBbmltYXRlZFN0cmluZyBiYXNlIGNsYXNzZXNcbiAgaWYgKGVsLmNsYXNzTmFtZSBpbnN0YW5jZW9mIGVsLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuU1ZHQW5pbWF0ZWRTdHJpbmcpIHtcbiAgICByZXR1cm4gZWwuY2xhc3NOYW1lLmJhc2VWYWw7XG4gIH1cbiAgcmV0dXJuIGVsLmNsYXNzTmFtZTtcbn1cblxuZnVuY3Rpb24gc2V0Q2xhc3NOYW1lKGVsLCBjbGFzc05hbWUpIHtcbiAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNsYXNzTmFtZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzZXMoZWwsIGFkZCwgYWxsKSB7XG4gIC8vIE9mIHRoZSBzZXQgb2YgJ2FsbCcgY2xhc3Nlcywgd2UgbmVlZCB0aGUgJ2FkZCcgY2xhc3NlcywgYW5kIG9ubHkgdGhlXG4gIC8vICdhZGQnIGNsYXNzZXMgdG8gYmUgc2V0LlxuICBhbGwuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XG4gICAgaWYgKGFkZC5pbmRleE9mKGNscykgPT09IC0xICYmIGhhc0NsYXNzKGVsLCBjbHMpKSB7XG4gICAgICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbiAgICB9XG4gIH0pO1xuXG4gIGFkZC5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICBpZiAoIWhhc0NsYXNzKGVsLCBjbHMpKSB7XG4gICAgICBhZGRDbGFzcyhlbCwgY2xzKTtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgZGVmZXJyZWQgPSBbXTtcblxudmFyIGRlZmVyID0gZnVuY3Rpb24gZGVmZXIoZm4pIHtcbiAgZGVmZXJyZWQucHVzaChmbik7XG59O1xuXG52YXIgZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgdmFyIGZuID0gdW5kZWZpbmVkO1xuICB3aGlsZSAoZm4gPSBkZWZlcnJlZC5wb3AoKSkge1xuICAgIGZuKCk7XG4gIH1cbn07XG5cbnZhciBFdmVudGVkID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXZlbnRlZCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnRlZCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRXZlbnRlZCwgW3tcbiAgICBrZXk6ICdvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKGV2ZW50LCBoYW5kbGVyLCBjdHgpIHtcbiAgICAgIHZhciBvbmNlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAzIHx8IGFyZ3VtZW50c1szXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbM107XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5iaW5kaW5ncyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLmJpbmRpbmdzW2V2ZW50XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYmluZGluZ3NbZXZlbnRdLnB1c2goeyBoYW5kbGVyOiBoYW5kbGVyLCBjdHg6IGN0eCwgb25jZTogb25jZSB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbmNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25jZShldmVudCwgaGFuZGxlciwgY3R4KSB7XG4gICAgICB0aGlzLm9uKGV2ZW50LCBoYW5kbGVyLCBjdHgsIHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29mZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mZihldmVudCwgaGFuZGxlcikge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLmJpbmRpbmdzID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgdGhpcy5iaW5kaW5nc1tldmVudF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkZWxldGUgdGhpcy5iaW5kaW5nc1tldmVudF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5iaW5kaW5nc1tldmVudF0ubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYmluZGluZ3NbZXZlbnRdW2ldLmhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbZXZlbnRdLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3RyaWdnZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmlnZ2VyKGV2ZW50KSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuYmluZGluZ3MgIT09ICd1bmRlZmluZWQnICYmIHRoaXMuYmluZGluZ3NbZXZlbnRdKSB7XG4gICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5iaW5kaW5nc1tldmVudF0ubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIF9iaW5kaW5ncyRldmVudCRpID0gdGhpcy5iaW5kaW5nc1tldmVudF1baV07XG4gICAgICAgICAgdmFyIGhhbmRsZXIgPSBfYmluZGluZ3MkZXZlbnQkaS5oYW5kbGVyO1xuICAgICAgICAgIHZhciBjdHggPSBfYmluZGluZ3MkZXZlbnQkaS5jdHg7XG4gICAgICAgICAgdmFyIG9uY2UgPSBfYmluZGluZ3MkZXZlbnQkaS5vbmNlO1xuXG4gICAgICAgICAgdmFyIGNvbnRleHQgPSBjdHg7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGFuZGxlci5hcHBseShjb250ZXh0LCBhcmdzKTtcblxuICAgICAgICAgIGlmIChvbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzW2V2ZW50XS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRXZlbnRlZDtcbn0pKCk7XG5cblRldGhlckJhc2UuVXRpbHMgPSB7XG4gIGdldEFjdHVhbEJvdW5kaW5nQ2xpZW50UmVjdDogZ2V0QWN0dWFsQm91bmRpbmdDbGllbnRSZWN0LFxuICBnZXRTY3JvbGxQYXJlbnRzOiBnZXRTY3JvbGxQYXJlbnRzLFxuICBnZXRCb3VuZHM6IGdldEJvdW5kcyxcbiAgZ2V0T2Zmc2V0UGFyZW50OiBnZXRPZmZzZXRQYXJlbnQsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICBhZGRDbGFzczogYWRkQ2xhc3MsXG4gIHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzcyxcbiAgaGFzQ2xhc3M6IGhhc0NsYXNzLFxuICB1cGRhdGVDbGFzc2VzOiB1cGRhdGVDbGFzc2VzLFxuICBkZWZlcjogZGVmZXIsXG4gIGZsdXNoOiBmbHVzaCxcbiAgdW5pcXVlSWQ6IHVuaXF1ZUlkLFxuICBFdmVudGVkOiBFdmVudGVkLFxuICBnZXRTY3JvbGxCYXJTaXplOiBnZXRTY3JvbGxCYXJTaXplLFxuICByZW1vdmVVdGlsRWxlbWVudHM6IHJlbW92ZVV0aWxFbGVtZW50c1xufTtcbi8qIGdsb2JhbHMgVGV0aGVyQmFzZSwgcGVyZm9ybWFuY2UgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVsncmV0dXJuJ10pIF9pWydyZXR1cm4nXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7IH0gfTsgfSkoKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3g2LCBfeDcsIF94OCkgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeDYsIHByb3BlcnR5ID0gX3g3LCByZWNlaXZlciA9IF94ODsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeDYgPSBwYXJlbnQ7IF94NyA9IHByb3BlcnR5OyBfeDggPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaWYgKHR5cGVvZiBUZXRoZXJCYXNlID09PSAndW5kZWZpbmVkJykge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGluY2x1ZGUgdGhlIHV0aWxzLmpzIGZpbGUgYmVmb3JlIHRldGhlci5qcycpO1xufVxuXG52YXIgX1RldGhlckJhc2UkVXRpbHMgPSBUZXRoZXJCYXNlLlV0aWxzO1xudmFyIGdldFNjcm9sbFBhcmVudHMgPSBfVGV0aGVyQmFzZSRVdGlscy5nZXRTY3JvbGxQYXJlbnRzO1xudmFyIGdldEJvdW5kcyA9IF9UZXRoZXJCYXNlJFV0aWxzLmdldEJvdW5kcztcbnZhciBnZXRPZmZzZXRQYXJlbnQgPSBfVGV0aGVyQmFzZSRVdGlscy5nZXRPZmZzZXRQYXJlbnQ7XG52YXIgZXh0ZW5kID0gX1RldGhlckJhc2UkVXRpbHMuZXh0ZW5kO1xudmFyIGFkZENsYXNzID0gX1RldGhlckJhc2UkVXRpbHMuYWRkQ2xhc3M7XG52YXIgcmVtb3ZlQ2xhc3MgPSBfVGV0aGVyQmFzZSRVdGlscy5yZW1vdmVDbGFzcztcbnZhciB1cGRhdGVDbGFzc2VzID0gX1RldGhlckJhc2UkVXRpbHMudXBkYXRlQ2xhc3NlcztcbnZhciBkZWZlciA9IF9UZXRoZXJCYXNlJFV0aWxzLmRlZmVyO1xudmFyIGZsdXNoID0gX1RldGhlckJhc2UkVXRpbHMuZmx1c2g7XG52YXIgZ2V0U2Nyb2xsQmFyU2l6ZSA9IF9UZXRoZXJCYXNlJFV0aWxzLmdldFNjcm9sbEJhclNpemU7XG52YXIgcmVtb3ZlVXRpbEVsZW1lbnRzID0gX1RldGhlckJhc2UkVXRpbHMucmVtb3ZlVXRpbEVsZW1lbnRzO1xuXG5mdW5jdGlvbiB3aXRoaW4oYSwgYikge1xuICB2YXIgZGlmZiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IDEgOiBhcmd1bWVudHNbMl07XG5cbiAgcmV0dXJuIGEgKyBkaWZmID49IGIgJiYgYiA+PSBhIC0gZGlmZjtcbn1cblxudmFyIHRyYW5zZm9ybUtleSA9IChmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gIHZhciB0cmFuc2Zvcm1zID0gWyd0cmFuc2Zvcm0nLCAnV2Via2l0VHJhbnNmb3JtJywgJ09UcmFuc2Zvcm0nLCAnTW96VHJhbnNmb3JtJywgJ21zVHJhbnNmb3JtJ107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3Jtcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBrZXkgPSB0cmFuc2Zvcm1zW2ldO1xuICAgIGlmIChlbC5zdHlsZVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG59KSgpO1xuXG52YXIgdGV0aGVycyA9IFtdO1xuXG52YXIgcG9zaXRpb24gPSBmdW5jdGlvbiBwb3NpdGlvbigpIHtcbiAgdGV0aGVycy5mb3JFYWNoKGZ1bmN0aW9uICh0ZXRoZXIpIHtcbiAgICB0ZXRoZXIucG9zaXRpb24oZmFsc2UpO1xuICB9KTtcbiAgZmx1c2goKTtcbn07XG5cbmZ1bmN0aW9uIG5vdygpIHtcbiAgaWYgKHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfVxuICByZXR1cm4gK25ldyBEYXRlKCk7XG59XG5cbihmdW5jdGlvbiAoKSB7XG4gIHZhciBsYXN0Q2FsbCA9IG51bGw7XG4gIHZhciBsYXN0RHVyYXRpb24gPSBudWxsO1xuICB2YXIgcGVuZGluZ1RpbWVvdXQgPSBudWxsO1xuXG4gIHZhciB0aWNrID0gZnVuY3Rpb24gdGljaygpIHtcbiAgICBpZiAodHlwZW9mIGxhc3REdXJhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgbGFzdER1cmF0aW9uID4gMTYpIHtcbiAgICAgIC8vIFdlIHZvbHVudGFyaWx5IHRocm90dGxlIG91cnNlbHZlcyBpZiB3ZSBjYW4ndCBtYW5hZ2UgNjBmcHNcbiAgICAgIGxhc3REdXJhdGlvbiA9IE1hdGgubWluKGxhc3REdXJhdGlvbiAtIDE2LCAyNTApO1xuXG4gICAgICAvLyBKdXN0IGluIGNhc2UgdGhpcyBpcyB0aGUgbGFzdCBldmVudCwgcmVtZW1iZXIgdG8gcG9zaXRpb24ganVzdCBvbmNlIG1vcmVcbiAgICAgIHBlbmRpbmdUaW1lb3V0ID0gc2V0VGltZW91dCh0aWNrLCAyNTApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbGFzdENhbGwgIT09ICd1bmRlZmluZWQnICYmIG5vdygpIC0gbGFzdENhbGwgPCAxMCkge1xuICAgICAgLy8gU29tZSBicm93c2VycyBjYWxsIGV2ZW50cyBhIGxpdHRsZSB0b28gZnJlcXVlbnRseSwgcmVmdXNlIHRvIHJ1biBtb3JlIHRoYW4gaXMgcmVhc29uYWJsZVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwZW5kaW5nVGltZW91dCAhPSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQocGVuZGluZ1RpbWVvdXQpO1xuICAgICAgcGVuZGluZ1RpbWVvdXQgPSBudWxsO1xuICAgIH1cblxuICAgIGxhc3RDYWxsID0gbm93KCk7XG4gICAgcG9zaXRpb24oKTtcbiAgICBsYXN0RHVyYXRpb24gPSBub3coKSAtIGxhc3RDYWxsO1xuICB9O1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgWydyZXNpemUnLCAnc2Nyb2xsJywgJ3RvdWNobW92ZSddLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdGljayk7XG4gICAgfSk7XG4gIH1cbn0pKCk7XG5cbnZhciBNSVJST1JfTFIgPSB7XG4gIGNlbnRlcjogJ2NlbnRlcicsXG4gIGxlZnQ6ICdyaWdodCcsXG4gIHJpZ2h0OiAnbGVmdCdcbn07XG5cbnZhciBNSVJST1JfVEIgPSB7XG4gIG1pZGRsZTogJ21pZGRsZScsXG4gIHRvcDogJ2JvdHRvbScsXG4gIGJvdHRvbTogJ3RvcCdcbn07XG5cbnZhciBPRkZTRVRfTUFQID0ge1xuICB0b3A6IDAsXG4gIGxlZnQ6IDAsXG4gIG1pZGRsZTogJzUwJScsXG4gIGNlbnRlcjogJzUwJScsXG4gIGJvdHRvbTogJzEwMCUnLFxuICByaWdodDogJzEwMCUnXG59O1xuXG52YXIgYXV0b1RvRml4ZWRBdHRhY2htZW50ID0gZnVuY3Rpb24gYXV0b1RvRml4ZWRBdHRhY2htZW50KGF0dGFjaG1lbnQsIHJlbGF0aXZlVG9BdHRhY2htZW50KSB7XG4gIHZhciBsZWZ0ID0gYXR0YWNobWVudC5sZWZ0O1xuICB2YXIgdG9wID0gYXR0YWNobWVudC50b3A7XG5cbiAgaWYgKGxlZnQgPT09ICdhdXRvJykge1xuICAgIGxlZnQgPSBNSVJST1JfTFJbcmVsYXRpdmVUb0F0dGFjaG1lbnQubGVmdF07XG4gIH1cblxuICBpZiAodG9wID09PSAnYXV0bycpIHtcbiAgICB0b3AgPSBNSVJST1JfVEJbcmVsYXRpdmVUb0F0dGFjaG1lbnQudG9wXTtcbiAgfVxuXG4gIHJldHVybiB7IGxlZnQ6IGxlZnQsIHRvcDogdG9wIH07XG59O1xuXG52YXIgYXR0YWNobWVudFRvT2Zmc2V0ID0gZnVuY3Rpb24gYXR0YWNobWVudFRvT2Zmc2V0KGF0dGFjaG1lbnQpIHtcbiAgdmFyIGxlZnQgPSBhdHRhY2htZW50LmxlZnQ7XG4gIHZhciB0b3AgPSBhdHRhY2htZW50LnRvcDtcblxuICBpZiAodHlwZW9mIE9GRlNFVF9NQVBbYXR0YWNobWVudC5sZWZ0XSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsZWZ0ID0gT0ZGU0VUX01BUFthdHRhY2htZW50LmxlZnRdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBPRkZTRVRfTUFQW2F0dGFjaG1lbnQudG9wXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0b3AgPSBPRkZTRVRfTUFQW2F0dGFjaG1lbnQudG9wXTtcbiAgfVxuXG4gIHJldHVybiB7IGxlZnQ6IGxlZnQsIHRvcDogdG9wIH07XG59O1xuXG5mdW5jdGlvbiBhZGRPZmZzZXQoKSB7XG4gIHZhciBvdXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBvZmZzZXRzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgb2Zmc2V0c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIG9mZnNldHMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciB0b3AgPSBfcmVmLnRvcDtcbiAgICB2YXIgbGVmdCA9IF9yZWYubGVmdDtcblxuICAgIGlmICh0eXBlb2YgdG9wID09PSAnc3RyaW5nJykge1xuICAgICAgdG9wID0gcGFyc2VGbG9hdCh0b3AsIDEwKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAnc3RyaW5nJykge1xuICAgICAgbGVmdCA9IHBhcnNlRmxvYXQobGVmdCwgMTApO1xuICAgIH1cblxuICAgIG91dC50b3AgKz0gdG9wO1xuICAgIG91dC5sZWZ0ICs9IGxlZnQ7XG4gIH0pO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIG9mZnNldFRvUHgob2Zmc2V0LCBzaXplKSB7XG4gIGlmICh0eXBlb2Ygb2Zmc2V0LmxlZnQgPT09ICdzdHJpbmcnICYmIG9mZnNldC5sZWZ0LmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICBvZmZzZXQubGVmdCA9IHBhcnNlRmxvYXQob2Zmc2V0LmxlZnQsIDEwKSAvIDEwMCAqIHNpemUud2lkdGg7XG4gIH1cbiAgaWYgKHR5cGVvZiBvZmZzZXQudG9wID09PSAnc3RyaW5nJyAmJiBvZmZzZXQudG9wLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICBvZmZzZXQudG9wID0gcGFyc2VGbG9hdChvZmZzZXQudG9wLCAxMCkgLyAxMDAgKiBzaXplLmhlaWdodDtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbnZhciBwYXJzZU9mZnNldCA9IGZ1bmN0aW9uIHBhcnNlT2Zmc2V0KHZhbHVlKSB7XG4gIHZhciBfdmFsdWUkc3BsaXQgPSB2YWx1ZS5zcGxpdCgnICcpO1xuXG4gIHZhciBfdmFsdWUkc3BsaXQyID0gX3NsaWNlZFRvQXJyYXkoX3ZhbHVlJHNwbGl0LCAyKTtcblxuICB2YXIgdG9wID0gX3ZhbHVlJHNwbGl0MlswXTtcbiAgdmFyIGxlZnQgPSBfdmFsdWUkc3BsaXQyWzFdO1xuXG4gIHJldHVybiB7IHRvcDogdG9wLCBsZWZ0OiBsZWZ0IH07XG59O1xudmFyIHBhcnNlQXR0YWNobWVudCA9IHBhcnNlT2Zmc2V0O1xuXG52YXIgVGV0aGVyQ2xhc3MgPSAoZnVuY3Rpb24gKF9FdmVudGVkKSB7XG4gIF9pbmhlcml0cyhUZXRoZXJDbGFzcywgX0V2ZW50ZWQpO1xuXG4gIGZ1bmN0aW9uIFRldGhlckNsYXNzKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRldGhlckNsYXNzKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFRldGhlckNsYXNzLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb24uYmluZCh0aGlzKTtcblxuICAgIHRldGhlcnMucHVzaCh0aGlzKTtcblxuICAgIHRoaXMuaGlzdG9yeSA9IFtdO1xuXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMsIGZhbHNlKTtcblxuICAgIFRldGhlckJhc2UubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgIGlmICh0eXBlb2YgbW9kdWxlLmluaXRpYWxpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG1vZHVsZS5pbml0aWFsaXplLmNhbGwoX3RoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5wb3NpdGlvbigpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRldGhlckNsYXNzLCBbe1xuICAgIGtleTogJ2dldENsYXNzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2xhc3MoKSB7XG4gICAgICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gJycgOiBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgY2xhc3NlcyA9IHRoaXMub3B0aW9ucy5jbGFzc2VzO1xuXG4gICAgICBpZiAodHlwZW9mIGNsYXNzZXMgIT09ICd1bmRlZmluZWQnICYmIGNsYXNzZXNba2V5XSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNsYXNzZXNba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmNsYXNzUHJlZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY2xhc3NQcmVmaXggKyAnLScgKyBrZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NldE9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgcG9zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICBvZmZzZXQ6ICcwIDAnLFxuICAgICAgICB0YXJnZXRPZmZzZXQ6ICcwIDAnLFxuICAgICAgICB0YXJnZXRBdHRhY2htZW50OiAnYXV0byBhdXRvJyxcbiAgICAgICAgY2xhc3NQcmVmaXg6ICd0ZXRoZXInXG4gICAgICB9O1xuXG4gICAgICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICB2YXIgX29wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgZWxlbWVudCA9IF9vcHRpb25zLmVsZW1lbnQ7XG4gICAgICB2YXIgdGFyZ2V0ID0gX29wdGlvbnMudGFyZ2V0O1xuICAgICAgdmFyIHRhcmdldE1vZGlmaWVyID0gX29wdGlvbnMudGFyZ2V0TW9kaWZpZXI7XG5cbiAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgIHRoaXMudGFyZ2V0TW9kaWZpZXIgPSB0YXJnZXRNb2RpZmllcjtcblxuICAgICAgaWYgKHRoaXMudGFyZ2V0ID09PSAndmlld3BvcnQnKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gZG9jdW1lbnQuYm9keTtcbiAgICAgICAgdGhpcy50YXJnZXRNb2RpZmllciA9ICd2aXNpYmxlJztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50YXJnZXQgPT09ICdzY3JvbGwtaGFuZGxlJykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IGRvY3VtZW50LmJvZHk7XG4gICAgICAgIHRoaXMudGFyZ2V0TW9kaWZpZXIgPSAnc2Nyb2xsLWhhbmRsZSc7XG4gICAgICB9XG5cbiAgICAgIFsnZWxlbWVudCcsICd0YXJnZXQnXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBfdGhpczJba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RldGhlciBFcnJvcjogQm90aCBlbGVtZW50IGFuZCB0YXJnZXQgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIF90aGlzMltrZXldLmpxdWVyeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBfdGhpczJba2V5XSA9IF90aGlzMltrZXldWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBfdGhpczJba2V5XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBfdGhpczJba2V5XSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoX3RoaXMyW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgYWRkQ2xhc3ModGhpcy5lbGVtZW50LCB0aGlzLmdldENsYXNzKCdlbGVtZW50JykpO1xuICAgICAgaWYgKCEodGhpcy5vcHRpb25zLmFkZFRhcmdldENsYXNzZXMgPT09IGZhbHNlKSkge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLnRhcmdldCwgdGhpcy5nZXRDbGFzcygndGFyZ2V0JykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5hdHRhY2htZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGV0aGVyIEVycm9yOiBZb3UgbXVzdCBwcm92aWRlIGFuIGF0dGFjaG1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50YXJnZXRBdHRhY2htZW50ID0gcGFyc2VBdHRhY2htZW50KHRoaXMub3B0aW9ucy50YXJnZXRBdHRhY2htZW50KTtcbiAgICAgIHRoaXMuYXR0YWNobWVudCA9IHBhcnNlQXR0YWNobWVudCh0aGlzLm9wdGlvbnMuYXR0YWNobWVudCk7XG4gICAgICB0aGlzLm9mZnNldCA9IHBhcnNlT2Zmc2V0KHRoaXMub3B0aW9ucy5vZmZzZXQpO1xuICAgICAgdGhpcy50YXJnZXRPZmZzZXQgPSBwYXJzZU9mZnNldCh0aGlzLm9wdGlvbnMudGFyZ2V0T2Zmc2V0KTtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNjcm9sbFBhcmVudHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50YXJnZXRNb2RpZmllciA9PT0gJ3Njcm9sbC1oYW5kbGUnKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50cyA9IFt0aGlzLnRhcmdldF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNjcm9sbFBhcmVudHMgPSBnZXRTY3JvbGxQYXJlbnRzKHRoaXMudGFyZ2V0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCEodGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlKSkge1xuICAgICAgICB0aGlzLmVuYWJsZShwb3MpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFRhcmdldEJvdW5kcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRhcmdldEJvdW5kcygpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy50YXJnZXRNb2RpZmllciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0TW9kaWZpZXIgPT09ICd2aXNpYmxlJykge1xuICAgICAgICAgIGlmICh0aGlzLnRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiBwYWdlWU9mZnNldCwgbGVmdDogcGFnZVhPZmZzZXQsIGhlaWdodDogaW5uZXJIZWlnaHQsIHdpZHRoOiBpbm5lcldpZHRoIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBib3VuZHMgPSBnZXRCb3VuZHModGhpcy50YXJnZXQpO1xuXG4gICAgICAgICAgICB2YXIgb3V0ID0ge1xuICAgICAgICAgICAgICBoZWlnaHQ6IGJvdW5kcy5oZWlnaHQsXG4gICAgICAgICAgICAgIHdpZHRoOiBib3VuZHMud2lkdGgsXG4gICAgICAgICAgICAgIHRvcDogYm91bmRzLnRvcCxcbiAgICAgICAgICAgICAgbGVmdDogYm91bmRzLmxlZnRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG91dC5oZWlnaHQgPSBNYXRoLm1pbihvdXQuaGVpZ2h0LCBib3VuZHMuaGVpZ2h0IC0gKHBhZ2VZT2Zmc2V0IC0gYm91bmRzLnRvcCkpO1xuICAgICAgICAgICAgb3V0LmhlaWdodCA9IE1hdGgubWluKG91dC5oZWlnaHQsIGJvdW5kcy5oZWlnaHQgLSAoYm91bmRzLnRvcCArIGJvdW5kcy5oZWlnaHQgLSAocGFnZVlPZmZzZXQgKyBpbm5lckhlaWdodCkpKTtcbiAgICAgICAgICAgIG91dC5oZWlnaHQgPSBNYXRoLm1pbihpbm5lckhlaWdodCwgb3V0LmhlaWdodCk7XG4gICAgICAgICAgICBvdXQuaGVpZ2h0IC09IDI7XG5cbiAgICAgICAgICAgIG91dC53aWR0aCA9IE1hdGgubWluKG91dC53aWR0aCwgYm91bmRzLndpZHRoIC0gKHBhZ2VYT2Zmc2V0IC0gYm91bmRzLmxlZnQpKTtcbiAgICAgICAgICAgIG91dC53aWR0aCA9IE1hdGgubWluKG91dC53aWR0aCwgYm91bmRzLndpZHRoIC0gKGJvdW5kcy5sZWZ0ICsgYm91bmRzLndpZHRoIC0gKHBhZ2VYT2Zmc2V0ICsgaW5uZXJXaWR0aCkpKTtcbiAgICAgICAgICAgIG91dC53aWR0aCA9IE1hdGgubWluKGlubmVyV2lkdGgsIG91dC53aWR0aCk7XG4gICAgICAgICAgICBvdXQud2lkdGggLT0gMjtcblxuICAgICAgICAgICAgaWYgKG91dC50b3AgPCBwYWdlWU9mZnNldCkge1xuICAgICAgICAgICAgICBvdXQudG9wID0gcGFnZVlPZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3V0LmxlZnQgPCBwYWdlWE9mZnNldCkge1xuICAgICAgICAgICAgICBvdXQubGVmdCA9IHBhZ2VYT2Zmc2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRhcmdldE1vZGlmaWVyID09PSAnc2Nyb2xsLWhhbmRsZScpIHtcbiAgICAgICAgICB2YXIgYm91bmRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgICAgICBpZiAodGFyZ2V0ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgICAgIGJvdW5kcyA9IHtcbiAgICAgICAgICAgICAgbGVmdDogcGFnZVhPZmZzZXQsXG4gICAgICAgICAgICAgIHRvcDogcGFnZVlPZmZzZXQsXG4gICAgICAgICAgICAgIGhlaWdodDogaW5uZXJIZWlnaHQsXG4gICAgICAgICAgICAgIHdpZHRoOiBpbm5lcldpZHRoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBib3VuZHMgPSBnZXRCb3VuZHModGFyZ2V0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XG5cbiAgICAgICAgICB2YXIgaGFzQm90dG9tU2Nyb2xsID0gdGFyZ2V0LnNjcm9sbFdpZHRoID4gdGFyZ2V0LmNsaWVudFdpZHRoIHx8IFtzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYXS5pbmRleE9mKCdzY3JvbGwnKSA+PSAwIHx8IHRoaXMudGFyZ2V0ICE9PSBkb2N1bWVudC5ib2R5O1xuXG4gICAgICAgICAgdmFyIHNjcm9sbEJvdHRvbSA9IDA7XG4gICAgICAgICAgaWYgKGhhc0JvdHRvbVNjcm9sbCkge1xuICAgICAgICAgICAgc2Nyb2xsQm90dG9tID0gMTU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQgLSBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlclRvcFdpZHRoKSAtIHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyQm90dG9tV2lkdGgpIC0gc2Nyb2xsQm90dG9tO1xuXG4gICAgICAgICAgdmFyIG91dCA9IHtcbiAgICAgICAgICAgIHdpZHRoOiAxNSxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0ICogMC45NzUgKiAoaGVpZ2h0IC8gdGFyZ2V0LnNjcm9sbEhlaWdodCksXG4gICAgICAgICAgICBsZWZ0OiBib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCAtIHBhcnNlRmxvYXQoc3R5bGUuYm9yZGVyTGVmdFdpZHRoKSAtIDE1XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBmaXRBZGogPSAwO1xuICAgICAgICAgIGlmIChoZWlnaHQgPCA0MDggJiYgdGhpcy50YXJnZXQgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIGZpdEFkaiA9IC0wLjAwMDExICogTWF0aC5wb3coaGVpZ2h0LCAyKSAtIDAuMDA3MjcgKiBoZWlnaHQgKyAyMi41ODtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy50YXJnZXQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIG91dC5oZWlnaHQgPSBNYXRoLm1heChvdXQuaGVpZ2h0LCAyNCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNjcm9sbFBlcmNlbnRhZ2UgPSB0aGlzLnRhcmdldC5zY3JvbGxUb3AgLyAodGFyZ2V0LnNjcm9sbEhlaWdodCAtIGhlaWdodCk7XG4gICAgICAgICAgb3V0LnRvcCA9IHNjcm9sbFBlcmNlbnRhZ2UgKiAoaGVpZ2h0IC0gb3V0LmhlaWdodCAtIGZpdEFkaikgKyBib3VuZHMudG9wICsgcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJUb3BXaWR0aCk7XG5cbiAgICAgICAgICBpZiAodGhpcy50YXJnZXQgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIG91dC5oZWlnaHQgPSBNYXRoLm1heChvdXQuaGVpZ2h0LCAyNCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdldEJvdW5kcyh0aGlzLnRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnY2xlYXJDYWNoZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyQ2FjaGUoKSB7XG4gICAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NhY2hlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FjaGUoaywgZ2V0dGVyKSB7XG4gICAgICAvLyBNb3JlIHRoYW4gb25lIG1vZHVsZSB3aWxsIG9mdGVuIG5lZWQgdGhlIHNhbWUgRE9NIGluZm8sIHNvXG4gICAgICAvLyB3ZSBrZWVwIGEgY2FjaGUgd2hpY2ggaXMgY2xlYXJlZCBvbiBlYWNoIHBvc2l0aW9uIGNhbGxcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fY2FjaGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fY2FjaGVba10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlW2tdID0gZ2V0dGVyLmNhbGwodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZVtrXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbmFibGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHBvcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgIGlmICghKHRoaXMub3B0aW9ucy5hZGRUYXJnZXRDbGFzc2VzID09PSBmYWxzZSkpIHtcbiAgICAgICAgYWRkQ2xhc3ModGhpcy50YXJnZXQsIHRoaXMuZ2V0Q2xhc3MoJ2VuYWJsZWQnKSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyh0aGlzLmVsZW1lbnQsIHRoaXMuZ2V0Q2xhc3MoJ2VuYWJsZWQnKSk7XG4gICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICB0aGlzLnNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQgIT09IF90aGlzMy50YXJnZXQub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgIHBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBfdGhpczMucG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHBvcykge1xuICAgICAgICB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGlzYWJsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgcmVtb3ZlQ2xhc3ModGhpcy50YXJnZXQsIHRoaXMuZ2V0Q2xhc3MoJ2VuYWJsZWQnKSk7XG4gICAgICByZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnQsIHRoaXMuZ2V0Q2xhc3MoJ2VuYWJsZWQnKSk7XG4gICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNjcm9sbFBhcmVudHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgICBwYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgX3RoaXM0LnBvc2l0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdGhpcy5kaXNhYmxlKCk7XG5cbiAgICAgIHRldGhlcnMuZm9yRWFjaChmdW5jdGlvbiAodGV0aGVyLCBpKSB7XG4gICAgICAgIGlmICh0ZXRoZXIgPT09IF90aGlzNSkge1xuICAgICAgICAgIHRldGhlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gUmVtb3ZlIGFueSBlbGVtZW50cyB3ZSB3ZXJlIHVzaW5nIGZvciBjb252ZW5pZW5jZSBmcm9tIHRoZSBET01cbiAgICAgIGlmICh0ZXRoZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZW1vdmVVdGlsRWxlbWVudHMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVBdHRhY2hDbGFzc2VzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQXR0YWNoQ2xhc3NlcyhlbGVtZW50QXR0YWNoLCB0YXJnZXRBdHRhY2gpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICBlbGVtZW50QXR0YWNoID0gZWxlbWVudEF0dGFjaCB8fCB0aGlzLmF0dGFjaG1lbnQ7XG4gICAgICB0YXJnZXRBdHRhY2ggPSB0YXJnZXRBdHRhY2ggfHwgdGhpcy50YXJnZXRBdHRhY2htZW50O1xuICAgICAgdmFyIHNpZGVzID0gWydsZWZ0JywgJ3RvcCcsICdib3R0b20nLCAncmlnaHQnLCAnbWlkZGxlJywgJ2NlbnRlciddO1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2FkZEF0dGFjaENsYXNzZXMgIT09ICd1bmRlZmluZWQnICYmIHRoaXMuX2FkZEF0dGFjaENsYXNzZXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIHVwZGF0ZUF0dGFjaENsYXNzZXMgY2FuIGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZSBpbiBhIHBvc2l0aW9uIGNhbGwsIHNvXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gY2xlYW4gdXAgYWZ0ZXIgb3Vyc2VsdmVzIHN1Y2ggdGhhdCB3aGVuIHRoZSBsYXN0IGRlZmVyIGdldHNcbiAgICAgICAgLy8gcmFuIGl0IGRvZXNuJ3QgYWRkIGFueSBleHRyYSBjbGFzc2VzIGZyb20gcHJldmlvdXMgY2FsbHMuXG4gICAgICAgIHRoaXMuX2FkZEF0dGFjaENsYXNzZXMuc3BsaWNlKDAsIHRoaXMuX2FkZEF0dGFjaENsYXNzZXMubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9hZGRBdHRhY2hDbGFzc2VzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLl9hZGRBdHRhY2hDbGFzc2VzID0gW107XG4gICAgICB9XG4gICAgICB2YXIgYWRkID0gdGhpcy5fYWRkQXR0YWNoQ2xhc3NlcztcblxuICAgICAgaWYgKGVsZW1lbnRBdHRhY2gudG9wKSB7XG4gICAgICAgIGFkZC5wdXNoKHRoaXMuZ2V0Q2xhc3MoJ2VsZW1lbnQtYXR0YWNoZWQnKSArICctJyArIGVsZW1lbnRBdHRhY2gudG9wKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50QXR0YWNoLmxlZnQpIHtcbiAgICAgICAgYWRkLnB1c2godGhpcy5nZXRDbGFzcygnZWxlbWVudC1hdHRhY2hlZCcpICsgJy0nICsgZWxlbWVudEF0dGFjaC5sZWZ0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0YXJnZXRBdHRhY2gudG9wKSB7XG4gICAgICAgIGFkZC5wdXNoKHRoaXMuZ2V0Q2xhc3MoJ3RhcmdldC1hdHRhY2hlZCcpICsgJy0nICsgdGFyZ2V0QXR0YWNoLnRvcCk7XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0QXR0YWNoLmxlZnQpIHtcbiAgICAgICAgYWRkLnB1c2godGhpcy5nZXRDbGFzcygndGFyZ2V0LWF0dGFjaGVkJykgKyAnLScgKyB0YXJnZXRBdHRhY2gubGVmdCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbGwgPSBbXTtcbiAgICAgIHNpZGVzLmZvckVhY2goZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgICAgYWxsLnB1c2goX3RoaXM2LmdldENsYXNzKCdlbGVtZW50LWF0dGFjaGVkJykgKyAnLScgKyBzaWRlKTtcbiAgICAgICAgYWxsLnB1c2goX3RoaXM2LmdldENsYXNzKCd0YXJnZXQtYXR0YWNoZWQnKSArICctJyArIHNpZGUpO1xuICAgICAgfSk7XG5cbiAgICAgIGRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIF90aGlzNi5fYWRkQXR0YWNoQ2xhc3NlcyAhPT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlQ2xhc3NlcyhfdGhpczYuZWxlbWVudCwgX3RoaXM2Ll9hZGRBdHRhY2hDbGFzc2VzLCBhbGwpO1xuICAgICAgICBpZiAoIShfdGhpczYub3B0aW9ucy5hZGRUYXJnZXRDbGFzc2VzID09PSBmYWxzZSkpIHtcbiAgICAgICAgICB1cGRhdGVDbGFzc2VzKF90aGlzNi50YXJnZXQsIF90aGlzNi5fYWRkQXR0YWNoQ2xhc3NlcywgYWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBfdGhpczYuX2FkZEF0dGFjaENsYXNzZXM7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwb3NpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIHZhciBmbHVzaENoYW5nZXMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzBdO1xuXG4gICAgICAvLyBmbHVzaENoYW5nZXMgY29tbWl0cyB0aGUgY2hhbmdlcyBpbW1lZGlhdGVseSwgbGVhdmUgdHJ1ZSB1bmxlc3MgeW91IGFyZSBwb3NpdGlvbmluZyBtdWx0aXBsZVxuICAgICAgLy8gdGV0aGVycyAoaW4gd2hpY2ggY2FzZSBjYWxsIFRldGhlci5VdGlscy5mbHVzaCB5b3Vyc2VsZiB3aGVuIHlvdSdyZSBkb25lKVxuXG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuXG4gICAgICAvLyBUdXJuICdhdXRvJyBhdHRhY2htZW50cyBpbnRvIHRoZSBhcHByb3ByaWF0ZSBjb3JuZXIgb3IgZWRnZVxuICAgICAgdmFyIHRhcmdldEF0dGFjaG1lbnQgPSBhdXRvVG9GaXhlZEF0dGFjaG1lbnQodGhpcy50YXJnZXRBdHRhY2htZW50LCB0aGlzLmF0dGFjaG1lbnQpO1xuXG4gICAgICB0aGlzLnVwZGF0ZUF0dGFjaENsYXNzZXModGhpcy5hdHRhY2htZW50LCB0YXJnZXRBdHRhY2htZW50KTtcblxuICAgICAgdmFyIGVsZW1lbnRQb3MgPSB0aGlzLmNhY2hlKCdlbGVtZW50LWJvdW5kcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldEJvdW5kcyhfdGhpczcuZWxlbWVudCk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIHdpZHRoID0gZWxlbWVudFBvcy53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBlbGVtZW50UG9zLmhlaWdodDtcblxuICAgICAgaWYgKHdpZHRoID09PSAwICYmIGhlaWdodCA9PT0gMCAmJiB0eXBlb2YgdGhpcy5sYXN0U2l6ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIF9sYXN0U2l6ZSA9IHRoaXMubGFzdFNpemU7XG5cbiAgICAgICAgLy8gV2UgY2FjaGUgdGhlIGhlaWdodCBhbmQgd2lkdGggdG8gbWFrZSBpdCBwb3NzaWJsZSB0byBwb3NpdGlvbiBlbGVtZW50cyB0aGF0IGFyZVxuICAgICAgICAvLyBnZXR0aW5nIGhpZGRlbi5cbiAgICAgICAgd2lkdGggPSBfbGFzdFNpemUud2lkdGg7XG4gICAgICAgIGhlaWdodCA9IF9sYXN0U2l6ZS5oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxhc3RTaXplID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gICAgICB9XG5cbiAgICAgIHZhciB0YXJnZXRQb3MgPSB0aGlzLmNhY2hlKCd0YXJnZXQtYm91bmRzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXM3LmdldFRhcmdldEJvdW5kcygpO1xuICAgICAgfSk7XG4gICAgICB2YXIgdGFyZ2V0U2l6ZSA9IHRhcmdldFBvcztcblxuICAgICAgLy8gR2V0IGFuIGFjdHVhbCBweCBvZmZzZXQgZnJvbSB0aGUgYXR0YWNobWVudFxuICAgICAgdmFyIG9mZnNldCA9IG9mZnNldFRvUHgoYXR0YWNobWVudFRvT2Zmc2V0KHRoaXMuYXR0YWNobWVudCksIHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTtcbiAgICAgIHZhciB0YXJnZXRPZmZzZXQgPSBvZmZzZXRUb1B4KGF0dGFjaG1lbnRUb09mZnNldCh0YXJnZXRBdHRhY2htZW50KSwgdGFyZ2V0U2l6ZSk7XG5cbiAgICAgIHZhciBtYW51YWxPZmZzZXQgPSBvZmZzZXRUb1B4KHRoaXMub2Zmc2V0LCB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7XG4gICAgICB2YXIgbWFudWFsVGFyZ2V0T2Zmc2V0ID0gb2Zmc2V0VG9QeCh0aGlzLnRhcmdldE9mZnNldCwgdGFyZ2V0U2l6ZSk7XG5cbiAgICAgIC8vIEFkZCB0aGUgbWFudWFsbHkgcHJvdmlkZWQgb2Zmc2V0XG4gICAgICBvZmZzZXQgPSBhZGRPZmZzZXQob2Zmc2V0LCBtYW51YWxPZmZzZXQpO1xuICAgICAgdGFyZ2V0T2Zmc2V0ID0gYWRkT2Zmc2V0KHRhcmdldE9mZnNldCwgbWFudWFsVGFyZ2V0T2Zmc2V0KTtcblxuICAgICAgLy8gSXQncyBub3cgb3VyIGdvYWwgdG8gbWFrZSAoZWxlbWVudCBwb3NpdGlvbiArIG9mZnNldCkgPT0gKHRhcmdldCBwb3NpdGlvbiArIHRhcmdldCBvZmZzZXQpXG4gICAgICB2YXIgbGVmdCA9IHRhcmdldFBvcy5sZWZ0ICsgdGFyZ2V0T2Zmc2V0LmxlZnQgLSBvZmZzZXQubGVmdDtcbiAgICAgIHZhciB0b3AgPSB0YXJnZXRQb3MudG9wICsgdGFyZ2V0T2Zmc2V0LnRvcCAtIG9mZnNldC50b3A7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVGV0aGVyQmFzZS5tb2R1bGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBfbW9kdWxlMiA9IFRldGhlckJhc2UubW9kdWxlc1tpXTtcbiAgICAgICAgdmFyIHJldCA9IF9tb2R1bGUyLnBvc2l0aW9uLmNhbGwodGhpcywge1xuICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgdGFyZ2V0QXR0YWNobWVudDogdGFyZ2V0QXR0YWNobWVudCxcbiAgICAgICAgICB0YXJnZXRQb3M6IHRhcmdldFBvcyxcbiAgICAgICAgICBlbGVtZW50UG9zOiBlbGVtZW50UG9zLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgIHRhcmdldE9mZnNldDogdGFyZ2V0T2Zmc2V0LFxuICAgICAgICAgIG1hbnVhbE9mZnNldDogbWFudWFsT2Zmc2V0LFxuICAgICAgICAgIG1hbnVhbFRhcmdldE9mZnNldDogbWFudWFsVGFyZ2V0T2Zmc2V0LFxuICAgICAgICAgIHNjcm9sbGJhclNpemU6IHNjcm9sbGJhclNpemUsXG4gICAgICAgICAgYXR0YWNobWVudDogdGhpcy5hdHRhY2htZW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiByZXQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9wID0gcmV0LnRvcDtcbiAgICAgICAgICBsZWZ0ID0gcmV0LmxlZnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gV2UgZGVzY3JpYmUgdGhlIHBvc2l0aW9uIHRocmVlIGRpZmZlcmVudCB3YXlzIHRvIGdpdmUgdGhlIG9wdGltaXplclxuICAgICAgLy8gYSBjaGFuY2UgdG8gZGVjaWRlIHRoZSBiZXN0IHBvc3NpYmxlIHdheSB0byBwb3NpdGlvbiB0aGUgZWxlbWVudFxuICAgICAgLy8gd2l0aCB0aGUgZmV3ZXN0IHJlcGFpbnRzLlxuICAgICAgdmFyIG5leHQgPSB7XG4gICAgICAgIC8vIEl0J3MgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHBhZ2UgKGFic29sdXRlIHBvc2l0aW9uaW5nIHdoZW5cbiAgICAgICAgLy8gdGhlIGVsZW1lbnQgaXMgYSBjaGlsZCBvZiB0aGUgYm9keSlcbiAgICAgICAgcGFnZToge1xuICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgIGxlZnQ6IGxlZnRcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBJdCdzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydCAoZml4ZWQgcG9zaXRpb25pbmcpXG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgdG9wOiB0b3AgLSBwYWdlWU9mZnNldCxcbiAgICAgICAgICBib3R0b206IHBhZ2VZT2Zmc2V0IC0gdG9wIC0gaGVpZ2h0ICsgaW5uZXJIZWlnaHQsXG4gICAgICAgICAgbGVmdDogbGVmdCAtIHBhZ2VYT2Zmc2V0LFxuICAgICAgICAgIHJpZ2h0OiBwYWdlWE9mZnNldCAtIGxlZnQgLSB3aWR0aCArIGlubmVyV2lkdGhcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGRvYyA9IHRoaXMudGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICB2YXIgd2luID0gZG9jLmRlZmF1bHRWaWV3O1xuXG4gICAgICB2YXIgc2Nyb2xsYmFyU2l6ZSA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICh3aW4uaW5uZXJIZWlnaHQgPiBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkge1xuICAgICAgICBzY3JvbGxiYXJTaXplID0gdGhpcy5jYWNoZSgnc2Nyb2xsYmFyLXNpemUnLCBnZXRTY3JvbGxCYXJTaXplKTtcbiAgICAgICAgbmV4dC52aWV3cG9ydC5ib3R0b20gLT0gc2Nyb2xsYmFyU2l6ZS5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh3aW4uaW5uZXJXaWR0aCA+IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpIHtcbiAgICAgICAgc2Nyb2xsYmFyU2l6ZSA9IHRoaXMuY2FjaGUoJ3Njcm9sbGJhci1zaXplJywgZ2V0U2Nyb2xsQmFyU2l6ZSk7XG4gICAgICAgIG5leHQudmlld3BvcnQucmlnaHQgLT0gc2Nyb2xsYmFyU2l6ZS53aWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKFsnJywgJ3N0YXRpYyddLmluZGV4T2YoZG9jLmJvZHkuc3R5bGUucG9zaXRpb24pID09PSAtMSB8fCBbJycsICdzdGF0aWMnXS5pbmRleE9mKGRvYy5ib2R5LnBhcmVudEVsZW1lbnQuc3R5bGUucG9zaXRpb24pID09PSAtMSkge1xuICAgICAgICAvLyBBYnNvbHV0ZSBwb3NpdGlvbmluZyBpbiB0aGUgYm9keSB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoZSBwYWdlLCBub3QgdGhlICdpbml0aWFsIGNvbnRhaW5pbmcgYmxvY2snXG4gICAgICAgIG5leHQucGFnZS5ib3R0b20gPSBkb2MuYm9keS5zY3JvbGxIZWlnaHQgLSB0b3AgLSBoZWlnaHQ7XG4gICAgICAgIG5leHQucGFnZS5yaWdodCA9IGRvYy5ib2R5LnNjcm9sbFdpZHRoIC0gbGVmdCAtIHdpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vcHRpbWl6YXRpb25zICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLm9wdGlvbnMub3B0aW1pemF0aW9ucy5tb3ZlRWxlbWVudCAhPT0gZmFsc2UgJiYgISh0eXBlb2YgdGhpcy50YXJnZXRNb2RpZmllciAhPT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIG9mZnNldFBhcmVudCA9IF90aGlzNy5jYWNoZSgndGFyZ2V0LW9mZnNldHBhcmVudCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQoX3RoaXM3LnRhcmdldCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIG9mZnNldFBvc2l0aW9uID0gX3RoaXM3LmNhY2hlKCd0YXJnZXQtb2Zmc2V0cGFyZW50LWJvdW5kcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCb3VuZHMob2Zmc2V0UGFyZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50U3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCk7XG4gICAgICAgICAgdmFyIG9mZnNldFBhcmVudFNpemUgPSBvZmZzZXRQb3NpdGlvbjtcblxuICAgICAgICAgIHZhciBvZmZzZXRCb3JkZXIgPSB7fTtcbiAgICAgICAgICBbJ1RvcCcsICdMZWZ0JywgJ0JvdHRvbScsICdSaWdodCddLmZvckVhY2goZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgICAgICAgIG9mZnNldEJvcmRlcltzaWRlLnRvTG93ZXJDYXNlKCldID0gcGFyc2VGbG9hdChvZmZzZXRQYXJlbnRTdHlsZVsnYm9yZGVyJyArIHNpZGUgKyAnV2lkdGgnXSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBvZmZzZXRQb3NpdGlvbi5yaWdodCA9IGRvYy5ib2R5LnNjcm9sbFdpZHRoIC0gb2Zmc2V0UG9zaXRpb24ubGVmdCAtIG9mZnNldFBhcmVudFNpemUud2lkdGggKyBvZmZzZXRCb3JkZXIucmlnaHQ7XG4gICAgICAgICAgb2Zmc2V0UG9zaXRpb24uYm90dG9tID0gZG9jLmJvZHkuc2Nyb2xsSGVpZ2h0IC0gb2Zmc2V0UG9zaXRpb24udG9wIC0gb2Zmc2V0UGFyZW50U2l6ZS5oZWlnaHQgKyBvZmZzZXRCb3JkZXIuYm90dG9tO1xuXG4gICAgICAgICAgaWYgKG5leHQucGFnZS50b3AgPj0gb2Zmc2V0UG9zaXRpb24udG9wICsgb2Zmc2V0Qm9yZGVyLnRvcCAmJiBuZXh0LnBhZ2UuYm90dG9tID49IG9mZnNldFBvc2l0aW9uLmJvdHRvbSkge1xuICAgICAgICAgICAgaWYgKG5leHQucGFnZS5sZWZ0ID49IG9mZnNldFBvc2l0aW9uLmxlZnQgKyBvZmZzZXRCb3JkZXIubGVmdCAmJiBuZXh0LnBhZ2UucmlnaHQgPj0gb2Zmc2V0UG9zaXRpb24ucmlnaHQpIHtcbiAgICAgICAgICAgICAgLy8gV2UncmUgd2l0aGluIHRoZSB2aXNpYmxlIHBhcnQgb2YgdGhlIHRhcmdldCdzIHNjcm9sbCBwYXJlbnRcbiAgICAgICAgICAgICAgdmFyIHNjcm9sbFRvcCA9IG9mZnNldFBhcmVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gb2Zmc2V0UGFyZW50LnNjcm9sbExlZnQ7XG5cbiAgICAgICAgICAgICAgLy8gSXQncyBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgdGFyZ2V0J3Mgb2Zmc2V0IHBhcmVudCAoYWJzb2x1dGUgcG9zaXRpb25pbmcgd2hlblxuICAgICAgICAgICAgICAvLyB0aGUgZWxlbWVudCBpcyBtb3ZlZCB0byBiZSBhIGNoaWxkIG9mIHRoZSB0YXJnZXQncyBvZmZzZXQgcGFyZW50KS5cbiAgICAgICAgICAgICAgbmV4dC5vZmZzZXQgPSB7XG4gICAgICAgICAgICAgICAgdG9wOiBuZXh0LnBhZ2UudG9wIC0gb2Zmc2V0UG9zaXRpb24udG9wICsgc2Nyb2xsVG9wIC0gb2Zmc2V0Qm9yZGVyLnRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0OiBuZXh0LnBhZ2UubGVmdCAtIG9mZnNldFBvc2l0aW9uLmxlZnQgKyBzY3JvbGxMZWZ0IC0gb2Zmc2V0Qm9yZGVyLmxlZnRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGNvdWxkIGFsc28gdHJhdmVsIHVwIHRoZSBET00gYW5kIHRyeSBlYWNoIGNvbnRhaW5pbmcgY29udGV4dCwgcmF0aGVyIHRoYW4gb25seVxuICAgICAgLy8gbG9va2luZyBhdCB0aGUgYm9keSwgYnV0IHdlJ3JlIGdvbm5hIGdldCBkaW1pbmlzaGluZyByZXR1cm5zLlxuXG4gICAgICB0aGlzLm1vdmUobmV4dCk7XG5cbiAgICAgIHRoaXMuaGlzdG9yeS51bnNoaWZ0KG5leHQpO1xuXG4gICAgICBpZiAodGhpcy5oaXN0b3J5Lmxlbmd0aCA+IDMpIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5LnBvcCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmx1c2hDaGFuZ2VzKSB7XG4gICAgICAgIGZsdXNoKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFRIRSBJU1NVRVxuICB9LCB7XG4gICAga2V5OiAnbW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmUocG9zKSB7XG4gICAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgICAgaWYgKCEodHlwZW9mIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlICE9PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2FtZSA9IHt9O1xuXG4gICAgICBmb3IgKHZhciB0eXBlIGluIHBvcykge1xuICAgICAgICBzYW1lW3R5cGVdID0ge307XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHBvc1t0eXBlXSkge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmhpc3RvcnkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IHRoaXMuaGlzdG9yeVtpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnRbdHlwZV0gIT09ICd1bmRlZmluZWQnICYmICF3aXRoaW4ocG9pbnRbdHlwZV1ba2V5XSwgcG9zW3R5cGVdW2tleV0pKSB7XG4gICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgc2FtZVt0eXBlXVtrZXldID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNzcyA9IHsgdG9wOiAnJywgbGVmdDogJycsIHJpZ2h0OiAnJywgYm90dG9tOiAnJyB9O1xuXG4gICAgICB2YXIgdHJhbnNjcmliZSA9IGZ1bmN0aW9uIHRyYW5zY3JpYmUoX3NhbWUsIF9wb3MpIHtcbiAgICAgICAgdmFyIGhhc09wdGltaXphdGlvbnMgPSB0eXBlb2YgX3RoaXM4Lm9wdGlvbnMub3B0aW1pemF0aW9ucyAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIHZhciBncHUgPSBoYXNPcHRpbWl6YXRpb25zID8gX3RoaXM4Lm9wdGlvbnMub3B0aW1pemF0aW9ucy5ncHUgOiBudWxsO1xuICAgICAgICBpZiAoZ3B1ICE9PSBmYWxzZSkge1xuICAgICAgICAgIHZhciB5UG9zID0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICB4UG9zID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChfc2FtZS50b3ApIHtcbiAgICAgICAgICAgIGNzcy50b3AgPSAwO1xuICAgICAgICAgICAgeVBvcyA9IF9wb3MudG9wO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjc3MuYm90dG9tID0gMDtcbiAgICAgICAgICAgIHlQb3MgPSAtX3Bvcy5ib3R0b207XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9zYW1lLmxlZnQpIHtcbiAgICAgICAgICAgIGNzcy5sZWZ0ID0gMDtcbiAgICAgICAgICAgIHhQb3MgPSBfcG9zLmxlZnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNzcy5yaWdodCA9IDA7XG4gICAgICAgICAgICB4UG9zID0gLV9wb3MucmlnaHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKSB7XG4gICAgICAgICAgICAvLyBIdWJTcG90L3RldGhlciMyMDdcbiAgICAgICAgICAgIHZhciByZXRpbmEgPSB3aW5kb3cubWF0Y2hNZWRpYSgnb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMS4zZHBweCknKS5tYXRjaGVzIHx8IHdpbmRvdy5tYXRjaE1lZGlhKCdvbmx5IHNjcmVlbiBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMS4zKScpLm1hdGNoZXM7XG4gICAgICAgICAgICBpZiAoIXJldGluYSkge1xuICAgICAgICAgICAgICB4UG9zID0gTWF0aC5yb3VuZCh4UG9zKTtcbiAgICAgICAgICAgICAgeVBvcyA9IE1hdGgucm91bmQoeVBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3NzW3RyYW5zZm9ybUtleV0gPSAndHJhbnNsYXRlWCgnICsgeFBvcyArICdweCkgdHJhbnNsYXRlWSgnICsgeVBvcyArICdweCknO1xuXG4gICAgICAgICAgaWYgKHRyYW5zZm9ybUtleSAhPT0gJ21zVHJhbnNmb3JtJykge1xuICAgICAgICAgICAgLy8gVGhlIFogdHJhbnNmb3JtIHdpbGwga2VlcCB0aGlzIGluIHRoZSBHUFUgKGZhc3RlciwgYW5kIHByZXZlbnRzIGFydGlmYWN0cyksXG4gICAgICAgICAgICAvLyBidXQgSUU5IGRvZXNuJ3Qgc3VwcG9ydCAzZCB0cmFuc2Zvcm1zIGFuZCB3aWxsIGNob2tlLlxuICAgICAgICAgICAgY3NzW3RyYW5zZm9ybUtleV0gKz0gXCIgdHJhbnNsYXRlWigwKVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoX3NhbWUudG9wKSB7XG4gICAgICAgICAgICBjc3MudG9wID0gX3Bvcy50b3AgKyAncHgnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjc3MuYm90dG9tID0gX3Bvcy5ib3R0b20gKyAncHgnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfc2FtZS5sZWZ0KSB7XG4gICAgICAgICAgICBjc3MubGVmdCA9IF9wb3MubGVmdCArICdweCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNzcy5yaWdodCA9IF9wb3MucmlnaHQgKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIG1vdmVkID0gZmFsc2U7XG4gICAgICBpZiAoKHNhbWUucGFnZS50b3AgfHwgc2FtZS5wYWdlLmJvdHRvbSkgJiYgKHNhbWUucGFnZS5sZWZ0IHx8IHNhbWUucGFnZS5yaWdodCkpIHtcbiAgICAgICAgY3NzLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdHJhbnNjcmliZShzYW1lLnBhZ2UsIHBvcy5wYWdlKTtcbiAgICAgIH0gZWxzZSBpZiAoKHNhbWUudmlld3BvcnQudG9wIHx8IHNhbWUudmlld3BvcnQuYm90dG9tKSAmJiAoc2FtZS52aWV3cG9ydC5sZWZ0IHx8IHNhbWUudmlld3BvcnQucmlnaHQpKSB7XG4gICAgICAgIGNzcy5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgIHRyYW5zY3JpYmUoc2FtZS52aWV3cG9ydCwgcG9zLnZpZXdwb3J0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNhbWUub2Zmc2V0ICE9PSAndW5kZWZpbmVkJyAmJiBzYW1lLm9mZnNldC50b3AgJiYgc2FtZS5vZmZzZXQubGVmdCkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNzcy5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgdmFyIG9mZnNldFBhcmVudCA9IF90aGlzOC5jYWNoZSgndGFyZ2V0LW9mZnNldHBhcmVudCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQoX3RoaXM4LnRhcmdldCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoZ2V0T2Zmc2V0UGFyZW50KF90aGlzOC5lbGVtZW50KSAhPT0gb2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICBkZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzOC5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoX3RoaXM4LmVsZW1lbnQpO1xuICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQuYXBwZW5kQ2hpbGQoX3RoaXM4LmVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJhbnNjcmliZShzYW1lLm9mZnNldCwgcG9zLm9mZnNldCk7XG4gICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICB9KSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3NzLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdHJhbnNjcmliZSh7IHRvcDogdHJ1ZSwgbGVmdDogdHJ1ZSB9LCBwb3MucGFnZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghbW92ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ib2R5RWxlbWVudCkge1xuICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSAhPT0gdGhpcy5vcHRpb25zLmJvZHlFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYm9keUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG9mZnNldFBhcmVudElzQm9keSA9IHRydWU7XG4gICAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gdGhpcy5lbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlICYmIGN1cnJlbnROb2RlLm5vZGVUeXBlID09PSAxICYmIGN1cnJlbnROb2RlLnRhZ05hbWUgIT09ICdCT0RZJykge1xuICAgICAgICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUoY3VycmVudE5vZGUpLnBvc2l0aW9uICE9PSAnc3RhdGljJykge1xuICAgICAgICAgICAgICBvZmZzZXRQYXJlbnRJc0JvZHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIW9mZnNldFBhcmVudElzQm9keSkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQW55IGNzcyBjaGFuZ2Ugd2lsbCB0cmlnZ2VyIGEgcmVwYWludCwgc28gbGV0J3MgYXZvaWQgb25lIGlmIG5vdGhpbmcgY2hhbmdlZFxuICAgICAgdmFyIHdyaXRlQ1NTID0ge307XG4gICAgICB2YXIgd3JpdGUgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBjc3MpIHtcbiAgICAgICAgdmFyIHZhbCA9IGNzc1trZXldO1xuICAgICAgICB2YXIgZWxWYWwgPSB0aGlzLmVsZW1lbnQuc3R5bGVba2V5XTtcblxuICAgICAgICBpZiAoZWxWYWwgIT09IHZhbCkge1xuICAgICAgICAgIHdyaXRlID0gdHJ1ZTtcbiAgICAgICAgICB3cml0ZUNTU1trZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh3cml0ZSkge1xuICAgICAgICBkZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZXh0ZW5kKF90aGlzOC5lbGVtZW50LnN0eWxlLCB3cml0ZUNTUyk7XG4gICAgICAgICAgX3RoaXM4LnRyaWdnZXIoJ3JlcG9zaXRpb25lZCcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGV0aGVyQ2xhc3M7XG59KShFdmVudGVkKTtcblxuVGV0aGVyQ2xhc3MubW9kdWxlcyA9IFtdO1xuXG5UZXRoZXJCYXNlLnBvc2l0aW9uID0gcG9zaXRpb247XG5cbnZhciBUZXRoZXIgPSBleHRlbmQoVGV0aGVyQ2xhc3MsIFRldGhlckJhc2UpO1xuLyogZ2xvYmFscyBUZXRoZXJCYXNlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9zbGljZWRUb0FycmF5ID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbJ3JldHVybiddKSBfaVsncmV0dXJuJ10oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZScpOyB9IH07IH0pKCk7XG5cbnZhciBfVGV0aGVyQmFzZSRVdGlscyA9IFRldGhlckJhc2UuVXRpbHM7XG52YXIgZ2V0Qm91bmRzID0gX1RldGhlckJhc2UkVXRpbHMuZ2V0Qm91bmRzO1xudmFyIGV4dGVuZCA9IF9UZXRoZXJCYXNlJFV0aWxzLmV4dGVuZDtcbnZhciB1cGRhdGVDbGFzc2VzID0gX1RldGhlckJhc2UkVXRpbHMudXBkYXRlQ2xhc3NlcztcbnZhciBkZWZlciA9IF9UZXRoZXJCYXNlJFV0aWxzLmRlZmVyO1xuXG52YXIgQk9VTkRTX0ZPUk1BVCA9IFsnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJ107XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nUmVjdCh0ZXRoZXIsIHRvKSB7XG4gIGlmICh0byA9PT0gJ3Njcm9sbFBhcmVudCcpIHtcbiAgICB0byA9IHRldGhlci5zY3JvbGxQYXJlbnRzWzBdO1xuICB9IGVsc2UgaWYgKHRvID09PSAnd2luZG93Jykge1xuICAgIHRvID0gW3BhZ2VYT2Zmc2V0LCBwYWdlWU9mZnNldCwgaW5uZXJXaWR0aCArIHBhZ2VYT2Zmc2V0LCBpbm5lckhlaWdodCArIHBhZ2VZT2Zmc2V0XTtcbiAgfVxuXG4gIGlmICh0byA9PT0gZG9jdW1lbnQpIHtcbiAgICB0byA9IHRvLmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdG8ubm9kZVR5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBub2RlID0gdG87XG4gICAgICB2YXIgc2l6ZSA9IGdldEJvdW5kcyh0byk7XG4gICAgICB2YXIgcG9zID0gc2l6ZTtcbiAgICAgIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodG8pO1xuXG4gICAgICB0byA9IFtwb3MubGVmdCwgcG9zLnRvcCwgc2l6ZS53aWR0aCArIHBvcy5sZWZ0LCBzaXplLmhlaWdodCArIHBvcy50b3BdO1xuXG4gICAgICAvLyBBY2NvdW50IGFueSBwYXJlbnQgRnJhbWVzIHNjcm9sbCBvZmZzZXRcbiAgICAgIGlmIChub2RlLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50KSB7XG4gICAgICAgIHZhciB3aW4gPSBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgICAgIHRvWzBdICs9IHdpbi5wYWdlWE9mZnNldDtcbiAgICAgICAgdG9bMV0gKz0gd2luLnBhZ2VZT2Zmc2V0O1xuICAgICAgICB0b1syXSArPSB3aW4ucGFnZVhPZmZzZXQ7XG4gICAgICAgIHRvWzNdICs9IHdpbi5wYWdlWU9mZnNldDtcbiAgICAgIH1cblxuICAgICAgQk9VTkRTX0ZPUk1BVC5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlLCBpKSB7XG4gICAgICAgIHNpZGUgPSBzaWRlWzBdLnRvVXBwZXJDYXNlKCkgKyBzaWRlLnN1YnN0cigxKTtcbiAgICAgICAgaWYgKHNpZGUgPT09ICdUb3AnIHx8IHNpZGUgPT09ICdMZWZ0Jykge1xuICAgICAgICAgIHRvW2ldICs9IHBhcnNlRmxvYXQoc3R5bGVbJ2JvcmRlcicgKyBzaWRlICsgJ1dpZHRoJ10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvW2ldIC09IHBhcnNlRmxvYXQoc3R5bGVbJ2JvcmRlcicgKyBzaWRlICsgJ1dpZHRoJ10pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSgpO1xuICB9XG5cbiAgcmV0dXJuIHRvO1xufVxuXG5UZXRoZXJCYXNlLm1vZHVsZXMucHVzaCh7XG4gIHBvc2l0aW9uOiBmdW5jdGlvbiBwb3NpdGlvbihfcmVmKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciB0b3AgPSBfcmVmLnRvcDtcbiAgICB2YXIgbGVmdCA9IF9yZWYubGVmdDtcbiAgICB2YXIgdGFyZ2V0QXR0YWNobWVudCA9IF9yZWYudGFyZ2V0QXR0YWNobWVudDtcblxuICAgIGlmICghdGhpcy5vcHRpb25zLmNvbnN0cmFpbnRzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgX2NhY2hlID0gdGhpcy5jYWNoZSgnZWxlbWVudC1ib3VuZHMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ2V0Qm91bmRzKF90aGlzLmVsZW1lbnQpO1xuICAgIH0pO1xuXG4gICAgdmFyIGhlaWdodCA9IF9jYWNoZS5oZWlnaHQ7XG4gICAgdmFyIHdpZHRoID0gX2NhY2hlLndpZHRoO1xuXG4gICAgaWYgKHdpZHRoID09PSAwICYmIGhlaWdodCA9PT0gMCAmJiB0eXBlb2YgdGhpcy5sYXN0U2l6ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBfbGFzdFNpemUgPSB0aGlzLmxhc3RTaXplO1xuXG4gICAgICAvLyBIYW5kbGUgdGhlIGl0ZW0gZ2V0dGluZyBoaWRkZW4gYXMgYSByZXN1bHQgb2Ygb3VyIHBvc2l0aW9uaW5nIHdpdGhvdXQgZ2xpdGNoaW5nXG4gICAgICAvLyB0aGUgY2xhc3NlcyBpbiBhbmQgb3V0XG4gICAgICB3aWR0aCA9IF9sYXN0U2l6ZS53aWR0aDtcbiAgICAgIGhlaWdodCA9IF9sYXN0U2l6ZS5oZWlnaHQ7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldFNpemUgPSB0aGlzLmNhY2hlKCd0YXJnZXQtYm91bmRzJywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90aGlzLmdldFRhcmdldEJvdW5kcygpO1xuICAgIH0pO1xuXG4gICAgdmFyIHRhcmdldEhlaWdodCA9IHRhcmdldFNpemUuaGVpZ2h0O1xuICAgIHZhciB0YXJnZXRXaWR0aCA9IHRhcmdldFNpemUud2lkdGg7XG5cbiAgICB2YXIgYWxsQ2xhc3NlcyA9IFt0aGlzLmdldENsYXNzKCdwaW5uZWQnKSwgdGhpcy5nZXRDbGFzcygnb3V0LW9mLWJvdW5kcycpXTtcblxuICAgIHRoaXMub3B0aW9ucy5jb25zdHJhaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG4gICAgICB2YXIgb3V0T2ZCb3VuZHNDbGFzcyA9IGNvbnN0cmFpbnQub3V0T2ZCb3VuZHNDbGFzcztcbiAgICAgIHZhciBwaW5uZWRDbGFzcyA9IGNvbnN0cmFpbnQucGlubmVkQ2xhc3M7XG5cbiAgICAgIGlmIChvdXRPZkJvdW5kc0NsYXNzKSB7XG4gICAgICAgIGFsbENsYXNzZXMucHVzaChvdXRPZkJvdW5kc0NsYXNzKTtcbiAgICAgIH1cbiAgICAgIGlmIChwaW5uZWRDbGFzcykge1xuICAgICAgICBhbGxDbGFzc2VzLnB1c2gocGlubmVkQ2xhc3MpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWxsQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgIFsnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJ10uZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgICBhbGxDbGFzc2VzLnB1c2goY2xzICsgJy0nICsgc2lkZSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciBhZGRDbGFzc2VzID0gW107XG5cbiAgICB2YXIgdEF0dGFjaG1lbnQgPSBleHRlbmQoe30sIHRhcmdldEF0dGFjaG1lbnQpO1xuICAgIHZhciBlQXR0YWNobWVudCA9IGV4dGVuZCh7fSwgdGhpcy5hdHRhY2htZW50KTtcblxuICAgIHRoaXMub3B0aW9ucy5jb25zdHJhaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG4gICAgICB2YXIgdG8gPSBjb25zdHJhaW50LnRvO1xuICAgICAgdmFyIGF0dGFjaG1lbnQgPSBjb25zdHJhaW50LmF0dGFjaG1lbnQ7XG4gICAgICB2YXIgcGluID0gY29uc3RyYWludC5waW47XG5cbiAgICAgIGlmICh0eXBlb2YgYXR0YWNobWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgYXR0YWNobWVudCA9ICcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hhbmdlQXR0YWNoWCA9IHVuZGVmaW5lZCxcbiAgICAgICAgICBjaGFuZ2VBdHRhY2hZID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGF0dGFjaG1lbnQuaW5kZXhPZignICcpID49IDApIHtcbiAgICAgICAgdmFyIF9hdHRhY2htZW50JHNwbGl0ID0gYXR0YWNobWVudC5zcGxpdCgnICcpO1xuXG4gICAgICAgIHZhciBfYXR0YWNobWVudCRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfYXR0YWNobWVudCRzcGxpdCwgMik7XG5cbiAgICAgICAgY2hhbmdlQXR0YWNoWSA9IF9hdHRhY2htZW50JHNwbGl0MlswXTtcbiAgICAgICAgY2hhbmdlQXR0YWNoWCA9IF9hdHRhY2htZW50JHNwbGl0MlsxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYW5nZUF0dGFjaFggPSBjaGFuZ2VBdHRhY2hZID0gYXR0YWNobWVudDtcbiAgICAgIH1cblxuICAgICAgdmFyIGJvdW5kcyA9IGdldEJvdW5kaW5nUmVjdChfdGhpcywgdG8pO1xuXG4gICAgICBpZiAoY2hhbmdlQXR0YWNoWSA9PT0gJ3RhcmdldCcgfHwgY2hhbmdlQXR0YWNoWSA9PT0gJ2JvdGgnKSB7XG4gICAgICAgIGlmICh0b3AgPCBib3VuZHNbMV0gJiYgdEF0dGFjaG1lbnQudG9wID09PSAndG9wJykge1xuICAgICAgICAgIHRvcCArPSB0YXJnZXRIZWlnaHQ7XG4gICAgICAgICAgdEF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9wICsgaGVpZ2h0ID4gYm91bmRzWzNdICYmIHRBdHRhY2htZW50LnRvcCA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICB0b3AgLT0gdGFyZ2V0SGVpZ2h0O1xuICAgICAgICAgIHRBdHRhY2htZW50LnRvcCA9ICd0b3AnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VBdHRhY2hZID09PSAndG9nZXRoZXInKSB7XG4gICAgICAgIGlmICh0QXR0YWNobWVudC50b3AgPT09ICd0b3AnKSB7XG4gICAgICAgICAgaWYgKGVBdHRhY2htZW50LnRvcCA9PT0gJ2JvdHRvbScgJiYgdG9wIDwgYm91bmRzWzFdKSB7XG4gICAgICAgICAgICB0b3AgKz0gdGFyZ2V0SGVpZ2h0O1xuICAgICAgICAgICAgdEF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XG5cbiAgICAgICAgICAgIHRvcCArPSBoZWlnaHQ7XG4gICAgICAgICAgICBlQXR0YWNobWVudC50b3AgPSAndG9wJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGVBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcgJiYgdG9wICsgaGVpZ2h0ID4gYm91bmRzWzNdICYmIHRvcCAtIChoZWlnaHQgLSB0YXJnZXRIZWlnaHQpID49IGJvdW5kc1sxXSkge1xuICAgICAgICAgICAgdG9wIC09IGhlaWdodCAtIHRhcmdldEhlaWdodDtcbiAgICAgICAgICAgIHRBdHRhY2htZW50LnRvcCA9ICdib3R0b20nO1xuXG4gICAgICAgICAgICBlQXR0YWNobWVudC50b3AgPSAnYm90dG9tJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodEF0dGFjaG1lbnQudG9wID09PSAnYm90dG9tJykge1xuICAgICAgICAgIGlmIChlQXR0YWNobWVudC50b3AgPT09ICd0b3AnICYmIHRvcCArIGhlaWdodCA+IGJvdW5kc1szXSkge1xuICAgICAgICAgICAgdG9wIC09IHRhcmdldEhlaWdodDtcbiAgICAgICAgICAgIHRBdHRhY2htZW50LnRvcCA9ICd0b3AnO1xuXG4gICAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XG4gICAgICAgICAgfSBlbHNlIGlmIChlQXR0YWNobWVudC50b3AgPT09ICdib3R0b20nICYmIHRvcCA8IGJvdW5kc1sxXSAmJiB0b3AgKyAoaGVpZ2h0ICogMiAtIHRhcmdldEhlaWdodCkgPD0gYm91bmRzWzNdKSB7XG4gICAgICAgICAgICB0b3AgKz0gaGVpZ2h0IC0gdGFyZ2V0SGVpZ2h0O1xuICAgICAgICAgICAgdEF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XG5cbiAgICAgICAgICAgIGVBdHRhY2htZW50LnRvcCA9ICd0b3AnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0QXR0YWNobWVudC50b3AgPT09ICdtaWRkbGUnKSB7XG4gICAgICAgICAgaWYgKHRvcCArIGhlaWdodCA+IGJvdW5kc1szXSAmJiBlQXR0YWNobWVudC50b3AgPT09ICd0b3AnKSB7XG4gICAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ2JvdHRvbSc7XG4gICAgICAgICAgfSBlbHNlIGlmICh0b3AgPCBib3VuZHNbMV0gJiYgZUF0dGFjaG1lbnQudG9wID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgdG9wICs9IGhlaWdodDtcbiAgICAgICAgICAgIGVBdHRhY2htZW50LnRvcCA9ICd0b3AnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlQXR0YWNoWCA9PT0gJ3RhcmdldCcgfHwgY2hhbmdlQXR0YWNoWCA9PT0gJ2JvdGgnKSB7XG4gICAgICAgIGlmIChsZWZ0IDwgYm91bmRzWzBdICYmIHRBdHRhY2htZW50LmxlZnQgPT09ICdsZWZ0Jykge1xuICAgICAgICAgIGxlZnQgKz0gdGFyZ2V0V2lkdGg7XG4gICAgICAgICAgdEF0dGFjaG1lbnQubGVmdCA9ICdyaWdodCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVmdCArIHdpZHRoID4gYm91bmRzWzJdICYmIHRBdHRhY2htZW50LmxlZnQgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICBsZWZ0IC09IHRhcmdldFdpZHRoO1xuICAgICAgICAgIHRBdHRhY2htZW50LmxlZnQgPSAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZUF0dGFjaFggPT09ICd0b2dldGhlcicpIHtcbiAgICAgICAgaWYgKGxlZnQgPCBib3VuZHNbMF0gJiYgdEF0dGFjaG1lbnQubGVmdCA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgaWYgKGVBdHRhY2htZW50LmxlZnQgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIGxlZnQgKz0gdGFyZ2V0V2lkdGg7XG4gICAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcblxuICAgICAgICAgICAgbGVmdCArPSB3aWR0aDtcbiAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAnbGVmdCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChlQXR0YWNobWVudC5sZWZ0ID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIGxlZnQgKz0gdGFyZ2V0V2lkdGg7XG4gICAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcblxuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAncmlnaHQnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICsgd2lkdGggPiBib3VuZHNbMl0gJiYgdEF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgIGlmIChlQXR0YWNobWVudC5sZWZ0ID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIGxlZnQgLT0gdGFyZ2V0V2lkdGg7XG4gICAgICAgICAgICB0QXR0YWNobWVudC5sZWZ0ID0gJ2xlZnQnO1xuXG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdyaWdodCc7XG4gICAgICAgICAgfSBlbHNlIGlmIChlQXR0YWNobWVudC5sZWZ0ID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICBsZWZ0IC09IHRhcmdldFdpZHRoO1xuICAgICAgICAgICAgdEF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcblxuICAgICAgICAgICAgbGVmdCArPSB3aWR0aDtcbiAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAnbGVmdCc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRBdHRhY2htZW50LmxlZnQgPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgaWYgKGxlZnQgKyB3aWR0aCA+IGJvdW5kc1syXSAmJiBlQXR0YWNobWVudC5sZWZ0ID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ3JpZ2h0JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgPCBib3VuZHNbMF0gJiYgZUF0dGFjaG1lbnQubGVmdCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgbGVmdCArPSB3aWR0aDtcbiAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAnbGVmdCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VBdHRhY2hZID09PSAnZWxlbWVudCcgfHwgY2hhbmdlQXR0YWNoWSA9PT0gJ2JvdGgnKSB7XG4gICAgICAgIGlmICh0b3AgPCBib3VuZHNbMV0gJiYgZUF0dGFjaG1lbnQudG9wID09PSAnYm90dG9tJykge1xuICAgICAgICAgIHRvcCArPSBoZWlnaHQ7XG4gICAgICAgICAgZUF0dGFjaG1lbnQudG9wID0gJ3RvcCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9wICsgaGVpZ2h0ID4gYm91bmRzWzNdICYmIGVBdHRhY2htZW50LnRvcCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICAgIGVBdHRhY2htZW50LnRvcCA9ICdib3R0b20nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VBdHRhY2hYID09PSAnZWxlbWVudCcgfHwgY2hhbmdlQXR0YWNoWCA9PT0gJ2JvdGgnKSB7XG4gICAgICAgIGlmIChsZWZ0IDwgYm91bmRzWzBdKSB7XG4gICAgICAgICAgaWYgKGVBdHRhY2htZW50LmxlZnQgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIGxlZnQgKz0gd2lkdGg7XG4gICAgICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gJ2xlZnQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIGxlZnQgKz0gd2lkdGggLyAyO1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdsZWZ0JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVmdCArIHdpZHRoID4gYm91bmRzWzJdKSB7XG4gICAgICAgICAgaWYgKGVBdHRhY2htZW50LmxlZnQgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICAgIGVBdHRhY2htZW50LmxlZnQgPSAncmlnaHQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZUF0dGFjaG1lbnQubGVmdCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGggLyAyO1xuICAgICAgICAgICAgZUF0dGFjaG1lbnQubGVmdCA9ICdyaWdodCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgcGluID09PSAnc3RyaW5nJykge1xuICAgICAgICBwaW4gPSBwaW4uc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICByZXR1cm4gcC50cmltKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChwaW4gPT09IHRydWUpIHtcbiAgICAgICAgcGluID0gWyd0b3AnLCAnbGVmdCcsICdyaWdodCcsICdib3R0b20nXTtcbiAgICAgIH1cblxuICAgICAgcGluID0gcGluIHx8IFtdO1xuXG4gICAgICB2YXIgcGlubmVkID0gW107XG4gICAgICB2YXIgb29iID0gW107XG5cbiAgICAgIGlmICh0b3AgPCBib3VuZHNbMV0pIHtcbiAgICAgICAgaWYgKHBpbi5pbmRleE9mKCd0b3AnKSA+PSAwKSB7XG4gICAgICAgICAgdG9wID0gYm91bmRzWzFdO1xuICAgICAgICAgIHBpbm5lZC5wdXNoKCd0b3AnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvb2IucHVzaCgndG9wJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRvcCArIGhlaWdodCA+IGJvdW5kc1szXSkge1xuICAgICAgICBpZiAocGluLmluZGV4T2YoJ2JvdHRvbScpID49IDApIHtcbiAgICAgICAgICB0b3AgPSBib3VuZHNbM10gLSBoZWlnaHQ7XG4gICAgICAgICAgcGlubmVkLnB1c2goJ2JvdHRvbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9vYi5wdXNoKCdib3R0b20nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGVmdCA8IGJvdW5kc1swXSkge1xuICAgICAgICBpZiAocGluLmluZGV4T2YoJ2xlZnQnKSA+PSAwKSB7XG4gICAgICAgICAgbGVmdCA9IGJvdW5kc1swXTtcbiAgICAgICAgICBwaW5uZWQucHVzaCgnbGVmdCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9vYi5wdXNoKCdsZWZ0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxlZnQgKyB3aWR0aCA+IGJvdW5kc1syXSkge1xuICAgICAgICBpZiAocGluLmluZGV4T2YoJ3JpZ2h0JykgPj0gMCkge1xuICAgICAgICAgIGxlZnQgPSBib3VuZHNbMl0gLSB3aWR0aDtcbiAgICAgICAgICBwaW5uZWQucHVzaCgncmlnaHQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvb2IucHVzaCgncmlnaHQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGlubmVkLmxlbmd0aCkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBwaW5uZWRDbGFzcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLm9wdGlvbnMucGlubmVkQ2xhc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwaW5uZWRDbGFzcyA9IF90aGlzLm9wdGlvbnMucGlubmVkQ2xhc3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBpbm5lZENsYXNzID0gX3RoaXMuZ2V0Q2xhc3MoJ3Bpbm5lZCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGFkZENsYXNzZXMucHVzaChwaW5uZWRDbGFzcyk7XG4gICAgICAgICAgcGlubmVkLmZvckVhY2goZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgICAgICAgIGFkZENsYXNzZXMucHVzaChwaW5uZWRDbGFzcyArICctJyArIHNpZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAob29iLmxlbmd0aCkge1xuICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBvb2JDbGFzcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLm9wdGlvbnMub3V0T2ZCb3VuZHNDbGFzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG9vYkNsYXNzID0gX3RoaXMub3B0aW9ucy5vdXRPZkJvdW5kc0NsYXNzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvb2JDbGFzcyA9IF90aGlzLmdldENsYXNzKCdvdXQtb2YtYm91bmRzJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWRkQ2xhc3Nlcy5wdXNoKG9vYkNsYXNzKTtcbiAgICAgICAgICBvb2IuZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgICAgICAgYWRkQ2xhc3Nlcy5wdXNoKG9vYkNsYXNzICsgJy0nICsgc2lkZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwaW5uZWQuaW5kZXhPZignbGVmdCcpID49IDAgfHwgcGlubmVkLmluZGV4T2YoJ3JpZ2h0JykgPj0gMCkge1xuICAgICAgICBlQXR0YWNobWVudC5sZWZ0ID0gdEF0dGFjaG1lbnQubGVmdCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHBpbm5lZC5pbmRleE9mKCd0b3AnKSA+PSAwIHx8IHBpbm5lZC5pbmRleE9mKCdib3R0b20nKSA+PSAwKSB7XG4gICAgICAgIGVBdHRhY2htZW50LnRvcCA9IHRBdHRhY2htZW50LnRvcCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodEF0dGFjaG1lbnQudG9wICE9PSB0YXJnZXRBdHRhY2htZW50LnRvcCB8fCB0QXR0YWNobWVudC5sZWZ0ICE9PSB0YXJnZXRBdHRhY2htZW50LmxlZnQgfHwgZUF0dGFjaG1lbnQudG9wICE9PSBfdGhpcy5hdHRhY2htZW50LnRvcCB8fCBlQXR0YWNobWVudC5sZWZ0ICE9PSBfdGhpcy5hdHRhY2htZW50LmxlZnQpIHtcbiAgICAgICAgX3RoaXMudXBkYXRlQXR0YWNoQ2xhc3NlcyhlQXR0YWNobWVudCwgdEF0dGFjaG1lbnQpO1xuICAgICAgICBfdGhpcy50cmlnZ2VyKCd1cGRhdGUnLCB7XG4gICAgICAgICAgYXR0YWNobWVudDogZUF0dGFjaG1lbnQsXG4gICAgICAgICAgdGFyZ2V0QXR0YWNobWVudDogdEF0dGFjaG1lbnRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBkZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIShfdGhpcy5vcHRpb25zLmFkZFRhcmdldENsYXNzZXMgPT09IGZhbHNlKSkge1xuICAgICAgICB1cGRhdGVDbGFzc2VzKF90aGlzLnRhcmdldCwgYWRkQ2xhc3NlcywgYWxsQ2xhc3Nlcyk7XG4gICAgICB9XG4gICAgICB1cGRhdGVDbGFzc2VzKF90aGlzLmVsZW1lbnQsIGFkZENsYXNzZXMsIGFsbENsYXNzZXMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcbiAgfVxufSk7XG4vKiBnbG9iYWxzIFRldGhlckJhc2UgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX1RldGhlckJhc2UkVXRpbHMgPSBUZXRoZXJCYXNlLlV0aWxzO1xudmFyIGdldEJvdW5kcyA9IF9UZXRoZXJCYXNlJFV0aWxzLmdldEJvdW5kcztcbnZhciB1cGRhdGVDbGFzc2VzID0gX1RldGhlckJhc2UkVXRpbHMudXBkYXRlQ2xhc3NlcztcbnZhciBkZWZlciA9IF9UZXRoZXJCYXNlJFV0aWxzLmRlZmVyO1xuXG5UZXRoZXJCYXNlLm1vZHVsZXMucHVzaCh7XG4gIHBvc2l0aW9uOiBmdW5jdGlvbiBwb3NpdGlvbihfcmVmKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciB0b3AgPSBfcmVmLnRvcDtcbiAgICB2YXIgbGVmdCA9IF9yZWYubGVmdDtcblxuICAgIHZhciBfY2FjaGUgPSB0aGlzLmNhY2hlKCdlbGVtZW50LWJvdW5kcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXRCb3VuZHMoX3RoaXMuZWxlbWVudCk7XG4gICAgfSk7XG5cbiAgICB2YXIgaGVpZ2h0ID0gX2NhY2hlLmhlaWdodDtcbiAgICB2YXIgd2lkdGggPSBfY2FjaGUud2lkdGg7XG5cbiAgICB2YXIgdGFyZ2V0UG9zID0gdGhpcy5nZXRUYXJnZXRCb3VuZHMoKTtcblxuICAgIHZhciBib3R0b20gPSB0b3AgKyBoZWlnaHQ7XG4gICAgdmFyIHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuXG4gICAgdmFyIGFidXR0ZWQgPSBbXTtcbiAgICBpZiAodG9wIDw9IHRhcmdldFBvcy5ib3R0b20gJiYgYm90dG9tID49IHRhcmdldFBvcy50b3ApIHtcbiAgICAgIFsnbGVmdCcsICdyaWdodCddLmZvckVhY2goZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgICAgdmFyIHRhcmdldFBvc1NpZGUgPSB0YXJnZXRQb3Nbc2lkZV07XG4gICAgICAgIGlmICh0YXJnZXRQb3NTaWRlID09PSBsZWZ0IHx8IHRhcmdldFBvc1NpZGUgPT09IHJpZ2h0KSB7XG4gICAgICAgICAgYWJ1dHRlZC5wdXNoKHNpZGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobGVmdCA8PSB0YXJnZXRQb3MucmlnaHQgJiYgcmlnaHQgPj0gdGFyZ2V0UG9zLmxlZnQpIHtcbiAgICAgIFsndG9wJywgJ2JvdHRvbSddLmZvckVhY2goZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgICAgdmFyIHRhcmdldFBvc1NpZGUgPSB0YXJnZXRQb3Nbc2lkZV07XG4gICAgICAgIGlmICh0YXJnZXRQb3NTaWRlID09PSB0b3AgfHwgdGFyZ2V0UG9zU2lkZSA9PT0gYm90dG9tKSB7XG4gICAgICAgICAgYWJ1dHRlZC5wdXNoKHNpZGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgYWxsQ2xhc3NlcyA9IFtdO1xuICAgIHZhciBhZGRDbGFzc2VzID0gW107XG5cbiAgICB2YXIgc2lkZXMgPSBbJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbSddO1xuICAgIGFsbENsYXNzZXMucHVzaCh0aGlzLmdldENsYXNzKCdhYnV0dGVkJykpO1xuICAgIHNpZGVzLmZvckVhY2goZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgIGFsbENsYXNzZXMucHVzaChfdGhpcy5nZXRDbGFzcygnYWJ1dHRlZCcpICsgJy0nICsgc2lkZSk7XG4gICAgfSk7XG5cbiAgICBpZiAoYWJ1dHRlZC5sZW5ndGgpIHtcbiAgICAgIGFkZENsYXNzZXMucHVzaCh0aGlzLmdldENsYXNzKCdhYnV0dGVkJykpO1xuICAgIH1cblxuICAgIGFidXR0ZWQuZm9yRWFjaChmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgYWRkQ2xhc3Nlcy5wdXNoKF90aGlzLmdldENsYXNzKCdhYnV0dGVkJykgKyAnLScgKyBzaWRlKTtcbiAgICB9KTtcblxuICAgIGRlZmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghKF90aGlzLm9wdGlvbnMuYWRkVGFyZ2V0Q2xhc3NlcyA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHVwZGF0ZUNsYXNzZXMoX3RoaXMudGFyZ2V0LCBhZGRDbGFzc2VzLCBhbGxDbGFzc2VzKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZUNsYXNzZXMoX3RoaXMuZWxlbWVudCwgYWRkQ2xhc3NlcywgYWxsQ2xhc3Nlcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSk7XG4vKiBnbG9iYWxzIFRldGhlckJhc2UgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVsncmV0dXJuJ10pIF9pWydyZXR1cm4nXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7IH0gfTsgfSkoKTtcblxuVGV0aGVyQmFzZS5tb2R1bGVzLnB1c2goe1xuICBwb3NpdGlvbjogZnVuY3Rpb24gcG9zaXRpb24oX3JlZikge1xuICAgIHZhciB0b3AgPSBfcmVmLnRvcDtcbiAgICB2YXIgbGVmdCA9IF9yZWYubGVmdDtcblxuICAgIGlmICghdGhpcy5vcHRpb25zLnNoaWZ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNoaWZ0ID0gdGhpcy5vcHRpb25zLnNoaWZ0O1xuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnNoaWZ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzaGlmdCA9IHRoaXMub3B0aW9ucy5zaGlmdC5jYWxsKHRoaXMsIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfSk7XG4gICAgfVxuXG4gICAgdmFyIHNoaWZ0VG9wID0gdW5kZWZpbmVkLFxuICAgICAgICBzaGlmdExlZnQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiBzaGlmdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNoaWZ0ID0gc2hpZnQuc3BsaXQoJyAnKTtcbiAgICAgIHNoaWZ0WzFdID0gc2hpZnRbMV0gfHwgc2hpZnRbMF07XG5cbiAgICAgIHZhciBfc2hpZnQgPSBzaGlmdDtcblxuICAgICAgdmFyIF9zaGlmdDIgPSBfc2xpY2VkVG9BcnJheShfc2hpZnQsIDIpO1xuXG4gICAgICBzaGlmdFRvcCA9IF9zaGlmdDJbMF07XG4gICAgICBzaGlmdExlZnQgPSBfc2hpZnQyWzFdO1xuXG4gICAgICBzaGlmdFRvcCA9IHBhcnNlRmxvYXQoc2hpZnRUb3AsIDEwKTtcbiAgICAgIHNoaWZ0TGVmdCA9IHBhcnNlRmxvYXQoc2hpZnRMZWZ0LCAxMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoaWZ0VG9wID0gc2hpZnQudG9wO1xuICAgICAgc2hpZnRMZWZ0ID0gc2hpZnQubGVmdDtcbiAgICB9XG5cbiAgICB0b3AgKz0gc2hpZnRUb3A7XG4gICAgbGVmdCArPSBzaGlmdExlZnQ7XG5cbiAgICByZXR1cm4geyB0b3A6IHRvcCwgbGVmdDogbGVmdCB9O1xuICB9XG59KTtcbnJldHVybiBUZXRoZXI7XG5cbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3RldGhlci9kaXN0L2pzL3RldGhlci5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc2Fzcy9tYWluLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG5pbXBvcnQgeyBDYWxpZm9ybmlhQXBwIH0gZnJvbSBcIi4vTW9kZWxzL0NhbGlmb3JuaWFBcHBcIjtcclxuQ2FsaWZvcm5pYUFwcC5DYWxpZm9ybmlhQXBwSW5zdGFuY2UgPSBuZXcgQ2FsaWZvcm5pYUFwcCgpO1xyXG5cclxuLy8gVE9ETyBwb2x5ZmlsbCBmb3IgQXJyYXkuZmluZCAoaWV4cGxvcmUxMSlcclxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRcclxuaWYgKCFBcnJheS5wcm90b3R5cGUuZmluZCkge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSwgJ2ZpbmQnLCB7XHJcbiAgICAgIHZhbHVlOiBmdW5jdGlvbihwcmVkaWNhdGU6IGFueSkge1xyXG4gICAgICAgLy8gMS4gTGV0IE8gYmUgPyBUb09iamVjdCh0aGlzIHZhbHVlKS5cclxuICAgICAgICBpZiAodGhpcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInRoaXNcIiBpcyBudWxsIG9yIG5vdCBkZWZpbmVkJyk7XHJcbiAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgIHZhciBvID0gT2JqZWN0KHRoaXMpO1xyXG4gIFxyXG4gICAgICAgIC8vIDIuIExldCBsZW4gYmUgPyBUb0xlbmd0aCg/IEdldChPLCBcImxlbmd0aFwiKSkuXHJcbiAgICAgICAgdmFyIGxlbiA9IG8ubGVuZ3RoID4+PiAwO1xyXG4gIFxyXG4gICAgICAgIC8vIDMuIElmIElzQ2FsbGFibGUocHJlZGljYXRlKSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxyXG4gICAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcmVkaWNhdGUgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XHJcbiAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgIC8vIDQuIElmIHRoaXNBcmcgd2FzIHN1cHBsaWVkLCBsZXQgVCBiZSB0aGlzQXJnOyBlbHNlIGxldCBUIGJlIHVuZGVmaW5lZC5cclxuICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXTtcclxuICBcclxuICAgICAgICAvLyA1LiBMZXQgayBiZSAwLlxyXG4gICAgICAgIHZhciBrID0gMDtcclxuICBcclxuICAgICAgICAvLyA2LiBSZXBlYXQsIHdoaWxlIGsgPCBsZW5cclxuICAgICAgICB3aGlsZSAoayA8IGxlbikge1xyXG4gICAgICAgICAgLy8gYS4gTGV0IFBrIGJlICEgVG9TdHJpbmcoaykuXHJcbiAgICAgICAgICAvLyBiLiBMZXQga1ZhbHVlIGJlID8gR2V0KE8sIFBrKS5cclxuICAgICAgICAgIC8vIGMuIExldCB0ZXN0UmVzdWx0IGJlIFRvQm9vbGVhbig/IENhbGwocHJlZGljYXRlLCBULCDCqyBrVmFsdWUsIGssIE8gwrspKS5cclxuICAgICAgICAgIC8vIGQuIElmIHRlc3RSZXN1bHQgaXMgdHJ1ZSwgcmV0dXJuIGtWYWx1ZS5cclxuICAgICAgICAgIHZhciBrVmFsdWUgPSBvW2tdO1xyXG4gICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIGtWYWx1ZSwgaywgbykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGtWYWx1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIGUuIEluY3JlYXNlIGsgYnkgMS5cclxuICAgICAgICAgIGsrKztcclxuICAgICAgICB9XHJcbiAgXHJcbiAgICAgICAgLy8gNy4gUmV0dXJuIHVuZGVmaW5lZC5cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4vLyBUT0RPIHBvbHlmaWxsIGZvciBBcnJheS5maW5kSW5kZXggKGlleHBsb3JlMTEpXHJcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhcclxuaWYgKCFBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSB7XHJcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSwgJ2ZpbmRJbmRleCcsIHtcclxuICAgIHZhbHVlOiBmdW5jdGlvbihwcmVkaWNhdGU6IGFueSkge1xyXG4gICAgIC8vIDEuIExldCBPIGJlID8gVG9PYmplY3QodGhpcyB2YWx1ZSkuXHJcbiAgICAgIGlmICh0aGlzID09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInRoaXNcIiBpcyBudWxsIG9yIG5vdCBkZWZpbmVkJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBvID0gT2JqZWN0KHRoaXMpO1xyXG5cclxuICAgICAgLy8gMi4gTGV0IGxlbiBiZSA/IFRvTGVuZ3RoKD8gR2V0KE8sIFwibGVuZ3RoXCIpKS5cclxuICAgICAgdmFyIGxlbiA9IG8ubGVuZ3RoID4+PiAwO1xyXG5cclxuICAgICAgLy8gMy4gSWYgSXNDYWxsYWJsZShwcmVkaWNhdGUpIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXHJcbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJlZGljYXRlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyA0LiBJZiB0aGlzQXJnIHdhcyBzdXBwbGllZCwgbGV0IFQgYmUgdGhpc0FyZzsgZWxzZSBsZXQgVCBiZSB1bmRlZmluZWQuXHJcbiAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xyXG5cclxuICAgICAgLy8gNS4gTGV0IGsgYmUgMC5cclxuICAgICAgdmFyIGsgPSAwO1xyXG5cclxuICAgICAgLy8gNi4gUmVwZWF0LCB3aGlsZSBrIDwgbGVuXHJcbiAgICAgIHdoaWxlIChrIDwgbGVuKSB7XHJcbiAgICAgICAgLy8gYS4gTGV0IFBrIGJlICEgVG9TdHJpbmcoaykuXHJcbiAgICAgICAgLy8gYi4gTGV0IGtWYWx1ZSBiZSA/IEdldChPLCBQaykuXHJcbiAgICAgICAgLy8gYy4gTGV0IHRlc3RSZXN1bHQgYmUgVG9Cb29sZWFuKD8gQ2FsbChwcmVkaWNhdGUsIFQsIMKrIGtWYWx1ZSwgaywgTyDCuykpLlxyXG4gICAgICAgIC8vIGQuIElmIHRlc3RSZXN1bHQgaXMgdHJ1ZSwgcmV0dXJuIGsuXHJcbiAgICAgICAgdmFyIGtWYWx1ZSA9IG9ba107XHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIGtWYWx1ZSwgaywgbykpIHtcclxuICAgICAgICAgIHJldHVybiBrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBlLiBJbmNyZWFzZSBrIGJ5IDEuXHJcbiAgICAgICAgaysrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyA3LiBSZXR1cm4gLTEuXHJcbiAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICB9KTtcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NpdGUudHN4IiwiXHJcblxyXG4vLy88cmVmZXJlbmNlIHR5cGVzPVwianF1ZXJ5XCIgLz5cbmltcG9ydCAqIGFzIGhlbHBlcnMgZnJvbSBcIi4vdHNnZW5IZWxwZXJzXCI7IFxyXG5pbXBvcnQgeyBDYWxpZm9ybmlhQXBwIH0gZnJvbSBcIi4vLi4vTW9kZWxzL0NhbGlmb3JuaWFBcHBcIjtcclxubGV0IGN1cnJlbnRBcHA6IENhbGlmb3JuaWFBcHA7XHJcbmV4cG9ydCBjbGFzcyBDYWxpZm9ybmlhQ29udHJvbGxlciB7XHJcbiAgICAgICAgY29uc3RydWN0b3IoY2FsaWZvcm5pYUFwcEFyZzogQ2FsaWZvcm5pYUFwcCkge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwID0gY2FsaWZvcm5pYUFwcEFyZztcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIGJlZm9yZVNlbmRBamF4ID0gKGpxWEhSOiBKUXVlcnlYSFIsIHNldHRpbmdzOiBhbnkpOiBmYWxzZSB8IHZvaWQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudEFwcC5pc0FqYXhSZXF1ZXN0UnVubmluZyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJpZ25vcmVkIHJlcXVlc3QgKGFqYXggY2FsbCBzdGlsbCBpbiBwcm9ncmVzcylcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudEFwcC5pc0FqYXhSZXF1ZXN0UnVubmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGpxWEhSLmRvbmUoeGhyID0+IHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuaXNBamF4UmVxdWVzdFJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSkuZmFpbCh4aHIgPT4ge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEFwcC5pc0FqYXhSZXF1ZXN0UnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEFwcC5wcm9qZWN0b3Iuc2NoZWR1bGVSZW5kZXIoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBwdWJsaWMgTG9nb3V0QWN0aW9uID0gKCkgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5BY3Rpb24oYC9jYWxpZm9ybmlhL0xvZ291dGAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIEluZGV4QWN0aW9uID0gKGlkOiBzdHJpbmcsIHRva2VuOiBzdHJpbmcpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuQWN0aW9uKGAvY2FsaWZvcm5pYS9JbmRleCR7ZW5jb2RlVVJJQ29tcG9uZW50KGlkKX0/dG9rZW49JHtlbmNvZGVVUklDb21wb25lbnQodG9rZW4pfWAsIFwiZ2V0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgRGVsZXRlTGF5b3V0U3R5bGVJbnRlcmFjdGlvbkpzb24gPSAobGF5b3V0U3R5bGVJbnRlcmFjdGlvbklkOiBudW1iZXIgfCB1bmRlZmluZWQpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvRGVsZXRlTGF5b3V0U3R5bGVJbnRlcmFjdGlvbj9sYXlvdXRTdHlsZUludGVyYWN0aW9uSWQ9JHtsYXlvdXRTdHlsZUludGVyYWN0aW9uSWR9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgRGVsZXRlU3R5bGVWYWx1ZUludGVyYWN0aW9uSnNvbiA9IChsYXlvdXRTdHlsZUludGVyYWN0aW9uSWQ6IG51bWJlciB8IHVuZGVmaW5lZCwgc3R5bGVWYWx1ZUlkOiBudW1iZXIgfCB1bmRlZmluZWQpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvRGVsZXRlU3R5bGVWYWx1ZUludGVyYWN0aW9uP2xheW91dFN0eWxlSW50ZXJhY3Rpb25JZD0ke2xheW91dFN0eWxlSW50ZXJhY3Rpb25JZH0mc3R5bGVWYWx1ZUlkPSR7c3R5bGVWYWx1ZUlkfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIENyZWF0ZUxheW91dFN0eWxlSW50ZXJhY3Rpb25Gb3JMYXlvdXRBdG9tSnNvbiA9IChsYXlvdXRBdG9tSWQ6IG51bWJlciB8IHVuZGVmaW5lZCkgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5Kc29uKGAvY2FsaWZvcm5pYS9DcmVhdGVMYXlvdXRTdHlsZUludGVyYWN0aW9uRm9yTGF5b3V0QXRvbT9sYXlvdXRBdG9tSWQ9JHtsYXlvdXRBdG9tSWR9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgcHViQWN0aW9uID0gKHZpZXc6IHN0cmluZywgaWQ6IHN0cmluZykgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5BY3Rpb24oYC9jYWxpZm9ybmlhL3B1YiR7ZW5jb2RlVVJJQ29tcG9uZW50KGlkKX0/dmlldz0ke2VuY29kZVVSSUNvbXBvbmVudCh2aWV3KX1gLCBcImdldFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIFN0YXRpY0Nzc0FjdGlvbiA9IChpZDogc3RyaW5nKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkFjdGlvbihgL2NhbGlmb3JuaWEvU3RhdGljQ3NzJHtlbmNvZGVVUklDb21wb25lbnQoaWQpfWAsIFwiZ2V0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgU3RhdGljSnNBY3Rpb24gPSAoaWQ6IHN0cmluZykgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5BY3Rpb24oYC9jYWxpZm9ybmlhL1N0YXRpY0pzJHtlbmNvZGVVUklDb21wb25lbnQoaWQpfWAsIFwiZ2V0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgUHVibGlzaEFjdGlvbiA9IChjYWxpZm9ybmlhUHJvamVjdElkOiBudW1iZXIgfCB1bmRlZmluZWQsIHZpZXc6IHN0cmluZykgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5BY3Rpb24oYC9jYWxpZm9ybmlhL1B1Ymxpc2g/Y2FsaWZvcm5pYVByb2plY3RJZD0ke2NhbGlmb3JuaWFQcm9qZWN0SWR9JnZpZXc9JHtlbmNvZGVVUklDb21wb25lbnQodmlldyl9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgSW5pdGlhbENsaWVudERhdGFKc29uID0gKGpzVGltZVN0cmluZzogc3RyaW5nKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL0luaXRpYWxDbGllbnREYXRhP2pzVGltZVN0cmluZz0ke2VuY29kZVVSSUNvbXBvbmVudChqc1RpbWVTdHJpbmcpfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIFNldFNwZWNpYWxMYXlvdXRCb3hUeXBlSnNvbiA9IChsYXlvdXRCb3hJZDogbnVtYmVyIHwgdW5kZWZpbmVkLCBzcGVjaWFsTGF5b3V0Qm94VHlwZTogbnVtYmVyIHwgdW5kZWZpbmVkKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL1NldFNwZWNpYWxMYXlvdXRCb3hUeXBlP2xheW91dEJveElkPSR7bGF5b3V0Qm94SWR9JnNwZWNpYWxMYXlvdXRCb3hUeXBlPSR7c3BlY2lhbExheW91dEJveFR5cGV9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgRGVsZXRlU3R5bGVRdWFudHVtSnNvbiA9IChzdHlsZVF1YW50dW1JZDogbnVtYmVyIHwgdW5kZWZpbmVkKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL0RlbGV0ZVN0eWxlUXVhbnR1bT9zdHlsZVF1YW50dW1JZD0ke3N0eWxlUXVhbnR1bUlkfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIERlbGV0ZUxheW91dEpzb24gPSAobGF5b3V0QmFzZUlkOiBudW1iZXIgfCB1bmRlZmluZWQsIGlzT25seUJlbG93OiBib29sZWFuKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL0RlbGV0ZUxheW91dD9sYXlvdXRCYXNlSWQ9JHtsYXlvdXRCYXNlSWR9JmlzT25seUJlbG93PSR7aXNPbmx5QmVsb3d9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgU2V0U3R5bGVNb2xlY3VsZUFzUmVmZXJlbmNlU3R5bGVKc29uID0gKHN0eWxlTW9sZWN1bGVJZDogbnVtYmVyIHwgdW5kZWZpbmVkKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL1NldFN0eWxlTW9sZWN1bGVBc1JlZmVyZW5jZVN0eWxlP3N0eWxlTW9sZWN1bGVJZD0ke3N0eWxlTW9sZWN1bGVJZH1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBTZXRTdHlsZU1vbGVjdWxlUmVmZXJlbmNlSnNvbiA9IChzdHlsZU1vbGVjdWxlSWQ6IG51bWJlciB8IHVuZGVmaW5lZCwgcmVmZXJlbmNlU3R5bGVNb2xlY3VsZUlkOiBudW1iZXIgfCB1bmRlZmluZWQpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvU2V0U3R5bGVNb2xlY3VsZVJlZmVyZW5jZT9zdHlsZU1vbGVjdWxlSWQ9JHtzdHlsZU1vbGVjdWxlSWR9JnJlZmVyZW5jZVN0eWxlTW9sZWN1bGVJZD0ke3JlZmVyZW5jZVN0eWxlTW9sZWN1bGVJZH1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBTeW5jU3R5bGVNb2xlY3VsZVRvUmVmZXJlbmNlU3R5bGVKc29uID0gKHN0eWxlTW9sZWN1bGVJZDogbnVtYmVyIHwgdW5kZWZpbmVkKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL1N5bmNTdHlsZU1vbGVjdWxlVG9SZWZlcmVuY2VTdHlsZT9zdHlsZU1vbGVjdWxlSWQ9JHtzdHlsZU1vbGVjdWxlSWR9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgU3luY1N0eWxlTW9sZWN1bGVGcm9tUmVmZXJlbmNlU3R5bGVKc29uID0gKHN0eWxlTW9sZWN1bGVJZDogbnVtYmVyIHwgdW5kZWZpbmVkKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL1N5bmNTdHlsZU1vbGVjdWxlRnJvbVJlZmVyZW5jZVN0eWxlP3N0eWxlTW9sZWN1bGVJZD0ke3N0eWxlTW9sZWN1bGVJZH1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBTeW5jTGF5b3V0U3R5bGVzSW1pdGF0aW5nUmVmZXJlbmNlTGF5b3V0SnNvbiA9ICh0YXJnZXRMYXlvdXRNb2xlY3VsZUlkOiBudW1iZXIgfCB1bmRlZmluZWQsIHJlZmVyZW5jZUxheW91dE1vbGVjdWxlSWQ6IG51bWJlciB8IHVuZGVmaW5lZCkgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5Kc29uKGAvY2FsaWZvcm5pYS9TeW5jTGF5b3V0U3R5bGVzSW1pdGF0aW5nUmVmZXJlbmNlTGF5b3V0P3RhcmdldExheW91dE1vbGVjdWxlSWQ9JHt0YXJnZXRMYXlvdXRNb2xlY3VsZUlkfSZyZWZlcmVuY2VMYXlvdXRNb2xlY3VsZUlkPSR7cmVmZXJlbmNlTGF5b3V0TW9sZWN1bGVJZH1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBTZXRMYXlvdXRCb3hDb3VudEZvclJvd09yQm94SnNvbiA9IChsYXlvdXRSb3dJZDogbnVtYmVyIHwgdW5kZWZpbmVkLCBib3hTdHlsZU1vbGVjdWxlSWQ6IG51bWJlciB8IHVuZGVmaW5lZCwgdGFyZ2V0Qm94Q291bnQ6IG51bWJlciB8IHVuZGVmaW5lZCwgaXNGaXRXaWR0aDogYm9vbGVhbikgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5Kc29uKGAvY2FsaWZvcm5pYS9TZXRMYXlvdXRCb3hDb3VudEZvclJvd09yQm94P2xheW91dFJvd0lkPSR7bGF5b3V0Um93SWR9JmJveFN0eWxlTW9sZWN1bGVJZD0ke2JveFN0eWxlTW9sZWN1bGVJZH0mdGFyZ2V0Qm94Q291bnQ9JHt0YXJnZXRCb3hDb3VudH0maXNGaXRXaWR0aD0ke2lzRml0V2lkdGh9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgQ3JlYXRlU3R5bGVWYWx1ZUZvckF0b21Kc29uID0gKHN0eWxlQXRvbUlkOiBudW1iZXIgfCB1bmRlZmluZWQsIGNzc1Byb3BlcnR5OiBzdHJpbmcpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvQ3JlYXRlU3R5bGVWYWx1ZUZvckF0b20/c3R5bGVBdG9tSWQ9JHtzdHlsZUF0b21JZH0mY3NzUHJvcGVydHk9JHtlbmNvZGVVUklDb21wb25lbnQoY3NzUHJvcGVydHkpfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIENyZWF0ZUNhbGlmb3JuaWFWaWV3SnNvbiA9IChjYWxpZm9ybmlhUHJvamVjdElkOiBudW1iZXIgfCB1bmRlZmluZWQsIGNhbGlmb3JuaWFWaWV3TmFtZTogc3RyaW5nKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL0NyZWF0ZUNhbGlmb3JuaWFWaWV3P2NhbGlmb3JuaWFQcm9qZWN0SWQ9JHtjYWxpZm9ybmlhUHJvamVjdElkfSZjYWxpZm9ybmlhVmlld05hbWU9JHtlbmNvZGVVUklDb21wb25lbnQoY2FsaWZvcm5pYVZpZXdOYW1lKX1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBDcmVhdGVDYWxpZm9ybmlhVmlld0Zyb21SZWZlcmVuY2VWaWV3SnNvbiA9IChjYWxpZm9ybmlhUHJvamVjdElkOiBudW1iZXIgfCB1bmRlZmluZWQsIGNhbGlmb3JuaWFWaWV3TmFtZTogc3RyaW5nLCByZWZlcmVuY2VDYWxpZm9ybmlhVmlld0lkOiBudW1iZXIgfCB1bmRlZmluZWQpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvQ3JlYXRlQ2FsaWZvcm5pYVZpZXdGcm9tUmVmZXJlbmNlVmlldz9jYWxpZm9ybmlhUHJvamVjdElkPSR7Y2FsaWZvcm5pYVByb2plY3RJZH0mY2FsaWZvcm5pYVZpZXdOYW1lPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGNhbGlmb3JuaWFWaWV3TmFtZSl9JnJlZmVyZW5jZUNhbGlmb3JuaWFWaWV3SWQ9JHtyZWZlcmVuY2VDYWxpZm9ybmlhVmlld0lkfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIERlbGV0ZUNhbGlmb3JuaWFWaWV3SnNvbiA9IChjYWxpZm9ybmlhVmlld0lkOiBudW1iZXIgfCB1bmRlZmluZWQpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvRGVsZXRlQ2FsaWZvcm5pYVZpZXc/Y2FsaWZvcm5pYVZpZXdJZD0ke2NhbGlmb3JuaWFWaWV3SWR9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgQ3JlYXRlU3R5bGVWYWx1ZUludGVyYWN0aW9uSnNvbiA9IChsYXlvdXRTdHlsZUludGVyYWN0aW9uSWQ6IG51bWJlciB8IHVuZGVmaW5lZCwgc3R5bGVWYWx1ZUlkOiBudW1iZXIgfCB1bmRlZmluZWQsIGNzc1ZhbHVlOiBzdHJpbmcpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvQ3JlYXRlU3R5bGVWYWx1ZUludGVyYWN0aW9uP2xheW91dFN0eWxlSW50ZXJhY3Rpb25JZD0ke2xheW91dFN0eWxlSW50ZXJhY3Rpb25JZH0mc3R5bGVWYWx1ZUlkPSR7c3R5bGVWYWx1ZUlkfSZjc3NWYWx1ZT0ke2VuY29kZVVSSUNvbXBvbmVudChjc3NWYWx1ZSl9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgQ3JlYXRlU3R5bGVBdG9tRm9yTW9sZWN1bGVKc29uID0gKHN0eWxlTW9sZWN1bGVJZDogbnVtYmVyIHwgdW5kZWZpbmVkLCBzdHlsZUF0b21UeXBlOiBudW1iZXIgfCB1bmRlZmluZWQsIHJlc3BvbnNpdmVEZXZpY2VJZDogbnVtYmVyIHwgdW5kZWZpbmVkLCBzdGF0ZU1vZGlmaWVyOiBzdHJpbmcpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvQ3JlYXRlU3R5bGVBdG9tRm9yTW9sZWN1bGU/c3R5bGVNb2xlY3VsZUlkPSR7c3R5bGVNb2xlY3VsZUlkfSZzdHlsZUF0b21UeXBlPSR7c3R5bGVBdG9tVHlwZX0mcmVzcG9uc2l2ZURldmljZUlkPSR7cmVzcG9uc2l2ZURldmljZUlkfSZzdGF0ZU1vZGlmaWVyPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHN0YXRlTW9kaWZpZXIpfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIERlbGV0ZVN0eWxlQXRvbUpzb24gPSAoc3R5bGVBdG9tSWQ6IG51bWJlciB8IHVuZGVmaW5lZCkgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5Kc29uKGAvY2FsaWZvcm5pYS9EZWxldGVTdHlsZUF0b20/c3R5bGVBdG9tSWQ9JHtzdHlsZUF0b21JZH1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBBcHBseVN0eWxlUXVhbnR1bVRvQXRvbUpzb24gPSAoc3R5bGVBdG9tSWQ6IG51bWJlciB8IHVuZGVmaW5lZCwgc3R5bGVRdWFudHVtSWQ6IG51bWJlciB8IHVuZGVmaW5lZCkgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5Kc29uKGAvY2FsaWZvcm5pYS9BcHBseVN0eWxlUXVhbnR1bVRvQXRvbT9zdHlsZUF0b21JZD0ke3N0eWxlQXRvbUlkfSZzdHlsZVF1YW50dW1JZD0ke3N0eWxlUXVhbnR1bUlkfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIENyZWF0ZVN0eWxlUXVhbnR1bUpzb24gPSAoY2FsaWZvcm5pYVByb2plY3RJZDogbnVtYmVyIHwgdW5kZWZpbmVkLCBxdWFudHVtTmFtZTogc3RyaW5nLCBjc3NQcm9wZXJ0eTogc3RyaW5nLCBjc3NWYWx1ZTogc3RyaW5nKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL0NyZWF0ZVN0eWxlUXVhbnR1bT9jYWxpZm9ybmlhUHJvamVjdElkPSR7Y2FsaWZvcm5pYVByb2plY3RJZH0mcXVhbnR1bU5hbWU9JHtlbmNvZGVVUklDb21wb25lbnQocXVhbnR1bU5hbWUpfSZjc3NQcm9wZXJ0eT0ke2VuY29kZVVSSUNvbXBvbmVudChjc3NQcm9wZXJ0eSl9JmNzc1ZhbHVlPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGNzc1ZhbHVlKX1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBVcGRhdGVUZXh0Q29udGVudEF0b21Kc29uID0gKGNvbnRlbnRBdG9tSWQ6IG51bWJlciB8IHVuZGVmaW5lZCwgdXBkYXRlZFRleHRDb250ZW50OiBzdHJpbmcpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvVXBkYXRlVGV4dENvbnRlbnRBdG9tP2NvbnRlbnRBdG9tSWQ9JHtjb250ZW50QXRvbUlkfSZ1cGRhdGVkVGV4dENvbnRlbnQ9JHtlbmNvZGVVUklDb21wb25lbnQodXBkYXRlZFRleHRDb250ZW50KX1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBVcGRhdGVTdHlsZVF1YW50dW1Kc29uID0gKHN0eWxlUXVhbnR1bUlkOiBudW1iZXIgfCB1bmRlZmluZWQsIGNzc1ZhbHVlOiBzdHJpbmcpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvVXBkYXRlU3R5bGVRdWFudHVtP3N0eWxlUXVhbnR1bUlkPSR7c3R5bGVRdWFudHVtSWR9JmNzc1ZhbHVlPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGNzc1ZhbHVlKX1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBVcGRhdGVTdHlsZVZhbHVlSnNvbiA9IChzdHlsZVZhbHVlSWQ6IG51bWJlciB8IHVuZGVmaW5lZCwgY3NzVmFsdWU6IHN0cmluZykgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5Kc29uKGAvY2FsaWZvcm5pYS9VcGRhdGVTdHlsZVZhbHVlP3N0eWxlVmFsdWVJZD0ke3N0eWxlVmFsdWVJZH0mY3NzVmFsdWU9JHtlbmNvZGVVUklDb21wb25lbnQoY3NzVmFsdWUpfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIFVwZGF0ZVVzZXJEZWZpbmVkQ3NzRm9yUHJvamVjdEpzb24gPSAoY2FsaWZvcm5pYVByb2plY3RJZDogbnVtYmVyIHwgdW5kZWZpbmVkLCBjc3NWYWx1ZTogc3RyaW5nKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL1VwZGF0ZVVzZXJEZWZpbmVkQ3NzRm9yUHJvamVjdD9jYWxpZm9ybmlhUHJvamVjdElkPSR7Y2FsaWZvcm5pYVByb2plY3RJZH0mY3NzVmFsdWU9JHtlbmNvZGVVUklDb21wb25lbnQoY3NzVmFsdWUpfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIFVwZGF0ZVVzZXJEZWZpbmVkQ3NzRm9yVmlld0pzb24gPSAoY2FsaWZvcm5pYVZpZXdJZDogbnVtYmVyIHwgdW5kZWZpbmVkLCBjc3NWYWx1ZTogc3RyaW5nKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL1VwZGF0ZVVzZXJEZWZpbmVkQ3NzRm9yVmlldz9jYWxpZm9ybmlhVmlld0lkPSR7Y2FsaWZvcm5pYVZpZXdJZH0mY3NzVmFsdWU9JHtlbmNvZGVVUklDb21wb25lbnQoY3NzVmFsdWUpfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIERlbGV0ZVN0eWxlVmFsdWVKc29uID0gKHN0eWxlVmFsdWVJZDogbnVtYmVyIHwgdW5kZWZpbmVkKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL0RlbGV0ZVN0eWxlVmFsdWU/c3R5bGVWYWx1ZUlkPSR7c3R5bGVWYWx1ZUlkfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIER1cGxpY2F0ZVN0eWxlUXVhbnR1bUpzb24gPSAoc3R5bGVRdWFudHVtSWQ6IG51bWJlciB8IHVuZGVmaW5lZCkgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5Kc29uKGAvY2FsaWZvcm5pYS9EdXBsaWNhdGVTdHlsZVF1YW50dW0/c3R5bGVRdWFudHVtSWQ9JHtzdHlsZVF1YW50dW1JZH1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBDcmVhdGVMYXlvdXRBdG9tRm9yQm94SnNvbiA9ICh0YXJnZXRMYXlvdXRCb3hJZDogbnVtYmVyIHwgdW5kZWZpbmVkLCByZWZlcmVuY2VMYXlvdXRBdG9tSWQ6IG51bWJlciB8IHVuZGVmaW5lZCkgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5Kc29uKGAvY2FsaWZvcm5pYS9DcmVhdGVMYXlvdXRBdG9tRm9yQm94P3RhcmdldExheW91dEJveElkPSR7dGFyZ2V0TGF5b3V0Qm94SWR9JnJlZmVyZW5jZUxheW91dEF0b21JZD0ke3JlZmVyZW5jZUxheW91dEF0b21JZH1gLCBcInBvc3RcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBDcmVhdGVMYXlvdXRCb3hGb3JCb3hPclJvd0pzb24gPSAodGFyZ2V0TGF5b3V0Qm94T3JSb3dJZDogbnVtYmVyIHwgdW5kZWZpbmVkLCByZWZlcmVuY2VMYXlvdXRCb3hJZDogbnVtYmVyIHwgdW5kZWZpbmVkKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL0NyZWF0ZUxheW91dEJveEZvckJveE9yUm93P3RhcmdldExheW91dEJveE9yUm93SWQ9JHt0YXJnZXRMYXlvdXRCb3hPclJvd0lkfSZyZWZlcmVuY2VMYXlvdXRCb3hJZD0ke3JlZmVyZW5jZUxheW91dEJveElkfWAsIFwicG9zdFwiLCBudWxsLCB0aGlzLmJlZm9yZVNlbmRBamF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHVibGljIENyZWF0ZUxheW91dEJveEZvckF0b21JblBsYWNlSnNvbiA9ICh0YXJnZXRMYXlvdXRBdG9tSWQ6IG51bWJlciB8IHVuZGVmaW5lZCwgcmVmZXJlbmNlTGF5b3V0Qm94SWQ6IG51bWJlciB8IHVuZGVmaW5lZCkgOiBKUXVlcnlYSFIgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVycy5Kc29uKGAvY2FsaWZvcm5pYS9DcmVhdGVMYXlvdXRCb3hGb3JBdG9tSW5QbGFjZT90YXJnZXRMYXlvdXRBdG9tSWQ9JHt0YXJnZXRMYXlvdXRBdG9tSWR9JnJlZmVyZW5jZUxheW91dEJveElkPSR7cmVmZXJlbmNlTGF5b3V0Qm94SWR9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgQ3JlYXRlTGF5b3V0Um93Rm9yVmlld0pzb24gPSAodGFyZ2V0Q2FsaWZvcm5pYVZpZXdJZDogbnVtYmVyIHwgdW5kZWZpbmVkLCByZWZlcmVuY2VMYXlvdXRSb3dJZDogbnVtYmVyIHwgdW5kZWZpbmVkKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL0NyZWF0ZUxheW91dFJvd0ZvclZpZXc/dGFyZ2V0Q2FsaWZvcm5pYVZpZXdJZD0ke3RhcmdldENhbGlmb3JuaWFWaWV3SWR9JnJlZmVyZW5jZUxheW91dFJvd0lkPSR7cmVmZXJlbmNlTGF5b3V0Um93SWR9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgU2V0TGF5b3V0Um93T3JCb3hBc0luc3RhbmNlYWJsZUpzb24gPSAoY2FsaWZvcm5pYVByb2plY3RJZDogbnVtYmVyIHwgdW5kZWZpbmVkLCBsYXlvdXRSb3dPckJveElkOiBudW1iZXIgfCB1bmRlZmluZWQpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvU2V0TGF5b3V0Um93T3JCb3hBc0luc3RhbmNlYWJsZT9jYWxpZm9ybmlhUHJvamVjdElkPSR7Y2FsaWZvcm5pYVByb2plY3RJZH0mbGF5b3V0Um93T3JCb3hJZD0ke2xheW91dFJvd09yQm94SWR9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgTW92ZVN0eWxlQXRvbVRvUmVzcG9uc2l2ZURldmljZUpzb24gPSAoc3R5bGVBdG9tSWQ6IG51bWJlciB8IHVuZGVmaW5lZCwgdGFyZ2V0UmVzcG9uc2l2ZURldmljZUlkOiBudW1iZXIgfCB1bmRlZmluZWQpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvTW92ZVN0eWxlQXRvbVRvUmVzcG9uc2l2ZURldmljZT9zdHlsZUF0b21JZD0ke3N0eWxlQXRvbUlkfSZ0YXJnZXRSZXNwb25zaXZlRGV2aWNlSWQ9JHt0YXJnZXRSZXNwb25zaXZlRGV2aWNlSWR9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgUmVmcmVzaEV4dGVybmFsQXBpc0FjdGlvbiA9ICgpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuQWN0aW9uKGAvY2FsaWZvcm5pYS9SZWZyZXNoRXh0ZXJuYWxBcGlzYCwgXCJnZXRcIiwgbnVsbCwgdGhpcy5iZWZvcmVTZW5kQWpheCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHB1YmxpYyBNb3ZlTGF5b3V0TW9sZWN1bGVJbnRvTGF5b3V0TW9sZWN1bGVKc29uID0gKG1vdmVkTGF5b3V0TW9sZWN1bGVJZDogbnVtYmVyIHwgdW5kZWZpbmVkLCB0YXJnZXRDb250YWluZXJMYXlvdXRNb2xlY3VsZUlkOiBudW1iZXIgfCB1bmRlZmluZWQpIDogSlF1ZXJ5WEhSID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnMuSnNvbihgL2NhbGlmb3JuaWEvTW92ZUxheW91dE1vbGVjdWxlSW50b0xheW91dE1vbGVjdWxlP21vdmVkTGF5b3V0TW9sZWN1bGVJZD0ke21vdmVkTGF5b3V0TW9sZWN1bGVJZH0mdGFyZ2V0Q29udGFpbmVyTGF5b3V0TW9sZWN1bGVJZD0ke3RhcmdldENvbnRhaW5lckxheW91dE1vbGVjdWxlSWR9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwdWJsaWMgTW92ZUxheW91dE1vbGVjdWxlTmV4dFRvTGF5b3V0TW9sZWN1bGVKc29uID0gKG1vdmVkTGF5b3V0TW9sZWN1bGVJZDogbnVtYmVyIHwgdW5kZWZpbmVkLCB0YXJnZXROZWlnaGJvckxheW91dE1vbGVjdWxlSWQ6IG51bWJlciB8IHVuZGVmaW5lZCwgaXNNb3ZlQmVmb3JlOiBib29sZWFuKSA6IEpRdWVyeVhIUiA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwZXJzLkpzb24oYC9jYWxpZm9ybmlhL01vdmVMYXlvdXRNb2xlY3VsZU5leHRUb0xheW91dE1vbGVjdWxlP21vdmVkTGF5b3V0TW9sZWN1bGVJZD0ke21vdmVkTGF5b3V0TW9sZWN1bGVJZH0mdGFyZ2V0TmVpZ2hib3JMYXlvdXRNb2xlY3VsZUlkPSR7dGFyZ2V0TmVpZ2hib3JMYXlvdXRNb2xlY3VsZUlkfSZpc01vdmVCZWZvcmU9JHtpc01vdmVCZWZvcmV9YCwgXCJwb3N0XCIsIG51bGwsIHRoaXMuYmVmb3JlU2VuZEFqYXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9UeXBld3JpdGVyL0NhbGlmb3JuaWFDb250cm9sbGVyLnRzIiwiLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJqcXVlcnlcIiAvPlxyXG5leHBvcnQgZnVuY3Rpb24gSnNvbih1cmw6IHN0cmluZywgbWV0aG9kOiBzdHJpbmcsIGRhdGE6IGFueSwgYmVmb3JlU2VuZENhbGxiYWNrOiBhbnkpOiBKUXVlcnlYSFIge1xyXG4gICAgLy8gVE9ETyBkb2VzIG5vdCB3b3JrIHJlbGlhYmx5OiBjYWNoZSBzZXQgdG8gZmFsc2UgZm9yIGFsbCBjb250cm9sbGVyIGFjdGlvbnMgYnkgZGVmYXVsdCAocmVhc29uOiBpcGFkIGJ1ZyB3aGVyZSBmdW5jdGlvbiB3YXMgaHR0cEdFVCBvcmlnaW5hbGx5IGFuZCBjYWNoZWQgcmVzcG9uc2Ugd2FzIHVzZWQgZm9yIHNhbWUgZnVuY3Rpb24gYXMgaHR0cFBPU1QpXHJcbiAgICBsZXQgcmVxdWVzdDogSlF1ZXJ5WEhSO1xyXG4gICAgaWYgKGRhdGEgIT09IG51bGwpIHtcclxuICAgICAgICByZXF1ZXN0ID0galF1ZXJ5LmFqYXgodXJsLCB7IG1ldGhvZDogbWV0aG9kLCBkYXRhOiBKU09OLnN0cmluZ2lmeShkYXRhKSwgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLCBiZWZvcmVTZW5kOiBiZWZvcmVTZW5kQ2FsbGJhY2sgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXF1ZXN0ID0galF1ZXJ5LmFqYXgodXJsLCB7IG1ldGhvZDogbWV0aG9kLCBiZWZvcmVTZW5kOiBiZWZvcmVTZW5kQ2FsbGJhY2sgfSk7XHJcbiAgICB9XHJcbiAgICByZXF1ZXN0LmZhaWwoKGRhdGE6IEpRdWVyeVhIUik6IHZvaWQgPT4ge1xyXG4gICAgICAgIGlmICgoZGF0YS5yZXNwb25zZUpTT04gIT09IHVuZGVmaW5lZCkgJiYgKGRhdGEucmVzcG9uc2VKU09OLlN0YXR1c1RleHQgIT09IHVuZGVmaW5lZCkpIHsgLy8gVE9ETyBpcyB0aGlzIHN0aWxsIGNvcnJlY3QgXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEucmVzcG9uc2VKU09OLlN0YXR1c1RleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPIHByaW50IGVycm9yIC8gc3RhdHVzIHRleHQgZG9lcyBub3Qgd29yayB3aGVuIGRldmVsb3BtZW50IGlzIGVuYWJsZWQgYW5kIGh0bWwgZXJyb3IgcGFnZSBpcyByZXR1cm5lZCA9PiBleHRyYWN0IGVycm9yIG1lc3NhZ2VcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlcXVlc3Q7IC8vIFRPRE8gbXVsdGlwbGUgcXVldWVzLCBydW5uaW5nLCBkb25lLCBmYWlsLCByZXNjaGVkdWxlOyBjb21wYXJlIHJldmlzaW9uIGFuZCBcclxuICAgIC8vIFRPRE8gcGF1c2Ugd2hlbiBkZXRlY3RpbmcgaG9sZXNcclxufTtcclxuZXhwb3J0IGZ1bmN0aW9uIEFjdGlvbih1cmw6IHN0cmluZywgbWV0aG9kOiBzdHJpbmcsIGRhdGE6IGFueSwgYmVmb3JlU2VuZENhbGxiYWNrOiBhbnkpOiBKUXVlcnlYSFIge1xyXG4gICAgLy8gVE9ETyBkb2VzIG5vdCB3b3JrIHJlbGlhYmx5OiBjYWNoZSBzZXQgdG8gZmFsc2UgZm9yIGFsbCBjb250cm9sbGVyIGFjdGlvbnMgYnkgZGVmYXVsdCAocmVhc29uOiBpcGFkIGJ1ZyB3aGVyZSBmdW5jdGlvbiB3YXMgaHR0cEdFVCBvcmlnaW5hbGx5IGFuZCBjYWNoZWQgcmVzcG9uc2Ugd2FzIHVzZWQgZm9yIHNhbWUgZnVuY3Rpb24gYXMgaHR0cFBPU1QpXHJcbiAgICBsZXQgcmVxdWVzdDogSlF1ZXJ5WEhSO1xyXG4gICAgaWYgKGRhdGEgIT09IG51bGwpIHtcclxuICAgICAgICByZXF1ZXN0ID0galF1ZXJ5LmFqYXgodXJsLCB7IG1ldGhvZDogbWV0aG9kLCBkYXRhOiBKU09OLnN0cmluZ2lmeShkYXRhKSwgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLCBiZWZvcmVTZW5kOiBiZWZvcmVTZW5kQ2FsbGJhY2sgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXF1ZXN0ID0galF1ZXJ5LmFqYXgodXJsLCB7IG1ldGhvZDogbWV0aG9kLCBiZWZvcmVTZW5kOiBiZWZvcmVTZW5kQ2FsbGJhY2sgfSk7XHJcbiAgICB9XHJcbiAgICByZXF1ZXN0LmZhaWwoKGRhdGE6IEpRdWVyeVhIUik6IHZvaWQgPT4ge1xyXG4gICAgICAgIGlmIChkYXRhLnN0YXR1c1RleHQgIT09IHVuZGVmaW5lZCkgeyAvLyBUT0RPIGlzIHRoaXMgc3RpbGwgY29ycmVjdFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhLnN0YXR1c1RleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlcXVlc3Q7XHJcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vVHlwZXdyaXRlci90c2dlbkhlbHBlcnMudHMiLCJcclxuXHJcbmV4cG9ydCBlbnVtIENhbGlmb3JuaWFFdmVudCB7XHJcbiAgICBSZWFkSW5pdGlhbENsaWVudERhdGEgPSAwLFxyXG4gICAgQ3JlYXRlU3RvcmUgPSAxLFxyXG4gICAgUmVhZFN0b3JlID0gMixcclxuICAgIENyZWF0ZVN0eWxlUXVhbnR1bSA9IDMsXHJcbiAgICBEdXBsaWNhdGVTdHlsZVF1YW50dW0gPSA0LFxyXG4gICAgRGVsZXRlU3R5bGVRdWFudHVtID0gNSxcclxuICAgIERlbGV0ZVN0eWxlVmFsdWUgPSA2LFxyXG4gICAgQ3JlYXRlU3R5bGVWYWx1ZUZvckF0b20gPSA3LFxyXG4gICAgVXBkYXRlU3R5bGVWYWx1ZSA9IDgsXHJcbiAgICBVcGRhdGVTdHlsZVF1YW50dW0gPSA5LFxyXG4gICAgQXBwbHlTdHlsZVF1YW50dW1Ub0F0b20gPSAxMCxcclxuICAgIENyZWF0ZVN0eWxlQXRvbUZvck1vbGVjdWxlID0gMTEsXHJcbiAgICBEZWxldGVTdHlsZUF0b20gPSAxMixcclxuICAgIFVwZGF0ZUNvbnRlbnRBdG9tID0gMTMsXHJcbiAgICBDcmVhdGVMYXlvdXRBdG9tRm9yQm94ID0gMTQsXHJcbiAgICBDcmVhdGVMYXlvdXRSb3dGb3JWaWV3ID0gMTUsXHJcbiAgICBEZWxldGVMYXlvdXQgPSAxNixcclxuICAgIFNldEJveENvdW50ID0gMTcsXHJcbiAgICBDcmVhdGVMYXlvdXRCb3hGb3JCb3hPclJvdyA9IDE4LFxyXG4gICAgTW92ZVN0eWxlQXRvbVRvUmVzcG9uc2l2ZURldmljZSA9IDE5LFxyXG4gICAgU2V0U3R5bGVNb2xlY3VsZVJlZmVyZW5jZSA9IDIwLFxyXG4gICAgU2V0U3R5bGVNb2xlY3VsZUFzUmVmZXJlbmNlID0gMjEsXHJcbiAgICBTZXRMYXlvdXRNb2xlY3VsZUFzSW5zdGFuY2VhYmxlID0gMjIsXHJcbiAgICBTeW5jU3R5bGVNb2xlY3VsZVRvUmVmZXJlbmNlID0gMjMsXHJcbiAgICBTeW5jU3R5bGVNb2xlY3VsZUZyb21SZWZlcmVuY2UgPSAyNCxcclxuICAgIE1vdmVMYXlvdXRNb2xlY3VsZUludG9MYXlvdXRNb2xlY3VsZSA9IDI1LFxyXG4gICAgTW92ZUxheW91dE1vbGVjdWxlTmV4dFRvTGF5b3V0TW9sZWN1bGUgPSAyNixcclxuICAgIFB1Ymxpc2ggPSAyNyxcclxuICAgIFZpZXcgPSAyOCxcclxuICAgIENyZWF0ZUNhbGlmb3JuaWFWaWV3ID0gMjksXHJcbiAgICBEZWxldGVDYWxpZm9ybmlhVmlldyA9IDMwLFxyXG4gICAgQ3JlYXRlTGF5b3V0U3R5bGVJbnRlcmFjdGlvbiA9IDMxLFxyXG4gICAgQ3JlYXRlU3R5bGVWYWx1ZUludGVyYWN0aW9uID0gMzIsXHJcbiAgICBEZWxldGVMYXlvdXRTdHlsZUludGVyYWN0aW9uID0gMzMsXHJcbiAgICBDcmVhdGVMYXlvdXRCb3hGb3JBdG9tSW5QbGFjZSA9IDM0LFxyXG4gICAgU3luY0xheW91dFN0eWxlc0ltaXRhdGluZ1JlZmVyZW5jZSA9IDM1LFxyXG4gICAgQ3JlYXRlQ2FsaWZvcm5pYVZpZXdGcm9tUmVmZXJlbmNlVmlldyA9IDM2LFxyXG4gICAgRGVsZXRlU3R5bGVWYWx1ZUludGVyYWN0aW9uID0gMzcsXHJcbiAgICBTZXRTcGVjaWFsTGF5b3V0Qm94VHlwZSA9IDM4LFxyXG4gICAgVmlld0pzID0gMzksXHJcbiAgICBWaWV3Q3NzID0gNDAsXHJcbiAgICBVcGRhdGVVc2VyRGVmaW5lZENzc0ZvclByb2plY3QgPSA0MSxcclxuICAgIFVwZGF0ZVVzZXJEZWZpbmVkQ3NzRm9yVmlldyA9IDQyLFxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vVHlwZXdyaXRlci9DYWxpZm9ybmlhRXZlbnQudHMiLCJcclxuXHJcbmltcG9ydCB7U3R5bGVRdWFudHVtfSBmcm9tIFwiLi9TdHlsZVF1YW50dW1cIjtcbmltcG9ydCB7U3R5bGVBdG9tfSBmcm9tIFwiLi9TdHlsZUF0b21cIjtcbmltcG9ydCB7U3R5bGVNb2xlY3VsZX0gZnJvbSBcIi4vU3R5bGVNb2xlY3VsZVwiO1xuaW1wb3J0IHtSZXNwb25zaXZlRGV2aWNlfSBmcm9tIFwiLi9SZXNwb25zaXZlRGV2aWNlXCI7XG5pbXBvcnQge0NvbnRlbnRBdG9tfSBmcm9tIFwiLi9Db250ZW50QXRvbVwiO1xuaW1wb3J0IHtQaWN0dXJlQ29udGVudH0gZnJvbSBcIi4vUGljdHVyZUNvbnRlbnRcIjtcbmltcG9ydCB7Q2FsaWZvcm5pYVZpZXd9IGZyb20gXCIuL0NhbGlmb3JuaWFWaWV3XCI7XG5pbXBvcnQge1NoYXJlZFByb2plY3RJbmZvfSBmcm9tIFwiLi9TaGFyZWRQcm9qZWN0SW5mb1wiO1xuaW1wb3J0IHtTdHlsZVZhbHVlfSBmcm9tIFwiLi9TdHlsZVZhbHVlXCI7XG5pbXBvcnQge0xheW91dEJhc2V9IGZyb20gXCIuL0xheW91dEJhc2VcIjtcbmltcG9ydCB7TGF5b3V0U3R5bGVJbnRlcmFjdGlvbn0gZnJvbSBcIi4vTGF5b3V0U3R5bGVJbnRlcmFjdGlvblwiO1xuaW1wb3J0IHtDYWxpZm9ybmlhU2VsZWN0aW9uT3ZlcmxheX0gZnJvbSBcIi4vQ2FsaWZvcm5pYVNlbGVjdGlvbk92ZXJsYXlcIjsgXHJcbmV4cG9ydCBjbGFzcyBDYWxpZm9ybmlhUHJvamVjdCB7IFxyXG4gICAgQ2FsaWZvcm5pYVByb2plY3RJZDogbnVtYmVyO1xyXG4gICAgTmFtZTogc3RyaW5nO1xyXG4gICAgU3R5bGVWYWx1ZXM6IFN0eWxlVmFsdWVbXTtcclxuICAgIFN0eWxlUXVhbnR1bXM6IFN0eWxlUXVhbnR1bVtdO1xyXG4gICAgU3R5bGVBdG9tczogU3R5bGVBdG9tW107XHJcbiAgICBTdHlsZU1vbGVjdWxlczogU3R5bGVNb2xlY3VsZVtdO1xyXG4gICAgUmVzcG9uc2l2ZURldmljZXM6IFJlc3BvbnNpdmVEZXZpY2VbXTtcclxuICAgIExheW91dE1vbGVjdWxlczogTGF5b3V0QmFzZVtdO1xyXG4gICAgTGF5b3V0U3R5bGVJbnRlcmFjdGlvbnM6IExheW91dFN0eWxlSW50ZXJhY3Rpb25bXTtcclxuICAgIENvbnRlbnRBdG9tczogQ29udGVudEF0b21bXTtcclxuICAgIFBpY3R1cmVDb250ZW50czogUGljdHVyZUNvbnRlbnRbXTtcclxuICAgIENhbGlmb3JuaWFWaWV3czogQ2FsaWZvcm5pYVZpZXdbXTtcclxuICAgIFNoYXJlZFByb2plY3RJbmZvczogU2hhcmVkUHJvamVjdEluZm9bXTtcclxuICAgIFByb2plY3REZWZhdWx0c1JldmlzaW9uOiBudW1iZXI7XHJcbiAgICBVc2VyRGVmaW5lZENzczogc3RyaW5nIHwgdW5kZWZpbmVkXHJcbiAgICBDdXJyZW50U2VsZWN0aW9uOiBDYWxpZm9ybmlhU2VsZWN0aW9uT3ZlcmxheTtcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvQ2FsaWZvcm5pYVByb2plY3QudHMiLCJcclxuXHJcbmludGVyZmFjZSBDYWxpZm9ybmlhU3RvcmUgeyBDYWxpZm9ybmlhU3RvcmVJZDogc3RyaW5nOyB9XG4gXHJcbmV4cG9ydCBjbGFzcyBDYWxpZm9ybmlhVXNlckRlZmF1bHRzIHsgXHJcbiAgICBDYWxpZm9ybmlhVXNlckRlZmF1bHRzSWQ6IG51bWJlcjtcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvQ2FsaWZvcm5pYVVzZXJEZWZhdWx0cy50cyIsIlxyXG5cclxuaW1wb3J0IHtDYWxpZm9ybmlhUHJvamVjdH0gZnJvbSBcIi4vQ2FsaWZvcm5pYVByb2plY3RcIjtcbmltcG9ydCB7U3R5bGVRdWFudHVtfSBmcm9tIFwiLi9TdHlsZVF1YW50dW1cIjtcbmltcG9ydCB7Q2FsaWZvcm5pYUNsaWVudFBhcnRpYWxEYXRhfSBmcm9tIFwiLi9DYWxpZm9ybmlhQ2xpZW50UGFydGlhbERhdGFcIjsgXHJcbmV4cG9ydCBjbGFzcyBDYWxpZm9ybmlhQ2xpZW50Vmlld01vZGVsIHsgXHJcbiAgICBTdGF0dXNUZXh0OiBzdHJpbmcgfCB1bmRlZmluZWRcclxuICAgIEN1cnJlbnRSZXZpc2lvbjogbnVtYmVyO1xyXG4gICAgQ2FsaWZvcm5pYUV2ZW50OiBudW1iZXI7XHJcbiAgICBDYWxpZm9ybmlhUHJvamVjdDogQ2FsaWZvcm5pYVByb2plY3Q7XHJcbiAgICBTdHlsZUF0b21Dc3NQcm9wZXJ0eU1hcHBpbmc6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nW107IH07XHJcbiAgICBBbGxDc3NQcm9wZXJ0aWVzOiBzdHJpbmdbXTtcclxuICAgIFRoaXJkUGFydHlGb250czogc3RyaW5nW107XHJcbiAgICBVcmxUb1JlYWRPbmx5OiBzdHJpbmcgfCB1bmRlZmluZWRcclxuICAgIFVybFRvUmVhZEFuZEVkaXQ6IHN0cmluZyB8IHVuZGVmaW5lZFxyXG4gICAgUGFydGlhbFVwZGF0ZTogQ2FsaWZvcm5pYUNsaWVudFBhcnRpYWxEYXRhO1xyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vVHlwZXdyaXRlci9DYWxpZm9ybmlhQ2xpZW50Vmlld01vZGVsLnRzIiwiXHJcblxyXG5pbXBvcnQge0NhbGlmb3JuaWFQcm9qZWN0fSBmcm9tIFwiLi9DYWxpZm9ybmlhUHJvamVjdFwiO1xuaW1wb3J0IHtTdHlsZU1vbGVjdWxlQXRvbU1hcHBpbmd9IGZyb20gXCIuL1N0eWxlTW9sZWN1bGVBdG9tTWFwcGluZ1wiO1xuaW1wb3J0IHtDb250ZW50QXRvbX0gZnJvbSBcIi4vQ29udGVudEF0b21cIjtcbmltcG9ydCB7TGF5b3V0QmFzZX0gZnJvbSBcIi4vTGF5b3V0QmFzZVwiOyBcclxuZXhwb3J0IGNsYXNzIFN0eWxlTW9sZWN1bGUgeyBcclxuICAgIFN0eWxlTW9sZWN1bGVJZDogbnVtYmVyO1xyXG4gICAgTmFtZTogc3RyaW5nO1xyXG4gICAgTmFtZVNob3J0OiBzdHJpbmc7XHJcbiAgICBIdG1sVGFnOiBzdHJpbmcgfCB1bmRlZmluZWRcclxuICAgIENsb25lZEZyb21TdHlsZUlkOiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICBDbG9uZWRGcm9tU3R5bGU6IFN0eWxlTW9sZWN1bGU7XHJcbiAgICBDbG9uZU9mU3R5bGVzOiBTdHlsZU1vbGVjdWxlW107XHJcbiAgICBTdHlsZUZvckxheW91dElkOiBudW1iZXI7XHJcbiAgICBTdHlsZUZvckxheW91dDogTGF5b3V0QmFzZTtcclxuICAgIE1hcHBlZFN0eWxlQXRvbXM6IFN0eWxlTW9sZWN1bGVBdG9tTWFwcGluZ1tdO1xyXG4gICAgSXNQb3NpdGlvbkZpeGVkOiBib29sZWFuO1xyXG4gICAgVG9wQ3NzVmFsdWVQeDogc3RyaW5nIHwgdW5kZWZpbmVkXHJcbiAgICBMZWZ0Q3NzVmFsdWVQeDogc3RyaW5nIHwgdW5kZWZpbmVkXHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9UeXBld3JpdGVyL1N0eWxlTW9sZWN1bGUudHMiLCJcclxuXHJcbmltcG9ydCB7Q2FsaWZvcm5pYVByb2plY3R9IGZyb20gXCIuL0NhbGlmb3JuaWFQcm9qZWN0XCI7XG5pbXBvcnQge1N0eWxlQXRvbVF1YW50dW1NYXBwaW5nfSBmcm9tIFwiLi9TdHlsZUF0b21RdWFudHVtTWFwcGluZ1wiOyBcclxuZXhwb3J0IGNsYXNzIFN0eWxlUXVhbnR1bSB7IFxyXG4gICAgU3R5bGVRdWFudHVtSWQ6IG51bWJlcjtcclxuICAgIE5hbWU6IHN0cmluZztcclxuICAgIENzc1Byb3BlcnR5OiBzdHJpbmc7XHJcbiAgICBDc3NWYWx1ZTogc3RyaW5nO1xyXG4gICAgSXNEZWxldGFibGU6IGJvb2xlYW47XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9UeXBld3JpdGVyL1N0eWxlUXVhbnR1bS50cyIsIlxyXG5cclxuaW1wb3J0IHtDYWxpZm9ybmlhUHJvamVjdH0gZnJvbSBcIi4vQ2FsaWZvcm5pYVByb2plY3RcIjtcbmltcG9ydCB7U3R5bGVBdG9tVHlwZX0gZnJvbSBcIi4vU3R5bGVBdG9tVHlwZVwiO1xuaW1wb3J0IHtTdHlsZUF0b21RdWFudHVtTWFwcGluZ30gZnJvbSBcIi4vU3R5bGVBdG9tUXVhbnR1bU1hcHBpbmdcIjtcbmltcG9ydCB7U3R5bGVWYWx1ZX0gZnJvbSBcIi4vU3R5bGVWYWx1ZVwiO1xuaW1wb3J0IHtTdHlsZU1vbGVjdWxlQXRvbU1hcHBpbmd9IGZyb20gXCIuL1N0eWxlTW9sZWN1bGVBdG9tTWFwcGluZ1wiOyBcclxuZXhwb3J0IGNsYXNzIFN0eWxlQXRvbSB7IFxyXG4gICAgU3R5bGVBdG9tSWQ6IG51bWJlcjtcclxuICAgIE5hbWU6IHN0cmluZztcclxuICAgIFN0eWxlQXRvbVR5cGU6IFN0eWxlQXRvbVR5cGU7XHJcbiAgICBBcHBsaWVkVmFsdWVzOiBTdHlsZVZhbHVlW107XHJcbiAgICBNYXBwZWRRdWFudHVtczogU3R5bGVBdG9tUXVhbnR1bU1hcHBpbmdbXTtcclxuICAgIE1hcHBlZFRvTW9sZWN1bGVJZDogbnVtYmVyO1xyXG4gICAgSXNEZWxldGFibGU6IGJvb2xlYW47XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9UeXBld3JpdGVyL1N0eWxlQXRvbS50cyIsIlxyXG5cclxuZXhwb3J0IGVudW0gU3R5bGVBdG9tVHlwZSB7XHJcbiAgICBHZW5lcmljID0gMCxcclxuICAgIEZvbnQgPSAxLFxyXG4gICAgVHlwb2dyYXBoeSA9IDIsXHJcbiAgICBEaXZpZGVyID0gMyxcclxuICAgIEJhY2tncm91bmQgPSA0LFxyXG4gICAgU3BhY2luZyA9IDUsXHJcbiAgICBQaWN0dXJlID0gNixcclxuICAgIEdyaWQgPSA3LFxyXG4gICAgUm93ID0gOCxcclxuICAgIE5hdmJhciA9IDksXHJcbiAgICBMaXN0ID0gMTAsXHJcbiAgICBCb3ggPSAxMSxcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvU3R5bGVBdG9tVHlwZS50cyIsIlxyXG5cclxuaW1wb3J0IHtDYWxpZm9ybmlhUHJvamVjdH0gZnJvbSBcIi4vQ2FsaWZvcm5pYVByb2plY3RcIjtcbmltcG9ydCB7U3R5bGVBdG9tfSBmcm9tIFwiLi9TdHlsZUF0b21cIjsgXHJcbmV4cG9ydCBjbGFzcyBTdHlsZVZhbHVlIHsgXHJcbiAgICBTdHlsZVZhbHVlSWQ6IG51bWJlcjtcclxuICAgIFN0eWxlQXRvbUlkOiBudW1iZXI7XHJcbiAgICBDc3NQcm9wZXJ0eTogc3RyaW5nO1xyXG4gICAgQ3NzVmFsdWU6IHN0cmluZztcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvU3R5bGVWYWx1ZS50cyIsIlxyXG5cclxuaW1wb3J0IHtDYWxpZm9ybmlhUHJvamVjdH0gZnJvbSBcIi4vQ2FsaWZvcm5pYVByb2plY3RcIjtcbmltcG9ydCB7U3R5bGVNb2xlY3VsZUF0b21NYXBwaW5nfSBmcm9tIFwiLi9TdHlsZU1vbGVjdWxlQXRvbU1hcHBpbmdcIjsgXHJcbmV4cG9ydCBjbGFzcyBSZXNwb25zaXZlRGV2aWNlIHsgXHJcbiAgICBSZXNwb25zaXZlRGV2aWNlSWQ6IG51bWJlcjtcclxuICAgIE5hbWU6IHN0cmluZztcclxuICAgIE5hbWVTaG9ydDogc3RyaW5nO1xyXG4gICAgV2lkdGhUaHJlc2hvbGQ6IG51bWJlcjtcclxuICAgIEFwcGxpZWRUb01hcHBpbmdzOiBTdHlsZU1vbGVjdWxlQXRvbU1hcHBpbmdbXTtcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvUmVzcG9uc2l2ZURldmljZS50cyIsIlxyXG5cclxuaW1wb3J0IHtDYWxpZm9ybmlhUHJvamVjdH0gZnJvbSBcIi4vQ2FsaWZvcm5pYVByb2plY3RcIjtcbmltcG9ydCB7TGF5b3V0Um93fSBmcm9tIFwiLi9MYXlvdXRSb3dcIjtcbmltcG9ydCB7UXVlcnlWaWV3TGF5b3V0Qm94TWFwcGluZ30gZnJvbSBcIi4vUXVlcnlWaWV3TGF5b3V0Qm94TWFwcGluZ1wiOyBcclxuZXhwb3J0IGNsYXNzIENhbGlmb3JuaWFWaWV3IHsgXHJcbiAgICBDYWxpZm9ybmlhVmlld0lkOiBudW1iZXI7XHJcbiAgICBOYW1lOiBzdHJpbmc7XHJcbiAgICBRdWVyeVVybDogc3RyaW5nO1xyXG4gICAgSG9zdGVkQnlMYXlvdXRNYXBwaW5nczogUXVlcnlWaWV3TGF5b3V0Qm94TWFwcGluZ1tdO1xyXG4gICAgUGxhY2VkTGF5b3V0Um93czogTGF5b3V0Um93W107XHJcbiAgICBWaWV3U29ydE9yZGVyS2V5OiBudW1iZXI7XHJcbiAgICBJc0ludGVybmFsOiBib29sZWFuO1xyXG4gICAgVXNlckRlZmluZWRDc3M6IHN0cmluZyB8IHVuZGVmaW5lZFxyXG4gICAgRGVlcGVzdExldmVsOiBudW1iZXI7XHJcbiAgICBTcGVjaWFsU3R5bGVWaWV3U3R5bGVNb2xlY3VsZUlkOiBudW1iZXI7XHJcbiAgICBTcGVjaWFsU3R5bGVCb2R5U3R5bGVNb2xlY3VsZUlkOiBudW1iZXI7XHJcbiAgICBTcGVjaWFsU3R5bGVIdG1sU3R5bGVNb2xlY3VsZUlkOiBudW1iZXI7XHJcbiAgICBTcGVjaWFsU3R5bGVWaWV3U3R5bGVNb2xlY3VsZUlkU3RyaW5nOiBzdHJpbmc7XHJcbiAgICBTcGVjaWFsU3R5bGVCb2R5U3R5bGVNb2xlY3VsZUlkU3RyaW5nOiBzdHJpbmc7XHJcbiAgICBTcGVjaWFsU3R5bGVIdG1sU3R5bGVNb2xlY3VsZUlkU3RyaW5nOiBzdHJpbmc7XHJcbiAgICBTcGVjaWFsU3R5bGVWaWV3U3R5bGVTdHJpbmc6IHN0cmluZztcclxuICAgIFNwZWNpYWxTdHlsZUJvZHlTdHlsZVN0cmluZzogc3RyaW5nO1xyXG4gICAgU3BlY2lhbFN0eWxlSHRtbFN0eWxlU3RyaW5nOiBzdHJpbmc7XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9UeXBld3JpdGVyL0NhbGlmb3JuaWFWaWV3LnRzIiwiXHJcblxyXG5pbXBvcnQge0NhbGlmb3JuaWFQcm9qZWN0fSBmcm9tIFwiLi9DYWxpZm9ybmlhUHJvamVjdFwiO1xuaW1wb3J0IHtMYXlvdXRCb3h9IGZyb20gXCIuL0xheW91dEJveFwiO1xuaW1wb3J0IHtTdHlsZU1vbGVjdWxlfSBmcm9tIFwiLi9TdHlsZU1vbGVjdWxlXCI7XG5pbXBvcnQge0NhbGlmb3JuaWFWaWV3fSBmcm9tIFwiLi9DYWxpZm9ybmlhVmlld1wiO1xuaW1wb3J0IHtMYXlvdXRUeXBlfSBmcm9tIFwiLi9MYXlvdXRUeXBlXCI7IFxyXG5leHBvcnQgY2xhc3MgTGF5b3V0Um93IHsgXHJcbiAgICBMYXlvdXRCYXNlSWQ6IG51bWJlcjtcclxuICAgIFN0eWxlTW9sZWN1bGU6IFN0eWxlTW9sZWN1bGU7XHJcbiAgICBMYXlvdXRTb3J0T3JkZXJLZXk6IG51bWJlcjtcclxuICAgIExheW91dFR5cGU6IExheW91dFR5cGU7XHJcbiAgICBBbGxCb3hlc0JlbG93Um93OiBMYXlvdXRCb3hbXTtcclxuICAgIFBsYWNlZE9uVmlld0lkOiBudW1iZXI7XHJcbiAgICBEZWVwZXN0TGV2ZWw6IG51bWJlcjtcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvTGF5b3V0Um93LnRzIiwiXHJcblxyXG5pbXBvcnQge0NhbGlmb3JuaWFQcm9qZWN0fSBmcm9tIFwiLi9DYWxpZm9ybmlhUHJvamVjdFwiO1xuaW1wb3J0IHtMYXlvdXRSb3d9IGZyb20gXCIuL0xheW91dFJvd1wiO1xuaW1wb3J0IHtMYXlvdXRBdG9tfSBmcm9tIFwiLi9MYXlvdXRBdG9tXCI7XG5pbXBvcnQge1N0eWxlTW9sZWN1bGV9IGZyb20gXCIuL1N0eWxlTW9sZWN1bGVcIjtcbmltcG9ydCB7UXVlcnlWaWV3TGF5b3V0Qm94TWFwcGluZ30gZnJvbSBcIi4vUXVlcnlWaWV3TGF5b3V0Qm94TWFwcGluZ1wiO1xuaW1wb3J0IHtMYXlvdXRUeXBlfSBmcm9tIFwiLi9MYXlvdXRUeXBlXCI7XG5pbXBvcnQge1NwZWNpYWxMYXlvdXRCb3hUeXBlfSBmcm9tIFwiLi9TcGVjaWFsTGF5b3V0Qm94VHlwZVwiOyBcclxuZXhwb3J0IGNsYXNzIExheW91dEJveCB7IFxyXG4gICAgTGF5b3V0QmFzZUlkOiBudW1iZXI7XHJcbiAgICBTdHlsZU1vbGVjdWxlOiBTdHlsZU1vbGVjdWxlO1xyXG4gICAgTGF5b3V0U29ydE9yZGVyS2V5OiBudW1iZXI7XHJcbiAgICBMYXlvdXRUeXBlOiBMYXlvdXRUeXBlO1xyXG4gICAgUGxhY2VkSW5Cb3hBdG9tczogTGF5b3V0QXRvbVtdO1xyXG4gICAgUGxhY2VkSW5Cb3hCb3hlczogTGF5b3V0Qm94W107XHJcbiAgICBQbGFjZWRCb3hJbkJveElkOiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICBQbGFjZWRCb3hJbkJveDogTGF5b3V0Qm94O1xyXG4gICAgQm94T3duZXJSb3dJZDogbnVtYmVyO1xyXG4gICAgQm94T3duZXJSb3c6IExheW91dFJvdztcclxuICAgIEhvc3RlZFZpZXdNYXBwaW5nczogUXVlcnlWaWV3TGF5b3V0Qm94TWFwcGluZ1tdO1xyXG4gICAgU3BlY2lhbExheW91dEJveFR5cGU6IFNwZWNpYWxMYXlvdXRCb3hUeXBlO1xyXG4gICAgTGV2ZWw6IG51bWJlcjtcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvTGF5b3V0Qm94LnRzIiwiXHJcblxyXG5pbXBvcnQge0NhbGlmb3JuaWFQcm9qZWN0fSBmcm9tIFwiLi9DYWxpZm9ybmlhUHJvamVjdFwiO1xuaW1wb3J0IHtDb250ZW50QXRvbX0gZnJvbSBcIi4vQ29udGVudEF0b21cIjtcbmltcG9ydCB7TGF5b3V0Qm94fSBmcm9tIFwiLi9MYXlvdXRCb3hcIjtcbmltcG9ydCB7U3R5bGVNb2xlY3VsZX0gZnJvbSBcIi4vU3R5bGVNb2xlY3VsZVwiO1xuaW1wb3J0IHtMYXlvdXRUeXBlfSBmcm9tIFwiLi9MYXlvdXRUeXBlXCI7XG5pbXBvcnQge0xheW91dFN0eWxlSW50ZXJhY3Rpb259IGZyb20gXCIuL0xheW91dFN0eWxlSW50ZXJhY3Rpb25cIjsgXHJcbmV4cG9ydCBjbGFzcyBMYXlvdXRBdG9tIHsgXHJcbiAgICBMYXlvdXRCYXNlSWQ6IG51bWJlcjtcclxuICAgIFN0eWxlTW9sZWN1bGU6IFN0eWxlTW9sZWN1bGU7XHJcbiAgICBMYXlvdXRTb3J0T3JkZXJLZXk6IG51bWJlcjtcclxuICAgIExheW91dFR5cGU6IExheW91dFR5cGU7XHJcbiAgICBQbGFjZWRBdG9tSW5Cb3hJZDogbnVtYmVyO1xyXG4gICAgUGxhY2VkQXRvbUluQm94OiBMYXlvdXRCb3g7XHJcbiAgICBIb3N0ZWRDb250ZW50QXRvbTogQ29udGVudEF0b207XHJcbiAgICBMYXlvdXRTdHlsZUludGVyYWN0aW9uczogTGF5b3V0U3R5bGVJbnRlcmFjdGlvbltdO1xyXG4gICAgTGV2ZWw6IG51bWJlcjtcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvTGF5b3V0QXRvbS50cyIsIlxyXG5cclxuaW1wb3J0IHtTdHlsZU1vbGVjdWxlfSBmcm9tIFwiLi9TdHlsZU1vbGVjdWxlXCI7XG5pbXBvcnQge1N0eWxlQXRvbX0gZnJvbSBcIi4vU3R5bGVBdG9tXCI7XG5pbXBvcnQge1Jlc3BvbnNpdmVEZXZpY2V9IGZyb20gXCIuL1Jlc3BvbnNpdmVEZXZpY2VcIjsgXHJcbmV4cG9ydCBjbGFzcyBTdHlsZU1vbGVjdWxlQXRvbU1hcHBpbmcgeyBcclxuICAgIFN0eWxlTW9sZWN1bGVBdG9tTWFwcGluZ0lkOiBudW1iZXI7XHJcbiAgICBTdHlsZU1vbGVjdWxlSWQ6IG51bWJlcjtcclxuICAgIFN0eWxlTW9sZWN1bGU6IFN0eWxlTW9sZWN1bGU7XHJcbiAgICBSZXNwb25zaXZlRGV2aWNlSWQ6IG51bWJlcjtcclxuICAgIFJlc3BvbnNpdmVEZXZpY2U6IFJlc3BvbnNpdmVEZXZpY2U7XHJcbiAgICBTdGF0ZU1vZGlmaWVyOiBzdHJpbmcgfCB1bmRlZmluZWRcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvU3R5bGVNb2xlY3VsZUF0b21NYXBwaW5nLnRzIiwiXHJcblxyXG5pbXBvcnQge0NhbGlmb3JuaWFQcm9qZWN0fSBmcm9tIFwiLi9DYWxpZm9ybmlhUHJvamVjdFwiO1xuaW1wb3J0IHtTdHlsZU1vbGVjdWxlfSBmcm9tIFwiLi9TdHlsZU1vbGVjdWxlXCI7XG5pbXBvcnQge0NvbnRlbnRBdG9tVHlwZX0gZnJvbSBcIi4vQ29udGVudEF0b21UeXBlXCI7XG5pbXBvcnQge1BpY3R1cmVDb250ZW50fSBmcm9tIFwiLi9QaWN0dXJlQ29udGVudFwiO1xuaW1wb3J0IHtDYWxpZm9ybmlhVmlld30gZnJvbSBcIi4vQ2FsaWZvcm5pYVZpZXdcIjtcbmltcG9ydCB7TGF5b3V0QXRvbX0gZnJvbSBcIi4vTGF5b3V0QXRvbVwiOyBcclxuZXhwb3J0IGNsYXNzIENvbnRlbnRBdG9tIHsgXHJcbiAgICBDb250ZW50QXRvbUlkOiBudW1iZXI7XHJcbiAgICBDb250ZW50QXRvbVR5cGU6IENvbnRlbnRBdG9tVHlwZTtcclxuICAgIFRleHRDb250ZW50OiBzdHJpbmcgfCB1bmRlZmluZWRcclxuICAgIFVybDogc3RyaW5nIHwgdW5kZWZpbmVkXHJcbiAgICBQaWN0dXJlQ29udGVudElkOiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICBQaWN0dXJlQ29udGVudDogUGljdHVyZUNvbnRlbnQ7XHJcbiAgICBJc0RlbGV0ZWQ6IGJvb2xlYW47XHJcbiAgICBEZWxldGVkRGF0ZTogRGF0ZSB8IHN0cmluZ1xyXG4gICAgSW5zdGFuY2VkT25MYXlvdXRJZDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vVHlwZXdyaXRlci9Db250ZW50QXRvbS50cyIsIlxyXG5cclxuaW1wb3J0IHtTdHlsZU1vbGVjdWxlfSBmcm9tIFwiLi9TdHlsZU1vbGVjdWxlXCI7XG5pbXBvcnQge0xheW91dFR5cGV9IGZyb20gXCIuL0xheW91dFR5cGVcIjsgXHJcbmV4cG9ydCBjbGFzcyBMYXlvdXRCYXNlIHsgXHJcbiAgICBMYXlvdXRCYXNlSWQ6IG51bWJlcjtcclxuICAgIFN0eWxlTW9sZWN1bGU6IFN0eWxlTW9sZWN1bGU7XHJcbiAgICBMYXlvdXRTb3J0T3JkZXJLZXk6IG51bWJlcjtcclxuICAgIExheW91dFR5cGU6IExheW91dFR5cGU7XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9UeXBld3JpdGVyL0xheW91dEJhc2UudHMiLCJcclxuXHJcbmV4cG9ydCBlbnVtIExheW91dFR5cGUge1xyXG4gICAgUm93ID0gMCxcclxuICAgIEJveCA9IDEsXHJcbiAgICBBdG9tID0gMixcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvTGF5b3V0VHlwZS50cyIsIlxyXG5cclxuZXhwb3J0IGVudW0gU3BlY2lhbExheW91dEJveFR5cGUge1xyXG4gICAgRGVmYXVsdCA9IDAsXHJcbiAgICBDYWxpZm9ybmlhVmlld0hvbGRlciA9IDEsXHJcbiAgICBOYXZpZ2F0aW9uID0gMixcclxuICAgIFVuc29ydGVkTGlzdCA9IDMsXHJcbiAgICBTb3J0ZWRMaXN0ID0gNCxcclxuICAgIExpc3RJdGVtID0gNSxcclxuICAgIFJpY2hUZXh0ID0gNixcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1R5cGV3cml0ZXIvU3BlY2lhbExheW91dEJveFR5cGUudHMiLCJcclxuXHJcbmltcG9ydCB7U3R5bGVWYWx1ZUludGVyYWN0aW9uTWFwcGluZ30gZnJvbSBcIi4vU3R5bGVWYWx1ZUludGVyYWN0aW9uTWFwcGluZ1wiO1xuaW1wb3J0IHtMYXlvdXRTdHlsZUludGVyYWN0aW9uVHlwZX0gZnJvbSBcIi4vTGF5b3V0U3R5bGVJbnRlcmFjdGlvblR5cGVcIjsgXHJcbmV4cG9ydCBjbGFzcyBMYXlvdXRTdHlsZUludGVyYWN0aW9uIHsgXHJcbiAgICBMYXlvdXRTdHlsZUludGVyYWN0aW9uSWQ6IG51bWJlcjtcclxuICAgIExheW91dEF0b21JZDogbnVtYmVyO1xyXG4gICAgU3R5bGVWYWx1ZUludGVyYWN0aW9uczogU3R5bGVWYWx1ZUludGVyYWN0aW9uTWFwcGluZ1tdO1xyXG4gICAgTGF5b3V0U3R5bGVJbnRlcmFjdGlvblR5cGU6IExheW91dFN0eWxlSW50ZXJhY3Rpb25UeXBlO1xyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vVHlwZXdyaXRlci9MYXlvdXRTdHlsZUludGVyYWN0aW9uLnRzIiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2pzeC50c1wiIC8+XHJcblwidXNlIHN0cmljdFwiO1xyXG5pbXBvcnQgeyBWTm9kZSwgVk5vZGVQcm9wZXJ0aWVzIH0gZnJvbSBcIm1hcXVldHRlXCI7XHJcbmltcG9ydCAqIGFzIG1hcXVldHRlIGZyb20gXCJtYXF1ZXR0ZVwiO1xyXG5jb25zdCBoID0gbWFxdWV0dGUuaDtcclxuaW1wb3J0IHsgQ2FsaWZvcm5pYUFwcCwgREVGQVVMVF9FWENFUFRJT04sIHBhcnNlSW50RnJvbUF0dHJpYnV0ZSwgZ2V0QXJyYXlGb3JFbnVtLCBVSV9aX0lOREVYIH0gZnJvbSBcIi4vQ2FsaWZvcm5pYUFwcFwiO1xyXG5pbXBvcnQgeyBQYWdlUHJldmlld1ZNIH0gZnJvbSBcIi4vLi4vVmlld01vZGVscy9QYWdlUHJldmlld1ZNXCI7XHJcbmltcG9ydCB7IENhbGlmb3JuaWFWaWV3LCBMYXlvdXRSb3csIFN0eWxlTW9sZWN1bGUsIExheW91dEJveCwgTGF5b3V0QXRvbSwgUmVzcG9uc2l2ZURldmljZSwgU3R5bGVBdG9tLCBTdHlsZU1vbGVjdWxlQXRvbU1hcHBpbmcsIENvbnRlbnRBdG9tLCBTdHlsZVZhbHVlLCBTcGVjaWFsTGF5b3V0Qm94VHlwZSwgQ2FsaWZvcm5pYUNsaWVudFZpZXdNb2RlbCwgTGF5b3V0VHlwZSwgTGF5b3V0QmFzZSwgQ2FsaWZvcm5pYUV2ZW50IH0gZnJvbSBcIi4vQ2FsaWZvcm5pYUdlbmVyYXRlZFwiO1xyXG5pbXBvcnQgeyBTZWxlY3Rpb25Nb2RlLCBSZWFkeVN0YXRlLCBFZGl0Vmlld01vZGUgfSBmcm9tIFwiLi9DbGllbnRTdGF0ZVwiO1xyXG5pbXBvcnQgeyBDb250ZW50QXRvbVR5cGUgfSBmcm9tIFwiLi4vVHlwZXdyaXRlci9Db250ZW50QXRvbVR5cGVcIjtcclxuaW1wb3J0IHsgUHJvcGVydHlCYXJWTSB9IGZyb20gXCIuLi9WaWV3TW9kZWxzL1Byb3BlcnR5QmFyVk1cIjtcclxuaW1wb3J0IHsgVkVSWV9ISUdIX1ZBTFVFIH0gZnJvbSBcIi4vUHJvcGVydHlCYXJcIjtcclxuXHJcbmxldCBjdXJyZW50QXBwOiBDYWxpZm9ybmlhQXBwO1xyXG5sZXQgY3VycmVudFBhZ2VQcmV2aWV3OiBQYWdlUHJldmlldztcclxuXHJcbmV4cG9ydCBjb25zdCBISUdITElHSFRfQkFDS0dST1VORF9DT0xPUl9TVFJJTkc6IHN0cmluZyA9IFwicmdiKDIzMywyMzMsMjMzKVwiO1xyXG5leHBvcnQgY29uc3QgTUFOVUFMTFlfSElHSExJR0hUX0JBQ0tHUk9VTkRfQ09MT1JfU1RSSU5HOiBzdHJpbmcgPSBcInJnYigyMjIsMjIyLDIyMilcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBQYWdlUHJldmlldyB7XHJcbiAgICBwdWJsaWMgdmlld01vZGVsOiBQYWdlUHJldmlld1ZNO1xyXG4gICAgLy8gdmlydHVhbCBzdHlsZSBzaGVldHNcclxuICAgIHB1YmxpYyBkeW5hbWljQ2xpZW50R3JpZEJyZWFrcG9pbnRzOiBudW1iZXJbXSA9IFtdO1xyXG4gICAgcHVibGljIHZpcnR1YWxTdHlsZUluZGV4OiB7IFtrZXk6IG51bWJlcl06IG51bWJlciB9W10gPSBbXTtcclxuICAgIHB1YmxpYyB2aXJ0dWFsUHNldWRvU3R5bGVJbmRleDogeyBba2V5OiBzdHJpbmddOiBudW1iZXIgfVtdID0gW107XHJcbiAgICBwcml2YXRlIF92aXNpYmxlTGF5b3V0QXRvbURvbU5vZGVSZWZlcmVuY2VzOiBIVE1MRWxlbWVudFtdID0gW107XHJcbiAgICBwcml2YXRlIF9hY3RpdmVWaWV3TGF5b3V0QXRvbURvbU5vZGVSZWZlcmVuY2VzOiB7IFtrZXk6IHN0cmluZ106IEhUTUxFbGVtZW50IH0gPSB7fTtcclxuICAgIHByaXZhdGUgX3Zpc2libGVMYXlvdXRBdG9tS2V5czogc3RyaW5nW10gPSBbXTtcclxuICAgIHByaXZhdGUgX21vc3RVcHBlclZpc2libGVMYXlvdXRBdG9tSWQ6IG51bWJlciA9IDA7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY2FsaWZvcm5pYUFwcEFyZzogQ2FsaWZvcm5pYUFwcCkge1xyXG4gICAgICAgIGN1cnJlbnRQYWdlUHJldmlldyA9IHRoaXM7XHJcbiAgICAgICAgY3VycmVudEFwcCA9IGNhbGlmb3JuaWFBcHBBcmc7XHJcbiAgICAgICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgUGFnZVByZXZpZXdWTSh0aGlzKTtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBnZXQgdmlzaWJsZUxheW91dEF0b21Eb21Ob2RlUmVmZXJlbmNlcygpOiBIVE1MRWxlbWVudFtdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZUxheW91dEF0b21Eb21Ob2RlUmVmZXJlbmNlcztcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGdldCB2aXNpYmxlTGF5b3V0QXRvbUtleXMoKTogc3RyaW5nW10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlTGF5b3V0QXRvbUtleXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgZ2V0IGFjdGl2ZVZpZXdMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXMoKTogeyBba2V5OiBzdHJpbmddOiBIVE1MRWxlbWVudCB9IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlVmlld0xheW91dEF0b21Eb21Ob2RlUmVmZXJlbmNlcztcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGdldCBtb3N0VXBwZXJWaXNpYmxlTGF5b3V0QXRvbUlkKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vc3RVcHBlclZpc2libGVMYXlvdXRBdG9tSWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJQcmV2aWV3QXJlYSA9ICgpOiBWTm9kZSA9PiB7XHJcbiAgICAgICAgbGV0IHByZXZpZXdBcmVhU3R5bGVzID0ge1xyXG4gICAgICAgICAgICBcImZsZXhcIjogY3VycmVudEFwcC5zdGF0ZS5lZGl0Vmlld01vZGUgPT09IEVkaXRWaWV3TW9kZS5TaWRlYmFyT25seSA/IFwiMCAwIDFweFwiICA6IFwiMSAxIDc3N3B4XCIsIC8vID4xcHggZm9yIElFMTFcclxuICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiZmxleFwiLFxyXG4gICAgICAgICAgICBcImZsZXgtZmxvd1wiOiBcImNvbHVtbiBub3dyYXBcIixcclxuICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjUzM3B4XCIsXHJcbiAgICAgICAgICAgIFwibWF4LXdpZHRoXCI6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICAvL1wibWluLXdpZHRoXCI6IGN1cnJlbnRBcHAuc3RhdGUuZWRpdFZpZXdNb2RlID09PSBFZGl0Vmlld01vZGUuU2lkZWJhck9ubHkgPyB1bmRlZmluZWQgOiBcIjEwMHB4XCIsIC8vIHByZXZlbnRzIGhpZGluZyBvZiBwcmV2aWV3IGFyZWEgd2hlbiB1c2luZyBicm93c2VyIHpvb20gb3IgcmVzaXppbmcgVE9ETyBtZXNzZXMgd2l0aCB0aGUgd2lkdGggY29tcHV0YXRpb24gZnJvbSBmbGV4Li4uXHJcbiAgICAgICAgICAgIFwiaGVpZ2h0XCI6IFwiMTAwJVwiLCAvLyAxMDAlIGZvciBpUGFkLFxyXG4gICAgICAgICAgICBcIm92ZXJmbG93XCI6IFwidmlzaWJsZVwiIC8vIGZvciB0b3AgbmF2IFRPRE9cclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBpc1JSQnV0dG9uRW5hYmxlZDogYm9vbGVhbiA9IGN1cnJlbnRBcHAuc3RhdGUubGFzdENhbGlmb3JuaWFFdmVudERhdGEubGVuZ3RoID4gMDtcclxuICAgICAgICByZXR1cm4gPGRpdiBrZXk9XCIwXCIgc3R5bGVzPXtwcmV2aWV3QXJlYVN0eWxlc30+XHJcbiAgICAgICAgICAgIHtjdXJyZW50QXBwLnN0YXRlLmlzSGlkZVVzZXJJbnRlcmZhY2UgPyB1bmRlZmluZWQgOiBjdXJyZW50UGFnZVByZXZpZXcucmVuZGVyTmF2aWdhdGlvbigpfVxyXG4gICAgICAgICAgICB7Y3VycmVudEFwcC5zdGF0ZS5lZGl0Vmlld01vZGUgPT09IEVkaXRWaWV3TW9kZS5TaWRlYmFyT25seSA/IHVuZGVmaW5lZCA6IGN1cnJlbnRQYWdlUHJldmlldy5yZW5kZXJQYWdlUHJldmlld0hvbGRlcigpfVxyXG4gICAgICAgICAgICB7Y3VycmVudEFwcC5zdGF0ZS5pc0hpZGVVc2VySW50ZXJmYWNlID8gPGRpdiBrZXk9XCIyXCIgc3R5bGVzPXt7IFwicG9zaXRpb25cIjogXCJhYnNvbHV0ZVwiLCBcImxlZnRcIjogXCIwXCIsIFwidG9wXCI6IFwiMFwiLCBcInotaW5kZXhcIjogVUlfWl9JTkRFWC50b1N0cmluZygpLCBcImRpc3BsYXlcIjogXCJmbGV4XCIsIFwiZmxleC1mbG93XCI6IFwiY29sdW1uIG5vd3JhcFwiIH19PlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgb25jbGljaz17Y3VycmVudFBhZ2VQcmV2aWV3LnByZXZpZXdDbGlja0hhbmRsZXJ9PiYjODIzMDs8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYlwiIG9uY2xpY2s9e2N1cnJlbnRBcHAucHJvcGVydHlCYXJzWzBdLmluc2VydExheW91dFJvd0ludG9WaWV3Q2xpY2tIYW5kbGVyfT4rKFIpPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICB7aXNSUkJ1dHRvbkVuYWJsZWQgPyA8YnV0dG9uIGtleT1cImNcIiBvbmNsaWNrPXtjdXJyZW50UGFnZVByZXZpZXcucmVwZWF0Q2xpY2tIYW5kbGVyfSBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIiwgXCJ3aWR0aFwiOiBcImF1dG9cIiB9fT5SUjwvYnV0dG9uPiA6XHJcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJjMFwiIG9uY2xpY2s9e2N1cnJlbnRQYWdlUHJldmlldy5yZXBlYXRDbGlja0hhbmRsZXJ9IHN0eWxlcz17eyBcImZsZXhcIjogXCIwIDAgYXV0b1wiLCBcIndpZHRoXCI6IFwiYXV0b1wiIH19PlJSPC9idXR0b24+fVxyXG4gICAgICAgICAgICA8L2Rpdj4gOiB1bmRlZmluZWR9XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyTmF2aWdhdGlvbiA9ICgpOiBWTm9kZSA9PiB7XHJcbiAgICAgICAgbGV0IG5hdmlnYXRpb25TdHlsZXMgPSB7XHJcbiAgICAgICAgICAgIFwiZmxleFwiOiBgMCAwICR7Y3VycmVudEFwcC5uYXZpZ2F0aW9uSGVpZ3RoUHh9cHhgLFxyXG4gICAgICAgICAgICBcInBvc2l0aW9uXCI6IFwicmVsYXRpdmVcIiwgLy8gZm9yIGxvYWRpbmcgaW5kaWNhdG9yIHBvc2l0aW9uaW5nLFxyXG4gICAgICAgICAgICBcImRpc3BsYXlcIjogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgIFwiZmxleC1mbG93XCI6IFwicm93IG5vd3JhcFwiLFxyXG4gICAgICAgICAgICBcInotaW5kZXhcIjogXCIzXCJcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBsb2FkaW5nSW5kaWNhdG9yU3R5bGVzID0ge1xyXG4gICAgICAgICAgICBcInBvc2l0aW9uXCI6IFwiYWJzb2x1dGVcIixcclxuICAgICAgICAgICAgXCJyaWdodFwiOiBcIjBweFwiLFxyXG4gICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogXCJyZWRcIixcclxuICAgICAgICAgICAgXCJjb2xvclwiOiBcIndoaXRlXCIsXHJcbiAgICAgICAgICAgIFwiYm9yZGVyXCI6IFwic29saWQgYmxhY2sgMXB4XCJcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBuYXZpZ2F0aW9uQnV0dG9uU3R5bGVzID0ge1xyXG4gICAgICAgICAgICBcImZsZXhcIjogXCIwIDAgYXV0b1wiXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgaXNSUkJ1dHRvbkVuYWJsZWQ6IGJvb2xlYW4gPSBjdXJyZW50QXBwLnN0YXRlLmxhc3RDYWxpZm9ybmlhRXZlbnREYXRhLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgLy8gY2FuIGJlIHVzZWQgYXMgVEVTVCBmb3IgZGF0YWJhc2UgbW9kZWwgKGNyZWF0ZS9kZWxldGUpIGFuZCBURVNUIGRpc3BsYXkgd2l0aCBubyBlcnJvcnMgYW5kIFRFU1QgZGlzcGxheSBhbGwgZGF0YSBhbmQgVEVTVCBkYXRhIHRyYW5zbWl0dGVkIGFuZCBzbyBvblxyXG4gICAgICAgIHJldHVybiA8ZGl2IGtleT1cIjBcIiBzdHlsZXM9e25hdmlnYXRpb25TdHlsZXN9PlxyXG4gICAgICAgICAgICB7Y3VycmVudEFwcC5pc0FqYXhSZXF1ZXN0UnVubmluZyA/IDxwIGtleT1cInpcIiBzdHlsZXM9e2xvYWRpbmdJbmRpY2F0b3JTdHlsZXN9PkxvYWRpbmcuLi48L3A+IDogdW5kZWZpbmVkfVxyXG4gICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiBvbmNsaWNrPXtjdXJyZW50UGFnZVByZXZpZXcucHJldmlld0NsaWNrSGFuZGxlcn0gc3R5bGVzPXt7IFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsIFwid2lkdGhcIjogXCJhdXRvXCIgfX0+UHJldmlldzwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8YnV0dG9uIGtleT1cImJcIiBlaWQ9e0VkaXRWaWV3TW9kZS5QYWdlUHJldmlld09ubHkudG9TdHJpbmcoKX0gb25jbGljaz17Y3VycmVudFBhZ2VQcmV2aWV3LmNoYW5nZUVkaXRNb2RlQ2xpY2tIYW5kbGVyfSBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIiwgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IGN1cnJlbnRBcHAuc3RhdGUuZWRpdFZpZXdNb2RlID09PSBFZGl0Vmlld01vZGUuUGFnZVByZXZpZXdPbmx5ID8gXCJyZWRcIiA6IHVuZGVmaW5lZCB9fT5QPC9idXR0b24+XHJcbiAgICAgICAgICAgIDxidXR0b24ga2V5PVwiY1wiIGVpZD17RWRpdFZpZXdNb2RlLlNpZGViYXJPbmx5LnRvU3RyaW5nKCl9IG9uY2xpY2s9e2N1cnJlbnRQYWdlUHJldmlldy5jaGFuZ2VFZGl0TW9kZUNsaWNrSGFuZGxlcn0gc3R5bGVzPXt7IFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBjdXJyZW50QXBwLnN0YXRlLmVkaXRWaWV3TW9kZSA9PT0gRWRpdFZpZXdNb2RlLlNpZGViYXJPbmx5ID8gXCJyZWRcIiA6IHVuZGVmaW5lZCB9fT5TPC9idXR0b24+XHJcbiAgICAgICAgICAgIDxidXR0b24ga2V5PVwiZFwiIG9uY2xpY2s9e2N1cnJlbnRQYWdlUHJldmlldy50b2dnbGVTaWRlQmFyQ291bnR9IGNpZD1cIjFcIiBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIiB9fT54MTwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8YnV0dG9uIGtleT1cImVcIiBvbmNsaWNrPXtjdXJyZW50UGFnZVByZXZpZXcudG9nZ2xlU2lkZUJhckNvdW50fSBjaWQ9XCIyXCIgc3R5bGVzPXt7IFwiZmxleFwiOiBcIjAgMCBhdXRvXCIgfX0+eDI8L2J1dHRvbj5cclxuICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJmXCIgb25jbGljaz17Y3VycmVudFBhZ2VQcmV2aWV3LnRvZ2dsZVNpZGVCYXJDb3VudH0gY2lkPVwiNFwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIwIDAgYXV0b1wiIH19Png0PC9idXR0b24+XHJcbiAgICAgICAgICAgIHtjdXJyZW50UGFnZVByZXZpZXcucmVuZGVyUmVzcG9uc2l2ZURldmljZVNlbGVjdG9ycygpfVxyXG4gICAgICAgICAgICA8YnV0dG9uIGtleT1cImhcIiBvbmNsaWNrPXtjdXJyZW50UGFnZVByZXZpZXcuY2hhbmdlU2VsZWN0aW9uTW9kZUNsaWNrSGFuZGxlcn0gc3R5bGVzPXt7IFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBjdXJyZW50QXBwLnN0YXRlLmN1cnJlbnRTZWxlY3Rpb25Nb2RlID09PSBTZWxlY3Rpb25Nb2RlLkNvbnRlbnQgPyBcInJlZFwiIDogdW5kZWZpbmVkLCBcImNvbG9yXCI6IGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFNlbGVjdGlvbk1vZGUgPT09IFNlbGVjdGlvbk1vZGUuU3R5bGVzID8gXCJyZWRcIiA6IHVuZGVmaW5lZCB9fT57U2VsZWN0aW9uTW9kZVtjdXJyZW50QXBwLnN0YXRlLmN1cnJlbnRTZWxlY3Rpb25Nb2RlXX08L2J1dHRvbj5cclxuICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJpXCIgb25jbGljaz17Y3VycmVudFBhZ2VQcmV2aWV3LnB1Ymxpc2hDbGlja0hhbmRsZXJ9IHN0eWxlcz17eyBcImZsZXhcIjogXCIwIDAgYXV0b1wiLCBcIndpZHRoXCI6IFwiYXV0b1wiIH19PlNhdmU8L2J1dHRvbj5cclxuICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJqXCIgb25jbGljaz17Y3VycmVudFBhZ2VQcmV2aWV3LnB1Ymxpc2hBbmRPcGVuQ2xpY2tIYW5kbGVyfSBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIiwgXCJ3aWR0aFwiOiBcImF1dG9cIiB9fT5TYXZlJk9wZW48L2J1dHRvbj5cclxuICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJrXCIgb25jbGljaz17Y3VycmVudFBhZ2VQcmV2aWV3LnJlZnJlc2hDbGlja0hhbmRsZXJ9IHN0eWxlcz17eyBcImZsZXhcIjogXCIwIDAgYXV0b1wiLCBcIndpZHRoXCI6IFwiYXV0b1wiIH19PkpBWDwvYnV0dG9uPlxyXG4gICAgICAgICAgICB7aXNSUkJ1dHRvbkVuYWJsZWQgPyA8YnV0dG9uIGtleT1cImxcIiBvbmNsaWNrPXtjdXJyZW50UGFnZVByZXZpZXcucmVwZWF0Q2xpY2tIYW5kbGVyfSBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIiwgXCJ3aWR0aFwiOiBcImF1dG9cIiB9fT5SUjwvYnV0dG9uPiA6XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGRpc2FibGVkIGtleT1cImwwXCIgb25jbGljaz17Y3VycmVudFBhZ2VQcmV2aWV3LnJlcGVhdENsaWNrSGFuZGxlcn0gc3R5bGVzPXt7IFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsIFwid2lkdGhcIjogXCJhdXRvXCIgfX0+UlI8L2J1dHRvbj59XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgdG9nZ2xlU2lkZUJhckNvdW50ID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCBzaWRlYmFyQ291bnQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImNpZFwiKTtcclxuICAgICAgICBpZiAoc2lkZWJhckNvdW50ID4gMCAmJiBzaWRlYmFyQ291bnQgPD0gNCkge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLnZpc2libGVQcm9wZXJ0eUJhck1heENvdW50ID0gc2lkZWJhckNvdW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pOyAvLyBUT0RPXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcHVibGlzaENsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHsgLy8gVE9ETyBvcHRpbWl6ZTogMSBldmVudCBoYW5kbGVyLCBjb250cm9sbGVkIGJ5IGh0bWxcclxuICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcucHVibGlzaChmYWxzZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBwdWJsaXNoQW5kT3BlbkNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcucHVibGlzaCh0cnVlKTtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBwdWJsaXNoID0gKGlzT3BlbjogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgIGxldCBjdXJyZW50Q2FsaWZvcm5pYVZpZXc6IENhbGlmb3JuaWFWaWV3ID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFWaWV3cy5maW5kKHYgPT4gdi5DYWxpZm9ybmlhVmlld0lkID09IGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwuYWN0aXZlQ2FsaWZvcm5pYVZpZXdJZCkgYXMgQ2FsaWZvcm5pYVZpZXc7XHJcbiAgICAgICAgaWYgKGlzT3Blbikge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuUHVibGlzaEFjdGlvbihjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ2FsaWZvcm5pYVByb2plY3RJZCwgY3VycmVudENhbGlmb3JuaWFWaWV3Lk5hbWUpLmRvbmUoKHJlc3BvbnNlOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24od2luZG93LmxvY2F0aW9uLm9yaWdpbiArIGAvY2FsaWZvcm5pYS9wdWIvJHtjdXJyZW50Q2FsaWZvcm5pYVZpZXcuTmFtZX1gKTsgLy8gVE9ETyBoYXJkY29kZWQgbGluayAvLyBUT0RPIHNlY3VyaXR5IGF1ZGl0XHJcbiAgICAgICAgICAgIH0pLmZhaWwoKHJlcTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLlB1Ymxpc2hBY3Rpb24oY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFQcm9qZWN0SWQsIGN1cnJlbnRDYWxpZm9ybmlhVmlldy5OYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZWZyZXNoQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGlmICghY3VycmVudEFwcC5zdGF0ZS5pc0pheE9uKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gaXMgdGhpcyBsb2FkIGFzeW5jPyBUT0RPIHNlY3VyaXR5IGF1ZGl0IFRPRE8gbG9jYWxpemF0aW9uIFRPRE8gbG9hZCBvZiBzb21lIHN1YiBkZXBlbmRlbnQgZmlsZXMgZmFpbHMgVE9ETyBjb2RlIGR1cGxpY2F0aW9uIChhbG1vc3QgZXhjZXB0IHJvb3QgcGF0aCkgd2l0aCBwdWJsaXNoIGxheW91dFxyXG4gICAgICAgICAgICAvLyBUT0RPIHNob3dQcm9jZXNzaW5nTWVzc2FnZXM6IGZhbHNlLFxyXG4gICAgICAgICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXSwgc2NyaXB0O1xyXG4gICAgICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xyXG4gICAgICAgICAgICBzY3JpcHQudHlwZSA9IFwidGV4dC94LW1hdGhqYXgtY29uZmlnXCI7XHJcbiAgICAgICAgICAgIHNjcmlwdC50ZXh0ID1cclxuICAgICAgICAgICAgICAgIFwiTWF0aEpheC5IdWIuQ29uZmlnKHtcXG5cIiArXHJcbiAgICAgICAgICAgICAgICBcIiAgcm9vdDogXFxcIi4uL3RoaXJkX3BhcnR5L21hdGhqYXhcXFwiLFxcblwiICtcclxuICAgICAgICAgICAgICAgIFwiICBleHRlbnNpb25zOiBbXFxcInRleDJqYXguanNcXFwiXSxcXG5cIiArXHJcbiAgICAgICAgICAgICAgICBcIiAgamF4OiBbXFxcImlucHV0L1RlWFxcXCIsIFxcXCJvdXRwdXQvSFRNTC1DU1NcXFwiXSxcXG5cIiArXHJcbiAgICAgICAgICAgICAgICAvL1wiICBza2lwU3RhcnR1cFR5cGVzZXQ6IHRydWUsXFxuXCIgK1xyXG4gICAgICAgICAgICAgICAgLy9cIiAgY29uZmlnOiBbXFxcIlRlWC1BTVNfSFRNTC5qc1xcXCJdLFxcblwiICsgVE9ETyB0aGlzIHNlZW1zIG5vdCB0byBiZSByZXF1aXJlZCBvciBsb2FkZWQgYnkgZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgXCIgIHRleDJqYXg6IHsgaW5saW5lTWF0aDogW1snJCcsJyQnXSwgWydcXFxcXFxcXCgnLCdcXFxcXFxcXCknXV0sIHNraXBUYWdzOiBbXFxcInNjcmlwdFxcXCIsXFxcIm5vc2NyaXB0XFxcIixcXFwic3R5bGVcXFwiLFxcXCJ0ZXh0YXJlYVxcXCIsXFxcInByZVxcXCIsXFxcImNvZGVcXFwiLFxcXCJpbnB1dFxcXCJdLCBwcm9jZXNzRXNjYXBlczogdHJ1ZX0sXFxuXCIgK1xyXG4gICAgICAgICAgICAgICAgXCIgIFRlWDogeyBleHRlbnNpb25zOiBbXFxcIkFNU21hdGguanNcXFwiLCBcXFwiQU1Tc3ltYm9scy5qc1xcXCJdLCBlcXVhdGlvbk51bWJlcnM6IHsgYXV0b051bWJlcjogXFxcImFsbFxcXCIgfSB9LCBzaG93UHJvY2Vzc2luZ01lc3NhZ2VzOiB0cnVlLCBtZXNzYWdlU3R5bGU6XFxcIm5vcm1hbFxcXCIsXFxuXCIgK1xyXG4gICAgICAgICAgICAgICAgXCIgIFxcXCJIVE1MLUNTU1xcXCI6IHsgYXZhaWxhYmxlRm9udHM6IFtcXFwiVGVYXFxcIl0sIHByZWZlcnJlZEZvbnQ6IFxcXCJUZVhcXFwiLCBpbWFnZUZvbnQ6IG51bGwgfVxcblwiICsgLypUT0RPIGNvbmNlcHQgZm9yIGxpbmVicmVha3M6IHthdXRvbWF0aWM6IHRydWUsIHdpZHRoOiBcXFwiY29udGFpbmVyXFxcIn0qL1xyXG4gICAgICAgICAgICAgICAgXCJ9KTtcIjtcclxuICAgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xyXG4gICAgICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xyXG4gICAgICAgICAgICBzY3JpcHQudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XHJcbiAgICAgICAgICAgIC8vc2NyaXB0LnNyYyA9IFwiLi4vdGhpcmRfcGFydHkvbWF0aGpheC9NYXRoSmF4LmpzP2RlbGF5U3RhcnR1cFVudGlsPWNvbmZpZ3VyZWRcIjtcclxuICAgICAgICAgICAgc2NyaXB0LnNyYyA9IFwiLi4vdGhpcmRfcGFydHkvbWF0aGpheC9NYXRoSmF4LmpzXCI7XHJcbiAgICAgICAgICAgIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7IGN1cnJlbnRBcHAuc3RhdGUuaXNKYXhPbiA9IHRydWU7IH07XHJcbiAgICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuICAgICAgICAgICAgLy9NYXRoSmF4Lkh1Yi5Db25maWd1cmVkKCk7IC8vIFRPRE8gZG93bmxvYWQgKyBhY3RpdmF0ZSBvbiB1c2VyIHJlcXVlc3QgLyB3aGVuIGxhdGV4IGVsZW1lbnRzIGFyZSB0aGVyZVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgTWF0aEpheC5IdWIuUXVldWUoW1wicmVzZXRFcXVhdGlvbk51bWJlcnNcIiwgTWF0aEpheC5JbnB1dEpheC5UZVhdKTtcclxuICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnJlc2V0RXF1YXRpb25OdW1iZXJzV2hlbk1vZGlmeWluZyh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZXBlYXRDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUubGFzdENvbW1hbmQgPT09IENhbGlmb3JuaWFFdmVudC5DcmVhdGVMYXlvdXRCb3hGb3JCb3hPclJvdykge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuQ3JlYXRlTGF5b3V0Qm94Rm9yQm94T3JSb3dKc29uKGN1cnJlbnRBcHAuc3RhdGUubGFzdENhbGlmb3JuaWFFdmVudERhdGFbMF0gYXMgbnVtYmVyLCBjdXJyZW50QXBwLnN0YXRlLmxhc3RDYWxpZm9ybmlhRXZlbnREYXRhWzFdIGFzIG51bWJlcikuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjdXJyZW50QXBwLnN0YXRlLmxhc3RDb21tYW5kID09PSBDYWxpZm9ybmlhRXZlbnQuQ3JlYXRlTGF5b3V0Um93Rm9yVmlldykge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuQ3JlYXRlTGF5b3V0Um93Rm9yVmlld0pzb24oY3VycmVudEFwcC5zdGF0ZS5sYXN0Q2FsaWZvcm5pYUV2ZW50RGF0YVswXSBhcyBudW1iZXIsIGN1cnJlbnRBcHAuc3RhdGUubGFzdENhbGlmb3JuaWFFdmVudERhdGFbMV0gYXMgbnVtYmVyKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlc2V0RXF1YXRpb25OdW1iZXJzV2hlbk1vZGlmeWluZyA9IChpc1JlcHJvY2VzczogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLmlzSmF4T24pIHtcclxuICAgICAgICAgICAgLy9NYXRoSmF4Lkh1Yi5RdWV1ZShbXCJyZXNldEVxdWF0aW9uTnVtYmVyc1wiLCBNYXRoSmF4LklucHV0SmF4LlRlWF0pOyB0aHJvd3MgZXJyb3JzID0+IG9uIG1hbnVhbCByZXF1ZXN0XHJcbiAgICAgICAgICAgIGlmIChpc1JlcHJvY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgTWF0aEpheC5IdWIuUXVldWUoW1wiUHJlUHJvY2Vzc1wiLCBNYXRoSmF4Lkh1Yl0pOyAvLyBUT0RPIG9ubHkgd2hlbiBjaGFuZ2VkIHNvbWV0aGluZyB3aXRoIGxhYmVsIGFmdGVyIHNvbWUgZGVsYXlcclxuICAgICAgICAgICAgICAgIE1hdGhKYXguSHViLlF1ZXVlKFtcIlJlcHJvY2Vzc1wiLCBNYXRoSmF4Lkh1Yl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcHJldmlld0NsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmlzSGlkZVVzZXJJbnRlcmZhY2UgPSAhY3VycmVudEFwcC5zdGF0ZS5pc0hpZGVVc2VySW50ZXJmYWNlO1xyXG4gICAgICAgIGN1cnJlbnRBcHAucHJvamVjdG9yLnJlbmRlck5vdygpOyAvLyBUT0RPIHdvcmthcm91bmQgMiByZW5kZXJzIGZvciBzcGFjZSBjYWxjdWxhdGlvbiA9PiB1c2UgY2xpZW50IHdpZHRoIGluc3RlYWRcclxuICAgICAgICBjdXJyZW50QXBwLnJlc2l6ZUNoYW5nZWRIYW5kbGVyKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjaGFuZ2VFZGl0TW9kZUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgc2VsZWN0ZWRFZGl0Vmlld01vZGU6IEVkaXRWaWV3TW9kZSA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImVpZFwiKTtcclxuICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5lZGl0Vmlld01vZGUgPT09IHNlbGVjdGVkRWRpdFZpZXdNb2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLmVkaXRWaWV3TW9kZSA9PT0gRWRpdFZpZXdNb2RlLkRlZmF1bHQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuZWRpdFZpZXdNb2RlID0gRWRpdFZpZXdNb2RlLkRlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnByb2plY3Rvci5yZW5kZXJOb3coKTsgLy8gVE9ETyB3b3JrYXJvdW5kIDIgcmVuZGVycyBmb3Igc3BhY2UgY2FsY3VsYXRpb24gPT4gdXNlIGNsaWVudCB3aWR0aCBpbnN0ZWFkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuZWRpdFZpZXdNb2RlID0gc2VsZWN0ZWRFZGl0Vmlld01vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRBcHAucmVzaXplQ2hhbmdlZEhhbmRsZXIoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNoYW5nZVNlbGVjdGlvbk1vZGVDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50U2VsZWN0aW9uTW9kZSA9IGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFNlbGVjdGlvbk1vZGUgPT09IFNlbGVjdGlvbk1vZGUuQ29udGVudCA/IFNlbGVjdGlvbk1vZGUuU3R5bGVzIDogU2VsZWN0aW9uTW9kZS5Db250ZW50O1xyXG4gICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy5yZXNldENvbnRlbnRBdG9tRWRpdE1vZGUoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlbmRlclJlc3BvbnNpdmVEZXZpY2VTZWxlY3RvcnMgPSAoKTogVk5vZGUgPT4ge1xyXG4gICAgICAgIGxldCByZXNwb25zaXZlR3JvdXBTdHlsZXMgPSB7XHJcbiAgICAgICAgICAgIFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsXHJcbiAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcImZsZXhcIixcclxuICAgICAgICAgICAgXCJmbGV4LWZsb3dcIjogXCJyb3cgbm93cmFwXCJcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiA8ZGl2IGtleT1cIjFcIiBzdHlsZXM9e3Jlc3BvbnNpdmVHcm91cFN0eWxlc30+XHJcbiAgICAgICAgICAgIHsoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzICE9PSB1bmRlZmluZWQpID8gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzLm1hcChyID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChyLldpZHRoVGhyZXNob2xkIDwgMCkgeyAvLyByZXNwb25zaXZlIGRldmljZSBcIk5vbmVcIiBjYW4gbm90IGJlIHVzZWQgYXMgb3ZlcnJpZGVcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNpdmVCdXR0b25TdHlsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogci5SZXNwb25zaXZlRGV2aWNlSWQgPT0gY3VycmVudEFwcC5zdGF0ZS5vdmVycmlkZVJlc3BvbnNpdmVEZXZpY2VJZCA/IFwicmVkXCIgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiAoci5SZXNwb25zaXZlRGV2aWNlSWQgPT0gY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50UmVzcG9uc2l2ZURldmljZUlkICYmIGN1cnJlbnRBcHAuc3RhdGUub3ZlcnJpZGVSZXNwb25zaXZlRGV2aWNlSWQgPT0gMCkgPyBcInJlZFwiIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNpdmVEZXZpY2VJZFN0cmluZzogc3RyaW5nID0gci5SZXNwb25zaXZlRGV2aWNlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiA8YnV0dG9uIGtleT17cmVzcG9uc2l2ZURldmljZUlkU3RyaW5nfSByaWQ9e3Jlc3BvbnNpdmVEZXZpY2VJZFN0cmluZ30gb25jbGljaz17Y3VycmVudFBhZ2VQcmV2aWV3LnNlbGVjdFJlc3BvbnNpdmVEZXZpY2VDbGlja0hhbmRsZXJ9IHN0eWxlcz17cmVzcG9uc2l2ZUJ1dHRvblN0eWxlc30+e3IuTmFtZVNob3J0fXsvKlRPRE8gcmVlbmFibGUsIHRha2VzIG11Y2ggc3BhY2UgKG1pbjp7ci5XaWR0aFRocmVzaG9sZH1weCkqL308L2J1dHRvbj4gYXMgVk5vZGU7XHJcbiAgICAgICAgICAgIH0pIDogdW5kZWZpbmVkfVxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNlbGVjdFJlc3BvbnNpdmVEZXZpY2VDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IHNlbGVjdGVkSWQgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJyaWRcIik7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUub3ZlcnJpZGVSZXNwb25zaXZlRGV2aWNlSWQgPT0gc2VsZWN0ZWRJZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLm92ZXJyaWRlUmVzcG9uc2l2ZURldmljZUlkID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUub3ZlcnJpZGVSZXNwb25zaXZlRGV2aWNlSWQgPSBzZWxlY3RlZElkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudXBkYXRlUGFnZVByZXZpZXdEaW1lbnNpb25zKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJQYWdlUHJldmlld0hvbGRlciA9ICgpOiBWTm9kZSA9PiB7XHJcbiAgICAgICAgLy8gcGFnZSBwcmV2aWV3IHNpemUgZGVwZW5kcyBvbiBjdXJyZW50IHByZXZpZXcgYnJlYWtwb2ludFxyXG4gICAgICAgIGxldCBwYWdlUHJldmlld0hvbGRlclN0eWxlcyA9IHsgLy8gaW5zaWRlIGZsZXgtY29sdW1uLW5vd3JhcFxyXG4gICAgICAgICAgICBcImZsZXhcIjogY3VycmVudEFwcC5zdGF0ZS5pc0hpZGVVc2VySW50ZXJmYWNlID8gXCIxIDEgYXV0b1wiIDogXCIxIDEgMTAwJVwiLCAvLyAxcHggZm9yIElFMTEgPT4gMTAwJSBmb3IgaVBhZFxyXG4gICAgICAgICAgICBcIm1hcmdpblwiOiAoY3VycmVudEFwcC5zdGF0ZS5pc0hpZGVVc2VySW50ZXJmYWNlIHx8IGN1cnJlbnRBcHAuc3RhdGUuZWRpdFZpZXdNb2RlID09PSBFZGl0Vmlld01vZGUuUGFnZVByZXZpZXdPbmx5KSA/IC8qVE9ETyovXCIwXCIgOiBgMCAke2N1cnJlbnRBcHAuc3RhdGUudGFyZ2V0UGFnZVByZXZpZXdIb2xkZXJNYXJnaW5QeH1weGAsXHJcbiAgICAgICAgICAgIFwicG9zaXRpb25cIjogXCJyZWxhdGl2ZVwiLCAvLyBUT0RPIGRvY3VtZW50OiBmb3IgZml4ZWQgY29udGVudFxyXG4gICAgICAgICAgICBcImhlaWdodFwiOiBcIjEwMCVcIiwgLy8gMTAwJSBmb3IgaVBhZFxyXG4gICAgICAgICAgICBcIm1heC1oZWlnaHRcIjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgIFwib3ZlcmZsb3dcIjogXCJhdXRvXCJcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBzY3JvbGxlZFBhZ2VQcmV2aWV3ID0ge1xyXG4gICAgICAgICAgICBcImRpc3BsYXlcIjogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgIFwiZmxleC1mbG93XCI6IFwiY29sdW1uIG5vd3JhcFwiXHJcbiAgICAgICAgICAgIC8vXCJvdmVyZmxvd1wiOiBcImF1dG9cIiwgLy8gcGFyZW50IGVsZW1lbnQgb2YgcGFnZSBwcmV2aWV3XHJcbiAgICAgICAgICAgIC8qXCJoZWlnaHRcIjogXCIxMDAlXCIsKi8gLy8gVE9ETyAxMDAlIGZvciBpUGFkIGJ1dCBwcm9ibGVtOiBkaXYgY2FuIGJlIHNtYWxsZXIgb3IgbGFyZ2VyIHRoYW4gMTAwJSwgMTAwJSBpcyB3cm9uZyBmb3IgdGhlIGNhc2Ugb2YgbGFyZ2VyIGRpdlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIDxkaXYga2V5PVwiMVwiXHJcbiAgICAgICAgICAgIHN0eWxlcz17cGFnZVByZXZpZXdIb2xkZXJTdHlsZXN9XHJcbiAgICAgICAgICAgIG9uc2Nyb2xsPXtjdXJyZW50UGFnZVByZXZpZXcucGFnZVByZXZpZXdIb2xkZXJTY3JvbGxIYW5kbGVyfVxyXG4gICAgICAgICAgICBhZnRlckNyZWF0ZT17Y3VycmVudFBhZ2VQcmV2aWV3LnBhZ2VQcmV2aWV3SG9sZGVyQWZ0ZXJDcmVhdGVIYW5kbGVyfVxyXG4gICAgICAgICAgICBhZnRlclVwZGF0ZT17Y3VycmVudFBhZ2VQcmV2aWV3LnBhZ2VQcmV2aWV3SG9sZGVyQWZ0ZXJVcGRhdGVIYW5kbGVyfT5cclxuICAgICAgICAgICAgPGRpdiBrZXk9XCJwMFwiIHN0eWxlcz17c2Nyb2xsZWRQYWdlUHJldmlld30+e2N1cnJlbnRQYWdlUHJldmlldy5yZW5kZXJQYWdlUHJldmlldygpfTwvZGl2PlxyXG4gICAgICAgICAgICB7Y3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC5maXhlZExheW91dFJvd3NQcm9qZWN0b3IucmVzdWx0cy5tYXAociA9PiByLnJlbmRlck1hcXVldHRlKCkpfVxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBwYWdlUHJldmlld0hvbGRlckFmdGVyQ3JlYXRlSGFuZGxlciA9IChlbGVtZW50OiBFbGVtZW50LCBwcm9qZWN0aW9uT3B0aW9uczogbWFxdWV0dGUuUHJvamVjdGlvbk9wdGlvbnMsIHZub2RlU2VsZWN0b3I6IHN0cmluZywgcHJvcGVydGllczogbWFxdWV0dGUuVk5vZGVQcm9wZXJ0aWVzLCBjaGlsZHJlbjogVk5vZGVbXSkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAucGFnZVByZXZpZXdIb2xkZXIgPSBlbGVtZW50IGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgIGN1cnJlbnRBcHAucmVzaXplQ2hhbmdlZEhhbmRsZXIoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBwYWdlUHJldmlld0hvbGRlckFmdGVyVXBkYXRlSGFuZGxlciA9IChlbGVtZW50OiBFbGVtZW50LCBwcm9qZWN0aW9uT3B0aW9uczogbWFxdWV0dGUuUHJvamVjdGlvbk9wdGlvbnMsIHZub2RlU2VsZWN0b3I6IHN0cmluZywgcHJvcGVydGllczogbWFxdWV0dGUuVk5vZGVQcm9wZXJ0aWVzLCBjaGlsZHJlbjogVk5vZGVbXSkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAucGFnZVByZXZpZXdIb2xkZXIgPSBlbGVtZW50IGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgIC8vIFRPRE8gdGhpcyBtZXRob2QgcnVucyB3YXkgdG9vIG9mdGVuIT9cclxuICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudXBkYXRlVmlzaWJsZUxheW91dEF0b21zKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgcGFnZVByZXZpZXdIb2xkZXJTY3JvbGxIYW5kbGVyID0gKGV2dDogVUlFdmVudCkgPT4ge1xyXG4gICAgICAgIC8vIFRPRE8gZGVsYXkgcmVjYWxjdWxhdGlvbiBzaW1pbGFyIHRvIHJlc2l6ZVxyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLnZpc2libGVQcm9wZXJ0eUJhck1heENvdW50ID4gMCkge1xyXG4gICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudXBkYXRlVmlzaWJsZUxheW91dEF0b21zKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc3luY1Njcm9sbFBvc2l0aW9uRnJvbUJveFRyZWUgPSAoKTogdm9pZCA9PiB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRBcHAucHJvcGVydHlCYXJWTXNbMF0uaXNTeW5jZWRXaXRoUGFnZVByZXZpZXcpIHtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRBcHAucGFnZVByZXZpZXdIb2xkZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXRpY09mZnNldFB4OiBudW1iZXIgPSBjdXJyZW50QXBwLm5hdmlnYXRpb25IZWlndGhQeDtcclxuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRMYXlvdXRBdG9tSWQ6IG51bWJlciA9IGN1cnJlbnRBcHAucHJvcGVydHlCYXJzWzBdLm1vc3RVcHBlclZpc2libGVMYXlvdXRBdG9tSWQ7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwicHJldmlldyBmcm9tIHRyZWUgZm9yIHRhcmdldCBsYXlvdXQgI1wiICsgdGFyZ2V0TGF5b3V0QXRvbUlkKTtcclxuICAgICAgICAgICAgICAgIGxldCBkb21Ob2RlT2ZUYXJnZXRMYXlvdXQ6IEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkID0gY3VycmVudFBhZ2VQcmV2aWV3Ll92aXNpYmxlTGF5b3V0QXRvbURvbU5vZGVSZWZlcmVuY2VzLmZpbmQociA9PiBwYXJzZUludEZyb21BdHRyaWJ1dGUociwgXCJhaWRcIiAvKlRPRE8gdXNlIGRpY3QqLykgPT0gdGFyZ2V0TGF5b3V0QXRvbUlkKTtcclxuICAgICAgICAgICAgICAgIGlmIChkb21Ob2RlT2ZUYXJnZXRMYXlvdXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGVPZlRhcmdldExheW91dCA9IGN1cnJlbnRQYWdlUHJldmlldy5fYWN0aXZlVmlld0xheW91dEF0b21Eb21Ob2RlUmVmZXJlbmNlc1t0YXJnZXRMYXlvdXRBdG9tSWRdIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucGFnZVByZXZpZXdIb2xkZXIuc2Nyb2xsVG9wID0gY3VycmVudEFwcC5wYWdlUHJldmlld0hvbGRlci5zY3JvbGxUb3AgKyAoZG9tTm9kZU9mVGFyZ2V0TGF5b3V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtIHN0YXRpY09mZnNldFB4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHVwZGF0ZVZpc2libGVMYXlvdXRBdG9tcyA9ICgpID0+IHtcclxuICAgICAgICAvLyBUT0RPIGNhbGxlZCB0b28gb2Z0ZW4gVE9ETyBpbml0aWFsIHJlbmRlclxyXG4gICAgICAgIGxldCBwYWdlUHJldmlld0hvbGRlcjogSFRNTERpdkVsZW1lbnQgPSBjdXJyZW50QXBwLnBhZ2VQcmV2aWV3SG9sZGVyIGFzIEhUTUxEaXZFbGVtZW50O1xyXG4gICAgICAgIC8vIHVwZGF0ZSB2aXNpYmxlIGxheW91dCBhdG9tIGRvbSBub2RlIHJlZmVyZW5jZXNcclxuICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcuX3Zpc2libGVMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXMgPSBbXTtcclxuICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcuX3Zpc2libGVMYXlvdXRBdG9tS2V5cyA9IFtdO1xyXG4gICAgICAgIGxldCBwcm9jZXNzZWRFbGVtZW50Q291bnQ6IG51bWJlciA9IDA7XHJcbiAgICAgICAgbGV0IG1vc3RVcHBlclZpc2libGVJbmRleDogbnVtYmVyID0gLTE7XHJcbiAgICAgICAgbGV0IG1vc3RVcHBlclZpc2libGVMYXlvdXRBdG9tSWQ6IG51bWJlciA9IDA7XHJcbiAgICAgICAgbGV0IG1vc3RVcHBlclZpc2libGVEZWx0YVRvcExlZnQ6IG51bWJlciA9IHBhZ2VQcmV2aWV3SG9sZGVyLmNsaWVudEhlaWdodCArIDE7IC8vIG90aGVyd2lzZSBlbGVtZW50IGlzIGJlbG93IHZpc2libGUgYXJlYVxyXG4gICAgICAgIGxldCBzdGF0aWNPZmZzZXRQeDogbnVtYmVyID0gY3VycmVudEFwcC5uYXZpZ2F0aW9uSGVpZ3RoUHg7IC8vIFRPRE8gZXZlcnl3aGVyZTogcGl4ZWwgYWxpYXNpbmcgYXJlIG1heWJlIGJlY2F1c2UgY29tcGFyaW5nIG5vdCBudW1lcmljYWxseSwgYnV0IHN0cmljdGx5IChlcHMpXHJcbiAgICAgICAgbGV0IGN1cnJlbnRTY3JvbGxUb3A6IG51bWJlciA9IHBhZ2VQcmV2aWV3SG9sZGVyLnNjcm9sbFRvcDtcclxuICAgICAgICBsZXQgbWluWFByZXZpZXc6IG51bWJlciA9IDA7IC8vIDAgYmFzZWQgZm9yIHRvcCBsZWZ0IGNvcm5lciBpbiB2aWV3cG9ydC9wYWdlcHJldmlld1xyXG4gICAgICAgIGxldCBtYXhYUHJldmlldzogbnVtYmVyID0gcGFnZVByZXZpZXdIb2xkZXIuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJzY3JvbGxlZCBwcmV2aWV3IHRvXCIgKyBjdXJyZW50U2Nyb2xsVG9wICsgXCIgYXQgY2xpZW50IGhlaWdodCBcIiArIHBhZ2VQcmV2aWV3SG9sZGVyLmNsaWVudEhlaWdodCArIFwiIGZyb20gbWF4IGhlaWdodFwiICsgcGFnZVByZXZpZXdIb2xkZXIuc2Nyb2xsSGVpZ2h0ICArIFwiIG1pblggXCIgKyBtaW5YUHJldmlldyArIFwiIG1heFhcIiArIG1heFhQcmV2aWV3KTtcclxuICAgICAgICBmb3IobGV0IGVsZW1lbnRLZXkgaW4gY3VycmVudFBhZ2VQcmV2aWV3Ll9hY3RpdmVWaWV3TGF5b3V0QXRvbURvbU5vZGVSZWZlcmVuY2VzKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gb3JkZXIgYWxsIGxheW91dCBlbGVtZW50cyBhbmQgcHJvY2VzcyBvbmx5IHNwZWNpZmljIHJhbmdlIG9yIG1vdmUgcHJvY2Vzc2luZyByYW5nZSB3aXRoIHNjcm9sbFxyXG4gICAgICAgICAgICBsZXQgZG9tTm9kZTogSFRNTEVsZW1lbnQgPSBjdXJyZW50UGFnZVByZXZpZXcuX2FjdGl2ZVZpZXdMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXNbZWxlbWVudEtleV07XHJcbiAgICAgICAgICAgIGxldCBpc0RvbU5vZGVWaXNpYmxlOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJwcm9jZXNzaW5nIGVsZW1lbnQ6IGNsaWVudFRvcCBcIiArIGRvbU5vZGUuY2xpZW50SGVpZ2h0ICsgXCIsIG9mZnNldFRvcCBcIiArIGRvbU5vZGUub2Zmc2V0VG9wKTtcclxuICAgICAgICAgICAgbGV0IGJvdW5kaW5nUmVjdEVsZW1lbnQ6IENsaWVudFJlY3QgPSBkb21Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAvL2xldCBmaXJzdENsaWVudFJlY3RFbGVtZW50OiBDbGllbnRSZWN0ID0gZG9tTm9kZS5nZXRDbGllbnRSZWN0cygpWzBdO1xyXG4gICAgICAgICAgICBsZXQgbWluWEVsZW1lbnREZWx0YVRvcExlZnQ6IG51bWJlciA9IGJvdW5kaW5nUmVjdEVsZW1lbnQudG9wIC0gc3RhdGljT2Zmc2V0UHg7XHJcbiAgICAgICAgICAgIGxldCBtYXhYRWxlbWVudERlbHRhQm90dG9tTGVmdDogbnVtYmVyID0gcGFnZVByZXZpZXdIb2xkZXIuY2xpZW50SGVpZ2h0IC0gKGJvdW5kaW5nUmVjdEVsZW1lbnQudG9wIC0gc3RhdGljT2Zmc2V0UHggKyBjdXJyZW50U2Nyb2xsVG9wICsgYm91bmRpbmdSZWN0RWxlbWVudC5oZWlnaHQpICsgY3VycmVudFNjcm9sbFRvcDtcclxuICAgICAgICAgICAgaWYgKGJvdW5kaW5nUmVjdEVsZW1lbnQuaGVpZ2h0ID4gMCkgeyAvLyBoZWlnaHQgY2FuIGJlIDAgPT4gaW52aXNpYmxlXHJcbiAgICAgICAgICAgICAgICBpZiAobWluWEVsZW1lbnREZWx0YVRvcExlZnQgPj0gMC4wICYmIG1pblhFbGVtZW50RGVsdGFUb3BMZWZ0IDw9IHBhZ2VQcmV2aWV3SG9sZGVyLmNsaWVudEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzRG9tTm9kZVZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWF4WEVsZW1lbnREZWx0YUJvdHRvbUxlZnQgPj0gMC4wICYmIG1heFhFbGVtZW50RGVsdGFCb3R0b21MZWZ0IDw9IHBhZ2VQcmV2aWV3SG9sZGVyLmNsaWVudEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzRG9tTm9kZVZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWluWEVsZW1lbnREZWx0YVRvcExlZnQgPD0gMC4wICYmIG1heFhFbGVtZW50RGVsdGFCb3R0b21MZWZ0IDw9IDAuMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzRG9tTm9kZVZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJlbGVtZW50OiBib3VuZGluZyByZWN0IHRvcCBcIiArIGJvdW5kaW5nUmVjdEVsZW1lbnQudG9wICsgXCIsIHJlY3QgYm90dG9tIFwiICsgYm91bmRpbmdSZWN0RWxlbWVudC5ib3R0b20gKyBcIiwgbWluWEVsZW1lbnREZWx0YVRvcExlZnQ6IFwiICsgbWluWEVsZW1lbnREZWx0YVRvcExlZnQgKyBcIiwgbWF4WEVsZW1lbnREZWx0YUJvdHRvbUxlZnQ6IFwiICsgbWF4WEVsZW1lbnREZWx0YUJvdHRvbUxlZnQpO1xyXG4gICAgICAgICAgICBpZiAoaXNEb21Ob2RlVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3Ll92aXNpYmxlTGF5b3V0QXRvbURvbU5vZGVSZWZlcmVuY2VzLnB1c2goZG9tTm9kZSk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcuX3Zpc2libGVMYXlvdXRBdG9tS2V5cy5wdXNoKGVsZW1lbnRLZXkpO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInZpc2libGUgZWxlbWVudDogZmlyc3QgY2xpZW50IHJlY3QgdG9wIFwiICsgZmlyc3RDbGllbnRSZWN0RWxlbWVudC50b3AgKyBcIiwgcmVjdCBib3R0b20gXCIgKyBmaXJzdENsaWVudFJlY3RFbGVtZW50LmJvdHRvbSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWluWEVsZW1lbnREZWx0YVRvcExlZnQgPCBtb3N0VXBwZXJWaXNpYmxlRGVsdGFUb3BMZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9zdFVwcGVyVmlzaWJsZURlbHRhVG9wTGVmdCA9IG1pblhFbGVtZW50RGVsdGFUb3BMZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIG1vc3RVcHBlclZpc2libGVJbmRleCA9IGN1cnJlbnRQYWdlUHJldmlldy5fdmlzaWJsZUxheW91dEF0b21LZXlzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBtb3N0VXBwZXJWaXNpYmxlTGF5b3V0QXRvbUlkID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGRvbU5vZGUsIFwiYWlkXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtb3N0VXBwZXJWaXNpYmxlTGF5b3V0QXRvbUlkICE9IGN1cnJlbnRQYWdlUHJldmlldy5fbW9zdFVwcGVyVmlzaWJsZUxheW91dEF0b21JZCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3Ll9tb3N0VXBwZXJWaXNpYmxlTGF5b3V0QXRvbUlkID0gbW9zdFVwcGVyVmlzaWJsZUxheW91dEF0b21JZDtcclxuICAgICAgICAgICAgICAgIGlmIChtb3N0VXBwZXJWaXNpYmxlTGF5b3V0QXRvbUlkICE9IDAgJiYgY3VycmVudEFwcC5wcm9wZXJ0eUJhclZNc1swXS5pc1N5bmNlZFdpdGhQYWdlUHJldmlldykge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucHJvcGVydHlCYXJzWzBdLnN5bmNTY3JvbGxQb3NpdGlvbkZyb21QYWdlUHJldmlldygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByb2Nlc3NlZEVsZW1lbnRDb3VudCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwicGFnZVByZXZpZXcgc2Nyb2xsOiBwcm9jZXNzZWQgXCIgKyBwcm9jZXNzZWRFbGVtZW50Q291bnQgKyBcIiBvYmplY3QgcG9zaXRpb25zLCB2aXNpYmxlOiBcIiArIGN1cnJlbnRQYWdlUHJldmlldy5fdmlzaWJsZUxheW91dEF0b21Eb21Ob2RlUmVmZXJlbmNlcy5sZW5ndGgudG9TdHJpbmcoKSArIFwiIG1vc3QgdXBwZXIgdmlzaWJsZSBpbmRleDogXCIgKyBtb3N0VXBwZXJWaXNpYmxlSW5kZXggKyBcIiBtb3N0IHVwcGVyIHZpc2libGUgbGF5b3V0IGlkOiBcIiArIGN1cnJlbnRQYWdlUHJldmlldy5fbW9zdFVwcGVyVmlzaWJsZUxheW91dEF0b21JZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlbmRlclBhZ2VQcmV2aWV3ID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICAvLyBUT0RPIGRvIG5vdCBzZXQgd2hlbiBib2R5IGhlaWdodCBpcyBzZXQgaW4gY3VycmVudCB2aWV3XHJcbiAgICAgICAgbGV0IHBhZ2VQcmV2aWV3U3R5bGVzID0ge1xyXG4gICAgICAgICAgICAvL1RPRE8gXCJmbGV4XCI6IFwiMSAxIGF1dG9cIiwgLy8gMXB4IGZvciBJRTExID0+IGF1dG8gZm9yIGlQaG9uZVxyXG4gICAgICAgICAgICAvL1wiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsXHJcbiAgICAgICAgICAgIFwid2lkdGhcIjogKGN1cnJlbnRBcHAuc3RhdGUuaXNEYXRhTG9hZGVkICYmICFjdXJyZW50QXBwLnN0YXRlLmlzRW5vdWdoQXZhaWxhYmxlU3BhY2VQYWdlUHJldmlldykgPyAoY3VycmVudEFwcC5zdGF0ZS50YXJnZXRQYWdlUHJldmlld1dpZHRoUHgpICsgXCJweFwiIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBcImRpc3BsYXlcIjogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgIC8vVE9ETyBcImhlaWdodFwiOiBcIjFweFwiIC8vIFRPRE8gY3VycmVudEFwcC5zdGF0ZS5pc0hpZGVVc2VySW50ZXJmYWNlID8gLypUT0RPKi9cIjEwMCVcIiA6IFwiYXV0b1wiLCAvLyAxcHggPT4gYXV0byBmb3IgaVBob25lXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgaXNSZW5kZXJWaWV3OiBib29sZWFuID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFWaWV3cyAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGxldCBjYWxpZm9ybmlhVmlld0JvZHlTdHlsZVN0cmluZzogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ2FsaWZvcm5pYVZpZXdzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY2FsaWZvcm5pYVZpZXdCb2R5U3R5bGVTdHJpbmcgPSAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFWaWV3cy5maW5kKHYgPT4gdi5DYWxpZm9ybmlhVmlld0lkID09IGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwuYWN0aXZlQ2FsaWZvcm5pYVZpZXdJZCkgYXMgQ2FsaWZvcm5pYVZpZXcpLlNwZWNpYWxTdHlsZUJvZHlTdHlsZVN0cmluZzsgLy8gVE9ETyBleHBlbnNpdmVcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzUmVuZGVyVmlldyA/IDxkaXYga2V5PXtgdnAke2N1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwuYWN0aXZlQ2FsaWZvcm5pYVZpZXdJZH1gfSBjbGFzcz17Y2FsaWZvcm5pYVZpZXdCb2R5U3R5bGVTdHJpbmd9IHN0eWxlcz17cGFnZVByZXZpZXdTdHlsZXN9PlxyXG4gICAgICAgICAgICB7Y3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC5jYWxpZm9ybmlhVmlld1Byb2plY3Rvci5yZXN1bHRzLm1hcChyID0+IHIucmVuZGVyTWFxdWV0dGUoKSl9XHJcbiAgICAgICAgICAgIDwvZGl2PiBhcyBWTm9kZSA6IDxkaXYga2V5PVwidnAwXCIgc3R5bGVzPXtwYWdlUHJldmlld1N0eWxlc30+PC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyQ2FsaWZvcm5pYVZpZXdBcnJheSA9ICgpOiBtYXF1ZXR0ZS5NYXBwaW5nPENhbGlmb3JuaWFWaWV3LCB7IHJlbmRlck1hcXVldHRlOiAoKSA9PiBtYXF1ZXR0ZS5WTm9kZSB9PiA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG1hcXVldHRlLmNyZWF0ZU1hcHBpbmc8Q2FsaWZvcm5pYVZpZXcsIGFueT4oXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFNlY3Rpb25Tb3VyY2VLZXkoc291cmNlOiBDYWxpZm9ybmlhVmlldykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5DYWxpZm9ybmlhVmlld0lkO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVTZWN0aW9uVGFyZ2V0KHNvdXJjZTogQ2FsaWZvcm5pYVZpZXcpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzb3VyY2VDYWxpZm9ybmlhVmlld0lkU3RyaW5nID0gc291cmNlLkNhbGlmb3JuaWFWaWV3SWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGxldCBsYXlvdXRSb3dzID0gY3VycmVudFBhZ2VQcmV2aWV3LnJlbmRlckxheW91dFJvd0FycmF5KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGxheW91dFJvd3MubWFwKHNvdXJjZS5QbGFjZWRMYXlvdXRSb3dzKTtcclxuICAgICAgICAgICAgICAgIC8vIC0tLSBUT0RPIGNvZGUgZHVwbGljYXRpb25cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLy8gLS0tIGNvZGUgZHVwbGljYXRpb24gZW5kXHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHNob3cgYm9keStodG1sIHN0eWxlIG1vbGVjdWxlIGluIHBhZ2UgcHJldmlld1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJNYXF1ZXR0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2FsaWZvcm5pYVZpZXdTdHlsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsZXhcIjogXCIxIDEgMXB4XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYgY2xhc3M9e3NvdXJjZS5TcGVjaWFsU3R5bGVWaWV3U3R5bGVTdHJpbmd9IGtleT17c291cmNlQ2FsaWZvcm5pYVZpZXdJZFN0cmluZ30gaWQ9e2BjYWxpZm9ybmlhLXYke3NvdXJjZS5DYWxpZm9ybmlhVmlld0lkfV8ke3NvdXJjZS5OYW1lfWB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWQ9e3NvdXJjZUNhbGlmb3JuaWFWaWV3SWRTdHJpbmd9IHN0eWxlcz17Y2FsaWZvcm5pYVZpZXdTdHlsZXN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2xheW91dFJvd3MucmVzdWx0cy5tYXAociA9PiByLnJlbmRlck1hcXVldHRlKCkpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj47XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICh1cGRhdGVkU291cmNlOiBDYWxpZm9ybmlhVmlldykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSB1cGRhdGVkU291cmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRSb3dzLm1hcChzb3VyY2UuUGxhY2VkTGF5b3V0Um93cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUNhbGlmb3JuaWFWaWV3SWRTdHJpbmcgPSBzb3VyY2UuQ2FsaWZvcm5pYVZpZXdJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNlY3Rpb25UYXJnZXQodXBkYXRlZFNvdXJjZTogQ2FsaWZvcm5pYVZpZXcsIHRhcmdldDogeyByZW5kZXJNYXF1ZXR0ZSgpOiBhbnksIHVwZGF0ZSh1cGRhdGVkU291cmNlOiBDYWxpZm9ybmlhVmlldyk6IHZvaWQgfSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnVwZGF0ZSh1cGRhdGVkU291cmNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJMYXlvdXRSb3dBcnJheSA9IChpc1JlbmRlckZpeGVkTGF5b3V0OiBib29sZWFuKTogbWFxdWV0dGUuTWFwcGluZzxMYXlvdXRSb3csIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+ID0+IHsgLy8gVE9ETyBjb2RlIGR1cGxpY2F0aW9uIHdpdGggcGFnZSBwcmV2aWV3XHJcbiAgICAgICAgcmV0dXJuIG1hcXVldHRlLmNyZWF0ZU1hcHBpbmc8TGF5b3V0Um93LCBhbnk+KFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRTZWN0aW9uU291cmNlS2V5KHNvdXJjZTogTGF5b3V0Um93KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlLkxheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlU2VjdGlvblRhcmdldChzb3VyY2U6IExheW91dFJvdykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZUxheW91dFJvd0lkU3RyaW5nID0gc291cmNlLkxheW91dEJhc2VJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlTW9sZWN1bGU6IFN0eWxlTW9sZWN1bGUgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChtID0+IG0uU3R5bGVGb3JMYXlvdXRJZCA9PSBzb3VyY2UuTGF5b3V0QmFzZUlkKSBhcyBTdHlsZU1vbGVjdWxlOyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgbGV0IGxheW91dEJveE1hcHBpbmcgPSBjdXJyZW50UGFnZVByZXZpZXcucmVuZGVyTGF5b3V0Qm94QXJyYXkoaXNSZW5kZXJGaXhlZExheW91dCwgc3R5bGVNb2xlY3VsZS5Jc1Bvc2l0aW9uRml4ZWQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHVuc29ydGVkQm94ZXM6IExheW91dEJveFtdID0gc291cmNlLkFsbEJveGVzQmVsb3dSb3cuZmlsdGVyKGIgPT4gYi5QbGFjZWRCb3hJbkJveElkID09PSB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvcnRlZEJveGVzOiBMYXlvdXRCb3hbXSA9IHVuc29ydGVkQm94ZXMuc29ydCgoYm94QTogTGF5b3V0Qm94LCBib3hCOiBMYXlvdXRCb3gpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm94QS5MYXlvdXRTb3J0T3JkZXJLZXkgPCBib3hCLkxheW91dFNvcnRPcmRlcktleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJveEEuTGF5b3V0U29ydE9yZGVyS2V5ID09IGJveEIuTGF5b3V0U29ydE9yZGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gYm94QS5MYXlvdXRTb3J0T3JkZXJLZXkgPiBib3hCLkxheW91dFNvcnRPcmRlcktleVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGxheW91dEJveE1hcHBpbmcubWFwKHNvcnRlZEJveGVzKTtcclxuICAgICAgICAgICAgICAgIC8vIC0tLSBUT0RPIGNvZGUgZHVwbGljYXRpb24gLy8gVE9ETyBmaXggbWF4LXdpZHRoIGZvciByZXNwb25zaXZlIHZpZXdzIC8vIFRPRE8gZml4IGZvciBib3R0b20vcmlnaHQgaW5zdGVhZCBvZiB0b3AvbGVmdCAvLyBUT0RPIGZpeCBmb3IgaXNIaWRlVXNlckludGVyZmFjZSAvLyBUT0RPIHRyeSByZW5kZXJpbmcgZml4ZWQgaXRlbXMgYXMgYWJzb2x1dGUgcG9zaXRpb25lZCBkaXJlY3RseSB1bmRlciBwYWdlIHByZXZpZXcgaG9sZGVyXHJcbiAgICAgICAgICAgICAgICBsZXQgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQgfTtcclxuICAgICAgICAgICAgICAgIGxldCBtYXJnaW5Ub3BPdmVycmlkZVZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgdG9wT3ZlcnJpZGVWYWx1ZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgbGV0IG1hcmdpbkxlZnRPdmVycmlkZVZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGVNb2xlY3VsZS5Jc1Bvc2l0aW9uRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3BPdmVycmlkZVZhbHVlID0gYCR7c3R5bGVNb2xlY3VsZS5Ub3BDc3NWYWx1ZVB4fXB4YDtcclxuICAgICAgICAgICAgICAgICAgICB0b3BPdmVycmlkZVZhbHVlID0gc3R5bGVNb2xlY3VsZS5Ub3BDc3NWYWx1ZVB4ICE9PSB1bmRlZmluZWQgPyBgJHtjdXJyZW50QXBwLm5hdmlnYXRpb25IZWlndGhQeH1weGAgOiB1bmRlZmluZWQ7IC8vIFRPRE8gZXhwZW5zaXZlO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbkxlZnRPdmVycmlkZVZhbHVlID0gYCR7c3R5bGVNb2xlY3VsZS5MZWZ0Q3NzVmFsdWVQeH1weGA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3BPdmVycmlkZVZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcE92ZXJyaWRlVmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdE92ZXJyaWRlVmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyAtLS0gVE9ETyBjb2RlIGR1cGxpY2F0aW9uIGVuZFxyXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlTW9sZWN1bGVJZDogbnVtYmVyID0gc3R5bGVNb2xlY3VsZS5TdHlsZU1vbGVjdWxlSWQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVNb2xlY3VsZUlkU3RyaW5nOiBzdHJpbmcgPSBzdHlsZU1vbGVjdWxlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGxldCBsYXlvdXRSb3dTdHlsZUNsYXNzOiBzdHJpbmcgPSBgcyR7c3R5bGVNb2xlY3VsZUlkU3RyaW5nfWA7XHJcbiAgICAgICAgICAgICAgICBsZXQgaG9sZGVyS2V5U3RyaW5nOiBzdHJpbmcgPSBgJHtpc1JlbmRlckZpeGVkTGF5b3V0ID8gXCJmXCIgOiBcImdcIn0ke3NvdXJjZUxheW91dFJvd0lkU3RyaW5nfWA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlck1hcXVldHRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZW5kZXJlZExheW91dEJveGVzOiBWTm9kZVtdID0gbGF5b3V0Qm94TWFwcGluZy5yZXN1bHRzLmxlbmd0aCA+IDAgPyBsYXlvdXRCb3hNYXBwaW5nLnJlc3VsdHMubWFwKHIgPT4gci5yZW5kZXJNYXF1ZXR0ZSgpKSA6IFtdOyAvKlRPRE8gPGRpdiBrZXk9XCItMVwiPjxwPkFkZCBjb2x1bW5zLi4uPC9wPjwvZGl2PiovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpc0hvdmVyZWRJbkJveFRyZWU6IGJvb2xlYW4gPSBjdXJyZW50QXBwLnN0YXRlLmhvdmVyZWRCb3hUcmVlTGF5b3V0QmFzZUlkID09IHNvdXJjZS5MYXlvdXRCYXNlSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNSZW5kZXJGaXhlZExheW91dCAmJiBzdHlsZU1vbGVjdWxlLklzUG9zaXRpb25GaXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVNb2xlY3VsZS5Jc1Bvc2l0aW9uRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLypcIm1hcmdpbi10b3BcIjogbWFyZ2luVG9wT3ZlcnJpZGVWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1sZWZ0XCI6IG1hcmdpbkxlZnRPdmVycmlkZVZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidG9wXCI6IHRvcE92ZXJyaWRlVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsZWZ0XCI6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1heC13aWR0aFwiOiB1bmRlZmluZWQsKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCI6IFwiYWJzb2x1dGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1JlbmRlckZpeGVkTGF5b3V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbmRlcmVkTGF5b3V0Qm94ZXMuZmlsdGVyKHYgPT4gdiAhPT0gdW5kZWZpbmVkKS5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLypcIm1hcmdpbi10b3BcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLWxlZnRcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidG9wXCI6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImxlZnRcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWF4LXdpZHRoXCI6IHVuZGVmaW5lZCwqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicG9zaXRpb25cIjogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJiYWNrZ3JvdW5kLWNvbG9yXCJdID0gaXNIb3ZlcmVkSW5Cb3hUcmVlID8gSElHSExJR0hUX0JBQ0tHUk9VTkRfQ09MT1JfU1RSSU5HIDogdW5kZWZpbmVkOyAgLy8gVE9ETyBoaWdobGlnaHQgZmlyc3QgYXRvbSBvciBkcmF3IG91dGxpbmUgaW5zdGVhZCAoYXRvbSBiZy1jb2xvciBjYW4gb3ZlcnJpZGUgPT4gbm8gaGlnaGxpZ2h0IHZpc2libGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuTGF5b3V0QmFzZUlkID09IGN1cnJlbnRBcHAuc3RhdGUuaGlnaGxpZ2h0ZWRMYXlvdXRCYXNlSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJvdXRsaW5lXCJdID0gXCJzb2xpZCAxcHggYmxhY2tcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJvdXRsaW5lLW9mZnNldFwiXSA9IFwiLTFweFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlc1tcImJhY2tncm91bmQtY29sb3JcIl0gPSBNQU5VQUxMWV9ISUdITElHSFRfQkFDS0dST1VORF9DT0xPUl9TVFJJTkc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzW1wib3V0bGluZVwiXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJvdXRsaW5lLW9mZnNldFwiXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVNb2xlY3VsZS5Jc1Bvc2l0aW9uRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlc1tcIm1heC13aWR0aFwiXSA9IHN0eWxlTW9sZWN1bGUuSXNQb3NpdGlvbkZpeGVkICYmIGN1cnJlbnRBcHAuc3RhdGUuaXNEYXRhTG9hZGVkICYmIGN1cnJlbnRBcHAuc3RhdGUuaXNFbm91Z2hBdmFpbGFibGVTcGFjZVBhZ2VQcmV2aWV3ICYmIGN1cnJlbnRBcHAuc3RhdGUuZWRpdFZpZXdNb2RlICE9PSBFZGl0Vmlld01vZGUuUGFnZVByZXZpZXdPbmx5ID8gYCR7Y3VycmVudEFwcC5zdGF0ZS50YXJnZXRQYWdlUHJldmlld1dpZHRoUHh9cHhgIDogdW5kZWZpbmVkOyAvLyBUT0RPIGV4cGVuc2l2ZSBUT0RPIGR1cGxpY2F0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3BhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJsZWZ0XCJdID0gc3R5bGVNb2xlY3VsZS5Jc1Bvc2l0aW9uRml4ZWQgJiYgc3R5bGVNb2xlY3VsZS5MZWZ0Q3NzVmFsdWVQeCAhPT0gdW5kZWZpbmVkID8gYCR7cGFyc2VJbnQoc3R5bGVNb2xlY3VsZS5MZWZ0Q3NzVmFsdWVQeCkgKyBjdXJyZW50QXBwLnN0YXRlLnRhcmdldFBhZ2VQcmV2aWV3SG9sZGVyTWFyZ2luUHh9cHhgIDogdW5kZWZpbmVkOyAvLyBUT0RPIGV4cGVuc2l2ZSAvLyBUT0RPIGRhbmdlcm91cyAvLyBUT0RPIG1hZ2ljIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17aG9sZGVyS2V5U3RyaW5nfSBjbGFzcz17bGF5b3V0Um93U3R5bGVDbGFzc30gc3R5bGVzPXtwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtyZW5kZXJlZExheW91dEJveGVzfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gYXMgVk5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICh1cGRhdGVkU291cmNlOiBMYXlvdXRSb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gdXBkYXRlZFNvdXJjZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTGF5b3V0Um93SWRTdHJpbmcgPSBzb3VyY2UuTGF5b3V0QmFzZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlTW9sZWN1bGUgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChtID0+IG0uU3R5bGVGb3JMYXlvdXRJZCA9PSBzb3VyY2UuTGF5b3V0QmFzZUlkKSBhcyBTdHlsZU1vbGVjdWxlOyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRCb3hNYXBwaW5nID0gY3VycmVudFBhZ2VQcmV2aWV3LnJlbmRlckxheW91dEJveEFycmF5KGlzUmVuZGVyRml4ZWRMYXlvdXQsIHN0eWxlTW9sZWN1bGUuSXNQb3NpdGlvbkZpeGVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5zb3J0ZWRCb3hlcyA9IHNvdXJjZS5BbGxCb3hlc0JlbG93Um93LmZpbHRlcihiID0+IGIuUGxhY2VkQm94SW5Cb3hJZCA9PT0gdW5kZWZpbmVkKTsgLy8gaW4gdGhlIGNhc2Ugb2YgYSBwcmV2aWV3IGJveCAodGVtcG9yYXJ5IGNoYW5nZSBpbiBsYXlvdXQgc3RydWN0dXJlKSB0aGUgcGxhY2VkIGluIGJveCByZWZlcmVuY2UgaXMga2VwdCBpbiBpbmNvbnNpc3RlbnQgc3RhdGUgPT4gY2hlY2sgaWQgb25seVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0ZWRCb3hlcyA9IHVuc29ydGVkQm94ZXMuc29ydCgoYm94QTogTGF5b3V0Qm94LCBib3hCOiBMYXlvdXRCb3gpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib3hBLkxheW91dFNvcnRPcmRlcktleSA8IGJveEIuTGF5b3V0U29ydE9yZGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYm94QS5MYXlvdXRTb3J0T3JkZXJLZXkgPT0gYm94Qi5MYXlvdXRTb3J0T3JkZXJLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBib3hBLkxheW91dFNvcnRPcmRlcktleSA+IGJveEIuTGF5b3V0U29ydE9yZGVyS2V5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRCb3hNYXBwaW5nLm1hcChzb3J0ZWRCb3hlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0tLSBUT0RPIGNvZGUgZHVwbGljYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlTW9sZWN1bGUuSXNQb3NpdGlvbkZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3BPdmVycmlkZVZhbHVlID0gYCR7c3R5bGVNb2xlY3VsZS5Ub3BDc3NWYWx1ZVB4fXB4YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcE92ZXJyaWRlVmFsdWUgPSBzdHlsZU1vbGVjdWxlLlRvcENzc1ZhbHVlUHggIT09IHVuZGVmaW5lZCA/IGAke2N1cnJlbnRBcHAubmF2aWdhdGlvbkhlaWd0aFB4fXB4YCA6IHVuZGVmaW5lZDsgLy8gVE9ETyBleHBlbnNpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0T3ZlcnJpZGVWYWx1ZSA9IGAke3N0eWxlTW9sZWN1bGUuTGVmdENzc1ZhbHVlUHh9cHhgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wT3ZlcnJpZGVWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcE92ZXJyaWRlVmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0T3ZlcnJpZGVWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAtLS0gVE9ETyBjb2RlIGR1cGxpY2F0aW9uIGVuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZU1vbGVjdWxlSWQgPSBzdHlsZU1vbGVjdWxlLlN0eWxlTW9sZWN1bGVJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVNb2xlY3VsZUlkU3RyaW5nID0gc3R5bGVNb2xlY3VsZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dFJvd1N0eWxlQ2xhc3MgPSBgcyR7c3R5bGVNb2xlY3VsZUlkfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlcktleVN0cmluZyA9IGAke2lzUmVuZGVyRml4ZWRMYXlvdXQgPyBcImZcIiA6IFwiZ1wifSR7c291cmNlTGF5b3V0Um93SWRTdHJpbmd9YDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVTZWN0aW9uVGFyZ2V0KHVwZGF0ZWRTb3VyY2U6IExheW91dFJvdywgdGFyZ2V0OiB7IHJlbmRlck1hcXVldHRlKCk6IGFueSwgdXBkYXRlKHVwZGF0ZWRTb3VyY2U6IExheW91dFJvdyk6IHZvaWQgfSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnVwZGF0ZSh1cGRhdGVkU291cmNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgcmVuZGVyTGF5b3V0Qm94QXJyYXkgPSAoaXNSZW5kZXJGaXhlZExheW91dDogYm9vbGVhbiwgaXNMYXlvdXRCb3hJbnNpZGVGaXhlZDogYm9vbGVhbik6IG1hcXVldHRlLk1hcHBpbmc8TGF5b3V0Qm94LCB7IHJlbmRlck1hcXVldHRlOiAoKSA9PiBtYXF1ZXR0ZS5WTm9kZSB9PiA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG1hcXVldHRlLmNyZWF0ZU1hcHBpbmc8TGF5b3V0Qm94LCBhbnk+KFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRTZWN0aW9uU291cmNlS2V5KHNvdXJjZTogTGF5b3V0Qm94KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlLkxheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlU2VjdGlvblRhcmdldChzb3VyY2U6IExheW91dEJveCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZUxheW91dEJveElkU3RyaW5nID0gc291cmNlLkxheW91dEJhc2VJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlTW9sZWN1bGU6IFN0eWxlTW9sZWN1bGUgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChtID0+IG0uU3R5bGVGb3JMYXlvdXRJZCA9PSBzb3VyY2UuTGF5b3V0QmFzZUlkKSBhcyBTdHlsZU1vbGVjdWxlOyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgbGV0IHJlbmRlcmVkTGF5b3V0QXRvbXMgPSBjdXJyZW50UGFnZVByZXZpZXcucmVuZGVyTGF5b3V0QXRvbUFycmF5KGlzUmVuZGVyRml4ZWRMYXlvdXQsIHN0eWxlTW9sZWN1bGUuSXNQb3NpdGlvbkZpeGVkIHx8IGlzTGF5b3V0Qm94SW5zaWRlRml4ZWQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlbmRlcmVkTGF5b3V0Qm94ZXMgPSBjdXJyZW50UGFnZVByZXZpZXcucmVuZGVyTGF5b3V0Qm94QXJyYXkoaXNSZW5kZXJGaXhlZExheW91dCwgc3R5bGVNb2xlY3VsZS5Jc1Bvc2l0aW9uRml4ZWQgfHwgaXNMYXlvdXRCb3hJbnNpZGVGaXhlZCk7XHJcbiAgICAgICAgICAgICAgICAvLyAtLS0gVE9ETyBjb2RlIGR1cGxpY2F0aW9uIC8vIFRPRE8gZml4IG1heC13aWR0aCBmb3IgcmVzcG9uc2l2ZSB2aWV3cyAvLyBUT0RPIGZpeCBmb3IgYm90dG9tL3JpZ2h0IGluc3RlYWQgb2YgdG9wL2xlZnQgLy8gVE9ETyBmaXggZm9yIGlzSGlkZVVzZXJJbnRlcmZhY2VcclxuICAgICAgICAgICAgICAgIGxldCBwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZCB9O1xyXG4gICAgICAgICAgICAgICAgbGV0IG1hcmdpblRvcE92ZXJyaWRlVmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGxldCB0b3BPdmVycmlkZVZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWFyZ2luTGVmdE92ZXJyaWRlVmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGlmIChzdHlsZU1vbGVjdWxlLklzUG9zaXRpb25GaXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcE92ZXJyaWRlVmFsdWUgPSBgJHtzdHlsZU1vbGVjdWxlLlRvcENzc1ZhbHVlUHh9cHhgO1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcE92ZXJyaWRlVmFsdWUgPSBzdHlsZU1vbGVjdWxlLlRvcENzc1ZhbHVlUHggIT09IHVuZGVmaW5lZCA/IGAke2N1cnJlbnRBcHAubmF2aWdhdGlvbkhlaWd0aFB4fXB4YCA6IHVuZGVmaW5lZDsgLy8gVE9ETyBleHBlbnNpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdE92ZXJyaWRlVmFsdWUgPSBgJHtzdHlsZU1vbGVjdWxlLkxlZnRDc3NWYWx1ZVB4fXB4YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcE92ZXJyaWRlVmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9wT3ZlcnJpZGVWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0T3ZlcnJpZGVWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIC0tLSBUT0RPIGNvZGUgZHVwbGljYXRpb24gZW5kXHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVNb2xlY3VsZUlkOiBudW1iZXIgPSBzdHlsZU1vbGVjdWxlLlN0eWxlTW9sZWN1bGVJZDtcclxuICAgICAgICAgICAgICAgIGxldCBzdHlsZU1vbGVjdWxlSWRTdHJpbmc6IHN0cmluZyA9IHN0eWxlTW9sZWN1bGVJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxheW91dEJveFN0eWxlQ2xhc3M6IHN0cmluZyA9IGBzJHtzdHlsZU1vbGVjdWxlSWR9YDtcclxuICAgICAgICAgICAgICAgIGxldCByaWNoVGV4dFRhZzogc3RyaW5nID0gXCJwXCI7XHJcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLlNwZWNpYWxMYXlvdXRCb3hUeXBlID09PSBTcGVjaWFsTGF5b3V0Qm94VHlwZS5SaWNoVGV4dCAmJiBzb3VyY2UuUGxhY2VkSW5Cb3hBdG9tcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxheW91dElkT2ZGaXJzdEF0b206IG51bWJlciA9IHNvdXJjZS5QbGFjZWRJbkJveEF0b21zWzBdLkxheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3R5bGVPZkZpcnN0QXRvbTogU3R5bGVNb2xlY3VsZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcy5maW5kKG0gPT4gbS5TdHlsZUZvckxheW91dElkID09IGxheW91dElkT2ZGaXJzdEF0b20pIGFzIFN0eWxlTW9sZWN1bGU7Ly8gVE9ETyBleHBlbnNpdmVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVPZkZpcnN0QXRvbS5IdG1sVGFnICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmljaFRleHRUYWcgPSBzdHlsZU9mRmlyc3RBdG9tLkh0bWxUYWc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7IC8vIFRPRE9cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlck1hcXVldHRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZW5kZXJlZEJveENvbnRlbnQ6IFZOb2RlW10gPSBjdXJyZW50UGFnZVByZXZpZXcubWFwQW5kUmVuZGVyTGF5b3V0Qm94Q29udGVudChzb3VyY2UsIHNvdXJjZS5QbGFjZWRJbkJveEF0b21zLCByZW5kZXJlZExheW91dEF0b21zLCBzb3VyY2UuUGxhY2VkSW5Cb3hCb3hlcywgcmVuZGVyZWRMYXlvdXRCb3hlcyk7IC8vIHNvcnRlZCB0d2ljZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXNIb3ZlcmVkSW5Cb3hUcmVlOiBib29sZWFuID0gY3VycmVudEFwcC5zdGF0ZS5ob3ZlcmVkQm94VHJlZUxheW91dEJhc2VJZCA9PSBzb3VyY2UuTGF5b3V0QmFzZUlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVuZGVyRml4ZWRMYXlvdXQgJiYgc3R5bGVNb2xlY3VsZS5Jc1Bvc2l0aW9uRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlTW9sZWN1bGUuSXNQb3NpdGlvbkZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qXCJtYXJnaW4tdG9wXCI6IG1hcmdpblRvcE92ZXJyaWRlVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tbGVmdFwiOiBtYXJnaW5MZWZ0T3ZlcnJpZGVWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRvcFwiOiB0b3BPdmVycmlkZVZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGVmdFwiOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXgtd2lkdGhcIjogdW5kZWZpbmVkKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCI6IFwiYWJzb2x1dGVcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1JlbmRlckZpeGVkTGF5b3V0ICYmICFpc0xheW91dEJveEluc2lkZUZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbmRlcmVkQm94Q29udGVudC5maWx0ZXIodiA9PiB2ICE9PSB1bmRlZmluZWQpLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKlwibWFyZ2luLXRvcFwiOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tbGVmdFwiOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0b3BcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibGVmdFwiOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXgtd2lkdGhcIjogdW5kZWZpbmVkKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBvc2l0aW9uXCI6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzW1wiYmFja2dyb3VuZC1jb2xvclwiXSA9IGlzSG92ZXJlZEluQm94VHJlZSA/IEhJR0hMSUdIVF9CQUNLR1JPVU5EX0NPTE9SX1NUUklORyA6IHVuZGVmaW5lZDsgLy8gVE9ETyBoaWdobGlnaHQgZmlyc3QgYXRvbSBvciBkcmF3IG91dGxpbmUgaW5zdGVhZCAoYXRvbSBiZy1jb2xvciBjYW4gb3ZlcnJpZGUgPT4gbm8gaGlnaGxpZ2h0IHZpc2libGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuTGF5b3V0QmFzZUlkID09IGN1cnJlbnRBcHAuc3RhdGUuaGlnaGxpZ2h0ZWRMYXlvdXRCYXNlSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJvdXRsaW5lXCJdID0gXCJzb2xpZCAxcHggYmxhY2tcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJvdXRsaW5lLW9mZnNldFwiXSA9IFwiLTFweFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlc1tcImJhY2tncm91bmQtY29sb3JcIl0gPSBNQU5VQUxMWV9ISUdITElHSFRfQkFDS0dST1VORF9DT0xPUl9TVFJJTkc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzW1wib3V0bGluZVwiXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJvdXRsaW5lLW9mZnNldFwiXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVNb2xlY3VsZS5Jc1Bvc2l0aW9uRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlc1tcIm1heC13aWR0aFwiXSA9IHN0eWxlTW9sZWN1bGUuSXNQb3NpdGlvbkZpeGVkICYmIGN1cnJlbnRBcHAuc3RhdGUuaXNEYXRhTG9hZGVkICYmIGN1cnJlbnRBcHAuc3RhdGUuaXNFbm91Z2hBdmFpbGFibGVTcGFjZVBhZ2VQcmV2aWV3ICYmIGN1cnJlbnRBcHAuc3RhdGUuZWRpdFZpZXdNb2RlICE9PSBFZGl0Vmlld01vZGUuUGFnZVByZXZpZXdPbmx5ID8gYCR7Y3VycmVudEFwcC5zdGF0ZS50YXJnZXRQYWdlUHJldmlld1dpZHRoUHh9cHhgIDogdW5kZWZpbmVkOyAvLyBUT0RPIGV4cGVuc2l2ZSBUT0RPIGR1cGxpY2F0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3BhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJsZWZ0XCJdID0gc3R5bGVNb2xlY3VsZS5Jc1Bvc2l0aW9uRml4ZWQgJiYgc3R5bGVNb2xlY3VsZS5MZWZ0Q3NzVmFsdWVQeCAhPT0gdW5kZWZpbmVkID8gYCR7cGFyc2VJbnQoc3R5bGVNb2xlY3VsZS5MZWZ0Q3NzVmFsdWVQeCkgKyBjdXJyZW50QXBwLnN0YXRlLnRhcmdldFBhZ2VQcmV2aWV3SG9sZGVyTWFyZ2luUHh9cHhgIDogdW5kZWZpbmVkOyAvLyBUT0RPIGV4cGVuc2l2ZSAvLyBUT0RPIGRhbmdlcm91cyAvLyBUT0RPIG1hZ2ljIHN0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gY2hlY2sgZXZlcnl3aGVyZTogYXJlIGNvbW1lbnRzIGZyb20gdHN4IHN0cmlwcGVkIG91dD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChzb3VyY2UuU3BlY2lhbExheW91dEJveFR5cGUgPT09IFNwZWNpYWxMYXlvdXRCb3hUeXBlLkRlZmF1bHQpID8gPGRpdiBrZXk9e3NvdXJjZUxheW91dEJveElkU3RyaW5nfSBjbGFzcz17bGF5b3V0Qm94U3R5bGVDbGFzc30gc3R5bGVzPXtwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtyZW5kZXJlZEJveENvbnRlbnR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PiA6IChzb3VyY2UuU3BlY2lhbExheW91dEJveFR5cGUgPT09IFNwZWNpYWxMYXlvdXRCb3hUeXBlLlVuc29ydGVkTGlzdCkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1bCBrZXk9e3NvdXJjZUxheW91dEJveElkU3RyaW5nfSBjbGFzcz17bGF5b3V0Qm94U3R5bGVDbGFzc30gc3R5bGVzPXtwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7cmVuZGVyZWRCb3hDb250ZW50fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC91bD4gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzb3VyY2UuU3BlY2lhbExheW91dEJveFR5cGUgPT09IFNwZWNpYWxMYXlvdXRCb3hUeXBlLlNvcnRlZExpc3QpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9sIGtleT17c291cmNlTGF5b3V0Qm94SWRTdHJpbmd9IGNsYXNzPXtsYXlvdXRCb3hTdHlsZUNsYXNzfSBzdHlsZXM9e3BhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtyZW5kZXJlZEJveENvbnRlbnR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvb2w+IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNvdXJjZS5TcGVjaWFsTGF5b3V0Qm94VHlwZSA9PT0gU3BlY2lhbExheW91dEJveFR5cGUuTGlzdEl0ZW0pID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBrZXk9e3NvdXJjZUxheW91dEJveElkU3RyaW5nfSBjbGFzcz17bGF5b3V0Qm94U3R5bGVDbGFzc30gc3R5bGVzPXtwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7cmVuZGVyZWRCb3hDb250ZW50Lmxlbmd0aCA+IDAgPyByZW5kZXJlZEJveENvbnRlbnQgOiA8cD5hZGQgYXRvbXMuLi48L3A+fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT4gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNvdXJjZS5TcGVjaWFsTGF5b3V0Qm94VHlwZSA9PT0gU3BlY2lhbExheW91dEJveFR5cGUuUmljaFRleHQpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoKHJpY2hUZXh0VGFnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogc291cmNlTGF5b3V0Qm94SWRTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczogcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IGxheW91dEJveFN0eWxlQ2xhc3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbcmVuZGVyZWRCb3hDb250ZW50Lmxlbmd0aCA+IDAgPyByZW5kZXJlZEJveENvbnRlbnQgOiBoKFwicFwiLCBbXCJhZGQgYXRvbXMuLi5cIl0pXSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwPlRPRE8gQm94IFR5cGUgbm90IGltcGxlbWVudGVkITwvcD47XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICh1cGRhdGVkU291cmNlOiBMYXlvdXRCb3gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gdXBkYXRlZFNvdXJjZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTGF5b3V0Qm94SWRTdHJpbmcgPSBzb3VyY2UuTGF5b3V0QmFzZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlTW9sZWN1bGUgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChtID0+IG0uU3R5bGVGb3JMYXlvdXRJZCA9PSBzb3VyY2UuTGF5b3V0QmFzZUlkKSBhcyBTdHlsZU1vbGVjdWxlOyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZExheW91dEF0b21zID0gY3VycmVudFBhZ2VQcmV2aWV3LnJlbmRlckxheW91dEF0b21BcnJheShpc1JlbmRlckZpeGVkTGF5b3V0LCBzdHlsZU1vbGVjdWxlLklzUG9zaXRpb25GaXhlZCB8fCBpc0xheW91dEJveEluc2lkZUZpeGVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRMYXlvdXRCb3hlcyA9IGN1cnJlbnRQYWdlUHJldmlldy5yZW5kZXJMYXlvdXRCb3hBcnJheShpc1JlbmRlckZpeGVkTGF5b3V0LCBzdHlsZU1vbGVjdWxlLklzUG9zaXRpb25GaXhlZCB8fCBpc0xheW91dEJveEluc2lkZUZpeGVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLS0tIFRPRE8gY29kZSBkdXBsaWNhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVNb2xlY3VsZS5Jc1Bvc2l0aW9uRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcE92ZXJyaWRlVmFsdWUgPSBgJHtzdHlsZU1vbGVjdWxlLlRvcENzc1ZhbHVlUHh9cHhgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wT3ZlcnJpZGVWYWx1ZSA9IHN0eWxlTW9sZWN1bGUuVG9wQ3NzVmFsdWVQeCAhPT0gdW5kZWZpbmVkID8gYCR7Y3VycmVudEFwcC5uYXZpZ2F0aW9uSGVpZ3RoUHh9cHhgIDogdW5kZWZpbmVkOyAvLyBUT0RPIGV4cGVuc2l2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkxlZnRPdmVycmlkZVZhbHVlID0gYCR7c3R5bGVNb2xlY3VsZS5MZWZ0Q3NzVmFsdWVQeH1weGA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3BPdmVycmlkZVZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wT3ZlcnJpZGVWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkxlZnRPdmVycmlkZVZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0tLSBUT0RPIGNvZGUgZHVwbGljYXRpb24gZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlTW9sZWN1bGVJZCA9IHN0eWxlTW9sZWN1bGUuU3R5bGVNb2xlY3VsZUlkOyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZU1vbGVjdWxlSWRTdHJpbmcgPSBzdHlsZU1vbGVjdWxlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0Qm94U3R5bGVDbGFzcyA9IGBzJHtzdHlsZU1vbGVjdWxlSWR9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmljaFRleHRUYWcgPSBcInBcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5TcGVjaWFsTGF5b3V0Qm94VHlwZSA9PT0gU3BlY2lhbExheW91dEJveFR5cGUuUmljaFRleHQgJiYgc291cmNlLlBsYWNlZEluQm94QXRvbXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxheW91dElkT2ZGaXJzdEF0b206IG51bWJlciA9IHNvdXJjZS5QbGFjZWRJbkJveEF0b21zWzBdLkxheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdHlsZU9mRmlyc3RBdG9tOiBTdHlsZU1vbGVjdWxlID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlTW9sZWN1bGVzLmZpbmQobSA9PiBtLlN0eWxlRm9yTGF5b3V0SWQgPT0gbGF5b3V0SWRPZkZpcnN0QXRvbSkgYXMgU3R5bGVNb2xlY3VsZTsvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlT2ZGaXJzdEF0b20uSHRtbFRhZyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmljaFRleHRUYWcgPSBzdHlsZU9mRmlyc3RBdG9tLkh0bWxUYWc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7IC8vIFRPRE9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNlY3Rpb25UYXJnZXQodXBkYXRlZFNvdXJjZTogTGF5b3V0Qm94LCB0YXJnZXQ6IHsgcmVuZGVyTWFxdWV0dGUoKTogYW55LCB1cGRhdGUodXBkYXRlZFNvdXJjZTogTGF5b3V0Qm94KTogdm9pZCB9KSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQudXBkYXRlKHVwZGF0ZWRTb3VyY2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSByZW5kZXJMYXlvdXRBdG9tQXJyYXkgPSAoaXNSZW5kZXJGaXhlZExheW91dDogYm9vbGVhbiwgaXNMYXlvdXRBdG9tSW5zaWRlRml4ZWQ6IGJvb2xlYW4pOiBtYXF1ZXR0ZS5NYXBwaW5nPExheW91dEF0b20sIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+ID0+IHtcclxuICAgICAgICByZXR1cm4gbWFxdWV0dGUuY3JlYXRlTWFwcGluZzxMYXlvdXRBdG9tLCBhbnk+KFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRTZWN0aW9uU291cmNlS2V5KHNvdXJjZTogTGF5b3V0QXRvbSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5MYXlvdXRCYXNlSWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb25UYXJnZXQoc291cmNlOiBMYXlvdXRBdG9tKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc291cmNlTGF5b3V0QXRvbUlkU3RyaW5nID0gc291cmNlLkxheW91dEJhc2VJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZUNvbnRlbnRBdG9tSWRTdHJpbmcgPSBzb3VyY2UuSG9zdGVkQ29udGVudEF0b20uQ29udGVudEF0b21JZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgLy8gLS0tIFRPRE8gY29kZSBkdXBsaWNhdGlvbiAvLyBUT0RPIGZpeCBtYXgtd2lkdGggZm9yIHJlc3BvbnNpdmUgdmlld3MgLy8gVE9ETyBmaXggZm9yIGJvdHRvbS9yaWdodCBpbnN0ZWFkIG9mIHRvcC9sZWZ0IC8vIFRPRE8gZml4IGZvciBpc0hpZGVVc2VySW50ZXJmYWNlXHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVNb2xlY3VsZTogU3R5bGVNb2xlY3VsZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcy5maW5kKG0gPT4gbS5TdHlsZUZvckxheW91dElkID09IHNvdXJjZS5MYXlvdXRCYXNlSWQpIGFzIFN0eWxlTW9sZWN1bGU7IC8vIFRPRE8gZXhwZW5zaXZlXHJcbiAgICAgICAgICAgICAgICBsZXQgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQgfTtcclxuICAgICAgICAgICAgICAgIGxldCBtYXJnaW5Ub3BPdmVycmlkZVZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgdG9wT3ZlcnJpZGVWYWx1ZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgbGV0IG1hcmdpbkxlZnRPdmVycmlkZVZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgYmFja2dyb3VuZE92ZXJyaWRlVmFsdWU6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGlmIChzdHlsZU1vbGVjdWxlLklzUG9zaXRpb25GaXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcE92ZXJyaWRlVmFsdWUgPSBgJHtzdHlsZU1vbGVjdWxlLlRvcENzc1ZhbHVlUHh9cHhgO1xyXG4gICAgICAgICAgICAgICAgICAgIHRvcE92ZXJyaWRlVmFsdWUgPSBzdHlsZU1vbGVjdWxlLlRvcENzc1ZhbHVlUHggIT09IHVuZGVmaW5lZCA/IGAke2N1cnJlbnRBcHAubmF2aWdhdGlvbkhlaWd0aFB4fXB4YCA6IHVuZGVmaW5lZDsgLy8gVE9ETyBleHBlbnNpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdE92ZXJyaWRlVmFsdWUgPSBgJHtzdHlsZU1vbGVjdWxlLkxlZnRDc3NWYWx1ZVB4fXB4YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcE92ZXJyaWRlVmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9wT3ZlcnJpZGVWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0T3ZlcnJpZGVWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIC0tLSBUT0RPIGNvZGUgZHVwbGljYXRpb24gZW5kXHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVNb2xlY3VsZUlkOiBudW1iZXIgPSBzdHlsZU1vbGVjdWxlLlN0eWxlTW9sZWN1bGVJZDtcclxuICAgICAgICAgICAgICAgIGxldCBzdHlsZU1vbGVjdWxlSWRTdHJpbmc6IHN0cmluZyA9IHN0eWxlTW9sZWN1bGVJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxheW91dEF0b21TdHlsZUNsYXNzOiBzdHJpbmcgPSBgcyR7c3R5bGVNb2xlY3VsZUlkU3RyaW5nfWA7IC8vIFRPRE8gY3JlYXRlIGFsbCBvZiB0aGVzZSBjb25zdGFudCBzdHJpbmdzIHdoZW4gcGFyc2luZyBkYXRhID0+IG9uZSBpbnN0YW5jZSBpbiBtZW1vcnkgISEhXHJcbiAgICAgICAgICAgICAgICBsZXQgaG9zdGVkQ29udGVudEF0b206IENvbnRlbnRBdG9tID0gKGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5Db250ZW50QXRvbXMuZmluZChjID0+IGMuQ29udGVudEF0b21JZCA9PSBzb3VyY2UuSG9zdGVkQ29udGVudEF0b20uQ29udGVudEF0b21JZCkgYXMgQ29udGVudEF0b20pOyAvLyBUT0RPIGV4cGVuc2l2ZSAoMiBjb3BpZXMgb2YgY29udGVudClcclxuICAgICAgICAgICAgICAgIGlmIChzdHlsZU1vbGVjdWxlLkh0bWxUYWcgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IGxheW91dEF0b21IdG1sVGFnOiBzdHJpbmcgPSBzdHlsZU1vbGVjdWxlLkh0bWxUYWcgIT09IHVuZGVmaW5lZCA/IHN0eWxlTW9sZWN1bGUuSHRtbFRhZyA6IFwicFwiO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5QbGFjZWRBdG9tSW5Cb3guU3BlY2lhbExheW91dEJveFR5cGUgPT09IFNwZWNpYWxMYXlvdXRCb3hUeXBlLlJpY2hUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0QXRvbUh0bWxUYWcgPSBcInNwYW5cIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTWFxdWV0dGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBzaW5jZSBpdCBpcyBuZWNlc3NhcnkgdG8ga25vdyB3aGljaCBhdG9tcyBhcmUgdmlzaWJsZSB0byB0aGUgdXNlciwgYW5kIHRoaXMgaXMgdHJhY2tlZCBvbiBzY3JvbGwgZXRjLi4uIGl0IGlzIHBvc3NpYmxlIHRvIHNhdmUgdmlzaWJsZSBzdGF0ZSBoZXJlIGFuZCBqdXN0IHBlcmZvcm0gc3R5bGUgY2FsY3VsYXRpb25zIHdoZW4gaXRzIHZpc2libGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzSG92ZXJlZEluQm94VHJlZTogYm9vbGVhbiA9IGN1cnJlbnRBcHAuc3RhdGUuaG92ZXJlZEJveFRyZWVMYXlvdXRCYXNlSWQgPT0gc291cmNlLkxheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmVuZGVyRml4ZWRMYXlvdXQgJiYgIWlzTGF5b3V0QXRvbUluc2lkZUZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZU1vbGVjdWxlLklzUG9zaXRpb25GaXhlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi10b3BcIjogbWFyZ2luVG9wT3ZlcnJpZGVWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1sZWZ0XCI6IG1hcmdpbkxlZnRPdmVycmlkZVZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidG9wXCI6IHRvcE92ZXJyaWRlVmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsZWZ0XCI6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1heC13aWR0aFwiOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ6LWluZGV4XCI6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi10b3BcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLWxlZnRcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidG9wXCI6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImxlZnRcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWF4LXdpZHRoXCI6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInotaW5kZXhcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlc1tcImJhY2tncm91bmQtY29sb3JcIl0gPSBpc0hvdmVyZWRJbkJveFRyZWUgPyBISUdITElHSFRfQkFDS0dST1VORF9DT0xPUl9TVFJJTkcgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuTGF5b3V0QmFzZUlkID09IGN1cnJlbnRBcHAuc3RhdGUuaGlnaGxpZ2h0ZWRMYXlvdXRCYXNlSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJvdXRsaW5lXCJdID0gXCJzb2xpZCAxcHggYmxhY2tcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJvdXRsaW5lLW9mZnNldFwiXSA9IFwiLTFweFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlc1tcImJhY2tncm91bmQtY29sb3JcIl0gPSBNQU5VQUxMWV9ISUdITElHSFRfQkFDS0dST1VORF9DT0xPUl9TVFJJTkc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzW1wib3V0bGluZVwiXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJvdXRsaW5lLW9mZnNldFwiXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVNb2xlY3VsZS5Jc1Bvc2l0aW9uRml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VQcmV2aWV3T3ZlcnJpZGVTdHlsZXNbXCJtYXgtd2lkdGhcIl0gPSBzdHlsZU1vbGVjdWxlLklzUG9zaXRpb25GaXhlZCAmJiBjdXJyZW50QXBwLnN0YXRlLmlzRGF0YUxvYWRlZCAmJiBjdXJyZW50QXBwLnN0YXRlLmlzRW5vdWdoQXZhaWxhYmxlU3BhY2VQYWdlUHJldmlldyAmJiBjdXJyZW50QXBwLnN0YXRlLmVkaXRWaWV3TW9kZSAhPT0gRWRpdFZpZXdNb2RlLlBhZ2VQcmV2aWV3T25seSA/IGAke2N1cnJlbnRBcHAuc3RhdGUudGFyZ2V0UGFnZVByZXZpZXdXaWR0aFB4fXB4YCA6IHVuZGVmaW5lZDsgLy8gVE9ETyBleHBlbnNpdmUgVE9ETyBkdXBsaWNhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlc1tcImxlZnRcIl0gPSBzdHlsZU1vbGVjdWxlLklzUG9zaXRpb25GaXhlZCAmJiBzdHlsZU1vbGVjdWxlLkxlZnRDc3NWYWx1ZVB4ICE9PSB1bmRlZmluZWQgPyBgJHtwYXJzZUludChzdHlsZU1vbGVjdWxlLkxlZnRDc3NWYWx1ZVB4KSArIGN1cnJlbnRBcHAuc3RhdGUudGFyZ2V0UGFnZVByZXZpZXdIb2xkZXJNYXJnaW5QeH1weGAgOiB1bmRlZmluZWQ7IC8vIFRPRE8gZXhwZW5zaXZlIC8vIFRPRE8gZGFuZ2Vyb3VzIC8vIFRPRE8gbWFnaWMgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzRWRpdGVkTGF5b3V0QXRvbUlkOiBib29sZWFuID0gc291cmNlLkxheW91dEJhc2VJZCA9PSBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLmVkaXRlZExheW91dEF0b21JZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlc1tcInotaW5kZXhcIl0gPSBpc0VkaXRlZExheW91dEF0b21JZCA/IFwiMzBcIiA6IHVuZGVmaW5lZDsgLy8gVE9ETyBkb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRWRpdGVkTGF5b3V0QXRvbUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG93IGlucHV0IGZpZWxkIGluc3RlYWQgb2YgcmVuZGVyZWQgYXRvbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDx0ZXh0YXJlYSBrZXk9e2BpJHtzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmd9YH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz17bGF5b3V0QXRvbVN0eWxlQ2xhc3N9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2N1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwudGVtcENvbnRlbnR9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25pbnB1dD17Y3VycmVudFBhZ2VQcmV2aWV3LmNvbnRlbnRBdG9tSW5wdXRIYW5kbGVyfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uYmx1cj17Y3VycmVudFBhZ2VQcmV2aWV3LmNvbnRlbnRBdG9tTG9zdEZvY3VzSGFuZGxlcn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmtleWRvd249e2N1cnJlbnRQYWdlUHJldmlldy5jb250ZW50QXRvbUtleURvd25IYW5kbGVyfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyQ3JlYXRlPXtjdXJyZW50UGFnZVByZXZpZXcuY29udGVudEF0b21BZnRlckNyZWF0ZUhhbmRsZXJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJVcGRhdGU9e2N1cnJlbnRQYWdlUHJldmlldy5jb250ZW50QXRvbUFmdGVyVXBkYXRlSGFuZGxlcn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0QW5pbWF0aW9uPXtjdXJyZW50UGFnZVByZXZpZXcuY29udGVudEF0b21FeGl0QW5pbWF0aW9uSGFuZGxlcn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaWQ9e3NvdXJjZUNvbnRlbnRBdG9tSWRTdHJpbmd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzPXtwYWdlUHJldmlld092ZXJyaWRlU3R5bGVzfT48L3RleHRhcmVhPiBhcyBWTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9zdGVkQ29udGVudEF0b20uQ29udGVudEF0b21UeXBlID09PSBDb250ZW50QXRvbVR5cGUuVGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGgobGF5b3V0QXRvbUh0bWxUYWcsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHNvdXJjZUxheW91dEF0b21JZFN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogbGF5b3V0QXRvbVN0eWxlQ2xhc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljazogY3VycmVudFBhZ2VQcmV2aWV3LmxheW91dEF0b21DbGlja0hhbmRsZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25kYmxjbGljazogY3VycmVudFBhZ2VQcmV2aWV3LmxheW91dEF0b21EYmxDbGlja0hhbmRsZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3VzdG9tIGh0bWwgZmllbGRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWlkOiBzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2lkOiBzb3VyY2VDb250ZW50QXRvbUlkU3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczogcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlckNyZWF0ZTogY3VycmVudFBhZ2VQcmV2aWV3LmxheW91dEF0b21BZnRlckNyZWF0ZUhhbmRsZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXJVcGRhdGU6IGN1cnJlbnRQYWdlUHJldmlldy5sYXlvdXRBdG9tQWZ0ZXJVcGRhdGVIYW5kbGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXRBbmltYXRpb246IGN1cnJlbnRQYWdlUHJldmlldy5sYXlvdXRBdG9tRXhpdEFuaW1hdGlvbkhhbmRsZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25tb3VzZWVudGVyOiBjdXJyZW50UGFnZVByZXZpZXcubGF5b3V0QXRvbU1vdXNlRW50ZXJIYW5kbGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ubW91c2VsZWF2ZTogY3VycmVudFBhZ2VQcmV2aWV3LmxheW91dEF0b21Nb3VzZUxlYXZlSGFuZGxlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW2hvc3RlZENvbnRlbnRBdG9tLlRleHRDb250ZW50XSkgLy8gVE9ETyBubyB1bnNldCB2YWx1ZSBmb3IgZGVsZXRlIFwiYW5pbWF0aW9uXCIgPSBzZXQgY29udGVudCB0byBudWxsIHRoZW4gZGVsZXRlIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSAvLyBUT0RPIHRoaXMgY291bGQgYmUgcHJlcGFyZWQgb24gc2VydmVyIGluIG9uZSBcInJlbmRlci9kaXNwbGF5IGNvbnRlbnQgZmllbGRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChob3N0ZWRDb250ZW50QXRvbS5Db250ZW50QXRvbVR5cGUgPT09IENvbnRlbnRBdG9tVHlwZS5MaW5rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaChsYXlvdXRBdG9tSHRtbFRhZywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogc291cmNlTGF5b3V0QXRvbUlkU3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBsYXlvdXRBdG9tU3R5bGVDbGFzcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrOiBjdXJyZW50UGFnZVByZXZpZXcubGF5b3V0QXRvbUNsaWNrSGFuZGxlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmRibGNsaWNrOiBjdXJyZW50UGFnZVByZXZpZXcubGF5b3V0QXRvbURibENsaWNrSGFuZGxlciwgLy8gVE9ETyBvcGVuIGxpbmsgaW4gbmV3IHRhYlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1c3RvbSBodG1sIGZpZWxkc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFpZDogc291cmNlTGF5b3V0QXRvbUlkU3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNpZDogc291cmNlQ29udGVudEF0b21JZFN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmOiBcIlwiLCAvLyBuZWVkIHRvIHNldCB0byB0cmlnZ2VyIGJyb3dzZXIgdXJsIHJlbmRlcmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczogcGFnZVByZXZpZXdPdmVycmlkZVN0eWxlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbm1vdXNlZW50ZXI6IGN1cnJlbnRQYWdlUHJldmlldy5sYXlvdXRBdG9tTW91c2VFbnRlckhhbmRsZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25tb3VzZWxlYXZlOiBjdXJyZW50UGFnZVByZXZpZXcubGF5b3V0QXRvbU1vdXNlTGVhdmVIYW5kbGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBbaG9zdGVkQ29udGVudEF0b20uVXJsXSkgLy8gVE9ETyBubyB1bnNldCB2YWx1ZSBmb3IgZGVsZXRlIFwiYW5pbWF0aW9uXCIgPSBzZXQgY29udGVudCB0byBudWxsIHRoZW4gZGVsZXRlIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKHVwZGF0ZWRTb3VyY2U6IExheW91dEF0b20pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gdXBkYXRlZFNvdXJjZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTGF5b3V0QXRvbUlkU3RyaW5nID0gc291cmNlLkxheW91dEJhc2VJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VDb250ZW50QXRvbUlkU3RyaW5nID0gc291cmNlLkhvc3RlZENvbnRlbnRBdG9tLkNvbnRlbnRBdG9tSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVNb2xlY3VsZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcy5maW5kKG0gPT4gbS5TdHlsZUZvckxheW91dElkID09IHNvdXJjZS5MYXlvdXRCYXNlSWQpIGFzIFN0eWxlTW9sZWN1bGU7IC8vIFRPRE8gZXhwZW5zaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0tLSBUT0RPIGNvZGUgZHVwbGljYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlTW9sZWN1bGUuSXNQb3NpdGlvbkZpeGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3BPdmVycmlkZVZhbHVlID0gYCR7c3R5bGVNb2xlY3VsZS5Ub3BDc3NWYWx1ZVB4fXB4YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcE92ZXJyaWRlVmFsdWUgPSBzdHlsZU1vbGVjdWxlLlRvcENzc1ZhbHVlUHggIT09IHVuZGVmaW5lZCA/IGAke2N1cnJlbnRBcHAubmF2aWdhdGlvbkhlaWd0aFB4fXB4YCA6IHVuZGVmaW5lZDsgLy8gVE9ETyBleHBlbnNpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0T3ZlcnJpZGVWYWx1ZSA9IGAke3N0eWxlTW9sZWN1bGUuTGVmdENzc1ZhbHVlUHh9cHhgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wT3ZlcnJpZGVWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcE92ZXJyaWRlVmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0T3ZlcnJpZGVWYWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAtLS0gVE9ETyBjb2RlIGR1cGxpY2F0aW9uIGVuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZU1vbGVjdWxlSWQgPSBzdHlsZU1vbGVjdWxlLlN0eWxlTW9sZWN1bGVJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVNb2xlY3VsZUlkU3RyaW5nID0gc3R5bGVNb2xlY3VsZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEF0b21TdHlsZUNsYXNzID0gYHMke3N0eWxlTW9sZWN1bGVJZH1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0ZWRDb250ZW50QXRvbSA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ29udGVudEF0b21zLmZpbmQoYyA9PiBjLkNvbnRlbnRBdG9tSWQgPT0gc291cmNlLkhvc3RlZENvbnRlbnRBdG9tLkNvbnRlbnRBdG9tSWQpIGFzIENvbnRlbnRBdG9tKTsgLy8gVE9ETyBleHBlbnNpdmUgKDIgY29waWVzIG9mIGNvbnRlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZU1vbGVjdWxlLkh0bWxUYWcgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEF0b21IdG1sVGFnID0gc3R5bGVNb2xlY3VsZS5IdG1sVGFnICE9PSB1bmRlZmluZWQgPyBzdHlsZU1vbGVjdWxlLkh0bWxUYWcgOiBcInBcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5QbGFjZWRBdG9tSW5Cb3guU3BlY2lhbExheW91dEJveFR5cGUgPT09IFNwZWNpYWxMYXlvdXRCb3hUeXBlLlJpY2hUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRBdG9tSHRtbFRhZyA9IFwic3BhblwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlU2VjdGlvblRhcmdldCh1cGRhdGVkU291cmNlOiBMYXlvdXRBdG9tLCB0YXJnZXQ6IHsgcmVuZGVyTWFxdWV0dGUoKTogYW55LCB1cGRhdGUodXBkYXRlZFNvdXJjZTogTGF5b3V0QXRvbSk6IHZvaWQgfSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnVwZGF0ZSh1cGRhdGVkU291cmNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgcmVzZXRDb250ZW50QXRvbUVkaXRNb2RlID0gKCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy5yZXNldEVxdWF0aW9uTnVtYmVyc1doZW5Nb2RpZnlpbmcoZmFsc2UpO1xyXG4gICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwuZWRpdGVkTGF5b3V0QXRvbUlkID0gMDtcclxuICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBDb250ZW50ID0gXCJcIjtcclxuICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBPcmlnaW5hbENvbnRlbnQgPSBcIlwiO1xyXG4gICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwuc3R5bGVzT2ZFZGl0ZWRDb250ZW50ID0ge307XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgY29udGVudEF0b21Mb3N0Rm9jdXNIYW5kbGVyID0gKGV2dDogRm9jdXNFdmVudCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy51cGRhdGVDb250ZW50QXRvbShwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJjaWRcIikpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIHVwZGF0ZUNvbnRlbnRBdG9tID0gKGNvbnRlbnRBdG9tSWQ6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGlmIChjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLmVkaXRlZExheW91dEF0b21JZCAhPSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBDb250ZW50ICE9PSBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBPcmlnaW5hbENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb250ZW50QXRvbTogQ29udGVudEF0b20gPSAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNvbnRlbnRBdG9tcy5maW5kKGEgPT4gYS5JbnN0YW5jZWRPbkxheW91dElkID09IGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwuZWRpdGVkTGF5b3V0QXRvbUlkKSBhcyBDb250ZW50QXRvbSk7IC8vIFRPRE8gZXhwZW5zaXZlIGJ1dCBmZWVscyBiZXR0ZXJcclxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50QXRvbS5Db250ZW50QXRvbVR5cGUgPT09IENvbnRlbnRBdG9tVHlwZS5UZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudEF0b20uVGV4dENvbnRlbnQgPSBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBDb250ZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGVudEF0b20uQ29udGVudEF0b21UeXBlID09PSBDb250ZW50QXRvbVR5cGUuTGluaykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRBdG9tLlVybCA9IGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwudGVtcENvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwudGVtcENvbnRlbnQgPT09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHRoaXMgY29kZSBwYXRoIHNob3VsZCBiZSBwb3NzaWJsZSB3aGVyZXZlciBjb250ZW50IGlzIHVwZGF0ZWQgKD8pIChpLmUuIGNoYWluZWQgY2FsbHMgd2l0aCBpbnNlcnQgYXRvbSlcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuRGVsZXRlTGF5b3V0SnNvbihjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLmVkaXRlZExheW91dEF0b21JZCwgZmFsc2UpLmRvbmUoKGRhdGE6IGFueSkgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBmb2N1cyBwcmV2aW91cyBsYXlvdXQgYXRvbSAoaW4gc2FtZSBib3g/IG9yIGFsbCBib3hlcyBhbmQgcHJldmlvdXMgc29ydG9yZGVyPylcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFJlYWR5U3RhdGUgPSBSZWFkeVN0YXRlLlBlbmRpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLlVwZGF0ZVRleHRDb250ZW50QXRvbUpzb24oY29udGVudEF0b21JZCwgY3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC50ZW1wQ29udGVudCkuZG9uZSgoZGF0YTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy5yZXNldEVxdWF0aW9uTnVtYmVyc1doZW5Nb2RpZnlpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLmFsd2F5cygoZGF0YTogYW55KSA9PiBjdXJyZW50QXBwLnN0YXRlLmN1cnJlbnRSZWFkeVN0YXRlID0gUmVhZHlTdGF0ZS5Payk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnJlc2V0Q29udGVudEF0b21FZGl0TW9kZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIGNvbnRlbnRBdG9tS2V5RG93bkhhbmRsZXIgPSAoZXZ0OiBLZXlib2FyZEV2ZW50KSA9PiB7IC8vIFRPRE8gY29kZSBkdXBsaWNhdGlvblxyXG4gICAgICAgIGlmIChldnQua2V5Q29kZSA9PSAxMyAvKkVOVEVSKi8pIHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGlmIChldnQuc2hpZnRLZXkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy5jb250ZW50QXRvbUNyZWF0ZU5ld0xpbmUocGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwiY2lkXCIpKTsgLy8gVE9ETyBtdWx0aXBsZSByZXF1ZXN0cyB3aGVuIGRhdGEgaGFzIGNoYW5nZWQgPT4gY29tYmluZWQgcmVxdWVzdCBjaGFpbjsgY3VycmVudGx5IHJlbGllcyBvbiBmdW5jdGlvbiBvcmRlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIChldnQudGFyZ2V0IGFzIEhUTUxUZXh0QXJlYUVsZW1lbnQpLmJsdXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXZ0LmtleUNvZGUgPT0gMjcgLypFU0MqLykge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnJlc2V0Q29udGVudEF0b21FZGl0TW9kZSgpO1xyXG4gICAgICAgICAgICAoZXZ0LnRhcmdldCBhcyBIVE1MVGV4dEFyZWFFbGVtZW50KS5ibHVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV2dC5rZXlDb2RlID09IHVuZGVmaW5lZCAvKnRleHQgYXJlYSBmb2N1cyBsb3N0Ki8pIHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE8gY2xlYW4gd2hpdGVzcGFjZXNcclxuICAgICAgICAvLyBUT0RPIGF1dG9zaXplXHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgY29udGVudEF0b21DcmVhdGVOZXdMaW5lID0gKGNvbnRlbnRBdG9tSWQ6IG51bWJlcik6IHZvaWQgPT4ge1xyXG4gICAgICAgIC8vIFRPRE8gdGFyZ2V0IGF0b20gdHlwZSBjb3VsZCBiZSBkZWZhdWx0IHR5cGUgZm9yIGJveCB0eXBlIChub25lID0+IHRleHQsIGxpc3QgPT4gbGlzdCBpdGVtLCAuLi4pIGJ1dCBkb2VzIG5vdCB3b3JrIGZvciBoZWFkaW5nc1xyXG4gICAgICAgIC8vIFRPRE8gdGFyZ2V0IGF0b20gdHlwZSBjb3VsZCBiZSB0aGF0IG9mIGN1cnJlbnQgZWRpdGVkIGxheW91dCBhdG9tXHJcbiAgICAgICAgaWYgKGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwuZWRpdGVkTGF5b3V0QXRvbUlkICE9IDApIHtcclxuICAgICAgICAgICAgbGV0IGVkaXRlZExheW91dEF0b206IExheW91dEF0b20gPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuTGF5b3V0TW9sZWN1bGVzLmZpbmQobCA9PiBsLkxheW91dEJhc2VJZCA9PSBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLmVkaXRlZExheW91dEF0b21JZCkgYXMgTGF5b3V0QXRvbTsgLy8gVE9ETyBleHBlbnNpdmVcclxuICAgICAgICAgICAgbGV0IGVkaXRlZExheW91dEF0b21JZENoYWluZWRDYWxsOiBudW1iZXIgPSBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLmVkaXRlZExheW91dEF0b21JZDtcclxuICAgICAgICAgICAgbGV0IHBsYWNlZEF0b21JbkJveElkQ2hhaW5lZENhbGw6IG51bWJlciA9IGVkaXRlZExheW91dEF0b20uUGxhY2VkQXRvbUluQm94SWQ7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBDb250ZW50ICE9PSBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBPcmlnaW5hbENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFJlYWR5U3RhdGUgPSBSZWFkeVN0YXRlLlBlbmRpbmc7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuVXBkYXRlVGV4dENvbnRlbnRBdG9tSnNvbihjb250ZW50QXRvbUlkLCBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBDb250ZW50KS5kb25lKChkYXRhOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcuY2hhaW5lZEFkZE1vdmVMYXlvdXRBdG9tQ2FsbFdpdGhGdWxsVXBkYXRlKHBsYWNlZEF0b21JbkJveElkQ2hhaW5lZENhbGwsIGVkaXRlZExheW91dEF0b21JZENoYWluZWRDYWxsKTsgICAgXHJcbiAgICAgICAgICAgICAgICB9KS5hbHdheXMoKGRhdGE6IGFueSkgPT4gY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50UmVhZHlTdGF0ZSA9IFJlYWR5U3RhdGUuT2spO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnJlc2V0Q29udGVudEF0b21FZGl0TW9kZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LmNoYWluZWRBZGRNb3ZlTGF5b3V0QXRvbUNhbGxXaXRoRnVsbFVwZGF0ZShwbGFjZWRBdG9tSW5Cb3hJZENoYWluZWRDYWxsLCBlZGl0ZWRMYXlvdXRBdG9tSWRDaGFpbmVkQ2FsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjaGFpbmVkQWRkTW92ZUxheW91dEF0b21DYWxsV2l0aEZ1bGxVcGRhdGUgPSAocGxhY2VkQXRvbUluQm94SWRDaGFpbmVkQ2FsbDogbnVtYmVyLCBlZGl0ZWRMYXlvdXRBdG9tSWRDaGFpbmVkQ2FsbDogbnVtYmVyKTogdm9pZCA9PiB7XHJcbiAgICAgICAgLy8gVE9ETyBzaG91bGQgYmUgb25lIGJpZyBiYWNrZW5kIG9wZXJhdGlvbiBvciBhZGQgdHJpZ2dlciB0byBiYWNrZW5kIHRvIHNhdmUgaW50ZXJtZWRpYXRlIGRhdGEgdHJhbnNmZXJcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuQ3JlYXRlTGF5b3V0QXRvbUZvckJveEpzb24ocGxhY2VkQXRvbUluQm94SWRDaGFpbmVkQ2FsbCwgZWRpdGVkTGF5b3V0QXRvbUlkQ2hhaW5lZENhbGwpLmRvbmUoKGRhdGFTdWI6IENhbGlmb3JuaWFDbGllbnRWaWV3TW9kZWwpID0+IHtcclxuICAgICAgICAgICAgbGV0IHN1YkJveEF0b21zOiBMYXlvdXRCYXNlW10gPSBkYXRhU3ViLkNhbGlmb3JuaWFQcm9qZWN0LkxheW91dE1vbGVjdWxlcy5maWx0ZXIobSA9PiBtLkxheW91dFR5cGUgPT09IExheW91dFR5cGUuQXRvbSAmJiAobSBhcyBMYXlvdXRBdG9tKS5QbGFjZWRBdG9tSW5Cb3hJZCA9PSBwbGFjZWRBdG9tSW5Cb3hJZENoYWluZWRDYWxsKTtcclxuICAgICAgICAgICAgbGV0IGNyZWF0ZWRMYXlvdXRNb2xlY3VsZUlkOiBudW1iZXIgPSBzdWJCb3hBdG9tc1tzdWJCb3hBdG9tcy5sZW5ndGggLSAxXS5MYXlvdXRCYXNlSWQ7IC8vIFRPRE8gd2lsZCBndWVzczogbGFzdCBlbnRyeSBpbiBsaXN0IGlzIHRoZSBjcmVhdGVkIGF0b21cclxuICAgICAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLk1vdmVMYXlvdXRNb2xlY3VsZU5leHRUb0xheW91dE1vbGVjdWxlSnNvbihjcmVhdGVkTGF5b3V0TW9sZWN1bGVJZCwgZWRpdGVkTGF5b3V0QXRvbUlkQ2hhaW5lZENhbGwsIHRydWUpLmRvbmUoKGRhdGFTdWJTdWI6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLk1vdmVMYXlvdXRNb2xlY3VsZU5leHRUb0xheW91dE1vbGVjdWxlSnNvbihlZGl0ZWRMYXlvdXRBdG9tSWRDaGFpbmVkQ2FsbCwgY3JlYXRlZExheW91dE1vbGVjdWxlSWQsIHRydWUpLmRvbmUoKGRhdGFTdWJTdWJTdWI6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YVN1YlN1YlN1Yik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhvc3RlZENvbnRlbnRBdG9tOiBDb250ZW50QXRvbSA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ29udGVudEF0b21zLmZpbmQoYyA9PiBjLkluc3RhbmNlZE9uTGF5b3V0SWQgPT0gY3JlYXRlZExheW91dE1vbGVjdWxlSWQpIGFzIENvbnRlbnRBdG9tKTsgLy8gVE9ETyBleHBlbnNpdmUgKDIgY29waWVzIG9mIGNvbnRlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC50ZW1wQ29udGVudCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC50ZW1wT3JpZ2luYWxDb250ZW50ID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaG9zdGVkQ29udGVudEF0b20uQ29udGVudEF0b21UeXBlID09PSBDb250ZW50QXRvbVR5cGUuVGV4dCkgeyAvLyBUT0RPIGNvZGUgZHVwbGljYXRpb24gZm9yIGNvbnRlbnQgc2VsZWN0aW9uIGF0IG11bHRpcGxlIHBsYWNlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBPcmlnaW5hbENvbnRlbnQgPSBob3N0ZWRDb250ZW50QXRvbS5UZXh0Q29udGVudCBhcyBzdHJpbmc7IC8vIFRPRE8gZGVmYXVsdCB0ZXh0IHNob3VsZCBiZSBlbXB0eSB3aGVuIGNyZWF0aW5nIGEgbmV3IGVsZW1lbnQgd2l0aCBzaG9ydGN1dCAocHJlc3NpbmcgZXNjYXBlIGxlYXZlcyBlbGVtZW50IHdpdGggZGVmYXVsdCB0ZXh0IGluc3RlYWQgb2YgcmVtb3ZpbmcgaXQgYWdhaW4pXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhvc3RlZENvbnRlbnRBdG9tLkNvbnRlbnRBdG9tVHlwZSA9PT0gQ29udGVudEF0b21UeXBlLkxpbmspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC50ZW1wT3JpZ2luYWxDb250ZW50ID0gaG9zdGVkQ29udGVudEF0b20uVXJsIGFzIHN0cmluZztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLmVkaXRlZExheW91dEF0b21JZCA9IGNyZWF0ZWRMYXlvdXRNb2xlY3VsZUlkO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIGNvbnRlbnRBdG9tQWZ0ZXJDcmVhdGVIYW5kbGVyID0gKGVsZW1lbnQ6IEVsZW1lbnQsIHByb2plY3Rpb25PcHRpb25zOiBtYXF1ZXR0ZS5Qcm9qZWN0aW9uT3B0aW9ucywgdm5vZGVTZWxlY3Rvcjogc3RyaW5nLCBwcm9wZXJ0aWVzOiBtYXF1ZXR0ZS5WTm9kZVByb3BlcnRpZXMsIGNoaWxkcmVuOiBWTm9kZVtdKSA9PiB7XHJcbiAgICAgICAgbGV0IHRhcmdldEVsZW1lbnQ6IEhUTUxUZXh0QXJlYUVsZW1lbnQgPSBlbGVtZW50IGFzIEhUTUxUZXh0QXJlYUVsZW1lbnQ7XHJcbiAgICAgICAgJCh0YXJnZXRFbGVtZW50KS5jc3MoY3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC5zdHlsZXNPZkVkaXRlZENvbnRlbnQpO1xyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLmlzU2VsZWN0QWxsVGV4dEFyZWEgPT09IHRydWUpIHsgLy8gVE9ETyBkb2VzIG5vdCB3b3JrIHdpdGggY2xpY2svZGJsY2xpY2sgZGlmZmVyZW50aWF0aW9uIGJlY2F1c2UgY2xpY2sgYWx3YXlzIGZpcmVzIGJlZm9yZSBkYmxjbGljayA9PiB1c2UgdGltZW91dCBvciBkaWZmZXJlbnRpYXRlIHByZXNlbGVjdGlvbiB3aXNoIHdpdGggdWkgc3RhdGVcclxuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZSgwLCBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBDb250ZW50Lmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRhcmdldEVsZW1lbnQuZm9jdXMoKTsgLy9UT0RPIGRvZXMgbm90IHdvcmsgd2l0aCB0ZXh0IGFyZWEgKG9uIGlwaG9uZSkgLyBUT0RPIHRyeSByZW5kZXJOb3dcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBjb250ZW50QXRvbUFmdGVyVXBkYXRlSGFuZGxlciA9IChlbGVtZW50OiBFbGVtZW50LCBwcm9qZWN0aW9uT3B0aW9uczogbWFxdWV0dGUuUHJvamVjdGlvbk9wdGlvbnMsIHZub2RlU2VsZWN0b3I6IHN0cmluZywgcHJvcGVydGllczogbWFxdWV0dGUuVk5vZGVQcm9wZXJ0aWVzLCBjaGlsZHJlbjogVk5vZGVbXSkgPT4ge1xyXG4gICAgICAgIC8vIGRvIG5vdGhpbmdcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBjb250ZW50QXRvbUV4aXRBbmltYXRpb25IYW5kbGVyID0gKGVsZW1lbnQ6IEVsZW1lbnQsIHJlbW92ZUVsZW1lbnQ6ICgpID0+IHZvaWQsIHByb3BlcnRpZXM/OiBWTm9kZVByb3BlcnRpZXMpOiB2b2lkID0+IHtcclxuICAgICAgICByZW1vdmVFbGVtZW50KCk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBwcml2YXRlIGxheW91dEF0b21BZnRlckNyZWF0ZUhhbmRsZXIgPSAoZWxlbWVudDogRWxlbWVudCwgcHJvamVjdGlvbk9wdGlvbnM6IG1hcXVldHRlLlByb2plY3Rpb25PcHRpb25zLCB2bm9kZVNlbGVjdG9yOiBzdHJpbmcsIHByb3BlcnRpZXM6IG1hcXVldHRlLlZOb2RlUHJvcGVydGllcywgY2hpbGRyZW46IFZOb2RlW10pID0+IHtcclxuICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5pc0pheE9uKSB7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXRFbGVtZW50OiBIVE1MRWxlbWVudCA9IGVsZW1lbnQgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy5fYWN0aXZlVmlld0xheW91dEF0b21Eb21Ob2RlUmVmZXJlbmNlc1twcm9wZXJ0aWVzLmtleSBhcyBzdHJpbmddID0gdGFyZ2V0RWxlbWVudDtcclxuICAgICAgICAgICAgaWYgKHRhcmdldEVsZW1lbnQuaW5uZXJUZXh0LmluZGV4T2YoXCIkXCIpICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBNYXRoSmF4Lkh1Yi5RdWV1ZShbXCJUeXBlc2V0XCIsIE1hdGhKYXguSHViLCB0YXJnZXRFbGVtZW50XSk7IC8vIFRPRE8gdXNlIEh1Yi5RdWV1ZS5TdXNwZW5kXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgbGF5b3V0QXRvbUV4aXRBbmltYXRpb25IYW5kbGVyID0gKGVsZW1lbnQ6IEVsZW1lbnQsIHJlbW92ZUVsZW1lbnQ6ICgpID0+IHZvaWQsIHByb3BlcnRpZXM6IFZOb2RlUHJvcGVydGllcyk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGRlbGV0ZSBjdXJyZW50UGFnZVByZXZpZXcuX2FjdGl2ZVZpZXdMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXNbcHJvcGVydGllcy5rZXkgYXMgc3RyaW5nXTtcclxuICAgICAgICByZW1vdmVFbGVtZW50KCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgbGF5b3V0QXRvbU1vdXNlRW50ZXJIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCB0YXJnZXRFbGVtZW50OiBIVE1MRWxlbWVudCA9IGV2dC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmhvdmVyZWRQYWdlUHJldmlld0xheW91dEJhc2VJZCA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZSh0YXJnZXRFbGVtZW50LCBcImFpZFwiKTtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBsYXlvdXRBdG9tTW91c2VMZWF2ZUhhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5ob3ZlcmVkUGFnZVByZXZpZXdMYXlvdXRCYXNlSWQgPSAwO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcHJpdmF0ZSBsYXlvdXRBdG9tQWZ0ZXJVcGRhdGVIYW5kbGVyID0gKGVsZW1lbnQ6IEVsZW1lbnQsIHByb2plY3Rpb25PcHRpb25zOiBtYXF1ZXR0ZS5Qcm9qZWN0aW9uT3B0aW9ucywgdm5vZGVTZWxlY3Rvcjogc3RyaW5nLCBwcm9wZXJ0aWVzOiBtYXF1ZXR0ZS5WTm9kZVByb3BlcnRpZXMsIGNoaWxkcmVuOiBWTm9kZVtdKSA9PiB7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUuaXNKYXhPbikge1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0RWxlbWVudDogSFRNTEVsZW1lbnQgPSBlbGVtZW50IGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgICAgICB2YXIgbWF0aDogYW55ID0gTWF0aEpheC5IdWIuZ2V0QWxsSmF4KHRhcmdldEVsZW1lbnQpWzBdO1xyXG4gICAgICAgICAgICBpZiAobWF0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvKmxldCBsYXlvdXRBdG9tSWRTdHJpbmc6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHByb3BlcnRpZXNbXCJhaWRcIl07XHJcbiAgICAgICAgICAgICAgICBpZiAobGF5b3V0QXRvbUlkU3RyaW5nICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGVuYWJsZSB1cGRhdGVyICsgcmVudW1iZXI6IGRpc2FibGVkLCBiZWNhdXNlIG5lZWQgdG8gZXh0cmFjdCBtYXRoIGZyb20gdGV4dCBjb250ZW50LCBlbHNlIGRvdWJsZSBjb250ZW50IChvbmNlIG5vcm1hbCByZW5kZXIsIG9uY2UgYXMgbWF0aClcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGF5b3V0QXRvbUlkOiBudW1iZXIgPSBwYXJzZUludChsYXlvdXRBdG9tSWRTdHJpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudEFwcC5wcm9wZXJ0eUJhckNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldFZNOiBQcm9wZXJ0eUJhclZNID0gY3VycmVudEFwcC5wcm9wZXJ0eUJhcnNbaV0udmlld01vZGVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Vk0uZWRpdGVkTGF5b3V0QXRvbUlkID09IGxheW91dEF0b21JZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aEpheC5IdWIuUXVldWUoW1wiVGV4dFwiLCBtYXRoLCB0YXJnZXRWTS50ZW1wQ29udGVudF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy5yZXNldEVxdWF0aW9uTnVtYmVyc1doZW5Nb2RpZnlpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgICAgICAgICAgfSovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0RWxlbWVudC5pbm5lclRleHQuaW5kZXhPZihcIiRcIikgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gd2h5IGlzIHRoZSBmb3JtdWxhIGRlc3Ryb3llZCB3aGVuIHRoZSByZW5kZXJlZCBjb250ZW50IGNoYW5nZXMgPT4gdHJpZ2dlciBmb3JtdWxhIHVwZGF0ZSBpbnN0ZWFkXHJcbiAgICAgICAgICAgICAgICBNYXRoSmF4Lkh1Yi5RdWV1ZShbXCJUeXBlc2V0XCIsIE1hdGhKYXguSHViLCB0YXJnZXRFbGVtZW50XSk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcucmVzZXRFcXVhdGlvbk51bWJlcnNXaGVuTW9kaWZ5aW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE8gYWxzbyBzdXBwb3J0cyByZXJlbmRlciAob25seSB3aGVuIGNzcyBjaGFuZ2VzKVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBjb250ZW50QXRvbUlucHV0SGFuZGxlciA9IChldnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBDb250ZW50ID0gKGV2dC50YXJnZXQgYXMgSFRNTFRleHRBcmVhRWxlbWVudCkudmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgbGF5b3V0QXRvbURibENsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTsgLy8gVE9ETyB0aGlzIGlzIHNldCBmb3IgZXZlcnkgY29udGVudCBhdG9tIGluIHByZXZpZXcuLi4gcGVyZm9ybWFuY2U/XHJcbiAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFJlYWR5U3RhdGUgIT09IFJlYWR5U3RhdGUuT2spIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwZW5kaW5nLi4uXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLmN1cnJlbnRTZWxlY3Rpb25Nb2RlID09PSBTZWxlY3Rpb25Nb2RlLkNvbnRlbnQpIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldEVsZW1lbnQ6IEhUTUxFbGVtZW50ID0gZXZ0LmN1cnJlbnRUYXJnZXQgYXMgSFRNTEVsZW1lbnQ7ICAvLyBoYWQgdG8gYmUgY3VycmVudFRhcmdldCBhZnRlciBpbm5lckh0bWwgd2FzIG1hbmlwdWxhdGVkIHVzaW5nIG1hdGhqYXggLy8gVE9ETyBjb2RlIGR1cGxpY2F0aW9uXHJcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwuc3R5bGVzT2ZFZGl0ZWRDb250ZW50ID0gY3VycmVudFBhZ2VQcmV2aWV3LmdldFN0eWxlT2JqZWN0KHRhcmdldEVsZW1lbnQpOyAvLyBUT0RPIGRvZXMgdGhpcyBoYXZlIHRvIGJlIGV2ZXJ5d2hlcmUgaS5lLiBhbmltYXRpb25zP1xyXG4gICAgICAgICAgICBsZXQgY29udGVudElkOiBudW1iZXIgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUodGFyZ2V0RWxlbWVudCwgXCJjaWRcIik7XHJcbiAgICAgICAgICAgIGxldCBsYXlvdXRJZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKHRhcmdldEVsZW1lbnQsIFwiYWlkXCIpO1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0V2lkdGg6IG51bWJlciA9IHRhcmdldEVsZW1lbnQuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXRIZWlnaHQ6IG51bWJlciA9IHRhcmdldEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgICAgICBsZXQgbWF4SXRlcmF0aW9uczogbnVtYmVyID0gMTA7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50SXRlcmF0aW9uOiBudW1iZXIgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudEl0ZXJhdGlvbisrIDwgbWF4SXRlcmF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldFdpZHRoID09IDAgfHwgdGFyZ2V0SGVpZ2h0ID09IDApIHsgLy8gaGFwcGVucyBmb3IgPHNwYW4+IGluc2lkZSByaWNoIHRleHRcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RWxlbWVudC5wYXJlbnRFbGVtZW50ICE9PSBudWxsKSB7IC8vIFRPRE8gcmVjdXJzaXZlIHdoaWxlIGxvb3AgbWF4IDEwIGl0ZXJhdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0V2lkdGggPSB0YXJnZXRFbGVtZW50LnBhcmVudEVsZW1lbnQuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEhlaWdodCA9IHRhcmdldEVsZW1lbnQucGFyZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQgPSB0YXJnZXRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy5sYXlvdXRBdG9tVG9UZXh0QXJlYVNldHVwKGNvbnRlbnRJZCwgbGF5b3V0SWQsIHRydWUsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVE9ET1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBsYXlvdXRBdG9tQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBUT0RPIHRoaXMgaXMgc2V0IGZvciBldmVyeSBjb250ZW50IGF0b20gaW4gcHJldmlldy4uLiBwZXJmb3JtYW5jZT9cclxuICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50UmVhZHlTdGF0ZSAhPT0gUmVhZHlTdGF0ZS5Paykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInBlbmRpbmcuLi5cIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFNlbGVjdGlvbk1vZGUgPT09IFNlbGVjdGlvbk1vZGUuQ29udGVudCkge1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0RWxlbWVudDogSFRNTEVsZW1lbnQgPSBldnQuY3VycmVudFRhcmdldCBhcyBIVE1MRWxlbWVudDsgIC8vIGhhZCB0byBiZSBjdXJyZW50VGFyZ2V0IGFmdGVyIGlubmVySHRtbCB3YXMgbWFuaXB1bGF0ZWQgdXNpbmcgbWF0aGpheCAvLyBUT0RPIGNvZGUgZHVwbGljYXRpb25cclxuICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC5zdHlsZXNPZkVkaXRlZENvbnRlbnQgPSBjdXJyZW50UGFnZVByZXZpZXcuZ2V0U3R5bGVPYmplY3QodGFyZ2V0RWxlbWVudCk7IC8vIFRPRE8gZG9lcyB0aGlzIGhhdmUgdG8gYmUgZXZlcnl3aGVyZSBpLmUuIGFuaW1hdGlvbnM/XHJcbiAgICAgICAgICAgIGxldCBjb250ZW50SWQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZSh0YXJnZXRFbGVtZW50LCBcImNpZFwiKTtcclxuICAgICAgICAgICAgbGV0IGxheW91dElkOiBudW1iZXIgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUodGFyZ2V0RWxlbWVudCwgXCJhaWRcIik7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXRXaWR0aDogbnVtYmVyID0gdGFyZ2V0RWxlbWVudC5jbGllbnRXaWR0aDtcclxuICAgICAgICAgICAgbGV0IHRhcmdldEhlaWdodDogbnVtYmVyID0gdGFyZ2V0RWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgICAgIGxldCBtYXhJdGVyYXRpb25zOiBudW1iZXIgPSAxMDtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRJdGVyYXRpb246IG51bWJlciA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50SXRlcmF0aW9uKysgPCBtYXhJdGVyYXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0V2lkdGggPT0gMCB8fCB0YXJnZXRIZWlnaHQgPT0gMCkgeyAvLyBoYXBwZW5zIGZvciA8c3Bhbj4gaW5zaWRlIHJpY2ggdGV4dCAvLyBUT0RPIHJlYWQgcGFkZGluZyBvciBvZmZzZXQgb2YgZmlyc3Qgd29yZCBpbiBhIHJpY2ggdGV4dCBhbmQgaW5zZXJ0IGZha2Ugd2hpdGVzcGFjZSBpbiB0aGUgaW5wdXQgZmllbGRcclxuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBpbnB1dCBmaWVsZCBpcyByZWN0YW5ndWxhciBhbmQgdGhlbiByZW5kZXJlZCBjb21wbGV0ZWx5IGJlbG93IHRoZSBwcmVjZWRpbmcgdGV4dCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEVsZW1lbnQucGFyZW50RWxlbWVudCAhPT0gbnVsbCkgeyAvLyBUT0RPIHJlY3Vyc2l2ZSB3aGlsZSBsb29wIG1heCAxMCBpdGVyYXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFdpZHRoID0gdGFyZ2V0RWxlbWVudC5wYXJlbnRFbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRIZWlnaHQgPSB0YXJnZXRFbGVtZW50LnBhcmVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50ID0gdGFyZ2V0RWxlbWVudC5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcubGF5b3V0QXRvbVRvVGV4dEFyZWFTZXR1cChjb250ZW50SWQsIGxheW91dElkLCB0cnVlLCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE9cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgbGF5b3V0QXRvbVRvVGV4dEFyZWFTZXR1cCA9IChjb250ZW50QXRvbUlkOiBudW1iZXIsIGxheW91dEF0b21JZDogbnVtYmVyLCBpc1ByZVNlbGVjdEFsbDogYm9vbGVhbiwgdGFyZ2V0V2lkdGhQeDogbnVtYmVyLCB0YXJnZXRIZWlnaHRQeDogbnVtYmVyKTogdm9pZCA9PiB7XHJcbiAgICAgICAgLy8gVE9ETyBnZXQgcG9zaXRpb24sIGhlaWdodCArIHdpZHRoIGFuZCBwbGFjZSBhcyBhYnNvbHV0ZSBhYm92ZSBlZGl0ZWQgbGF5b3V0IChubyByZXBsYWNlbWVudCBlbGVtZW50KVxyXG4gICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuaXNTZWxlY3RBbGxUZXh0QXJlYSA9IGlzUHJlU2VsZWN0QWxsO1xyXG4gICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwuc3R5bGVzT2ZFZGl0ZWRDb250ZW50W1wib3V0bGluZVwiXSA9IFwic29saWQgMXB4IHJnYigyMDAsMjAwLDIwMClcIjsgLy8gdGV4dCBhcmVhIGNhbid0IGZvY3VzIGRpcmVjdGx5IG9uIGlQaG9uZSA9PiBzaG93IGludGVybWVkaWF0ZSBzdGF0ZSBUT0RPIHRyeSByZW5kZXJOb3coKVxyXG4gICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwuc3R5bGVzT2ZFZGl0ZWRDb250ZW50W1wib3V0bGluZS1vZmZzZXRcIl0gPSBcIi0xcHhcIjtcclxuICAgICAgICAvLyBrZWVwIHNwYWNlIGZvciByZW5kZXJlZCBmb250cyB0aGUgc2FtZSAoYWRkIHNwYWNlIGZvciBzY3JvbGxiYXIgb2YgdGV4dGFyZWEpXHJcbiAgICAgICAgaWYgKGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwuc3R5bGVzT2ZFZGl0ZWRDb250ZW50W1wid2lkdGhcIl0gPT09IHVuZGVmaW5lZCB8fCBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnN0eWxlc09mRWRpdGVkQ29udGVudFtcImhlaWdodFwiXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIGFsd2F5cyBleHBlY3RlZCB0byBiZSBhbHJlYWR5IHNldCBieSBicm93c2VyIG9yIGNzc1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0V2lkdGhTdHJpbmc6IHN0cmluZyA9ICh0YXJnZXRXaWR0aFB4ID09IDAgPyAzMDAgOiB0YXJnZXRXaWR0aFB4KS50b1N0cmluZygpICsgXCJweFwiO1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0SGVpZ2h0U3RyaW5nOiBzdHJpbmcgPSAodGFyZ2V0SGVpZ2h0UHggPT0gMCA/IDMwMCA6IHRhcmdldEhlaWdodFB4KS50b1N0cmluZygpICsgXCJweFwiO1xyXG4gICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnN0eWxlc09mRWRpdGVkQ29udGVudFtcIndpZHRoXCJdID0gdGFyZ2V0V2lkdGhTdHJpbmc7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwuc3R5bGVzT2ZFZGl0ZWRDb250ZW50W1wibWluLXdpZHRoXCJdID0gdGFyZ2V0V2lkdGhTdHJpbmc7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwuc3R5bGVzT2ZFZGl0ZWRDb250ZW50W1wiaGVpZ2h0XCJdID0gdGFyZ2V0SGVpZ2h0U3RyaW5nO1xyXG4gICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnN0eWxlc09mRWRpdGVkQ29udGVudFtcIm1pbi1oZWlnaHRcIl0gPSB0YXJnZXRIZWlnaHRTdHJpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBob3N0ZWRDb250ZW50QXRvbTogQ29udGVudEF0b20gPSAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNvbnRlbnRBdG9tcy5maW5kKGMgPT4gYy5Db250ZW50QXRvbUlkID09IGNvbnRlbnRBdG9tSWQpIGFzIENvbnRlbnRBdG9tKTsgLy8gVE9ETyBleHBlbnNpdmUgKDIgY29waWVzIG9mIGNvbnRlbnQpXHJcbiAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC50ZW1wQ29udGVudCA9IFwiXCI7XHJcbiAgICAgICAgaWYgKGhvc3RlZENvbnRlbnRBdG9tLkNvbnRlbnRBdG9tVHlwZSA9PT0gQ29udGVudEF0b21UeXBlLlRleHQpIHsgLy8gVE9ETyBjb2RlIGR1cGxpY2F0aW9uIGZvciBjb250ZW50IHNlbGVjdGlvbiBhdCBtdWx0aXBsZSBwbGFjZXNcclxuICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnZpZXdNb2RlbC50ZW1wQ29udGVudCA9IGhvc3RlZENvbnRlbnRBdG9tLlRleHRDb250ZW50IGFzIHN0cmluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaG9zdGVkQ29udGVudEF0b20uQ29udGVudEF0b21UeXBlID09PSBDb250ZW50QXRvbVR5cGUuTGluaykge1xyXG4gICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBDb250ZW50ID0gaG9zdGVkQ29udGVudEF0b20uVXJsIGFzIHN0cmluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBPcmlnaW5hbENvbnRlbnQgPSBjdXJyZW50UGFnZVByZXZpZXcudmlld01vZGVsLnRlbXBDb250ZW50O1xyXG4gICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy52aWV3TW9kZWwuZWRpdGVkTGF5b3V0QXRvbUlkID0gbGF5b3V0QXRvbUlkO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcHJpdmF0ZSBnZXRTdHlsZU9iamVjdCA9ICh0YXJnZXRFbGVtZW50OiBIVE1MRWxlbWVudCk6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPT4ge1xyXG4gICAgICAgIHZhciBkb20gPSAkKHRhcmdldEVsZW1lbnQpLmdldCgwKTtcclxuICAgICAgICB2YXIgc3R5bGU7XHJcbiAgICAgICAgdmFyIHJldHVybnM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcclxuICAgICAgICAvL2lmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSkge1xyXG4gICAgICAgIHZhciBjYW1lbGl6ZSA9IGZ1bmN0aW9uIChhOiBzdHJpbmcsIGI6IHN0cmluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gYi50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20sIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdHlsZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHByb3AgPSBzdHlsZVtpXTtcclxuICAgICAgICAgICAgdmFyIGNhbWVsID0gcHJvcC5yZXBsYWNlKC9cXC0oW2Etel0pL2csIGNhbWVsaXplKTtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcCk7XHJcbiAgICAgICAgICAgIHJldHVybnNbY2FtZWxdID0gdmFsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHJldHVybnM7XHJcbiAgICAgICAgLy99O1xyXG4gICAgICAgIC8qaWYgKHN0eWxlID0gZG9tLmN1cnJlbnRTdHlsZSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm5zW3Byb3BdID0gc3R5bGVbcHJvcF07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiByZXR1cm5zO1xyXG4gICAgICAgIH07Ki9cclxuICAgICAgICAvL3JldHVybiAkKHRhcmdldEVsZW1lbnQpLmNzcygpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgbWFwQW5kUmVuZGVyTGF5b3V0Qm94Q29udGVudCA9IChyZWZMYXlvdXRCb3g6IExheW91dEJveCwgLy8gVE9ETyBtYXJrIGFzIHN0YXRpYyAvIG5vIHNpZGUgZWZmZWN0c1xyXG4gICAgICAgIHVuc29ydGVkQXRvbXM6IExheW91dEF0b21bXSwgYXRvbU1hcHBpbmc6IG1hcXVldHRlLk1hcHBpbmc8TGF5b3V0QXRvbSwgeyByZW5kZXJNYXF1ZXR0ZTogKCkgPT4gbWFxdWV0dGUuVk5vZGUgfT4sXHJcbiAgICAgICAgdW5zb3J0ZWRCb3hlczogTGF5b3V0Qm94W10sIGJveE1hcHBpbmc6IG1hcXVldHRlLk1hcHBpbmc8TGF5b3V0Qm94LCB7IHJlbmRlck1hcXVldHRlOiAoKSA9PiBtYXF1ZXR0ZS5WTm9kZSB9Pik6IFZOb2RlW10gPT4ge1xyXG4gICAgICAgIGlmICh1bnNvcnRlZEF0b21zLmxlbmd0aCA9PSAwICYmIHVuc29ydGVkQm94ZXMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdOyAvLyBbPHAga2V5PVwiMFwiPkFkZCBhdG9tcy4uLjwvcD4gYXMgVk5vZGVdOyBUT0RPXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgc29ydGVkQXRvbXM6IExheW91dEF0b21bXSA9IHVuc29ydGVkQXRvbXMuc29ydCgoYXRvbUE6IExheW91dEF0b20sIGF0b21COiBMYXlvdXRBdG9tKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChhdG9tQS5MYXlvdXRTb3J0T3JkZXJLZXkgPCBhdG9tQi5MYXlvdXRTb3J0T3JkZXJLZXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhdG9tQS5MYXlvdXRTb3J0T3JkZXJLZXkgPT0gYXRvbUIuTGF5b3V0U29ydE9yZGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHsgLy8gYXRvbUEuTGF5b3V0U29ydE9yZGVyS2V5ID4gYXRvbUIuTGF5b3V0U29ydE9yZGVyS2V5XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCBzb3J0ZWRCb3hlczogTGF5b3V0Qm94W10gPSB1bnNvcnRlZEJveGVzLnNvcnQoKGJveEE6IExheW91dEJveCwgYm94QjogTGF5b3V0Qm94KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChib3hBLkxheW91dFNvcnRPcmRlcktleSA8IGJveEIuTGF5b3V0U29ydE9yZGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYm94QS5MYXlvdXRTb3J0T3JkZXJLZXkgPT0gYm94Qi5MYXlvdXRTb3J0T3JkZXJLZXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgeyAvLyBib3hBLkxheW91dFNvcnRPcmRlcktleSA+IGJveEIuTGF5b3V0U29ydE9yZGVyS2V5XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGF0b21NYXBwaW5nLm1hcChzb3J0ZWRBdG9tcyk7XHJcbiAgICAgICAgYm94TWFwcGluZy5tYXAoc29ydGVkQm94ZXMpO1xyXG4gICAgICAgIC8vIGV4cGVjdHMgYXRvbXMgYW5kIGJveGVzIHNvcnRlZCBieSBMYXlvdXRTb3J0T3JkZXJLZXkgYW5kIG1hcHBpbmdzIGluIHRoZSBzYW1lIG9yZGVyXHJcbiAgICAgICAgbGV0IHJlbmRlcmVkQXRvbXNBbmRCb3hlczogVk5vZGVbXSA9IFtdO1xyXG4gICAgICAgIGxldCBhdG9tSW5kZXg6IG51bWJlciA9IDA7XHJcbiAgICAgICAgbGV0IGJveEluZGV4OiBudW1iZXIgPSAwO1xyXG4gICAgICAgIGxldCBhdG9tc0xlbmd0aDogbnVtYmVyID0gc29ydGVkQXRvbXMubGVuZ3RoO1xyXG4gICAgICAgIGxldCBib3hlc0xlbmd0aDogbnVtYmVyID0gc29ydGVkQm94ZXMubGVuZ3RoO1xyXG4gICAgICAgIGxldCB0b3RhbEl0ZW1zOiBudW1iZXIgPSBhdG9tc0xlbmd0aCArIGJveGVzTGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxJdGVtczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50QXRvbTogTGF5b3V0QXRvbSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRCb3g6IExheW91dEJveCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYgKGF0b21JbmRleCA8IGF0b21zTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QXRvbSA9IHNvcnRlZEF0b21zW2F0b21JbmRleF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJveEluZGV4IDwgYm94ZXNMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRCb3ggPSBzb3J0ZWRCb3hlc1tib3hJbmRleF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRBdG9tICE9PSB1bmRlZmluZWQgJiYgY3VycmVudEJveCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEF0b20uTGF5b3V0U29ydE9yZGVyS2V5IDwgY3VycmVudEJveC5MYXlvdXRTb3J0T3JkZXJLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZEF0b21zQW5kQm94ZXMucHVzaChhdG9tTWFwcGluZy5yZXN1bHRzW2F0b21JbmRleCsrXS5yZW5kZXJNYXF1ZXR0ZSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkQXRvbXNBbmRCb3hlcy5wdXNoKGJveE1hcHBpbmcucmVzdWx0c1tib3hJbmRleCsrXS5yZW5kZXJNYXF1ZXR0ZSgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50QXRvbSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVtYWluaW5nQXRvbXM6IG51bWJlciA9IGF0b21zTGVuZ3RoIC0gYXRvbUluZGV4O1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZW1haW5pbmdBdG9tczsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRBdG9tc0FuZEJveGVzLnB1c2goYXRvbU1hcHBpbmcucmVzdWx0c1thdG9tSW5kZXgrK10ucmVuZGVyTWFxdWV0dGUoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHsvLyBpZiAoY3VycmVudEJveCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVtYWluaW5nQm94ZXM6IG51bWJlciA9IGJveGVzTGVuZ3RoIC0gYm94SW5kZXg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlbWFpbmluZ0JveGVzOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZEF0b21zQW5kQm94ZXMucHVzaChib3hNYXBwaW5nLnJlc3VsdHNbYm94SW5kZXgrK10ucmVuZGVyTWFxdWV0dGUoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVuZGVyZWRBdG9tc0FuZEJveGVzO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgZ2V0Q3NzUnVsZU9mID0gKHN0eWxlTW9sZWN1bGU6IFN0eWxlTW9sZWN1bGUsIHJlc3BvbnNpdmVEZXZpY2U6IFJlc3BvbnNpdmVEZXZpY2UsIHN0YXRlTW9kaWZpZXI6IHN0cmluZyB8IHVuZGVmaW5lZCk6IHN0cmluZyA9PiB7XHJcbiAgICAgICAgLy9sZXQgcmVzcG9uc2l2ZVNldHRpbmc6IFJlYWN0b3JSZXNwb25zaXZlU2V0dGluZyA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5Vc2VyUmVzcG9uc2l2ZVNldHRpbmdzW3Jlc3BvbnNpdmVJZF07XHJcbiAgICAgICAgbGV0IHNlbGVjdG9yOiBzdHJpbmcgPSBgLnMke3N0eWxlTW9sZWN1bGUuU3R5bGVNb2xlY3VsZUlkfWA7XHJcbiAgICAgICAgaWYgKChzdGF0ZU1vZGlmaWVyID09PSB1bmRlZmluZWQpIHx8IChzdGF0ZU1vZGlmaWVyID09PSBcIlwiKSkge1xyXG4gICAgICAgICAgICBsZXQgc3R5bGVSdWxlOiBzdHJpbmcgPSBgJHtzZWxlY3Rvcn17YDtcclxuICAgICAgICAgICAgLy8gZWxlbWVudCBzdHlsZSBpcyB0YXJnZXRcclxuICAgICAgICAgICAgZm9yIChsZXQgc3R5bGVBdG9tTWFwcGluZyBvZiBzdHlsZU1vbGVjdWxlLk1hcHBlZFN0eWxlQXRvbXMuZmlsdGVyKHN0eWxlQXRvbU1hcCA9PiBzdHlsZUF0b21NYXAuUmVzcG9uc2l2ZURldmljZUlkID09IHJlc3BvbnNpdmVEZXZpY2UuUmVzcG9uc2l2ZURldmljZUlkICYmIChzdHlsZUF0b21NYXAuU3RhdGVNb2RpZmllciA9PT0gdW5kZWZpbmVkIHx8IHN0eWxlQXRvbU1hcC5TdGF0ZU1vZGlmaWVyID09PSBcIlwiKSkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzdHlsZUF0b21JZDogbnVtYmVyID0gKGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZUF0b21zLmZpbmQoYSA9PiBhLk1hcHBlZFRvTW9sZWN1bGVJZCA9PSBzdHlsZUF0b21NYXBwaW5nLlN0eWxlTW9sZWN1bGVBdG9tTWFwcGluZ0lkKSBhcyBTdHlsZUF0b20pLlN0eWxlQXRvbUlkOyAvLyBUT0RPIHNsb3dcclxuICAgICAgICAgICAgICAgIGxldCBhcHBsaWVkVmFsdWVzOiBTdHlsZVZhbHVlW10gPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVWYWx1ZXMuZmlsdGVyKHYgPT4gdi5TdHlsZUF0b21JZCA9PSBzdHlsZUF0b21JZCk7IC8vIFRPRE8gc2xvd1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY3NzUHJvcCBvZiBhcHBsaWVkVmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzc1Byb3AuQ3NzVmFsdWUgIT09IFwiXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVSdWxlICs9IGAke2Nzc1Byb3AuQ3NzUHJvcGVydHl9OiAke2Nzc1Byb3AuQ3NzVmFsdWV9O2A7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0eWxlUnVsZSArPSBcIn1cIjtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRQYWdlUHJldmlldy53cmFwQ3NzTWVkaWFRdWVyeShzdHlsZVJ1bGUsIHJlc3BvbnNpdmVEZXZpY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcHNldWRvIHN0eWxlIGlzIHRhcmdldFxyXG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBjc3MgZGVjbGFyYXRpb24gZm9yIHRhcmdldCBwc2V1ZG8gc3R5bGVcclxuICAgICAgICAgICAgbGV0IHBzZXVkb1N0eWxlUnVsZTogc3RyaW5nID0gYCR7c2VsZWN0b3J9JHtzdGF0ZU1vZGlmaWVyfXtgO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBwc2V1ZG9TdHlsZUF0b21NYXBwaW5nIG9mIHN0eWxlTW9sZWN1bGUuTWFwcGVkU3R5bGVBdG9tcy5maWx0ZXIoc3R5bGVBdG9tTWFwID0+IHN0eWxlQXRvbU1hcC5SZXNwb25zaXZlRGV2aWNlSWQgPT0gcmVzcG9uc2l2ZURldmljZS5SZXNwb25zaXZlRGV2aWNlSWQgJiYgc3R5bGVBdG9tTWFwLlN0YXRlTW9kaWZpZXIgPT09IHN0YXRlTW9kaWZpZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVBdG9tSWQ6IG51bWJlciA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVBdG9tcy5maW5kKGEgPT4gYS5NYXBwZWRUb01vbGVjdWxlSWQgPT0gcHNldWRvU3R5bGVBdG9tTWFwcGluZy5TdHlsZU1vbGVjdWxlQXRvbU1hcHBpbmdJZCkgYXMgU3R5bGVBdG9tKS5TdHlsZUF0b21JZDsgLy8gVE9ETyBzbG93XHJcbiAgICAgICAgICAgICAgICBsZXQgYXBwbGllZFZhbHVlczogU3R5bGVWYWx1ZVtdID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlVmFsdWVzLmZpbHRlcih2ID0+IHYuU3R5bGVBdG9tSWQgPT0gc3R5bGVBdG9tSWQpOyAvLyBUT0RPIHNsb3dcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNzc1Byb3Agb2YgYXBwbGllZFZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjc3NQcm9wLkNzc1ZhbHVlICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBzZXVkb1N0eWxlUnVsZSArPSBgJHtjc3NQcm9wLkNzc1Byb3BlcnR5fTogJHtjc3NQcm9wLkNzc1ZhbHVlfTtgO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwc2V1ZG9TdHlsZVJ1bGUgKz0gXCJ9XCI7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50UGFnZVByZXZpZXcud3JhcENzc01lZGlhUXVlcnkocHNldWRvU3R5bGVSdWxlLCByZXNwb25zaXZlRGV2aWNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgd3JhcENzc01lZGlhUXVlcnkgPSAoc3R5bGVSdWxlOiBzdHJpbmcsIHJlc3BvbnNpdmVEZXZpY2U6IFJlc3BvbnNpdmVEZXZpY2UpOiBzdHJpbmcgPT4ge1xyXG4gICAgICAgIC8vIGNzcyBmb3IgZGVmYXVsdCArIHNtYWxsZXN0IGRldmljZSAobW9kSW5kZXggMCwgMSkgYXJlIFwiY2xhc3NpY1wiIGNzcyBydWxlc1xyXG4gICAgICAgIGlmIChyZXNwb25zaXZlRGV2aWNlLldpZHRoVGhyZXNob2xkICE9PSB1bmRlZmluZWQgJiYgcmVzcG9uc2l2ZURldmljZS5XaWR0aFRocmVzaG9sZCA+IDApIHtcclxuICAgICAgICAgICAgLy8gbWVkaXVtIGRldmljZSArIC4uLiArIGxhcmdlc3QgZGV2aWNlIFwibWVkaWFcIiBjc3MgcnVsZXNcclxuICAgICAgICAgICAgcmV0dXJuIGBAbWVkaWEobWluLXdpZHRoOiR7Y3VycmVudFBhZ2VQcmV2aWV3LmR5bmFtaWNDbGllbnRHcmlkQnJlYWtwb2ludHNbY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzLmluZGV4T2YocmVzcG9uc2l2ZURldmljZSldfXB4KXske3N0eWxlUnVsZX19YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGRvbnQgd3JhcFxyXG4gICAgICAgICAgICByZXR1cm4gc3R5bGVSdWxlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGFwcGVuZFN0eWxlUnVsZXNGb3IgPSAoc3R5bGVNb2xlY3VsZTogU3R5bGVNb2xlY3VsZSwgc3R5bGVTaGVldDogQ1NTU3R5bGVTaGVldCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGxldCBydWxlSW5kZXg6IG51bWJlcjtcclxuICAgICAgICBsZXQgc3R5bGVSdWxlOiBzdHJpbmc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuUmVzcG9uc2l2ZURldmljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHJlc3BvbnNpdmVEZXZpY2UgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuUmVzcG9uc2l2ZURldmljZXNbaV07XHJcbiAgICAgICAgICAgIHJ1bGVJbmRleCA9IHN0eWxlU2hlZXQuY3NzUnVsZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBzdHlsZVJ1bGUgPSBjdXJyZW50UGFnZVByZXZpZXcuZ2V0Q3NzUnVsZU9mKHN0eWxlTW9sZWN1bGUsIHJlc3BvbnNpdmVEZXZpY2UsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIHN0eWxlU2hlZXQuaW5zZXJ0UnVsZShzdHlsZVJ1bGUsIHJ1bGVJbmRleCk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy52aXJ0dWFsU3R5bGVJbmRleFtpXVtzdHlsZU1vbGVjdWxlLlN0eWxlTW9sZWN1bGVJZF0gPSBydWxlSW5kZXg7XHJcblxyXG4gICAgICAgICAgICBsZXQgc3RhdGVNb2RpZmllcnM6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3R5bGVNb2xlY3VsZS5NYXBwZWRTdHlsZUF0b21zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVBdG9tTWFwID0gc3R5bGVNb2xlY3VsZS5NYXBwZWRTdHlsZUF0b21zW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlQXRvbU1hcC5SZXNwb25zaXZlRGV2aWNlSWQgPT0gcmVzcG9uc2l2ZURldmljZS5SZXNwb25zaXZlRGV2aWNlSWQgJiYgc3R5bGVBdG9tTWFwLlN0YXRlTW9kaWZpZXIgIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZU1vZGlmaWVycy5maW5kSW5kZXgocyA9PiBzID09PSBzdHlsZUF0b21NYXAuU3RhdGVNb2RpZmllcikgPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZU1vZGlmaWVycy5wdXNoKHN0eWxlQXRvbU1hcC5TdGF0ZU1vZGlmaWVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBzdGF0ZU1vZGlmaWVyIG9mIHN0YXRlTW9kaWZpZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAvL2lmIChzdGF0ZU1vZGlmaWVyID09PSBcIjpob3ZlclwiKSB7IC8vIFRPRE8gbXVzdCB3aGl0ZWxpc3QgYWNjZXB0YWJsZSBzZWxlY3RvcnMgb3IgYnJvd3NlciB0aHJvd3MgZXhjZXB0aW9uXHJcbiAgICAgICAgICAgICAgICBydWxlSW5kZXggPSBzdHlsZVNoZWV0LmNzc1J1bGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHN0eWxlUnVsZSA9IGN1cnJlbnRQYWdlUHJldmlldy5nZXRDc3NSdWxlT2Yoc3R5bGVNb2xlY3VsZSwgcmVzcG9uc2l2ZURldmljZSwgc3RhdGVNb2RpZmllcik7XHJcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0Lmluc2VydFJ1bGUoc3R5bGVSdWxlLCBydWxlSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LnZpcnR1YWxQc2V1ZG9TdHlsZUluZGV4W2ldW2Ake3N0eWxlTW9sZWN1bGUuU3R5bGVNb2xlY3VsZUlkfSR7c3RhdGVNb2RpZmllcn1gXSA9IHJ1bGVJbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlbG9hZENzc1N0eWxlcyA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgICBmb3IgKGxldCBpID0gY3VycmVudEFwcC5zdHlsZVNoZWV0LmNzc1J1bGVzLmxlbmd0aDsgaSA+IDA7IGktLSkge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0eWxlU2hlZXQuZGVsZXRlUnVsZShpIC0gMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlTW9sZWN1bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBzdHlsZU1vbGVjdWxlOiBTdHlsZU1vbGVjdWxlID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlTW9sZWN1bGVzW2ldO1xyXG4gICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcuYXBwZW5kU3R5bGVSdWxlc0ZvcihzdHlsZU1vbGVjdWxlLCBjdXJyZW50QXBwLnN0eWxlU2hlZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHVwZGF0ZVBhZ2VQcmV2aWV3RGltZW5zaW9ucyA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgICAvLyBjYWxjdWxhdGUgcGFnZSBwcmV2aWV3IGhvbGRlciB0YXJnZXQgd2lkdGggZm9yIG92ZXJyaWRkZW4gcmVzcG9uc2l2ZSBkZXZpY2VcclxuICAgICAgICBsZXQgc3RhdGljTWFyZ2luOiBudW1iZXIgPSBjdXJyZW50QXBwLnN0YXRlLmRlZmF1bHRTeW1tZXRyaWNQYWdlUHJldmlld0hvbGRlck1hcmdpblB4O1xyXG4gICAgICAgIGxldCB0YXJnZXRXaWR0aFB4OiBudW1iZXIgPSAwO1xyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLm92ZXJyaWRlUmVzcG9uc2l2ZURldmljZUlkID09IDApIHtcclxuICAgICAgICAgICAgLy8gZGVmYXVsdDogdXNlIGF2YWlsYWJsZSBzcGFjZSB0byBmaWxsIHZpZXdwb3J0IGhvcml6b250YWxseVxyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLnRhcmdldFBhZ2VQcmV2aWV3SG9sZGVyTWFyZ2luUHggPSBzdGF0aWNNYXJnaW47XHJcbiAgICAgICAgICAgIHRhcmdldFdpZHRoUHggPSBjdXJyZW50QXBwLnN0YXRlLmF2YWlsYWJsZVNwYWNlUGFnZVByZXZpZXdQeCAtIDIgKiBzdGF0aWNNYXJnaW47XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUudGFyZ2V0UGFnZVByZXZpZXdXaWR0aFB4ID0gdGFyZ2V0V2lkdGhQeDtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5pc0Vub3VnaEF2YWlsYWJsZVNwYWNlUGFnZVByZXZpZXcgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gc3BlY2lmaWMgcHJldmlldyBzaXplIHdhcyBzZXQgYnkgdXNlciA9PiBtb2RpZnkgdGFyZ2V0IHdpZHRoIGZvciBvdmVycmlkZGVuIHJlc3BvbnNpdmUgZGV2aWNlXHJcbiAgICAgICAgICAgIGxldCBvdmVycmlkZVdpdGhSZXNwb25zaXZlRGV2aWNlOiBSZXNwb25zaXZlRGV2aWNlID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzLmZpbmQociA9PiByLlJlc3BvbnNpdmVEZXZpY2VJZCA9PSBjdXJyZW50QXBwLnN0YXRlLm92ZXJyaWRlUmVzcG9uc2l2ZURldmljZUlkKSBhcyBSZXNwb25zaXZlRGV2aWNlO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5vdmVycmlkZVJlc3BvbnNpdmVEZXZpY2VJZCA9PSBjdXJyZW50QXBwLnN0YXRlLmhpZ2hlc3RXaWR0aFRocmVzaG9sZFJlc3BvbnNpdmVEZXZpY2VJZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gYWRkIDFweCB0byBoaWdoZXN0IHJlc3BvbnNpdmUgc2V0dGluZyB3aWR0aCB0aHJlc2hvbGQsIHN1Y2ggdGhhdCB0YXJnZXRXaWR0aCBpcyBoaWdoZXIgdGhhbiBoaWdoZXN0IHZhbHVlXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRXaWR0aFB4ID0gb3ZlcnJpZGVXaXRoUmVzcG9uc2l2ZURldmljZS5XaWR0aFRocmVzaG9sZCArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0UmVzcG9uc2l2ZVNldHRpbmdBYm92ZTogUmVzcG9uc2l2ZURldmljZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5SZXNwb25zaXZlRGV2aWNlc1tjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuUmVzcG9uc2l2ZURldmljZXMuaW5kZXhPZihvdmVycmlkZVdpdGhSZXNwb25zaXZlRGV2aWNlKSArIDFdOyAvLyByZWxpZXMgb24gc29ydGVkIGRldmljZXNcclxuICAgICAgICAgICAgICAgIHRhcmdldFdpZHRoUHggPSB0YXJnZXRSZXNwb25zaXZlU2V0dGluZ0Fib3ZlLldpZHRoVGhyZXNob2xkIC0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKGN1cnJlbnRBcHAuc3RhdGUuYXZhaWxhYmxlU3BhY2VQYWdlUHJldmlld1B4IC0gMiAqIHN0YXRpY01hcmdpbikgPj0gdGFyZ2V0V2lkdGhQeCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlbWFpbmluZ1NwYWNlUHg6IG51bWJlciA9ICgoY3VycmVudEFwcC5zdGF0ZS5hdmFpbGFibGVTcGFjZVBhZ2VQcmV2aWV3UHggLSAyICogc3RhdGljTWFyZ2luKSAtIHRhcmdldFdpZHRoUHgpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS50YXJnZXRQYWdlUHJldmlld0hvbGRlck1hcmdpblB4ID0gc3RhdGljTWFyZ2luICsgKHJlbWFpbmluZ1NwYWNlUHggLyAyKTsgLy8gVE9ETyBkbyB3ZSBuZWVkIGZsb29yPyAxcHggZXJyb3IgVE9ETyBhbHNvIGJyb3dzZXIgZGlzcGxheXMgd2lkdGggcGl4ZWxzIHdpdGggZnJhY3Rpb25cclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUudGFyZ2V0UGFnZVByZXZpZXdXaWR0aFB4ID0gY3VycmVudEFwcC5zdGF0ZS5hdmFpbGFibGVTcGFjZVBhZ2VQcmV2aWV3UHggLSByZW1haW5pbmdTcGFjZVB4O1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5pc0Vub3VnaEF2YWlsYWJsZVNwYWNlUGFnZVByZXZpZXcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmlzRW5vdWdoQXZhaWxhYmxlU3BhY2VQYWdlUHJldmlldyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS50YXJnZXRQYWdlUHJldmlld0hvbGRlck1hcmdpblB4ID0gc3RhdGljTWFyZ2luO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS50YXJnZXRQYWdlUHJldmlld1dpZHRoUHggPSB0YXJnZXRXaWR0aFB4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLmlzRGF0YUxvYWRlZCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudFJlc3BvbnNpdmVEZXZpY2VJbmRleCA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5SZXNwb25zaXZlRGV2aWNlcy5maW5kSW5kZXgociA9PiB0YXJnZXRXaWR0aFB4IDwgci5XaWR0aFRocmVzaG9sZCk7IC8vIGRlcGVuZHMgb24gc29ydCBvcmRlclxyXG4gICAgICAgICAgICBpZiAoY3VycmVudFJlc3BvbnNpdmVEZXZpY2VJbmRleCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0YXJnZXRXaWR0aFB4ID09IDBcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50UmVzcG9uc2l2ZURldmljZUluZGV4ID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBub3QgZm91bmQgPT4gbGFyZ2VyIHRoYW4gaGlnaGVzdFxyXG4gICAgICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50UmVzcG9uc2l2ZURldmljZUlkID0gY3VycmVudEFwcC5zdGF0ZS5oaWdoZXN0V2lkdGhUaHJlc2hvbGRSZXNwb25zaXZlRGV2aWNlSWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmN1cnJlbnRSZXNwb25zaXZlRGV2aWNlSWQgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuUmVzcG9uc2l2ZURldmljZXNbY3VycmVudFJlc3BvbnNpdmVEZXZpY2VJbmRleCAtIDFdLlJlc3BvbnNpdmVEZXZpY2VJZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYWRqdXN0IG1lZGlhIHF1ZXJ5IG1pbi13aWR0aHMgb2YgcGFnZSBwcmV2aWV3IHN0eWxlcywgc3VjaCB0aGF0IHBhZ2UgcHJldmlldyBzaG93cyByZXNwb25zaXZlIGRldmljZSB2aWV3OyBpbmRlcGVuZGVudCBvZiBjbGllbnQgd2lkdGggYW5kIFVJIHdpZHRoXHJcbiAgICAgICAgLy8gY3NzIG1lZGlhIHF1ZXJ5IHJlbmRlcmluZyBvcmRlciBvZiBicm93c2VycyBpcyBtb2JpbGUgZmlyc3QgKG5vIG1pbi13aWR0aCwgbWluLXdpZHRoXzEgPCBtaW4td2lkdGhfMiA8IC4uLilcclxuICAgICAgICAvLyBUT0RPIGNyZWF0ZSBkeW5hbWljIGNsaWVudCBicmVha3BvaW50cyBzdWNoIHRoYXQgYSBicm93c2VyIHJlc2l6ZSB0byBzbWFsbGVyIHZpZXcgZG9lcyBub3QgdHJpZ2dlciBzbWFsbGVyIGJyZWFrcG9pbnRzIGJlZm9yZSByZWNhbGN1bGF0aW5nIHVpIHNpemUgKyBjbGllbnQgYnJlYWtwb2ludHNcclxuICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcuZHluYW1pY0NsaWVudEdyaWRCcmVha3BvaW50cyA9IFtdO1xyXG4gICAgICAgIGxldCBjYWxpZm9ybmlhQXBwV2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZCA9ICQod2luZG93KS53aWR0aCgpOyAvLyBUT0RPIHVzZSBpbm5lciBvciBvdXRlciB3aWR0aFxyXG4gICAgICAgIGlmIChjYWxpZm9ybmlhQXBwV2lkdGggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNhbGlmb3JuaWFVSVdpZHRoID0gY2FsaWZvcm5pYUFwcFdpZHRoIC0gY3VycmVudEFwcC5zdGF0ZS5hdmFpbGFibGVTcGFjZVBhZ2VQcmV2aWV3UHg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuUmVzcG9uc2l2ZURldmljZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHJlc3BvbnNpdmVEZXZpY2U6IFJlc3BvbnNpdmVEZXZpY2UgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuUmVzcG9uc2l2ZURldmljZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChyZXNwb25zaXZlRGV2aWNlLldpZHRoVGhyZXNob2xkIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCArIHhzIGFyZSBkZWZhdWx0IGNzcyAobm8gbWVkaWEgcXVlcnkpIGFuZCBhbHdheXMgYXBwbGllZCAob3JkZXIgbWF0dGVycywgeHMgY3NzIG92ZXJ3cml0ZXMgZGVmYXVsdCBjc3MpXHJcbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0L05vbmUgPT0gLTE7IHNtYWxsZXN0IGRldmljZSA9PSAwXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcuZHluYW1pY0NsaWVudEdyaWRCcmVha3BvaW50cy5wdXNoKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNpdmVEZXZpY2UuV2lkdGhUaHJlc2hvbGQgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LmR5bmFtaWNDbGllbnRHcmlkQnJlYWtwb2ludHMucHVzaCgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlc3BvbnNpdmUgZGV2aWNlcyBnZXQgYW4gYWRqdXN0ZWQgdmFsdWUgZm9yIFdpZHRoVGhyZXNob2xkOiBsb3dlciB0aGFuIGN1cnJlbnQgY2xpZW50IHdpZHRoIGZvciBXaWR0aFRocmVzaG9sZCA8IGN1cnJlbnRSZXNwb25zaXZlRGV2aWNlLldpZHRoVGhyZXNob2xkOyBoaWdoZXIgdGhhbiBjbGllbnQgd2lkdGggZm9yIFdpZHRoVGhyZXNob2xkID4gY3VycmVudFJlc3BvbnNpdmVEZXZpY2UuV2lkdGhUaHJlc2hvbGQ7IG11c3QgYmUgc3RyaWN0bHkgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nXHJcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudERldmljZUluZGV4ID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzLmZpbmRJbmRleChyID0+IHIuUmVzcG9uc2l2ZURldmljZUlkID09IGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFJlc3BvbnNpdmVEZXZpY2VJZCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2FmZXR5TWFyZ2luUHg6IG51bWJlciA9IDUwOyAvLyBzY3JvbGwgYmFyXHJcbiAgICAgICAgICAgICAgICBpZiAoaSA8PSBjdXJyZW50RGV2aWNlSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYWRqdXN0ZWRCcmVha1BvaW50ID0gY2FsaWZvcm5pYUFwcFdpZHRoIC0gc2FmZXR5TWFyZ2luUHggLSAoKGN1cnJlbnREZXZpY2VJbmRleCArIDEgLSBpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhZ2VQcmV2aWV3LmR5bmFtaWNDbGllbnRHcmlkQnJlYWtwb2ludHMucHVzaChhZGp1c3RlZEJyZWFrUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFkanVzdGVkQnJlYWtQb2ludCA9IGNhbGlmb3JuaWFBcHBXaWR0aCArIHNhZmV0eU1hcmdpblB4ICsgKGkgLSBjdXJyZW50RGV2aWNlSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYWdlUHJldmlldy5keW5hbWljQ2xpZW50R3JpZEJyZWFrcG9pbnRzLnB1c2goYWRqdXN0ZWRCcmVha1BvaW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50UGFnZVByZXZpZXcucmVsb2FkQ3NzU3R5bGVzKCk7XHJcbiAgICB9O1xyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vTW9kZWxzL1BhZ2VQcmV2aWV3LnRzeCIsIlwidXNlIHN0cmljdFwiO1xyXG5pbXBvcnQgKiBhcyBtYXF1ZXR0ZSBmcm9tIFwibWFxdWV0dGVcIjtcclxuY29uc3QgaCA9IG1hcXVldHRlLmg7XHJcbmltcG9ydCB7IFBhZ2VQcmV2aWV3IH0gZnJvbSBcIi4vLi4vTW9kZWxzL1BhZ2VQcmV2aWV3XCI7XHJcbmltcG9ydCB7IENhbGlmb3JuaWFWaWV3LCBMYXlvdXRSb3cgfSBmcm9tIFwiLi4vTW9kZWxzL0NhbGlmb3JuaWFHZW5lcmF0ZWRcIjtcclxubGV0IGN1cnJlbnRWTTogUGFnZVByZXZpZXdWTTtcclxuXHJcbmV4cG9ydCBjbGFzcyBQYWdlUHJldmlld1ZNIHtcclxuICAgIC8vIGRhdGFcclxuICAgIHB1YmxpYyB0ZW1wT3JpZ2luYWxDb250ZW50OiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHVibGljIHRlbXBDb250ZW50OiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHVibGljIGVkaXRlZExheW91dEF0b21JZDogbnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBzdHlsZXNPZkVkaXRlZENvbnRlbnQ6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcclxuICAgIHB1YmxpYyBhY3RpdmVDYWxpZm9ybmlhVmlld0lkOiBudW1iZXIgPSAwO1xyXG4gICAgcHVibGljIGFjdGl2ZUNhbGlmb3JuaWFWaWV3Qm9keVN0eWxlU3RyaW5nOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHVibGljIGFjdGl2ZUNhbGlmb3JuaWFWaWV3U3R5bGVTdHJpbmc6IHN0cmluZyA9IFwiXCI7XHJcbiAgICAvLyBjb21wb25lbnRzXHJcbiAgICBwdWJsaWMgY2FsaWZvcm5pYVZpZXdQcm9qZWN0b3I6IG1hcXVldHRlLk1hcHBpbmc8Q2FsaWZvcm5pYVZpZXcsIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+O1xyXG4gICAgcHVibGljIGZpeGVkTGF5b3V0Um93c1Byb2plY3RvcjogbWFxdWV0dGUuTWFwcGluZzxMYXlvdXRSb3csIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+O1xyXG5cclxuICAgIC8vIGNsaWVudCBzZXR0aW5nc1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHBhZ2VQcmV2aWV3QXJnOiBQYWdlUHJldmlldykge1xyXG4gICAgICAgIGN1cnJlbnRWTSA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jYWxpZm9ybmlhVmlld1Byb2plY3RvciA9IHBhZ2VQcmV2aWV3QXJnLnJlbmRlckNhbGlmb3JuaWFWaWV3QXJyYXkoKTtcclxuICAgICAgICB0aGlzLmZpeGVkTGF5b3V0Um93c1Byb2plY3RvciA9IHBhZ2VQcmV2aWV3QXJnLnJlbmRlckxheW91dFJvd0FycmF5KHRydWUpO1xyXG4gICAgfTtcclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL1ZpZXdNb2RlbHMvUGFnZVByZXZpZXdWTS50c3giLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vanN4LnRzXCIgLz5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbmltcG9ydCB7IFZOb2RlLCBWTm9kZVByb3BlcnRpZXMgfSBmcm9tIFwibWFxdWV0dGVcIjtcclxuZGVjbGFyZSB2YXIgcmVxdWlyZTogYW55O1xyXG52YXIgdmVsb2NpdHk6IGFueSA9IHJlcXVpcmUoXCJ2ZWxvY2l0eS1hbmltYXRlXCIpO1xyXG5pbXBvcnQgKiBhcyBtYXF1ZXR0ZSBmcm9tIFwibWFxdWV0dGVcIjtcclxuY29uc3QgaCA9IG1hcXVldHRlLmg7XHJcbmltcG9ydCB7IENhbGlmb3JuaWFBcHAsIERFRkFVTFRfRVhDRVBUSU9OLCBnZXRBcnJheUZvckVudW0sIHBhcnNlSW50RnJvbUF0dHJpYnV0ZSwgcGFyc2VTdHJpbmdGcm9tQXR0cmlidXRlIH0gZnJvbSBcIi4vQ2FsaWZvcm5pYUFwcFwiO1xyXG5pbXBvcnQgeyBQcm9wZXJ0eUJhck1vZGUsIFByb3BlcnR5QmFyVk0sIFBvcHVwTW9kZSwgUG9wdXBTZWNvbmRhcnlNb2RlLCBUcmFuc2FjdGlvbk1vZGUgfSBmcm9tIFwiLi8uLi9WaWV3TW9kZWxzL1Byb3BlcnR5QmFyVk1cIjtcclxuaW1wb3J0IHsgU3R5bGVRdWFudHVtLCBTdHlsZUF0b20sIFN0eWxlVmFsdWUsIFN0eWxlQXRvbVR5cGUsIFN0eWxlTW9sZWN1bGUsIFJlc3BvbnNpdmVEZXZpY2UsIFN0eWxlTW9sZWN1bGVBdG9tTWFwcGluZywgTGF5b3V0QmFzZSwgTGF5b3V0Um93LCBMYXlvdXRCb3gsIExheW91dEF0b20sIExheW91dFR5cGUsIENhbGlmb3JuaWFWaWV3LCBTcGVjaWFsTGF5b3V0Qm94VHlwZSwgQ29udGVudEF0b20sIENhbGlmb3JuaWFFdmVudCB9IGZyb20gXCIuL0NhbGlmb3JuaWFHZW5lcmF0ZWRcIjtcclxuaW1wb3J0IHsgRWRpdFZpZXdNb2RlLCBSZWFkeVN0YXRlLCBTZWxlY3Rpb25Nb2RlIH0gZnJvbSBcIi4vQ2xpZW50U3RhdGVcIjtcclxuaW1wb3J0ICogYXMgcG9wcGVyanMgZnJvbSBcInBvcHBlci5qc1wiO1xyXG5pbXBvcnQgeyBDb250ZW50QXRvbVR5cGUgfSBmcm9tIFwiLi4vVHlwZXdyaXRlci9Db250ZW50QXRvbVR5cGVcIjtcclxuXHJcbmxldCBjdXJyZW50QXBwOiBDYWxpZm9ybmlhQXBwO1xyXG5cclxuZXhwb3J0IGNvbnN0IFZFUllfSElHSF9WQUxVRTogbnVtYmVyID0gMjMwMDAwMDAwMDtcclxuXHJcbmVudW0gQ2FsaWZvcm5pYVZpZXdTcGVjaWFsU3R5bGUge1xyXG4gICAgVmlldyA9IDAsXHJcbiAgICBCb2R5ID0gMSxcclxuICAgIEh0bWwgPSAyXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBQcm9wZXJ0eUJhciB7XHJcbiAgICBwdWJsaWMgdmlld01vZGVsOiBQcm9wZXJ0eUJhclZNO1xyXG4gICAgcHJpdmF0ZSBwcm9wZXJ0eUJhckluZGV4OiBudW1iZXIgPSAtMTtcclxuICAgIHByaXZhdGUgX3Zpc2libGVMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXM6IEhUTUxFbGVtZW50W10gPSBbXTtcclxuICAgIHByaXZhdGUgX2FjdGl2ZVZpZXdMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXM6IHsgW2tleTogc3RyaW5nXTogSFRNTEVsZW1lbnQgfSA9IHt9O1xyXG4gICAgcHJpdmF0ZSBfdmlzaWJsZUxheW91dEF0b21LZXlzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSBfbW9zdFVwcGVyVmlzaWJsZUxheW91dEF0b21JZDogbnVtYmVyID0gMDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihjYWxpZm9ybmlhQXBwQXJnOiBDYWxpZm9ybmlhQXBwLCB0YXJnZXRJbmRleDogbnVtYmVyKSB7XHJcbiAgICAgICAgY3VycmVudEFwcCA9IGNhbGlmb3JuaWFBcHBBcmc7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0eUJhckluZGV4ID0gdGFyZ2V0SW5kZXg7XHJcbiAgICAgICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgUHJvcGVydHlCYXJWTSh0aGlzLCB0YXJnZXRJbmRleCwgY2FsaWZvcm5pYUFwcEFyZyk7XHJcbiAgICAgICAgdGhpcy52aWV3TW9kZWwuaXNTeW5jZWRXaXRoQm94VHJlZVRvVGhlTGVmdCA9IGZhbHNlOy8vIFRPRE8gdGFyZ2V0SW5kZXggIT0gMDtcclxuICAgICAgICB0aGlzLnZpZXdNb2RlbC5pc1N5bmNlZFdpdGhQYWdlUHJldmlldyA9IGZhbHNlOy8vIFRPRE8gdGFyZ2V0SW5kZXggPT0gMDtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBnZXQgY3VycmVudFByb3BlcnR5QmFyKCk6IFByb3BlcnR5QmFyIHtcclxuICAgICAgICByZXR1cm4gY3VycmVudEFwcC5wcm9wZXJ0eUJhcnNbdGhpcy5wcm9wZXJ0eUJhckluZGV4XTtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBnZXQgbmV4dEV4Y2VwdExhc3RQcm9wZXJ0eUJhcigpOiBQcm9wZXJ0eUJhciB7XHJcbiAgICAgICAgbGV0IG5leHRQcm9wZXJ0eUJhckluZGV4OiBudW1iZXIgPSB0aGlzLnByb3BlcnR5QmFySW5kZXggKyAxO1xyXG4gICAgICAgIGlmIChuZXh0UHJvcGVydHlCYXJJbmRleCA8IGN1cnJlbnRBcHAuc3RhdGUudmlzaWJsZVByb3BlcnR5QmFyTWF4Q291bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRBcHAucHJvcGVydHlCYXJzW25leHRQcm9wZXJ0eUJhckluZGV4XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhcjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBnZXQgdmlzaWJsZUxheW91dEF0b21Eb21Ob2RlUmVmZXJlbmNlcygpOiBIVE1MRWxlbWVudFtdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZUxheW91dEF0b21Eb21Ob2RlUmVmZXJlbmNlcztcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGdldCB2aXNpYmxlTGF5b3V0QXRvbUtleXMoKTogc3RyaW5nW10ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlTGF5b3V0QXRvbUtleXM7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBnZXQgbW9zdFVwcGVyVmlzaWJsZUxheW91dEF0b21JZCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tb3N0VXBwZXJWaXNpYmxlTGF5b3V0QXRvbUlkO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgZ2V0IGFjdGl2ZVZpZXdMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXMoKTogeyBba2V5OiBzdHJpbmddOiBIVE1MRWxlbWVudCB9IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlVmlld0xheW91dEF0b21Eb21Ob2RlUmVmZXJlbmNlcztcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlbmRlclByb3BlcnR5QmFyID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICBsZXQgZGl2UHJvcGVydHlCYXJzU3R5bGVzID0ge1xyXG4gICAgICAgICAgICAvLyBUT0RPIHNjcm9sbCBzeW5jXHJcbiAgICAgICAgICAgIFwiZmxleFwiOiBjdXJyZW50QXBwLnN0YXRlLmVkaXRWaWV3TW9kZSA9PT0gRWRpdFZpZXdNb2RlLlNpZGViYXJPbmx5ID8gXCIxIDEgMjAwcHhcIiA6IGAxIDEgMjAwcHhgLCAvLyBwcm9wZXJ0eSBiYXIgd2lkdGggbm90IGludmFyaWFudCB0byBicm93c2VyIHpvb20gKCUtdmFsdWUgd291bGQgYmUsIGJ1dCBkZXBlbmRzIG9uIHZpZXdwb3J0IHNpemUpXHJcbiAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcImZsZXhcIixcclxuICAgICAgICAgICAgXCJmbGV4LWZsb3dcIjogXCJyb3cgbm93cmFwXCIsXHJcbiAgICAgICAgICAgIFwiaGVpZ2h0XCI6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICBcIm1pbi13aWR0aFwiOiBcIjEwMHB4XCIsXHJcbiAgICAgICAgICAgIFwid2lkdGhcIjogXCIyMDBweFwiLFxyXG4gICAgICAgICAgICBcInotaW5kZXhcIjogXCIyXCIgLy8gVE9ETyBkb2N1bWVudFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHByb3BlcnR5QmFyU3R5bGVzID0ge1xyXG4gICAgICAgICAgICBcImZsZXhcIjogY3VycmVudEFwcC5zdGF0ZS5lZGl0Vmlld01vZGUgPT09IEVkaXRWaWV3TW9kZS5TaWRlYmFyT25seSA/IFwiMSAxIDFweFwiIDogYDEgMSAxcHhgLCAvLyBwcm9wZXJ0eSBiYXIgd2lkdGggbm90IGludmFyaWFudCB0byBicm93c2VyIHpvb20gKCUtdmFsdWUgd291bGQgYmUsIGJ1dCBkZXBlbmRzIG9uIHZpZXdwb3J0IHNpemUpXHJcbiAgICAgICAgICAgIC8vXCJ3aWR0aFwiOiBjdXJyZW50QXBwLnN0YXRlLmVkaXRWaWV3TW9kZSA9PT0gRWRpdFZpZXdNb2RlLlNpZGViYXJPbmx5ID8gXCJhdXRvXCIgLy9cIjEwMCVcIiA6IGAke2N1cnJlbnRBcHAuY29udHJvbEFyZWFXaWR0aFB4fXB4YCxcclxuICAgICAgICAgICAgLy9cImRpc3BsYXlcIjogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgIC8vXCJmbGV4LWZsb3dcIjogXCJjb2x1bW4gbm93cmFwXCIsXHJcbiAgICAgICAgICAgIC8vXCJvdmVyZmxvd1wiOiBcImhpZGRlblwiLFxyXG4gICAgICAgICAgICAvL1wibWFyZ2luLXRvcFwiOiAvKmN1cnJlbnRBcHAuc3RhdGUuaXNTaG93U2lkZWJhck9ubHkgPyBUT0RPKi9jdXJyZW50QXBwLm5hdmlnYXRpb25IZWlndGhQeCArIFwicHhcIiwgVE9ETyA9PiBtb3ZlZCB0byBuYXZpZ2F0aW9uIGVsZW1lbnRcclxuICAgICAgICAgICAgXCJib3JkZXItcmlnaHRcIjogdGhpcy5wcm9wZXJ0eUJhckluZGV4IDwgKGN1cnJlbnRBcHAucHJvcGVydHlCYXJDb3VudCAtIDEpICYmIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5jdXJyZW50UHJvcGVydHlCYXJNb2RlID09PSBQcm9wZXJ0eUJhck1vZGUuQ2FsaWZvcm5pYVZpZXcgPyBcInNvbGlkIDNweCBibGFja1wiIDogdW5kZWZpbmVkLCAvLyBUT0RPIHBhdHRlcm5cclxuICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgXCJoZWlnaHRcIjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcImZsZXhcIixcclxuICAgICAgICAgICAgXCJmbGV4LWZsb3dcIjogXCJjb2x1bW4gbm93cmFwXCJcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiA8ZGl2IGtleT17YHAke3RoaXMucHJvcGVydHlCYXJJbmRleC50b1N0cmluZygpfWB9IHN0eWxlcz17ZGl2UHJvcGVydHlCYXJzU3R5bGVzfT5cclxuICAgICAgICAgICAgPGRpdiBrZXk9XCJ2MFwiIHN0eWxlcz17cHJvcGVydHlCYXJTdHlsZXN9PlxyXG4gICAgICAgICAgICAgICAge3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnJlbmRlclByb3BlcnR5QmFyTmF2aWdhdGlvbigpfVxyXG4gICAgICAgICAgICAgICAge3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnJlbmRlclByb3BlcnR5QmFyQ29udHJvbHMoKX1cclxuICAgICAgICAgICAgICAgIHt0aGlzLnByb3BlcnR5QmFySW5kZXggIT0gMCA/IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnJlbmRlclByb3BlcnR5QmFyUG9wcGVyc1JlbmRlck9uY2UoKSA6IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyUHJvcGVydHlCYXJQb3BwZXJzUmVuZGVyT25jZSA9ICgpOiBWTm9kZSA9PiB7IC8vIFRPRE8ganVzdCByZW5kZXIgb25jZS4uLlxyXG4gICAgICAgIHJldHVybiA8ZGl2IGtleT1cImswXCI+XHJcbiAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZW5kZXJBZGRDc3NQcm9wZXJ0eVBvcHVwKCl9XHJcbiAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZW5kZXJBbGxDc3NQcm9wZXJ0aWVzUG9wdXAoKX1cclxuICAgICAgICAgICAge3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnJlbmRlclVwZGF0ZUNzc1ZhbHVlUG9wdXAoKX1cclxuICAgICAgICAgICAge3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnJlbmRlck1hdGNoaW5nUXVhbnR1bXNQb3B1cCgpfVxyXG4gICAgICAgICAgICB7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucmVuZGVyVXBkYXRlQ3NzUXVhbnR1bVBvcHVwKCl9XHJcbiAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZW5kZXJBbGxDc3NQcm9wZXJ0aWVzRm9yUXVhbnR1bVBvcHVwKCl9XHJcbiAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pbnNlcnRMYXlvdXRSb3dJbnRvVmlld1BvcHVwKCl9XHJcbiAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pbnNlcnRMYXlvdXRBdG9tSW50b0JveFBvcHVwKCl9XHJcbiAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pbnNlcnRMYXlvdXRCb3hJbnRvQm94UG9wdXAoKX1cclxuICAgICAgICAgICAge3RoaXMuY3VycmVudFByb3BlcnR5QmFyLm1vdmVTdHlsZUF0b21Ub1Jlc3BvbnNpdmVEZXZpY2VQb3B1cCgpfVxyXG4gICAgICAgICAgICB7Lyp0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5tb3ZlTGF5b3V0TW9sZWN1bGVJbnRvUG9wdXAoKSovfVxyXG4gICAgICAgICAgICB7Lyp0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5tb3ZlTGF5b3V0TW9sZWN1bGVCZWZvcmVQb3B1cCgpKi99XHJcbiAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZW5kZXJTZWxlY3RJbnRlcmFjdGlvblRhcmdldFBvcHVwKCl9XHJcbiAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZW5kZXJTZWxlY3RJbnRlcmFjdGlvblRhcmdldExheW91dEZpbHRlclBvcHVwKCl9XHJcbiAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZW5kZXJTaGFyZUNhbGlmb3JuaWFQcm9qZWN0UG9wdXAoKX1cclxuICAgICAgICAgICAge3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnJlbmRlckNhbGlmb3JuaWFWaWV3U2VsZWN0aW9uUG9wdXAoKX1cclxuICAgICAgICAgICAge3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnJlbmRlckVkaXRVc2VyRGVmaW5lZENzc1BvcHVwKCl9XHJcbiAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZW5kZXJTdWdnZXN0ZWRDc3NWYWx1ZXNQb3B1cCgpfVxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlbmRlclByb3BlcnR5QmFyTmF2aWdhdGlvbiA9ICgpOiBWTm9kZSA9PiB7XHJcbiAgICAgICAgbGV0IHByb3BlcnR5QmFyTmF2aWdhdGlvblN0eWxlcyA9IHtcclxuICAgICAgICAgICAgXCJtYXJnaW4tdG9wXCI6IC8qY3VycmVudEFwcC5zdGF0ZS5pc1Nob3dTaWRlYmFyT25seSA/IFRPRE8qL2N1cnJlbnRBcHAubmF2aWdhdGlvbkhlaWd0aFB4ICsgXCJweFwiLFxyXG4gICAgICAgICAgICBcImRpc3BsYXlcIjogYGZsZXhgLFxyXG4gICAgICAgICAgICBcImZsZXgtZmxvd1wiOiBcInJvdyBub3dyYXBcIixcclxuICAgICAgICAgICAgXCJoZWlnaHRcIjogYGF1dG9gLFxyXG4gICAgICAgICAgICBcIndpZHRoXCI6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICBcImZsZXhcIjogXCIwIDAgYXV0b1wiXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgaGlkZGVuTW9kZUJ1dHRvbnM6IG51bWJlcltdID0gW1xyXG4gICAgICAgICAgICBQcm9wZXJ0eUJhck1vZGUuTm9uZSxcclxuICAgICAgICAgICAgUHJvcGVydHlCYXJNb2RlLkFsbFN0eWxlQXRvbXMsXHJcbiAgICAgICAgICAgIFByb3BlcnR5QmFyTW9kZS5MYXlvdXRBdG9tcyxcclxuICAgICAgICAgICAgUHJvcGVydHlCYXJNb2RlLkxheW91dEJhc2UsXHJcbiAgICAgICAgICAgIFByb3BlcnR5QmFyTW9kZS5MYXlvdXRNb2xlY3VsZXMsXHJcbiAgICAgICAgICAgIFByb3BlcnR5QmFyTW9kZS5TdHlsZU1vbGVjdWxlXHJcbiAgICAgICAgXTsgLy8gVE9ETyByZW5kZXIgd2hvbGUgVUkgc3RhdGljXHJcbiAgICAgICAgbGV0IHByb3BlcnR5QmFyTW9kZUljb25TdHJpbmdzOiB7IFtrZXk6IG51bWJlcl06IHN0cmluZyB9ID0ge307XHJcbiAgICAgICAgcHJvcGVydHlCYXJNb2RlSWNvblN0cmluZ3NbUHJvcGVydHlCYXJNb2RlLkFsbENhbGlmb3JuaWFWaWV3c10gPSBcIlZcIjtcclxuICAgICAgICBwcm9wZXJ0eUJhck1vZGVJY29uU3RyaW5nc1tQcm9wZXJ0eUJhck1vZGUuQWxsTGF5b3V0TW9sZWN1bGVzXSA9IFwiTFwiO1xyXG4gICAgICAgIHByb3BlcnR5QmFyTW9kZUljb25TdHJpbmdzW1Byb3BlcnR5QmFyTW9kZS5BbGxTdHlsZU1vbGVjdWxlc10gPSBcIlNcIjtcclxuICAgICAgICBwcm9wZXJ0eUJhck1vZGVJY29uU3RyaW5nc1tQcm9wZXJ0eUJhck1vZGUuQWxsU3R5bGVRdWFudHVtc10gPSBcIlFcIjtcclxuICAgICAgICBwcm9wZXJ0eUJhck1vZGVJY29uU3RyaW5nc1tQcm9wZXJ0eUJhck1vZGUuQ2FsaWZvcm5pYVZpZXddID0gXCI6KVwiO1xyXG4gICAgICAgIGxldCBwcm9wZXJ0eUJhck1vZGVCdXR0b25zOiAoVk5vZGUgfCB1bmRlZmluZWQpW10gPSBnZXRBcnJheUZvckVudW0oUHJvcGVydHlCYXJNb2RlKS5tYXAoKHR5cGU6IHN0cmluZywgaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbW9kZUJ1dHRvblN0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgIFwiY29sb3JcIjogaW5kZXggPT09IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5jdXJyZW50UHJvcGVydHlCYXJNb2RlID8gXCJyZWRcIiA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCIxcHhcIixcclxuICAgICAgICAgICAgICAgIFwibWFyZ2luLXJpZ2h0XCI6IFwiNXB4XCIsXHJcbiAgICAgICAgICAgICAgICBcIm1hcmdpbi1sZWZ0XCI6IFwiNXB4XCIsXHJcbiAgICAgICAgICAgICAgICBcImZsZXhcIjogXCIxIDEgMXB4XCJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGhpZGRlbk1vZGVCdXR0b25zLmZpbmRJbmRleChlbCA9PiBlbCA9PSBpbmRleCkgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIDxidXR0b24ga2V5PXtpbmRleH0gcm9sZT1cImJ1dHRvblwiIHBpZD17aW5kZXgudG9TdHJpbmcoKX0gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2V0UHJvcGVydHlCYXJNb2RlfSBzdHlsZXM9e21vZGVCdXR0b25TdHlsZXN9Pntwcm9wZXJ0eUJhck1vZGVJY29uU3RyaW5nc1tpbmRleF0gIT09IHVuZGVmaW5lZCA/IHByb3BlcnR5QmFyTW9kZUljb25TdHJpbmdzW2luZGV4XSA6IHR5cGV9PC9idXR0b24+IGFzIFZOb2RlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiA8ZGl2IGtleT1cIm4wXCIgc3R5bGVzPXtwcm9wZXJ0eUJhck5hdmlnYXRpb25TdHlsZXN9PlxyXG4gICAgICAgICAgICB7cHJvcGVydHlCYXJNb2RlQnV0dG9uc31cclxuICAgICAgICAgICAge3RoaXMucHJvcGVydHlCYXJJbmRleCA9PSAwID8gPGJ1dHRvbiBrZXk9XCJhXCIgb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIubG9nb3V0UG9wdXBDbGlja0hhbmRsZXJ9IHN0eWxlcz17eyBcImZsZXhcIjogXCIwIDAgYXV0b1wiLCBcIndpZHRoXCI6IFwiYXV0b1wiIH19PiYjOTk5MzsmIzgyMzA7PC9idXR0b24+IDogdW5kZWZpbmVkfVxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNldFByb3BlcnR5QmFyTW9kZSA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuY3VycmVudFByb3BlcnR5QmFyTW9kZSA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcInBpZFwiKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlbmRlclByb3BlcnR5QmFyQ29udHJvbHMgPSAoKTogVk5vZGUgPT4ge1xyXG4gICAgICAgIGxldCBkaXZQcm9wZXJ0eUJhckNvbnRyb2xzU3R5bGVzID0ge1xyXG4gICAgICAgICAgICBcImZsZXhcIjogXCIxIDEgYXV0b1wiLFxyXG4gICAgICAgICAgICBcImhlaWdodFwiOiBcIjFweFwiLCAvLyBUT0RPIHdhcyAxMDAlIGJlZm9yZSwgYnV0IGl0IGdvdCBjdXQgb2ZmIG9uIHRoZSBib3R0b21cclxuICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjEwMCVcIlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHByb3BlcnR5QmFyQ29udHJvbHNTdHlsZXMgPSB7XHJcbiAgICAgICAgICAgIFwid2lkdGhcIjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgIFwiaGVpZ2h0XCI6IFwiMTAwJVwiLCAvLyBUT0RPIGZpeG1lXHJcbiAgICAgICAgICAgIFwib3ZlcmZsb3dcIjogXCJhdXRvXCJcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiA8ZGl2IGtleT17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmN1cnJlbnRQcm9wZXJ0eUJhck1vZGV9IHN0eWxlcz17ZGl2UHJvcGVydHlCYXJDb250cm9sc1N0eWxlc30+XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5jdXJyZW50UHJvcGVydHlCYXJNb2RlID09PSBQcm9wZXJ0eUJhck1vZGUuQWxsU3R5bGVBdG9tcyA/XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9e1Byb3BlcnR5QmFyTW9kZS5BbGxTdHlsZUF0b21zfSBzdHlsZXM9e3Byb3BlcnR5QmFyQ29udHJvbHNTdHlsZXN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnN0eWxlQXRvbVByb2plY3Rvci5yZXN1bHRzLm1hcChyID0+IHIucmVuZGVyTWFxdWV0dGUoKSl9XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuY3VycmVudFByb3BlcnR5QmFyTW9kZSA9PT0gUHJvcGVydHlCYXJNb2RlLkFsbFN0eWxlUXVhbnR1bXMgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17UHJvcGVydHlCYXJNb2RlLkFsbFN0eWxlUXVhbnR1bXN9IHN0eWxlcz17cHJvcGVydHlCYXJDb250cm9sc1N0eWxlc30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucmVuZGVyU3R5bGVRdWFudHVtQ29udHJvbHMoKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc3R5bGVRdWFudHVtUHJvamVjdG9yLnJlc3VsdHMubWFwKHIgPT4gci5yZW5kZXJNYXF1ZXR0ZSgpKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmN1cnJlbnRQcm9wZXJ0eUJhck1vZGUgPT09IFByb3BlcnR5QmFyTW9kZS5BbGxTdHlsZU1vbGVjdWxlcyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17UHJvcGVydHlCYXJNb2RlLkFsbFN0eWxlTW9sZWN1bGVzfSBzdHlsZXM9e3Byb3BlcnR5QmFyQ29udHJvbHNTdHlsZXN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc3R5bGVNb2xlY3VsZVByb2plY3Rvci5yZXN1bHRzLm1hcChyID0+IHIucmVuZGVyTWFxdWV0dGUoKSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5jdXJyZW50UHJvcGVydHlCYXJNb2RlID09PSBQcm9wZXJ0eUJhck1vZGUuU3R5bGVNb2xlY3VsZSkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXtQcm9wZXJ0eUJhck1vZGUuQWxsU3R5bGVNb2xlY3VsZXN9IHN0eWxlcz17cHJvcGVydHlCYXJDb250cm9sc1N0eWxlc30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZW5kZXJTdHlsZU1vbGVjdWxlQ29udHJvbHModGhpcyl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuY3VycmVudFByb3BlcnR5QmFyTW9kZSA9PT0gUHJvcGVydHlCYXJNb2RlLkxheW91dEF0b21zID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9e1Byb3BlcnR5QmFyTW9kZS5MYXlvdXRBdG9tc30gc3R5bGVzPXtwcm9wZXJ0eUJhckNvbnRyb2xzU3R5bGVzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuaW5zdGFuY2VhYmxlQXRvbVByb2plY3Rvci5yZXN1bHRzLm1hcChyID0+IHIucmVuZGVyTWFxdWV0dGUoKSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5jdXJyZW50UHJvcGVydHlCYXJNb2RlID09PSBQcm9wZXJ0eUJhck1vZGUuTGF5b3V0TW9sZWN1bGVzID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXtQcm9wZXJ0eUJhck1vZGUuTGF5b3V0TW9sZWN1bGVzfSBzdHlsZXM9e3Byb3BlcnR5QmFyQ29udHJvbHNTdHlsZXN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuaW5zdGFuY2VhYmxlTW9sZWN1bGVQcm9qZWN0b3IucmVzdWx0cy5tYXAociA9PiByLnJlbmRlck1hcXVldHRlKCkpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5jdXJyZW50UHJvcGVydHlCYXJNb2RlID09PSBQcm9wZXJ0eUJhck1vZGUuQWxsTGF5b3V0TW9sZWN1bGVzID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17UHJvcGVydHlCYXJNb2RlLkFsbExheW91dE1vbGVjdWxlc30gc3R5bGVzPXtwcm9wZXJ0eUJhckNvbnRyb2xzU3R5bGVzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5hbGxMYXlvdXRNb2xlY3VsZXNQcm9qZWN0b3IucmVzdWx0cy5tYXAociA9PiByLnJlbmRlck1hcXVldHRlKCkpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmN1cnJlbnRQcm9wZXJ0eUJhck1vZGUgPT09IFByb3BlcnR5QmFyTW9kZS5MYXlvdXRCYXNlID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9e1Byb3BlcnR5QmFyTW9kZS5MYXlvdXRCYXNlfSBzdHlsZXM9e3Byb3BlcnR5QmFyQ29udHJvbHNTdHlsZXN9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnJlbmRlckxheW91dEJhc2VDb250cm9scygpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuY3VycmVudFByb3BlcnR5QmFyTW9kZSA9PT0gUHJvcGVydHlCYXJNb2RlLkFsbENhbGlmb3JuaWFWaWV3cyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17UHJvcGVydHlCYXJNb2RlLkFsbENhbGlmb3JuaWFWaWV3c30gc3R5bGVzPXtwcm9wZXJ0eUJhckNvbnRyb2xzU3R5bGVzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucmVuZGVyQ2FsaWZvcm5pYVZpZXdDb250cm9sc1doZW5BbGwoKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmFsbENhbGlmb3JuaWFWaWV3c1Byb2plY3Rvci5yZXN1bHRzLm1hcChyID0+IHIucmVuZGVyTWFxdWV0dGUoKSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmN1cnJlbnRQcm9wZXJ0eUJhck1vZGUgPT09IFByb3BlcnR5QmFyTW9kZS5DYWxpZm9ybmlhVmlldyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9e1Byb3BlcnR5QmFyTW9kZS5DYWxpZm9ybmlhVmlld30gc3R5bGVzPXtwcm9wZXJ0eUJhckNvbnRyb2xzU3R5bGVzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnJlbmRlckNhbGlmb3JuaWFWaWV3Q29udHJvbHMoKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKnB1YmxpYyBzY3JvbGxUT0RPID0gKGV2dDogVUlFdmVudCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiaW4gc2Nyb2xsXCIpO1xyXG4gICAgICAgIGxldCBzY3JvbGxlZEVsZW1lbnQ6IEhUTUxFbGVtZW50ID0gZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICAvLyBUT0RPIHNlbWktY29uc3RcclxuICAgICAgICBsZXQgc2Nyb2xsVmVydGljYWxNaW5QeDogbnVtYmVyID0gMDtcclxuICAgICAgICBsZXQgc2Nyb2xsVmVydGljYWxNYXhQeDogbnVtYmVyID0gMjIyO1xyXG4gICAgICAgIHNjcm9sbFZlcnRpY2FsTWF4UHggPSBzY3JvbGxlZEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsZWRFbGVtZW50LmNsaWVudEhlaWdodDsvL3Njcm9sbGVkRWxlbWVudC5zY3JvbGxIZWlnaHQgLSAoKChzY3JvbGxlZEVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQgYXMgSFRNTEVsZW1lbnQpLmxhc3RFbGVtZW50Q2hpbGQgYXMgSFRNTEVsZW1lbnQpLmZpcnN0RWxlbWVudENoaWxkIGFzIEhUTUxFbGVtZW50KS5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgbGV0IHNjcm9sbFRhcmdldENzc1ZhbHVlTWluOiBudW1iZXIgPSAwO1xyXG4gICAgICAgIGxldCBzY3JvbGxUYXJnZXRDc3NWYWx1ZU1heDogbnVtYmVyID0gMjIyO1xyXG4gICAgICAgIGxldCBzY3JvbGxEZWx0YVN0YXI6IG51bWJlciA9IHNjcm9sbFZlcnRpY2FsTWF4UHggLSBzY3JvbGxWZXJ0aWNhbE1pblB4O1xyXG4gICAgICAgIGxldCBpc0ludmVydGVkOiBib29sZWFuID0gdHJ1ZTtcclxuICAgICAgICAvLyAtLS1cclxuICAgICAgICBpZiAoc2Nyb2xsZWRFbGVtZW50LnNjcm9sbFRvcCA+IHNjcm9sbFZlcnRpY2FsTWluUHggfHwgc2Nyb2xsZWRFbGVtZW50LnNjcm9sbFRvcCA8IHNjcm9sbFZlcnRpY2FsTWF4UHgpIHsgLy9UT0RPIG5lZWQgdG8gc2F2ZSBzdGF0ZSBvZiBwcmV2aW91cyBzY3JvbGwgZXZlbnQgZm9yIHRoZSBjYXNlIHdoZW4gdGhlIHNjcm9sbCBkaXN0YW5jZSBpcyBsYXJnZVxyXG4gICAgICAgICAgICBsZXQgc2Nyb2xsRGVsdGE6IG51bWJlciA9IHNjcm9sbGVkRWxlbWVudC5zY3JvbGxUb3AgLSBzY3JvbGxWZXJ0aWNhbE1pblB4O1xyXG4gICAgICAgICAgICBsZXQgc2Nyb2xsRnJhY3Rpb246IG51bWJlciA9IChzY3JvbGxEZWx0YSAvIHNjcm9sbERlbHRhU3Rhcik7XHJcbiAgICAgICAgICAgIGlmIChpc0ludmVydGVkID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBzY3JvbGxGcmFjdGlvbiA9IDEuMCAtIHNjcm9sbEZyYWN0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBzY3JvbGxUYXJnZXRDc3NWYWx1ZTogbnVtYmVyID0gc2Nyb2xsRnJhY3Rpb24gKiAoc2Nyb2xsVGFyZ2V0Q3NzVmFsdWVNYXggLSBzY3JvbGxUYXJnZXRDc3NWYWx1ZU1pbikgKyBzY3JvbGxUYXJnZXRDc3NWYWx1ZU1pbjtcclxuICAgICAgICAgICAgbGV0IHNjcm9sbFRhcmdldENzc1N0cmluZzogc3RyaW5nID0gYHJnYigke3Njcm9sbFRhcmdldENzc1ZhbHVlfSwke3Njcm9sbFRhcmdldENzc1ZhbHVlfSwke3Njcm9sbFRhcmdldENzc1ZhbHVlfSlgO1xyXG4gICAgICAgICAgICBzY3JvbGxlZEVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gc2Nyb2xsVGFyZ2V0Q3NzU3RyaW5nO1xyXG4gICAgICAgIH1cclxuICAgIH07Ki9cclxuXHJcbiAgICAvKnB1YmxpYyBzY3JvbGxUT0RPID0gKGV2dDogVUlFdmVudCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiaW4gc2Nyb2xsXCIpO1xyXG4gICAgICAgIGxldCBzY3JvbGxlZEVsZW1lbnQ6IEhUTUxFbGVtZW50ID0gZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICAvLyBUT0RPIHNlbWktY29uc3RcclxuICAgICAgICBsZXQgc2Nyb2xsVmVydGljYWxNaW5QeDogbnVtYmVyID0gMDtcclxuICAgICAgICBsZXQgc2Nyb2xsVmVydGljYWxNYXhQeDogbnVtYmVyID0gMjIyO1xyXG4gICAgICAgIHNjcm9sbFZlcnRpY2FsTWF4UHggPSBzY3JvbGxlZEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsZWRFbGVtZW50LmNsaWVudEhlaWdodDsvL3Njcm9sbGVkRWxlbWVudC5zY3JvbGxIZWlnaHQgLSAoKChzY3JvbGxlZEVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQgYXMgSFRNTEVsZW1lbnQpLmxhc3RFbGVtZW50Q2hpbGQgYXMgSFRNTEVsZW1lbnQpLmZpcnN0RWxlbWVudENoaWxkIGFzIEhUTUxFbGVtZW50KS5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgbGV0IHNjcm9sbFRhcmdldENzc1ZhbHVlTWluOiBudW1iZXIgPSAwO1xyXG4gICAgICAgIGxldCBzY3JvbGxUYXJnZXRDc3NWYWx1ZU1heDogbnVtYmVyID0gNDA7XHJcbiAgICAgICAgbGV0IHNjcm9sbERlbHRhU3RhcjogbnVtYmVyID0gc2Nyb2xsVmVydGljYWxNYXhQeCAtIHNjcm9sbFZlcnRpY2FsTWluUHg7XHJcbiAgICAgICAgbGV0IGlzSW52ZXJ0ZWQ6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgICAgIC8vIC0tLVxyXG4gICAgICAgIGlmIChzY3JvbGxlZEVsZW1lbnQuc2Nyb2xsVG9wID4gc2Nyb2xsVmVydGljYWxNaW5QeCB8fCBzY3JvbGxlZEVsZW1lbnQuc2Nyb2xsVG9wIDwgc2Nyb2xsVmVydGljYWxNYXhQeCkgeyAvL1RPRE8gbmVlZCB0byBzYXZlIHN0YXRlIG9mIHByZXZpb3VzIHNjcm9sbCBldmVudCBmb3IgdGhlIGNhc2Ugd2hlbiB0aGUgc2Nyb2xsIGRpc3RhbmNlIGlzIGxhcmdlXHJcbiAgICAgICAgICAgIGxldCBzY3JvbGxEZWx0YTogbnVtYmVyID0gc2Nyb2xsZWRFbGVtZW50LnNjcm9sbFRvcCAtIHNjcm9sbFZlcnRpY2FsTWluUHg7XHJcbiAgICAgICAgICAgIGxldCBzY3JvbGxGcmFjdGlvbjogbnVtYmVyID0gKHNjcm9sbERlbHRhIC8gc2Nyb2xsRGVsdGFTdGFyKTtcclxuICAgICAgICAgICAgaWYgKGlzSW52ZXJ0ZWQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHNjcm9sbEZyYWN0aW9uID0gMS4wIC0gc2Nyb2xsRnJhY3Rpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHNjcm9sbFRhcmdldENzc1ZhbHVlOiBudW1iZXIgPSBzY3JvbGxGcmFjdGlvbiAqIChzY3JvbGxUYXJnZXRDc3NWYWx1ZU1heCAtIHNjcm9sbFRhcmdldENzc1ZhbHVlTWluKSArIHNjcm9sbFRhcmdldENzc1ZhbHVlTWluO1xyXG4gICAgICAgICAgICBsZXQgcGFkZGluZ1RhcmdldENzc1N0cmluZzogc3RyaW5nID0gYCR7c2Nyb2xsVGFyZ2V0Q3NzVmFsdWV9cHhgO1xyXG4gICAgICAgICAgICBzY3JvbGxlZEVsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSBwYWRkaW5nVGFyZ2V0Q3NzU3RyaW5nO1xyXG4gICAgICAgIH1cclxuICAgIH07Ki9cclxuXHJcbiAgICAvKnByaXZhdGUgaXNBbmltYXRpb25SdW5uaW5nOiBib29sZWFuID0gZmFsc2U7IFRPRE8gY29kZSBzYW1wbGVzIGFuaW1hdGlvbnMgb24gc2Nyb2xsIHBvc2l0aW9uIHJlYWNoaW5nL2xlYXZpbmcgdG9wXHJcbiAgICBwcml2YXRlIGlzQW5pbWF0aW9uSW5TZWNvbmRTdGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIHB1YmxpYyBzY3JvbGxUT0RPID0gKGV2dDogVUlFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCBzY3JvbGxlZEVsZW1lbnQ6IEhUTUxFbGVtZW50ID0gZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICAvLyBUT0RPIHNlbWktY29uc3RcclxuICAgICAgICBsZXQgc2Nyb2xsVmVydGljYWxNaW5QeDogbnVtYmVyID0gMDtcclxuICAgICAgICBsZXQgc2Nyb2xsVmVydGljYWxNYXhQeDogbnVtYmVyID0gMjIyO1xyXG4gICAgICAgIC8vc2Nyb2xsVmVydGljYWxNYXhQeCA9IHNjcm9sbGVkRWxlbWVudC5zY3JvbGxIZWlnaHQgLSBzY3JvbGxlZEVsZW1lbnQuY2xpZW50SGVpZ2h0Oy8vc2Nyb2xsZWRFbGVtZW50LnNjcm9sbEhlaWdodCAtICgoKHNjcm9sbGVkRWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCBhcyBIVE1MRWxlbWVudCkubGFzdEVsZW1lbnRDaGlsZCBhcyBIVE1MRWxlbWVudCkuZmlyc3RFbGVtZW50Q2hpbGQgYXMgSFRNTEVsZW1lbnQpLmNsaWVudEhlaWdodDtcclxuICAgICAgICBsZXQgc2Nyb2xsVGFyZ2V0Q3NzVmFsdWVNaW46IG51bWJlciA9IDA7XHJcbiAgICAgICAgbGV0IHNjcm9sbFRhcmdldENzc1ZhbHVlTWF4OiBudW1iZXIgPSA0MDtcclxuICAgICAgICBsZXQgc2Nyb2xsRGVsdGFTdGFyOiBudW1iZXIgPSBzY3JvbGxWZXJ0aWNhbE1heFB4IC0gc2Nyb2xsVmVydGljYWxNaW5QeDtcclxuICAgICAgICBsZXQgaXNJbnZlcnRlZDogYm9vbGVhbiA9IHRydWU7XHJcbiAgICAgICAgLy8gLS0tXHJcbiAgICAgICAgLy8gYW5pbWF0aW9uOiBmb2xkIGluIHdoZW4gc2Nyb2xsaW5nIGF3YXkgZnJvbSB0b3BcclxuICAgICAgICBsZXQgaXNGaXJzdFRyYW5zaXRpb246IGJvb2xlYW4gPSAhdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaXNBbmltYXRpb25JblNlY29uZFN0YXRlO1xyXG4gICAgICAgIGlmIChzY3JvbGxlZEVsZW1lbnQuc2Nyb2xsVG9wID4gMCkge1xyXG4gICAgICAgICAgICAvLyB0cmFuc2l0aW9uIDIgPT4gMVxyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaXNBbmltYXRpb25JblNlY29uZFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaXNBbmltYXRpb25SdW5uaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmVsb2NpdHkuYW5pbWF0ZShzY3JvbGxlZEVsZW1lbnQsIFwic3RvcFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pc0FuaW1hdGlvblJ1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHsgLy8gc2Nyb2xsVG9wID09IDBcclxuICAgICAgICAgICAgLy8gdHJhbnNpdGlvbiAxID0+IDJcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmlzQW5pbWF0aW9uSW5TZWNvbmRTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmlzQW5pbWF0aW9uUnVubmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlbG9jaXR5LmFuaW1hdGUoc2Nyb2xsZWRFbGVtZW50LCBcInN0b3BcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaXNBbmltYXRpb25SdW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBkdXJhdGlvbk1heDogbnVtYmVyID0gMTAwO1xyXG4gICAgICAgIGxldCBwYWRkaW5nTGVmdDogc3RyaW5nID0gc2Nyb2xsZWRFbGVtZW50LnN0eWxlLm1hcmdpbkxlZnQgYXMgc3RyaW5nO1xyXG4gICAgICAgIGxldCBwYWRkaW5nTGVmdFB4OiBudW1iZXIgPSBwYXJzZUludChwYWRkaW5nTGVmdC5zdWJzdHJpbmcoMCwgcGFkZGluZ0xlZnQubGVuZ3RoIC0gMikpO1xyXG4gICAgICAgIGlmIChpc0ZpcnN0VHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pc0FuaW1hdGlvbkluU2Vjb25kU3RhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICBsZXQgZHVyYXRpb25EZWx0YSA9IChwYWRkaW5nTGVmdFB4IC0gMCkgLyA0MC4wICogZHVyYXRpb25NYXg7XHJcbiAgICAgICAgICAgIGlmIChkdXJhdGlvbkRlbHRhID4gMTApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmlzQW5pbWF0aW9uUnVubmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eS5hbmltYXRlKHNjcm9sbGVkRWxlbWVudCwgeyBcIm1hcmdpbi1sZWZ0XCI6IDAgfSwgeyBkdXJhdGlvbjogZHVyYXRpb25EZWx0YSwgZWFzaW5nOiBcImVhc2UtaW5cIiwgY29tcGxldGU6ICgpID0+IHsgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaXNBbmltYXRpb25SdW5uaW5nID0gZmFsc2U7IH0gfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzY3JvbGxlZEVsZW1lbnQuc3R5bGUubWFyZ2luTGVmdCA9IFwiMHB4XCI7XHJcbiAgICAgICAgICAgIH0gICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmlzQW5pbWF0aW9uSW5TZWNvbmRTdGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvL2RvbU5vZGUuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xyXG4gICAgICAgICAgICBsZXQgZHVyYXRpb25EZWx0YSA9ICg0MCAtIHBhZGRpbmdMZWZ0UHgpIC8gNDAuMCAqIGR1cmF0aW9uTWF4O1xyXG4gICAgICAgICAgICBpZiAoZHVyYXRpb25EZWx0YSA+IDEwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pc0FuaW1hdGlvblJ1bm5pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmVsb2NpdHkuYW5pbWF0ZShzY3JvbGxlZEVsZW1lbnQsIHsgXCJtYXJnaW4tbGVmdFwiOiA0MCB9LCB7IGR1cmF0aW9uOiBkdXJhdGlvbkRlbHRhLCBlYXNpbmc6IFwiZWFzZS1vdXRcIiwgY29tcGxldGU6ICgpID0+IHsgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaXNBbmltYXRpb25SdW5uaW5nID0gZmFsc2U7IH0gfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzY3JvbGxlZEVsZW1lbnQuc3R5bGUubWFyZ2luTGVmdCA9IFwiNDBweFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTsqL1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJTdHlsZU1vbGVjdWxlQ29udHJvbHMgPSAocHJvcGVydHlCYXI6IFByb3BlcnR5QmFyKTogVk5vZGUgfCB1bmRlZmluZWQgPT4ge1xyXG4gICAgICAgIGlmIChwcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZU1vbGVjdWxlSWQgIT0gMCkge1xyXG4gICAgICAgICAgICBsZXQgc291cmNlU3R5bGVNb2xlY3VsZUlkU3RyaW5nOiBzdHJpbmcgPSBwcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZU1vbGVjdWxlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgbGV0IHN0eWxlTW9sZWN1bGU6IFN0eWxlTW9sZWN1bGUgfCB1bmRlZmluZWQgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChtID0+IG0uU3R5bGVNb2xlY3VsZUlkID09IHByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFN0eWxlTW9sZWN1bGVJZCk7IC8vIFRPRE8gZmluZCB1c2VkIHJlcGVhdGVkbHkgZm9yIHJlbmRlciBjb250cm9sc1xyXG4gICAgICAgICAgICBpZiAoc3R5bGVNb2xlY3VsZSA9PT0gdW5kZWZpbmVkKSB7IC8vIGNhbiBoYXBwZW4gaWYgc3R5bGUgbW9sZWN1bGUgZ290IGRlbGV0ZWQgaW4gdGhlIG1lYW4gdGltZSBpbiBvdGhlciBwcm9wZXJ0eSBiYXJzXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBUT0RPIGRvY3VtZW50XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGlzQ2xvbmVkU3R5bGU6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgbGV0IGNsb25lUmVmU3R5bGVNb2xlY3VsZUlkU3RyaW5nOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGlmIChzdHlsZU1vbGVjdWxlLkNsb25lZEZyb21TdHlsZUlkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlzQ2xvbmVkU3R5bGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY2xvbmVSZWZTdHlsZU1vbGVjdWxlSWRTdHJpbmcgPSBzdHlsZU1vbGVjdWxlLkNsb25lZEZyb21TdHlsZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHN0eWxlZExheW91dEJhc2VJZFN0cmluZzogc3RyaW5nID0gc3R5bGVNb2xlY3VsZS5TdHlsZUZvckxheW91dElkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eUJhckNvbnRyb2xzU3R5bGVzID0ge1xyXG4gICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiZmxleFwiLFxyXG4gICAgICAgICAgICAgICAgXCJmbGV4LWZsb3dcIjogXCJjb2x1bW4gbm93cmFwXCJcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE8gY2xvbmUgcmVmZXJlbmNlIHN0eWxlIHNlbGVjdG9yIHNob3VsZCBhbHdheXMgYmUgdmlzaWJsZSAoZGVwZW5kcyBvbiBjbG9uZU9mU3R5bGVJZClcclxuICAgICAgICAgICAgLy8gVE9ETyByZWYgc3R5bGUvY2xvbmUgc3R5bGVcclxuICAgICAgICAgICAgcmV0dXJuIDxkaXYga2V5PXtQcm9wZXJ0eUJhck1vZGUuU3R5bGVNb2xlY3VsZX0gc3R5bGVzPXtwcm9wZXJ0eUJhckNvbnRyb2xzU3R5bGVzfT5cclxuICAgICAgICAgICAgICAgIDxkaXYga2V5PVwiMFwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIwIDAgYXV0b1wiIH19PlxyXG4gICAgICAgICAgICAgICAgICAgIFNlbGVjdGVkIFN0eWxlTW9sZWN1bGUgI3twcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZU1vbGVjdWxlSWR9XHJcbiAgICAgICAgICAgICAgICAgICAge2lzQ2xvbmVkU3R5bGUgPyA8ZGl2IGtleT1cIjBcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIG1pZD17Y2xvbmVSZWZTdHlsZU1vbGVjdWxlSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLnNlbGVjdFN0eWxlTW9sZWN1bGVDbGlja0hhbmRsZXJ9PnJlZiBzdHlsZSAoI3tjbG9uZVJlZlN0eWxlTW9sZWN1bGVJZFN0cmluZ30pPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gZGlzYWJsZWQga2V5PVwiYlwiIHJvbGU9XCJidXR0b25cIiBtaWQ9e3NvdXJjZVN0eWxlTW9sZWN1bGVJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuY3JlYXRlUmVmZXJlbmNlU3R5bGVNb2xlY3VsZUNsaWNrSGFuZGxlcn0+bWFrZSByZWY8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJjXCIgcm9sZT1cImJ1dHRvblwiIG1pZD17c291cmNlU3R5bGVNb2xlY3VsZUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5zeW5jVG9SZWZlcmVuY2VTdHlsZUNsaWNrSGFuZGxlcn0+c3luYyB0byByZWY8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJkXCIgcm9sZT1cImJ1dHRvblwiIG1pZD17c291cmNlU3R5bGVNb2xlY3VsZUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5zeW5jRnJvbVJlZmVyZW5jZVN0eWxlQ2xpY2tIYW5kbGVyfT5zeW5jIGZyb20gcmVmPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+IDogcHJvcGVydHlCYXIucmVuZGVyU3R5bGVNb2xlY3VsZVJlZmVyZW5jZVNlbGVjdG9yKCl9XHJcbiAgICAgICAgICAgICAgICAgICAge3Byb3BlcnR5QmFyLnJlbmRlclJlc3BvbnNpdmVEZXZpY2VTZWxlY3RvcnMoKX1cclxuICAgICAgICAgICAgICAgICAgICB7cHJvcGVydHlCYXIucmVuZGVyU3RhdGVNb2RpZmllclNlbGVjdG9ycygpfVxyXG4gICAgICAgICAgICAgICAgICAgIHtwcm9wZXJ0eUJhci5yZW5kZXJTdHlsZUF0b21Db250cm9scygpfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGtleT1cIjFcIiBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMSAxIDFweFwiLCBcIm92ZXJmbG93XCI6IFwic2Nyb2xsXCIgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAge3Byb3BlcnR5QmFyLnZpZXdNb2RlbC5zdHlsZUF0b21Qcm9qZWN0b3IucmVzdWx0cy5tYXAociA9PiByLnJlbmRlck1hcXVldHRlKCkpfVxyXG4gICAgICAgICAgICAgICAgICAgIHtwcm9wZXJ0eUJhci5yZW5kZXJTdHlsZU1vbGVjdWxlQ2hpbGRyZW4ocHJvcGVydHlCYXIpfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGtleT1cIjJcIiBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIiB9fT5cclxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgbGlkPXtzdHlsZWRMYXlvdXRCYXNlSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLnNlbGVjdExheW91dEJhc2VDbGlja0hhbmRsZXJ9PmxheW91dCAje3N0eWxlZExheW91dEJhc2VJZFN0cmluZ308L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj4gYXMgVk5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHN5bmNUb1JlZmVyZW5jZVN0eWxlQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5TeW5jU3R5bGVNb2xlY3VsZVRvUmVmZXJlbmNlU3R5bGVKc29uKHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcIm1pZFwiKSkuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc3luY0Zyb21SZWZlcmVuY2VTdHlsZUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuU3luY1N0eWxlTW9sZWN1bGVGcm9tUmVmZXJlbmNlU3R5bGVKc29uKHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcIm1pZFwiKSkuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY3JlYXRlUmVmZXJlbmNlU3R5bGVNb2xlY3VsZUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuU2V0U3R5bGVNb2xlY3VsZUFzUmVmZXJlbmNlU3R5bGVKc29uKHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcIm1pZFwiKSkuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyU3R5bGVNb2xlY3VsZVJlZmVyZW5jZVNlbGVjdG9yID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICAvLyBUT0RPIGVuYWJsZSB3aGVuIGJhY2tlbmQgZnVuY3Rpb25hbGl0eSBpcyBpbXBsZW1lbnRlZFxyXG4gICAgICAgIHJldHVybiA8ZGl2IGtleT1cIi0xXCI+XHJcbiAgICAgICAgICAgIDxzZWxlY3QgZGlzYWJsZWQgb25jaGFuZ2U9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnN0eWxlTW9sZWN1bGVSZWZlcmVuY2VDaGFuZ2VkSGFuZGxlcn0+XHJcbiAgICAgICAgICAgICAgICB7Y3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlTW9sZWN1bGVzLm1hcChtb2wgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gZXhwZW5zaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vbC5DbG9uZWRGcm9tU3R5bGVJZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBzdHlsZXMgd2hpY2ggYXJlIG5vdCByZWZlcmVuY2Ugc3R5bGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdHlsZU1vbGVjdWxlSWRTdHJpbmc6IHN0cmluZyA9IG1vbC5TdHlsZU1vbGVjdWxlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobW9sLlN0eWxlTW9sZWN1bGVJZCA9PSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZU1vbGVjdWxlSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxvcHRpb24gc2VsZWN0ZWQga2V5PXtzdHlsZU1vbGVjdWxlSWRTdHJpbmd9IHZhbHVlPXtzdHlsZU1vbGVjdWxlSWRTdHJpbmd9Pnttb2wuTmFtZX0gI3ttb2wuU3R5bGVNb2xlY3VsZUlkfTwvb3B0aW9uPjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8b3B0aW9uIGtleT17c3R5bGVNb2xlY3VsZUlkU3RyaW5nfSB2YWx1ZT17c3R5bGVNb2xlY3VsZUlkU3RyaW5nfT57bW9sLk5hbWV9ICN7bW9sLlN0eWxlTW9sZWN1bGVJZH08L29wdGlvbj47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSl9XHJcbiAgICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHN0eWxlTW9sZWN1bGVSZWZlcmVuY2VDaGFuZ2VkSGFuZGxlciA9IChldnQ6IFVJRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgdGFyZ2V0U2VsZWN0ID0gZXZ0LnRhcmdldCBhcyBIVE1MU2VsZWN0RWxlbWVudDtcclxuICAgICAgICBsZXQgcGFyc2VkU3R5bGVNb2xlY3VsZUlkOiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKHRhcmdldFNlbGVjdC5zZWxlY3RlZEluZGV4IDwgdGFyZ2V0U2VsZWN0LmNoaWxkRWxlbWVudENvdW50KSB7XHJcbiAgICAgICAgICAgIGxldCBzZWxlY3RPcHRpb25FbGVtZW50OiBIVE1MT3B0aW9uRWxlbWVudCA9IHRhcmdldFNlbGVjdC5vcHRpb25zW3RhcmdldFNlbGVjdC5zZWxlY3RlZEluZGV4XTtcclxuICAgICAgICAgICAgcGFyc2VkU3R5bGVNb2xlY3VsZUlkID0gcGFyc2VJbnQoc2VsZWN0T3B0aW9uRWxlbWVudC52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXJzZWRTdHlsZU1vbGVjdWxlSWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuU2V0U3R5bGVNb2xlY3VsZVJlZmVyZW5jZUpzb24odGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3R5bGVNb2xlY3VsZUlkLCBwYXJzZWRTdHlsZU1vbGVjdWxlSWQpLmRvbmUoZGF0YSA9PiBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJTdHlsZU1vbGVjdWxlQ2hpbGRyZW4gPSAocHJvcGVydHlCYXI6IFByb3BlcnR5QmFyKTogVk5vZGUgPT4ge1xyXG4gICAgICAgIGxldCBjaGlsZE1vbGVjdWxlczogU3R5bGVNb2xlY3VsZVtdID0gW107XHJcbiAgICAgICAgaWYgKHByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFN0eWxlTW9sZWN1bGVJZCAhPSAwKSB7XHJcbiAgICAgICAgICAgIGNoaWxkTW9sZWN1bGVzID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlTW9sZWN1bGVzLmZpbHRlcihzID0+IHMuQ2xvbmVkRnJvbVN0eWxlSWQgPT0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3R5bGVNb2xlY3VsZUlkKTsgLy8gVE9ETyBleHBlbnNpdmUgLy8gVE9ETyBldmVyeXdoZXJlIHdoZXJlIHNvbWV0aGluZyBsaWtlIHMuQ2xvbmVkRnJvbVN0eWxlSWQgaXMgdXNlZDogcmVzZXQgdmlldyBiZWZvcmUgZWxlbWVudHMgYXJlIGRlbGV0ZWQuLiB0aGlzIGNhbiB0aHJvdyB1bmRlZmluZWRcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDxkaXYga2V5PVwiLTRcIj4gYWZmZWN0cyBzdHlsZXM6XHJcbiAgICAgICAgICAgIHtjaGlsZE1vbGVjdWxlcy5tYXAocyA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVNb2xlY3VsZUlkU3RyaW5nOiBzdHJpbmcgPSBzLlN0eWxlTW9sZWN1bGVJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYga2V5PXtzdHlsZU1vbGVjdWxlSWRTdHJpbmd9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiBtaWQ9e3N0eWxlTW9sZWN1bGVJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuc2VsZWN0U3R5bGVNb2xlY3VsZUNsaWNrSGFuZGxlcn0+I3tzdHlsZU1vbGVjdWxlSWRTdHJpbmd9PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj47XHJcbiAgICAgICAgICAgIH0pfVxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlbmRlckJveFRyZWVGb3JDYWxpZm9ybmlhVmlldyA9IChwcm9wZXJ0eUJhcjogUHJvcGVydHlCYXIpOiBtYXF1ZXR0ZS5NYXBwaW5nPENhbGlmb3JuaWFWaWV3LCB7IHJlbmRlck1hcXVldHRlOiAoKSA9PiBtYXF1ZXR0ZS5WTm9kZSB9PiA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG1hcXVldHRlLmNyZWF0ZU1hcHBpbmc8Q2FsaWZvcm5pYVZpZXcsIGFueT4oXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFNlY3Rpb25Tb3VyY2VLZXkoc291cmNlOiBDYWxpZm9ybmlhVmlldykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5DYWxpZm9ybmlhVmlld0lkO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVTZWN0aW9uVGFyZ2V0KHNvdXJjZTogQ2FsaWZvcm5pYVZpZXcpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzb3VyY2VDYWxpZm9ybmlhVmlld0lkU3RyaW5nID0gc291cmNlLkNhbGlmb3JuaWFWaWV3SWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGxldCBsYXlvdXRSb3dzID0gcHJvcGVydHlCYXIucmVuZGVyTGF5b3V0Um93QXJyYXkocHJvcGVydHlCYXIpO1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0Um93cy5tYXAoc291cmNlLlBsYWNlZExheW91dFJvd3MpO1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBzaG93IGJvZHkraHRtbCBzdHlsZSBtb2xlY3VsZSBpbiBwYWdlIHByZXZpZXdcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTWFxdWV0dGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRyZWVWaWV3U3R5bGVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiZmxleFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmbGV4LWRpcmVjdGlvblwiOiBcInJvd1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmbGV4LXdyYXBcIjogXCJ3cmFwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1yaWdodFwiOiBcIi0xNXB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZvbnQtZmFtaWx5XCI6IFwic2Fucy1zZXJpZlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cIndpZHRoXCI6IFwiOTAwcHhcIiwgLy8gVE9ETyB3b3JrYXJvdW5kIGVsZW1lbnRzIGJyZWFraW5nIGxpbmUuLi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYm9yZGVyLWJvdHRvbVwiOiBcInNvbGlkLCAxcHgsIGJsYWNrXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogXCJhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhZGRpbmctYm90dG9tXCI6IFwiMTIzcHhcIiAvKlRPRE8gc2l6ZSBvZiBuKmVsZW1lbnQgZm9yIGFkZC9jcmVhdGUgbGF5b3V0IGVsZW1lbnRzIGF0IGVuZCwgY3VycmVudGx5IDEyMCszKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChwcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRDYWxpZm9ybmlhVmlld0lkID09IHNvdXJjZS5DYWxpZm9ybmlhVmlld0lkKSA/IDxkaXYga2V5PXtzb3VyY2VDYWxpZm9ybmlhVmlld0lkU3RyaW5nfSBzdHlsZXM9e3RyZWVWaWV3U3R5bGVzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtsYXlvdXRSb3dzLnJlc3VsdHMubWFwKHIgPT4gci5yZW5kZXJNYXF1ZXR0ZSgpKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+IDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAodXBkYXRlZFNvdXJjZTogQ2FsaWZvcm5pYVZpZXcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gdXBkYXRlZFNvdXJjZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0Um93cy5tYXAoc291cmNlLlBsYWNlZExheW91dFJvd3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VDYWxpZm9ybmlhVmlld0lkU3RyaW5nID0gc291cmNlLkNhbGlmb3JuaWFWaWV3SWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVTZWN0aW9uVGFyZ2V0KHVwZGF0ZWRTb3VyY2U6IENhbGlmb3JuaWFWaWV3LCB0YXJnZXQ6IHsgcmVuZGVyTWFxdWV0dGUoKTogYW55LCB1cGRhdGUodXBkYXRlZFNvdXJjZTogQ2FsaWZvcm5pYVZpZXcpOiB2b2lkIH0pIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC51cGRhdGUodXBkYXRlZFNvdXJjZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyTGF5b3V0Um93QXJyYXkgPSAocHJvcGVydHlCYXI6IFByb3BlcnR5QmFyKTogbWFxdWV0dGUuTWFwcGluZzxMYXlvdXRSb3csIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+ID0+IHsgLy8gVE9ETyBjb2RlIGR1cGxpY2F0aW9uIHdpdGggcGFnZSBwcmV2aWV3XHJcbiAgICAgICAgcmV0dXJuIG1hcXVldHRlLmNyZWF0ZU1hcHBpbmc8TGF5b3V0Um93LCBhbnk+KFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRTZWN0aW9uU291cmNlS2V5KHNvdXJjZTogTGF5b3V0Um93KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlLkxheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlU2VjdGlvblRhcmdldChzb3VyY2U6IExheW91dFJvdykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZUxheW91dFJvd0lkU3RyaW5nID0gc291cmNlLkxheW91dEJhc2VJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlbmRlcmVkTGF5b3V0Qm94ZXMgPSBwcm9wZXJ0eUJhci5yZW5kZXJMYXlvdXRCb3hBcnJheShwcm9wZXJ0eUJhcik7XHJcbiAgICAgICAgICAgICAgICBsZXQgdW5zb3J0ZWRCb3hlczogTGF5b3V0Qm94W10gPSBzb3VyY2UuQWxsQm94ZXNCZWxvd1Jvdy5maWx0ZXIoYiA9PiBiLlBsYWNlZEJveEluQm94SWQgPT09IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc29ydGVkQm94ZXM6IExheW91dEJveFtdID0gdW5zb3J0ZWRCb3hlcy5zb3J0KChib3hBOiBMYXlvdXRCb3gsIGJveEI6IExheW91dEJveCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib3hBLkxheW91dFNvcnRPcmRlcktleSA8IGJveEIuTGF5b3V0U29ydE9yZGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYm94QS5MYXlvdXRTb3J0T3JkZXJLZXkgPT0gYm94Qi5MYXlvdXRTb3J0T3JkZXJLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBib3hBLkxheW91dFNvcnRPcmRlcktleSA+IGJveEIuTGF5b3V0U29ydE9yZGVyS2V5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZWRMYXlvdXRCb3hlcy5tYXAoc29ydGVkQm94ZXMpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlTW9sZWN1bGVJZDogbnVtYmVyID0gKGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcy5maW5kKG0gPT4gbS5TdHlsZUZvckxheW91dElkID09IHNvdXJjZS5MYXlvdXRCYXNlSWQpIGFzIFN0eWxlTW9sZWN1bGUpLlN0eWxlTW9sZWN1bGVJZDsgLy8gVE9ETyBleHBlbnNpdmVcclxuICAgICAgICAgICAgICAgIGxldCBzdHlsZU1vbGVjdWxlSWRTdHJpbmc6IHN0cmluZyA9IHN0eWxlTW9sZWN1bGVJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxheW91dFJvd1N0eWxlQ2xhc3M6IHN0cmluZyA9IGBzJHtzdHlsZU1vbGVjdWxlSWRTdHJpbmd9YDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTWFxdWV0dGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRyZWVSb3dTdHlsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsZXgtYmFzaXNcIjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXgtd2lkdGhcIjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhZGRpbmctbGVmdFwiOiBcIjE1cHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFkZGluZy1yaWdodFwiOiBcIjE1cHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcInJnYigyMjIsIDIyMiwgMjIyKVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjYXB0aW9uU3R5bGVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmbGV4LWJhc2lzXCI6IFwiYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcImF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIjogXCJyZ2IoNzgsIDc4LCA3OClcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFkZGluZy1sZWZ0XCI6IFwiMTVweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nLXJpZ2h0XCI6IFwiMTVweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW5cIjogXCIwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogXCJyZ2IoMjIyLCAyMjIsIDIyMilcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dC1kZWNvcmF0aW9uXCI6IFwidW5kZXJsaW5lXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpdkJ1dHRvblN0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcImZsZXhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxleC1kaXJlY3Rpb25cIjogXCJyb3dcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxleC13cmFwXCI6IFwibm93cmFwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1wibWFyZ2luLWxlZnRcIjogXCItMTVweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tcmlnaHRcIjogXCItMTVweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcImF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBidXR0b25TdHlsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZvbnQtc2l6ZVwiOiBcIjEwcHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIjogXCJyZ2IoNzgsIDc4LCA3OClcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcInJnYigyMjIsIDIyMiwgMjIyKVwiLCAvLyBUT0RPIG1hZ2ljIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCJhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsZXhcIjogXCIwIDAgYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvdXRsaW5lXCI6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3V0bGluZS1vZmZzZXRcIjogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpc1ByZXNlbGVjdGVkQW55OiBib29sZWFuID0gY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCAhPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXNQcmVzZWxlY3RlZEN1cnJlbnQ6IGJvb2xlYW4gPSBpc1ByZXNlbGVjdGVkQW55ICYmIGN1cnJlbnRBcHAuc3RhdGUucHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQgPT0gc291cmNlLkxheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJ1dHRvblN0eWxlc1RhcmdldCA9IHsgLy8gVE9ETyBhcHBlbmQgYXJyYXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZm9udC1zaXplXCI6IFwiMTBweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiAhaXNQcmVzZWxlY3RlZEFueSB8fCBpc1ByZXNlbGVjdGVkQ3VycmVudCA/IFwicmdiKDIyMiwgMjIyLCAyMjIpXCIgOiBcInJnYig3OCwgNzgsIDc4KVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwicmdiKDIyMiwgMjIyLCAyMjIpXCIsIC8vIFRPRE8gbWFnaWMgc3RyaW5nc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcImF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm91dGxpbmVcIjogIWlzUHJlc2VsZWN0ZWRBbnkgfHwgaXNQcmVzZWxlY3RlZEN1cnJlbnQgPyB1bmRlZmluZWQgOiBcInNvbGlkIDRweCByZ2IoMjAwLDAsMClcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3V0bGluZS1vZmZzZXRcIjogIWlzUHJlc2VsZWN0ZWRBbnkgfHwgaXNQcmVzZWxlY3RlZEN1cnJlbnQgPyB1bmRlZmluZWQgOiBcIi00cHhcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYnV0dG9uU3R5bGVzUHJlc2VsZWN0Um93ID0geyAvLyBUT0RPIGFwcGVuZCBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmb250LXNpemVcIjogXCIxMHB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCI6IGlzUHJlc2VsZWN0ZWRDdXJyZW50ID8gXCJyZ2IoMjIyLDIyMiwyMjIpXCIgOiBpc1ByZXNlbGVjdGVkQW55ID8gXCJyZ2IoMjIyLCAyMjIsIDIyMilcIiA6IFwicmdiKDc4LCA3OCwgNzgpXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogaXNQcmVzZWxlY3RlZEN1cnJlbnQgPyBcInJnYigyMDAsMCwwKVwiIDogXCJyZ2IoMjIyLCAyMjIsIDIyMilcIiwgLy8gVE9ETyBtYWdpYyBzdHJpbmdzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3V0bGluZVwiOiBpc1ByZXNlbGVjdGVkQ3VycmVudCB8fCBpc1ByZXNlbGVjdGVkQW55ID8gdW5kZWZpbmVkIDogXCJzb2xpZCAxcHggcmdiKDIwMCwwLDApXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm91dGxpbmUtb2Zmc2V0XCI6IGlzUHJlc2VsZWN0ZWRDdXJyZW50IHx8IGlzUHJlc2VsZWN0ZWRBbnkgPyB1bmRlZmluZWQgOiBcIi0xcHhcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGl2U3ViQm94U3R5bGVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmbGV4LWJhc2lzXCI6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIjEwMCVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWF4LXdpZHRoXCI6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nLWxlZnRcIjogXCIxNXB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhZGRpbmctcmlnaHRcIjogXCIxNXB4XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYga2V5PXtzb3VyY2VMYXlvdXRSb3dJZFN0cmluZ30gc3R5bGVzPXt0cmVlUm93U3R5bGVzfSBsaWQ9e3NvdXJjZUxheW91dFJvd0lkU3RyaW5nfSBvbm1vdXNlZW50ZXI9e3Byb3BlcnR5QmFyLmxheW91dEJhc2VNb3VzZUVudGVySGFuZGxlcn0gb25tb3VzZWxlYXZlPXtwcm9wZXJ0eUJhci5sYXlvdXRCYXNlTW91c2VMZWF2ZUhhbmRsZXJ9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9XCItMlwiIHN0eWxlcz17ZGl2QnV0dG9uU3R5bGVzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBrZXk9XCItMVwiIHN0eWxlcz17Y2FwdGlvblN0eWxlc30+Uk9XPC9wPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHN0eWxlcz17YnV0dG9uU3R5bGVzfSBsaWQ9e3NvdXJjZUxheW91dFJvd0lkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5pbnNlcnRMYXlvdXRCb3hJbnRvQm94Q2xpY2tIYW5kbGVyfT4rKEIpPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJiXCIgc3R5bGVzPXtidXR0b25TdHlsZXN9IGxpZD17c291cmNlTGF5b3V0Um93SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLnNlbGVjdExheW91dEJhc2VDbGlja0hhbmRsZXJ9PiYjODIzMDt7LyplbGxpcHNpcyBUT0RPIGNoZWNrIGlzIHRoaXMgY29tbWVudCByZW1vdmVkKi99PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJjXCIgc3R5bGVzPXtidXR0b25TdHlsZXN9IGxpZD17c291cmNlTGF5b3V0Um93SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmhpZ2hsaWdodExheW91dEJhc2VDbGlja0hhbmRsZXJ9Pj88L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImRcIiBzdHlsZXM9e2J1dHRvblN0eWxlc30gbWlkPXtzdHlsZU1vbGVjdWxlSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLnNlbGVjdFN0eWxlTW9sZWN1bGVDbGlja0hhbmRsZXJ9PlMmIzgyMzA7PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJlXCIgc3R5bGVzPXtidXR0b25TdHlsZXN9IGxpZD17c291cmNlTGF5b3V0Um93SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLnNhdmVMYXlvdXRNb2xlY3VsZUNsaWNrSGFuZGxlcn0+ISEhPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2lzUHJlc2VsZWN0ZWRDdXJyZW50IHx8ICFpc1ByZXNlbGVjdGVkQW55ID8gPGJ1dHRvbiBrZXk9XCJmXCIgc3R5bGVzPXtidXR0b25TdHlsZXNQcmVzZWxlY3RSb3d9IGxpZD17c291cmNlTGF5b3V0Um93SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLm1vdmVMYXlvdXRSb3dCZWZvcmVSb3dDbGlja0hhbmRsZXJ9Pk1WKFIpPC9idXR0b24+IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJmMFwiIHN0eWxlcz17YnV0dG9uU3R5bGVzUHJlc2VsZWN0Um93fSBsaWQ9e3NvdXJjZUxheW91dFJvd0lkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5tb3ZlTGF5b3V0Um93QmVmb3JlUm93Q2xpY2tIYW5kbGVyfT5NVihSKTwvYnV0dG9uPn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aXNQcmVzZWxlY3RlZEN1cnJlbnQgfHwgIWlzUHJlc2VsZWN0ZWRBbnkgPyA8YnV0dG9uIGtleT1cImdcIiBzdHlsZXM9e2J1dHRvblN0eWxlc1ByZXNlbGVjdFJvd30gbGlkPXtzb3VyY2VMYXlvdXRSb3dJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuc3luY0xheW91dEJhc2VTdHlsZXNDbGlja0hhbmRsZXJ9PlNUKFIpPC9idXR0b24+IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJnMFwiIHN0eWxlcz17YnV0dG9uU3R5bGVzUHJlc2VsZWN0Um93fSBsaWQ9e3NvdXJjZUxheW91dFJvd0lkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5zeW5jTGF5b3V0QmFzZVN0eWxlc0NsaWNrSGFuZGxlcn0+U1QoUik8L2J1dHRvbj59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2lzUHJlc2VsZWN0ZWRBbnkgJiYgIWlzUHJlc2VsZWN0ZWRDdXJyZW50ID8gPGJ1dHRvbiBrZXk9XCJoXCIgc3R5bGVzPXtidXR0b25TdHlsZXNUYXJnZXR9IGxpZD17c291cmNlTGF5b3V0Um93SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmZpbmFsaXplTGF5b3V0UmVxdWVzdH0+JChCOlIpPC9idXR0b24+IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJoMFwiIHN0eWxlcz17YnV0dG9uU3R5bGVzVGFyZ2V0fSBsaWQ9e3NvdXJjZUxheW91dFJvd0lkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5maW5hbGl6ZUxheW91dFJlcXVlc3R9PiQoQjpSKTwvYnV0dG9uPn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IWlzUHJlc2VsZWN0ZWRBbnkgPyA8YnV0dG9uIGtleT1cImlcIiBzdHlsZXM9e2J1dHRvblN0eWxlc30gbGlkPXtzb3VyY2VMYXlvdXRSb3dJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuZGVsZXRlTGF5b3V0QmFzZUNsaWNrSGFuZGxlcn0+WDwvYnV0dG9uPiA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gZGlzYWJsZWQga2V5PVwiaTBcIiBzdHlsZXM9e2J1dHRvblN0eWxlc30gbGlkPXtzb3VyY2VMYXlvdXRSb3dJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuZGVsZXRlTGF5b3V0QmFzZUNsaWNrSGFuZGxlcn0+WDwvYnV0dG9uPn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IWlzUHJlc2VsZWN0ZWRBbnkgJiYgc29ydGVkQm94ZXMubGVuZ3RoID4gMCA/IDxidXR0b24ga2V5PVwialwiIHN0eWxlcz17YnV0dG9uU3R5bGVzfSBsaWQ9e3NvdXJjZUxheW91dFJvd0lkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5kZWxldGVCZWxvd0xheW91dEJhc2VDbGlja0hhbmRsZXJ9PkNMUjwvYnV0dG9uPiA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gZGlzYWJsZWQga2V5PVwiajBcIiBzdHlsZXM9e2J1dHRvblN0eWxlc30gbGlkPXtzb3VyY2VMYXlvdXRSb3dJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuZGVsZXRlQmVsb3dMYXlvdXRCYXNlQ2xpY2tIYW5kbGVyfT5DTFI8L2J1dHRvbj59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYga2V5PVwiMFwiIHN0eWxlcz17ZGl2U3ViQm94U3R5bGVzfT57cmVuZGVyZWRMYXlvdXRCb3hlcy5yZXN1bHRzLm1hcChyID0+IHIucmVuZGVyTWFxdWV0dGUoKSl9PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PjtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKHVwZGF0ZWRTb3VyY2U6IExheW91dFJvdykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSB1cGRhdGVkU291cmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VMYXlvdXRSb3dJZFN0cmluZyA9IHNvdXJjZS5MYXlvdXRCYXNlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5zb3J0ZWRCb3hlcyA9IHNvdXJjZS5BbGxCb3hlc0JlbG93Um93LmZpbHRlcihiID0+IGIuUGxhY2VkQm94SW5Cb3hJZCA9PT0gdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29ydGVkQm94ZXMgPSB1bnNvcnRlZEJveGVzLnNvcnQoKGJveEE6IExheW91dEJveCwgYm94QjogTGF5b3V0Qm94KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm94QS5MYXlvdXRTb3J0T3JkZXJLZXkgPCBib3hCLkxheW91dFNvcnRPcmRlcktleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJveEEuTGF5b3V0U29ydE9yZGVyS2V5ID09IGJveEIuTGF5b3V0U29ydE9yZGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gYm94QS5MYXlvdXRTb3J0T3JkZXJLZXkgPiBib3hCLkxheW91dFNvcnRPcmRlcktleVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRMYXlvdXRCb3hlcy5tYXAoc29ydGVkQm94ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZU1vbGVjdWxlSWQgPSAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlTW9sZWN1bGVzLmZpbmQobSA9PiBtLlN0eWxlRm9yTGF5b3V0SWQgPT0gc291cmNlLkxheW91dEJhc2VJZCkgYXMgU3R5bGVNb2xlY3VsZSkuU3R5bGVNb2xlY3VsZUlkOyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZU1vbGVjdWxlSWRTdHJpbmcgPSBzdHlsZU1vbGVjdWxlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0Um93U3R5bGVDbGFzcyA9IGBzJHtzdHlsZU1vbGVjdWxlSWR9YDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVTZWN0aW9uVGFyZ2V0KHVwZGF0ZWRTb3VyY2U6IExheW91dFJvdywgdGFyZ2V0OiB7IHJlbmRlck1hcXVldHRlKCk6IGFueSwgdXBkYXRlKHVwZGF0ZWRTb3VyY2U6IExheW91dFJvdyk6IHZvaWQgfSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnVwZGF0ZSh1cGRhdGVkU291cmNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgcmVuZGVyTGF5b3V0Qm94QXJyYXkgPSAocHJvcGVydHlCYXI6IFByb3BlcnR5QmFyKTogbWFxdWV0dGUuTWFwcGluZzxMYXlvdXRCb3gsIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+ID0+IHtcclxuICAgICAgICByZXR1cm4gbWFxdWV0dGUuY3JlYXRlTWFwcGluZzxMYXlvdXRCb3gsIGFueT4oXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFNlY3Rpb25Tb3VyY2VLZXkoc291cmNlOiBMYXlvdXRCb3gpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2UuTGF5b3V0QmFzZUlkO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVTZWN0aW9uVGFyZ2V0KHNvdXJjZTogTGF5b3V0Qm94KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc291cmNlTGF5b3V0Qm94SWRTdHJpbmcgPSBzb3VyY2UuTGF5b3V0QmFzZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVuZGVyZWRMYXlvdXRBdG9tcyA9IHByb3BlcnR5QmFyLnJlbmRlckxheW91dEF0b21BcnJheShwcm9wZXJ0eUJhcik7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVuZGVyZWRMYXlvdXRCb3hlcyA9IHByb3BlcnR5QmFyLnJlbmRlckxheW91dEJveEFycmF5KHByb3BlcnR5QmFyKTtcclxuICAgICAgICAgICAgICAgIGxldCBzdHlsZU1vbGVjdWxlSWQ6IG51bWJlciA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChtID0+IG0uU3R5bGVGb3JMYXlvdXRJZCA9PSBzb3VyY2UuTGF5b3V0QmFzZUlkKSBhcyBTdHlsZU1vbGVjdWxlKS5TdHlsZU1vbGVjdWxlSWQ7IC8vIFRPRE8gZXhwZW5zaXZlXHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVNb2xlY3VsZUlkU3RyaW5nOiBzdHJpbmcgPSBzdHlsZU1vbGVjdWxlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGxldCBsYXlvdXRCb3hTdHlsZUNsYXNzOiBzdHJpbmcgPSBgcyR7c3R5bGVNb2xlY3VsZUlkfWA7XHJcbiAgICAgICAgICAgICAgICAvLyAtLS0gb25seSByZW5kZXIgbW9kZTogdHJlZSAtLS1cclxuICAgICAgICAgICAgICAgIGxldCBkZWVwbmVzc1BhZGRpbmc6IHN0cmluZyA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2FsY3VsYXRlZEJhY2tncm91bmRDb2xvcjogc3RyaW5nID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIGxldCBjYWxjdWxhdGVkQ29sb3I6IHN0cmluZyA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2FsY3VsYXRlZEJvcmRlckNvbG9yOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgbGV0IGhhc1N1YkF0b21zOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBsZXQgaXNPZGRMZXZlbDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLy8gLS0tXHJcbiAgICAgICAgICAgICAgICBkZWVwbmVzc1BhZGRpbmcgPSBgJHsoc291cmNlLkxldmVsICsgMSkgKiAxNX1weGA7XHJcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkQmFja2dyb3VuZENvbG9yID0gcHJvcGVydHlCYXIuY2FsY3VsYXRlQmFja2dyb3VuZENvbG9yRm9yTGV2ZWwoc291cmNlLkxldmVsKTtcclxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRDb2xvciA9IHByb3BlcnR5QmFyLmNhbGN1bGF0ZUNvbG9yRm9yTGV2ZWwoc291cmNlLkxldmVsKTtcclxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRCb3JkZXJDb2xvciA9IGBzb2xpZCAxcHggJHtwcm9wZXJ0eUJhci5jYWxjdWxhdGVCYWNrZ3JvdW5kQ29sb3JGb3JMZXZlbChzb3VyY2UuTGV2ZWwgKyAxKX1gO1xyXG4gICAgICAgICAgICAgICAgaGFzU3ViQXRvbXMgPSBzb3VyY2UuUGxhY2VkSW5Cb3hBdG9tcy5sZW5ndGggPiAwO1xyXG4gICAgICAgICAgICAgICAgaXNPZGRMZXZlbCA9IChzb3VyY2UuTGV2ZWwgJSAyKSAhPSAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJNYXF1ZXR0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVuZGVyZWRCb3hDb250ZW50OiBWTm9kZVtdID0gY3VycmVudEFwcC5wYWdlUHJldmlldy5tYXBBbmRSZW5kZXJMYXlvdXRCb3hDb250ZW50KHNvdXJjZSwgc291cmNlLlBsYWNlZEluQm94QXRvbXMsIHJlbmRlcmVkTGF5b3V0QXRvbXMsIHNvdXJjZS5QbGFjZWRJbkJveEJveGVzLCByZW5kZXJlZExheW91dEJveGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRyZWVCb3hTdHlsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsZXgtZGlyZWN0aW9uXCI6IFwicm93XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsZXgtd3JhcFwiOiBcIndyYXBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXCJtYXJnaW4tbGVmdFwiOiBcIi0xNXB4XCIsIFRPRE8gc3RhaXIgZWZmZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1yaWdodFwiOiBcIi0xNXB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogXCJyZ2IoMjIyLCAyMjIsIDIyMilcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYm9yZGVyLWJvdHRvbVwiOiBoYXNTdWJBdG9tcyA/IGNhbGN1bGF0ZWRCb3JkZXJDb2xvciA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYm9yZGVyLWxlZnRcIjogXCJzb2xpZCAxcHggYmxhY2tcIiwvLyBoYXNTdWJBdG9tcyA/IGNhbGN1bGF0ZWRCb3JkZXJDb2xvciA6IHVuZGVmaW5lZCAvLyBUT0RPIG9ubHkgbmV4dCB0byBhdG9tc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ6b29tXCI6IFwiMS4wNVwiIC8vIFRPRE8gY2FsZWlkb3Njb3BlIC8gem9vbSBmYWN0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJveENhcHRpb25TdHlsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhZGRpbmctbGVmdFwiOiBcIjE1cHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFkZGluZy1yaWdodFwiOiBcIjE1cHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCJhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsZXhcIjogXCIwIDAgYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW5cIjogXCIwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRleHQtZGVjb3JhdGlvblwiOiBcInVuZGVybGluZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiBjYWxjdWxhdGVkQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogY2FsY3VsYXRlZEJhY2tncm91bmRDb2xvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZm9udC1zdHJldGNoXCI6IGlzT2RkTGV2ZWwgPyBcImV4dHJhLWNvbmRlbnNlZFwiIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaXZCdXR0b25TdHlsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRpc3BsYXlcIjogXCJmbGV4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsZXgtZGlyZWN0aW9uXCI6IFwicm93XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsZXgtd3JhcFwiOiBcIm5vd3JhcFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tbGVmdFwiOiBcIi0xNXB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1yaWdodFwiOiBcIi0xNXB4XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJ1dHRvblN0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZm9udC1zaXplXCI6IFwiMTBweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiBjYWxjdWxhdGVkQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogY2FsY3VsYXRlZEJhY2tncm91bmRDb2xvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCJhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsZXhcIjogXCIwIDAgYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvdXRsaW5lXCI6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3V0bGluZS1vZmZzZXRcIjogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBidXR0b25EaXNhYmxlZFN0eWxlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZm9udC1zaXplXCI6IFwiMTBweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwicmdiKDI0MiwyNDIsMjQyKVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiBjYWxjdWxhdGVkQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3V0bGluZVwiOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm91dGxpbmUtb2Zmc2V0XCI6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXNQcmVzZWxlY3RlZEFueTogYm9vbGVhbiA9IGN1cnJlbnRBcHAuc3RhdGUucHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQgIT0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzUHJlc2VsZWN0ZWRDdXJyZW50OiBib29sZWFuID0gaXNQcmVzZWxlY3RlZEFueSAmJiBjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkID09IHNvdXJjZS5MYXlvdXRCYXNlSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBidXR0b25TdHlsZXNUYXJnZXQgPSB7IC8vIFRPRE8gYXBwZW5kIGFycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZvbnQtc2l6ZVwiOiBcIjEwcHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIjogIWlzUHJlc2VsZWN0ZWRBbnkgfHwgaXNQcmVzZWxlY3RlZEN1cnJlbnQgPyBjYWxjdWxhdGVkQmFja2dyb3VuZENvbG9yIDogY2FsY3VsYXRlZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IGNhbGN1bGF0ZWRCYWNrZ3JvdW5kQ29sb3IsIC8vIFRPRE8gbWFnaWMgc3RyaW5nc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcImF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm91dGxpbmVcIjogIWlzUHJlc2VsZWN0ZWRBbnkgfHwgaXNQcmVzZWxlY3RlZEN1cnJlbnQgPyB1bmRlZmluZWQgOiBcInNvbGlkIDRweCByZ2IoMjAwLDAsMClcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3V0bGluZS1vZmZzZXRcIjogIWlzUHJlc2VsZWN0ZWRBbnkgfHwgaXNQcmVzZWxlY3RlZEN1cnJlbnQgPyB1bmRlZmluZWQgOiBcIi00cHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJ1dHRvblN0eWxlc1ByZXNlbGVjdEFueSA9IHsgLy8gVE9ETyBhcHBlbmQgYXJyYXkgLy8gVE9ETyBkaWZmZXJlbnRpYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZvbnQtc2l6ZVwiOiBcIjEwcHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiY29sb3JcIjogaXNQcmVzZWxlY3RlZEN1cnJlbnQgPyBjYWxjdWxhdGVkQmFja2dyb3VuZENvbG9yIDogaXNQcmVzZWxlY3RlZEFueSA/IGNhbGN1bGF0ZWRCYWNrZ3JvdW5kQ29sb3IgOiBjYWxjdWxhdGVkQ29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogaXNQcmVzZWxlY3RlZEN1cnJlbnQgPyBcInJnYigyMDAsMCwwKVwiIDogY2FsY3VsYXRlZEJhY2tncm91bmRDb2xvciwgLy8gVE9ETyBtYWdpYyBzdHJpbmdzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3V0bGluZVwiOiBpc1ByZXNlbGVjdGVkQ3VycmVudCB8fCBpc1ByZXNlbGVjdGVkQW55ID8gdW5kZWZpbmVkIDogXCJzb2xpZCAxcHggcmdiKDIwMCwwLDApXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm91dGxpbmUtb2Zmc2V0XCI6IGlzUHJlc2VsZWN0ZWRDdXJyZW50IHx8IGlzUHJlc2VsZWN0ZWRBbnkgPyB1bmRlZmluZWQgOiBcIi0xcHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRpdlN1YlRyZWVTdHlsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsZXgtYmFzaXNcIjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXgtd2lkdGhcIjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhZGRpbmctbGVmdFwiOiBcIjE1cHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFkZGluZy1yaWdodFwiOiBcIjE1cHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBjYWxjdWxhdGVkQmFja2dyb3VuZENvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gZG9jdW1lbnQ6IHdob2xlIGNsaWVudCBhcHAgcmVsaWVzIG9uIGRhdGFiYXNlIGtleXMgYmVpbmcgc3RyaWN0bHkgcG9zaXRpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBjb25jZXB0K2RvIGV2ZXJ5d2hlcmU6IGluIHRoaXMgY2FzZSBtYW55IGh0bWwgdGFncyBhcmUgc2V0IHdoZW4gMSB3b3VsZCBiZSBlbm91Z2ggb24gcGFyZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17c291cmNlTGF5b3V0Qm94SWRTdHJpbmd9IHN0eWxlcz17dHJlZUJveFN0eWxlc30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT1cIjBcIiBzdHlsZXM9e2RpdlN1YlRyZWVTdHlsZXN9IGxpZD17c291cmNlTGF5b3V0Qm94SWRTdHJpbmd9IG9ubW91c2VlbnRlcj17cHJvcGVydHlCYXIubGF5b3V0QmFzZU1vdXNlRW50ZXJIYW5kbGVyfSBvbm1vdXNlbGVhdmU9e3Byb3BlcnR5QmFyLmxheW91dEJhc2VNb3VzZUxlYXZlSGFuZGxlcn0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9XCItMlwiIHN0eWxlcz17ZGl2QnV0dG9uU3R5bGVzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgezxwIGtleT1cIi0xXCIgc3R5bGVzPXtib3hDYXB0aW9uU3R5bGVzfT5CT1h7IWlzT2RkTGV2ZWwgPyBcIiB8XCIgOiB1bmRlZmluZWR9PC9wPn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgc3R5bGVzPXtidXR0b25TdHlsZXN9IGxpZD17c291cmNlTGF5b3V0Qm94SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmluc2VydExheW91dEF0b21JbnRvQm94Q2xpY2tIYW5kbGVyfT4rKEEpPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYlwiIHN0eWxlcz17YnV0dG9uU3R5bGVzfSBsaWQ9e3NvdXJjZUxheW91dEJveElkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5pbnNlcnRMYXlvdXRCb3hJbnRvQm94Q2xpY2tIYW5kbGVyfT4rKEIpPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiY1wiIHN0eWxlcz17YnV0dG9uU3R5bGVzfSBsaWQ9e3NvdXJjZUxheW91dEJveElkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5zZWxlY3RMYXlvdXRCYXNlQ2xpY2tIYW5kbGVyfT4mIzgyMzA7ey8qRWxsaXBzaXMqL308L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJkXCIgc3R5bGVzPXtidXR0b25TdHlsZXN9IGxpZD17c291cmNlTGF5b3V0Qm94SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmhpZ2hsaWdodExheW91dEJhc2VDbGlja0hhbmRsZXJ9Pj88L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJlXCIgc3R5bGVzPXtidXR0b25TdHlsZXN9IG1pZD17c3R5bGVNb2xlY3VsZUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5zZWxlY3RTdHlsZU1vbGVjdWxlQ2xpY2tIYW5kbGVyfT5TJiM4MjMwO3svKkVsbGlwc2lzKi99PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiZlwiIHN0eWxlcz17YnV0dG9uU3R5bGVzfSBsaWQ9e3NvdXJjZUxheW91dEJveElkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5zYXZlTGF5b3V0TW9sZWN1bGVDbGlja0hhbmRsZXJ9PiEhITwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aXNQcmVzZWxlY3RlZEN1cnJlbnQgfHwgIWlzUHJlc2VsZWN0ZWRBbnkgPyA8YnV0dG9uIGtleT1cImdcIiBzdHlsZXM9e2J1dHRvblN0eWxlc1ByZXNlbGVjdEFueX0gbGlkPXtzb3VyY2VMYXlvdXRCb3hJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIubW92ZUxheW91dEJveEludG9Sb3dDbGlja0hhbmRsZXJ9PklOKFIpPC9idXR0b24+IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gZGlzYWJsZWQga2V5PVwiZzBcIiBzdHlsZXM9e2J1dHRvblN0eWxlc1ByZXNlbGVjdEFueX0gbGlkPXtzb3VyY2VMYXlvdXRCb3hJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIubW92ZUxheW91dEJveEludG9Sb3dDbGlja0hhbmRsZXJ9PklOKFIpPC9idXR0b24+fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aXNQcmVzZWxlY3RlZEN1cnJlbnQgfHwgIWlzUHJlc2VsZWN0ZWRBbnkgPyA8YnV0dG9uIGtleT1cImhcIiBzdHlsZXM9e2J1dHRvblN0eWxlc1ByZXNlbGVjdEFueX0gbGlkPXtzb3VyY2VMYXlvdXRCb3hJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIubW92ZUxheW91dEJveEludG9Cb3hDbGlja0hhbmRsZXJ9PklOKEIpPC9idXR0b24+IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gZGlzYWJsZWQga2V5PVwiaDBcIiBzdHlsZXM9e2J1dHRvblN0eWxlc1ByZXNlbGVjdEFueX0gbGlkPXtzb3VyY2VMYXlvdXRCb3hJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIubW92ZUxheW91dEJveEludG9Cb3hDbGlja0hhbmRsZXJ9PklOKEIpPC9idXR0b24+fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aXNQcmVzZWxlY3RlZEN1cnJlbnQgfHwgIWlzUHJlc2VsZWN0ZWRBbnkgPyA8YnV0dG9uIGtleT1cImlcIiBzdHlsZXM9e2J1dHRvblN0eWxlc1ByZXNlbGVjdEFueX0gbGlkPXtzb3VyY2VMYXlvdXRCb3hJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIubW92ZUxheW91dEJveEJlZm9yZUJveENsaWNrSGFuZGxlcn0+TVYoQTpCKTwvYnV0dG9uPiA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGRpc2FibGVkIGtleT1cImkwXCIgc3R5bGVzPXtidXR0b25TdHlsZXNQcmVzZWxlY3RBbnl9IGxpZD17c291cmNlTGF5b3V0Qm94SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLm1vdmVMYXlvdXRCb3hCZWZvcmVCb3hDbGlja0hhbmRsZXJ9Pk1WKEE6Qik8L2J1dHRvbj59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpc1ByZXNlbGVjdGVkQ3VycmVudCB8fCAhaXNQcmVzZWxlY3RlZEFueSA/IDxidXR0b24ga2V5PVwialwiIHN0eWxlcz17YnV0dG9uU3R5bGVzUHJlc2VsZWN0QW55fSBsaWQ9e3NvdXJjZUxheW91dEJveElkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5zeW5jTGF5b3V0QmFzZVN0eWxlc0NsaWNrSGFuZGxlcn0+U1QoQik8L2J1dHRvbj4gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJqMFwiIHN0eWxlcz17YnV0dG9uU3R5bGVzUHJlc2VsZWN0QW55fSBsaWQ9e3NvdXJjZUxheW91dEJveElkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5zeW5jTGF5b3V0QmFzZVN0eWxlc0NsaWNrSGFuZGxlcn0+U1QoQik8L2J1dHRvbj59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpc1ByZXNlbGVjdGVkQW55ICYmICFpc1ByZXNlbGVjdGVkQ3VycmVudCA/IDxidXR0b24ga2V5PVwia1wiIHN0eWxlcz17YnV0dG9uU3R5bGVzVGFyZ2V0fSBsaWQ9e3NvdXJjZUxheW91dEJveElkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5maW5hbGl6ZUxheW91dFJlcXVlc3R9PiQoQTpCKTwvYnV0dG9uPiA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGRpc2FibGVkIGtleT1cImswXCIgc3R5bGVzPXtidXR0b25TdHlsZXNUYXJnZXR9IGxpZD17c291cmNlTGF5b3V0Qm94SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmZpbmFsaXplTGF5b3V0UmVxdWVzdH0+JChBOkIpPC9idXR0b24+fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IWlzUHJlc2VsZWN0ZWRBbnkgPyA8YnV0dG9uIGtleT1cImxcIiBzdHlsZXM9e2J1dHRvblN0eWxlc30gbGlkPXtzb3VyY2VMYXlvdXRCb3hJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuZGVsZXRlTGF5b3V0QmFzZUNsaWNrSGFuZGxlcn0+WDwvYnV0dG9uPiA6IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJsMFwiIHN0eWxlcz17YnV0dG9uU3R5bGVzfSBsaWQ9e3NvdXJjZUxheW91dEJveElkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5kZWxldGVMYXlvdXRCYXNlQ2xpY2tIYW5kbGVyfT5YPC9idXR0b24+fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IWlzUHJlc2VsZWN0ZWRBbnkgJiYgcmVuZGVyZWRCb3hDb250ZW50Lmxlbmd0aCA+IDAgPyA8YnV0dG9uIGtleT1cIm1cIiBzdHlsZXM9e2J1dHRvblN0eWxlc30gbGlkPXtzb3VyY2VMYXlvdXRCb3hJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuZGVsZXRlQmVsb3dMYXlvdXRCYXNlQ2xpY2tIYW5kbGVyfT5DTFI8L2J1dHRvbj4gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJtMFwiIHN0eWxlcz17YnV0dG9uU3R5bGVzfSBsaWQ9e3NvdXJjZUxheW91dEJveElkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5kZWxldGVCZWxvd0xheW91dEJhc2VDbGlja0hhbmRsZXJ9PkNMUjwvYnV0dG9uPn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7cmVuZGVyZWRCb3hDb250ZW50fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PjtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKHVwZGF0ZWRTb3VyY2U6IExheW91dEJveCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSB1cGRhdGVkU291cmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VMYXlvdXRCb3hJZFN0cmluZyA9IHNvdXJjZS5MYXlvdXRCYXNlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVNb2xlY3VsZUlkID0gKGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcy5maW5kKG0gPT4gbS5TdHlsZUZvckxheW91dElkID09IHNvdXJjZS5MYXlvdXRCYXNlSWQpIGFzIFN0eWxlTW9sZWN1bGUpLlN0eWxlTW9sZWN1bGVJZDsgLy8gVE9ETyBleHBlbnNpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVNb2xlY3VsZUlkU3RyaW5nID0gc3R5bGVNb2xlY3VsZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dEJveFN0eWxlQ2xhc3MgPSBgcyR7c3R5bGVNb2xlY3VsZUlkfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZXBuZXNzUGFkZGluZyA9IGAkeyhzb3VyY2UuTGV2ZWwgKyAxKSAqIDE1fXB4YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlZEJhY2tncm91bmRDb2xvciA9IHByb3BlcnR5QmFyLmNhbGN1bGF0ZUJhY2tncm91bmRDb2xvckZvckxldmVsKHNvdXJjZS5MZXZlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRDb2xvciA9IHByb3BlcnR5QmFyLmNhbGN1bGF0ZUNvbG9yRm9yTGV2ZWwoc291cmNlLkxldmVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlZEJvcmRlckNvbG9yID0gYHNvbGlkIDFweCAke3Byb3BlcnR5QmFyLmNhbGN1bGF0ZUJhY2tncm91bmRDb2xvckZvckxldmVsKHNvdXJjZS5MZXZlbCArIDEpfWA7IC8vIFRPRE8gdGVzdCBpZiByZW5kZXJlZCB0b28gbWFueSB0aW1lcyBieSBzZXR0aW5nIGJyZWFrIHBvaW50IGluIHVwZGF0ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzU3ViQXRvbXMgPSBzb3VyY2UuUGxhY2VkSW5Cb3hBdG9tcy5sZW5ndGggPiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc09kZExldmVsID0gKHNvdXJjZS5MZXZlbCAlIDIpICE9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlU2VjdGlvblRhcmdldCh1cGRhdGVkU291cmNlOiBMYXlvdXRCb3gsIHRhcmdldDogeyByZW5kZXJNYXF1ZXR0ZSgpOiBhbnksIHVwZGF0ZSh1cGRhdGVkU291cmNlOiBMYXlvdXRCb3gpOiB2b2lkIH0pIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC51cGRhdGUodXBkYXRlZFNvdXJjZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY2FsY3VsYXRlQ29sb3JGb3JMZXZlbCA9IChsZXZlbDogbnVtYmVyKTogc3RyaW5nID0+IHsgLy8gVE9ETyBoYXJkY29kZWQgcHJlY2FsY3VsYXRlZCB0YWJsZVxyXG4gICAgICAgIGxldmVsID0gbGV2ZWwgPCAwID8gMCA6IGxldmVsO1xyXG4gICAgICAgIGxldCBjb2xvclZhbHVlOiBudW1iZXIgPSBsZXZlbCA+IDIgPyAyMjIgOiA3OCArIGxldmVsICogMTI7IC8vIGdyYXkgdG9uZSB3aXRoIGxpbWl0IHRvIHdoaXRlXHJcbiAgICAgICAgcmV0dXJuIGByZ2IoJHtjb2xvclZhbHVlfSwke2NvbG9yVmFsdWV9LCR7Y29sb3JWYWx1ZX0pYDtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNhbGN1bGF0ZUJhY2tncm91bmRDb2xvckZvckxldmVsID0gKGxldmVsOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xyXG4gICAgICAgIGxldmVsID0gbGV2ZWwgPCAwID8gMCA6IGxldmVsO1xyXG4gICAgICAgIGxldCBjb2xvclZhbHVlOiBudW1iZXIgPSAyMDAgLSBsZXZlbCAqIDIyO1xyXG4gICAgICAgIGNvbG9yVmFsdWUgPSBjb2xvclZhbHVlIDwgMCA/IDAgOiBjb2xvclZhbHVlO1xyXG4gICAgICAgIHJldHVybiBgcmdiKCR7Y29sb3JWYWx1ZX0sJHtjb2xvclZhbHVlfSwke2NvbG9yVmFsdWV9KWA7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgcmVuZGVyTGF5b3V0QXRvbUFycmF5ID0gKHByb3BlcnR5QmFyOiBQcm9wZXJ0eUJhcik6IG1hcXVldHRlLk1hcHBpbmc8TGF5b3V0QXRvbSwgeyByZW5kZXJNYXF1ZXR0ZTogKCkgPT4gbWFxdWV0dGUuVk5vZGUgfT4gPT4ge1xyXG4gICAgICAgIHJldHVybiBtYXF1ZXR0ZS5jcmVhdGVNYXBwaW5nPExheW91dEF0b20sIGFueT4oXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFNlY3Rpb25Tb3VyY2VLZXkoc291cmNlOiBMYXlvdXRBdG9tKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlLkxheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlU2VjdGlvblRhcmdldChzb3VyY2U6IExheW91dEF0b20pIHtcclxuICAgICAgICAgICAgICAgIGxldCBzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmcgPSBzb3VyY2UuTGF5b3V0QmFzZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc291cmNlQ29udGVudEF0b21JZFN0cmluZyA9IHNvdXJjZS5Ib3N0ZWRDb250ZW50QXRvbS5Db250ZW50QXRvbUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVNb2xlY3VsZTogU3R5bGVNb2xlY3VsZSA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChtID0+IG0uU3R5bGVGb3JMYXlvdXRJZCA9PSBzb3VyY2UuTGF5b3V0QmFzZUlkKSBhcyBTdHlsZU1vbGVjdWxlKTsgLy8gVE9ETyBleHBlbnNpdmVcclxuICAgICAgICAgICAgICAgIGxldCBzdHlsZU1vbGVjdWxlSWQ6IG51bWJlciA9IHN0eWxlTW9sZWN1bGUuU3R5bGVNb2xlY3VsZUlkO1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlTW9sZWN1bGVJZFN0cmluZzogc3RyaW5nID0gc3R5bGVNb2xlY3VsZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGF5b3V0QXRvbVN0eWxlQ2xhc3M6IHN0cmluZyA9IGBzJHtzdHlsZU1vbGVjdWxlSWRTdHJpbmd9YDsgLy8gVE9ETyBjcmVhdGUgYWxsIG9mIHRoZXNlIGNvbnN0YW50IHN0cmluZ3Mgd2hlbiBwYXJzaW5nIGRhdGEgPT4gb25lIGluc3RhbmNlIGluIG1lbW9yeSAhISFcclxuICAgICAgICAgICAgICAgIC8vIC0tLSBvbmx5IHJlbmRlciBtb2RlOiB0cmVlIC0tLVxyXG4gICAgICAgICAgICAgICAgbGV0IGNhbGN1bGF0ZWRQYWRkaW5nUHg6IG51bWJlciA9IChwcm9wZXJ0eUJhci52aWV3TW9kZWwuZGVlcGVzdExldmVsQWN0aXZlVmlldyArIDEgLSBzb3VyY2UuTGV2ZWwpICogMTU7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2FsY3VsYXRlZE1hcmdpbjogc3RyaW5nID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIGxldCBjYWxjdWxhdGVkQ29sb3I6IHN0cmluZyA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2FsY3VsYXRlZEJhY2tncm91bmRDb2xvcjogc3RyaW5nID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIC8vIC0tLVxyXG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZE1hcmdpbiA9IGAkeyhzb3VyY2UuTGV2ZWwpICogMTUgKyAxNX1weGA7XHJcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkQ29sb3IgPSBwcm9wZXJ0eUJhci5jYWxjdWxhdGVDb2xvckZvckxldmVsKHNvdXJjZS5MZXZlbCk7XHJcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkQmFja2dyb3VuZENvbG9yID0gcHJvcGVydHlCYXIuY2FsY3VsYXRlQmFja2dyb3VuZENvbG9yRm9yTGV2ZWwoc291cmNlLkxldmVsKTtcclxuICAgICAgICAgICAgICAgIGxldCBob3N0ZWRDb250ZW50QXRvbTogQ29udGVudEF0b20gPSAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNvbnRlbnRBdG9tcy5maW5kKGMgPT4gYy5Db250ZW50QXRvbUlkID09IHNvdXJjZS5Ib3N0ZWRDb250ZW50QXRvbS5Db250ZW50QXRvbUlkKSBhcyBDb250ZW50QXRvbSk7IC8vIFRPRE8gZXhwZW5zaXZlICgyIGNvcGllcyBvZiBjb250ZW50KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJNYXF1ZXR0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXNSZW5kZXJlZEF0b21WaXNpYmxlOiBib29sZWFuID0gY3VycmVudEFwcC5wYWdlUHJldmlldy52aXNpYmxlTGF5b3V0QXRvbUtleXMuZmluZEluZGV4KGsgPT4gayA9PT0gc291cmNlTGF5b3V0QXRvbUlkU3RyaW5nKSAhPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzUmVuZGVyZWRBdG9tSG92ZXJlZDogYm9vbGVhbiA9IGN1cnJlbnRBcHAuc3RhdGUuaG92ZXJlZFBhZ2VQcmV2aWV3TGF5b3V0QmFzZUlkID09IHNvdXJjZS5MYXlvdXRCYXNlSWQ7IC8vIFRPRE8gd2lnZ2xlIGVmZmVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHNhbWUgc3RhaXIgZWZmZWN0IHJpZ2h0IHNpZGUgbWFyZ2luXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaXZBdG9tU3R5bGVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiZmxleFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmbGV4LWRpcmVjdGlvblwiOiBcInJvd1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmbGV4LXdyYXBcIjogXCJub3dyYXBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXCJtYXJnaW4tbGVmdFwiOiBcIi0xNXB4XCIsIFRPRE8gc3RhaXIgZWZmZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1yaWdodFwiOiBcIi0xNXB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJvcmRlci1sZWZ0XCI6IFwic29saWQgMXB4IGJsYWNrXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGF0b21DYXB0aW9uU3R5bGVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0LWRlY29yYXRpb25cIjogXCJ1bmRlcmxpbmVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tbGVmdFwiOiBcIjE1cHhcIiwgLy8gVE9ETyBzdGFpciBlZmZlY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFkZGluZy1sZWZ0XCI6IGAkeyhjYWxjdWxhdGVkUGFkZGluZ1B4ICsgKGlzUmVuZGVyZWRBdG9tVmlzaWJsZSA/IC0xIDogMCkpLnRvU3RyaW5nKCl9cHhgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYWRkaW5nLXJpZ2h0XCI6IFwiMTVweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW5cIjogXCIwXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCI6IGNhbGN1bGF0ZWRDb2xvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBjYWxjdWxhdGVkQmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmb250LXNpemVcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtaW4td2lkdGhcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJib3JkZXItbGVmdFwiOiBpc1JlbmRlcmVkQXRvbUhvdmVyZWQgPyBcInNvbGlkIDNweCByZ2IoMjAwLDAsMClcIiA6IGlzUmVuZGVyZWRBdG9tVmlzaWJsZSA/IFwiZGFzaGVkIDFweCByZ2IoMjAwLDAsMClcIiA6ICB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlucHV0U3R5bGVzID0geyAvLyBUT0RPIGlucHV0IGRpc2FwcGVhcnMgd2hlbiBsYXlvdXRhdG9tIGhvc3RlZCBjb250ZW50IGF0b20gdGV4dCBpczogJFxcbGVmdC5cXHJpZ2h0XSRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGV4dC1kZWNvcmF0aW9uXCI6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tbGVmdFwiOiBcIjE1cHhcIiwgLy8gVE9ETyBzdGFpciBlZmZlY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFkZGluZy1sZWZ0XCI6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFkZGluZy1yaWdodFwiOiBcIjE1cHhcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWFyZ2luXCI6IFwiMFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmb250LXNpemVcIjogXCIwLjhyZW1cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWluLXdpZHRoXCI6IFwiMjAwcHhcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYnV0dG9uU3R5bGVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmb250LXNpemVcIjogXCIxMHB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCI6IGNhbGN1bGF0ZWRDb2xvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBjYWxjdWxhdGVkQmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcImF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm91dGxpbmVcIjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvdXRsaW5lLW9mZnNldFwiOiB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzUHJlc2VsZWN0ZWRBbnk6IGJvb2xlYW4gPSBjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkICE9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpc1ByZXNlbGVjdGVkQ3VycmVudDogYm9vbGVhbiA9IGlzUHJlc2VsZWN0ZWRBbnkgJiYgY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCA9PSBzb3VyY2UuTGF5b3V0QmFzZUlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYnV0dG9uU3R5bGVzVGFyZ2V0ID0geyAvLyBUT0RPIGFwcGVuZCBhcnJheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJmb250LXNpemVcIjogXCIxMHB4XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNvbG9yXCI6ICFpc1ByZXNlbGVjdGVkQW55IHx8IGlzUHJlc2VsZWN0ZWRDdXJyZW50ID8gY2FsY3VsYXRlZEJhY2tncm91bmRDb2xvciA6IGNhbGN1bGF0ZWRDb2xvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBjYWxjdWxhdGVkQmFja2dyb3VuZENvbG9yLCAvLyBUT0RPIG1hZ2ljIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCJhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsZXhcIjogXCIwIDAgYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvdXRsaW5lXCI6ICFpc1ByZXNlbGVjdGVkQW55IHx8IGlzUHJlc2VsZWN0ZWRDdXJyZW50ID8gdW5kZWZpbmVkIDogXCJzb2xpZCA0cHggcmdiKDIwMCwwLDApXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm91dGxpbmUtb2Zmc2V0XCI6ICFpc1ByZXNlbGVjdGVkQW55IHx8IGlzUHJlc2VsZWN0ZWRDdXJyZW50ID8gdW5kZWZpbmVkIDogXCItNHB4XCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJ1dHRvblN0eWxlc1ByZXNlbGVjdEFueSA9IHsgLy8gVE9ETyBhcHBlbmQgYXJyYXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZm9udC1zaXplXCI6IFwiMTBweFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb2xvclwiOiBpc1ByZXNlbGVjdGVkQ3VycmVudCA/IGNhbGN1bGF0ZWRCYWNrZ3JvdW5kQ29sb3IgOiBpc1ByZXNlbGVjdGVkQW55ID8gY2FsY3VsYXRlZEJhY2tncm91bmRDb2xvciA6IGNhbGN1bGF0ZWRDb2xvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBpc1ByZXNlbGVjdGVkQ3VycmVudCA/IFwicmdiKDIwMCwwLDApXCIgOiBjYWxjdWxhdGVkQmFja2dyb3VuZENvbG9yLCAvLyBUT0RPIG1hZ2ljIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCJhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImZsZXhcIjogXCIwIDAgYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvdXRsaW5lXCI6IGlzUHJlc2VsZWN0ZWRDdXJyZW50IHx8IGlzUHJlc2VsZWN0ZWRBbnkgPyB1bmRlZmluZWQgOiBcInNvbGlkIDFweCByZ2IoMjAwLDAsMClcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3V0bGluZS1vZmZzZXRcIjogaXNQcmVzZWxlY3RlZEN1cnJlbnQgfHwgaXNQcmVzZWxlY3RlZEFueSA/IHVuZGVmaW5lZCA6IFwiLTFweFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZXNjcmlwdGlvbjogc3RyaW5nID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvc3RlZENvbnRlbnRBdG9tLkNvbnRlbnRBdG9tVHlwZSA9PT0gQ29udGVudEF0b21UeXBlLlRleHQgJiYgaG9zdGVkQ29udGVudEF0b20uVGV4dENvbnRlbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBob3N0ZWRDb250ZW50QXRvbS5UZXh0Q29udGVudC5sZW5ndGggPiAyMCA/IGhvc3RlZENvbnRlbnRBdG9tLlRleHRDb250ZW50LnN1YnN0cmluZygwLCAyMCkgKyBcIi4uLlwiIDogaG9zdGVkQ29udGVudEF0b20uVGV4dENvbnRlbnQ7IC8vIFRPRE8gZXhwZW5zaXZlIC8vIFRPRE8gZWxsaXBzaXMgLy8gVE9ETyBtdWx0aXBsZSBwbGFjZXMgLy8gVE9ETyBjcmVhdGUgd2hlbiBzdG9yaW5nIGluIERCPyBvciB3aGVuIGxvYWRpbmcgaW4gY2xpZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaG9zdGVkQ29udGVudEF0b20uQ29udGVudEF0b21UeXBlID09PSBDb250ZW50QXRvbVR5cGUuTGluayAmJiBob3N0ZWRDb250ZW50QXRvbS5VcmwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBob3N0ZWRDb250ZW50QXRvbS5VcmwubGVuZ3RoID4gMjAgPyBob3N0ZWRDb250ZW50QXRvbS5Vcmwuc3Vic3RyaW5nKDAsIDIwKSArIFwiLi4uXCIgOiBob3N0ZWRDb250ZW50QXRvbS5Vcmw7IC8vIFRPRE8gZXhwZW5zaXZlIC8vIFRPRE8gZWxsaXBzaXMgLy8gVE9ETyBtdWx0aXBsZSBwbGFjZXMgLy8gVE9ETyBjcmVhdGUgd2hlbiBzdG9yaW5nIGluIERCPyBvciB3aGVuIGxvYWRpbmcgaW4gY2xpZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZW5kZXJlZElucHV0Rm9yQ29udGVudDogVk5vZGUgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpc0VkaXRlZExheW91dEF0b21JZDogYm9vbGVhbiA9IHNvdXJjZS5MYXlvdXRCYXNlSWQgPT0gcHJvcGVydHlCYXIudmlld01vZGVsLmVkaXRlZExheW91dEF0b21JZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRWRpdGVkTGF5b3V0QXRvbUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG93IGlucHV0IGZpZWxkIGluc3RlYWQgb2YgcmVuZGVyZWQgYXRvbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRJbnB1dEZvckNvbnRlbnQgPSA8aW5wdXQga2V5PXtgaW5wJHtzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmd9YH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz17bGF5b3V0QXRvbVN0eWxlQ2xhc3N9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3Byb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ29udGVudH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmlucHV0PXtwcm9wZXJ0eUJhci5jb250ZW50QXRvbUlucHV0SGFuZGxlcn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmJsdXI9e3Byb3BlcnR5QmFyLmNvbnRlbnRBdG9tTG9zdEZvY3VzSGFuZGxlcn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmtleWRvd249e3Byb3BlcnR5QmFyLmNvbnRlbnRBdG9tS2V5RG93bkhhbmRsZXJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzPXtpbnB1dFN0eWxlc31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlckNyZWF0ZT17cHJvcGVydHlCYXIuY29udGVudEF0b21BZnRlckNyZWF0ZUhhbmRsZXJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2lkPXtzb3VyY2VDb250ZW50QXRvbUlkU3RyaW5nfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPjwvaW5wdXQ+IGFzIFZOb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17c291cmNlTGF5b3V0QXRvbUlkU3RyaW5nfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlkPXtzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM9e2RpdkF0b21TdHlsZXN9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlckNyZWF0ZT17cHJvcGVydHlCYXIubGF5b3V0QXRvbUFmdGVyQ3JlYXRlSGFuZGxlcn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ubW91c2VlbnRlcj17cHJvcGVydHlCYXIubGF5b3V0QmFzZU1vdXNlRW50ZXJIYW5kbGVyfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25tb3VzZWxlYXZlPXtwcm9wZXJ0eUJhci5sYXlvdXRCYXNlTW91c2VMZWF2ZUhhbmRsZXJ9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyFpc0VkaXRlZExheW91dEF0b21JZCA/IDxwIGtleT1cIjBcIiBzdHlsZXM9e2F0b21DYXB0aW9uU3R5bGVzfSBhaWQ9e3NvdXJjZUxheW91dEF0b21JZFN0cmluZ30gY2lkPXtzb3VyY2VDb250ZW50QXRvbUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5sYXlvdXRBdG9tQ2xpY2tIYW5kbGVyfT48c21hbGwga2V5PVwiMFwiIGFpZD17c291cmNlTGF5b3V0QXRvbUlkU3RyaW5nfSBjaWQ9e3NvdXJjZUNvbnRlbnRBdG9tSWRTdHJpbmd9PntkZXNjcmlwdGlvbn1BVE9NPC9zbWFsbD48L3A+IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZElucHV0Rm9yQ29udGVudH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHN0eWxlcz17YnV0dG9uU3R5bGVzfSBsaWQ9e3NvdXJjZUxheW91dEF0b21JZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuc2VsZWN0TGF5b3V0QmFzZUNsaWNrSGFuZGxlcn0+JiM4MjMwO3svKkVsbGlwc2lzKi99PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImJcIiBzdHlsZXM9e2J1dHRvblN0eWxlc30gbGlkPXtzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmhpZ2hsaWdodExheW91dEJhc2VDbGlja0hhbmRsZXJ9Pj88L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiY1wiIHN0eWxlcz17YnV0dG9uU3R5bGVzfSBtaWQ9e3N0eWxlTW9sZWN1bGVJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuc2VsZWN0U3R5bGVNb2xlY3VsZUNsaWNrSGFuZGxlcn0+UyYjODIzMDt7LypFbGxpcHNpcyovfTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2lzUHJlc2VsZWN0ZWRDdXJyZW50IHx8ICFpc1ByZXNlbGVjdGVkQW55ID8gPGJ1dHRvbiBrZXk9XCJkXCIgc3R5bGVzPXtidXR0b25TdHlsZXNQcmVzZWxlY3RBbnl9IGxpZD17c291cmNlTGF5b3V0QXRvbUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5tb3ZlTGF5b3V0QXRvbUludG9Cb3hDbGlja0hhbmRsZXJ9PklOPC9idXR0b24+IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGRpc2FibGVkIGtleT1cImQwXCIgc3R5bGVzPXtidXR0b25TdHlsZXNQcmVzZWxlY3RBbnl9IGxpZD17c291cmNlTGF5b3V0QXRvbUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5tb3ZlTGF5b3V0QXRvbUludG9Cb3hDbGlja0hhbmRsZXJ9PklOPC9idXR0b24+fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2lzUHJlc2VsZWN0ZWRDdXJyZW50IHx8ICFpc1ByZXNlbGVjdGVkQW55ID8gPGJ1dHRvbiBrZXk9XCJlXCIgc3R5bGVzPXtidXR0b25TdHlsZXNQcmVzZWxlY3RBbnl9IGxpZD17c291cmNlTGF5b3V0QXRvbUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5tb3ZlTGF5b3V0QXRvbUJlZm9yZUF0b21DbGlja0hhbmRsZXJ9Pk1WPC9idXR0b24+IDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGRpc2FibGVkIGtleT1cImUwXCIgc3R5bGVzPXtidXR0b25TdHlsZXNQcmVzZWxlY3RBbnl9IGxpZD17c291cmNlTGF5b3V0QXRvbUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5tb3ZlTGF5b3V0QXRvbUJlZm9yZUF0b21DbGlja0hhbmRsZXJ9Pk1WPC9idXR0b24+fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2lzUHJlc2VsZWN0ZWRDdXJyZW50IHx8ICFpc1ByZXNlbGVjdGVkQW55ID8gPGJ1dHRvbiBrZXk9XCJmXCIgc3R5bGVzPXtidXR0b25TdHlsZXNQcmVzZWxlY3RBbnl9IGxpZD17c291cmNlTGF5b3V0QXRvbUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5zeW5jTGF5b3V0QmFzZVN0eWxlc0NsaWNrSGFuZGxlcn0+U1QoQSk8L2J1dHRvbj4gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gZGlzYWJsZWQga2V5PVwiZjBcIiBzdHlsZXM9e2J1dHRvblN0eWxlc1ByZXNlbGVjdEFueX0gbGlkPXtzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLnN5bmNMYXlvdXRCYXNlU3R5bGVzQ2xpY2tIYW5kbGVyfT5TVChBKTwvYnV0dG9uPn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpc1ByZXNlbGVjdGVkQ3VycmVudCB8fCAhaXNQcmVzZWxlY3RlZEFueSA/IDxidXR0b24ga2V5PVwiZ1wiIHN0eWxlcz17YnV0dG9uU3R5bGVzUHJlc2VsZWN0QW55fSBsaWQ9e3NvdXJjZUxheW91dEF0b21JZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuY3JlYXRlQm94Rm9yQXRvbUluUGxhY2VDbGlja0hhbmRsZXJ9PisoQikuSU48L2J1dHRvbj4gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gZGlzYWJsZWQga2V5PVwiZzBcIiBzdHlsZXM9e2J1dHRvblN0eWxlc1ByZXNlbGVjdEFueX0gbGlkPXtzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmNyZWF0ZUJveEZvckF0b21JblBsYWNlQ2xpY2tIYW5kbGVyfT4rKEIpLklOPC9idXR0b24+fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2lzUHJlc2VsZWN0ZWRBbnkgJiYgIWlzUHJlc2VsZWN0ZWRDdXJyZW50ID8gPGJ1dHRvbiBrZXk9XCJoXCIgc3R5bGVzPXtidXR0b25TdHlsZXNUYXJnZXR9IGxpZD17c291cmNlTGF5b3V0QXRvbUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5maW5hbGl6ZUxheW91dFJlcXVlc3R9PiQoQTpCKTwvYnV0dG9uPiA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJoMFwiIHN0eWxlcz17YnV0dG9uU3R5bGVzVGFyZ2V0fSBsaWQ9e3NvdXJjZUxheW91dEF0b21JZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuZmluYWxpemVMYXlvdXRSZXF1ZXN0fT4kKEE6Qik8L2J1dHRvbj59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IWlzUHJlc2VsZWN0ZWRBbnkgPyA8YnV0dG9uIGtleT1cImlcIiBzdHlsZXM9e2J1dHRvblN0eWxlc30gbGlkPXtzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmRlbGV0ZUxheW91dEJhc2VDbGlja0hhbmRsZXJ9Plg8L2J1dHRvbj4gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gZGlzYWJsZWQga2V5PVwiaTBcIiBzdHlsZXM9e2J1dHRvblN0eWxlc30gbGlkPXtzb3VyY2VMYXlvdXRBdG9tSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmRlbGV0ZUxheW91dEJhc2VDbGlja0hhbmRsZXJ9Plg8L2J1dHRvbj59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PjtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKHVwZGF0ZWRTb3VyY2U6IExheW91dEF0b20pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gdXBkYXRlZFNvdXJjZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTGF5b3V0QXRvbUlkU3RyaW5nID0gc291cmNlLkxheW91dEJhc2VJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VDb250ZW50QXRvbUlkU3RyaW5nID0gc291cmNlLkhvc3RlZENvbnRlbnRBdG9tLkNvbnRlbnRBdG9tSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVNb2xlY3VsZSA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChtID0+IG0uU3R5bGVGb3JMYXlvdXRJZCA9PSBzb3VyY2UuTGF5b3V0QmFzZUlkKSBhcyBTdHlsZU1vbGVjdWxlKTsgLy8gVE9ETyBleHBlbnNpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVNb2xlY3VsZUlkID0gc3R5bGVNb2xlY3VsZS5TdHlsZU1vbGVjdWxlSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlTW9sZWN1bGVJZFN0cmluZyA9IHN0eWxlTW9sZWN1bGVJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXRBdG9tU3R5bGVDbGFzcyA9IGBzJHtzdHlsZU1vbGVjdWxlSWR9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlZFBhZGRpbmdQeCA9IChwcm9wZXJ0eUJhci52aWV3TW9kZWwuZGVlcGVzdExldmVsQWN0aXZlVmlldyAtIHNvdXJjZS5MZXZlbCkgKiAxNSArIDE1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVkQ29sb3IgPSBwcm9wZXJ0eUJhci5jYWxjdWxhdGVDb2xvckZvckxldmVsKHNvdXJjZS5MZXZlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRNYXJnaW4gPSBgJHsoc291cmNlLkxldmVsKSAqIDE1ICsgMTV9cHhgO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVkQmFja2dyb3VuZENvbG9yID0gcHJvcGVydHlCYXIuY2FsY3VsYXRlQmFja2dyb3VuZENvbG9yRm9yTGV2ZWwoc291cmNlLkxldmVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdGVkQ29udGVudEF0b20gPSAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNvbnRlbnRBdG9tcy5maW5kKGMgPT4gYy5Db250ZW50QXRvbUlkID09IHNvdXJjZS5Ib3N0ZWRDb250ZW50QXRvbS5Db250ZW50QXRvbUlkKSBhcyBDb250ZW50QXRvbSk7IC8vIFRPRE8gZXhwZW5zaXZlICgyIGNvcGllcyBvZiBjb250ZW50KVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNlY3Rpb25UYXJnZXQodXBkYXRlZFNvdXJjZTogTGF5b3V0QXRvbSwgdGFyZ2V0OiB7IHJlbmRlck1hcXVldHRlKCk6IGFueSwgdXBkYXRlKHVwZGF0ZWRTb3VyY2U6IExheW91dEF0b20pOiB2b2lkIH0pIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC51cGRhdGUodXBkYXRlZFNvdXJjZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIGNvbnRlbnRBdG9tQWZ0ZXJDcmVhdGVIYW5kbGVyID0gKGVsZW1lbnQ6IEVsZW1lbnQsIHByb2plY3Rpb25PcHRpb25zOiBtYXF1ZXR0ZS5Qcm9qZWN0aW9uT3B0aW9ucywgdm5vZGVTZWxlY3Rvcjogc3RyaW5nLCBwcm9wZXJ0aWVzOiBtYXF1ZXR0ZS5WTm9kZVByb3BlcnRpZXMsIGNoaWxkcmVuOiBWTm9kZVtdKSA9PiB7XHJcbiAgICAgICAgbGV0IHRhcmdldEVsZW1lbnQ6IEhUTUxJbnB1dEVsZW1lbnQgPSBlbGVtZW50IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5mb2N1cygpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIGxheW91dEJhc2VNb3VzZUVudGVySGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgdGFyZ2V0RWxlbWVudDogSFRNTEVsZW1lbnQgPSBldnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5ob3ZlcmVkQm94VHJlZUxheW91dEJhc2VJZCA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZSh0YXJnZXRFbGVtZW50LCBcImxpZFwiKTtcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBsYXlvdXRCYXNlTW91c2VMZWF2ZUhhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5ob3ZlcmVkQm94VHJlZUxheW91dEJhc2VJZCA9IDA7IC8vIFRPRE8gcmVtZW1iZXIgd2hhdCB3YXMgZW50ZXJlZCBiZWZvcmUgYW5kIHJlaGlnaGxpZ2h0XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgbGF5b3V0QXRvbUFmdGVyQ3JlYXRlSGFuZGxlciA9IChlbGVtZW50OiBFbGVtZW50LCBwcm9qZWN0aW9uT3B0aW9uczogbWFxdWV0dGUuUHJvamVjdGlvbk9wdGlvbnMsIHZub2RlU2VsZWN0b3I6IHN0cmluZywgcHJvcGVydGllczogbWFxdWV0dGUuVk5vZGVQcm9wZXJ0aWVzLCBjaGlsZHJlbjogVk5vZGVbXSkgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5wcm9wZXJ0eUJhckluZGV4ID09IDApIHtcclxuICAgICAgICAgICAgbGV0IHRhcmdldEVsZW1lbnQ6IEhUTUxFbGVtZW50ID0gZWxlbWVudCBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuX2FjdGl2ZVZpZXdMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXNbcHJvcGVydGllcy5rZXkgYXMgc3RyaW5nXSA9IHRhcmdldEVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIHJlc2V0Q29udGVudEF0b21FZGl0TW9kZSA9ICgpID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLnBhZ2VQcmV2aWV3LnJlc2V0RXF1YXRpb25OdW1iZXJzV2hlbk1vZGlmeWluZyhmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmVkaXRlZExheW91dEF0b21JZCA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDb250ZW50ID0gXCJcIjtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcE9yaWdpbmFsQ29udGVudCA9IFwiXCI7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgY29udGVudEF0b21Mb3N0Rm9jdXNIYW5kbGVyID0gKGV2dDogRm9jdXNFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnVwZGF0ZUNvbnRlbnRBdG9tKHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImNpZFwiKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgdXBkYXRlQ29udGVudEF0b20gPSAoY29udGVudEF0b21JZDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5lZGl0ZWRMYXlvdXRBdG9tSWQgIT0gMCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDb250ZW50ICE9PSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcE9yaWdpbmFsQ29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ29udGVudCAhPT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50QXRvbTogQ29udGVudEF0b20gPSAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNvbnRlbnRBdG9tcy5maW5kKGEgPT4gYS5JbnN0YW5jZWRPbkxheW91dElkID09IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5lZGl0ZWRMYXlvdXRBdG9tSWQpIGFzIENvbnRlbnRBdG9tKTsgLy8gVE9ETyBleHBlbnNpdmUgYnV0IGZlZWxzIGJldHRlclxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50QXRvbS5Db250ZW50QXRvbVR5cGUgPT09IENvbnRlbnRBdG9tVHlwZS5UZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRBdG9tLlRleHRDb250ZW50ID0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDb250ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250ZW50QXRvbS5Db250ZW50QXRvbVR5cGUgPT09IENvbnRlbnRBdG9tVHlwZS5MaW5rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRBdG9tLlVybCA9IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ29udGVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmN1cnJlbnRSZWFkeVN0YXRlID0gUmVhZHlTdGF0ZS5QZW5kaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5VcGRhdGVUZXh0Q29udGVudEF0b21Kc29uKGNvbnRlbnRBdG9tSWQsIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ29udGVudCkuZG9uZSgoZGF0YTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuYWx3YXlzKChkYXRhOiBhbnkpID0+IGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFJlYWR5U3RhdGUgPSBSZWFkeVN0YXRlLk9rKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmcgVE9ETyBkb2N1bWVudCA9PiB1c2UgYnV0dG9uIHRvIGRlbGV0ZSBsYXlvdXQgYXRvbSBpbnN0ZWFkLCBzaG93cyBlc2NhcGUgYmVoYXZpb3VyIGluIGN1cnJlbnQgaW1wbGVtZW50YXRpb25cclxuICAgICAgICAgICAgICAgICAgICAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNvbnRlbnRBdG9tcy5maW5kKGMgPT4gYy5JbnN0YW5jZWRPbkxheW91dElkID09IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5lZGl0ZWRMYXlvdXRBdG9tSWQpIGFzIENvbnRlbnRBdG9tKS5UZXh0Q29udGVudCA9IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wT3JpZ2luYWxDb250ZW50OyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnJlc2V0Q29udGVudEF0b21FZGl0TW9kZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIGNvbnRlbnRBdG9tS2V5RG93bkhhbmRsZXIgPSAoZXZ0OiBLZXlib2FyZEV2ZW50KSA9PiB7IC8vIFRPRE8gY29kZSBkdXBsaWNhdGlvblxyXG4gICAgICAgIGlmIChldnQua2V5Q29kZSA9PSAxMyAvKkVOVEVSKi8pIHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIChldnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLmJsdXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXZ0LmtleUNvZGUgPT0gMjcgLypFU0MqLykge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgKGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5Db250ZW50QXRvbXMuZmluZChjID0+IGMuSW5zdGFuY2VkT25MYXlvdXRJZCA9PSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuZWRpdGVkTGF5b3V0QXRvbUlkKSBhcyBDb250ZW50QXRvbSkuVGV4dENvbnRlbnQgPSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcE9yaWdpbmFsQ29udGVudDsgLy8gVE9ETyBleHBlbnNpdmVcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIucmVzZXRDb250ZW50QXRvbUVkaXRNb2RlKCk7XHJcbiAgICAgICAgICAgIChldnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLmJsdXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXZ0LmtleUNvZGUgPT0gdW5kZWZpbmVkIC8qaW5wdXQgZm9jdXMgbG9zdCovKSB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPIGNsZWFuIHdoaXRlc3BhY2VzXHJcbiAgICAgICAgLy8gVE9ETyBhdXRvc2l6ZVxyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIGNvbnRlbnRBdG9tSW5wdXRIYW5kbGVyID0gKGV2dDogS2V5Ym9hcmRFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ29udGVudCA9IChldnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlO1xyXG4gICAgICAgIChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ29udGVudEF0b21zLmZpbmQoYyA9PiBjLkluc3RhbmNlZE9uTGF5b3V0SWQgPT0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmVkaXRlZExheW91dEF0b21JZCkgYXMgQ29udGVudEF0b20pLlRleHRDb250ZW50ID0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDb250ZW50OyAvLyBUT0RPIGV4cGVuc2l2ZSAvLyBUT0RPIGEgbmljZXIgd2F5IHdvdWxkIGJlIHRvIHByZXZlbnQgdXBkYXRlIGluIHJlbmRlcmVkIHBhZ2UgYW5kIHRyaWdnZXIgZm9ybXVsYSB1cGRhdGU7IGZvcm11bGEgaXMgZGVzdHJveWVkIHdoZW4gcmVuZGVyZWQgY29udGVudCBjaGFuZ2VzXHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgbGF5b3V0QXRvbUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTsgLy8gVE9ETyB0aGlzIGlzIHNldCBmb3IgZXZlcnkgY29udGVudCBhdG9tIGluIHByZXZpZXcuLi4gcGVyZm9ybWFuY2U/XHJcbiAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFJlYWR5U3RhdGUgIT09IFJlYWR5U3RhdGUuT2spIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwZW5kaW5nLi4uXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLmN1cnJlbnRTZWxlY3Rpb25Nb2RlID09PSBTZWxlY3Rpb25Nb2RlLkNvbnRlbnQpIHtcclxuICAgICAgICAgICAgbGV0IGNvbnRlbnRBdG9tSWQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImNpZFwiKTtcclxuICAgICAgICAgICAgbGV0IGxheW91dEF0b21JZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwiYWlkXCIpO1xyXG4gICAgICAgICAgICBsZXQgaG9zdGVkQ29udGVudEF0b206IENvbnRlbnRBdG9tID0gKGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5Db250ZW50QXRvbXMuZmluZChjID0+IGMuQ29udGVudEF0b21JZCA9PSBjb250ZW50QXRvbUlkKSBhcyBDb250ZW50QXRvbSk7IC8vIFRPRE8gZXhwZW5zaXZlICgyIGNvcGllcyBvZiBjb250ZW50KVxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENvbnRlbnQgPSBcIlwiO1xyXG4gICAgICAgICAgICBpZiAoaG9zdGVkQ29udGVudEF0b20uQ29udGVudEF0b21UeXBlID09PSBDb250ZW50QXRvbVR5cGUuVGV4dCkgeyAvLyBUT0RPIGNvZGUgZHVwbGljYXRpb24gZm9yIGNvbnRlbnQgc2VsZWN0aW9uIGF0IG11bHRpcGxlIHBsYWNlc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDb250ZW50ID0gaG9zdGVkQ29udGVudEF0b20uVGV4dENvbnRlbnQgYXMgc3RyaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGhvc3RlZENvbnRlbnRBdG9tLkNvbnRlbnRBdG9tVHlwZSA9PT0gQ29udGVudEF0b21UeXBlLkxpbmspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ29udGVudCA9IGhvc3RlZENvbnRlbnRBdG9tLlVybCBhcyBzdHJpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBPcmlnaW5hbENvbnRlbnQgPSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENvbnRlbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5lZGl0ZWRMYXlvdXRBdG9tSWQgPSBsYXlvdXRBdG9tSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyU3RhdGVNb2RpZmllclNlbGVjdG9ycyA9ICgpOiBWTm9kZSA9PiB7XHJcbiAgICAgICAgbGV0IHN0YXRlTW9kaWZpZXJHcm91cFN0eWxlcyA9IHtcclxuICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwiZmxleFwiLFxyXG4gICAgICAgICAgICBcImZsZXgtZmxvd1wiOiBcInJvdyBub3dyYXBcIlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHN0YXRlTW9kaWZpZXJzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIGxldCBzdHlsZU1vbGVjdWxlOiBTdHlsZU1vbGVjdWxlID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlTW9sZWN1bGVzLmZpbmQobSA9PiBtLlN0eWxlTW9sZWN1bGVJZCA9PSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZU1vbGVjdWxlSWQpIGFzIFN0eWxlTW9sZWN1bGU7IC8vIFRPRE8gZmluZCB1c2VkIHJlcGVhdGVkbHkgZm9yIHJlbmRlciBjb250cm9sc1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3R5bGVNb2xlY3VsZS5NYXBwZWRTdHlsZUF0b21zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBtb2RpZmllcjogc3RyaW5nIHwgdW5kZWZpbmVkID0gc3R5bGVNb2xlY3VsZS5NYXBwZWRTdHlsZUF0b21zW2ldLlN0YXRlTW9kaWZpZXI7XHJcbiAgICAgICAgICAgIGlmIChtb2RpZmllciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBtb2RpZmllciA9IFwiXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YXRlTW9kaWZpZXJzLmZpbmRJbmRleChzID0+IHMgPT09IG1vZGlmaWVyKSA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgc3RhdGVNb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHJlbmRlcmVkTW9kaWZpZXJzOiBWTm9kZVtdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZU1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgbW9kaWZpZXI6IHN0cmluZyA9IHN0YXRlTW9kaWZpZXJzW2ldO1xyXG4gICAgICAgICAgICBsZXQgbW9kaWZpZXJCdXR0b25TdHlsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICBcImZsZXhcIjogXCIwIDAgYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IG1vZGlmaWVyID09IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFN0YXRlTW9kaWZpZXIgPyBcInJlZFwiIDogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJlbmRlcmVkTW9kaWZpZXJzLnB1c2goPGJ1dHRvbiBrZXk9e21vZGlmaWVyfSByb2xlPVwiYnV0dG9uXCIgbWlkPXttb2RpZmllcn0gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc3RhdGVNb2RpZmllckNsaWNrSGFuZGxlcn0gc3R5bGVzPXttb2RpZmllckJ1dHRvblN0eWxlc30+e21vZGlmaWVyfTwvYnV0dG9uPiBhcyBWTm9kZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gPGRpdiBrZXk9XCItMlwiIHN0eWxlcz17c3RhdGVNb2RpZmllckdyb3VwU3R5bGVzfT5cclxuICAgICAgICAgICAge3JlbmRlcmVkTW9kaWZpZXJzfVxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHN0YXRlTW9kaWZpZXJDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IHNlbGVjdGVkU3RhdGVNb2RpZmllcjogc3RyaW5nID0gcGFyc2VTdHJpbmdGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibWlkXCIpO1xyXG4gICAgICAgIGlmIChzZWxlY3RlZFN0YXRlTW9kaWZpZXIgPT09IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFN0YXRlTW9kaWZpZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3RhdGVNb2RpZmllciA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdGF0ZU1vZGlmaWVyID0gc2VsZWN0ZWRTdGF0ZU1vZGlmaWVyO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlbmRlclJlc3BvbnNpdmVEZXZpY2VTZWxlY3RvcnMgPSAoKTogVk5vZGUgPT4ge1xyXG4gICAgICAgIGxldCByZXNwb25zaXZlR3JvdXBTdHlsZXMgPSB7XHJcbiAgICAgICAgICAgIFwiZGlzcGxheVwiOiBcImZsZXhcIixcclxuICAgICAgICAgICAgXCJmbGV4LWZsb3dcIjogXCJyb3cgd3JhcFwiXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gPGRpdiBrZXk9XCItM1wiIHN0eWxlcz17cmVzcG9uc2l2ZUdyb3VwU3R5bGVzfT5cclxuICAgICAgICAgICAgeyhjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuUmVzcG9uc2l2ZURldmljZXMgIT09IHVuZGVmaW5lZCkgPyBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuUmVzcG9uc2l2ZURldmljZXMubWFwKHIgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNpdmVCdXR0b25TdHlsZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICBcImJhY2tncm91bmQtY29sb3JcIjogci5SZXNwb25zaXZlRGV2aWNlSWQgPT0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkUmVzcG9uc2l2ZURldmljZUlkID8gXCJyZWRcIiA6IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGxldCByZXNwb25zaXZlRGV2aWNlSWRTdHJpbmc6IHN0cmluZyA9IHIuUmVzcG9uc2l2ZURldmljZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPGJ1dHRvbiBrZXk9e3Jlc3BvbnNpdmVEZXZpY2VJZFN0cmluZ30gcm9sZT1cImJ1dHRvblwiIHJpZD17cmVzcG9uc2l2ZURldmljZUlkU3RyaW5nfSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zZWxlY3RSZXNwb25zaXZlRGV2aWNlQ2xpY2tIYW5kbGVyfSBzdHlsZXM9e3Jlc3BvbnNpdmVCdXR0b25TdHlsZXN9PntyLk5hbWVTaG9ydH08L2J1dHRvbj4gYXMgVk5vZGU7XHJcbiAgICAgICAgICAgIH0pIDogdW5kZWZpbmVkfVxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNlbGVjdFJlc3BvbnNpdmVEZXZpY2VDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IHNlbGVjdGVkUmVzcG9uc2l2ZUlkOiBudW1iZXIgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJyaWRcIik7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFJlc3BvbnNpdmVEZXZpY2VJZCA9PSBzZWxlY3RlZFJlc3BvbnNpdmVJZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRSZXNwb25zaXZlRGV2aWNlSWQgPSBjdXJyZW50QXBwLnN0YXRlLm5vbmVSZXNwb25zaXZlRGV2aWNlSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRSZXNwb25zaXZlRGV2aWNlSWQgPSBzZWxlY3RlZFJlc3BvbnNpdmVJZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJTdHlsZUF0b21Db250cm9scyA9ICgpOiBWTm9kZSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIDxkaXYga2V5PVwiLTFcIj5cclxuICAgICAgICAgICAgPHNlbGVjdCBrZXk9XCIwXCJcclxuICAgICAgICAgICAgICAgIG9uY2hhbmdlPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zdHlsZUF0b21UeXBlQ2hhbmdlZEhhbmRsZXJ9PlxyXG4gICAgICAgICAgICAgICAge2dldEFycmF5Rm9yRW51bShTdHlsZUF0b21UeXBlKS5tYXAoKHR5cGU6IHN0cmluZywgaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpc1NlbGVjdGVkOiBib29sZWFuID0gaW5kZXggPT09IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFN0eWxlQXRvbVR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzU2VsZWN0ZWQgPyA8b3B0aW9uIHNlbGVjdGVkIGtleT17aW5kZXh9IHZhbHVlPXtpbmRleC50b1N0cmluZygpfT57dHlwZX08L29wdGlvbj4gOiA8b3B0aW9uIGtleT17aW5kZXh9IHZhbHVlPXtpbmRleC50b1N0cmluZygpfT57dHlwZX08L29wdGlvbj47XHJcbiAgICAgICAgICAgICAgICB9KX1cclxuICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgIDxpbnB1dCBrZXk9XCItMVwiXHJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj17XCJvcHRpb25hbCA6aG92ZXIsOmJlZm9yZSwuLi5cIn1cclxuICAgICAgICAgICAgICAgIHZhbHVlPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcFBzZXVkb1NlbGVjdG9yfVxyXG4gICAgICAgICAgICAgICAgb25pbnB1dD17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucHNldWRvU2VsZWN0b3JJbnB1dEhhbmRsZXJ9PlxyXG4gICAgICAgICAgICA8L2lucHV0PlxyXG4gICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY3JlYXRlU3R5bGVBdG9tRm9yTW9sZWN1bGVDbGlja0hhbmRsZXJ9Pis8L2J1dHRvbj5cclxuICAgICAgICA8L2Rpdj4gYXMgVk5vZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBwc2V1ZG9TZWxlY3RvcklucHV0SGFuZGxlciA9IChldnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcFBzZXVkb1NlbGVjdG9yID0gKGV2dC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzdHlsZUF0b21UeXBlQ2hhbmdlZEhhbmRsZXIgPSAoZXZ0OiBVSUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IHRhcmdldFNlbGVjdCA9IGV2dC50YXJnZXQgYXMgSFRNTFNlbGVjdEVsZW1lbnQ7XHJcbiAgICAgICAgbGV0IHBhcnNlZFN0eWxlQXRvbVR5cGU6IG51bWJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAodGFyZ2V0U2VsZWN0LnNlbGVjdGVkSW5kZXggPCB0YXJnZXRTZWxlY3QuY2hpbGRFbGVtZW50Q291bnQpIHtcclxuICAgICAgICAgICAgbGV0IHNlbGVjdE9wdGlvbkVsZW1lbnQ6IEhUTUxPcHRpb25FbGVtZW50ID0gdGFyZ2V0U2VsZWN0Lm9wdGlvbnNbdGFyZ2V0U2VsZWN0LnNlbGVjdGVkSW5kZXhdO1xyXG4gICAgICAgICAgICBwYXJzZWRTdHlsZUF0b21UeXBlID0gcGFyc2VJbnQoc2VsZWN0T3B0aW9uRWxlbWVudC52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwYXJzZWRTdHlsZUF0b21UeXBlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3R5bGVBdG9tVHlwZSA9IHBhcnNlZFN0eWxlQXRvbVR5cGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY3JlYXRlU3R5bGVBdG9tRm9yTW9sZWN1bGVDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wUHNldWRvU2VsZWN0b3IgIT09IFwiXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3RhdGVNb2RpZmllciA9IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wUHNldWRvU2VsZWN0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5DcmVhdGVTdHlsZUF0b21Gb3JNb2xlY3VsZUpzb24odGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3R5bGVNb2xlY3VsZUlkLCB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZUF0b21UeXBlLCB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRSZXNwb25zaXZlRGV2aWNlSWQsIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFN0YXRlTW9kaWZpZXIpLmRvbmUoZGF0YSA9PiBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcFBzZXVkb1NlbGVjdG9yID0gXCJcIjtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlbmRlclN0eWxlUXVhbnR1bUNvbnRyb2xzID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICByZXR1cm4gPGRpdiBrZXk9XCIwXCI+XHJcbiAgICAgICAgICAgIDxpbnB1dCBrZXk9XCItM1wiXHJcbiAgICAgICAgICAgICAgICB2YWx1ZT17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBRdWFudHVtTmFtZX1cclxuICAgICAgICAgICAgICAgIG9uaW5wdXQ9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnF1YW50dW1OYW1lSW5wdXRIYW5kbGVyfT5cclxuICAgICAgICAgICAgPC9pbnB1dD5cclxuICAgICAgICAgICAgPGlucHV0IGtleT1cIi0yXCJcclxuICAgICAgICAgICAgICAgIHZhbHVlPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1Byb3BlcnR5TmFtZX1cclxuICAgICAgICAgICAgICAgIG9uaW5wdXQ9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmNzc1Byb3BlcnR5TmFtZUlucHV0SGFuZGxlcn0+XHJcbiAgICAgICAgICAgIDwvaW5wdXQ+XHJcbiAgICAgICAgICAgIDxpbnB1dCBrZXk9XCItMVwiXHJcbiAgICAgICAgICAgICAgICB2YWx1ZT17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDc3NWYWx1ZX1cclxuICAgICAgICAgICAgICAgIG9uaW5wdXQ9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmNzc1ZhbHVlSW5wdXRIYW5kbGVyfT5cclxuICAgICAgICAgICAgPC9pbnB1dD5cclxuICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmNyZWF0ZVN0eWxlUXVhbnR1bUNsaWNrSGFuZGxlcn0+JiMxMDAwNDs8L2J1dHRvbj5cclxuICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJiXCIgcm9sZT1cImJ1dHRvblwiIG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnNob3dBbGxDc3NQcm9wZXJ0aWVzRm9yUXVhbnR1bUNsaWNrSGFuZGxlcn0+PzwvYnV0dG9uPlxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNob3dBbGxDc3NQcm9wZXJ0aWVzRm9yUXVhbnR1bUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5kaXNwbGF5UG9wdXAoZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgUG9wdXBNb2RlLkFsbENzc1Byb3BlcnRpZXNGb3JRdWFudHVtKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNyZWF0ZVN0eWxlUXVhbnR1bUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuQ3JlYXRlU3R5bGVRdWFudHVtSnNvbihjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ2FsaWZvcm5pYVByb2plY3RJZCwgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBRdWFudHVtTmFtZSwgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDc3NQcm9wZXJ0eU5hbWUsIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzVmFsdWUpLmRvbmUoZGF0YSA9PiBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZXNldEFkZFF1YW50dW1TdGF0ZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVzZXRBZGRRdWFudHVtU3RhdGUgPSAoKTogdm9pZCA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBRdWFudHVtTmFtZSA9IFwiUXVhbnR1bVwiO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzUHJvcGVydHlOYW1lID0gXCJcIjtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1ZhbHVlID0gXCJcIjtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHF1YW50dW1OYW1lSW5wdXRIYW5kbGVyID0gKGV2dDogS2V5Ym9hcmRFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wUXVhbnR1bU5hbWUgPSAoZXZ0LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlbmRlclN0eWxlVmFsdWVBcnJheSA9IChwcm9wZXJ0eUJhcjogUHJvcGVydHlCYXIpOiBtYXF1ZXR0ZS5NYXBwaW5nPFN0eWxlVmFsdWUsIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+ID0+IHtcclxuICAgICAgICByZXR1cm4gbWFxdWV0dGUuY3JlYXRlTWFwcGluZzxTdHlsZVZhbHVlLCBhbnk+KFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRTZWN0aW9uU291cmNlS2V5KHNvdXJjZTogU3R5bGVWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5TdHlsZVZhbHVlSWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb25UYXJnZXQoc291cmNlOiBTdHlsZVZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc291cmNlSWRTdHJpbmcgPSBzb3VyY2UuU3R5bGVWYWx1ZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVWYWx1ZUJ1dHRvblN0eWxlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiBcImF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICBcImhlaWdodFwiOiBcIjFyZW1cIlxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGxldCBzdHlsZVZhbHVlVGV4dFN0eWxlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIFwib3V0bGluZVwiOiBzb3VyY2UuQ3NzVmFsdWUgPT09IFwiXCIgPyBcInNvbGlkIHdoaXRlIDFweFwiIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIFwib3V0bGluZS1vZmZzZXRcIjogc291cmNlLkNzc1ZhbHVlID09PSBcIlwiID8gXCItMXB4XCIgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJmbGV4XCI6IFwiMCAwIGF1dG9cIixcclxuICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IFwiYXV0b1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibWFyZ2luXCI6IFwiMFwiXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJNYXF1ZXR0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPGRpdiBrZXk9e3NvdXJjZUlkU3RyaW5nfSBleGl0QW5pbWF0aW9uPXtwcm9wZXJ0eUJhci5zdHlsZUVsZW1lbnRFeGl0QW5pbWF0aW9ufSBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6XCJmbGV4XCIsIFwiZmxleC1mbG93XCI6IFwicm93IG5vd3JhcFwifX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBzdHlsZXM9e3N0eWxlVmFsdWVUZXh0U3R5bGV9Pntzb3VyY2UuQ3NzUHJvcGVydHl9OiB7c291cmNlLkNzc1ZhbHVlfTwvcD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiB2aWQ9e3NvdXJjZUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5kZWxldGVTdHlsZVZhbHVlQ2xpY2tIYW5kbGVyfSBzdHlsZXM9e3N0eWxlVmFsdWVCdXR0b25TdHlsZX0+WDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJiXCIgcm9sZT1cImJ1dHRvblwiIGFpZD17c291cmNlLlN0eWxlQXRvbUlkLnRvU3RyaW5nKCl9IHZpZD17c291cmNlSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLnVwZGF0ZUNzc1ZhbHVlQ2xpY2tIYW5kbGVyfSBzdHlsZXM9e3N0eWxlVmFsdWVCdXR0b25TdHlsZX0+RWRpdDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gYXMgVk5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICh1cGRhdGVkU291cmNlOiBTdHlsZVZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHVwZGF0ZWRTb3VyY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUlkU3RyaW5nID0gc291cmNlLlN0eWxlVmFsdWVJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNlY3Rpb25UYXJnZXQodXBkYXRlZFNvdXJjZTogU3R5bGVWYWx1ZSwgdGFyZ2V0OiB7IHJlbmRlck1hcXVldHRlKCk6IGFueSwgdXBkYXRlKHVwZGF0ZWRTb3VyY2U6IFN0eWxlVmFsdWUpOiB2b2lkIH0pIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC51cGRhdGUodXBkYXRlZFNvdXJjZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyU3R5bGVRdWFudHVtQXJyYXlGb3JTdHlsZUF0b20gPSAoKTogbWFxdWV0dGUuTWFwcGluZzxTdHlsZVF1YW50dW0sIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+ID0+IHtcclxuICAgICAgICByZXR1cm4gbWFxdWV0dGUuY3JlYXRlTWFwcGluZzxTdHlsZVF1YW50dW0sIGFueT4oXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFNlY3Rpb25Tb3VyY2VLZXkoc291cmNlOiBTdHlsZVF1YW50dW0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2UuU3R5bGVRdWFudHVtSWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb25UYXJnZXQoc291cmNlOiBTdHlsZVF1YW50dW0pIHtcclxuICAgICAgICAgICAgICAgIGxldCBzb3VyY2VJZFN0cmluZyA9IHNvdXJjZS5TdHlsZVF1YW50dW1JZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJNYXF1ZXR0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPGRpdiBrZXk9e3NvdXJjZUlkU3RyaW5nfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIHN0eWxlcz17e1wibWFyZ2luXCI6IFwiMFwifX0+e3NvdXJjZS5OYW1lfToge3NvdXJjZS5Dc3NQcm9wZXJ0eX0gKHtzb3VyY2UuQ3NzVmFsdWV9KTwvcD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAodXBkYXRlZFNvdXJjZTogU3R5bGVRdWFudHVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHVwZGF0ZWRTb3VyY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUlkU3RyaW5nID0gc291cmNlLlN0eWxlUXVhbnR1bUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlU2VjdGlvblRhcmdldCh1cGRhdGVkU291cmNlOiBTdHlsZVF1YW50dW0sIHRhcmdldDogeyByZW5kZXJNYXF1ZXR0ZSgpOiBhbnksIHVwZGF0ZSh1cGRhdGVkU291cmNlOiBTdHlsZVF1YW50dW0pOiB2b2lkIH0pIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC51cGRhdGUodXBkYXRlZFNvdXJjZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyU3R5bGVBdG9tQXJyYXkgPSAocHJvcGVydHlCYXI6IFByb3BlcnR5QmFyKTogbWFxdWV0dGUuTWFwcGluZzxTdHlsZUF0b20sIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+ID0+IHtcclxuICAgICAgICByZXR1cm4gbWFxdWV0dGUuY3JlYXRlTWFwcGluZzxTdHlsZUF0b20sIGFueT4oXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFNlY3Rpb25Tb3VyY2VLZXkoc291cmNlOiBTdHlsZUF0b20pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2UuU3R5bGVBdG9tSWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb25UYXJnZXQoc291cmNlOiBTdHlsZUF0b20pIHtcclxuICAgICAgICAgICAgICAgIGxldCBzdHlsZUF0b21JZFN0cmluZyA9IHNvdXJjZS5TdHlsZUF0b21JZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGFwcGxpZWRWYWx1ZXNNYXAgPSBwcm9wZXJ0eUJhci5yZW5kZXJTdHlsZVZhbHVlQXJyYXkocHJvcGVydHlCYXIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGFwcGxpZWRRdWFudHVtc01hcCA9IHByb3BlcnR5QmFyLnJlbmRlclN0eWxlUXVhbnR1bUFycmF5Rm9yU3R5bGVBdG9tKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLkFwcGxpZWRWYWx1ZXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFwcGxpZWRWYWx1ZXNNYXAubWFwKHNvdXJjZS5BcHBsaWVkVmFsdWVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFwcGxpZWRWYWx1ZXNNYXAubWFwKFtdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuTWFwcGVkUXVhbnR1bXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFwcGxpZWRRdWFudHVtc01hcC5tYXAoc291cmNlLk1hcHBlZFF1YW50dW1zLm1hcChxbSA9PiBxbS5TdHlsZVF1YW50dW0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFwcGxpZWRRdWFudHVtc01hcC5tYXAoW10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJNYXF1ZXR0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXNEaXNwbGF5U3R5bGVBdG9tOiBib29sZWFuID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5QmFyLnZpZXdNb2RlbC5jdXJyZW50UHJvcGVydHlCYXJNb2RlID09PSBQcm9wZXJ0eUJhck1vZGUuU3R5bGVNb2xlY3VsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0eWxlTW9sZWN1bGU6IFN0eWxlTW9sZWN1bGUgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChtID0+IG0uU3R5bGVNb2xlY3VsZUlkID09IHByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFN0eWxlTW9sZWN1bGVJZCkgYXMgU3R5bGVNb2xlY3VsZTsvLyBUT0RPIHNsb3cgdmVyeSBleHBlbnNpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRNYXBwaW5nSW5kZXg6IG51bWJlciA9IHN0eWxlTW9sZWN1bGUuTWFwcGVkU3R5bGVBdG9tcy5maW5kSW5kZXgobSA9PiBtLlJlc3BvbnNpdmVEZXZpY2VJZCA9PSBwcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRSZXNwb25zaXZlRGV2aWNlSWQgJiYgbS5TdHlsZU1vbGVjdWxlQXRvbU1hcHBpbmdJZCA9PSBzb3VyY2UuTWFwcGVkVG9Nb2xlY3VsZUlkICYmICgobS5TdGF0ZU1vZGlmaWVyID09PSB1bmRlZmluZWQgJiYgcHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3RhdGVNb2RpZmllciA9PT0gXCJcIikgfHwgKG0uU3RhdGVNb2RpZmllciA9PT0gcHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3RhdGVNb2RpZmllcikpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRGlzcGxheVN0eWxlQXRvbSA9IHRhcmdldE1hcHBpbmdJbmRleCAhPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGl2U3R5bGVBdG9tU3R5bGVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkaXNwbGF5XCI6ICFpc0Rpc3BsYXlTdHlsZUF0b20gPyBcIm5vbmVcIiA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImhlaWdodFwiOiBcImF1dG9cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPGRpdiBrZXk9e3N0eWxlQXRvbUlkU3RyaW5nfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdEFuaW1hdGlvbj17cHJvcGVydHlCYXIuc3R5bGVFbGVtZW50RXhpdEFuaW1hdGlvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlcz17ZGl2U3R5bGVBdG9tU3R5bGVzfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGtleT1cIjBcIiBzdHlsZXM9e3sgXCJtYXJnaW5cIjogXCIwXCIgfX0+KCN7c3R5bGVBdG9tSWRTdHJpbmd9KXtzb3VyY2UuTmFtZX06PC9wPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2FwcGxpZWRWYWx1ZXNNYXAucmVzdWx0cy5tYXAociA9PiByLnJlbmRlck1hcXVldHRlKCkpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIGFpZD17c3R5bGVBdG9tSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmNyZWF0ZUNzc1Byb3BlcnR5Rm9yQXRvbUNsaWNrSGFuZGxlcn0+KzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJiXCIgcm9sZT1cImJ1dHRvblwiIGFpZD17c3R5bGVBdG9tSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLm1vdmVTdHlsZUF0b21Qb3B1cENsaWNrSGFuZGxlcn0+PT48L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzb3VyY2UuSXNEZWxldGFibGUgPyA8YnV0dG9uIGtleT1cImIwXCIgcm9sZT1cImJ1dHRvblwiIGFpZD17c3R5bGVBdG9tSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmRlbGV0ZVN0eWxlQXRvbUNsaWNrSGFuZGxlcn0+WDwvYnV0dG9uPiA6IDxidXR0b24gZGlzYWJsZWQga2V5PVwiYjFcIiByb2xlPVwiYnV0dG9uXCIgYWlkPXtzdHlsZUF0b21JZFN0cmluZ30+WDwvYnV0dG9uPn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzb3VyY2UuTWFwcGVkUXVhbnR1bXMubGVuZ3RoID4gMCA/IDxwIGtleT1cIi0xXCI+cXVhbnR1bXM6PC9wPiA6IHVuZGVmaW5lZH0ge2FwcGxpZWRRdWFudHVtc01hcC5yZXN1bHRzLm1hcChyID0+IHIucmVuZGVyTWFxdWV0dGUoKSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PjtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKHVwZGF0ZWRTb3VyY2U6IFN0eWxlQXRvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSB1cGRhdGVkU291cmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWVkVmFsdWVzTWFwLm1hcCh1cGRhdGVkU291cmNlLkFwcGxpZWRWYWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWVkUXVhbnR1bXNNYXAubWFwKHVwZGF0ZWRTb3VyY2UuTWFwcGVkUXVhbnR1bXMubWFwKHFtID0+IHFtLlN0eWxlUXVhbnR1bSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVNlY3Rpb25UYXJnZXQodXBkYXRlZFNvdXJjZTogU3R5bGVBdG9tLCB0YXJnZXQ6IHsgcmVuZGVyTWFxdWV0dGUoKTogYW55LCB1cGRhdGUodXBkYXRlZFNvdXJjZTogU3R5bGVBdG9tKTogdm9pZCB9KSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQudXBkYXRlKHVwZGF0ZWRTb3VyY2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIG1vdmVTdHlsZUF0b21Qb3B1cENsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZUF0b21JZEZvclBvcHVwID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwiYWlkXCIpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmRpc3BsYXlQb3B1cChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCBQb3B1cE1vZGUuTW92ZVN0eWxlQXRvbSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjcmVhdGVDc3NQcm9wZXJ0eUZvckF0b21DbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3R5bGVBdG9tSWQgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJhaWRcIik7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZGlzcGxheVBvcHVwKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsIFBvcHVwTW9kZS5BZGRDc3NQcm9wZXJ0eSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZGlzcGxheVBvcHVwKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsIFBvcHVwTW9kZS5BbGxDc3NQcm9wZXJ0aWVzKTsgLy8gVE9ETyByZW5kZXIgZmlyc3QgcG9wdXAsIHRoZW4gdXNlIHJlbmRlcmQgcXVlc3Rpb24gbWFyayBidXR0b24gYXMgdGFyZ2V0IChpbnRlcm1lZGlhdGUgcG9wdXAgZG9tKVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgZGVsZXRlU3R5bGVBdG9tQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5EZWxldGVTdHlsZUF0b21Kc29uKHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImFpZFwiKSkuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcHVibGljIHVwZGF0ZUNzc1ZhbHVlQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCBzdHlsZVZhbHVlSWQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcInZpZFwiKTtcclxuICAgICAgICBsZXQgc3R5bGVBdG9tSWQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImFpZFwiKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZVZhbHVlSWQgPSBzdHlsZVZhbHVlSWQ7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3R5bGVBdG9tSWQgPSBzdHlsZUF0b21JZDtcclxuICAgICAgICBsZXQgdGFyZ2V0U3R5bGVWYWx1ZTogU3R5bGVWYWx1ZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZVZhbHVlcy5maW5kKHZhbCA9PiB2YWwuU3R5bGVWYWx1ZUlkID09IHN0eWxlVmFsdWVJZCkgYXMgU3R5bGVWYWx1ZTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1ZhbHVlID0gdGFyZ2V0U3R5bGVWYWx1ZS5Dc3NWYWx1ZTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1Byb3BlcnR5TmFtZSA9IHRhcmdldFN0eWxlVmFsdWUuQ3NzUHJvcGVydHk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZGlzcGxheVBvcHVwKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsIFBvcHVwTW9kZS5VcGRhdGVDc3NWYWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBkZWxldGVTdHlsZVZhbHVlQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5EZWxldGVTdHlsZVZhbHVlSnNvbihwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJ2aWRcIikpLmRvbmUoZGF0YSA9PiBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlbmRlckFkZENzc1Byb3BlcnR5UG9wdXAgPSAoKTogVk5vZGUgPT4ge1xyXG4gICAgICAgIGxldCBpc1BvcHVwVmlzaWJsZTogYm9vbGVhbiA9IHRoaXMudmlld01vZGVsLmN1cnJlbnRQb3B1cE1vZGUgPT09IFBvcHVwTW9kZS5BZGRDc3NQcm9wZXJ0eSB8fCB0aGlzLnZpZXdNb2RlbC5jdXJyZW50UG9wdXBNb2RlID09PSBQb3B1cE1vZGUuQWxsQ3NzUHJvcGVydGllcztcclxuICAgICAgICByZXR1cm4gPGRpdiBpZD17YCR7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucHJvcGVydHlCYXJJbmRleH1Qb3B1cE1vZGUke1BvcHVwTW9kZVtQb3B1cE1vZGUuQWRkQ3NzUHJvcGVydHldfWB9IHN0eWxlcz17eyBcImRpc3BsYXlcIjogaXNQb3B1cFZpc2libGUgPyBcImJsb2NrXCIgOiBcIm5vbmVcIiwgXCJ6LWluZGV4XCIgOiBcIjMxXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsIFwiYm9yZGVyXCI6IFwic29saWQgYmxhY2sgMXB4XCIgfX0+XHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGVzPXt7IFwiZGlzcGxheVwiOiBcImZsZXhcIiwgXCJmbGV4LWZsb3dcIjogXCJyb3cgbm93cmFwXCIsIFwibWluLXdpZHRoXCI6IFwiMjUwcHhcIiB9fT5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMSAwIDEwJVwiLCBcIndpZHRoXCI6IFwiMTAlXCIsIFwibWluLXdpZHRoXCI6IFwiMTAlXCIgfX0gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2F2ZUNzc1Byb3BlcnR5Rm9yQXRvbUNsaWNrSGFuZGxlcn0+JiMxMDAwNDs8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYlwiIHJvbGU9XCJidXR0b25cIiBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMSAwIDEwJVwiLCBcIndpZHRoXCI6IFwiMTAlXCIsIFwibWluLXdpZHRoXCI6IFwiMTAlXCIgfX0gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2FuY2VsQWRkQ3NzUHJvcGVydHlGb3JBdG9tQ2xpY2tIYW5kbGVyfT54PC9idXR0b24+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPGlucHV0IGtleT1cIi0xXCJcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDc3NQcm9wZXJ0eU5hbWV9XHJcbiAgICAgICAgICAgICAgICAgICAgb25pbnB1dD17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY3NzUHJvcGVydHlOYW1lSW5wdXRIYW5kbGVyfT5cclxuICAgICAgICAgICAgICAgIDwvaW5wdXQ+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2hvd0FsbENzc1Byb3BlcnRpZXNDbGlja0hhbmRsZXJ9Pj88L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyQWxsQ3NzUHJvcGVydGllc0ZvclF1YW50dW1Qb3B1cCA9ICgpOiBWTm9kZSA9PiB7XHJcbiAgICAgICAgbGV0IGlzUG9wdXBWaXNpYmxlOiBib29sZWFuID0gdGhpcy52aWV3TW9kZWwuY3VycmVudFBvcHVwTW9kZSA9PT0gUG9wdXBNb2RlLkFsbENzc1Byb3BlcnRpZXNGb3JRdWFudHVtO1xyXG4gICAgICAgIHJldHVybiA8ZGl2IGlkPXtgJHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5wcm9wZXJ0eUJhckluZGV4fVBvcHVwTW9kZSR7UG9wdXBNb2RlW1BvcHVwTW9kZS5BbGxDc3NQcm9wZXJ0aWVzRm9yUXVhbnR1bV19YH0gc3R5bGVzPXt7IFwiZGlzcGxheVwiOiBpc1BvcHVwVmlzaWJsZSA/IFwiYmxvY2tcIiA6IFwibm9uZVwiLCBcInotaW5kZXhcIiA6IFwiMzFcIiAvKlRPRE8gZG9jdW1lbnQqLywgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVcIiwgXCJib3JkZXJcIjogXCJzb2xpZCBibGFjayAxcHhcIiwgXCJoZWlnaHRcIjogXCIzMDBweFwiLCBcIm92ZXJmbG93XCI6IFwic2Nyb2xsXCIgfX0+XHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGVzPXt7IFwiZGlzcGxheVwiOiBcImZsZXhcIiwgXCJmbGV4LWZsb3dcIjogXCJyb3cgbm93cmFwXCIsIFwibWluLXdpZHRoXCI6IFwiMjUwcHhcIiB9fT5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMSAwIDEwJVwiLCBcIndpZHRoXCI6IFwiMTAlXCIsIFwibWluLXdpZHRoXCI6IFwiMTAlXCIgfX0gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2FuY2VsVXBkYXRlQ3NzUHJvcGVydHlGb3JRdWFudHVtQ2xpY2tIYW5kbGVyfT54PC9idXR0b24+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICB7Y3VycmVudEFwcC5jbGllbnREYXRhLkFsbENzc1Byb3BlcnRpZXMubWFwKChwcm9wOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17cHJvcH0+XHJcbiAgICAgICAgICAgICAgICAgICAge3Byb3B9PGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIGNpZD17cHJvcH0gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2V0U2VsZWN0ZWRDc3NQcm9wZXJ0eUZvclF1YW50dW1DbGlja0hhbmRsZXJ9PiYjMTAwMDQ7PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj47XHJcbiAgICAgICAgICAgIH0pfVxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNldFNlbGVjdGVkQ3NzUHJvcGVydHlGb3JRdWFudHVtQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzUHJvcGVydHlOYW1lID0gcGFyc2VTdHJpbmdGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwiY2lkXCIpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmNsb3NlUG9wdXAoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNhbmNlbFVwZGF0ZUNzc1Byb3BlcnR5Rm9yUXVhbnR1bUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jbG9zZVBvcHVwKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBpbnNlcnRMYXlvdXRSb3dJbnRvVmlld1BvcHVwID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICBsZXQgaXNQb3B1cFZpc2libGU6IGJvb2xlYW4gPSB0aGlzLnZpZXdNb2RlbC5jdXJyZW50UG9wdXBNb2RlID09PSBQb3B1cE1vZGUuSW5zZXJ0TGF5b3V0Um93SW50b1ZpZXc7XHJcbiAgICAgICAgbGV0IGluc3RhbmNlYWJsZUxheW91dFJvd3M6IExheW91dFJvd1tdID0gW107XHJcbiAgICAgICAgaWYgKGlzUG9wdXBWaXNpYmxlKSB7IC8vIFRPRE8gd2lsbCBicmVhayB3aGVuIGRhdGEgaXMgbm90IHN1cHBsaWVkXHJcbiAgICAgICAgICAgIGxldCBpbnN0YW5jZWFibGVSb3dzVmlldzogQ2FsaWZvcm5pYVZpZXcgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ2FsaWZvcm5pYVZpZXdzLmZpbmQodmlldyA9PiB2aWV3LklzSW50ZXJuYWwgJiYgdmlldy5OYW1lID09PSBcIltJbnRlcm5hbF0gSW5zdGFuY2VhYmxlIExheW91dCBSb3dzXCIpIGFzIENhbGlmb3JuaWFWaWV3OyAvLyBUT0RPIG1hZ2ljIHN0cmluZyA9PiBjb25zdCBleHBvcnRcclxuICAgICAgICAgICAgaW5zdGFuY2VhYmxlTGF5b3V0Um93cy5wdXNoKC4uLmluc3RhbmNlYWJsZVJvd3NWaWV3LlBsYWNlZExheW91dFJvd3MpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHVzZXJJbnN0YW5jZWFibGVSb3dzVmlldzogQ2FsaWZvcm5pYVZpZXcgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ2FsaWZvcm5pYVZpZXdzLmZpbmQodmlldyA9PiB2aWV3LklzSW50ZXJuYWwgJiYgdmlldy5OYW1lID09PSBcIltJbnRlcm5hbF0gVXNlciBMYXlvdXQgTW9sZWN1bGVzXCIpIGFzIENhbGlmb3JuaWFWaWV3OyAvLyBUT0RPIG1hZ2ljIHN0cmluZyA9PiBjb25zdCBleHBvcnRcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB1c2VySW5zdGFuY2VhYmxlUm93c1ZpZXcuUGxhY2VkTGF5b3V0Um93cy5sZW5ndGg7IGkrKykgeyAvLyBza2lwIGJveCBob2xkZXJcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlYWJsZUxheW91dFJvd3MucHVzaCh1c2VySW5zdGFuY2VhYmxlUm93c1ZpZXcuUGxhY2VkTGF5b3V0Um93c1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDxkaXYgaWQ9e2Ake3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXh9UG9wdXBNb2RlJHtQb3B1cE1vZGVbUG9wdXBNb2RlLkluc2VydExheW91dFJvd0ludG9WaWV3XX1gfSBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IGlzUG9wdXBWaXNpYmxlID8gXCJibG9ja1wiIDogXCJub25lXCIsIFwiei1pbmRleFwiIDogXCIzMVwiLCBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLCBcImJvcmRlclwiOiBcInNvbGlkIGJsYWNrIDFweFwiLCBcImhlaWdodFwiOiBcIjMwMHB4XCIsIFwib3ZlcmZsb3dcIjogXCJzY3JvbGxcIiB9fT5cclxuICAgICAgICAgICAgPGRpdiBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IFwiZmxleFwiLCBcImZsZXgtZmxvd1wiOiBcInJvdyBub3dyYXBcIiwgXCJtaW4td2lkdGhcIjogXCIyNTBweFwiIH19PlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIxIDAgMTAlXCIsIFwid2lkdGhcIjogXCIxMCVcIiwgXCJtaW4td2lkdGhcIjogXCIxMCVcIiB9fSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jYW5jZWxJbnNlcnRMYXlvdXRSb3dJbnRvVmlld0NsaWNrSGFuZGxlcn0+eDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAge2luc3RhbmNlYWJsZUxheW91dFJvd3MubWFwKChwcm9wOiBMYXlvdXRSb3cpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17cHJvcC5MYXlvdXRCYXNlSWR9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gc3R5bGVzPXt7IFwid2lkdGhcIjogXCJhdXRvXCIsIFwibWFyZ2luXCI6IFwiMFwiIH19IGtleT1cImFcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaWQ9e3Byb3AuTGF5b3V0QmFzZUlkLnRvU3RyaW5nKCl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmluc2VydFNlbGVjdGVkTGF5b3V0Um93SW50b1ZpZXdDbGlja0hhbmRsZXJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ubW91c2VlbnRlcj17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaW5zZXJ0Um93U2hvd1ByZXZpZXdIYW5kbGVyfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbm1vdXNlbGVhdmU9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmluc2VydFJvd0hpZGVQcmV2aWV3SGFuZGxlcn0+JiMxMDAwNDtcclxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICA8cCBrZXk9XCIwXCIgc3R5bGVzPXt7IFwiLXdlYmtpdC11c2VyLXNlbGVjdFwiOiBcIm5vbmVcIiwgXCJ3aWR0aFwiOiBcImF1dG9cIiwgXCJtYXJnaW5cIjogXCIwXCIsIFwiZmxvYXRcIjogXCJsZWZ0XCIgfX0gbGlkPXtwcm9wLkxheW91dEJhc2VJZC50b1N0cmluZygpfSBvbnRvdWNoc3RhcnQ9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmluc2VydFJvd1Nob3dQcmV2aWV3SGFuZGxlcn0gb250b3VjaGVuZD17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaW5zZXJ0Um93SGlkZVByZXZpZXdIYW5kbGVyfT57cHJvcC5MYXlvdXRCYXNlSWR9PC9wPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+O1xyXG4gICAgICAgICAgICB9KX1cclxuICAgICAgICA8L2Rpdj4gYXMgVk5vZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBpbnNlcnRTZWxlY3RlZExheW91dFJvd0ludG9WaWV3Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCBsYXlvdXRJZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibGlkXCIpO1xyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5DcmVhdGVMYXlvdXRSb3dGb3JWaWV3SnNvbih0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRDYWxpZm9ybmlhVmlld0lkLCBsYXlvdXRJZCkuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgICAgIGN1cnJlbnRBcHAuc3RhdGUubGFzdENvbW1hbmQgPSBDYWxpZm9ybmlhRXZlbnQuQ3JlYXRlTGF5b3V0Um93Rm9yVmlldztcclxuICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmxhc3RDYWxpZm9ybmlhRXZlbnREYXRhID0gW3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZENhbGlmb3JuaWFWaWV3SWQsIGxheW91dElkXTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jbG9zZVBvcHVwKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjYW5jZWxJbnNlcnRMYXlvdXRSb3dJbnRvVmlld0NsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jbG9zZVBvcHVwKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBpbnNlcnRMYXlvdXRBdG9tSW50b0JveFBvcHVwID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICBsZXQgaXNQb3B1cFZpc2libGU6IGJvb2xlYW4gPSB0aGlzLnZpZXdNb2RlbC5jdXJyZW50UG9wdXBNb2RlID09PSBQb3B1cE1vZGUuSW5zZXJ0TGF5b3V0QXRvbUludG9Cb3g7XHJcbiAgICAgICAgbGV0IGluc3RhbmNlYWJsZUxheW91dEF0b21zOiBMYXlvdXRBdG9tW10gPSBbXTtcclxuICAgICAgICBpZiAoaXNQb3B1cFZpc2libGUpIHsgLy8gVE9ETyB3aWxsIGJyZWFrIHdoZW4gZGF0YSBpcyBub3Qgc3VwcGxpZWRcclxuICAgICAgICAgICAgbGV0IGluc3RhbmNlYWJsZUF0b21zVmlldzogQ2FsaWZvcm5pYVZpZXcgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ2FsaWZvcm5pYVZpZXdzLmZpbmQodmlldyA9PiB2aWV3LklzSW50ZXJuYWwgJiYgdmlldy5OYW1lID09PSBcIltJbnRlcm5hbF0gSW5zdGFuY2VhYmxlIExheW91dCBBdG9tc1wiKSBhcyBDYWxpZm9ybmlhVmlldzsgLy8gVE9ETyBtYWdpYyBzdHJpbmcgPT4gY29uc3QgZXhwb3J0XHJcbiAgICAgICAgICAgIGxldCBhdG9tQ29udGFpbmVyQm94OiBMYXlvdXRCb3ggPSBpbnN0YW5jZWFibGVBdG9tc1ZpZXcuUGxhY2VkTGF5b3V0Um93c1swXS5BbGxCb3hlc0JlbG93Um93LmZpbmQoYiA9PiBiLlBsYWNlZEluQm94QXRvbXMubGVuZ3RoID4gMCkgYXMgTGF5b3V0Qm94O1xyXG4gICAgICAgICAgICBpbnN0YW5jZWFibGVMYXlvdXRBdG9tcy5wdXNoKC4uLmF0b21Db250YWluZXJCb3guUGxhY2VkSW5Cb3hBdG9tcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiA8ZGl2IGlkPXtgJHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5wcm9wZXJ0eUJhckluZGV4fVBvcHVwTW9kZSR7UG9wdXBNb2RlW1BvcHVwTW9kZS5JbnNlcnRMYXlvdXRBdG9tSW50b0JveF19YH0gc3R5bGVzPXt7IFwiZGlzcGxheVwiOiBpc1BvcHVwVmlzaWJsZSA/IFwiYmxvY2tcIiA6IFwibm9uZVwiLCBcInotaW5kZXhcIiA6IFwiMzFcIiwgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVcIiwgXCJib3JkZXJcIjogXCJzb2xpZCBibGFjayAxcHhcIiwgXCJoZWlnaHRcIjogXCIzMDBweFwiLCBcIm92ZXJmbG93XCI6IFwic2Nyb2xsXCIgfX0+XHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGVzPXt7IFwiZGlzcGxheVwiOiBcImZsZXhcIiwgXCJmbGV4LWZsb3dcIjogXCJyb3cgbm93cmFwXCIsIFwibWluLXdpZHRoXCI6IFwiMjUwcHhcIiB9fT5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMSAwIDEwJVwiLCBcIndpZHRoXCI6IFwiMTAlXCIsIFwibWluLXdpZHRoXCI6IFwiMTAlXCIgfX0gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2FuY2VsSW5zZXJ0TGF5b3V0QXRvbUludG9Cb3hDbGlja0hhbmRsZXJ9Png8L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIHtpbnN0YW5jZWFibGVMYXlvdXRBdG9tcy5tYXAoKHByb3A6IExheW91dEF0b20pID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB0ZXh0UHJldmlldzogc3RyaW5nID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wLkhvc3RlZENvbnRlbnRBdG9tLkNvbnRlbnRBdG9tVHlwZSA9PT0gQ29udGVudEF0b21UeXBlLlRleHQpIHsgLy8gVE9ETyBjb2RlIGR1cGxpY2F0aW9uIGZvciBjb250ZW50IHNlbGVjdGlvbiBhdCBtdWx0aXBsZSBwbGFjZXNcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0UHJldmlldyA9IHByb3AuSG9zdGVkQ29udGVudEF0b20uVGV4dENvbnRlbnQgYXMgc3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcC5Ib3N0ZWRDb250ZW50QXRvbS5Db250ZW50QXRvbVR5cGUgPT09IENvbnRlbnRBdG9tVHlwZS5MaW5rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dFByZXZpZXcgPSBwcm9wLkhvc3RlZENvbnRlbnRBdG9tLlVybCBhcyBzdHJpbmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYga2V5PXtwcm9wLkxheW91dEJhc2VJZH0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBzdHlsZXM9e3sgXCJ3aWR0aFwiOiBcImF1dG9cIiwgXCJtYXJnaW5cIjogXCIwXCIgfX0ga2V5PVwiYVwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpZD17cHJvcC5MYXlvdXRCYXNlSWQudG9TdHJpbmcoKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaW5zZXJ0U2VsZWN0ZWRMYXlvdXRBdG9tSW50b0JveENsaWNrSGFuZGxlcn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25tb3VzZWVudGVyPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pbnNlcnRBdG9tU2hvd1ByZXZpZXdIYW5kbGVyfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbm1vdXNlbGVhdmU9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmluc2VydEF0b21IaWRlUHJldmlld0hhbmRsZXJ9PiYjMTAwMDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgPHAga2V5PVwiMFwiIHN0eWxlcz17eyBcIi13ZWJraXQtdXNlci1zZWxlY3RcIjogXCJub25lXCIsIFwid2lkdGhcIjogXCJhdXRvXCIsIFwibWFyZ2luXCI6IFwiMFwiLCBcImZsb2F0XCI6IFwibGVmdFwiIH19IGxpZD17cHJvcC5MYXlvdXRCYXNlSWQudG9TdHJpbmcoKX0gb250b3VjaHN0YXJ0PXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pbnNlcnRBdG9tU2hvd1ByZXZpZXdIYW5kbGVyfSBvbnRvdWNoZW5kPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pbnNlcnRBdG9tSGlkZVByZXZpZXdIYW5kbGVyfT57cHJvcC5MYXlvdXRCYXNlSWR9IHt0ZXh0UHJldmlld308L3A+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj47XHJcbiAgICAgICAgICAgIH0pfVxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGluc2VydFNlbGVjdGVkTGF5b3V0QXRvbUludG9Cb3hDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IHRhcmdldEJveElkOiBudW1iZXIgPSBjdXJyZW50QXBwLnN0YXRlLnNlbGVjdGVkTGF5b3V0QmFzZUlkO1xyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5DcmVhdGVMYXlvdXRBdG9tRm9yQm94SnNvbih0YXJnZXRCb3hJZCwgcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibGlkXCIpKS5kb25lKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpO1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnByb2plY3Rvci5yZW5kZXJOb3coKTsgLy8gVE9ET1xyXG4gICAgICAgICAgICBsZXQgdXBkYXRlZFN1YkF0b21zOiBMYXlvdXRBdG9tW10gPSAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkxheW91dE1vbGVjdWxlcy5maW5kKGwgPT4gbC5MYXlvdXRCYXNlSWQgPT0gdGFyZ2V0Qm94SWQpIGFzIExheW91dEJveCkuUGxhY2VkSW5Cb3hBdG9tcztcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmVkaXRlZExheW91dEF0b21JZCA9IHVwZGF0ZWRTdWJBdG9tc1t1cGRhdGVkU3ViQXRvbXMubGVuZ3RoIC0gMV0uTGF5b3V0QmFzZUlkOyAvLyBUT0RPIGp1c3QgZ3Vlc3NpbmcsIHNhdmUgYWxsIGV4aXN0aW5nIGFuZCBjb21wYXJlIHRvIGFsbCBuZXcgZm9yIHNhZmUgdmFyaWFudFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmNsb3NlUG9wdXAoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNhbmNlbEluc2VydExheW91dEF0b21JbnRvQm94Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmNsb3NlUG9wdXAoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGRpc3BsYXlQb3B1cCA9ICh0YXJnZXRQb3NpdGlvbjogSFRNTEVsZW1lbnQsIHBvcHVwTW9kZTogUG9wdXBNb2RlKSA9PiB7XHJcbiAgICAgICAgLyppZiAoQ2FsaWZvcm5pYUFwcC5DYWxpZm9ybmlhQXBwSW5zdGFuY2Uuc3RhdGUuY3VycmVudFBvcHVwTW9kZSAhPT0gUG9wdXBNb2RlLk5vbmUpIHsgVE9ET1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfSovXHJcbiAgICAgICAgbGV0IHBvcHVwRWxlbWVudDogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcclxuICAgICAgICBwb3B1cEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgJHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5wcm9wZXJ0eUJhckluZGV4fVBvcHVwTW9kZSR7UG9wdXBNb2RlW3BvcHVwTW9kZV19YCkgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKHBvcHVwRWxlbWVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5jdXJyZW50UG9wdXBNb2RlID0gcG9wdXBNb2RlO1xyXG4gICAgICAgICAgICB2YXIgZGlzcGxheVBvcHVwID0gbmV3IHBvcHBlcmpzLmRlZmF1bHQodGFyZ2V0UG9zaXRpb24sIHBvcHVwRWxlbWVudCwge1xyXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50OiAnYm90dG9tLWVuZCcsXHJcbiAgICAgICAgICAgICAgICBtb2RpZmllcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAvKmZsaXA6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVoYXZpb3I6IFsnbGVmdCcsICdib3R0b20nLCAndG9wJ11cclxuICAgICAgICAgICAgICAgICAgICB9LCovXHJcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudE92ZXJmbG93OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiBkb2N1bWVudC5ib2R5LFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvL2RvY3VtZW50LmJvZHkuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJyZ2IoMjQ1LCAyNDUsIDI0NSlcIjsgVE9ET1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnByb2plY3Rvci5yZW5kZXJOb3coKTsgLy8gcmVxdWlyZWQgdG8gdXBkYXRlIHBvcHVwIHBvc2l0aW9uIHRvIGJlIGNvbnRhaW5lZCBieSBib3VuZGFyaWVzIGVsZW1lbnRcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjbG9zZVBvcHVwID0gKCkgPT4ge1xyXG4gICAgICAgIC8vZG9jdW1lbnQuYm9keS5zdHlsZS5iYWNrZ3JvdW5kID0gXCJ3aGl0ZVwiOyBUT0RPXHJcbiAgICAgICAgdGhpcy52aWV3TW9kZWwuY3VycmVudFBvcHVwTW9kZSA9IFBvcHVwTW9kZS5Ob25lO1xyXG4gICAgICAgIHRoaXMudmlld01vZGVsLmN1cnJlbnRTZWNvbmRhcnlQb3B1cE1vZGUgPSBQb3B1cFNlY29uZGFyeU1vZGUuTm9uZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGluc2VydExheW91dEJveEludG9Cb3hQb3B1cCA9ICgpOiBWTm9kZSA9PiB7XHJcbiAgICAgICAgbGV0IGlzUG9wdXBWaXNpYmxlOiBib29sZWFuID0gdGhpcy52aWV3TW9kZWwuY3VycmVudFBvcHVwTW9kZSA9PT0gUG9wdXBNb2RlLlNlbGVjdEJveDtcclxuICAgICAgICBsZXQgaW5zdGFuY2VhYmxlTGF5b3V0Qm94ZXM6IExheW91dEJveFtdID0gW107XHJcbiAgICAgICAgaWYgKGlzUG9wdXBWaXNpYmxlKSB7IC8vIFRPRE8gd2lsbCBicmVhayB3aGVuIGRhdGEgaXMgbm90IHN1cHBsaWVkXHJcbiAgICAgICAgICAgIGxldCBpbnN0YW5jZWFibGVSb3dzVmlldzogQ2FsaWZvcm5pYVZpZXcgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ2FsaWZvcm5pYVZpZXdzLmZpbmQodmlldyA9PiB2aWV3LklzSW50ZXJuYWwgJiYgdmlldy5OYW1lID09PSBcIltJbnRlcm5hbF0gSW5zdGFuY2VhYmxlIExheW91dCBSb3dzXCIpIGFzIENhbGlmb3JuaWFWaWV3OyAvLyBUT0RPIG1hZ2ljIHN0cmluZyA9PiBjb25zdCBleHBvcnRcclxuICAgICAgICAgICAgbGV0IGFsbEJveGVzOiBMYXlvdXRCb3hbXSA9IGluc3RhbmNlYWJsZVJvd3NWaWV3LlBsYWNlZExheW91dFJvd3NbMF0uQWxsQm94ZXNCZWxvd1JvdztcclxuICAgICAgICAgICAgbGV0IGZpcnN0U3ViQm94OiBMYXlvdXRCb3ggPSBhbGxCb3hlcy5maW5kKGIgPT4gYi5QbGFjZWRCb3hJbkJveElkID09PSB1bmRlZmluZWQpIGFzIExheW91dEJveDtcclxuICAgICAgICAgICAgLy9sZXQgdGFyZ2V0Qm94OiBMYXlvdXRCb3ggPSBhbGxCb3hlcy5maW5kKGIgPT4gYi5QbGFjZWRCb3hJbkJveElkID09IGZpcnN0U3ViQm94LkxheW91dEJhc2VJZCkgYXMgTGF5b3V0Qm94OyBUT0RPIGtlcHQgYXMgcmVmZXJlbmNlIGZvciBwcmV2aW91cyBwcm9qZWN0IGRlZmF1bHQgd2l0aCAyeDIgYm94ZXMgKG5vdyAxeDIpXHJcbiAgICAgICAgICAgIGluc3RhbmNlYWJsZUxheW91dEJveGVzLnB1c2goZmlyc3RTdWJCb3gpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHVzZXJJbnN0YW5jZWFibGVWaWV3OiBDYWxpZm9ybmlhVmlldyA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5DYWxpZm9ybmlhVmlld3MuZmluZCh2aWV3ID0+IHZpZXcuSXNJbnRlcm5hbCAmJiB2aWV3Lk5hbWUgPT09IFwiW0ludGVybmFsXSBVc2VyIExheW91dCBNb2xlY3VsZXNcIikgYXMgQ2FsaWZvcm5pYVZpZXc7IC8vIFRPRE8gbWFnaWMgc3RyaW5nID0+IGNvbnN0IGV4cG9ydFxyXG4gICAgICAgICAgICBsZXQgdXNlckJveGVzOiBMYXlvdXRCb3hbXSA9IHVzZXJJbnN0YW5jZWFibGVWaWV3LlBsYWNlZExheW91dFJvd3NbMF0uQWxsQm94ZXNCZWxvd1Jvdy5maWx0ZXIoYiA9PiBiLlBsYWNlZEJveEluQm94SWQgPT09IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIGluc3RhbmNlYWJsZUxheW91dEJveGVzLnB1c2goLi4udXNlckJveGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDxkaXYgaWQ9e2Ake3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXh9UG9wdXBNb2RlJHtQb3B1cE1vZGVbUG9wdXBNb2RlLlNlbGVjdEJveF19YH0gc3R5bGVzPXt7IFwiZGlzcGxheVwiOiBpc1BvcHVwVmlzaWJsZSA/IFwiYmxvY2tcIiA6IFwibm9uZVwiLCBcInotaW5kZXhcIiA6IFwiMzFcIiwgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVcIiwgXCJib3JkZXJcIjogXCJzb2xpZCBibGFjayAxcHhcIiwgXCJoZWlnaHRcIjogXCIzMDBweFwiLCBcIm92ZXJmbG93XCI6IFwic2Nyb2xsXCIgfX0+XHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGVzPXt7IFwiZGlzcGxheVwiOiBcImZsZXhcIiwgXCJmbGV4LWZsb3dcIjogXCJyb3cgbm93cmFwXCIsIFwibWluLXdpZHRoXCI6IFwiMjUwcHhcIiB9fT5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMSAwIDEwJVwiLCBcIndpZHRoXCI6IFwiMTAlXCIsIFwibWluLXdpZHRoXCI6IFwiMTAlXCIgfX0gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2FuY2VsSW5zZXJ0TGF5b3V0Qm94SW50b0JveENsaWNrSGFuZGxlcn0+eDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAge2luc3RhbmNlYWJsZUxheW91dEJveGVzLm1hcCgocHJvcDogTGF5b3V0Qm94KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPGRpdiBrZXk9e3Byb3AuTGF5b3V0QmFzZUlkfT5cclxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHN0eWxlcz17eyBcIndpZHRoXCI6IFwiYXV0b1wiLCBcIm1hcmdpblwiOiBcIjBcIiB9fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk9XCJhXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZT1cImJ1dHRvblwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpZD17cHJvcC5MYXlvdXRCYXNlSWQudG9TdHJpbmcoKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaW5zZXJ0U2VsZWN0ZWRMYXlvdXRCb3hJbnRvQm94T3JSb3dDbGlja0hhbmRsZXJ9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ubW91c2VlbnRlcj17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuaW5zZXJ0Qm94U2hvd1ByZXZpZXdIYW5kbGVyfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbm1vdXNlbGVhdmU9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmluc2VydEJveEhpZGVQcmV2aWV3SGFuZGxlcn0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICYjMTAwMDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgPHAga2V5PVwiMFwiIHN0eWxlcz17eyBcIi13ZWJraXQtdXNlci1zZWxlY3RcIjogXCJub25lXCIsIFwid2lkdGhcIjogXCJhdXRvXCIsIFwibWFyZ2luXCI6IFwiMFwiLCBcImZsb2F0XCI6IFwibGVmdFwiIH19IGxpZD17cHJvcC5MYXlvdXRCYXNlSWQudG9TdHJpbmcoKX0gb250b3VjaHN0YXJ0PXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5pbnNlcnRCb3hTaG93UHJldmlld0hhbmRsZXJ9IG9udG91Y2hlbmQ9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmluc2VydEJveEhpZGVQcmV2aWV3SGFuZGxlcn0+e3Byb3AuTGF5b3V0QmFzZUlkfTwvcD5cclxuICAgICAgICAgICAgICAgIDwvZGl2PjtcclxuICAgICAgICAgICAgfSl9XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIGluc2VydFJvd1Nob3dQcmV2aWV3SGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSA9PiB7IC8vIFRPRE8gY29kZSBkdXBsaWNhdGlvblxyXG4gICAgICAgIGxldCB0YXJnZXRFbGVtZW50OiBIVE1MRWxlbWVudCA9IGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgbGV0IGhvdmVyZWRMYXlvdXRJZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKHRhcmdldEVsZW1lbnQsIFwibGlkXCIpO1xyXG4gICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuaG92ZXJlZEluc2VydExheW91dEJhc2VJZCA9IGhvdmVyZWRMYXlvdXRJZDtcclxuICAgICAgICBsZXQgdGVtcFJvdzogTGF5b3V0Um93ID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkxheW91dE1vbGVjdWxlcy5maW5kKGwgPT4gbC5MYXlvdXRCYXNlSWQgPT0gaG92ZXJlZExheW91dElkKSBhcyBMYXlvdXRSb3c7XHJcbiAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5iYWNrdXBTb3J0T3JkZXIgPSB0ZW1wUm93LkxheW91dFNvcnRPcmRlcktleTtcclxuICAgICAgICB0ZW1wUm93LkxheW91dFNvcnRPcmRlcktleSA9IFZFUllfSElHSF9WQUxVRTsgLy8gVE9ETyB2ZXJ5IGhpZ2ggdmFsdWVcclxuICAgICAgICBsZXQgY2FsaWZvcm5pYVZpZXc6IENhbGlmb3JuaWFWaWV3ID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFWaWV3cy5maW5kKHYgPT4gdi5DYWxpZm9ybmlhVmlld0lkID09IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZENhbGlmb3JuaWFWaWV3SWQpIGFzIENhbGlmb3JuaWFWaWV3O1xyXG4gICAgICAgIGNhbGlmb3JuaWFWaWV3LlBsYWNlZExheW91dFJvd3MucHVzaCh0ZW1wUm93KTtcclxuICAgICAgICBjdXJyZW50QXBwLnJvdXRlci5zZXRBY3RpdmVDYWxpZm9ybmlhVmlldyhjYWxpZm9ybmlhVmlldyk7IC8vIFRPRE8gaW5jb25zaXN0ZW50IGRhdGEgbW9kZWwgbGVhZHMgdG8gdGhpcyBtYW51YWwgcmVmcmVzaCAvIGJveHRyZWUgbm90IGluIHN5bmNcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBpbnNlcnRSb3dIaWRlUHJldmlld0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkgPT4geyAvLyBUT0RPIGNvZGUgZHVwbGljYXRpb25cclxuICAgICAgICBsZXQgY2FsaWZvcm5pYVZpZXc6IENhbGlmb3JuaWFWaWV3ID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFWaWV3cy5maW5kKHYgPT4gdi5DYWxpZm9ybmlhVmlld0lkID09IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZENhbGlmb3JuaWFWaWV3SWQpIGFzIENhbGlmb3JuaWFWaWV3O1xyXG4gICAgICAgIGxldCB0ZW1wUm93SW5kZXg6IG51bWJlciA9IGNhbGlmb3JuaWFWaWV3LlBsYWNlZExheW91dFJvd3MuZmluZEluZGV4KHIgPT4gci5MYXlvdXRCYXNlSWQgPT0gY3VycmVudEFwcC5zdGF0ZS5ob3ZlcmVkSW5zZXJ0TGF5b3V0QmFzZUlkKTtcclxuICAgICAgICBpZiAodGVtcFJvd0luZGV4ICE9IC0xKSB7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wUm93OiBMYXlvdXRSb3cgPSBjYWxpZm9ybmlhVmlldy5QbGFjZWRMYXlvdXRSb3dzLnNwbGljZSh0ZW1wUm93SW5kZXgsIDEpWzBdO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5iYWNrdXBTb3J0T3JkZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGVtcFJvdy5MYXlvdXRTb3J0T3JkZXJLZXkgPSBjdXJyZW50QXBwLnN0YXRlLmJhY2t1cFNvcnRPcmRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmJhY2t1cFNvcnRPcmRlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5ob3ZlcmVkSW5zZXJ0TGF5b3V0QmFzZUlkID0gMDtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5yb3V0ZXIuc2V0QWN0aXZlQ2FsaWZvcm5pYVZpZXcoY2FsaWZvcm5pYVZpZXcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBpbnNlcnRCb3hTaG93UHJldmlld0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkgPT4geyAvLyBUT0RPIGNvZGUgZHVwbGljYXRpb25cclxuICAgICAgICAvLyBUT0RPIHRlc3QgLyBjaGVjayBpcyBpdCBuZWNlc3NhcnkgdG8gYWRkIHN1YmJveCByZWZlcmVuY2VzIHRvIHBhcmVudFJvdz0+YWxsQm94ZXNCZWxvd1JvdyBmb3IgdGhpcyB0ZW1wb3JhcnkgdXBkYXRlP1xyXG4gICAgICAgIGxldCB0YXJnZXRFbGVtZW50OiBIVE1MRWxlbWVudCA9IGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgbGV0IGhvdmVyZWRMYXlvdXRJZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKHRhcmdldEVsZW1lbnQsIFwibGlkXCIpO1xyXG4gICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuaG92ZXJlZEluc2VydExheW91dEJhc2VJZCA9IGhvdmVyZWRMYXlvdXRJZDtcclxuICAgICAgICBsZXQgdGVtcEJveDogTGF5b3V0Qm94ID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkxheW91dE1vbGVjdWxlcy5maW5kKGwgPT4gbC5MYXlvdXRCYXNlSWQgPT0gaG92ZXJlZExheW91dElkKSBhcyBMYXlvdXRCb3g7XHJcbiAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5iYWNrdXBTb3J0T3JkZXIgPSB0ZW1wQm94LkxheW91dFNvcnRPcmRlcktleTtcclxuICAgICAgICB0ZW1wQm94LkxheW91dFNvcnRPcmRlcktleSA9IFZFUllfSElHSF9WQUxVRTsgLy8gVE9ETyB2ZXJ5IGhpZ2ggdmFsdWVcclxuICAgICAgICBsZXQgc2VsZWN0ZWRCb3hPclJvdzogTGF5b3V0QmFzZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5MYXlvdXRNb2xlY3VsZXMuZmluZChsID0+IGwuTGF5b3V0QmFzZUlkID09IGN1cnJlbnRBcHAuc3RhdGUuc2VsZWN0ZWRMYXlvdXRCYXNlSWQpIGFzIExheW91dEJhc2U7XHJcbiAgICAgICAgaWYgKHNlbGVjdGVkQm94T3JSb3cuTGF5b3V0VHlwZSA9PT0gTGF5b3V0VHlwZS5Cb3gpIHtcclxuICAgICAgICAgICAgLy8gc2VlbXMgdG8gd29yayB3aXRob3V0IGNoYW5naW5nIGxheW91dCBib3ggb3duZXIgcm93LCB1bmxpa2Ugd2hlbiBpbnNlcnRpbmcgZGlyZWN0bHkgaW50byBsYXlvdXQgcm93XHJcbiAgICAgICAgICAgIChzZWxlY3RlZEJveE9yUm93IGFzIExheW91dEJveCkuUGxhY2VkSW5Cb3hCb3hlcy5wdXNoKHRlbXBCb3gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzZWxlY3RlZEJveE9yUm93LkxheW91dFR5cGUgPT09IExheW91dFR5cGUuUm93KSB7XHJcbiAgICAgICAgICAgIC8vbGV0IHRlbXBOZXdPd25lclJvdzogTGF5b3V0Um93ID0gc2VsZWN0ZWRCb3hPclJvdyBhcyBMYXlvdXRSb3c7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wTmV3T3duZXJSb3c6IExheW91dFJvdyA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ2FsaWZvcm5pYVZpZXdzLmZpbmQodiA9PiB2LkNhbGlmb3JuaWFWaWV3SWQgPT0gY3VycmVudEFwcC5wYWdlUHJldmlld1ZNLmFjdGl2ZUNhbGlmb3JuaWFWaWV3SWQpIGFzIENhbGlmb3JuaWFWaWV3KS5QbGFjZWRMYXlvdXRSb3dzLmZpbmQocm8gPT4gcm8uTGF5b3V0QmFzZUlkID09IGN1cnJlbnRBcHAuc3RhdGUuc2VsZWN0ZWRMYXlvdXRCYXNlSWQpIGFzIExheW91dFJvdztcclxuICAgICAgICAgICAgdGVtcE5ld093bmVyUm93LkFsbEJveGVzQmVsb3dSb3cucHVzaCh0ZW1wQm94KTtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5iYWNrdXBPd25lclJvd0lkID0gdGVtcEJveC5Cb3hPd25lclJvd0lkO1xyXG4gICAgICAgICAgICB0ZW1wQm94LkJveE93bmVyUm93SWQgPSB0ZW1wTmV3T3duZXJSb3cuTGF5b3V0QmFzZUlkO1xyXG4gICAgICAgICAgICB0ZW1wQm94LkJveE93bmVyUm93ID0gdGVtcE5ld093bmVyUm93O1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmJhY2t1cFBsYWNlZEJveEluQm94SWQgPSB0ZW1wQm94LlBsYWNlZEJveEluQm94SWQ7XHJcbiAgICAgICAgICAgIHRlbXBCb3guUGxhY2VkQm94SW5Cb3hJZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudEFwcC5yb3V0ZXIuc2V0QWN0aXZlQ2FsaWZvcm5pYVZpZXcoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFWaWV3cy5maW5kKHYgPT4gdi5DYWxpZm9ybmlhVmlld0lkID09IGN1cnJlbnRBcHAucGFnZVByZXZpZXdWTS5hY3RpdmVDYWxpZm9ybmlhVmlld0lkKSBhcyBDYWxpZm9ybmlhVmlldyk7IC8vIFRPRE8gaW5jb25zaXN0ZW50IGRhdGEgbW9kZWwgbGVhZHMgdG8gdGhpcyBtYW51YWwgcmVmcmVzaCAvIGJveHRyZWUgbm90IGluIHN5bmNcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBpbnNlcnRCb3hIaWRlUHJldmlld0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkgPT4geyAvLyBUT0RPIGNvZGUgZHVwbGljYXRpb25cclxuICAgICAgICBsZXQgc2VsZWN0ZWRCb3hPclJvdzogTGF5b3V0QmFzZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5MYXlvdXRNb2xlY3VsZXMuZmluZChsID0+IGwuTGF5b3V0QmFzZUlkID09IGN1cnJlbnRBcHAuc3RhdGUuc2VsZWN0ZWRMYXlvdXRCYXNlSWQpIGFzIExheW91dEJhc2U7XHJcbiAgICAgICAgaWYgKHNlbGVjdGVkQm94T3JSb3cuTGF5b3V0VHlwZSA9PT0gTGF5b3V0VHlwZS5Cb3gpIHtcclxuICAgICAgICAgICAgbGV0IGxheW91dEJveDogTGF5b3V0Qm94ID0gc2VsZWN0ZWRCb3hPclJvdyBhcyBMYXlvdXRCb3g7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wQm94SW5kZXg6IG51bWJlciA9IGxheW91dEJveC5QbGFjZWRJbkJveEJveGVzLmZpbmRJbmRleChiID0+IGIuTGF5b3V0QmFzZUlkID09IGN1cnJlbnRBcHAuc3RhdGUuaG92ZXJlZEluc2VydExheW91dEJhc2VJZCk7XHJcbiAgICAgICAgICAgIGlmICh0ZW1wQm94SW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGxldCB0ZW1wQm94OiBMYXlvdXRCb3ggPSBsYXlvdXRCb3guUGxhY2VkSW5Cb3hCb3hlcy5zcGxpY2UodGVtcEJveEluZGV4LCAxKVswXTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLmJhY2t1cFNvcnRPcmRlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcEJveC5MYXlvdXRTb3J0T3JkZXJLZXkgPSBjdXJyZW50QXBwLnN0YXRlLmJhY2t1cFNvcnRPcmRlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlIGFsd2F5cyBzZXRcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmJhY2t1cFNvcnRPcmRlciA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuaG92ZXJlZEluc2VydExheW91dEJhc2VJZCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0ZWRCb3hPclJvdy5MYXlvdXRUeXBlID09PSBMYXlvdXRUeXBlLlJvdykge1xyXG4gICAgICAgICAgICBsZXQgbGF5b3V0Um93OiBMYXlvdXRSb3cgPSBzZWxlY3RlZEJveE9yUm93IGFzIExheW91dFJvdztcclxuICAgICAgICAgICAgbGV0IHRlbXBCb3hJbmRleDogbnVtYmVyID0gbGF5b3V0Um93LkFsbEJveGVzQmVsb3dSb3cuZmluZEluZGV4KGIgPT4gYi5MYXlvdXRCYXNlSWQgPT0gY3VycmVudEFwcC5zdGF0ZS5ob3ZlcmVkSW5zZXJ0TGF5b3V0QmFzZUlkKTtcclxuICAgICAgICAgICAgaWYgKHRlbXBCb3hJbmRleCAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRlbXBCb3g6IExheW91dEJveCA9IGxheW91dFJvdy5BbGxCb3hlc0JlbG93Um93LnNwbGljZSh0ZW1wQm94SW5kZXgsIDEpWzBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUuYmFja3VwU29ydE9yZGVyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wQm94LkxheW91dFNvcnRPcmRlcktleSA9IGN1cnJlbnRBcHAuc3RhdGUuYmFja3VwU29ydE9yZGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUuYmFja3VwT3duZXJSb3dJZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUgc2V0IG9ubHkgaW4gY2VydGFpbiBjYXNlc1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBiYWNrdXBSb3cgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuTGF5b3V0TW9sZWN1bGVzLmZpbmQociA9PiByLkxheW91dEJhc2VJZCA9PSBjdXJyZW50QXBwLnN0YXRlLmJhY2t1cE93bmVyUm93SWQpIGFzIExheW91dFJvdztcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wQm94LkJveE93bmVyUm93SWQgPSBjdXJyZW50QXBwLnN0YXRlLmJhY2t1cE93bmVyUm93SWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcEJveC5Cb3hPd25lclJvdyA9IGJhY2t1cFJvdztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5iYWNrdXBQbGFjZWRCb3hJbkJveElkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcEJveC5QbGFjZWRCb3hJbkJveElkID0gY3VycmVudEFwcC5zdGF0ZS5iYWNrdXBQbGFjZWRCb3hJbkJveElkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmJhY2t1cE93bmVyUm93SWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5iYWNrdXBQbGFjZWRCb3hJbkJveElkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5iYWNrdXBTb3J0T3JkZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmhvdmVyZWRJbnNlcnRMYXlvdXRCYXNlSWQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRBcHAucm91dGVyLnNldEFjdGl2ZUNhbGlmb3JuaWFWaWV3KGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5DYWxpZm9ybmlhVmlld3MuZmluZCh2ID0+IHYuQ2FsaWZvcm5pYVZpZXdJZCA9PSBjdXJyZW50QXBwLnBhZ2VQcmV2aWV3Vk0uYWN0aXZlQ2FsaWZvcm5pYVZpZXdJZCkgYXMgQ2FsaWZvcm5pYVZpZXcpOyAvLyBUT0RPIGluY29uc2lzdGVudCBkYXRhIG1vZGVsIGxlYWRzIHRvIHRoaXMgbWFudWFsIHJlZnJlc2ggLyBib3h0cmVlIG5vdCBpbiBzeW5jXHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgaW5zZXJ0QXRvbVNob3dQcmV2aWV3SGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50KSA9PiB7IC8vIFRPRE8gY29kZSBkdXBsaWNhdGlvblxyXG4gICAgICAgIC8vIFRPRE8gZXZlcnl3aGVyZSBtYWtlIHVzZSBvZiBpbnQ4IGFuZCBmaXggZW51bS9ib29sIHRvIGludDMyIGRlZmF1bHQgY29lcmNpb25zXHJcbiAgICAgICAgbGV0IHRhcmdldEVsZW1lbnQ6IEhUTUxFbGVtZW50ID0gZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICBsZXQgaG92ZXJlZExheW91dElkOiBudW1iZXIgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUodGFyZ2V0RWxlbWVudCwgXCJsaWRcIik7XHJcbiAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5ob3ZlcmVkSW5zZXJ0TGF5b3V0QmFzZUlkID0gaG92ZXJlZExheW91dElkO1xyXG4gICAgICAgIGxldCB0ZW1wQXRvbTogTGF5b3V0QXRvbSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5MYXlvdXRNb2xlY3VsZXMuZmluZChsID0+IGwuTGF5b3V0QmFzZUlkID09IGhvdmVyZWRMYXlvdXRJZCkgYXMgTGF5b3V0QXRvbTtcclxuICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmJhY2t1cFNvcnRPcmRlciA9IHRlbXBBdG9tLkxheW91dFNvcnRPcmRlcktleTtcclxuICAgICAgICB0ZW1wQXRvbS5MYXlvdXRTb3J0T3JkZXJLZXkgPSBWRVJZX0hJR0hfVkFMVUU7IC8vIFRPRE8gdmVyeSBoaWdoIHZhbHVlXHJcbiAgICAgICAgbGV0IGxheW91dEJveDogTGF5b3V0Qm94ID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkxheW91dE1vbGVjdWxlcy5maW5kKGwgPT4gbC5MYXlvdXRCYXNlSWQgPT0gY3VycmVudEFwcC5zdGF0ZS5zZWxlY3RlZExheW91dEJhc2VJZCkgYXMgTGF5b3V0Qm94O1xyXG4gICAgICAgIGxheW91dEJveC5QbGFjZWRJbkJveEF0b21zLnB1c2godGVtcEF0b20pO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIGluc2VydEF0b21IaWRlUHJldmlld0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudCkgPT4geyAvLyBUT0RPIGNvZGUgZHVwbGljYXRpb25cclxuICAgICAgICBsZXQgbGF5b3V0Qm94OiBMYXlvdXRCb3ggPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuTGF5b3V0TW9sZWN1bGVzLmZpbmQobCA9PiBsLkxheW91dEJhc2VJZCA9PSBjdXJyZW50QXBwLnN0YXRlLnNlbGVjdGVkTGF5b3V0QmFzZUlkKSBhcyBMYXlvdXRCb3g7XHJcbiAgICAgICAgbGV0IHRlbXBBdG9tSW5kZXg6IG51bWJlciA9IGxheW91dEJveC5QbGFjZWRJbkJveEF0b21zLmZpbmRJbmRleChhID0+IGEuTGF5b3V0QmFzZUlkID09IGN1cnJlbnRBcHAuc3RhdGUuaG92ZXJlZEluc2VydExheW91dEJhc2VJZCk7XHJcbiAgICAgICAgaWYgKHRlbXBBdG9tSW5kZXggIT0gLTEpIHtcclxuICAgICAgICAgICAgbGV0IHRlbXBBdG9tOiBMYXlvdXRBdG9tID0gbGF5b3V0Qm94LlBsYWNlZEluQm94QXRvbXMuc3BsaWNlKHRlbXBBdG9tSW5kZXgsIDEpWzBdO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5iYWNrdXBTb3J0T3JkZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGVtcEF0b20uTGF5b3V0U29ydE9yZGVyS2V5ID0gY3VycmVudEFwcC5zdGF0ZS5iYWNrdXBTb3J0T3JkZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5iYWNrdXBTb3J0T3JkZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuaG92ZXJlZEluc2VydExheW91dEJhc2VJZCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgaW5zZXJ0U2VsZWN0ZWRMYXlvdXRCb3hJbnRvQm94T3JSb3dDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgLy8gVE9ETyBkb2N1bWVudCBwb3B1cCBpcyByZXVzZWRcclxuICAgICAgICBpZiAodGhpcy52aWV3TW9kZWwuY3VycmVudFNlY29uZGFyeVBvcHVwTW9kZSA9PT0gUG9wdXBTZWNvbmRhcnlNb2RlLlNlbGVjdEJveEludG9Cb3gpIHtcclxuICAgICAgICAgICAgbGV0IGxheW91dElkOiBudW1iZXIgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJsaWRcIik7XHJcbiAgICAgICAgICAgIGxldCB0YXJnZXRMYXlvdXRJZDogbnVtYmVyID0gY3VycmVudEFwcC5zdGF0ZS5zZWxlY3RlZExheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLkNyZWF0ZUxheW91dEJveEZvckJveE9yUm93SnNvbih0YXJnZXRMYXlvdXRJZCwgbGF5b3V0SWQpLmRvbmUoZGF0YSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBmb2N1cyBsYXN0IGF0b20gaWYgb25lIHdhcyBjcmVhdGVkXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmxhc3RDb21tYW5kID0gQ2FsaWZvcm5pYUV2ZW50LkNyZWF0ZUxheW91dEJveEZvckJveE9yUm93O1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmxhc3RDYWxpZm9ybmlhRXZlbnREYXRhID0gW2N1cnJlbnRBcHAuc3RhdGUuc2VsZWN0ZWRMYXlvdXRCYXNlSWQsIGxheW91dElkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy52aWV3TW9kZWwuY3VycmVudFNlY29uZGFyeVBvcHVwTW9kZSA9PT0gUG9wdXBTZWNvbmRhcnlNb2RlLlNlbGVjdEJveEludG9Cb3hBdG9tSW5QbGFjZSkge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuQ3JlYXRlTGF5b3V0Qm94Rm9yQXRvbUluUGxhY2VKc29uKGN1cnJlbnRBcHAuc3RhdGUuc2VsZWN0ZWRMYXlvdXRCYXNlSWQsIHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImxpZFwiKSkuZG9uZShkYXRhID0+IHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGZvY3VzIGxhc3QgYXRvbSBpZiBvbmUgd2FzIGNyZWF0ZWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgfSAgICAgICAgXHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2xvc2VQb3B1cCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY2FuY2VsSW5zZXJ0TGF5b3V0Qm94SW50b0JveENsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jbG9zZVBvcHVwKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qcHVibGljIG1vdmVMYXlvdXRNb2xlY3VsZUludG9Qb3B1cCA9ICgpOiBWTm9kZSA9PiB7XHJcbiAgICAgICAgbGV0IHRoaXNQb3B1cE1vZGU6IFBvcHVwTW9kZSA9IFBvcHVwTW9kZS5Nb3ZlTGF5b3V0TW9sZWN1bGVJbnRvTGF5b3V0TW9sZWN1bGU7XHJcbiAgICAgICAgbGV0IGlzUG9wdXBWaXNpYmxlOiBib29sZWFuID0gdGhpcy52aWV3TW9kZWwuY3VycmVudFBvcHVwTW9kZSA9PT0gdGhpc1BvcHVwTW9kZTtcclxuICAgICAgICBsZXQgaXNEYXRhTG9hZGVkOiBib29sZWFuID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0ICE9PSB1bmRlZmluZWQgJiYgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzICE9PSB1bmRlZmluZWQ7IC8vIFRPRE8gY29kZSBkdXBsaWNhdGlvbiAvIHN0YXRlXHJcbiAgICAgICAgcmV0dXJuIDxkaXYgaWQ9e2Ake3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXh9UG9wdXBNb2RlJHtQb3B1cE1vZGVbdGhpc1BvcHVwTW9kZV19YH0gc3R5bGVzPXt7IFwiZGlzcGxheVwiOiBpc1BvcHVwVmlzaWJsZSA/IFwiYmxvY2tcIiA6IFwibm9uZVwiLCBcInotaW5kZXhcIiA6IFwiMzFcIiwgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVcIiwgXCJib3JkZXJcIjogXCJzb2xpZCBibGFjayAxcHhcIiB9fT5cclxuICAgICAgICAgICAgPGRpdiBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IFwiZmxleFwiLCBcImZsZXgtZmxvd1wiOiBcInJvdyBub3dyYXBcIiwgXCJtaW4td2lkdGhcIjogXCIyNTBweFwiIH19PlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIxIDAgMTAlXCIsIFwid2lkdGhcIjogXCIxMCVcIiwgXCJtaW4td2lkdGhcIjogXCIxMCVcIiB9fSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jYW5jZWxMYXlvdXRNb2xlY3VsZUludG9DbGlja0hhbmRsZXJ9Png8L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIHtpc0RhdGFMb2FkZWQgPyBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuTGF5b3V0TW9sZWN1bGVzLm1hcCgobGF5b3V0TW9sZWN1bGU6IExheW91dEJhc2UpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChsYXlvdXRNb2xlY3VsZS5MYXlvdXRUeXBlID09PSBMYXlvdXRUeXBlLkF0b20pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IGxheW91dEJhc2VJZFN0cmluZzogc3RyaW5nID0gbGF5b3V0TW9sZWN1bGUuTGF5b3V0QmFzZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc291cmNlU3R5bGVNb2xlY3VsZUlkU3RyaW5nID0gKGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcy5maW5kKG0gPT4gbS5TdHlsZUZvckxheW91dElkID09IGxheW91dE1vbGVjdWxlLkxheW91dEJhc2VJZCkgYXMgU3R5bGVNb2xlY3VsZSkuU3R5bGVNb2xlY3VsZUlkLnRvU3RyaW5nKCk7IC8vIFRPRE8gZXhwZW5zaXZlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPGRpdiBrZXk9e2xheW91dEJhc2VJZFN0cmluZ30+XHJcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgbGlkPXtsYXlvdXRCYXNlSWRTdHJpbmd9IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLm1vdmVMYXlvdXRNb2xlY3VsZUludG9MYXlvdXRNb2xlY3VsZUNsaWNrSGFuZGxlcn0+I3tsYXlvdXRCYXNlSWRTdHJpbmd9IHtMYXlvdXRUeXBlW2xheW91dE1vbGVjdWxlLkxheW91dFR5cGVdfSBzdHlsZSAje3NvdXJjZVN0eWxlTW9sZWN1bGVJZFN0cmluZ308L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICB9KSA6IHVuZGVmaW5lZH1cclxuICAgICAgICA8L2Rpdj4gYXMgVk5vZGU7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBwdWJsaWMgbW92ZUxheW91dE1vbGVjdWxlSW50b0xheW91dE1vbGVjdWxlQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5Nb3ZlTGF5b3V0TW9sZWN1bGVJbnRvTGF5b3V0TW9sZWN1bGVKc29uKGN1cnJlbnRBcHAuc3RhdGUuc2VsZWN0ZWRMYXlvdXRCYXNlSWQsIHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImxpZFwiKSkuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmNsb3NlUG9wdXAoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNhbmNlbExheW91dE1vbGVjdWxlSW50b0NsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jbG9zZVBvcHVwKCk7XHJcbiAgICB9OyovXHJcblxyXG4gICAgcHVibGljIG1vdmVMYXlvdXRNb2xlY3VsZUludG9MYXlvdXRNb2xlY3VsZSA9ICgpID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuTW92ZUxheW91dE1vbGVjdWxlSW50b0xheW91dE1vbGVjdWxlSnNvbihjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkLCBjdXJyZW50QXBwLnN0YXRlLnNlbGVjdGVkTGF5b3V0QmFzZUlkKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2xvc2VQb3B1cCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKnB1YmxpYyBtb3ZlTGF5b3V0TW9sZWN1bGVCZWZvcmVQb3B1cCA9ICgpOiBWTm9kZSA9PiB7IFRPRE8gdW51c2VkXHJcbiAgICAgICAgbGV0IHRoaXNQb3B1cE1vZGU6IFBvcHVwTW9kZSA9IFBvcHVwTW9kZS5Nb3ZlTGF5b3V0TW9sZWN1bGVCZWZvcmVMYXlvdXRNb2xlY3VsZTtcclxuICAgICAgICBsZXQgaXNQb3B1cFZpc2libGU6IGJvb2xlYW4gPSB0aGlzLnZpZXdNb2RlbC5jdXJyZW50UG9wdXBNb2RlID09PSB0aGlzUG9wdXBNb2RlO1xyXG4gICAgICAgIGxldCBpc0RhdGFMb2FkZWQ6IGJvb2xlYW4gPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QgIT09IHVuZGVmaW5lZCAmJiBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuUmVzcG9uc2l2ZURldmljZXMgIT09IHVuZGVmaW5lZDsgLy8gVE9ETyBjb2RlIGR1cGxpY2F0aW9uIC8gc3RhdGVcclxuICAgICAgICByZXR1cm4gPGRpdiBpZD17YCR7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucHJvcGVydHlCYXJJbmRleH1Qb3B1cE1vZGUke1BvcHVwTW9kZVt0aGlzUG9wdXBNb2RlXX1gfSBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IGlzUG9wdXBWaXNpYmxlID8gXCJibG9ja1wiIDogXCJub25lXCIsIFwiei1pbmRleFwiIDogXCIzMVwiLCBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLCBcImJvcmRlclwiOiBcInNvbGlkIGJsYWNrIDFweFwiIH19PlxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlcz17eyBcImRpc3BsYXlcIjogXCJmbGV4XCIsIFwiZmxleC1mbG93XCI6IFwicm93IG5vd3JhcFwiLCBcIm1pbi13aWR0aFwiOiBcIjI1MHB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgc3R5bGVzPXt7IFwiZmxleFwiOiBcIjEgMCAxMCVcIiwgXCJ3aWR0aFwiOiBcIjEwJVwiLCBcIm1pbi13aWR0aFwiOiBcIjEwJVwiIH19IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmNhbmNlbExheW91dE1vbGVjdWxlQmVmb3JlQ2xpY2tIYW5kbGVyfT54PC9idXR0b24+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICB7aXNEYXRhTG9hZGVkID8gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkxheW91dE1vbGVjdWxlcy5tYXAoKGxheW91dE1vbGVjdWxlOiBMYXlvdXRCYXNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGF5b3V0QmFzZUlkU3RyaW5nOiBzdHJpbmcgPSBsYXlvdXRNb2xlY3VsZS5MYXlvdXRCYXNlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGxldCBzb3VyY2VTdHlsZU1vbGVjdWxlSWRTdHJpbmcgPSAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlTW9sZWN1bGVzLmZpbmQobSA9PiBtLlN0eWxlRm9yTGF5b3V0SWQgPT0gbGF5b3V0TW9sZWN1bGUuTGF5b3V0QmFzZUlkKSBhcyBTdHlsZU1vbGVjdWxlKS5TdHlsZU1vbGVjdWxlSWQudG9TdHJpbmcoKTsgLy8gVE9ETyBleHBlbnNpdmVcclxuICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17bGF5b3V0QmFzZUlkU3RyaW5nfT5cclxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiBsaWQ9e2xheW91dEJhc2VJZFN0cmluZ30gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIubW92ZUxheW91dE1vbGVjdWxlQmVmb3JlTGF5b3V0TW9sZWN1bGVDbGlja0hhbmRsZXJ9PiN7bGF5b3V0QmFzZUlkU3RyaW5nfSB7TGF5b3V0VHlwZVtsYXlvdXRNb2xlY3VsZS5MYXlvdXRUeXBlXX0gc3R5bGUgI3tzb3VyY2VTdHlsZU1vbGVjdWxlSWRTdHJpbmd9PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgfSkgOiB1bmRlZmluZWR9XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgbW92ZUxheW91dE1vbGVjdWxlQmVmb3JlTGF5b3V0TW9sZWN1bGVDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLk1vdmVMYXlvdXRNb2xlY3VsZU5leHRUb0xheW91dE1vbGVjdWxlSnNvbihjdXJyZW50QXBwLnN0YXRlLnNlbGVjdGVkTGF5b3V0QmFzZUlkLCBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJsaWRcIiksIHRydWUpLmRvbmUoZGF0YSA9PiBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jbG9zZVBvcHVwKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjYW5jZWxMYXlvdXRNb2xlY3VsZUJlZm9yZUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jbG9zZVBvcHVwKCk7XHJcbiAgICB9OyovXHJcblxyXG4gICAgcHVibGljIG1vdmVMYXlvdXRNb2xlY3VsZUJlZm9yZUxheW91dE1vbGVjdWxlID0gKCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5Nb3ZlTGF5b3V0TW9sZWN1bGVOZXh0VG9MYXlvdXRNb2xlY3VsZUpzb24oY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCwgY3VycmVudEFwcC5zdGF0ZS5zZWxlY3RlZExheW91dEJhc2VJZCwgdHJ1ZSkuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmNsb3NlUG9wdXAoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHN5bmNMYXlvdXRNb2xlY3VsZVN0eWxlc0ltaXRhdGluZ1JlZmVyZW5jZUxheW91dCA9ICgpID0+IHtcclxuICAgICAgICAvLyBUT0RPIGV2ZXJ5d2hlcmUgY2hlY2tzIG1vdmUvZHVwbGljYXRlIHRvIGNsaWVudFxyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5TeW5jTGF5b3V0U3R5bGVzSW1pdGF0aW5nUmVmZXJlbmNlTGF5b3V0SnNvbihjdXJyZW50QXBwLnN0YXRlLnNlbGVjdGVkTGF5b3V0QmFzZUlkLCBjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7IC8vIFRPRE8gY29uY2VwdDogdGFyZ2V0L3ByZXNlbGVjdCBvcmRlciBjaGFuZ2VzXHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2xvc2VQb3B1cCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgbW92ZVN0eWxlQXRvbVRvUmVzcG9uc2l2ZURldmljZVBvcHVwID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICBsZXQgdGhpc1BvcHVwTW9kZTogUG9wdXBNb2RlID0gUG9wdXBNb2RlLk1vdmVTdHlsZUF0b207XHJcbiAgICAgICAgbGV0IGlzUG9wdXBWaXNpYmxlOiBib29sZWFuID0gdGhpcy52aWV3TW9kZWwuY3VycmVudFBvcHVwTW9kZSA9PT0gdGhpc1BvcHVwTW9kZTtcclxuICAgICAgICBsZXQgaXNEYXRhTG9hZGVkOiBib29sZWFuID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0ICE9PSB1bmRlZmluZWQgJiYgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzICE9PSB1bmRlZmluZWQ7IC8vIFRPRE8gY29kZSBkdXBsaWNhdGlvbiAvIHN0YXRlXHJcbiAgICAgICAgcmV0dXJuIDxkaXYgaWQ9e2Ake3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXh9UG9wdXBNb2RlJHtQb3B1cE1vZGVbdGhpc1BvcHVwTW9kZV19YH0gc3R5bGVzPXt7IFwiZGlzcGxheVwiOiBpc1BvcHVwVmlzaWJsZSA/IFwiYmxvY2tcIiA6IFwibm9uZVwiLCBcInotaW5kZXhcIiA6IFwiMzFcIiwgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVcIiwgXCJib3JkZXJcIjogXCJzb2xpZCBibGFjayAxcHhcIiB9fT5cclxuICAgICAgICAgICAgPGRpdiBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IFwiZmxleFwiLCBcImZsZXgtZmxvd1wiOiBcInJvdyBub3dyYXBcIiwgXCJtaW4td2lkdGhcIjogXCIyNTBweFwiIH19PlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIxIDAgMTAlXCIsIFwid2lkdGhcIjogXCIxMCVcIiwgXCJtaW4td2lkdGhcIjogXCIxMCVcIiB9fSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jYW5jZWxNb3ZlU3R5bGVBdG9tQ2xpY2tIYW5kbGVyfT54PC9idXR0b24+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICB7aXNEYXRhTG9hZGVkID8gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzLm1hcCgocmVzcG9uc2l2ZURldmljZTogUmVzcG9uc2l2ZURldmljZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNpdmVEZXZpY2VJZFN0cmluZzogc3RyaW5nID0gcmVzcG9uc2l2ZURldmljZS5SZXNwb25zaXZlRGV2aWNlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGxldCBpc1NlbGVjdGVkUmVzcG9uc2l2ZURldmljZUluUHJvcGVydHlCYXI6IGJvb2xlYW4gPSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRSZXNwb25zaXZlRGV2aWNlSWQgPT0gcmVzcG9uc2l2ZURldmljZS5SZXNwb25zaXZlRGV2aWNlSWQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPGRpdiBrZXk9e3Jlc3BvbnNpdmVEZXZpY2VJZFN0cmluZ30+XHJcbiAgICAgICAgICAgICAgICAgICAgeyFpc1NlbGVjdGVkUmVzcG9uc2l2ZURldmljZUluUHJvcGVydHlCYXIgPyA8YnV0dG9uIGtleT1cImFcIiByaWQ9e3Jlc3BvbnNpdmVEZXZpY2VJZFN0cmluZ30gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIubW92ZVN0eWxlQXRvbVRvUmVzcG9uc2l2ZURldmljZUNsaWNrSGFuZGxlcn0+e3Jlc3BvbnNpdmVEZXZpY2UuTmFtZVNob3J0fTwvYnV0dG9uPiA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gZGlzYWJsZWQga2V5PVwiYTBcIiByaWQ9e3Jlc3BvbnNpdmVEZXZpY2VJZFN0cmluZ30gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIubW92ZVN0eWxlQXRvbVRvUmVzcG9uc2l2ZURldmljZUNsaWNrSGFuZGxlcn0+e3Jlc3BvbnNpdmVEZXZpY2UuTmFtZVNob3J0fTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICB9KSA6IHVuZGVmaW5lZH1cclxuICAgICAgICA8L2Rpdj4gYXMgVk5vZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBtb3ZlU3R5bGVBdG9tVG9SZXNwb25zaXZlRGV2aWNlQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCB0YXJnZXRSZXNwb25zaXZlRGV2aWNlSWQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcInJpZFwiKTtcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuTW92ZVN0eWxlQXRvbVRvUmVzcG9uc2l2ZURldmljZUpzb24odGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3R5bGVBdG9tSWRGb3JQb3B1cCwgdGFyZ2V0UmVzcG9uc2l2ZURldmljZUlkKS5kb25lKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRSZXNwb25zaXZlRGV2aWNlSWQgPSB0YXJnZXRSZXNwb25zaXZlRGV2aWNlSWQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3R5bGVBdG9tSWRGb3JQb3B1cCA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2xvc2VQb3B1cCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY2FuY2VsTW92ZVN0eWxlQXRvbUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZUF0b21JZEZvclBvcHVwID0gMDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jbG9zZVBvcHVwKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJBbGxDc3NQcm9wZXJ0aWVzUG9wdXAgPSAoKTogVk5vZGUgPT4ge1xyXG4gICAgICAgIGxldCBpc1BvcHVwVmlzaWJsZTogYm9vbGVhbiA9IHRoaXMudmlld01vZGVsLmN1cnJlbnRQb3B1cE1vZGUgPT09IFBvcHVwTW9kZS5BbGxDc3NQcm9wZXJ0aWVzO1xyXG4gICAgICAgIHJldHVybiA8ZGl2IGlkPXtgJHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5wcm9wZXJ0eUJhckluZGV4fVBvcHVwTW9kZSR7UG9wdXBNb2RlW1BvcHVwTW9kZS5BbGxDc3NQcm9wZXJ0aWVzXX1gfSBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IGlzUG9wdXBWaXNpYmxlID8gXCJibG9ja1wiIDogXCJub25lXCIsIFwiei1pbmRleFwiIDogXCIzMVwiLCBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLCBcImJvcmRlclwiOiBcInNvbGlkIGJsYWNrIDFweFwiLCBcImhlaWdodFwiOiBcIjMwMHB4XCIsIFwib3ZlcmZsb3dcIjogXCJzY3JvbGxcIiB9fT5cclxuICAgICAgICAgICAgPGRpdiBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IFwiZmxleFwiLCBcImZsZXgtZmxvd1wiOiBcInJvdyBub3dyYXBcIiwgXCJtaW4td2lkdGhcIjogXCIyNTBweFwiIH19PlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIxIDAgMTAlXCIsIFwid2lkdGhcIjogXCIxMCVcIiwgXCJtaW4td2lkdGhcIjogXCIxMCVcIiB9fSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jYW5jZWxVcGRhdGVDc3NQcm9wZXJ0eWxpY2tIYW5kbGVyfT54PC9idXR0b24+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICB7Y3VycmVudEFwcC5jbGllbnREYXRhLkFsbENzc1Byb3BlcnRpZXMubWFwKChwcm9wOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBpc1Byb3BlcnR5VW5tYXBwZWQ6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgbGV0IGlzUHJvcGVydHlWaXNpYmxlOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3R5bGVBdG9tSWQgIT0gMCAmJiBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICYmIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZUF0b21zICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0QXRvbTogU3R5bGVBdG9tIHwgdW5kZWZpbmVkID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlQXRvbXMuZmluZChzID0+IHMuU3R5bGVBdG9tSWQgPT0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3R5bGVBdG9tSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRBdG9tICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0QXRvbS5BcHBsaWVkVmFsdWVzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcm9wZXJ0eVZpc2libGUgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuU3R5bGVBdG9tQ3NzUHJvcGVydHlNYXBwaW5nW1N0eWxlQXRvbVR5cGVbdGFyZ2V0QXRvbS5TdHlsZUF0b21UeXBlXV0uZmluZEluZGV4KHAgPT4gcCA9PT0gcHJvcCkgIT0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJvcGVydHlVbm1hcHBlZCA9IHRhcmdldEF0b20uQXBwbGllZFZhbHVlcy5maW5kSW5kZXgodiA9PiB2LkNzc1Byb3BlcnR5ID09PSBwcm9wKSA9PSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eVZpc2libGUgPyA8ZGl2IGtleT17cHJvcH0+XHJcbiAgICAgICAgICAgICAgICAgICAge3Byb3B9eyBpc1Byb3BlcnR5VW5tYXBwZWQgPyA8YnV0dG9uIGtleT1cImEwXCIgcm9sZT1cImJ1dHRvblwiIGNpZD17cHJvcH0gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2V0U2VsZWN0ZWRDc3NQcm9wZXJ0eUNsaWNrSGFuZGxlcn0+JiMxMDAwNDs8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgOiA8YnV0dG9uIGRpc2FibGVkIGtleT1cImExXCIgcm9sZT1cImJ1dHRvblwiIGNpZD17cHJvcH0gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2V0U2VsZWN0ZWRDc3NQcm9wZXJ0eUNsaWNrSGFuZGxlcn0+JiMxMDAwNDs8L2J1dHRvbj59XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj4gOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0pfVxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNhbmNlbFVwZGF0ZUNzc1Byb3BlcnR5bGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy52aWV3TW9kZWwuY3VycmVudFBvcHVwTW9kZSA9IFBvcHVwTW9kZS5BZGRDc3NQcm9wZXJ0eTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNob3dBbGxDc3NQcm9wZXJ0aWVzQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmRpc3BsYXlQb3B1cChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCBQb3B1cE1vZGUuQWxsQ3NzUHJvcGVydGllcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzZXRTZWxlY3RlZENzc1Byb3BlcnR5Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzUHJvcGVydHlOYW1lID0gcGFyc2VTdHJpbmdGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwiY2lkXCIpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnNhdmVDc3NQcm9wZXJ0eUZvckF0b20oKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNhdmVDc3NQcm9wZXJ0eUZvckF0b21DbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2F2ZUNzc1Byb3BlcnR5Rm9yQXRvbSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIHNhdmVDc3NQcm9wZXJ0eUZvckF0b20gPSAoKTogdm9pZCA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLkNyZWF0ZVN0eWxlVmFsdWVGb3JBdG9tSnNvbih0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZUF0b21JZCwgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDc3NQcm9wZXJ0eU5hbWUpLmRvbmUoZGF0YSA9PiBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZXNldFRlbXBDc3NQcm9wZXJ0eVN0YXRlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjYW5jZWxBZGRDc3NQcm9wZXJ0eUZvckF0b21DbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIucmVzZXRUZW1wQ3NzUHJvcGVydHlTdGF0ZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVzZXRUZW1wQ3NzUHJvcGVydHlTdGF0ZSA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1Byb3BlcnR5TmFtZSA9IFwiXCI7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDc3NWYWx1ZSA9IFwiXCI7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3R5bGVBdG9tSWQgPSAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFN0eWxlVmFsdWVJZCA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3R5bGVRdWFudHVtSWQgPSAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmNsb3NlUG9wdXAoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNzc1Byb3BlcnR5TmFtZUlucHV0SGFuZGxlciA9IChldnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1Byb3BlcnR5TmFtZSA9IChldnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyVXBkYXRlQ3NzVmFsdWVQb3B1cCA9ICgpOiBWTm9kZSA9PiB7XHJcbiAgICAgICAgbGV0IGlzUG9wdXBWaXNpYmxlOiBib29sZWFuID0gdGhpcy52aWV3TW9kZWwuY3VycmVudFBvcHVwTW9kZSA9PT0gUG9wdXBNb2RlLlVwZGF0ZUNzc1ZhbHVlIHx8IHRoaXMudmlld01vZGVsLmN1cnJlbnRQb3B1cE1vZGUgPT09IFBvcHVwTW9kZS5NYXRjaGluZ1F1YW50dW1zO1xyXG4gICAgICAgIHJldHVybiA8ZGl2IGlkPXtgJHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5wcm9wZXJ0eUJhckluZGV4fVBvcHVwTW9kZSR7UG9wdXBNb2RlW1BvcHVwTW9kZS5VcGRhdGVDc3NWYWx1ZV19YH0gc3R5bGVzPXt7IFwiZGlzcGxheVwiOiBpc1BvcHVwVmlzaWJsZSA/IFwiYmxvY2tcIiA6IFwibm9uZVwiLCBcInotaW5kZXhcIiA6IFwiMzFcIiwgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVcIiwgXCJib3JkZXJcIjogXCJzb2xpZCBibGFjayAxcHhcIiB9fT5cclxuICAgICAgICAgICAgPGRpdiBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IFwiZmxleFwiLCBcImZsZXgtZmxvd1wiOiBcInJvdyBub3dyYXBcIiwgXCJtaW4td2lkdGhcIjogXCIyNTBweFwiIH19PlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIxIDAgMTAlXCIsIFwid2lkdGhcIjogXCIxMCVcIiwgXCJtaW4td2lkdGhcIjogXCIxMCVcIiB9fSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zYXZlVXBkYXRlZENzc1ZhbHVlQ2xpY2tIYW5kbGVyfT4mIzEwMDA0OzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJiXCIgcm9sZT1cImJ1dHRvblwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIxIDAgMTAlXCIsIFwid2lkdGhcIjogXCIxMCVcIiwgXCJtaW4td2lkdGhcIjogXCIxMCVcIiB9fSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jYW5jZWxVcGRhdGVDc3NWYWx1ZUNsaWNrSGFuZGxlcn0+eDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxpbnB1dCBrZXk9XCItMVwiXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzVmFsdWV9XHJcbiAgICAgICAgICAgICAgICAgICAgb25pbnB1dD17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY3NzVmFsdWVJbnB1dEhhbmRsZXJ9PlxyXG4gICAgICAgICAgICAgICAgPC9pbnB1dD5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zaG93TWF0Y2hpbmdRdWFudHVtc0NsaWNrSGFuZGxlcn0+PzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJiXCIgcm9sZT1cImJ1dHRvblwiIG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnNob3dTdWdnZXN0ZWRDc3NWYWx1ZXNDbGlja0hhbmRsZXJ9Pj8/PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImNcIiByb2xlPVwiYnV0dG9uXCIgb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2V0VGVtcENzc1RvWmVyb0NsaWNrSGFuZGxlcn0+MDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJkXCIgcm9sZT1cImJ1dHRvblwiIG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnNldFRlbXBDc3NUb05vbmVDbGlja0hhbmRsZXJ9Pm5vbmU8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiZVwiIHJvbGU9XCJidXR0b25cIiBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zZXRUZW1wQ3NzVG9OdWxsQ2xpY2tIYW5kbGVyfT5udWxsPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImZcIiByb2xlPVwiYnV0dG9uXCIgb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2V0VGVtcENzc1RvQXV0b0NsaWNrSGFuZGxlcn0+YXV0bzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAge3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5sYXN0VXNlZFRlbXBDc3NWYWx1ZSAhPT0gXCJcIiA/IDxidXR0b24ga2V5PVwiZ1wiIHJvbGU9XCJidXR0b25cIiBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zZXRUZW1wQ3NzQXBwZW5kTGFzdFVzZWRDbGlja0hhbmRsZXJ9Pit7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmxhc3RVc2VkVGVtcENzc1ZhbHVlLmxlbmd0aCA+IDEwID8gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmxhc3RVc2VkVGVtcENzc1ZhbHVlLnN1YnN0cmluZygwLCAxMCkgKyBcIi4uLlwiIDogdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmxhc3RVc2VkVGVtcENzc1ZhbHVlfTwvYnV0dG9uPiA6IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2hvd1N1Z2dlc3RlZENzc1ZhbHVlc0NsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5kaXNwbGF5UG9wdXAoZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgUG9wdXBNb2RlLlN1Z2dlc3RlZENzc1ZhbHVlcyk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzZXRUZW1wQ3NzVG9aZXJvQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzVmFsdWUgPSBcIjBcIjtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNldFRlbXBDc3NUb051bGxDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDc3NWYWx1ZSA9IFwibnVsbFwiO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2V0VGVtcENzc1RvTm9uZUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1ZhbHVlID0gXCJub25lXCI7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzZXRUZW1wQ3NzVG9BdXRvQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzVmFsdWUgPSBcImF1dG9cIjtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNldFRlbXBDc3NBcHBlbmRMYXN0VXNlZENsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1ZhbHVlID0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDc3NWYWx1ZSArIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5sYXN0VXNlZFRlbXBDc3NWYWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlbmRlclVwZGF0ZUNzc1F1YW50dW1Qb3B1cCA9ICgpOiBWTm9kZSA9PiB7XHJcbiAgICAgICAgbGV0IGlzUG9wdXBWaXNpYmxlOiBib29sZWFuID0gdGhpcy52aWV3TW9kZWwuY3VycmVudFBvcHVwTW9kZSA9PT0gUG9wdXBNb2RlLlVwZGF0ZUNzc1F1YW50dW07XHJcbiAgICAgICAgcmV0dXJuIDxkaXYgaWQ9e2Ake3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXh9UG9wdXBNb2RlJHtQb3B1cE1vZGVbUG9wdXBNb2RlLlVwZGF0ZUNzc1F1YW50dW1dfWB9IHN0eWxlcz17eyBcImRpc3BsYXlcIjogaXNQb3B1cFZpc2libGUgPyBcImJsb2NrXCIgOiBcIm5vbmVcIiwgXCJ6LWluZGV4XCIgOiBcIjMxXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsIFwiYm9yZGVyXCI6IFwic29saWQgYmxhY2sgMXB4XCIgfX0+XHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGVzPXt7IFwiZGlzcGxheVwiOiBcImZsZXhcIiwgXCJmbGV4LWZsb3dcIjogXCJyb3cgbm93cmFwXCIsIFwibWluLXdpZHRoXCI6IFwiMjUwcHhcIiB9fT5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMSAwIDEwJVwiLCBcIndpZHRoXCI6IFwiMTAlXCIsIFwibWluLXdpZHRoXCI6IFwiMTAlXCIgfX0gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2F2ZVVwZGF0ZWRDc3NRdWFudHVtQ2xpY2tIYW5kbGVyfT4mIzEwMDA0OzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJiXCIgcm9sZT1cImJ1dHRvblwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIxIDAgMTAlXCIsIFwid2lkdGhcIjogXCIxMCVcIiwgXCJtaW4td2lkdGhcIjogXCIxMCVcIiB9fSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jYW5jZWxVcGRhdGVDc3NRdWFudHVtQ2xpY2tIYW5kbGVyfT54PC9idXR0b24+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPGlucHV0IGtleT1cIi0xXCJcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDc3NWYWx1ZX1cclxuICAgICAgICAgICAgICAgICAgICBvbmlucHV0PXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jc3NWYWx1ZUlucHV0SGFuZGxlcn0+XHJcbiAgICAgICAgICAgICAgICA8L2lucHV0PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj4gYXMgVk5vZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzaG93TWF0Y2hpbmdRdWFudHVtc0NsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5kaXNwbGF5UG9wdXAoZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgUG9wdXBNb2RlLk1hdGNoaW5nUXVhbnR1bXMpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2F2ZVVwZGF0ZWRDc3NRdWFudHVtQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5VcGRhdGVTdHlsZVF1YW50dW1Kc29uKHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFN0eWxlUXVhbnR1bUlkLCB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1ZhbHVlKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmxhc3RVc2VkVGVtcENzc1ZhbHVlID0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDc3NWYWx1ZTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZXNldFRlbXBDc3NQcm9wZXJ0eVN0YXRlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjYW5jZWxVcGRhdGVDc3NRdWFudHVtQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnJlc2V0VGVtcENzc1Byb3BlcnR5U3RhdGUoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNhdmVVcGRhdGVkQ3NzVmFsdWVGcm9tQXR0ckNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1ZhbHVlID0gcGFyc2VTdHJpbmdGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwiZmlkXCIpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnNhdmVVcGRhdGVkQ3NzVmFsdWUoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNhdmVVcGRhdGVkQ3NzVmFsdWVDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2F2ZVVwZGF0ZWRDc3NWYWx1ZSgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2F2ZVVwZGF0ZWRDc3NWYWx1ZSA9ICgpID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuVXBkYXRlU3R5bGVWYWx1ZUpzb24odGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkU3R5bGVWYWx1ZUlkLCB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1ZhbHVlKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmxhc3RVc2VkVGVtcENzc1ZhbHVlID0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDc3NWYWx1ZTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZXNldFRlbXBDc3NQcm9wZXJ0eVN0YXRlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjYW5jZWxVcGRhdGVDc3NWYWx1ZUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5yZXNldFRlbXBDc3NQcm9wZXJ0eVN0YXRlKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjc3NWYWx1ZUlucHV0SGFuZGxlciA9IChldnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1ZhbHVlID0gKGV2dC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjc3NWYWx1ZUZvckludGVyYWN0aW9uSW5wdXRIYW5kbGVyID0gKGV2dDogS2V5Ym9hcmRFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzVmFsdWVGb3JJbnRlcmFjdGlvbiA9IChldnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyU2VsZWN0SW50ZXJhY3Rpb25UYXJnZXRQb3B1cCA9ICgpOiBWTm9kZSA9PiB7XHJcbiAgICAgICAgbGV0IGlzUG9wdXBWaXNpYmxlOiBib29sZWFuID0gdGhpcy52aWV3TW9kZWwuY3VycmVudFBvcHVwTW9kZSA9PT0gUG9wdXBNb2RlLlNlbGVjdEludGVyYWN0aW9uVGFyZ2V0O1xyXG4gICAgICAgIGxldCByZW5kZXJlZE9wdGlvbnM6IFZOb2RlW10gPSBbXTtcclxuICAgICAgICBpZiAoaXNQb3B1cFZpc2libGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkxheW91dE1vbGVjdWxlcy5tYXAobSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbGF5b3V0QmFzZUlkU3RyaW5nOiBzdHJpbmcgPSBtLkxheW91dEJhc2VJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZWRPcHRpb25zLnB1c2goPGRpdiBrZXk9e2xheW91dEJhc2VJZFN0cmluZ30gc3R5bGVzPXt7IFwiZmxleFwiOiBcIjAgMCAxMDAlXCIsIFwid2lkdGhcIjogXCIxMDAlXCIsIFwibWluLXdpZHRoXCI6IFwiMTAwJVwiIH19PlxyXG4gICAgICAgICAgICAgICAgICAgIGxheW91dCAje2xheW91dEJhc2VJZFN0cmluZ30gPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIGJpZD17bGF5b3V0QmFzZUlkU3RyaW5nfSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zZWxlY3RMYXlvdXRCYXNlRm9ySW50ZXJhY3Rpb25UYXJnZXRDbGlja0hhbmRsZXJ9PiYjMTAwMDQ7PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj4gYXMgVk5vZGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDxkaXYgaWQ9e2Ake3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXh9UG9wdXBNb2RlJHtQb3B1cE1vZGVbUG9wdXBNb2RlLlNlbGVjdEludGVyYWN0aW9uVGFyZ2V0XX1gfSBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IGlzUG9wdXBWaXNpYmxlID8gXCJibG9ja1wiIDogXCJub25lXCIsIFwiei1pbmRleFwiIDogXCIzMVwiLCBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLCBcImJvcmRlclwiOiBcInNvbGlkIGJsYWNrIDFweFwiIH19PlxyXG4gICAgICAgICAgICA8ZGl2IGtleT1cIjBcIiBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IFwiZmxleFwiLCBcImZsZXgtZmxvd1wiOiBcInJvdyBub3dyYXBcIiwgXCJtaW4td2lkdGhcIjogXCIyNTBweFwiIH19PlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIxIDAgMTAlXCIsIFwid2lkdGhcIjogXCIxMCVcIiwgXCJtaW4td2lkdGhcIjogXCIxMCVcIiB9fSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jYW5jZWxTZWxlY3RJbnRlcmFjdGlvblRhcmdldENsaWNrSGFuZGxlcn0+eDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBrZXk9XCIxXCIgc3R5bGVzPXt7IFwiZGlzcGxheVwiOiBcImZsZXhcIiwgXCJmbGV4LWZsb3dcIjogXCJyb3cgd3JhcFwiIH19PlxyXG4gICAgICAgICAgICAgICAge3JlbmRlcmVkT3B0aW9uc31cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyRWRpdFVzZXJEZWZpbmVkQ3NzUG9wdXAgPSAoKTogVk5vZGUgPT4ge1xyXG4gICAgICAgIC8vIFRPRE8gcHJldmVudCBjbG9zaW5nIHBvcHVwIGJlZm9yZSB1c2VyIGRpc2NhcmRlZC9jb25maXJtZWQgY2hhbmdlc1xyXG4gICAgICAgIGxldCBpc1BvcHVwVmlzaWJsZTogYm9vbGVhbiA9IHRoaXMudmlld01vZGVsLmN1cnJlbnRQb3B1cE1vZGUgPT09IFBvcHVwTW9kZS5FZGl0VXNlckRlZmluZWRDc3M7XHJcbiAgICAgICAgcmV0dXJuIDxkaXYgaWQ9e2Ake3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXh9UG9wdXBNb2RlJHtQb3B1cE1vZGVbUG9wdXBNb2RlLkVkaXRVc2VyRGVmaW5lZENzc119YH0gc3R5bGVzPXt7IFwiZGlzcGxheVwiOiBpc1BvcHVwVmlzaWJsZSA/IFwiYmxvY2tcIiA6IFwibm9uZVwiLCBcInotaW5kZXhcIjogXCIzMVwiLCBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLCBcImJvcmRlclwiOiBcInNvbGlkIGJsYWNrIDFweFwiIH19PlxyXG4gICAgICAgICAgICA8ZGl2IGtleT1cIjBcIiBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IFwiZmxleFwiLCBcImZsZXgtZmxvd1wiOiBcInJvdyBub3dyYXBcIiwgXCJtaW4td2lkdGhcIjogXCIyNTBweFwiIH19PlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIxIDAgMTAlXCIsIFwid2lkdGhcIjogXCIxMCVcIiwgXCJtaW4td2lkdGhcIjogXCIxMCVcIiB9fSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jb25maXJtRWRpdFVzZXJEZWZpbmVkQ3NzQ2xpY2tIYW5kbGVyfT4mIzEwMDA0OzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJiXCIgcm9sZT1cImJ1dHRvblwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIxIDAgMTAlXCIsIFwid2lkdGhcIjogXCIxMCVcIiwgXCJtaW4td2lkdGhcIjogXCIxMCVcIiB9fSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jYW5jZWxFZGl0VXNlckRlZmluZWRDc3NDbGlja0hhbmRsZXJ9Png8L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYga2V5PVwiMVwiPlxyXG4gICAgICAgICAgICAgICAgPHRleHRhcmVhXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wVXNlckRlZmluZWRDc3N9XHJcbiAgICAgICAgICAgICAgICAgICAgb25pbnB1dD17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIudXNlckRlZmluZWRDc3NJbnB1dEhhbmRsZXJ9PlxyXG4gICAgICAgICAgICAgICAgPC90ZXh0YXJlYT5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIHVzZXJEZWZpbmVkQ3NzSW5wdXRIYW5kbGVyID0gKGV2dDogS2V5Ym9hcmRFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wVXNlckRlZmluZWRDc3MgPSAoZXZ0LnRhcmdldCBhcyBIVE1MVGV4dEFyZWFFbGVtZW50KS52YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHVwZGF0ZVVzZXJEZWZpbmVkQ3NzID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcFVzZXJEZWZpbmVkQ3NzICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLlVwZGF0ZVVzZXJEZWZpbmVkQ3NzRm9yVmlld0pzb24oY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZENhbGlmb3JuaWFWaWV3SWQsIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wVXNlckRlZmluZWRDc3MpLmRvbmUoZGF0YSA9PiBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2FuY2VsRWRpdFVzZXJEZWZpbmVkQ3NzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY2FuY2VsRWRpdFVzZXJEZWZpbmVkQ3NzQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmNhbmNlbEVkaXRVc2VyRGVmaW5lZENzcygpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY29uZmlybUVkaXRVc2VyRGVmaW5lZENzc0NsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci51cGRhdGVVc2VyRGVmaW5lZENzcygpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY2FuY2VsRWRpdFVzZXJEZWZpbmVkQ3NzID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wVXNlckRlZmluZWRDc3MgPSBcIlwiO1xyXG4gICAgICAgIGN1cnJlbnRBcHAuc3RhdGUucHJlc2VsZWN0ZWRDYWxpZm9ybmlhVmlld0lkID0gMDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jbG9zZVBvcHVwKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzZWxlY3RMYXlvdXRCYXNlRm9ySW50ZXJhY3Rpb25UYXJnZXRDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkTGF5b3V0QmFzZUlkRm9yRmlsdGVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwiYmlkXCIpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmRpc3BsYXlQb3B1cChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCBQb3B1cE1vZGUuU2VsZWN0SW50ZXJhY3Rpb25UYXJnZXRMYXlvdXRGaWx0ZXIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY2FuY2VsU2VsZWN0SW50ZXJhY3Rpb25UYXJnZXRDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2xvc2VQb3B1cCgpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZExheW91dEJhc2VJZEZvckZpbHRlciA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkTGF5b3V0U3R5bGVJbnRlcmFjdGlvbiA9IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJTZWxlY3RJbnRlcmFjdGlvblRhcmdldExheW91dEZpbHRlclBvcHVwID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICBsZXQgaXNQb3B1cFZpc2libGU6IGJvb2xlYW4gPSB0aGlzLnZpZXdNb2RlbC5jdXJyZW50UG9wdXBNb2RlID09PSBQb3B1cE1vZGUuU2VsZWN0SW50ZXJhY3Rpb25UYXJnZXRMYXlvdXRGaWx0ZXI7XHJcbiAgICAgICAgbGV0IHJlbmRlcmVkT3B0aW9uczogVk5vZGVbXSA9IFtdO1xyXG4gICAgICAgIGlmIChpc1BvcHVwVmlzaWJsZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVWYWx1ZXMubWFwKHYgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlQXRvbTogU3R5bGVBdG9tID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlQXRvbXMuZmluZChhID0+IGEuQXBwbGllZFZhbHVlcy5maW5kSW5kZXgobWFwID0+IG1hcC5TdHlsZVZhbHVlSWQgPT0gdi5TdHlsZVZhbHVlSWQpICE9IC0xKSBhcyBTdHlsZUF0b207IC8vIFRPRE8gZXhwZW5zaXZlXHJcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVNb2xlY3VsZTogU3R5bGVNb2xlY3VsZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcy5maW5kKG0gPT4gbS5NYXBwZWRTdHlsZUF0b21zLmZpbmRJbmRleChtYXAgPT4gbWFwLlN0eWxlTW9sZWN1bGVBdG9tTWFwcGluZ0lkID09IHN0eWxlQXRvbS5NYXBwZWRUb01vbGVjdWxlSWQpICE9IC0xKSBhcyBTdHlsZU1vbGVjdWxlOyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlTW9sZWN1bGUuU3R5bGVGb3JMYXlvdXRJZCA9PSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRMYXlvdXRCYXNlSWRGb3JGaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3R5bGVWYWx1ZUlkU3RyaW5nOiBzdHJpbmcgPSB2LlN0eWxlVmFsdWVJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkT3B0aW9ucy5wdXNoKDxkaXYga2V5PXtzdHlsZVZhbHVlSWRTdHJpbmd9IHN0eWxlcz17eyBcImZsZXhcIjogXCIwIDAgMTAwJVwiLCBcIndpZHRoXCI6IFwiMTAwJVwiLCBcIm1pbi13aWR0aFwiOiBcIjEwMCVcIiB9fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgI3tzdHlsZVZhbHVlSWRTdHJpbmd9OiB7di5Dc3NQcm9wZXJ0eX06e3YuQ3NzVmFsdWV9IDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiB2aWQ9e3N0eWxlVmFsdWVJZFN0cmluZ30gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2VsZWN0U3R5bGVWYWx1ZUZvckludGVyYWN0aW9uVGFyZ2V0Q2xpY2tIYW5kbGVyfT4mIzEwMDA0OzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PiBhcyBWTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gPGRpdiBpZD17YCR7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucHJvcGVydHlCYXJJbmRleH1Qb3B1cE1vZGUke1BvcHVwTW9kZVtQb3B1cE1vZGUuU2VsZWN0SW50ZXJhY3Rpb25UYXJnZXRMYXlvdXRGaWx0ZXJdfWB9IHN0eWxlcz17eyBcImRpc3BsYXlcIjogaXNQb3B1cFZpc2libGUgPyBcImJsb2NrXCIgOiBcIm5vbmVcIiwgXCJ6LWluZGV4XCIgOiBcIjMxXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsIFwiYm9yZGVyXCI6IFwic29saWQgYmxhY2sgMXB4XCIgfX0+XHJcbiAgICAgICAgICAgIDxkaXYga2V5PVwiMFwiIHN0eWxlcz17eyBcImRpc3BsYXlcIjogXCJmbGV4XCIsIFwiZmxleC1mbG93XCI6IFwicm93IG5vd3JhcFwiLCBcIm1pbi13aWR0aFwiOiBcIjI1MHB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgc3R5bGVzPXt7IFwiZmxleFwiOiBcIjEgMCAxMCVcIiwgXCJ3aWR0aFwiOiBcIjEwJVwiLCBcIm1pbi13aWR0aFwiOiBcIjEwJVwiIH19IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmNhbmNlbFNlbGVjdFN0eWxlVmFsdWVGb3JJbnRlcmFjdGlvblRhcmdldENsaWNrSGFuZGxlcn0+eDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBrZXk9XCIxXCIgc3R5bGVzPXt7IFwiZGlzcGxheVwiOiBcImZsZXhcIiwgXCJmbGV4LWZsb3dcIjogXCJyb3cgd3JhcFwiIH19PlxyXG4gICAgICAgICAgICAgICAge3JlbmRlcmVkT3B0aW9uc31cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2VsZWN0U3R5bGVWYWx1ZUZvckludGVyYWN0aW9uVGFyZ2V0Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmNsb3NlUG9wdXAoKTtcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuQ3JlYXRlU3R5bGVWYWx1ZUludGVyYWN0aW9uSnNvbih0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRMYXlvdXRTdHlsZUludGVyYWN0aW9uLCBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJ2aWRcIiksIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzVmFsdWVGb3JJbnRlcmFjdGlvbikuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY2FuY2VsU2VsZWN0U3R5bGVWYWx1ZUZvckludGVyYWN0aW9uVGFyZ2V0Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmNsb3NlUG9wdXAoKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRMYXlvdXRCYXNlSWRGb3JGaWx0ZXIgPSAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZExheW91dFN0eWxlSW50ZXJhY3Rpb24gPSAwO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyTWF0Y2hpbmdRdWFudHVtc1BvcHVwID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICBsZXQgaXNQb3B1cFZpc2libGU6IGJvb2xlYW4gPSB0aGlzLnZpZXdNb2RlbC5jdXJyZW50UG9wdXBNb2RlID09PSBQb3B1cE1vZGUuTWF0Y2hpbmdRdWFudHVtcztcclxuICAgICAgICBsZXQgcmVuZGVyZWRPcHRpb25zOiBWTm9kZVtdID0gW107XHJcbiAgICAgICAgaWYgKGlzUG9wdXBWaXNpYmxlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZVF1YW50dW1zLm1hcChxdWFudHVtID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBpc01hdGNoaW5nUHJvcGVydHk6IGJvb2xlYW4gPSBxdWFudHVtLkNzc1Byb3BlcnR5ID09PSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1Byb3BlcnR5TmFtZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc01hdGNoaW5nUHJvcGVydHkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZE9wdGlvbnMucHVzaCg8ZGl2IGtleT17cXVhbnR1bS5TdHlsZVF1YW50dW1JZH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtxdWFudHVtLk5hbWV9ID0ge3F1YW50dW0uQ3NzVmFsdWV9IDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiBxaWQ9e3F1YW50dW0uU3R5bGVRdWFudHVtSWQudG9TdHJpbmcoKX0gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2V0UXVhbnR1bU9uQXRvbUNsaWNrSGFuZGxlcn0+JiMxMDAwNDs8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gYXMgVk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHJlbmRlcmVkT3B0aW9ucy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZWRPcHRpb25zLnB1c2goPGRpdiBrZXk9XCIwXCI+Tm8gcXVhbnR1bXMgYXZhaWxhYmxlLjwvZGl2PiBhcyBWTm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDxkaXYgaWQ9e2Ake3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXh9UG9wdXBNb2RlJHtQb3B1cE1vZGVbUG9wdXBNb2RlLk1hdGNoaW5nUXVhbnR1bXNdfWB9IHN0eWxlcz17eyBcImRpc3BsYXlcIjogaXNQb3B1cFZpc2libGUgPyBcImJsb2NrXCIgOiBcIm5vbmVcIiwgXCJ6LWluZGV4XCIgOiBcIjMxXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsIFwiYm9yZGVyXCI6IFwic29saWQgYmxhY2sgMXB4XCIsIFwiaGVpZ2h0XCI6IFwiMzAwcHhcIiwgXCJvdmVyZmxvd1wiOiBcInNjcm9sbFwiIH19PlxyXG4gICAgICAgICAgICA8ZGl2IHN0eWxlcz17eyBcImRpc3BsYXlcIjogXCJmbGV4XCIsIFwiZmxleC1mbG93XCI6IFwicm93IG5vd3JhcFwiLCBcIm1pbi13aWR0aFwiOiBcIjI1MHB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgc3R5bGVzPXt7IFwiZmxleFwiOiBcIjEgMCAxMCVcIiwgXCJ3aWR0aFwiOiBcIjEwJVwiLCBcIm1pbi13aWR0aFwiOiBcIjEwJVwiIH19IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmNhbmNlbFNlbGVjdE1hdGNoaW5nQ3NzUXVhbnR1bUNsaWNrSGFuZGxlcn0+eDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAge3JlbmRlcmVkT3B0aW9uc31cclxuICAgICAgICA8L2Rpdj4gYXMgVk5vZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjYW5jZWxTZWxlY3RNYXRjaGluZ0Nzc1F1YW50dW1DbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgdGhpcy52aWV3TW9kZWwuY3VycmVudFBvcHVwTW9kZSA9IFBvcHVwTW9kZS5VcGRhdGVDc3NWYWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHJlbmRlclN1Z2dlc3RlZENzc1ZhbHVlc1BvcHVwID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICBsZXQgaXNQb3B1cFZpc2libGU6IGJvb2xlYW4gPSB0aGlzLnZpZXdNb2RlbC5jdXJyZW50UG9wdXBNb2RlID09PSBQb3B1cE1vZGUuU3VnZ2VzdGVkQ3NzVmFsdWVzO1xyXG4gICAgICAgIGxldCByZW5kZXJlZE9wdGlvbnM6IFZOb2RlW10gPSBbXTtcclxuICAgICAgICBpZiAoaXNQb3B1cFZpc2libGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzUHJvcGVydHlOYW1lID09PSBcImZvbnQtZmFtaWx5XCIpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5UaGlyZFBhcnR5Rm9udHMubWFwKChmYW1pbHk6IHN0cmluZywgaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkT3B0aW9ucy5wdXNoKDxkaXYga2V5PXtpbmRleH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEdvb2dsZSBGb250OiB7ZmFtaWx5fSA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgZmlkPXtmYW1pbHl9IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnNhdmVVcGRhdGVkQ3NzVmFsdWVGcm9tQXR0ckNsaWNrSGFuZGxlcn0+JiMxMDAwNDs8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj4gYXMgVk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJlbmRlcmVkT3B0aW9ucy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZWRPcHRpb25zLnB1c2goPGRpdiBrZXk9XCIwXCI+Tm8gc3VnZ2VzdGlvbnMgYXZhaWxhYmxlLjwvZGl2PiBhcyBWTm9kZSk7IC8vIFRPRE8gZGlzYWJsZSBwb3B1cCBidXR0b24gd2hlbiBubyBzdWdnZXN0aW9ucyBhdmFpbGFibGUgZm9yIHByb3BlcnR5XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDxkaXYgaWQ9e2Ake3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXh9UG9wdXBNb2RlJHtQb3B1cE1vZGVbUG9wdXBNb2RlLlN1Z2dlc3RlZENzc1ZhbHVlc119YH0gc3R5bGVzPXt7IFwiZGlzcGxheVwiOiBpc1BvcHVwVmlzaWJsZSA/IFwiYmxvY2tcIiA6IFwibm9uZVwiLCBcInotaW5kZXhcIjogXCIzMVwiLCBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLCBcImJvcmRlclwiOiBcInNvbGlkIGJsYWNrIDFweFwiLCBcImhlaWdodFwiOiBcIjMwMHB4XCIsIFwib3ZlcmZsb3dcIjogXCJzY3JvbGxcIiB9fT5cclxuICAgICAgICAgICAgPGRpdiBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IFwiZmxleFwiLCBcImZsZXgtZmxvd1wiOiBcInJvdyBub3dyYXBcIiwgXCJtaW4td2lkdGhcIjogXCIyNTBweFwiIH19PlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIxIDAgMTAlXCIsIFwid2lkdGhcIjogXCIxMCVcIiwgXCJtaW4td2lkdGhcIjogXCIxMCVcIiB9fSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jYW5jZWxTdWdnZXN0ZWRDc3NWYWx1ZXNDbGlja0hhbmRsZXJ9Png8L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIHtyZW5kZXJlZE9wdGlvbnN9XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcHVibGljIGNhbmNlbFN1Z2dlc3RlZENzc1ZhbHVlc0NsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jbG9zZVBvcHVwKCk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBwdWJsaWMgc2V0UXVhbnR1bU9uQXRvbUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgcXVhbnR1bUlkOiBudW1iZXIgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJxaWRcIik7XHJcbiAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLkFwcGx5U3R5bGVRdWFudHVtVG9BdG9tSnNvbih0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZUF0b21JZCwgcXVhbnR1bUlkKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIucmVzZXRUZW1wQ3NzUHJvcGVydHlTdGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5sYXN0VXNlZFRlbXBDc3NWYWx1ZSA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVRdWFudHVtcy5maW5kKHEgPT4gcS5TdHlsZVF1YW50dW1JZCA9PSBxdWFudHVtSWQpIGFzIFN0eWxlUXVhbnR1bSkuQ3NzVmFsdWU7IC8vIFRPRE8gZXhwZW5zaXZlXHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJTdHlsZU1vbGVjdWxlQXJyYXkgPSAocHJvcGVydHlCYXI6IFByb3BlcnR5QmFyKTogbWFxdWV0dGUuTWFwcGluZzxTdHlsZU1vbGVjdWxlLCB7IHJlbmRlck1hcXVldHRlOiAoKSA9PiBtYXF1ZXR0ZS5WTm9kZSB9PiA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG1hcXVldHRlLmNyZWF0ZU1hcHBpbmc8U3R5bGVNb2xlY3VsZSwgYW55PihcclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U2VjdGlvblNvdXJjZUtleShzb3VyY2U6IFN0eWxlTW9sZWN1bGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2UuU3R5bGVNb2xlY3VsZUlkO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBjcmVhdGVTZWN0aW9uVGFyZ2V0KHNvdXJjZTogU3R5bGVNb2xlY3VsZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZVN0eWxlTW9sZWN1bGVJZFN0cmluZyA9IHNvdXJjZS5TdHlsZU1vbGVjdWxlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyTWFxdWV0dGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYga2V5PXtzb3VyY2VTdHlsZU1vbGVjdWxlSWRTdHJpbmd9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGl0QW5pbWF0aW9uPXtwcm9wZXJ0eUJhci5zdHlsZUVsZW1lbnRFeGl0QW5pbWF0aW9ufT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwPigje3NvdXJjZVN0eWxlTW9sZWN1bGVJZFN0cmluZ30pe3NvdXJjZS5OYW1lfTwvcD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiBtaWQ9e3NvdXJjZVN0eWxlTW9sZWN1bGVJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuc2VsZWN0U3R5bGVNb2xlY3VsZUNsaWNrSGFuZGxlcn0+RWRpdDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj47XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICh1cGRhdGVkU291cmNlOiBTdHlsZU1vbGVjdWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVN0eWxlTW9sZWN1bGVJZFN0cmluZyA9IHVwZGF0ZWRTb3VyY2UuU3R5bGVNb2xlY3VsZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHVwZGF0ZWRTb3VyY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlU2VjdGlvblRhcmdldCh1cGRhdGVkU291cmNlOiBTdHlsZU1vbGVjdWxlLCB0YXJnZXQ6IHsgcmVuZGVyTWFxdWV0dGUoKTogYW55LCB1cGRhdGUodXBkYXRlZFNvdXJjZTogU3R5bGVNb2xlY3VsZSk6IHZvaWQgfSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnVwZGF0ZSh1cGRhdGVkU291cmNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzZWxlY3RTdHlsZU1vbGVjdWxlQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMubmV4dEV4Y2VwdExhc3RQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZU1vbGVjdWxlSWQgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJtaWRcIik7XHJcbiAgICAgICAgdGhpcy5uZXh0RXhjZXB0TGFzdFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZFN0YXRlTW9kaWZpZXIgPSBcIlwiOyAvLyBUT0RPIHJlc2V0IHN0YXRlIG9ubHkgd2hlbiBub3QgYXZhaWxhYmxlIGluIG5ldyBzZWxlY3RlZCBtb2xlY3VsZVxyXG4gICAgICAgIHRoaXMubmV4dEV4Y2VwdExhc3RQcm9wZXJ0eUJhci52aWV3TW9kZWwuY3VycmVudFByb3BlcnR5QmFyTW9kZSA9IFByb3BlcnR5QmFyTW9kZS5TdHlsZU1vbGVjdWxlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2hvd0VkaXRVc2VyRGVmaW5lZENzc0NsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgY2FsaWZvcm5pYVZpZXdJZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwidmlkXCIpO1xyXG4gICAgICAgIGxldCBjYWxpZm9ybmlhVmlld0Nzczogc3RyaW5nIHwgdW5kZWZpbmVkID0gKGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5DYWxpZm9ybmlhVmlld3MuZmluZCh2ID0+IHYuQ2FsaWZvcm5pYVZpZXdJZCA9PSBjYWxpZm9ybmlhVmlld0lkKSBhcyBDYWxpZm9ybmlhVmlldykuVXNlckRlZmluZWRDc3M7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBVc2VyRGVmaW5lZENzcyA9IGNhbGlmb3JuaWFWaWV3Q3NzICE9PSB1bmRlZmluZWQgPyBjYWxpZm9ybmlhVmlld0NzcyA6IFwiXCI7XHJcbiAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZENhbGlmb3JuaWFWaWV3SWQgPSBjYWxpZm9ybmlhVmlld0lkO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmRpc3BsYXlQb3B1cChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCBQb3B1cE1vZGUuRWRpdFVzZXJEZWZpbmVkQ3NzKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGhpZ2hsaWdodExheW91dEJhc2VDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IHRhcmdldExheW91dEJhc2VJZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibGlkXCIpO1xyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLmhpZ2hsaWdodGVkTGF5b3V0QmFzZUlkICE9IHRhcmdldExheW91dEJhc2VJZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmhpZ2hsaWdodGVkTGF5b3V0QmFzZUlkID0gdGFyZ2V0TGF5b3V0QmFzZUlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5oaWdobGlnaHRlZExheW91dEJhc2VJZCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyU3R5bGVRdWFudHVtQXJyYXkgPSAocHJvcGVydHlCYXI6IFByb3BlcnR5QmFyKTogbWFxdWV0dGUuTWFwcGluZzxTdHlsZVF1YW50dW0sIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+ID0+IHtcclxuICAgICAgICByZXR1cm4gbWFxdWV0dGUuY3JlYXRlTWFwcGluZzxTdHlsZVF1YW50dW0sIGFueT4oXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFNlY3Rpb25Tb3VyY2VLZXkoc291cmNlOiBTdHlsZVF1YW50dW0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2UuU3R5bGVRdWFudHVtSWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb25UYXJnZXQoc291cmNlOiBTdHlsZVF1YW50dW0pIHtcclxuICAgICAgICAgICAgICAgIGxldCBzb3VyY2VJZFN0cmluZyA9IHNvdXJjZS5TdHlsZVF1YW50dW1JZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJNYXF1ZXR0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPGRpdiBrZXk9e3NvdXJjZUlkU3RyaW5nfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpdEFuaW1hdGlvbj17cHJvcGVydHlCYXIuc3R5bGVFbGVtZW50RXhpdEFuaW1hdGlvbn0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBrZXk9XCIwXCIgc3R5bGVzPXt7XCJtYXJnaW5cIjpcIjBcIn19Pigje3NvdXJjZUlkU3RyaW5nfSl7c291cmNlLk5hbWV9OiB7c291cmNlLkNzc1Byb3BlcnR5fSA9PiB7c291cmNlLkNzc1ZhbHVlfTwvcD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiBxaWQ9e3NvdXJjZUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5kdXBsaWNhdGVTdHlsZVF1YW50dW1DbGlja0hhbmRsZXJ9PkREPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c291cmNlLklzRGVsZXRhYmxlID8gPGJ1dHRvbiBrZXk9XCJiMFwiIHJvbGU9XCJidXR0b25cIiBxaWQ9e3NvdXJjZUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5kZWxldGVTdHlsZVF1YW50dW1DbGlja0hhbmRsZXJ9Plg8L2J1dHRvbj4gOiA8YnV0dG9uIGRpc2FibGVkIGtleT1cImIxXCIgcm9sZT1cImJ1dHRvblwiPlg8L2J1dHRvbj59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImNcIiByb2xlPVwiYnV0dG9uXCIgcWlkPXtzb3VyY2VJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIudXBkYXRlQ3NzUXVhbnR1bUNsaWNrSGFuZGxlcn0+RWRpdDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj47XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICh1cGRhdGVkU291cmNlOiBTdHlsZVF1YW50dW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlSWRTdHJpbmcgPSB1cGRhdGVkU291cmNlLlN0eWxlUXVhbnR1bUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHVwZGF0ZWRTb3VyY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlU2VjdGlvblRhcmdldCh1cGRhdGVkU291cmNlOiBTdHlsZVF1YW50dW0sIHRhcmdldDogeyByZW5kZXJNYXF1ZXR0ZSgpOiBhbnksIHVwZGF0ZSh1cGRhdGVkU291cmNlOiBTdHlsZVF1YW50dW0pOiB2b2lkIH0pIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC51cGRhdGUodXBkYXRlZFNvdXJjZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgdXBkYXRlQ3NzUXVhbnR1bUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgc3R5bGVRdWFudHVtSWQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcInFpZFwiKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRTdHlsZVF1YW50dW1JZCA9IHN0eWxlUXVhbnR1bUlkO1xyXG4gICAgICAgIGxldCB0YXJnZXRTdHlsZVF1YW50dW06IFN0eWxlUXVhbnR1bSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZVF1YW50dW1zLmZpbmQodmFsID0+IHZhbC5TdHlsZVF1YW50dW1JZCA9PSBzdHlsZVF1YW50dW1JZCkgYXMgU3R5bGVRdWFudHVtO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzVmFsdWUgPSB0YXJnZXRTdHlsZVF1YW50dW0uQ3NzVmFsdWU7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZGlzcGxheVBvcHVwKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsIFBvcHVwTW9kZS5VcGRhdGVDc3NRdWFudHVtKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGRlbGV0ZVN0eWxlUXVhbnR1bUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuRGVsZXRlU3R5bGVRdWFudHVtSnNvbihwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJxaWRcIikpLmRvbmUoZGF0YSA9PiBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGR1cGxpY2F0ZVN0eWxlUXVhbnR1bUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuRHVwbGljYXRlU3R5bGVRdWFudHVtSnNvbihwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJxaWRcIikpLmRvbmUoZGF0YSA9PiBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHN0eWxlRWxlbWVudEV4aXRBbmltYXRpb24gPSAoZG9tTm9kZTogSFRNTEVsZW1lbnQsIHJlbW92ZUVsZW1lbnQ6ICgpID0+IHZvaWQsIHByb3BlcnRpZXM/OiBtYXF1ZXR0ZS5WTm9kZVByb3BlcnRpZXMpID0+IHtcclxuICAgICAgICBkb21Ob2RlLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcclxuICAgICAgICB2ZWxvY2l0eS5hbmltYXRlKGRvbU5vZGUsIHsgb3BhY2l0eTogMC41LCBoZWlnaHQ6IDAgfSwgeyBkdXJhdGlvbjogMTAwLCBlYXNpbmc6IFwiZWFzZS1vdXRcIiwgY29tcGxldGU6IHJlbW92ZUVsZW1lbnQgfSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBwdWJsaWMgcmVuZGVyTGF5b3V0TW9sZWN1bGVBcnJheSA9IChwcm9wZXJ0eUJhcjogUHJvcGVydHlCYXIpOiBtYXF1ZXR0ZS5NYXBwaW5nPExheW91dEJhc2UsIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+ID0+IHtcclxuICAgICAgICByZXR1cm4gbWFxdWV0dGUuY3JlYXRlTWFwcGluZzxMYXlvdXRCYXNlLCBhbnk+KFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRTZWN0aW9uU291cmNlS2V5KHNvdXJjZTogTGF5b3V0QmFzZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEga2V5IHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGVhY2ggaXRlbSBpbiB0aGUgZGF0YVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5MYXlvdXRCYXNlSWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb25UYXJnZXQoc291cmNlOiBMYXlvdXRCYXNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIHRhcmdldCBiYXNlZCBvbiB0aGUgc291cmNlIFxyXG4gICAgICAgICAgICAgICAgLy8gKHRoZSBzYW1lIGZ1bmN0aW9uIHRoYXQgeW91IHVzZSBpbiBBcnJheS5tYXApXHJcbiAgICAgICAgICAgICAgICBsZXQgc291cmNlTGF5b3V0QmFzZUlkU3RyaW5nID0gc291cmNlLkxheW91dEJhc2VJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZVN0eWxlTW9sZWN1bGVJZFN0cmluZyA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChtID0+IG0uU3R5bGVGb3JMYXlvdXRJZCA9PSBzb3VyY2UuTGF5b3V0QmFzZUlkKSBhcyBTdHlsZU1vbGVjdWxlKS5TdHlsZU1vbGVjdWxlSWQudG9TdHJpbmcoKTsgLy8gVE9ETyBleHBlbnNpdmVcclxuICAgICAgICAgICAgICAgIGxldCBsYXlvdXRDb250cm9sQnV0dG9uU3R5bGVzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLXJpZ2h0XCI6IFwiNXB4XCJcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlck1hcXVldHRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZXNjcmlwdGlvbjogc3RyaW5nIHwgdW5kZWZpbmVkID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5MYXlvdXRUeXBlID09PSBMYXlvdXRUeXBlLkF0b20pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzb3VyY2VMYXlvdXRBdG9tOiBMYXlvdXRBdG9tID0gKHNvdXJjZSBhcyBMYXlvdXRBdG9tKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0Q29udGVudFN0cmluZzogc3RyaW5nID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VMYXlvdXRBdG9tLkhvc3RlZENvbnRlbnRBdG9tLkNvbnRlbnRBdG9tVHlwZSA9PT0gQ29udGVudEF0b21UeXBlLlRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Q29udGVudFN0cmluZyA9IHNvdXJjZUxheW91dEF0b20uSG9zdGVkQ29udGVudEF0b20uVGV4dENvbnRlbnQgYXMgc3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc291cmNlTGF5b3V0QXRvbS5Ib3N0ZWRDb250ZW50QXRvbS5Db250ZW50QXRvbVR5cGUgPT09IENvbnRlbnRBdG9tVHlwZS5MaW5rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENvbnRlbnRTdHJpbmcgPSBzb3VyY2VMYXlvdXRBdG9tLkhvc3RlZENvbnRlbnRBdG9tLlVybCBhcyBzdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9IHRleHRDb250ZW50U3RyaW5nLmxlbmd0aCA+IDIwID8gdGV4dENvbnRlbnRTdHJpbmcuc3Vic3RyaW5nKDAsIDIwKSArIFwiLi4uXCIgOiB0ZXh0Q29udGVudFN0cmluZzsgLy8gVE9ETyBleHBlbnNpdmUgLy8gVE9ETyBlbGxpcHNpcyAvLyBUT0RPIG11bHRpcGxlIHBsYWNlcyAvLyBUT0RPIGNyZWF0ZSB3aGVuIHN0b3JpbmcgaW4gREI/IG9yIHdoZW4gbG9hZGluZyBpbiBjbGllbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uICs9IGAgaW4gYm94ICMkeyhzb3VyY2UgYXMgTGF5b3V0QXRvbSkuUGxhY2VkQXRvbUluQm94SWR9YFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gaGlkZSBsYXlvdXQgbW9sZWN1bGVzLCB3aGVyZSBzdHlsZSBtb2xlY3VsZSBpcyBpbnRlcm5hbCBzdHlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPGRpdiBrZXk9e3NvdXJjZUxheW91dEJhc2VJZFN0cmluZ30+IHtMYXlvdXRUeXBlW3NvdXJjZS5MYXlvdXRUeXBlXS50b1N0cmluZygpfSAje3NvdXJjZUxheW91dEJhc2VJZFN0cmluZ30ge2Rlc2NyaXB0aW9ufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIGxpZD17c291cmNlTGF5b3V0QmFzZUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5zZWxlY3RMYXlvdXRCYXNlQ2xpY2tIYW5kbGVyfSBzdHlsZXM9e2xheW91dENvbnRyb2xCdXR0b25TdHlsZXN9Pj88L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYlwiIHJvbGU9XCJidXR0b25cIiBtaWQ9e3NvdXJjZVN0eWxlTW9sZWN1bGVJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuc2VsZWN0U3R5bGVNb2xlY3VsZUNsaWNrSGFuZGxlcn0gc3R5bGVzPXtsYXlvdXRDb250cm9sQnV0dG9uU3R5bGVzfT5TPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImNcIiByb2xlPVwiYnV0dG9uXCIgbGlkPXtzb3VyY2VMYXlvdXRCYXNlSWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLmRlbGV0ZUxheW91dEJhc2VDbGlja0hhbmRsZXJ9IHN0eWxlcz17bGF5b3V0Q29udHJvbEJ1dHRvblN0eWxlc30+WDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj47XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICh1cGRhdGVkU291cmNlOiBMYXlvdXRCYXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHVwZGF0ZWRTb3VyY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUxheW91dEJhc2VJZFN0cmluZyA9IHNvdXJjZS5MYXlvdXRCYXNlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNvdXJjZVN0eWxlTW9sZWN1bGVJZFN0cmluZyA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChtID0+IG0uU3R5bGVGb3JMYXlvdXRJZCA9PSBzb3VyY2UuTGF5b3V0QmFzZUlkKSBhcyBTdHlsZU1vbGVjdWxlKS5TdHlsZU1vbGVjdWxlSWQudG9TdHJpbmcoKTsgLy8gVE9ETyBleHBlbnNpdmVcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVTZWN0aW9uVGFyZ2V0KHVwZGF0ZWRTb3VyY2U6IExheW91dEJhc2UsIHRhcmdldDogeyByZW5kZXJNYXF1ZXR0ZSgpOiBhbnksIHVwZGF0ZSh1cGRhdGVkU291cmNlOiBMYXlvdXRCYXNlKTogdm9pZCB9KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIHVwZGF0ZSB0aGUgY29tcG9uZW50IHdpdGggdGhlIHVwZGF0ZWQgaXRlbVxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnVwZGF0ZSh1cGRhdGVkU291cmNlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJDYWxpZm9ybmlhVmlld0FycmF5ID0gKHByb3BlcnR5QmFyOiBQcm9wZXJ0eUJhcik6IG1hcXVldHRlLk1hcHBpbmc8Q2FsaWZvcm5pYVZpZXcsIHsgcmVuZGVyTWFxdWV0dGU6ICgpID0+IG1hcXVldHRlLlZOb2RlIH0+ID0+IHtcclxuICAgICAgICByZXR1cm4gbWFxdWV0dGUuY3JlYXRlTWFwcGluZzxDYWxpZm9ybmlhVmlldywgYW55PihcclxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0U2VjdGlvblNvdXJjZUtleShzb3VyY2U6IENhbGlmb3JuaWFWaWV3KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBrZXkgdG8gdW5pcXVlbHkgaWRlbnRpZnkgZWFjaCBpdGVtIGluIHRoZSBkYXRhXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlLkNhbGlmb3JuaWFWaWV3SWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNlY3Rpb25UYXJnZXQoc291cmNlOiBDYWxpZm9ybmlhVmlldykge1xyXG4gICAgICAgICAgICAgICAgLy8gZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSB0YXJnZXQgYmFzZWQgb24gdGhlIHNvdXJjZSBcclxuICAgICAgICAgICAgICAgIC8vICh0aGUgc2FtZSBmdW5jdGlvbiB0aGF0IHlvdSB1c2UgaW4gQXJyYXkubWFwKVxyXG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZUNhbGlmb3JuaWFWaWV3SWRTdHJpbmcgPSBzb3VyY2UuQ2FsaWZvcm5pYVZpZXdJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJNYXF1ZXR0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXNEZWxldGVCdXR0b25FbmFibGVkOiBib29sZWFuID0gc291cmNlLlBsYWNlZExheW91dFJvd3MubGVuZ3RoID09IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17c291cmNlQ2FsaWZvcm5pYVZpZXdJZFN0cmluZ30+e3NvdXJjZS5OYW1lfSBWaWV3ICN7c291cmNlQ2FsaWZvcm5pYVZpZXdJZFN0cmluZ31cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiB2aWQ9e3NvdXJjZUNhbGlmb3JuaWFWaWV3SWRTdHJpbmd9IG9uY2xpY2s9e3Byb3BlcnR5QmFyLnNlbGVjdENhbGlmb3JuaWFWaWV3Q2xpY2tIYW5kbGVyfT46KTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyghc291cmNlLklzSW50ZXJuYWwgJiYgc291cmNlLkNhbGlmb3JuaWFWaWV3SWQgIT0gY3VycmVudEFwcC5wYWdlUHJldmlldy52aWV3TW9kZWwuYWN0aXZlQ2FsaWZvcm5pYVZpZXdJZCkgPyA8YnV0dG9uIGtleT1cImJcIiByb2xlPVwiYnV0dG9uXCIgdmlkPXtzb3VyY2VDYWxpZm9ybmlhVmlld0lkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5hY3RpdmF0ZUNhbGlmb3JuaWFWaWV3Q2xpY2tIYW5kbGVyfT4mIzEwMDA0OzwvYnV0dG9uPiA6IHVuZGVmaW5lZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge3NvdXJjZS5Jc0ludGVybmFsID8gXCJpbnRlcm5hbFwiIDogdW5kZWZpbmVkfSB7c291cmNlLk5hbWV9IGhvc3RlZCBieSB7c291cmNlLkhvc3RlZEJ5TGF5b3V0TWFwcGluZ3MubGVuZ3RofSBsYXlvdXRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImNcIiByb2xlPVwiYnV0dG9uXCIgbWlkPXtzb3VyY2UuU3BlY2lhbFN0eWxlVmlld1N0eWxlTW9sZWN1bGVJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuc2VsZWN0U3R5bGVNb2xlY3VsZUNsaWNrSGFuZGxlcn0+c3R5bGUgI3tzb3VyY2UuU3BlY2lhbFN0eWxlVmlld1N0eWxlTW9sZWN1bGVJZFN0cmluZ308L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiZFwiIHJvbGU9XCJidXR0b25cIiBtaWQ9e3NvdXJjZS5TcGVjaWFsU3R5bGVCb2R5U3R5bGVNb2xlY3VsZUlkU3RyaW5nfSBvbmNsaWNrPXtwcm9wZXJ0eUJhci5zZWxlY3RTdHlsZU1vbGVjdWxlQ2xpY2tIYW5kbGVyfT5ib2R5IHN0eWxlICN7c291cmNlLlNwZWNpYWxTdHlsZUJvZHlTdHlsZU1vbGVjdWxlSWRTdHJpbmd9PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImVcIiByb2xlPVwiYnV0dG9uXCIgbWlkPXtzb3VyY2UuU3BlY2lhbFN0eWxlSHRtbFN0eWxlTW9sZWN1bGVJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuc2VsZWN0U3R5bGVNb2xlY3VsZUNsaWNrSGFuZGxlcn0+SFRNTCBzdHlsZSAje3NvdXJjZS5TcGVjaWFsU3R5bGVIdG1sU3R5bGVNb2xlY3VsZUlkU3RyaW5nfTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJmXCIgcm9sZT1cImJ1dHRvblwiIHZpZD17c291cmNlQ2FsaWZvcm5pYVZpZXdJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuc2hvd0VkaXRVc2VyRGVmaW5lZENzc0NsaWNrSGFuZGxlcn0+Q1NTPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aXNEZWxldGVCdXR0b25FbmFibGVkID8gPGJ1dHRvbiBrZXk9XCJnXCIgcm9sZT1cImJ1dHRvblwiIHZpZD17c291cmNlQ2FsaWZvcm5pYVZpZXdJZFN0cmluZ30gb25jbGljaz17cHJvcGVydHlCYXIuZGVsZXRlQ2FsaWZvcm5pYVZpZXdDbGlja0hhbmRsZXJ9Plg8L2J1dHRvbj4gOiA8YnV0dG9uIGRpc2FibGVkIGtleT1cImcwXCIgcm9sZT1cImJ1dHRvblwiIG9uY2xpY2s9e3Byb3BlcnR5QmFyLmRlbGV0ZUNhbGlmb3JuaWFWaWV3Q2xpY2tIYW5kbGVyfT5YPC9idXR0b24+fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj47XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICh1cGRhdGVkU291cmNlOiBDYWxpZm9ybmlhVmlldykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSB1cGRhdGVkU291cmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VDYWxpZm9ybmlhVmlld0lkU3RyaW5nID0gc291cmNlLkNhbGlmb3JuaWFWaWV3SWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVTZWN0aW9uVGFyZ2V0KHVwZGF0ZWRTb3VyY2U6IENhbGlmb3JuaWFWaWV3LCB0YXJnZXQ6IHsgcmVuZGVyTWFxdWV0dGUoKTogYW55LCB1cGRhdGUodXBkYXRlZFNvdXJjZTogQ2FsaWZvcm5pYVZpZXcpOiB2b2lkIH0pIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gdXBkYXRlIHRoZSBjb21wb25lbnQgd2l0aCB0aGUgdXBkYXRlZCBpdGVtXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQudXBkYXRlKHVwZGF0ZWRTb3VyY2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGxvZ291dFBvcHVwQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmRpc3BsYXlQb3B1cChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCBQb3B1cE1vZGUuU2hhcmVDYWxpZm9ybmlhUHJvamVjdCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJTaGFyZUNhbGlmb3JuaWFQcm9qZWN0UG9wdXAgPSAoKTogVk5vZGUgPT4ge1xyXG4gICAgICAgIC8vIFRPRE8gbXVsdGlsYW5ndWFnZSB3aGVyZSB0ZXh0IHN0cmluZ3MgYXJlIGV2ZXJ5d2hlcmVcclxuICAgICAgICBsZXQgaXNQb3B1cFZpc2libGU6IGJvb2xlYW4gPSB0aGlzLnZpZXdNb2RlbC5jdXJyZW50UG9wdXBNb2RlID09PSBQb3B1cE1vZGUuU2hhcmVDYWxpZm9ybmlhUHJvamVjdDsgLy8gVE9ETyBzaG9ydGVuIGlkcyBldmVyeXdoZXJlXHJcbiAgICAgICAgcmV0dXJuIDxkaXYgaWQ9e2Ake3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXh9UG9wdXBNb2RlJHtQb3B1cE1vZGVbUG9wdXBNb2RlLlNoYXJlQ2FsaWZvcm5pYVByb2plY3RdfWB9IHN0eWxlcz17eyBcImRpc3BsYXlcIjogaXNQb3B1cFZpc2libGUgPyBcImJsb2NrXCIgOiBcIm5vbmVcIiwgXCJ6LWluZGV4XCIgOiBcIjMxXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsIFwiYm9yZGVyXCI6IFwic29saWQgYmxhY2sgMXB4XCIgfX0+XHJcbiAgICAgICAgICAgIDxkaXYga2V5PVwiMFwiIHN0eWxlcz17eyBcImRpc3BsYXlcIjogXCJmbGV4XCIsIFwiZmxleC1mbG93XCI6IFwicm93IG5vd3JhcFwiLCBcIm1pbi13aWR0aFwiOiBcIjI1MHB4XCIgfX0+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImJcIiBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMSAwIDEwJVwiLCBcIndpZHRoXCI6IFwiMTAlXCIsIFwibWluLXdpZHRoXCI6IFwiMTAlXCIgfX0gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2FuY2VsU2hhcmVDYWxpZm9ybmlhUHJvamVjdENsaWNrSGFuZGxlcn0+eDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBrZXk9XCIxXCIgc3R5bGVzPXt7IFwiZGlzcGxheVwiOiBcImZsZXhcIiwgXCJmbGV4LWZsb3dcIjogXCJyb3cgd3JhcFwiIH19PlxyXG4gICAgICAgICAgICAgICAgPHAga2V5PVwiYVwiIHN0eWxlcz17eyBcImZsZXhcIjogXCIwIDAgMTAwJVwiLCBcIndpZHRoXCI6IFwiMTAwJVwiLCBcIm1pbi13aWR0aFwiOiBcIjEwMCVcIiB9fT57Y3VycmVudEFwcC5jbGllbnREYXRhLlVybFRvUmVhZE9ubHl9PC9wPlxyXG4gICAgICAgICAgICAgICAgey8qIFRPRE8gPHAga2V5PVwiYlwiPntjdXJyZW50QXBwLmNsaWVudERhdGEuVXJsVG9SZWFkQW5kRWRpdH08L3A+Ki99XHJcbiAgICAgICAgICAgICAgICBCb29rbWFyayEgQ2xlYXIgYnJvd3NlciBoaXN0b3J5IVxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJjXCIgdHlwZT1cImJ1dHRvblwiIG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmxvZ291dENsaWNrSGFuZGxlcn0gc3R5bGVzPXt7IFwiZmxleFwiOiBcIjAgMCAxMCVcIiwgXCJ3aWR0aFwiOiBcIjEwJVwiLCBcIm1pbi13aWR0aFwiOiBcIjEwJVwiIH19PiYjMTI4Mjc0OzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJkXCIgdHlwZT1cImJ1dHRvblwiIG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnRva3lvQ2xpY2tIYW5kbGVyfSBzdHlsZXM9e3sgXCJmbGV4XCI6IFwiMCAwIDEwJVwiLCBcIndpZHRoXCI6IFwiMTAlXCIsIFwibWluLXdpZHRoXCI6IFwiMTAlXCIgfX0+VE9LWU88L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgdG9reW9DbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgXCIvdG9reW8vXCIpOyAvLyBUT0RPIGhhcmRjb2RlZCBsaW5rXHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjYW5jZWxTaGFyZUNhbGlmb3JuaWFQcm9qZWN0Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmNsb3NlUG9wdXAoKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGxvZ291dENsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuTG9nb3V0QWN0aW9uKCkuZG9uZSgocmVzcG9uc2U6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyBcIi9jYWxpZm9ybmlhL1wiKTsgLy8gVE9ETyBoYXJkY29kZWQgbGlua1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgYWN0aXZhdGVDYWxpZm9ybmlhVmlld0NsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgY2FsaWZvcm5pYVZpZXdJZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwidmlkXCIpO1xyXG4gICAgICAgIGxldCB1c2VyUGFnZXM6IENhbGlmb3JuaWFWaWV3W10gPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ2FsaWZvcm5pYVZpZXdzLmZpbHRlcih2aWV3ID0+ICF2aWV3LklzSW50ZXJuYWwpO1xyXG4gICAgICAgIGxldCBhY3RpdmVWaWV3OiBDYWxpZm9ybmlhVmlldyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBsZXQgYWN0aXZlUGFnZUluZGV4OiBudW1iZXIgPSB1c2VyUGFnZXMuZmluZEluZGV4KHYgPT4gdi5DYWxpZm9ybmlhVmlld0lkID09IGNhbGlmb3JuaWFWaWV3SWQpO1xyXG4gICAgICAgIGlmIChhY3RpdmVQYWdlSW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICBhY3RpdmVWaWV3ID0gdXNlclBhZ2VzW2FjdGl2ZVBhZ2VJbmRleF07XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAucm91dGVyLnNldEFjdGl2ZUNhbGlmb3JuaWFWaWV3KGFjdGl2ZVZpZXcpO1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnBhZ2VQcmV2aWV3LnJlc2V0RXF1YXRpb25OdW1iZXJzV2hlbk1vZGlmeWluZyh0cnVlKTsgLy8gVE9ETyB0ZXN0XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZXRTZWxlY3RlZENhbGlmb3JuaWFWaWV3KGFjdGl2ZVZpZXcsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5jdXJyZW50UHJvcGVydHlCYXJNb2RlID0gUHJvcGVydHlCYXJNb2RlLkNhbGlmb3JuaWFWaWV3OyAvLyBUT0RPIGV2ZXJ5d2hlcmU6IHRoaXMudmllTW9kZWwgb3IgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc2VsZWN0TGF5b3V0QmFzZUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgbGF5b3V0QmFzZUlkOiBudW1iZXIgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJsaWRcIik7IC8vIFRPRE8gZXZlcnl3aGVyZTogdXNlIGJhY2tlbmQgdmFsdWUgaW5zdGVhZCBvZiBwYXJzaW5nIHdoZXJlIHBvc3NpYmxlID0+IHNhdmVzIG11bHRpcGxlIHN0cmluZ3NcclxuICAgICAgICBjdXJyZW50QXBwLnN0YXRlLnNlbGVjdGVkTGF5b3V0QmFzZUlkID0gbGF5b3V0QmFzZUlkO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5jdXJyZW50UHJvcGVydHlCYXJNb2RlID0gUHJvcGVydHlCYXJNb2RlLkxheW91dEJhc2U7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzZWxlY3RDYWxpZm9ybmlhVmlld0NsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgY2FsaWZvcm5pYVZpZXdJZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwidmlkXCIpO1xyXG4gICAgICAgIGxldCB1c2VyUGFnZXM6IENhbGlmb3JuaWFWaWV3W10gPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ2FsaWZvcm5pYVZpZXdzLmZpbHRlcih2aWV3ID0+ICF2aWV3LklzSW50ZXJuYWwpO1xyXG4gICAgICAgIGxldCBhY3RpdmVWaWV3OiBDYWxpZm9ybmlhVmlldyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBsZXQgYWN0aXZlUGFnZUluZGV4OiBudW1iZXIgPSB1c2VyUGFnZXMuZmluZEluZGV4KHYgPT4gdi5DYWxpZm9ybmlhVmlld0lkID09IGNhbGlmb3JuaWFWaWV3SWQpO1xyXG4gICAgICAgIGlmIChhY3RpdmVQYWdlSW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICBhY3RpdmVWaWV3ID0gdXNlclBhZ2VzW2FjdGl2ZVBhZ2VJbmRleF07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5wcm9wZXJ0eUJhckluZGV4ID09IDApIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucm91dGVyLnNldEFjdGl2ZUNhbGlmb3JuaWFWaWV3KGFjdGl2ZVZpZXcpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEFwcC5wYWdlUHJldmlldy5yZXNldEVxdWF0aW9uTnVtYmVyc1doZW5Nb2RpZnlpbmcodHJ1ZSk7IC8vIFRPRE8gdGVzdFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmlzU3luY2VkV2l0aEJveFRyZWVUb1RoZUxlZnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2V0U2VsZWN0ZWRDYWxpZm9ybmlhVmlldyhhY3RpdmVWaWV3LCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmN1cnJlbnRQcm9wZXJ0eUJhck1vZGUgPSBQcm9wZXJ0eUJhck1vZGUuQ2FsaWZvcm5pYVZpZXc7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBkZWxldGVMYXlvdXRCYXNlQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkICE9IDApIHsgLy8gVE9ETyBkb2N1bWVudCAvLyBUT0RPIGRpc2FibGUgYnV0dG9uXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5zZWxlY3RlZExheW91dEJhc2VJZCA9IDA7XHJcbiAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLkRlbGV0ZUxheW91dEpzb24ocGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibGlkXCIpLCBmYWxzZSkuZG9uZShkYXRhID0+IGN1cnJlbnRBcHAucm91dGVyLnVwZGF0ZURhdGEoZGF0YSkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgZGVsZXRlQmVsb3dMYXlvdXRCYXNlQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkICE9IDApIHsgLy8gVE9ETyBkb2N1bWVudCAvLyBUT0RPIGRpc2FibGUgYnV0dG9uXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5zZWxlY3RlZExheW91dEJhc2VJZCA9IDA7XHJcbiAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLkRlbGV0ZUxheW91dEpzb24ocGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibGlkXCIpLCB0cnVlKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJMYXlvdXRCYXNlQ29udHJvbHMgPSAoKTogVk5vZGUgfCB1bmRlZmluZWQgPT4ge1xyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLnNlbGVjdGVkTGF5b3V0QmFzZUlkID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHNlbGVjdGVkTGF5b3V0QmFzZTogTGF5b3V0QmFzZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5MYXlvdXRNb2xlY3VsZXMuZmluZChsID0+IGwuTGF5b3V0QmFzZUlkID09IGN1cnJlbnRBcHAuc3RhdGUuc2VsZWN0ZWRMYXlvdXRCYXNlSWQpIGFzIExheW91dEJhc2U7XHJcbiAgICAgICAgbGV0IGxheW91dEJhc2VJZFN0cmluZzogc3RyaW5nID0gc2VsZWN0ZWRMYXlvdXRCYXNlLkxheW91dEJhc2VJZC50b1N0cmluZygpO1xyXG4gICAgICAgIGxldCBzb3VyY2VTdHlsZU1vbGVjdWxlSWRTdHJpbmc6IHN0cmluZyA9IChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChtID0+IG0uU3R5bGVGb3JMYXlvdXRJZCA9PSBzZWxlY3RlZExheW91dEJhc2UuTGF5b3V0QmFzZUlkKSBhcyBTdHlsZU1vbGVjdWxlKS5TdHlsZU1vbGVjdWxlSWQudG9TdHJpbmcoKTsgLy8gVE9ETyBleHBlbnNpdmVcclxuICAgICAgICBpZiAoc2VsZWN0ZWRMYXlvdXRCYXNlLkxheW91dFR5cGUgPT09IExheW91dFR5cGUuQXRvbSkge1xyXG4gICAgICAgICAgICBsZXQgc2VsZWN0ZWRMYXlvdXRBdG9tOiBMYXlvdXRBdG9tID0gc2VsZWN0ZWRMYXlvdXRCYXNlIGFzIExheW91dEF0b207XHJcbiAgICAgICAgICAgIGxldCBpc1BpY3R1cmVDb250ZW50OiBib29sZWFuID0gc2VsZWN0ZWRMYXlvdXRBdG9tLkhvc3RlZENvbnRlbnRBdG9tLkNvbnRlbnRBdG9tVHlwZSA9PT0gQ29udGVudEF0b21UeXBlLlBpY3R1cmU7XHJcbiAgICAgICAgICAgIGxldCBwaWN0dXJlQ29udGVudElkU3RyaW5nOiBzdHJpbmcgfCB1bmRlZmluZWQgPSBpc1BpY3R1cmVDb250ZW50ID8gc2VsZWN0ZWRMYXlvdXRBdG9tLkhvc3RlZENvbnRlbnRBdG9tLlBpY3R1cmVDb250ZW50LlBpY3R1cmVDb250ZW50SWQudG9TdHJpbmcoKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcmV0dXJuIDxkaXYga2V5PXtMYXlvdXRUeXBlLkF0b219PiBBdG9tOlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIG1pZD17c291cmNlU3R5bGVNb2xlY3VsZUlkU3RyaW5nfSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zZWxlY3RTdHlsZU1vbGVjdWxlQ2xpY2tIYW5kbGVyfT5zdHlsZSAje3NvdXJjZVN0eWxlTW9sZWN1bGVJZFN0cmluZ308L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYlwiIHJvbGU9XCJidXR0b25cIiBsaWQ9e2xheW91dEJhc2VJZFN0cmluZ30gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZGVsZXRlTGF5b3V0QmFzZUNsaWNrSGFuZGxlcn0+WDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJjXCIgcm9sZT1cImJ1dHRvblwiIGFpZD17bGF5b3V0QmFzZUlkU3RyaW5nfSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jcmVhdGVMYXlvdXRTdHlsZUludGVyYWN0aW9ufT4rIEludGVyYWN0aW9uPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICB7c2VsZWN0ZWRMYXlvdXRBdG9tLkxheW91dFN0eWxlSW50ZXJhY3Rpb25zLm1hcChpbnRlcmFjdGlvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uSWRTdHJpbmc6IHN0cmluZyA9IGludGVyYWN0aW9uLkxheW91dFN0eWxlSW50ZXJhY3Rpb25JZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17YGkke2ludGVyYWN0aW9uSWRTdHJpbmd9YH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxwIGtleT1cIjBcIj5JbnRlcmFjdGlvbiAje2ludGVyYWN0aW9uLkxheW91dFN0eWxlSW50ZXJhY3Rpb25JZH08L3A+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBrZXk9XCIxXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENzc1ZhbHVlRm9ySW50ZXJhY3Rpb259XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmlucHV0PXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jc3NWYWx1ZUZvckludGVyYWN0aW9uSW5wdXRIYW5kbGVyfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9pbnB1dD5cclxuICAgICAgICAgICAgICAgICAgICAgICAge3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ3NzVmFsdWVGb3JJbnRlcmFjdGlvbiAhPT0gXCJcIiA/IDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiBsaWQ9e2ludGVyYWN0aW9uSWRTdHJpbmd9IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnNlbGVjdEludGVyYWN0aW9uVGFyZ2V0Q2xpY2tIYW5kbGVyfT4/PC9idXR0b24+IDogPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJhMFwiIHJvbGU9XCJidXR0b25cIiBsaWQ9e2ludGVyYWN0aW9uSWRTdHJpbmd9IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnNlbGVjdEludGVyYWN0aW9uVGFyZ2V0Q2xpY2tIYW5kbGVyfT4/PC9idXR0b24+fVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImJcIiByb2xlPVwiYnV0dG9uXCIgbGlkPXtpbnRlcmFjdGlvbklkU3RyaW5nfSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5kZWxldGVMYXlvdXRTdHlsZUludGVyYWN0aW9uQ2xpY2tIYW5kbGVyfT5YPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtpbnRlcmFjdGlvbi5TdHlsZVZhbHVlSW50ZXJhY3Rpb25zLm1hcChtYXAgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1hcHBpbmdJZFN0cmluZzogc3RyaW5nID0gbWFwLlN0eWxlVmFsdWVJbnRlcmFjdGlvbk1hcHBpbmdJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxkaXYga2V5PXttYXBwaW5nSWRTdHJpbmd9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGtleT1cIjBcIj4je21hcHBpbmdJZFN0cmluZ306IHttYXAuQ3NzVmFsdWV9PC9wPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiB2aWQ9e21hcC5TdHlsZVZhbHVlSWQudG9TdHJpbmcoKX0gbGlkPXtpbnRlcmFjdGlvbklkU3RyaW5nfSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5kZWxldGVTdHlsZVZhbHVlSW50ZXJhY3Rpb25DbGlja0hhbmRsZXJ9Plg8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KX1cclxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgIH0pfVxyXG4gICAgICAgICAgICAgICAgPGZvcm0ga2V5PVwiMFwiIGFjdGlvbj1cIlVwbG9hZEZpbGVzXCIgbWV0aG9kPVwicG9zdFwiIGVuY3R5cGU9XCJtdWx0aXBhcnQvZm9ybS1kYXRhXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHAga2V5PVwiMFwiPnBpY3R1cmUgaWQgI3twaWN0dXJlQ29udGVudElkU3RyaW5nfTwvcD5cclxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgbXVsdGlwbGUga2V5PVwiMVwiIHR5cGU9XCJmaWxlXCIgbmFtZT1cImZvcm1GaWxlc1wiIG9uY2hhbmdlPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci51cGxvYWRGaWxlQ2hhbmdlSGFuZGxlcn0+PC9pbnB1dD5cclxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgcGlkPXtwaWN0dXJlQ29udGVudElkU3RyaW5nfSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci51cGxvYWRGaWxlQ2xpY2tIYW5kbGVyfT4uLi48L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDwvZm9ybT5cclxuICAgICAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzZWxlY3RlZExheW91dEJhc2UuTGF5b3V0VHlwZSA9PT0gTGF5b3V0VHlwZS5Cb3gpIHtcclxuICAgICAgICAgICAgbGV0IHNlbGVjdGVkTGF5b3V0Qm94OiBMYXlvdXRCb3ggPSBzZWxlY3RlZExheW91dEJhc2UgYXMgTGF5b3V0Qm94O1xyXG4gICAgICAgICAgICBsZXQgc3BlY2lhbExheW91dEJveFR5cGVTZWxlY3RvcnM6IFZOb2RlW10gPSBbXTtcclxuICAgICAgICAgICAgZ2V0QXJyYXlGb3JFbnVtKFNwZWNpYWxMYXlvdXRCb3hUeXBlKS5tYXAoKHR5cGU6IHN0cmluZywgaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGlzTGF5b3V0Qm94VHlwZTogYm9vbGVhbiA9IGluZGV4ID09IHNlbGVjdGVkTGF5b3V0Qm94LlNwZWNpYWxMYXlvdXRCb3hUeXBlO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxheW91dEJveFR5cGVTdHJpbmc6IHN0cmluZyA9IGluZGV4LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBzcGVjaWFsTGF5b3V0Qm94VHlwZVNlbGVjdG9ycy5wdXNoKGlzTGF5b3V0Qm94VHlwZSA/IDxvcHRpb24gc2VsZWN0ZWQga2V5PXtsYXlvdXRCb3hUeXBlU3RyaW5nfSB2YWx1ZT17bGF5b3V0Qm94VHlwZVN0cmluZ30+e3R5cGV9PC9vcHRpb24+IGFzIFZOb2RlIDogPG9wdGlvbiBrZXk9e2xheW91dEJveFR5cGVTdHJpbmd9IHZhbHVlPXtsYXlvdXRCb3hUeXBlU3RyaW5nfT57dHlwZX08L29wdGlvbj4gYXMgVk5vZGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIDxkaXYga2V5PXtMYXlvdXRUeXBlLkJveH0+IEJveDpcclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIHJvbGU9XCJidXR0b25cIiBtaWQ9e3NvdXJjZVN0eWxlTW9sZWN1bGVJZFN0cmluZ30gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2VsZWN0U3R5bGVNb2xlY3VsZUNsaWNrSGFuZGxlcn0+c3R5bGUgI3tzb3VyY2VTdHlsZU1vbGVjdWxlSWRTdHJpbmd9PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGRpc2FibGVkIGtleT1cImJcIiByb2xlPVwiYnV0dG9uXCIgb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY3JlYXRlVmlld0ZvckJveENsaWNrSGFuZGxlcn0+Q3JlYXRlIFZpZXc8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiY1wiIHJvbGU9XCJidXR0b25cIiBsaWQ9e2xheW91dEJhc2VJZFN0cmluZ30gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZGVsZXRlTGF5b3V0QmFzZUNsaWNrSGFuZGxlcn0+WDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPHNlbGVjdCBrZXk9XCIwXCIgYmlkPXtsYXlvdXRCYXNlSWRTdHJpbmd9XHJcbiAgICAgICAgICAgICAgICAgICAgb25jaGFuZ2U9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnNwZWNpYWxMYXlvdXRCb3hUeXBlQ2hhbmdlZEhhbmRsZXJ9PlxyXG4gICAgICAgICAgICAgICAgICAgIHtzcGVjaWFsTGF5b3V0Qm94VHlwZVNlbGVjdG9yc31cclxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgICAgICA8L2Rpdj4gYXMgVk5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdGVkTGF5b3V0QmFzZS5MYXlvdXRUeXBlID09PSBMYXlvdXRUeXBlLlJvdykge1xyXG4gICAgICAgICAgICBsZXQgc2VsZWN0ZWRMYXlvdXRSb3c6IExheW91dFJvdyA9IHNlbGVjdGVkTGF5b3V0QmFzZSBhcyBMYXlvdXRSb3c7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50Qm94Q291bnQ6IG51bWJlciA9IHNlbGVjdGVkTGF5b3V0Um93LkFsbEJveGVzQmVsb3dSb3cuZmlsdGVyKGIgPT4gYi5QbGFjZWRCb3hJbkJveElkID09PSB1bmRlZmluZWQpLmxlbmd0aDtcclxuICAgICAgICAgICAgbGV0IGJveENvdW50U2VsZWN0b3JzOiBWTm9kZVtdID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IDEyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBpc1NlbGVjdGVkOiBib29sZWFuID0gaSA9PSBjdXJyZW50Qm94Q291bnQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgYm94Q291bnRTdHJpbmc6IHN0cmluZyA9IGkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBib3hDb3VudFNlbGVjdG9ycy5wdXNoKGlzU2VsZWN0ZWQgPyA8b3B0aW9uIGRpc2FibGVkIHNlbGVjdGVkIGtleT17Ym94Q291bnRTdHJpbmd9IHZhbHVlPXtib3hDb3VudFN0cmluZ30+e2JveENvdW50U3RyaW5nfTwvb3B0aW9uPiBhcyBWTm9kZSA6IDxvcHRpb24gZGlzYWJsZWQga2V5PXtib3hDb3VudFN0cmluZ30gdmFsdWU9e2JveENvdW50U3RyaW5nfT57Ym94Q291bnRTdHJpbmd9PC9vcHRpb24+IGFzIFZOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGJveENvdW50U2VsZWN0b3JzLnB1c2goaXNTZWxlY3RlZCA/IDxvcHRpb24gc2VsZWN0ZWQga2V5PXtib3hDb3VudFN0cmluZ30gdmFsdWU9e2JveENvdW50U3RyaW5nfT57Ym94Q291bnRTdHJpbmd9PC9vcHRpb24+IGFzIFZOb2RlIDogPG9wdGlvbiBrZXk9e2JveENvdW50U3RyaW5nfSB2YWx1ZT17Ym94Q291bnRTdHJpbmd9Pntib3hDb3VudFN0cmluZ308L29wdGlvbj4gYXMgVk5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiA8ZGl2IGtleT17TGF5b3V0VHlwZS5Sb3d9PiBSb3c6XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImFcIiByb2xlPVwiYnV0dG9uXCIgbWlkPXtzb3VyY2VTdHlsZU1vbGVjdWxlSWRTdHJpbmd9IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnNlbGVjdFN0eWxlTW9sZWN1bGVDbGlja0hhbmRsZXJ9PnN0eWxlICN7c291cmNlU3R5bGVNb2xlY3VsZUlkU3RyaW5nfTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJiXCIgcm9sZT1cImJ1dHRvblwiIGxpZD17bGF5b3V0QmFzZUlkU3RyaW5nfSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5kZWxldGVMYXlvdXRCYXNlQ2xpY2tIYW5kbGVyfT5YPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8c2VsZWN0IGtleT1cImNcIiByaWQ9e2xheW91dEJhc2VJZFN0cmluZ31cclxuICAgICAgICAgICAgICAgICAgICBvbmNoYW5nZT17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuYm94Q291bnRJblJvd0NoYW5nZWRIYW5kbGVyfT5cclxuICAgICAgICAgICAgICAgICAgICB7Ym94Q291bnRTZWxlY3RvcnN9XHJcbiAgICAgICAgICAgICAgICA8L3NlbGVjdD5cclxuICAgICAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHVwbG9hZEZpbGVDaGFuZ2VIYW5kbGVyID0gKGV2dDogRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBsZXQgZmlsZVNlbGVjdG9yOiBIVE1MSW5wdXRFbGVtZW50ID0gZXZ0LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGlmIChmaWxlU2VsZWN0b3IuZmlsZXMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgbGV0IGZpbGVBcnJheTogRmlsZVtdID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4IGluIGZpbGVTZWxlY3Rvci5maWxlcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGZpbGU6IEZpbGUgPSBmaWxlU2VsZWN0b3IuZmlsZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgZmlsZUFycmF5LnB1c2goZmlsZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhmaWxlKTtcclxuICAgICAgICAgICAgICAgIGxldCBmaWxlUmVhZGVyOiBGaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICAgICAgICAgIGZpbGVSZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlbmRcIiwgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZmlsZVByb2Nlc3NpbmdMb2FkRW5kSGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICAvL2ZpbGVSZWFkZXIucmVhZEFzVGV4dChuZXcgQmxvYihbZmlsZV0pLCB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmaWxlU2VsZWN0b3IuZmlsZXMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZW1wdHlcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9jdXJyZW50QXBwLmNvbnRyb2xsZXIuVXBsb2FkRmlsZXNBY3Rpb24oZmlsZUFycmF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidW5kZWZpbmVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGZpbGVQcm9jZXNzaW5nTG9hZEVuZEhhbmRsZXIgPSAoZXZ0OiBQcm9ncmVzc0V2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coZXZ0LnRvdGFsKTtcclxuICAgICAgICBjb25zb2xlLmxvZygoZXZ0LnRhcmdldCBhcyBGaWxlUmVhZGVyKS5yZXN1bHQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgdXBsb2FkRmlsZUNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBsZXQgdGFyZ2V0Rm9ybTogSFRNTEZvcm1FbGVtZW50ID0gKGV2dC50YXJnZXQgYXMgSFRNTEJ1dHRvbkVsZW1lbnQpLmZvcm0gYXMgSFRNTEZvcm1FbGVtZW50O1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwidXBsb2FkIGRpYWxvZyBUT0RPXCIpO1xyXG4gICAgICAgIGpRdWVyeS5hamF4KHRhcmdldEZvcm0uYWN0aW9uLCB7XHJcbiAgICAgICAgICAgIG1ldGhvZDogdGFyZ2V0Rm9ybS5tZXRob2QsXHJcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcIm11bHRpcGFydC9mb3JtLWRhdGFcIixcclxuICAgICAgICAgICAgZGF0YTogJCh0YXJnZXRGb3JtKS5zZXJpYWxpemUoKVxyXG4gICAgICAgIH0gYXMgSlF1ZXJ5QWpheFNldHRpbmdzKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNlbGVjdEludGVyYWN0aW9uVGFyZ2V0Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5zZWxlY3RlZExheW91dFN0eWxlSW50ZXJhY3Rpb24gPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJsaWRcIik7IC8vIFRPRE8gaGFja1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmRpc3BsYXlQb3B1cChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCBQb3B1cE1vZGUuU2VsZWN0SW50ZXJhY3Rpb25UYXJnZXQpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgZGVsZXRlU3R5bGVWYWx1ZUludGVyYWN0aW9uQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5EZWxldGVTdHlsZVZhbHVlSW50ZXJhY3Rpb25Kc29uKHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImxpZFwiKSwgcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwidmlkXCIpKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBwdWJsaWMgZGVsZXRlTGF5b3V0U3R5bGVJbnRlcmFjdGlvbkNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpOiB2b2lkID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuRGVsZXRlTGF5b3V0U3R5bGVJbnRlcmFjdGlvbkpzb24ocGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibGlkXCIpKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBjcmVhdGVMYXlvdXRTdHlsZUludGVyYWN0aW9uID0gKGV2dDogTW91c2VFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5DcmVhdGVMYXlvdXRTdHlsZUludGVyYWN0aW9uRm9yTGF5b3V0QXRvbUpzb24ocGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwiYWlkXCIpKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzcGVjaWFsTGF5b3V0Qm94VHlwZUNoYW5nZWRIYW5kbGVyID0gKGV2dDogVUlFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCB0YXJnZXRTZWxlY3QgPSBldnQudGFyZ2V0IGFzIEhUTUxTZWxlY3RFbGVtZW50O1xyXG4gICAgICAgIGxldCBzZWxlY3RlZFNwZWNpYWxMYXlvdXRCb3hUeXBlOiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKHRhcmdldFNlbGVjdC5zZWxlY3RlZEluZGV4IDwgdGFyZ2V0U2VsZWN0LmNoaWxkRWxlbWVudENvdW50KSB7XHJcbiAgICAgICAgICAgIGxldCBzZWxlY3RPcHRpb25FbGVtZW50OiBIVE1MT3B0aW9uRWxlbWVudCA9IHRhcmdldFNlbGVjdC5vcHRpb25zW3RhcmdldFNlbGVjdC5zZWxlY3RlZEluZGV4XTtcclxuICAgICAgICAgICAgc2VsZWN0ZWRTcGVjaWFsTGF5b3V0Qm94VHlwZSA9IHBhcnNlSW50KHNlbGVjdE9wdGlvbkVsZW1lbnQudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2VsZWN0ZWRTcGVjaWFsTGF5b3V0Qm94VHlwZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuY29udHJvbGxlci5TZXRTcGVjaWFsTGF5b3V0Qm94VHlwZUpzb24ocGFyc2VJbnRGcm9tQXR0cmlidXRlKHRhcmdldFNlbGVjdCwgXCJiaWRcIiksIHNlbGVjdGVkU3BlY2lhbExheW91dEJveFR5cGUpLmRvbmUoZGF0YSA9PiBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBib3hDb3VudEluUm93Q2hhbmdlZEhhbmRsZXIgPSAoZXZ0OiBVSUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IHRhcmdldFNlbGVjdCA9IGV2dC50YXJnZXQgYXMgSFRNTFNlbGVjdEVsZW1lbnQ7XHJcbiAgICAgICAgbGV0IHBhcnNlZEJveENvdW50OiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKHRhcmdldFNlbGVjdC5zZWxlY3RlZEluZGV4IDwgdGFyZ2V0U2VsZWN0LmNoaWxkRWxlbWVudENvdW50KSB7XHJcbiAgICAgICAgICAgIGxldCBzZWxlY3RPcHRpb25FbGVtZW50OiBIVE1MT3B0aW9uRWxlbWVudCA9IHRhcmdldFNlbGVjdC5vcHRpb25zW3RhcmdldFNlbGVjdC5zZWxlY3RlZEluZGV4XTtcclxuICAgICAgICAgICAgcGFyc2VkQm94Q291bnQgPSBwYXJzZUludChzZWxlY3RPcHRpb25FbGVtZW50LnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhcnNlZEJveENvdW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLlNldExheW91dEJveENvdW50Rm9yUm93T3JCb3hKc29uKHBhcnNlSW50RnJvbUF0dHJpYnV0ZSh0YXJnZXRTZWxlY3QsIFwicmlkXCIpLCBjdXJyZW50QXBwLnN0YXRlLm5ld0JveFN0eWxlTW9sZWN1bGVJZCwgcGFyc2VkQm94Q291bnQsIGZhbHNlKS5kb25lKGRhdGEgPT4gY3VycmVudEFwcC5yb3V0ZXIudXBkYXRlRGF0YShkYXRhKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgZmluYWxpemVMYXlvdXRSZXF1ZXN0ID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIC8vIFRPRE8gZGlmZmVyZW50aWF0ZSBtb2RlXHJcbiAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5zZWxlY3RlZExheW91dEJhc2VJZCA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImxpZFwiKTtcclxuICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25Nb2RlID09PSBUcmFuc2FjdGlvbk1vZGUuTW92ZUxheW91dE1vbGVjdWxlSW50b0xheW91dE1vbGVjdWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLm1vdmVMYXlvdXRNb2xlY3VsZUludG9MYXlvdXRNb2xlY3VsZSgpO1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25Nb2RlID09PSBUcmFuc2FjdGlvbk1vZGUuTW92ZUxheW91dE1vbGVjdWxlQmVmb3JlTGF5b3V0TW9sZWN1bGUpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIubW92ZUxheW91dE1vbGVjdWxlQmVmb3JlTGF5b3V0TW9sZWN1bGUoKTtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFRyYW5zYWN0aW9uTW9kZSA9PT0gVHJhbnNhY3Rpb25Nb2RlLlN5bmNMYXlvdXRTdHlsZXNJbWl0YXRpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc3luY0xheW91dE1vbGVjdWxlU3R5bGVzSW1pdGF0aW5nUmVmZXJlbmNlTGF5b3V0KCk7IC8vIFRPRE8gZG9jdW1lbnQgb3IgcmV3b3JrIHN0aWNreSBwcmVzZWxlY3Rpb25cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUucHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQgPSAwO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBtb3ZlTGF5b3V0Qm94SW50b1Jvd0NsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgbGF5b3V0QmFzZUlkOiBudW1iZXIgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJsaWRcIik7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUucHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQgIT0gbGF5b3V0QmFzZUlkKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUucHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQgPSBsYXlvdXRCYXNlSWQ7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuY3VycmVudFRyYW5zYWN0aW9uTW9kZSA9IFRyYW5zYWN0aW9uTW9kZS5Nb3ZlTGF5b3V0TW9sZWN1bGVJbnRvTGF5b3V0TW9sZWN1bGU7XHJcbiAgICAgICAgICAgIC8vdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZGlzcGxheVBvcHVwKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsIFBvcHVwTW9kZS5Nb3ZlTGF5b3V0TW9sZWN1bGVJbnRvTGF5b3V0TW9sZWN1bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgbW92ZUxheW91dEJveEludG9Cb3hDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IGxheW91dEJhc2VJZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibGlkXCIpO1xyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkICE9IGxheW91dEJhc2VJZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkID0gbGF5b3V0QmFzZUlkO1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmN1cnJlbnRUcmFuc2FjdGlvbk1vZGUgPSBUcmFuc2FjdGlvbk1vZGUuTW92ZUxheW91dE1vbGVjdWxlSW50b0xheW91dE1vbGVjdWxlO1xyXG4gICAgICAgICAgICAvL3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmRpc3BsYXlQb3B1cChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCBQb3B1cE1vZGUuTW92ZUxheW91dE1vbGVjdWxlSW50b0xheW91dE1vbGVjdWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUucHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIG1vdmVMYXlvdXRCb3hCZWZvcmVCb3hDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IGxheW91dEJhc2VJZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibGlkXCIpO1xyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkICE9IGxheW91dEJhc2VJZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkID0gbGF5b3V0QmFzZUlkO1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmN1cnJlbnRUcmFuc2FjdGlvbk1vZGUgPSBUcmFuc2FjdGlvbk1vZGUuTW92ZUxheW91dE1vbGVjdWxlQmVmb3JlTGF5b3V0TW9sZWN1bGU7XHJcbiAgICAgICAgICAgIC8vdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZGlzcGxheVBvcHVwKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsIFBvcHVwTW9kZS5Nb3ZlTGF5b3V0TW9sZWN1bGVCZWZvcmVMYXlvdXRNb2xlY3VsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBtb3ZlTGF5b3V0Um93QmVmb3JlUm93Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCBsYXlvdXRCYXNlSWQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImxpZFwiKTtcclxuICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCAhPSBsYXlvdXRCYXNlSWQpIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCA9IGxheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25Nb2RlID0gVHJhbnNhY3Rpb25Nb2RlLk1vdmVMYXlvdXRNb2xlY3VsZUJlZm9yZUxheW91dE1vbGVjdWxlO1xyXG4gICAgICAgICAgICAvL3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmRpc3BsYXlQb3B1cChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCBQb3B1cE1vZGUuTW92ZUxheW91dE1vbGVjdWxlQmVmb3JlTGF5b3V0TW9sZWN1bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgc3luY0xheW91dEJhc2VTdHlsZXNDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IGxheW91dEJhc2VJZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibGlkXCIpO1xyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkICE9IGxheW91dEJhc2VJZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkID0gbGF5b3V0QmFzZUlkO1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmN1cnJlbnRUcmFuc2FjdGlvbk1vZGUgPSBUcmFuc2FjdGlvbk1vZGUuU3luY0xheW91dFN0eWxlc0ltaXRhdGluZztcclxuICAgICAgICAgICAgLy90aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5kaXNwbGF5UG9wdXAoZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgUG9wdXBNb2RlLlVOREVGSU5FRCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBtb3ZlTGF5b3V0QXRvbUludG9Cb3hDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IGxheW91dEJhc2VJZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibGlkXCIpO1xyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkICE9IGxheW91dEJhc2VJZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkID0gbGF5b3V0QmFzZUlkO1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmN1cnJlbnRUcmFuc2FjdGlvbk1vZGUgPSBUcmFuc2FjdGlvbk1vZGUuTW92ZUxheW91dE1vbGVjdWxlSW50b0xheW91dE1vbGVjdWxlO1xyXG4gICAgICAgICAgICAvL3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmRpc3BsYXlQb3B1cChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCBQb3B1cE1vZGUuTW92ZUxheW91dE1vbGVjdWxlSW50b0xheW91dE1vbGVjdWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUucHJlc2VsZWN0ZWRMYXlvdXRCYXNlSWQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNyZWF0ZUJveEZvckF0b21JblBsYWNlQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuc2VsZWN0ZWRMYXlvdXRCYXNlSWQgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJsaWRcIik7XHJcbiAgICAgICAgLy8gVE9ETyBkb2N1bWVudDogZm9yZWlnbiBwb3B1cCBpcyB1c2VkLCBjb250cm9sbGVyIHJlcXVlc3QgZGlmZmVyZW50aWF0aW9uIGJ5IHN0YXRlXHJcbiAgICAgICAgdGhpcy52aWV3TW9kZWwuY3VycmVudFNlY29uZGFyeVBvcHVwTW9kZSA9IFBvcHVwU2Vjb25kYXJ5TW9kZS5TZWxlY3RCb3hJbnRvQm94QXRvbUluUGxhY2U7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZGlzcGxheVBvcHVwKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsIFBvcHVwTW9kZS5TZWxlY3RCb3gpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgbW92ZUxheW91dEF0b21CZWZvcmVBdG9tQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCBsYXlvdXRCYXNlSWQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImxpZFwiKTtcclxuICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCAhPSBsYXlvdXRCYXNlSWQpIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCA9IGxheW91dEJhc2VJZDtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25Nb2RlID0gVHJhbnNhY3Rpb25Nb2RlLk1vdmVMYXlvdXRNb2xlY3VsZUJlZm9yZUxheW91dE1vbGVjdWxlO1xyXG4gICAgICAgICAgICAvL3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmRpc3BsYXlQb3B1cChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCBQb3B1cE1vZGUuTW92ZUxheW91dE1vbGVjdWxlQmVmb3JlTGF5b3V0TW9sZWN1bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgbW92ZUxheW91dEF0b21CZWZvcmVCb3hDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IGxheW91dEJhc2VJZDogbnVtYmVyID0gcGFyc2VJbnRGcm9tQXR0cmlidXRlKGV2dC50YXJnZXQsIFwibGlkXCIpO1xyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkICE9IGxheW91dEJhc2VJZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkID0gbGF5b3V0QmFzZUlkO1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmN1cnJlbnRUcmFuc2FjdGlvbk1vZGUgPSBUcmFuc2FjdGlvbk1vZGUuTW92ZUxheW91dE1vbGVjdWxlQmVmb3JlTGF5b3V0TW9sZWN1bGU7XHJcbiAgICAgICAgICAgIC8vdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZGlzcGxheVBvcHVwKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsIFBvcHVwTW9kZS5Nb3ZlTGF5b3V0TW9sZWN1bGVCZWZvcmVMYXlvdXRNb2xlY3VsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLnByZXNlbGVjdGVkTGF5b3V0QmFzZUlkID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzYXZlTGF5b3V0TW9sZWN1bGVDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLlNldExheW91dFJvd09yQm94QXNJbnN0YW5jZWFibGVKc29uKGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5DYWxpZm9ybmlhUHJvamVjdElkLCBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJsaWRcIikpLmRvbmUoZGF0YSA9PiBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNyZWF0ZVZpZXdGb3JCb3hDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJUT0RPXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgaW5zZXJ0TGF5b3V0QXRvbUludG9Cb3hDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5zZWxlY3RlZExheW91dEJhc2VJZCA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImxpZFwiKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5kaXNwbGF5UG9wdXAoZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgUG9wdXBNb2RlLkluc2VydExheW91dEF0b21JbnRvQm94KTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGluc2VydExheW91dEJveEludG9Cb3hDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5zZWxlY3RlZExheW91dEJhc2VJZCA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcImxpZFwiKTtcclxuICAgICAgICB0aGlzLnZpZXdNb2RlbC5jdXJyZW50U2Vjb25kYXJ5UG9wdXBNb2RlID0gUG9wdXBTZWNvbmRhcnlNb2RlLlNlbGVjdEJveEludG9Cb3g7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZGlzcGxheVBvcHVwKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsIFBvcHVwTW9kZS5TZWxlY3RCb3gpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyQ2FsaWZvcm5pYVZpZXdDb250cm9sc1doZW5BbGwgPSAoKTogVk5vZGUgPT4ge1xyXG4gICAgICAgIGxldCBpc0FkZEJ1dHRvbkVuYWJsZWQ6IGJvb2xlYW4gPSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENhbGlmb3JuaWFWaWV3TmFtZSAhPT0gXCJcIjtcclxuICAgICAgICByZXR1cm4gPGRpdiBrZXk9XCItMVwiPlxyXG4gICAgICAgICAgICA8aW5wdXQga2V5PVwiMFwiXHJcbiAgICAgICAgICAgICAgICB2YWx1ZT17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDYWxpZm9ybmlhVmlld05hbWV9XHJcbiAgICAgICAgICAgICAgICBvbmlucHV0PXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jYWxpZm9ybmlhVmlld05hbWVJbnB1dEhhbmRsZXJ9PlxyXG4gICAgICAgICAgICA8L2lucHV0PlxyXG4gICAgICAgICAgICB7aXNBZGRCdXR0b25FbmFibGVkID8gPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmNyZWF0ZUNhbGlmb3JuaWFWaWV3Q2xpY2tIYW5kbGVyfT4mIzEwMDA0OzwvYnV0dG9uPiA6IDxidXR0b24gZGlzYWJsZWQga2V5PVwiYTBcIiByb2xlPVwiYnV0dG9uXCIgb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY3JlYXRlQ2FsaWZvcm5pYVZpZXdDbGlja0hhbmRsZXJ9PiYjMTAwMDQ7PC9idXR0b24+fVxyXG4gICAgICAgICAgICB7aXNBZGRCdXR0b25FbmFibGVkID8gPGJ1dHRvbiBrZXk9XCJiXCIgcm9sZT1cImJ1dHRvblwiIG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmNyZWF0ZUNhbGlmb3JuaWFWaWV3RnJvbVJlZmVyZW5jZUNsaWNrSGFuZGxlcn0+eDI8L2J1dHRvbj4gOiA8YnV0dG9uIGRpc2FibGVkIGtleT1cImIwXCIgcm9sZT1cImJ1dHRvblwiIG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmNyZWF0ZUNhbGlmb3JuaWFWaWV3RnJvbVJlZmVyZW5jZUNsaWNrSGFuZGxlcn0+eDI8L2J1dHRvbj59XHJcbiAgICAgICAgPC9kaXY+IGFzIFZOb2RlO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY3JlYXRlQ2FsaWZvcm5pYVZpZXdGcm9tUmVmZXJlbmNlQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmRpc3BsYXlQb3B1cChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCBQb3B1cE1vZGUuQ2FsaWZvcm5pYVZpZXdTZWxlY3Rpb24pO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY3JlYXRlQ2FsaWZvcm5pYVZpZXdDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5jb250cm9sbGVyLkNyZWF0ZUNhbGlmb3JuaWFWaWV3SnNvbihjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ2FsaWZvcm5pYVByb2plY3RJZCwgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnRlbXBDYWxpZm9ybmlhVmlld05hbWUpLmRvbmUoZGF0YSA9PiBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENhbGlmb3JuaWFWaWV3TmFtZSA9IFwiXCI7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBwdWJsaWMgY2FsaWZvcm5pYVZpZXdOYW1lSW5wdXRIYW5kbGVyID0gKGV2dDogS2V5Ym9hcmRFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ2FsaWZvcm5pYVZpZXdOYW1lID0gKGV2dC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJDYWxpZm9ybmlhVmlld1NlbGVjdGlvblBvcHVwID0gKCk6IFZOb2RlID0+IHtcclxuICAgICAgICBsZXQgaXNQb3B1cFZpc2libGU6IGJvb2xlYW4gPSB0aGlzLnZpZXdNb2RlbC5jdXJyZW50UG9wdXBNb2RlID09PSBQb3B1cE1vZGUuQ2FsaWZvcm5pYVZpZXdTZWxlY3Rpb247IC8vIFRPRE8gc2hvcnRlbiBpZHMgZXZlcnl3aGVyZVxyXG4gICAgICAgIGxldCByZW5kZXJlZE9wdGlvbnM6IFZOb2RlW10gPSBbXTtcclxuICAgICAgICBpZiAoaXNQb3B1cFZpc2libGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFWaWV3cy5maWx0ZXIobSA9PiAhbS5Jc0ludGVybmFsKS5tYXAobSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2FsaWZvcm5pYVZpZXdJZFN0cmluZzogc3RyaW5nID0gbS5DYWxpZm9ybmlhVmlld0lkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlZE9wdGlvbnMucHVzaCg8ZGl2IGtleT17Y2FsaWZvcm5pYVZpZXdJZFN0cmluZ30gc3R5bGVzPXt7IFwiZmxleFwiOiBcIjAgMCAxMDAlXCIsIFwid2lkdGhcIjogXCIxMDAlXCIsIFwibWluLXdpZHRoXCI6IFwiMTAwJVwiIH19PlxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcgI3tjYWxpZm9ybmlhVmlld0lkU3RyaW5nfToge20uTmFtZX0gPGJ1dHRvbiBrZXk9XCJhXCIgcm9sZT1cImJ1dHRvblwiIHZpZD17Y2FsaWZvcm5pYVZpZXdJZFN0cmluZ30gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2VsZWN0Q2FsaWZvcm5pYVZpZXdJblBvcHVwQ2xpY2tIYW5kbGVyfT4mIzEwMDA0OzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+IGFzIFZOb2RlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiA8ZGl2IGlkPXtgJHt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5wcm9wZXJ0eUJhckluZGV4fVBvcHVwTW9kZSR7UG9wdXBNb2RlW1BvcHVwTW9kZS5DYWxpZm9ybmlhVmlld1NlbGVjdGlvbl19YH0gc3R5bGVzPXt7IFwiZGlzcGxheVwiOiBpc1BvcHVwVmlzaWJsZSA/IFwiYmxvY2tcIiA6IFwibm9uZVwiLCBcInotaW5kZXhcIjogXCIzMVwiLCBcImJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZVwiLCBcImJvcmRlclwiOiBcInNvbGlkIGJsYWNrIDFweFwiIH19PlxyXG4gICAgICAgICAgICA8ZGl2IGtleT1cIjBcIiBzdHlsZXM9e3sgXCJkaXNwbGF5XCI6IFwiZmxleFwiLCBcImZsZXgtZmxvd1wiOiBcInJvdyBub3dyYXBcIiwgXCJtaW4td2lkdGhcIjogXCIyNTBweFwiIH19PlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJiXCIgc3R5bGVzPXt7IFwiZmxleFwiOiBcIjEgMCAxMCVcIiwgXCJ3aWR0aFwiOiBcIjEwJVwiLCBcIm1pbi13aWR0aFwiOiBcIjEwJVwiIH19IG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmNhbmNlbFNlbGVjdENhbGlmb3JuaWFWaWV3UG9wdXBDbGlja0hhbmRsZXJ9Png8L2J1dHRvbj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYga2V5PVwiMVwiIHN0eWxlcz17eyBcImRpc3BsYXlcIjogXCJmbGV4XCIsIFwiZmxleC1mbG93XCI6IFwicm93IHdyYXBcIiB9fT5cclxuICAgICAgICAgICAgICAgIHtyZW5kZXJlZE9wdGlvbnN9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PiBhcyBWTm9kZTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIHNlbGVjdENhbGlmb3JuaWFWaWV3SW5Qb3B1cENsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuQ3JlYXRlQ2FsaWZvcm5pYVZpZXdGcm9tUmVmZXJlbmNlVmlld0pzb24oY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFQcm9qZWN0SWQsIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC50ZW1wQ2FsaWZvcm5pYVZpZXdOYW1lLCBwYXJzZUludEZyb21BdHRyaWJ1dGUoZXZ0LnRhcmdldCwgXCJ2aWRcIikpLmRvbmUoZGF0YSA9PiBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwudGVtcENhbGlmb3JuaWFWaWV3TmFtZSA9IFwiXCI7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuY2xvc2VQb3B1cCgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgY2FuY2VsU2VsZWN0Q2FsaWZvcm5pYVZpZXdQb3B1cENsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5jbG9zZVBvcHVwKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyByZW5kZXJDYWxpZm9ybmlhVmlld0NvbnRyb2xzID0gKCk6IFZOb2RlIHwgdW5kZWZpbmVkID0+IHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLnNlbGVjdGVkQ2FsaWZvcm5pYVZpZXdJZCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBzZWxlY3RlZENhbGlmb3JuaWFWaWV3OiBDYWxpZm9ybmlhVmlldyA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5DYWxpZm9ybmlhVmlld3MuZmluZCh2ID0+IHYuQ2FsaWZvcm5pYVZpZXdJZCA9PSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuc2VsZWN0ZWRDYWxpZm9ybmlhVmlld0lkKSBhcyBDYWxpZm9ybmlhVmlldzsgLy8gVE9ETyBwb3RlbnRpYWxseSBzbG93XHJcbiAgICAgICAgbGV0IGNhbGlmb3JuaWFWaWV3SWRTdHJpbmc6IHN0cmluZyA9IHNlbGVjdGVkQ2FsaWZvcm5pYVZpZXcuQ2FsaWZvcm5pYVZpZXdJZC50b1N0cmluZygpO1xyXG4gICAgICAgIGxldCB2aWV3Q29udHJvbHNCdXR0b25Ib2xkZXJTdHlsZXMgPSB7XHJcbiAgICAgICAgICAgIFwiZmxleFwiOiBcIjAgMCBhdXRvXCIsXHJcbiAgICAgICAgICAgIFwiaGVpZ2h0XCI6IFwiYXV0b1wiXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgdmlld0NvbnRyb2xzQm94VHJlZUhvbGRlclN0eWxlcyA9IHtcclxuICAgICAgICAgICAgLypUT0RPIG5lZWQgc2V0IGFsbCBkaXYgc3R5bGVzIHdpZHRoL2hlaWdodCBpbiB0aGlzIGJveCB0byBlaXRoZXIgdW5kZWZpbmVkIG9yIHZhbHVlIC8vIFRPRE8gZG8gZXZlcnl3aGVyZSEhKi9cclxuICAgICAgICAgICAgXCJmbGV4XCI6IFwiMSAxIDFweFwiLFxyXG4gICAgICAgICAgICBcIndpZHRoXCI6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICBcImhlaWdodFwiOiBcImF1dG9cIixcclxuICAgICAgICAgICAgXCJvdmVyZmxvd1wiOiBcInNjcm9sbFwiXHJcbiAgICAgICAgfTsvLyBUT0RPIGFwcGxpZWQgYXQgbWFueSBwbGFjZXM6IGNvZGUgc2Vuc2UgZm9yIHVzYWdlIG9mIGJveFRyZWVQcm9qZWN0b3Igc2hvdWxkIGJlIGNvdXBsZWQgd2l0aCByZW5kZXJCb3hUcmVlIHJvdXRpbmVcclxuICAgICAgICBsZXQgaXNTeW5jV2l0aFByZXZpZXdBY3RpdmU6IGJvb2xlYW4gPSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5wcm9wZXJ0eUJhckluZGV4ID09IDA7XHJcbiAgICAgICAgbGV0IGlzU3luY1dpdGhMZWZ0QWN0aXZlOiBib29sZWFuID0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIucHJvcGVydHlCYXJJbmRleCAhPSAwO1xyXG4gICAgICAgIGxldCBpc0RyYXdIZWxwZXJMaW5lc0FjdGl2ZTogYm9vbGVhbiA9IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXggPT0gMDtcclxuICAgICAgICBsZXQgc3luY1dpdGhMZWZ0Qm94VHJlZUJ1dHRvblN0eWxlcyA9IHtcclxuICAgICAgICAgICAgXCJvdXRsaW5lXCI6ICFpc1N5bmNXaXRoTGVmdEFjdGl2ZSA/IHVuZGVmaW5lZCA6IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5pc1N5bmNlZFdpdGhCb3hUcmVlVG9UaGVMZWZ0ID8gXCJzb2xpZCAxcHggcmdiKDIwMCwwLDApXCIgOiBcInNvbGlkIDFweCByZ2IoMCwyNDIsMClcIixcclxuICAgICAgICAgICAgXCJvdXRsaW5lLW9mZnNldFwiOiAhaXNTeW5jV2l0aExlZnRBY3RpdmUgPyB1bmRlZmluZWQgOiBcIi0xcHhcIlxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHN5bmNXaXRoUHJldmlld0J1dHRvblN0eWxlcyA9IHtcclxuICAgICAgICAgICAgXCJvdXRsaW5lXCI6ICFpc1N5bmNXaXRoUHJldmlld0FjdGl2ZSA/IHVuZGVmaW5lZCA6IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5pc1N5bmNlZFdpdGhQYWdlUHJldmlldyA/IFwic29saWQgMXB4IHJnYigyMDAsMCwwKVwiIDogXCJzb2xpZCAxcHggcmdiKDAsMjQyLDApXCIsXHJcbiAgICAgICAgICAgIFwib3V0bGluZS1vZmZzZXRcIjogIWlzU3luY1dpdGhQcmV2aWV3QWN0aXZlID8gdW5kZWZpbmVkIDogXCItMXB4XCJcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBkcmF3SGVscGVyTGluZXNCdXR0b25TdHlsZXMgPSB7XHJcbiAgICAgICAgICAgIFwib3V0bGluZVwiOiAhaXNEcmF3SGVscGVyTGluZXNBY3RpdmUgPyB1bmRlZmluZWQgOiBjdXJyZW50QXBwLnN0YXRlLmlzRHJhd0hlbHBlckxpbmVzID8gXCJzb2xpZCAxcHggcmdiKDIwMCwwLDApXCIgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIFwib3V0bGluZS1vZmZzZXRcIjogIWlzRHJhd0hlbHBlckxpbmVzQWN0aXZlID8gdW5kZWZpbmVkIDogXCItMXB4XCJcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiA8ZGl2IHN0eWxlcz17eyBcIndpZHRoXCI6IFwiMTAwJVwiLCBcImhlaWdodFwiOiBcIjEwMCVcIiwgXCJkaXNwbGF5XCI6IFwiZmxleFwiLCBcImZsZXgtZmxvd1wiOiBcImNvbHVtbiBub3dyYXBcIiB9fT4gVmlldyAje2NhbGlmb3JuaWFWaWV3SWRTdHJpbmd9XHJcbiAgICAgICAgICAgIDxkaXYga2V5PVwiMFwiIHN0eWxlcz17dmlld0NvbnRyb2xzQnV0dG9uSG9sZGVyU3R5bGVzfT5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiYVwiIG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLmluc2VydExheW91dFJvd0ludG9WaWV3Q2xpY2tIYW5kbGVyfT4rKFIpPC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImJcIiBtaWQ9e3NlbGVjdGVkQ2FsaWZvcm5pYVZpZXcuU3BlY2lhbFN0eWxlVmlld1N0eWxlTW9sZWN1bGVJZFN0cmluZ30gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2VsZWN0U3R5bGVNb2xlY3VsZUNsaWNrSGFuZGxlcn0+c3R5bGUgI3tzZWxlY3RlZENhbGlmb3JuaWFWaWV3LlNwZWNpYWxTdHlsZVZpZXdTdHlsZU1vbGVjdWxlSWRTdHJpbmd9PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGtleT1cImNcIiBtaWQ9e3NlbGVjdGVkQ2FsaWZvcm5pYVZpZXcuU3BlY2lhbFN0eWxlQm9keVN0eWxlTW9sZWN1bGVJZFN0cmluZ30gb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuc2VsZWN0U3R5bGVNb2xlY3VsZUNsaWNrSGFuZGxlcn0+Ym9keSBzdHlsZSAje3NlbGVjdGVkQ2FsaWZvcm5pYVZpZXcuU3BlY2lhbFN0eWxlQm9keVN0eWxlTW9sZWN1bGVJZFN0cmluZ308L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgIDxidXR0b24ga2V5PVwiZFwiIG1pZD17c2VsZWN0ZWRDYWxpZm9ybmlhVmlldy5TcGVjaWFsU3R5bGVIdG1sU3R5bGVNb2xlY3VsZUlkU3RyaW5nfSBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zZWxlY3RTdHlsZU1vbGVjdWxlQ2xpY2tIYW5kbGVyfT5IVE1MIHN0eWxlICN7c2VsZWN0ZWRDYWxpZm9ybmlhVmlldy5TcGVjaWFsU3R5bGVIdG1sU3R5bGVNb2xlY3VsZUlkU3RyaW5nfTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBrZXk9XCJlXCIgb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIucmVzZXRQcmVzZWxlY3RlZExheW91dENsaWNrSGFuZGxlcn0+bzwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAge2lzRHJhd0hlbHBlckxpbmVzQWN0aXZlID8gPGJ1dHRvbiBrZXk9XCJmXCIgb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZHJhd0hlbHBlckxpbmVzQ2xpY2tIYW5kbGVyfSBzdHlsZXM9e2RyYXdIZWxwZXJMaW5lc0J1dHRvblN0eWxlc30+XFwtXFw8L2J1dHRvbj4gOiA8YnV0dG9uIGRpc2FibGVkIGtleT1cImYwXCIgb25jbGljaz17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuZHJhd0hlbHBlckxpbmVzQ2xpY2tIYW5kbGVyfSBzdHlsZXM9e2RyYXdIZWxwZXJMaW5lc0J1dHRvblN0eWxlc30+XFwtXFw8L2J1dHRvbj59XHJcbiAgICAgICAgICAgICAgICB7aXNTeW5jV2l0aFByZXZpZXdBY3RpdmUgPyA8YnV0dG9uIGtleT1cImdcIiBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zeW5jV2l0aFBhZ2VQcmV2aWV3Q2xpY2tIYW5kbGVyfSBzdHlsZXM9e3N5bmNXaXRoUHJldmlld0J1dHRvblN0eWxlc30+LT0tPC9idXR0b24+IDogPGJ1dHRvbiBkaXNhYmxlZCBrZXk9XCJnMFwiIG9uY2xpY2s9e3RoaXMuY3VycmVudFByb3BlcnR5QmFyLnN5bmNXaXRoUGFnZVByZXZpZXdDbGlja0hhbmRsZXJ9IHN0eWxlcz17c3luY1dpdGhQcmV2aWV3QnV0dG9uU3R5bGVzfT4tPS08L2J1dHRvbj59XHJcbiAgICAgICAgICAgICAgICB7aXNTeW5jV2l0aExlZnRBY3RpdmUgPyA8YnV0dG9uIGtleT1cImhcIiBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zeW5jV2l0aExlZnRQcm9wZXJ0eUJhckNsaWNrSGFuZGxlcn0gc3R5bGVzPXtzeW5jV2l0aExlZnRCb3hUcmVlQnV0dG9uU3R5bGVzfT49PTwvYnV0dG9uPiA6IDxidXR0b24gZGlzYWJsZWQga2V5PVwiaDBcIiBvbmNsaWNrPXt0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zeW5jV2l0aExlZnRQcm9wZXJ0eUJhckNsaWNrSGFuZGxlcn0gc3R5bGVzPXtzeW5jV2l0aExlZnRCb3hUcmVlQnV0dG9uU3R5bGVzfT49PTwvYnV0dG9uPn1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYga2V5PVwiMVwiXHJcbiAgICAgICAgICAgICAgICBzdHlsZXM9e3ZpZXdDb250cm9sc0JveFRyZWVIb2xkZXJTdHlsZXN9XHJcbiAgICAgICAgICAgICAgICBvbnNjcm9sbD17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuYm94VHJlZVNjcm9sbEhhbmRsZXJ9XHJcbiAgICAgICAgICAgICAgICBhZnRlckNyZWF0ZT17dGhpcy5jdXJyZW50UHJvcGVydHlCYXIuYm94VHJlZUFmdGVyQ3JlYXRlSGFuZGxlcn0+XHJcbiAgICAgICAgICAgICAgICB7dGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmJveFRyZWVQcm9qZWN0b3IucmVzdWx0cy5tYXAociA9PiByLnJlbmRlck1hcXVldHRlKCkpfVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj4gYXMgVk5vZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgYm94VHJlZVNjcm9sbEhhbmRsZXIgPSAoZXZ0OiBVSUV2ZW50KSA9PiB7XHJcbiAgICAgICAgLy8gVE9ETyBpbnN0ZWFkOiByZW5kZXIgaW4gc2FtZSBkaXYgdG8gc3luY2hyb25pemUgc2Nyb2xsXHJcbiAgICAgICAgLy8gVE9ETyBmaXggYnVnID0+IGJhZCBoYW5kbGluZyB3aGVuIHVzaW5nIHNjcm9sbCBiYXJzIGluIGVkZ2UuLi5cclxuICAgICAgICAvLyBUT0RPIGthbGVpZG9zY29wZSBlZmZlY3Qgc2VsZWN0aW9uIC8gYm94dHJlZSBkaXNwbGF5IHJhbmdlXHJcbiAgICAgICAgLy8gVE9ETyB0ZXN0IGNhc2U6IHNob3cgNCBib3ggdHJlZXMgIzEtIzQsIG1vdmUgIzIsIHN5bmMgdG8gbGVmdCAoIzEgcmVhZHMgZnJvbSAjMiksIG1vdmUgIzQsIHN5bmMgdG8gbGVmdCAoIzMgcmVhZHMgZnJvbSAjNCksIHRoZW4gYWN0aXZhdGUgc3luYyB0byBsZWZ0IGluICMzID0+IGFsbCBtb3ZlbWVudHMgc2hvdWxkIGJlIHN5bmNlZFxyXG4gICAgICAgIC8vIC0tLSBzeW5jIHNjcm9sbCB3aXRoIG90aGVyIHByb3BlcnR5IGJhcnMgLS0tXHJcbiAgICAgICAgbGV0IGN1cnJlbnRQcm9wZXJ0eUJhckluZGV4OiBudW1iZXIgPSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5wcm9wZXJ0eUJhckluZGV4O1xyXG4gICAgICAgIGxldCBjdXJyZW50U2Nyb2xsRG9tOiBIVE1MRGl2RWxlbWVudCB8IHVuZGVmaW5lZCA9IGN1cnJlbnRBcHAucHJvcGVydHlCYXJCb3hUcmVlRG9tUmVmZXJlbmNlc1tjdXJyZW50UHJvcGVydHlCYXJJbmRleF0gYXMgSFRNTERpdkVsZW1lbnQgLypUT0RPIGNhc3QgdW5zYWZlKi87XHJcbiAgICAgICAgaWYgKGN1cnJlbnRBcHAuc3RhdGUudmlzaWJsZVByb3BlcnR5QmFyTWF4Q291bnQgPiAxICYmIGN1cnJlbnRBcHAucHJvcGVydHlCYXJCb3hUcmVlU2Nyb2xsSGFuZGxlZFtjdXJyZW50UHJvcGVydHlCYXJJbmRleF0gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAucHJvcGVydHlCYXJCb3hUcmVlU2Nyb2xsSGFuZGxlZFtjdXJyZW50UHJvcGVydHlCYXJJbmRleF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwib25zY3JvbGwgZm9yIHByb3BlcnR5IGJhciAjXCIgKyB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5wcm9wZXJ0eUJhckluZGV4ICsgXCIgdG9cIiArIChldnQudGFyZ2V0IGFzIEhUTUxEaXZFbGVtZW50KS5zY3JvbGxUb3AgKyBcIiBmcm9tIG1heCBoZWlnaHRcIiArIChldnQudGFyZ2V0IGFzIEhUTUxEaXZFbGVtZW50KS5zY3JvbGxIZWlnaHQgKyBcIiwgZGlmZjogXCIgKyAoKGV2dC50YXJnZXQgYXMgSFRNTERpdkVsZW1lbnQpLnNjcm9sbEhlaWdodCAtIChldnQudGFyZ2V0IGFzIEhUTUxEaXZFbGVtZW50KS5zY3JvbGxUb3ApLnRvU3RyaW5nKCkgKyBcIiwgZXhwZWN0ZWQgYXQgbWF4IHNjcm9sbDogXCIgKyAoZXZ0LnRhcmdldCBhcyBIVE1MRGl2RWxlbWVudCkuY2xpZW50SGVpZ2h0KTtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRWaWV3TW9kZWw6IFByb3BlcnR5QmFyVk0gPSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWw7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50U2Nyb2xsRG9tID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgcHJvZ3Jlc3NpbmdQcm9wZXJ0eUJhckluZGV4OiBudW1iZXIgPSBjdXJyZW50UHJvcGVydHlCYXJJbmRleDtcclxuICAgICAgICAgICAgLy8gc3luYyB3aXRoIGxlZnQgKyBwcm9ncmVzc2lvbiB0byBsZWZ0XHJcbiAgICAgICAgICAgIGxldCBpc0tlZXBHb2luZ0xlZnQ6IGJvb2xlYW4gPSBjdXJyZW50UHJvcGVydHlCYXJJbmRleCA+IDA7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50SXRlcmF0aW9uOiBudW1iZXIgPSAwO1xyXG4gICAgICAgICAgICBsZXQgbWF4SXRlcmF0aW9uOiBudW1iZXIgPSBjdXJyZW50UHJvcGVydHlCYXJJbmRleCAtIDE7XHJcbiAgICAgICAgICAgIHdoaWxlIChpc0tlZXBHb2luZ0xlZnQgPT09IHRydWUgJiYgcHJvZ3Jlc3NpbmdQcm9wZXJ0eUJhckluZGV4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBcHAucHJvcGVydHlCYXJWTXNbcHJvZ3Jlc3NpbmdQcm9wZXJ0eUJhckluZGV4XS5pc1N5bmNlZFdpdGhCb3hUcmVlVG9UaGVMZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldFNjcm9sbERvbTogSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQgPSBjdXJyZW50QXBwLnByb3BlcnR5QmFyQm94VHJlZURvbVJlZmVyZW5jZXNbcHJvZ3Jlc3NpbmdQcm9wZXJ0eUJhckluZGV4IC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkxFRlQ6IGN1cnJlbnQ6IFwiICsgY3VycmVudFNjcm9sbERvbS5zY3JvbGxUb3AgKyBcIiwgcHJldjogXCIgKyAodGFyZ2V0U2Nyb2xsRG9tIGFzIEhUTUxEaXZFbGVtZW50KS5zY3JvbGxUb3ApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRTY3JvbGxEb20gIT09IHVuZGVmaW5lZCAmJiB0YXJnZXRTY3JvbGxEb20uc2Nyb2xsVG9wICE9IGN1cnJlbnRTY3JvbGxEb20uc2Nyb2xsVG9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucHJvcGVydHlCYXJCb3hUcmVlU2Nyb2xsSGFuZGxlZFtwcm9ncmVzc2luZ1Byb3BlcnR5QmFySW5kZXggLSAxXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFNjcm9sbERvbS5zY3JvbGxUb3AgPSBjdXJyZW50U2Nyb2xsRG9tLnNjcm9sbFRvcDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpc0tlZXBHb2luZ0xlZnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SXRlcmF0aW9uID4gbWF4SXRlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NpbmdQcm9wZXJ0eUJhckluZGV4LS07XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50SXRlcmF0aW9uKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc3luYyB3aXRoIHJpZ2h0ICsgcHJvZ3Jlc3Npb24gdG8gcmlnaHRcclxuICAgICAgICAgICAgcHJvZ3Jlc3NpbmdQcm9wZXJ0eUJhckluZGV4ID0gY3VycmVudFByb3BlcnR5QmFySW5kZXggKyAxO1xyXG4gICAgICAgICAgICBsZXQgaXNLZWVwR29pbmdSaWdodDogYm9vbGVhbiA9IHRydWU7XHJcbiAgICAgICAgICAgIGN1cnJlbnRJdGVyYXRpb24gPSAwO1xyXG4gICAgICAgICAgICBtYXhJdGVyYXRpb24gPSAoY3VycmVudEFwcC5zdGF0ZS52aXNpYmxlUHJvcGVydHlCYXJNYXhDb3VudCAtIDEpIC0gY3VycmVudFByb3BlcnR5QmFySW5kZXg7XHJcbiAgICAgICAgICAgIHdoaWxlIChpc0tlZXBHb2luZ1JpZ2h0ID09PSB0cnVlICYmIHByb2dyZXNzaW5nUHJvcGVydHlCYXJJbmRleCA8IGN1cnJlbnRBcHAuc3RhdGUudmlzaWJsZVByb3BlcnR5QmFyTWF4Q291bnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QXBwLnByb3BlcnR5QmFyVk1zW3Byb2dyZXNzaW5nUHJvcGVydHlCYXJJbmRleF0uaXNTeW5jZWRXaXRoQm94VHJlZVRvVGhlTGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRTY3JvbGxEb206IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkID0gY3VycmVudEFwcC5wcm9wZXJ0eUJhckJveFRyZWVEb21SZWZlcmVuY2VzW3Byb2dyZXNzaW5nUHJvcGVydHlCYXJJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlJJR0hUOiBjdXJyZW50OiBcIiArIGN1cnJlbnRTY3JvbGxEb20uc2Nyb2xsVG9wICsgXCIsIHByZXY6IFwiICsgKHRhcmdldFNjcm9sbERvbSBhcyBIVE1MRGl2RWxlbWVudCkuc2Nyb2xsVG9wKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0U2Nyb2xsRG9tICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0U2Nyb2xsRG9tLnNjcm9sbFRvcCAhPSBjdXJyZW50U2Nyb2xsRG9tLnNjcm9sbFRvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnByb3BlcnR5QmFyQm94VHJlZVNjcm9sbEhhbmRsZWRbcHJvZ3Jlc3NpbmdQcm9wZXJ0eUJhckluZGV4XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFNjcm9sbERvbS5zY3JvbGxUb3AgPSBjdXJyZW50U2Nyb2xsRG9tLnNjcm9sbFRvcDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpc0tlZXBHb2luZ1JpZ2h0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEl0ZXJhdGlvbiA+IG1heEl0ZXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByb2dyZXNzaW5nUHJvcGVydHlCYXJJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEl0ZXJhdGlvbisrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJvbnNjcm9sbCBlbmQgZm9yIHByb3BlcnR5IGJhciAjXCIgKyBjdXJyZW50UHJvcGVydHlCYXJJbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRBcHAuc3RhdGUudmlzaWJsZVByb3BlcnR5QmFyTWF4Q291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEFwcC5wcm9wZXJ0eUJhckJveFRyZWVTY3JvbGxIYW5kbGVkW2ldID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gLS0tIHN5bmMgdmlzaWJsZSBlbGVtZW50cyAtLS1cclxuICAgICAgICBpZiAoY3VycmVudFByb3BlcnR5QmFySW5kZXggPT0gMCAmJiB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWwuaXNTeW5jZWRXaXRoUGFnZVByZXZpZXcpIHtcclxuICAgICAgICAgICAgLy8gVE9ETyBjYWxsZWQgdG9vIG9mdGVuIFRPRE8gaW5pdGlhbCByZW5kZXJcclxuICAgICAgICAgICAgLy8gdXBkYXRlIHZpc2libGUgbGF5b3V0IGF0b20gZG9tIG5vZGUgcmVmZXJlbmNlc1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5fdmlzaWJsZUxheW91dEF0b21Eb21Ob2RlUmVmZXJlbmNlcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5fdmlzaWJsZUxheW91dEF0b21LZXlzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLl9tb3N0VXBwZXJWaXNpYmxlTGF5b3V0QXRvbUlkID0gMDtcclxuICAgICAgICAgICAgbGV0IHByb2Nlc3NlZEVsZW1lbnRDb3VudDogbnVtYmVyID0gMDtcclxuICAgICAgICAgICAgbGV0IG1vc3RVcHBlclZpc2libGVJbmRleDogbnVtYmVyID0gLTE7XHJcbiAgICAgICAgICAgIGxldCBtb3N0VXBwZXJWaXNpYmxlTGF5b3V0QXRvbUlkOiBudW1iZXIgPSAwO1xyXG4gICAgICAgICAgICBsZXQgbW9zdFVwcGVyVmlzaWJsZURlbHRhVG9wTGVmdDogbnVtYmVyID0gY3VycmVudFNjcm9sbERvbS5jbGllbnRIZWlnaHQgKyAxOyAvLyBvdGhlcndpc2UgZWxlbWVudCBpcyBiZWxvdyB2aXNpYmxlIGFyZWFcclxuICAgICAgICAgICAgbGV0IHN0YXRpY09mZnNldFB4OiBudW1iZXIgPSBjdXJyZW50U2Nyb2xsRG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDsgLy8gVE9ETyBldmVyeXdoZXJlOiBwaXhlbCBhbGlhc2luZyBhcmUgbWF5YmUgYmVjYXVzZSBjb21wYXJpbmcgbm90IG51bWVyaWNhbGx5LCBidXQgc3RyaWN0bHkgKGVwcylcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnRTY3JvbGxUb3A6IG51bWJlciA9IGN1cnJlbnRTY3JvbGxEb20uc2Nyb2xsVG9wO1xyXG4gICAgICAgICAgICBsZXQgbWluWFByZXZpZXc6IG51bWJlciA9IDA7IC8vIDAgYmFzZWQgZm9yIHRvcCBsZWZ0IGNvcm5lciBpbiB2aWV3cG9ydC9wYWdlcHJldmlld1xyXG4gICAgICAgICAgICBsZXQgbWF4WFByZXZpZXc6IG51bWJlciA9IGN1cnJlbnRTY3JvbGxEb20uY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwic2Nyb2xsZWQgYm94dHJlZSB0b1wiICsgY3VycmVudFNjcm9sbFRvcCArIFwiIGF0IGNsaWVudCBoZWlnaHQgXCIgKyBwYWdlUHJldmlld0hvbGRlci5jbGllbnRIZWlnaHQgKyBcIiBmcm9tIG1heCBoZWlnaHRcIiArIHBhZ2VQcmV2aWV3SG9sZGVyLnNjcm9sbEhlaWdodCAgKyBcIiBtaW5YIFwiICsgbWluWFByZXZpZXcgKyBcIiBtYXhYXCIgKyBtYXhYUHJldmlldyk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGVsZW1lbnRLZXkgaW4gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuX2FjdGl2ZVZpZXdMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gb3JkZXIgYWxsIGxheW91dCBlbGVtZW50cyBhbmQgcHJvY2VzcyBvbmx5IHNwZWNpZmljIHJhbmdlIG9yIG1vdmUgcHJvY2Vzc2luZyByYW5nZSB3aXRoIHNjcm9sbFxyXG4gICAgICAgICAgICAgICAgbGV0IGRvbU5vZGU6IEhUTUxFbGVtZW50ID0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuX2FjdGl2ZVZpZXdMYXlvdXRBdG9tRG9tTm9kZVJlZmVyZW5jZXNbZWxlbWVudEtleV07XHJcbiAgICAgICAgICAgICAgICBsZXQgaXNEb21Ob2RlVmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcInByb2Nlc3NpbmcgZWxlbWVudDogY2xpZW50VG9wIFwiICsgZG9tTm9kZS5jbGllbnRIZWlnaHQgKyBcIiwgb2Zmc2V0VG9wIFwiICsgZG9tTm9kZS5vZmZzZXRUb3ApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJvdW5kaW5nUmVjdEVsZW1lbnQ6IENsaWVudFJlY3QgPSBkb21Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgLy9sZXQgZmlyc3RDbGllbnRSZWN0RWxlbWVudDogQ2xpZW50UmVjdCA9IGRvbU5vZGUuZ2V0Q2xpZW50UmVjdHMoKVswXTtcclxuICAgICAgICAgICAgICAgIGxldCBtaW5YRWxlbWVudERlbHRhVG9wTGVmdDogbnVtYmVyID0gYm91bmRpbmdSZWN0RWxlbWVudC50b3AgLSBzdGF0aWNPZmZzZXRQeDtcclxuICAgICAgICAgICAgICAgIGxldCBtYXhYRWxlbWVudERlbHRhQm90dG9tTGVmdDogbnVtYmVyID0gY3VycmVudFNjcm9sbERvbS5jbGllbnRIZWlnaHQgLSAoYm91bmRpbmdSZWN0RWxlbWVudC50b3AgLSBzdGF0aWNPZmZzZXRQeCArIGN1cnJlbnRTY3JvbGxUb3AgKyBib3VuZGluZ1JlY3RFbGVtZW50LmhlaWdodCkgKyBjdXJyZW50U2Nyb2xsVG9wO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvdW5kaW5nUmVjdEVsZW1lbnQuaGVpZ2h0ID4gMCkgeyAvLyBoZWlnaHQgY2FuIGJlIDAgPT4gaW52aXNpYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pblhFbGVtZW50RGVsdGFUb3BMZWZ0ID49IDAuMCAmJiBtaW5YRWxlbWVudERlbHRhVG9wTGVmdCA8PSBjdXJyZW50U2Nyb2xsRG9tLmNsaWVudEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RvbU5vZGVWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWF4WEVsZW1lbnREZWx0YUJvdHRvbUxlZnQgPj0gMC4wICYmIG1heFhFbGVtZW50RGVsdGFCb3R0b21MZWZ0IDw9IGN1cnJlbnRTY3JvbGxEb20uY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRG9tTm9kZVZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtaW5YRWxlbWVudERlbHRhVG9wTGVmdCA8PSAwLjAgJiYgbWF4WEVsZW1lbnREZWx0YUJvdHRvbUxlZnQgPD0gMC4wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRG9tTm9kZVZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJlbGVtZW50OiBib3VuZGluZyByZWN0IHRvcCBcIiArIGJvdW5kaW5nUmVjdEVsZW1lbnQudG9wICsgXCIsIHJlY3QgYm90dG9tIFwiICsgYm91bmRpbmdSZWN0RWxlbWVudC5ib3R0b20gKyBcIiwgbWluWEVsZW1lbnREZWx0YVRvcExlZnQ6IFwiICsgbWluWEVsZW1lbnREZWx0YVRvcExlZnQgKyBcIiwgbWF4WEVsZW1lbnREZWx0YUJvdHRvbUxlZnQ6IFwiICsgbWF4WEVsZW1lbnREZWx0YUJvdHRvbUxlZnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRG9tTm9kZVZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5fdmlzaWJsZUxheW91dEF0b21Eb21Ob2RlUmVmZXJlbmNlcy5wdXNoKGRvbU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLl92aXNpYmxlTGF5b3V0QXRvbUtleXMucHVzaChlbGVtZW50S2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwidmlzaWJsZSBlbGVtZW50OiBmaXJzdCBjbGllbnQgcmVjdCB0b3AgXCIgKyBmaXJzdENsaWVudFJlY3RFbGVtZW50LnRvcCArIFwiLCByZWN0IGJvdHRvbSBcIiArIGZpcnN0Q2xpZW50UmVjdEVsZW1lbnQuYm90dG9tKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWluWEVsZW1lbnREZWx0YVRvcExlZnQgPCBtb3N0VXBwZXJWaXNpYmxlRGVsdGFUb3BMZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vc3RVcHBlclZpc2libGVEZWx0YVRvcExlZnQgPSBtaW5YRWxlbWVudERlbHRhVG9wTGVmdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9zdFVwcGVyVmlzaWJsZUluZGV4ID0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuX3Zpc2libGVMYXlvdXRBdG9tS2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vc3RVcHBlclZpc2libGVMYXlvdXRBdG9tSWQgPSBwYXJzZUludEZyb21BdHRyaWJ1dGUoZG9tTm9kZSwgXCJsaWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkRWxlbWVudENvdW50Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1vc3RVcHBlclZpc2libGVMYXlvdXRBdG9tSWQgIT0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIuX21vc3RVcHBlclZpc2libGVMYXlvdXRBdG9tSWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLl9tb3N0VXBwZXJWaXNpYmxlTGF5b3V0QXRvbUlkID0gbW9zdFVwcGVyVmlzaWJsZUxheW91dEF0b21JZDtcclxuICAgICAgICAgICAgICAgIGlmIChtb3N0VXBwZXJWaXNpYmxlTGF5b3V0QXRvbUlkICE9IDAgJiYgdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsLmlzU3luY2VkV2l0aFBhZ2VQcmV2aWV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5wYWdlUHJldmlldy5zeW5jU2Nyb2xsUG9zaXRpb25Gcm9tQm94VHJlZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJib3hUcmVlIHNjcm9sbDogcHJvY2Vzc2VkIFwiICsgcHJvY2Vzc2VkRWxlbWVudENvdW50ICsgXCIgb2JqZWN0IHBvc2l0aW9ucywgdmlzaWJsZTogXCIgKyB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5fdmlzaWJsZUxheW91dEF0b21Eb21Ob2RlUmVmZXJlbmNlcy5sZW5ndGgudG9TdHJpbmcoKSArIFwiIG1vc3QgdXBwZXIgdmlzaWJsZSBpbmRleDogXCIgKyBtb3N0VXBwZXJWaXNpYmxlSW5kZXggKyBcIiBtb3N0IHVwcGVyIHZpc2libGUgbGF5b3V0IGlkOiBcIiArIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLl9tb3N0VXBwZXJWaXNpYmxlTGF5b3V0QXRvbUlkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzeW5jU2Nyb2xsUG9zaXRpb25Gcm9tUGFnZVByZXZpZXcgPSAoKTogdm9pZCA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnZpZXdNb2RlbC5pc1N5bmNlZFdpdGhQYWdlUHJldmlldykge1xyXG4gICAgICAgICAgICBsZXQgY3VycmVudFByb3BlcnR5QmFySW5kZXg6IG51bWJlciA9IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXg7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50U2Nyb2xsRG9tOiBIVE1MRGl2RWxlbWVudCB8IHVuZGVmaW5lZCA9IGN1cnJlbnRBcHAucHJvcGVydHlCYXJCb3hUcmVlRG9tUmVmZXJlbmNlc1tjdXJyZW50UHJvcGVydHlCYXJJbmRleF07XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50U2Nyb2xsRG9tICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzdGF0aWNPZmZzZXRQeDogbnVtYmVyID0gY3VycmVudFNjcm9sbERvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0TGF5b3V0QXRvbUlkOiBudW1iZXIgPSBjdXJyZW50QXBwLnBhZ2VQcmV2aWV3Lm1vc3RVcHBlclZpc2libGVMYXlvdXRBdG9tSWQ7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInRyZWUgZnJvbSBwcmV2aWV3IGZvciB0YXJnZXQgbGF5b3V0ICNcIiArIHRhcmdldExheW91dEF0b21JZCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZG9tTm9kZU9mVGFyZ2V0TGF5b3V0OiBIVE1MRWxlbWVudCB8IHVuZGVmaW5lZCA9IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLl92aXNpYmxlTGF5b3V0QXRvbURvbU5vZGVSZWZlcmVuY2VzLmZpbmQociA9PiBwYXJzZUludEZyb21BdHRyaWJ1dGUociwgXCJsaWRcIiAvKlRPRE8gdXNlIGRpY3QqLykgPT0gdGFyZ2V0TGF5b3V0QXRvbUlkKTtcclxuICAgICAgICAgICAgICAgIGlmIChkb21Ob2RlT2ZUYXJnZXRMYXlvdXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGVPZlRhcmdldExheW91dCA9IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLl9hY3RpdmVWaWV3TGF5b3V0QXRvbURvbU5vZGVSZWZlcmVuY2VzW3RhcmdldExheW91dEF0b21JZF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9tTm9kZU9mVGFyZ2V0TGF5b3V0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Nyb2xsRG9tLnNjcm9sbFRvcCA9IGN1cnJlbnRTY3JvbGxEb20uc2Nyb2xsVG9wICsgKGRvbU5vZGVPZlRhcmdldExheW91dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgLSBzdGF0aWNPZmZzZXRQeCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhERUZBVUxUX0VYQ0VQVElPTik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHRlc3Qgd2hlbiB0aGlzIGhhcHBlbnMgYW5kIGZpeFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIGJveFRyZWVBZnRlckNyZWF0ZUhhbmRsZXIgPSAoZWxlbWVudDogRWxlbWVudCwgcHJvamVjdGlvbk9wdGlvbnM6IG1hcXVldHRlLlByb2plY3Rpb25PcHRpb25zLCB2bm9kZVNlbGVjdG9yOiBzdHJpbmcsIHByb3BlcnRpZXM6IG1hcXVldHRlLlZOb2RlUHJvcGVydGllcywgY2hpbGRyZW46IFZOb2RlW10pID0+IHtcclxuICAgICAgICBjdXJyZW50QXBwLnByb3BlcnR5QmFyQm94VHJlZURvbVJlZmVyZW5jZXNbdGhpcy5jdXJyZW50UHJvcGVydHlCYXIucHJvcGVydHlCYXJJbmRleF0gPSBlbGVtZW50IGFzIEhUTUxEaXZFbGVtZW50O1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgZGVsZXRlQ2FsaWZvcm5pYVZpZXdDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IGRlbGV0ZUNhbGlmb3JuaWFWaWV3SWQ6IG51bWJlciA9IHBhcnNlSW50RnJvbUF0dHJpYnV0ZShldnQudGFyZ2V0LCBcInZpZFwiKTtcclxuICAgICAgICAvLyBUT0RPIGFsc28gbmVlZCB0byBjbGVhciBzdHVmZiB0aGF0IGlzIGNvbm5lY3RlZCB0byB2aWV3Li4gc2VsZWN0ZWQgc3BlY2lhbCBzdHlsZSBldGMuXHJcbiAgICAgICAgY3VycmVudEFwcC5yb3V0ZXIuY2xlYXJDYWxpZm9ybmlhUHJvcGVydHlCYXJzKGZhbHNlLCBkZWxldGVDYWxpZm9ybmlhVmlld0lkKTtcclxuICAgICAgICBjdXJyZW50QXBwLmNvbnRyb2xsZXIuRGVsZXRlQ2FsaWZvcm5pYVZpZXdKc29uKGRlbGV0ZUNhbGlmb3JuaWFWaWV3SWQpLmRvbmUoZGF0YSA9PiBjdXJyZW50QXBwLnJvdXRlci51cGRhdGVEYXRhKGRhdGEpKTtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGluc2VydExheW91dFJvd0ludG9WaWV3Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFByb3BlcnR5QmFyLmRpc3BsYXlQb3B1cChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50LCBQb3B1cE1vZGUuSW5zZXJ0TGF5b3V0Um93SW50b1ZpZXcpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIHJlc2V0UHJlc2VsZWN0ZWRMYXlvdXRDbGlja0hhbmRsZXIgPSAoZXZ0OiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5wcmVzZWxlY3RlZExheW91dEJhc2VJZCA9IDA7XHJcbiAgICB9O1xyXG5cclxuICAgIHByaXZhdGUgZHJhd0hlbHBlckxpbmVzQ2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIC8vIFRPRE8gc21vb3RoIGxpbmUgdXBkYXRlIHdoZW4gc2Nyb2xsaW5nOiB1c2UgY3NzIHRyYW5zZm9ybSB0byBjaGFuZ2Ugc3RhcnQvZW5kIG5vZGUgZGVwZW5kZW50IG9uIHNjcm9sbGVkIGRpc3RhbmNlK3dpbmRvd1xyXG4gICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuaXNEcmF3SGVscGVyTGluZXMgPSAhY3VycmVudEFwcC5zdGF0ZS5pc0RyYXdIZWxwZXJMaW5lcztcclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBzeW5jV2l0aFBhZ2VQcmV2aWV3Q2xpY2tIYW5kbGVyID0gKGV2dDogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICAgIC8vIG9ubHkgZm9yIHRoZSBmaXJzdCBwcm9wZXJ0eSBiYXIsIHRvZ2dsZSAvLyBUT0RPIGRvY3VtZW50XHJcbiAgICAgICAgbGV0IGN1cnJlbnRQcm9wZXJ0eUJhckluZGV4OiBudW1iZXIgPSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5wcm9wZXJ0eUJhckluZGV4O1xyXG4gICAgICAgIGxldCBjdXJyZW50Vmlld01vZGVsOiBQcm9wZXJ0eUJhclZNID0gdGhpcy5jdXJyZW50UHJvcGVydHlCYXIudmlld01vZGVsO1xyXG4gICAgICAgIGlmIChjdXJyZW50UHJvcGVydHlCYXJJbmRleCA9PSAwKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRWaWV3TW9kZWwuaXNTeW5jZWRXaXRoUGFnZVByZXZpZXcgPSAhY3VycmVudFZpZXdNb2RlbC5pc1N5bmNlZFdpdGhQYWdlUHJldmlldztcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRWaWV3TW9kZWwuaXNTeW5jZWRXaXRoUGFnZVByZXZpZXcpIHtcclxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWwgc3luYyBzY3JvbGwgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50Qm94VHJlZURvbVJlZmVyZW5jZTogSFRNTEVsZW1lbnQgfCB1bmRlZmluZWQgPSBjdXJyZW50QXBwLnByb3BlcnR5QmFyQm94VHJlZURvbVJlZmVyZW5jZXNbY3VycmVudFByb3BlcnR5QmFySW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRCb3hUcmVlRG9tUmVmZXJlbmNlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEJveFRyZWVEb21SZWZlcmVuY2Uuc2Nyb2xsVG9wIDw9IDEuMC8qcHgqLykgey8vIFRPRE8gZG9jdW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3luYyBib3h0cmVlIHNjcm9sbCBvcmlnaW5hdGluZyBpbiBwYWdlcHJldmlld1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci5zeW5jU2Nyb2xsUG9zaXRpb25Gcm9tUGFnZVByZXZpZXcoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN5bmMgcGFnZXByZXZpZXcgc2Nyb2xsIG9yaWdpbmF0aW5nIGluIGJveHRyZWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5wYWdlUHJldmlldy5zeW5jU2Nyb2xsUG9zaXRpb25Gcm9tQm94VHJlZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHJpdmF0ZSBzeW5jV2l0aExlZnRQcm9wZXJ0eUJhckNsaWNrSGFuZGxlciA9IChldnQ6IE1vdXNlRXZlbnQpID0+IHtcclxuICAgICAgICAvLyBkZWZhdWx0IHdoZW4gcHJvcGVydHkgYmFyIGltbWVkaWF0ZWx5IHRvIHRoZSBsZWZ0IGRpc3BsYXlzIGVxdWl2YWxlbnQgYm94IHRyZWU6IHRvZ2dsZSBzeW5jIC8vIFRPRE8gZG9jdW1lbnRcclxuICAgICAgICAvLyBUT0RPIGluc3RlYWQ6IHJlbmRlciBpbiBzYW1lIGRpdiB0byBzeW5jaHJvbml6ZSBzY3JvbGxcclxuICAgICAgICBsZXQgY3VycmVudFByb3BlcnR5QmFySW5kZXg6IG51bWJlciA9IHRoaXMuY3VycmVudFByb3BlcnR5QmFyLnByb3BlcnR5QmFySW5kZXg7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRWaWV3TW9kZWw6IFByb3BlcnR5QmFyVk0gPSB0aGlzLmN1cnJlbnRQcm9wZXJ0eUJhci52aWV3TW9kZWw7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRQcm9wZXJ0eUJhckluZGV4ICE9IDBcclxuICAgICAgICAgICAgJiYgY3VycmVudEFwcC5wcm9wZXJ0eUJhclZNc1tjdXJyZW50UHJvcGVydHlCYXJJbmRleCAtIDFdLmN1cnJlbnRQcm9wZXJ0eUJhck1vZGUgPT09IFByb3BlcnR5QmFyTW9kZS5DYWxpZm9ybmlhVmlld1xyXG4gICAgICAgICAgICAmJiBjdXJyZW50QXBwLnByb3BlcnR5QmFyVk1zW2N1cnJlbnRQcm9wZXJ0eUJhckluZGV4IC0gMV0uc2VsZWN0ZWRDYWxpZm9ybmlhVmlld0lkID09IGN1cnJlbnRWaWV3TW9kZWwuc2VsZWN0ZWRDYWxpZm9ybmlhVmlld0lkKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRWaWV3TW9kZWwuaXNTeW5jZWRXaXRoQm94VHJlZVRvVGhlTGVmdCA9ICFjdXJyZW50Vmlld01vZGVsLmlzU3luY2VkV2l0aEJveFRyZWVUb1RoZUxlZnQ7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Vmlld01vZGVsLmlzU3luY2VkV2l0aEJveFRyZWVUb1RoZUxlZnQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWwgc3luYyBzY3JvbGwgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50Qm94VHJlZURvbVJlZmVyZW5jZTogSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQgPSBjdXJyZW50QXBwLnByb3BlcnR5QmFyQm94VHJlZURvbVJlZmVyZW5jZXNbY3VycmVudFByb3BlcnR5QmFySW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgbGV0IG90aGVyQm94VHJlZURvbVJlZmVyZW5jZTogSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQgPSBjdXJyZW50QXBwLnByb3BlcnR5QmFyQm94VHJlZURvbVJlZmVyZW5jZXNbY3VycmVudFByb3BlcnR5QmFySW5kZXggLSAxXTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Qm94VHJlZURvbVJlZmVyZW5jZSAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgb3RoZXJCb3hUcmVlRG9tUmVmZXJlbmNlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdGhlckJveFRyZWVEb21SZWZlcmVuY2Uuc2Nyb2xsVG9wID0gY3VycmVudEJveFRyZWVEb21SZWZlcmVuY2Uuc2Nyb2xsVG9wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWaWV3TW9kZWwuaXNTeW5jZWRXaXRoQm94VHJlZVRvVGhlTGVmdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdXJyZW50Vmlld01vZGVsLmlzU3luY2VkV2l0aEJveFRyZWVUb1RoZUxlZnQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vTW9kZWxzL1Byb3BlcnR5QmFyLnRzeCIsIi8qISBWZWxvY2l0eUpTLm9yZyAoMS41LjApLiAoQykgMjAxNCBKdWxpYW4gU2hhcGlyby4gTUlUIEBsaWNlbnNlOiBlbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2UgKi9cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKipcbiBWZWxvY2l0eSBqUXVlcnkgU2hpbVxuICoqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qISBWZWxvY2l0eUpTLm9yZyBqUXVlcnkgU2hpbSAoMS4wLjEpLiAoQykgMjAxNCBUaGUgalF1ZXJ5IEZvdW5kYXRpb24uIE1JVCBAbGljZW5zZTogZW4ud2lraXBlZGlhLm9yZy93aWtpL01JVF9MaWNlbnNlLiAqL1xuXG4vKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIGpRdWVyeSBmdW5jdGlvbnMgdGhhdCBWZWxvY2l0eSByZWxpZXMgb24sIHRoZXJlYnkgcmVtb3ZpbmcgVmVsb2NpdHkncyBkZXBlbmRlbmN5IG9uIGEgZnVsbCBjb3B5IG9mIGpRdWVyeSwgYW5kIGFsbG93aW5nIGl0IHRvIHdvcmsgaW4gYW55IGVudmlyb25tZW50LiAqL1xuLyogVGhlc2Ugc2hpbW1lZCBmdW5jdGlvbnMgYXJlIG9ubHkgdXNlZCBpZiBqUXVlcnkgaXNuJ3QgcHJlc2VudC4gSWYgYm90aCB0aGlzIHNoaW0gYW5kIGpRdWVyeSBhcmUgbG9hZGVkLCBWZWxvY2l0eSBkZWZhdWx0cyB0byBqUXVlcnkgcHJvcGVyLiAqL1xuLyogQnJvd3NlciBzdXBwb3J0OiBVc2luZyB0aGlzIHNoaW0gaW5zdGVhZCBvZiBqUXVlcnkgcHJvcGVyIHJlbW92ZXMgc3VwcG9ydCBmb3IgSUU4LiAqL1xuXG4oZnVuY3Rpb24od2luZG93KSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKioqKioqKioqKioqKioqXG5cdCBTZXR1cFxuXHQgKioqKioqKioqKioqKioqL1xuXG5cdC8qIElmIGpRdWVyeSBpcyBhbHJlYWR5IGxvYWRlZCwgdGhlcmUncyBubyBwb2ludCBpbiBsb2FkaW5nIHRoaXMgc2hpbS4gKi9cblx0aWYgKHdpbmRvdy5qUXVlcnkpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvKiBqUXVlcnkgYmFzZS4gKi9cblx0dmFyICQgPSBmdW5jdGlvbihzZWxlY3RvciwgY29udGV4dCkge1xuXHRcdHJldHVybiBuZXcgJC5mbi5pbml0KHNlbGVjdG9yLCBjb250ZXh0KTtcblx0fTtcblxuXHQvKioqKioqKioqKioqKioqKioqKipcblx0IFByaXZhdGUgTWV0aG9kc1xuXHQgKioqKioqKioqKioqKioqKioqKiovXG5cblx0LyogalF1ZXJ5ICovXG5cdCQuaXNXaW5kb3cgPSBmdW5jdGlvbihvYmopIHtcblx0XHQvKiBqc2hpbnQgZXFlcWVxOiBmYWxzZSAqL1xuXHRcdHJldHVybiBvYmogJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cdC8qIGpRdWVyeSAqL1xuXHQkLnR5cGUgPSBmdW5jdGlvbihvYmopIHtcblx0XHRpZiAoIW9iaikge1xuXHRcdFx0cmV0dXJuIG9iaiArIFwiXCI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cblx0XHRcdFx0Y2xhc3MydHlwZVt0b1N0cmluZy5jYWxsKG9iaildIHx8IFwib2JqZWN0XCIgOlxuXHRcdFx0XHR0eXBlb2Ygb2JqO1xuXHR9O1xuXG5cdC8qIGpRdWVyeSAqL1xuXHQkLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuXHRcdHJldHVybiAkLnR5cGUob2JqKSA9PT0gXCJhcnJheVwiO1xuXHR9O1xuXG5cdC8qIGpRdWVyeSAqL1xuXHRmdW5jdGlvbiBpc0FycmF5bGlrZShvYmopIHtcblx0XHR2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aCxcblx0XHRcdFx0dHlwZSA9ICQudHlwZShvYmopO1xuXG5cdFx0aWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCAkLmlzV2luZG93KG9iaikpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRpZiAob2JqLm5vZGVUeXBlID09PSAxICYmIGxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHR5cGUgPT09IFwiYXJyYXlcIiB8fCBsZW5ndGggPT09IDAgfHwgdHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmIChsZW5ndGggLSAxKSBpbiBvYmo7XG5cdH1cblxuXHQvKioqKioqKioqKioqKioqXG5cdCAkIE1ldGhvZHNcblx0ICoqKioqKioqKioqKioqKi9cblxuXHQvKiBqUXVlcnk6IFN1cHBvcnQgcmVtb3ZlZCBmb3IgSUU8OS4gKi9cblx0JC5pc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG5cdFx0dmFyIGtleTtcblxuXHRcdGlmICghb2JqIHx8ICQudHlwZShvYmopICE9PSBcIm9iamVjdFwiIHx8IG9iai5ub2RlVHlwZSB8fCAkLmlzV2luZG93KG9iaikpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0aWYgKG9iai5jb25zdHJ1Y3RvciAmJlxuXHRcdFx0XHRcdCFoYXNPd24uY2FsbChvYmosIFwiY29uc3RydWN0b3JcIikgJiZcblx0XHRcdFx0XHQhaGFzT3duLmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJpc1Byb3RvdHlwZU9mXCIpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gb2JqKSB7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkIHx8IGhhc093bi5jYWxsKG9iaiwga2V5KTtcblx0fTtcblxuXHQvKiBqUXVlcnkgKi9cblx0JC5lYWNoID0gZnVuY3Rpb24ob2JqLCBjYWxsYmFjaywgYXJncykge1xuXHRcdHZhciB2YWx1ZSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGgsXG5cdFx0XHRcdGlzQXJyYXkgPSBpc0FycmF5bGlrZShvYmopO1xuXG5cdFx0aWYgKGFyZ3MpIHtcblx0XHRcdGlmIChpc0FycmF5KSB7XG5cdFx0XHRcdGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrLmFwcGx5KG9ialtpXSwgYXJncyk7XG5cblx0XHRcdFx0XHRpZiAodmFsdWUgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoaSBpbiBvYmopIHtcblx0XHRcdFx0XHRpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhbHVlID0gY2FsbGJhY2suYXBwbHkob2JqW2ldLCBhcmdzKTtcblxuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChpc0FycmF5KSB7XG5cdFx0XHRcdGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqW2ldLCBpLCBvYmpbaV0pO1xuXG5cdFx0XHRcdFx0aWYgKHZhbHVlID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKGkgaW4gb2JqKSB7XG5cdFx0XHRcdFx0aWYgKCFvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqW2ldLCBpLCBvYmpbaV0pO1xuXG5cdFx0XHRcdFx0aWYgKHZhbHVlID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fTtcblxuXHQvKiBDdXN0b20gKi9cblx0JC5kYXRhID0gZnVuY3Rpb24obm9kZSwga2V5LCB2YWx1ZSkge1xuXHRcdC8qICQuZ2V0RGF0YSgpICovXG5cdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHZhciBnZXRJZCA9IG5vZGVbJC5leHBhbmRvXSxcblx0XHRcdFx0XHRzdG9yZSA9IGdldElkICYmIGNhY2hlW2dldElkXTtcblxuXHRcdFx0aWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiBzdG9yZTtcblx0XHRcdH0gZWxzZSBpZiAoc3RvcmUpIHtcblx0XHRcdFx0aWYgKGtleSBpbiBzdG9yZSkge1xuXHRcdFx0XHRcdHJldHVybiBzdG9yZVtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvKiAkLnNldERhdGEoKSAqL1xuXHRcdH0gZWxzZSBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHZhciBzZXRJZCA9IG5vZGVbJC5leHBhbmRvXSB8fCAobm9kZVskLmV4cGFuZG9dID0gKyskLnV1aWQpO1xuXG5cdFx0XHRjYWNoZVtzZXRJZF0gPSBjYWNoZVtzZXRJZF0gfHwge307XG5cdFx0XHRjYWNoZVtzZXRJZF1ba2V5XSA9IHZhbHVlO1xuXG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIEN1c3RvbSAqL1xuXHQkLnJlbW92ZURhdGEgPSBmdW5jdGlvbihub2RlLCBrZXlzKSB7XG5cdFx0dmFyIGlkID0gbm9kZVskLmV4cGFuZG9dLFxuXHRcdFx0XHRzdG9yZSA9IGlkICYmIGNhY2hlW2lkXTtcblxuXHRcdGlmIChzdG9yZSkge1xuXHRcdFx0Ly8gQ2xlYW51cCB0aGUgZW50aXJlIHN0b3JlIGlmIG5vIGtleXMgYXJlIHByb3ZpZGVkLlxuXHRcdFx0aWYgKCFrZXlzKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVtpZF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQkLmVhY2goa2V5cywgZnVuY3Rpb24oXywga2V5KSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHN0b3JlW2tleV07XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKiBqUXVlcnkgKi9cblx0JC5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgc3JjLCBjb3B5SXNBcnJheSwgY29weSwgbmFtZSwgb3B0aW9ucywgY2xvbmUsXG5cdFx0XHRcdHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcblx0XHRcdFx0aSA9IDEsXG5cdFx0XHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRcdGRlZXAgPSBmYWxzZTtcblxuXHRcdGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIikge1xuXHRcdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdFx0dGFyZ2V0ID0gYXJndW1lbnRzW2ldIHx8IHt9O1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICQudHlwZSh0YXJnZXQpICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdHRhcmdldCA9IHt9O1xuXHRcdH1cblxuXHRcdGlmIChpID09PSBsZW5ndGgpIHtcblx0XHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0XHRpLS07XG5cdFx0fVxuXG5cdFx0Zm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKChvcHRpb25zID0gYXJndW1lbnRzW2ldKSkge1xuXHRcdFx0XHRmb3IgKG5hbWUgaW4gb3B0aW9ucykge1xuXHRcdFx0XHRcdGlmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNyYyA9IHRhcmdldFtuYW1lXTtcblx0XHRcdFx0XHRjb3B5ID0gb3B0aW9uc1tuYW1lXTtcblxuXHRcdFx0XHRcdGlmICh0YXJnZXQgPT09IGNvcHkpIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChkZWVwICYmIGNvcHkgJiYgKCQuaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSAkLmlzQXJyYXkoY29weSkpKSkge1xuXHRcdFx0XHRcdFx0aWYgKGNvcHlJc0FycmF5KSB7XG5cdFx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmICQuaXNBcnJheShzcmMpID8gc3JjIDogW107XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmICQuaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRhcmdldFtuYW1lXSA9ICQuZXh0ZW5kKGRlZXAsIGNsb25lLCBjb3B5KTtcblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoY29weSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbbmFtZV0gPSBjb3B5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH07XG5cblx0LyogalF1ZXJ5IDEuNC4zICovXG5cdCQucXVldWUgPSBmdW5jdGlvbihlbGVtLCB0eXBlLCBkYXRhKSB7XG5cdFx0ZnVuY3Rpb24gJG1ha2VBcnJheShhcnIsIHJlc3VsdHMpIHtcblx0XHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0XHRpZiAoYXJyKSB7XG5cdFx0XHRcdGlmIChpc0FycmF5bGlrZShPYmplY3QoYXJyKSkpIHtcblx0XHRcdFx0XHQvKiAkLm1lcmdlICovXG5cdFx0XHRcdFx0KGZ1bmN0aW9uKGZpcnN0LCBzZWNvbmQpIHtcblx0XHRcdFx0XHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdFx0XHRcdFx0XHRqID0gMCxcblx0XHRcdFx0XHRcdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0XHRcdFx0XHR3aGlsZSAoaiA8IGxlbikge1xuXHRcdFx0XHRcdFx0XHRmaXJzdFtpKytdID0gc2Vjb25kW2orK107XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChsZW4gIT09IGxlbikge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoc2Vjb25kW2pdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRmaXJzdFtpKytdID0gc2Vjb25kW2orK107XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGZpcnN0O1xuXHRcdFx0XHRcdH0pKHJldCwgdHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/IFthcnJdIDogYXJyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRbXS5wdXNoLmNhbGwocmV0LCBhcnIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0aWYgKCFlbGVtKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dHlwZSA9ICh0eXBlIHx8IFwiZnhcIikgKyBcInF1ZXVlXCI7XG5cblx0XHR2YXIgcSA9ICQuZGF0YShlbGVtLCB0eXBlKTtcblxuXHRcdGlmICghZGF0YSkge1xuXHRcdFx0cmV0dXJuIHEgfHwgW107XG5cdFx0fVxuXG5cdFx0aWYgKCFxIHx8ICQuaXNBcnJheShkYXRhKSkge1xuXHRcdFx0cSA9ICQuZGF0YShlbGVtLCB0eXBlLCAkbWFrZUFycmF5KGRhdGEpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cS5wdXNoKGRhdGEpO1xuXHRcdH1cblxuXHRcdHJldHVybiBxO1xuXHR9O1xuXG5cdC8qIGpRdWVyeSAxLjQuMyAqL1xuXHQkLmRlcXVldWUgPSBmdW5jdGlvbihlbGVtcywgdHlwZSkge1xuXHRcdC8qIEN1c3RvbTogRW1iZWQgZWxlbWVudCBpdGVyYXRpb24uICovXG5cdFx0JC5lYWNoKGVsZW1zLm5vZGVUeXBlID8gW2VsZW1zXSA6IGVsZW1zLCBmdW5jdGlvbihpLCBlbGVtKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHRcdHZhciBxdWV1ZSA9ICQucXVldWUoZWxlbSwgdHlwZSksXG5cdFx0XHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpO1xuXG5cdFx0XHRpZiAoZm4gPT09IFwiaW5wcm9ncmVzc1wiKSB7XG5cdFx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGZuKSB7XG5cdFx0XHRcdGlmICh0eXBlID09PSBcImZ4XCIpIHtcblx0XHRcdFx0XHRxdWV1ZS51bnNoaWZ0KFwiaW5wcm9ncmVzc1wiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZuLmNhbGwoZWxlbSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0JC5kZXF1ZXVlKGVsZW0sIHR5cGUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblxuXHQvKioqKioqKioqKioqKioqKioqXG5cdCAkLmZuIE1ldGhvZHNcblx0ICoqKioqKioqKioqKioqKioqKi9cblxuXHQvKiBqUXVlcnkgKi9cblx0JC5mbiA9ICQucHJvdG90eXBlID0ge1xuXHRcdGluaXQ6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG5cdFx0XHQvKiBKdXN0IHJldHVybiB0aGUgZWxlbWVudCB3cmFwcGVkIGluc2lkZSBhbiBhcnJheTsgZG9uJ3QgcHJvY2VlZCB3aXRoIHRoZSBhY3R1YWwgalF1ZXJ5IG5vZGUgd3JhcHBpbmcgcHJvY2Vzcy4gKi9cblx0XHRcdGlmIChzZWxlY3Rvci5ub2RlVHlwZSkge1xuXHRcdFx0XHR0aGlzWzBdID0gc2VsZWN0b3I7XG5cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOb3QgYSBET00gbm9kZS5cIik7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0LyogalF1ZXJ5IGFsdGVyZWQgY29kZTogRHJvcHBlZCBkaXNjb25uZWN0ZWQgRE9NIG5vZGUgY2hlY2tpbmcuICovXG5cdFx0XHR2YXIgYm94ID0gdGhpc1swXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPyB0aGlzWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDoge3RvcDogMCwgbGVmdDogMH07XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHRvcDogYm94LnRvcCArICh3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuc2Nyb2xsVG9wIHx8IDApIC0gKGRvY3VtZW50LmNsaWVudFRvcCB8fCAwKSxcblx0XHRcdFx0bGVmdDogYm94LmxlZnQgKyAod2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LnNjcm9sbExlZnQgfHwgMCkgLSAoZG9jdW1lbnQuY2xpZW50TGVmdCB8fCAwKVxuXHRcdFx0fTtcblx0XHR9LFxuXHRcdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdC8qIGpRdWVyeSAqL1xuXHRcdFx0ZnVuY3Rpb24gb2Zmc2V0UGFyZW50Rm4oZWxlbSkge1xuXHRcdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gZWxlbS5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdFx0d2hpbGUgKG9mZnNldFBhcmVudCAmJiAob2Zmc2V0UGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwiaHRtbFwiICYmIG9mZnNldFBhcmVudC5zdHlsZSAmJiBvZmZzZXRQYXJlbnQuc3R5bGUucG9zaXRpb24udG9Mb3dlckNhc2UoKSA9PT0gXCJzdGF0aWNcIikpIHtcblx0XHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG9mZnNldFBhcmVudCB8fCBkb2N1bWVudDtcblx0XHRcdH1cblxuXHRcdFx0LyogWmVwdG8gKi9cblx0XHRcdHZhciBlbGVtID0gdGhpc1swXSxcblx0XHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnRGbihlbGVtKSxcblx0XHRcdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpLFxuXHRcdFx0XHRcdHBhcmVudE9mZnNldCA9IC9eKD86Ym9keXxodG1sKSQvaS50ZXN0KG9mZnNldFBhcmVudC5ub2RlTmFtZSkgPyB7dG9wOiAwLCBsZWZ0OiAwfSA6ICQob2Zmc2V0UGFyZW50KS5vZmZzZXQoKTtcblxuXHRcdFx0b2Zmc2V0LnRvcCAtPSBwYXJzZUZsb2F0KGVsZW0uc3R5bGUubWFyZ2luVG9wKSB8fCAwO1xuXHRcdFx0b2Zmc2V0LmxlZnQgLT0gcGFyc2VGbG9hdChlbGVtLnN0eWxlLm1hcmdpbkxlZnQpIHx8IDA7XG5cblx0XHRcdGlmIChvZmZzZXRQYXJlbnQuc3R5bGUpIHtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LnRvcCArPSBwYXJzZUZsb2F0KG9mZnNldFBhcmVudC5zdHlsZS5ib3JkZXJUb3BXaWR0aCkgfHwgMDtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0gcGFyc2VGbG9hdChvZmZzZXRQYXJlbnQuc3R5bGUuYm9yZGVyTGVmdFdpZHRoKSB8fCAwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wLFxuXHRcdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0XG5cdFx0XHR9O1xuXHRcdH1cblx0fTtcblxuXHQvKioqKioqKioqKioqKioqKioqKioqKlxuXHQgUHJpdmF0ZSBWYXJpYWJsZXNcblx0ICoqKioqKioqKioqKioqKioqKioqKiovXG5cblx0LyogRm9yICQuZGF0YSgpICovXG5cdHZhciBjYWNoZSA9IHt9O1xuXHQkLmV4cGFuZG8gPSBcInZlbG9jaXR5XCIgKyAobmV3IERhdGUoKS5nZXRUaW1lKCkpO1xuXHQkLnV1aWQgPSAwO1xuXG5cdC8qIEZvciAkLnF1ZXVlKCkgKi9cblx0dmFyIGNsYXNzMnR5cGUgPSB7fSxcblx0XHRcdGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHksXG5cdFx0XHR0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cblx0dmFyIHR5cGVzID0gXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yXCIuc3BsaXQoXCIgXCIpO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2xhc3MydHlwZVtcIltvYmplY3QgXCIgKyB0eXBlc1tpXSArIFwiXVwiXSA9IHR5cGVzW2ldLnRvTG93ZXJDYXNlKCk7XG5cdH1cblxuXHQvKiBNYWtlcyAkKG5vZGUpIHBvc3NpYmxlLCB3aXRob3V0IGhhdmluZyB0byBjYWxsIGluaXQuICovXG5cdCQuZm4uaW5pdC5wcm90b3R5cGUgPSAkLmZuO1xuXG5cdC8qIEdsb2JhbGl6ZSBWZWxvY2l0eSBvbnRvIHRoZSB3aW5kb3csIGFuZCBhc3NpZ24gaXRzIFV0aWxpdGllcyBwcm9wZXJ0eS4gKi9cblx0d2luZG93LlZlbG9jaXR5ID0ge1V0aWxpdGllczogJH07XG59KSh3aW5kb3cpO1xuXG4vKioqKioqKioqKioqKioqKioqXG4gVmVsb2NpdHkuanNcbiAqKioqKioqKioqKioqKioqKiovXG5cbihmdW5jdGlvbihmYWN0b3J5KSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKiBDb21tb25KUyBtb2R1bGUuICovXG5cdGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRcdC8qIEFNRCBtb2R1bGUuICovXG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcblx0XHRkZWZpbmUoZmFjdG9yeSk7XG5cdFx0LyogQnJvd3NlciBnbG9iYWxzLiAqL1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoKTtcblx0fVxufShmdW5jdGlvbigpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHJldHVybiBmdW5jdGlvbihnbG9iYWwsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xuXG5cdFx0LyoqKioqKioqKioqKioqKlxuXHRcdCBTdW1tYXJ5XG5cdFx0ICoqKioqKioqKioqKioqKi9cblxuXHRcdC8qXG5cdFx0IC0gQ1NTOiBDU1Mgc3RhY2sgdGhhdCB3b3JrcyBpbmRlcGVuZGVudGx5IGZyb20gdGhlIHJlc3Qgb2YgVmVsb2NpdHkuXG5cdFx0IC0gYW5pbWF0ZSgpOiBDb3JlIGFuaW1hdGlvbiBtZXRob2QgdGhhdCBpdGVyYXRlcyBvdmVyIHRoZSB0YXJnZXRlZCBlbGVtZW50cyBhbmQgcXVldWVzIHRoZSBpbmNvbWluZyBjYWxsIG9udG8gZWFjaCBlbGVtZW50IGluZGl2aWR1YWxseS5cblx0XHQgLSBQcmUtUXVldWVpbmc6IFByZXBhcmUgdGhlIGVsZW1lbnQgZm9yIGFuaW1hdGlvbiBieSBpbnN0YW50aWF0aW5nIGl0cyBkYXRhIGNhY2hlIGFuZCBwcm9jZXNzaW5nIHRoZSBjYWxsJ3Mgb3B0aW9ucy5cblx0XHQgLSBRdWV1ZWluZzogVGhlIGxvZ2ljIHRoYXQgcnVucyBvbmNlIHRoZSBjYWxsIGhhcyByZWFjaGVkIGl0cyBwb2ludCBvZiBleGVjdXRpb24gaW4gdGhlIGVsZW1lbnQncyAkLnF1ZXVlKCkgc3RhY2suXG5cdFx0IE1vc3QgbG9naWMgaXMgcGxhY2VkIGhlcmUgdG8gYXZvaWQgcmlza2luZyBpdCBiZWNvbWluZyBzdGFsZSAoaWYgdGhlIGVsZW1lbnQncyBwcm9wZXJ0aWVzIGhhdmUgY2hhbmdlZCkuXG5cdFx0IC0gUHVzaGluZzogQ29uc29saWRhdGlvbiBvZiB0aGUgdHdlZW4gZGF0YSBmb2xsb3dlZCBieSBpdHMgcHVzaCBvbnRvIHRoZSBnbG9iYWwgaW4tcHJvZ3Jlc3MgY2FsbHMgY29udGFpbmVyLlxuXHRcdCAtIHRpY2soKTogVGhlIHNpbmdsZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgbG9vcCByZXNwb25zaWJsZSBmb3IgdHdlZW5pbmcgYWxsIGluLXByb2dyZXNzIGNhbGxzLlxuXHRcdCAtIGNvbXBsZXRlQ2FsbCgpOiBIYW5kbGVzIHRoZSBjbGVhbnVwIHByb2Nlc3MgZm9yIGVhY2ggVmVsb2NpdHkgY2FsbC5cblx0XHQgKi9cblxuXHRcdC8qKioqKioqKioqKioqKioqKioqKipcblx0XHQgSGVscGVyIEZ1bmN0aW9uc1xuXHRcdCAqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHQvKiBJRSBkZXRlY3Rpb24uIEdpc3Q6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2p1bGlhbnNoYXBpcm8vOTA5ODYwOSAqL1xuXHRcdHZhciBJRSA9IChmdW5jdGlvbigpIHtcblx0XHRcdGlmIChkb2N1bWVudC5kb2N1bWVudE1vZGUpIHtcblx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmRvY3VtZW50TW9kZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSA3OyBpID4gNDsgaS0tKSB7XG5cdFx0XHRcdFx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cblx0XHRcdFx0XHRkaXYuaW5uZXJIVE1MID0gXCI8IS0tW2lmIElFIFwiICsgaSArIFwiXT48c3Bhbj48L3NwYW4+PCFbZW5kaWZdLS0+XCI7XG5cblx0XHRcdFx0XHRpZiAoZGl2LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic3BhblwiKS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGRpdiA9IG51bGw7XG5cblx0XHRcdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH0pKCk7XG5cblx0XHQvKiByQUYgc2hpbS4gR2lzdDogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vanVsaWFuc2hhcGlyby85NDk3NTEzICovXG5cdFx0dmFyIHJBRlNoaW0gPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGltZUxhc3QgPSAwO1xuXG5cdFx0XHRyZXR1cm4gd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHRcdHZhciB0aW1lQ3VycmVudCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCksXG5cdFx0XHRcdFx0XHR0aW1lRGVsdGE7XG5cblx0XHRcdFx0LyogRHluYW1pY2FsbHkgc2V0IGRlbGF5IG9uIGEgcGVyLXRpY2sgYmFzaXMgdG8gbWF0Y2ggNjBmcHMuICovXG5cdFx0XHRcdC8qIFRlY2huaXF1ZSBieSBFcmlrIE1vbGxlci4gTUlUIGxpY2Vuc2U6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC8xNTc5NjcxICovXG5cdFx0XHRcdHRpbWVEZWx0YSA9IE1hdGgubWF4KDAsIDE2IC0gKHRpbWVDdXJyZW50IC0gdGltZUxhc3QpKTtcblx0XHRcdFx0dGltZUxhc3QgPSB0aW1lQ3VycmVudCArIHRpbWVEZWx0YTtcblxuXHRcdFx0XHRyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRjYWxsYmFjayh0aW1lQ3VycmVudCArIHRpbWVEZWx0YSk7XG5cdFx0XHRcdH0sIHRpbWVEZWx0YSk7XG5cdFx0XHR9O1xuXHRcdH0pKCk7XG5cblx0XHR2YXIgcGVyZm9ybWFuY2UgPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcGVyZiA9IHdpbmRvdy5wZXJmb3JtYW5jZSB8fCB7fTtcblxuXHRcdFx0aWYgKHR5cGVvZiBwZXJmLm5vdyAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHZhciBub3dPZmZzZXQgPSBwZXJmLnRpbWluZyAmJiBwZXJmLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQgPyBwZXJmLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQgOiAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG5cdFx0XHRcdHBlcmYubm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBub3dPZmZzZXQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGVyZjtcblx0XHR9KSgpO1xuXG5cdFx0LyogQXJyYXkgY29tcGFjdGluZy4gQ29weXJpZ2h0IExvLURhc2guIE1JVCBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci9MSUNFTlNFLnR4dCAqL1xuXHRcdGZ1bmN0aW9uIGNvbXBhY3RTcGFyc2VBcnJheShhcnJheSkge1xuXHRcdFx0dmFyIGluZGV4ID0gLTEsXG5cdFx0XHRcdFx0bGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuXHRcdFx0XHRcdHJlc3VsdCA9IFtdO1xuXG5cdFx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG5cblx0XHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2godmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogU2hpbSBmb3IgXCJmaXhpbmdcIiBJRSdzIGxhY2sgb2Ygc3VwcG9ydCAoSUUgPCA5KSBmb3IgYXBwbHlpbmcgc2xpY2Vcblx0XHQgKiBvbiBob3N0IG9iamVjdHMgbGlrZSBOYW1lZE5vZGVNYXAsIE5vZGVMaXN0LCBhbmQgSFRNTENvbGxlY3Rpb25cblx0XHQgKiAodGVjaG5pY2FsbHksIHNpbmNlIGhvc3Qgb2JqZWN0cyBoYXZlIGJlZW4gaW1wbGVtZW50YXRpb24tZGVwZW5kZW50LFxuXHRcdCAqIGF0IGxlYXN0IGJlZm9yZSBFUzIwMTUsIElFIGhhc24ndCBuZWVkZWQgdG8gd29yayB0aGlzIHdheSkuXG5cdFx0ICogQWxzbyB3b3JrcyBvbiBzdHJpbmdzLCBmaXhlcyBJRSA8IDkgdG8gYWxsb3cgYW4gZXhwbGljaXQgdW5kZWZpbmVkXG5cdFx0ICogZm9yIHRoZSAybmQgYXJndW1lbnQgKGFzIGluIEZpcmVmb3gpLCBhbmQgcHJldmVudHMgZXJyb3JzIHdoZW5cblx0XHQgKiBjYWxsZWQgb24gb3RoZXIgRE9NIG9iamVjdHMuXG5cdFx0ICovXG5cdFx0dmFyIF9zbGljZSA9IChmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gQ2FuJ3QgYmUgdXNlZCB3aXRoIERPTSBlbGVtZW50cyBpbiBJRSA8IDlcblx0XHRcdFx0c2xpY2UuY2FsbChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuXHRcdFx0XHRyZXR1cm4gc2xpY2U7XG5cdFx0XHR9IGNhdGNoIChlKSB7IC8vIEZhaWxzIGluIElFIDwgOVxuXG5cdFx0XHRcdC8vIFRoaXMgd2lsbCB3b3JrIGZvciBnZW51aW5lIGFycmF5cywgYXJyYXktbGlrZSBvYmplY3RzLCBcblx0XHRcdFx0Ly8gTmFtZWROb2RlTWFwIChhdHRyaWJ1dGVzLCBlbnRpdGllcywgbm90YXRpb25zKSxcblx0XHRcdFx0Ly8gTm9kZUxpc3QgKGUuZy4sIGdldEVsZW1lbnRzQnlUYWdOYW1lKSwgSFRNTENvbGxlY3Rpb24gKGUuZy4sIGNoaWxkTm9kZXMpLFxuXHRcdFx0XHQvLyBhbmQgd2lsbCBub3QgZmFpbCBvbiBvdGhlciBET00gb2JqZWN0cyAoYXMgZG8gRE9NIGVsZW1lbnRzIGluIElFIDwgOSlcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcblx0XHRcdFx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdFx0XHRpZiAodHlwZW9mIGJlZ2luICE9PSBcIm51bWJlclwiKSB7XG5cdFx0XHRcdFx0XHRiZWdpbiA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIElFIDwgOSBnZXRzIHVuaGFwcHkgd2l0aCBhbiB1bmRlZmluZWQgZW5kIGFyZ3VtZW50XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBlbmQgIT09IFwibnVtYmVyXCIpIHtcblx0XHRcdFx0XHRcdGVuZCA9IGxlbjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gRm9yIG5hdGl2ZSBBcnJheSBvYmplY3RzLCB3ZSB1c2UgdGhlIG5hdGl2ZSBzbGljZSBmdW5jdGlvblxuXHRcdFx0XHRcdGlmICh0aGlzLnNsaWNlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc2xpY2UuY2FsbCh0aGlzLCBiZWdpbiwgZW5kKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gRm9yIGFycmF5IGxpa2Ugb2JqZWN0IHdlIGhhbmRsZSBpdCBvdXJzZWx2ZXMuXG5cdFx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0XHRcdGNsb25lZCA9IFtdLFxuXHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgbmVnYXRpdmUgdmFsdWUgZm9yIFwiYmVnaW5cIlxuXHRcdFx0XHRcdFx0XHRzdGFydCA9IChiZWdpbiA+PSAwKSA/IGJlZ2luIDogTWF0aC5tYXgoMCwgbGVuICsgYmVnaW4pLFxuXHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgbmVnYXRpdmUgdmFsdWUgZm9yIFwiZW5kXCJcblx0XHRcdFx0XHRcdFx0dXBUbyA9IGVuZCA8IDAgPyBsZW4gKyBlbmQgOiBNYXRoLm1pbihlbmQsIGxlbiksXG5cdFx0XHRcdFx0XHRcdC8vIEFjdHVhbCBleHBlY3RlZCBzaXplIG9mIHRoZSBzbGljZVxuXHRcdFx0XHRcdFx0XHRzaXplID0gdXBUbyAtIHN0YXJ0O1xuXG5cdFx0XHRcdFx0aWYgKHNpemUgPiAwKSB7XG5cdFx0XHRcdFx0XHRjbG9uZWQgPSBuZXcgQXJyYXkoc2l6ZSk7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5jaGFyQXQpIHtcblx0XHRcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdGNsb25lZFtpXSA9IHRoaXMuY2hhckF0KHN0YXJ0ICsgaSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRjbG9uZWRbaV0gPSB0aGlzW3N0YXJ0ICsgaV07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGNsb25lZDtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9KSgpO1xuXG5cdFx0LyogLmluZGV4T2YgZG9lc24ndCBleGlzdCBpbiBJRTw5ICovXG5cdFx0dmFyIF9pbkFycmF5ID0gKGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKEFycmF5LnByb3RvdHlwZS5pbmNsdWRlcykge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oYXJyLCB2YWwpIHtcblx0XHRcdFx0XHRyZXR1cm4gYXJyLmluY2x1ZGVzKHZhbCk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGFyciwgdmFsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGFyci5pbmRleE9mKHZhbCkgPj0gMDtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmdW5jdGlvbihhcnIsIHZhbCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChhcnJbaV0gPT09IHZhbCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSk7XG5cblx0XHRmdW5jdGlvbiBzYW5pdGl6ZUVsZW1lbnRzKGVsZW1lbnRzKSB7XG5cdFx0XHQvKiBVbndyYXAgalF1ZXJ5L1plcHRvIG9iamVjdHMuICovXG5cdFx0XHRpZiAoVHlwZS5pc1dyYXBwZWQoZWxlbWVudHMpKSB7XG5cdFx0XHRcdGVsZW1lbnRzID0gX3NsaWNlLmNhbGwoZWxlbWVudHMpO1xuXHRcdFx0XHQvKiBXcmFwIGEgc2luZ2xlIGVsZW1lbnQgaW4gYW4gYXJyYXkgc28gdGhhdCAkLmVhY2goKSBjYW4gaXRlcmF0ZSB3aXRoIHRoZSBlbGVtZW50IGluc3RlYWQgb2YgaXRzIG5vZGUncyBjaGlsZHJlbi4gKi9cblx0XHRcdH0gZWxzZSBpZiAoVHlwZS5pc05vZGUoZWxlbWVudHMpKSB7XG5cdFx0XHRcdGVsZW1lbnRzID0gW2VsZW1lbnRzXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW1lbnRzO1xuXHRcdH1cblxuXHRcdHZhciBUeXBlID0ge1xuXHRcdFx0aXNOdW1iZXI6IGZ1bmN0aW9uKHZhcmlhYmxlKSB7XG5cdFx0XHRcdHJldHVybiAodHlwZW9mIHZhcmlhYmxlID09PSBcIm51bWJlclwiKTtcblx0XHRcdH0sXG5cdFx0XHRpc1N0cmluZzogZnVuY3Rpb24odmFyaWFibGUpIHtcblx0XHRcdFx0cmV0dXJuICh0eXBlb2YgdmFyaWFibGUgPT09IFwic3RyaW5nXCIpO1xuXHRcdFx0fSxcblx0XHRcdGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24odmFyaWFibGUpIHtcblx0XHRcdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YXJpYWJsZSkgPT09IFwiW29iamVjdCBBcnJheV1cIjtcblx0XHRcdH0sXG5cdFx0XHRpc0Z1bmN0aW9uOiBmdW5jdGlvbih2YXJpYWJsZSkge1xuXHRcdFx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhcmlhYmxlKSA9PT0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiO1xuXHRcdFx0fSxcblx0XHRcdGlzTm9kZTogZnVuY3Rpb24odmFyaWFibGUpIHtcblx0XHRcdFx0cmV0dXJuIHZhcmlhYmxlICYmIHZhcmlhYmxlLm5vZGVUeXBlO1xuXHRcdFx0fSxcblx0XHRcdC8qIERldGVybWluZSBpZiB2YXJpYWJsZSBpcyBhbiBhcnJheS1saWtlIHdyYXBwZWQgalF1ZXJ5LCBaZXB0byBvciBzaW1pbGFyIGVsZW1lbnQsIG9yIGV2ZW4gYSBOb2RlTGlzdCBldGMuICovXG5cdFx0XHQvKiBOT1RFOiBIVE1MRm9ybUVsZW1lbnRzIGFsc28gaGF2ZSBhIGxlbmd0aC4gKi9cblx0XHRcdGlzV3JhcHBlZDogZnVuY3Rpb24odmFyaWFibGUpIHtcblx0XHRcdFx0cmV0dXJuIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHQmJiB2YXJpYWJsZSAhPT0gd2luZG93XG5cdFx0XHRcdFx0XHQmJiBUeXBlLmlzTnVtYmVyKHZhcmlhYmxlLmxlbmd0aClcblx0XHRcdFx0XHRcdCYmICFUeXBlLmlzU3RyaW5nKHZhcmlhYmxlKVxuXHRcdFx0XHRcdFx0JiYgIVR5cGUuaXNGdW5jdGlvbih2YXJpYWJsZSlcblx0XHRcdFx0XHRcdCYmICFUeXBlLmlzTm9kZSh2YXJpYWJsZSlcblx0XHRcdFx0XHRcdCYmICh2YXJpYWJsZS5sZW5ndGggPT09IDAgfHwgVHlwZS5pc05vZGUodmFyaWFibGVbMF0pKTtcblx0XHRcdH0sXG5cdFx0XHRpc1NWRzogZnVuY3Rpb24odmFyaWFibGUpIHtcblx0XHRcdFx0cmV0dXJuIHdpbmRvdy5TVkdFbGVtZW50ICYmICh2YXJpYWJsZSBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50KTtcblx0XHRcdH0sXG5cdFx0XHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbih2YXJpYWJsZSkge1xuXHRcdFx0XHRmb3IgKHZhciBuYW1lIGluIHZhcmlhYmxlKSB7XG5cdFx0XHRcdFx0aWYgKHZhcmlhYmxlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKioqKioqKioqKioqKioqKlxuXHRcdCBEZXBlbmRlbmNpZXNcblx0XHQgKioqKioqKioqKioqKioqKiovXG5cblx0XHR2YXIgJCxcblx0XHRcdFx0aXNKUXVlcnkgPSBmYWxzZTtcblxuXHRcdGlmIChnbG9iYWwuZm4gJiYgZ2xvYmFsLmZuLmpxdWVyeSkge1xuXHRcdFx0JCA9IGdsb2JhbDtcblx0XHRcdGlzSlF1ZXJ5ID0gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0JCA9IHdpbmRvdy5WZWxvY2l0eS5VdGlsaXRpZXM7XG5cdFx0fVxuXG5cdFx0aWYgKElFIDw9IDggJiYgIWlzSlF1ZXJ5KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJWZWxvY2l0eTogSUU4IGFuZCBiZWxvdyByZXF1aXJlIGpRdWVyeSB0byBiZSBsb2FkZWQgYmVmb3JlIFZlbG9jaXR5LlwiKTtcblx0XHR9IGVsc2UgaWYgKElFIDw9IDcpIHtcblx0XHRcdC8qIFJldmVydCB0byBqUXVlcnkncyAkLmFuaW1hdGUoKSwgYW5kIGxvc2UgVmVsb2NpdHkncyBleHRyYSBmZWF0dXJlcy4gKi9cblx0XHRcdGpRdWVyeS5mbi52ZWxvY2l0eSA9IGpRdWVyeS5mbi5hbmltYXRlO1xuXG5cdFx0XHQvKiBOb3cgdGhhdCAkLmZuLnZlbG9jaXR5IGlzIGFsaWFzZWQsIGFib3J0IHRoaXMgVmVsb2NpdHkgZGVjbGFyYXRpb24uICovXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0LyoqKioqKioqKioqKioqKioqXG5cdFx0IENvbnN0YW50c1xuXHRcdCAqKioqKioqKioqKioqKioqKi9cblxuXHRcdHZhciBEVVJBVElPTl9ERUZBVUxUID0gNDAwLFxuXHRcdFx0XHRFQVNJTkdfREVGQVVMVCA9IFwic3dpbmdcIjtcblxuXHRcdC8qKioqKioqKioqKioqXG5cdFx0IFN0YXRlXG5cdFx0ICoqKioqKioqKioqKiovXG5cblx0XHR2YXIgVmVsb2NpdHkgPSB7XG5cdFx0XHQvKiBDb250YWluZXIgZm9yIHBhZ2Utd2lkZSBWZWxvY2l0eSBzdGF0ZSBkYXRhLiAqL1xuXHRcdFx0U3RhdGU6IHtcblx0XHRcdFx0LyogRGV0ZWN0IG1vYmlsZSBkZXZpY2VzIHRvIGRldGVybWluZSBpZiBtb2JpbGVIQSBzaG91bGQgYmUgdHVybmVkIG9uLiAqL1xuXHRcdFx0XHRpc01vYmlsZTogL0FuZHJvaWR8d2ViT1N8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSxcblx0XHRcdFx0LyogVGhlIG1vYmlsZUhBIG9wdGlvbidzIGJlaGF2aW9yIGNoYW5nZXMgb24gb2xkZXIgQW5kcm9pZCBkZXZpY2VzIChHaW5nZXJicmVhZCwgdmVyc2lvbnMgMi4zLjMtMi4zLjcpLiAqL1xuXHRcdFx0XHRpc0FuZHJvaWQ6IC9BbmRyb2lkL2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCksXG5cdFx0XHRcdGlzR2luZ2VyYnJlYWQ6IC9BbmRyb2lkIDJcXC4zXFwuWzMtN10vaS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSxcblx0XHRcdFx0aXNDaHJvbWU6IHdpbmRvdy5jaHJvbWUsXG5cdFx0XHRcdGlzRmlyZWZveDogL0ZpcmVmb3gvaS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSxcblx0XHRcdFx0LyogQ3JlYXRlIGEgY2FjaGVkIGVsZW1lbnQgZm9yIHJlLXVzZSB3aGVuIGNoZWNraW5nIGZvciBDU1MgcHJvcGVydHkgcHJlZml4ZXMuICovXG5cdFx0XHRcdHByZWZpeEVsZW1lbnQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG5cdFx0XHRcdC8qIENhY2hlIGV2ZXJ5IHByZWZpeCBtYXRjaCB0byBhdm9pZCByZXBlYXRpbmcgbG9va3Vwcy4gKi9cblx0XHRcdFx0cHJlZml4TWF0Y2hlczoge30sXG5cdFx0XHRcdC8qIENhY2hlIHRoZSBhbmNob3IgdXNlZCBmb3IgYW5pbWF0aW5nIHdpbmRvdyBzY3JvbGxpbmcuICovXG5cdFx0XHRcdHNjcm9sbEFuY2hvcjogbnVsbCxcblx0XHRcdFx0LyogQ2FjaGUgdGhlIGJyb3dzZXItc3BlY2lmaWMgcHJvcGVydHkgbmFtZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBzY3JvbGwgYW5jaG9yLiAqL1xuXHRcdFx0XHRzY3JvbGxQcm9wZXJ0eUxlZnQ6IG51bGwsXG5cdFx0XHRcdHNjcm9sbFByb3BlcnR5VG9wOiBudWxsLFxuXHRcdFx0XHQvKiBLZWVwIHRyYWNrIG9mIHdoZXRoZXIgb3VyIFJBRiB0aWNrIGlzIHJ1bm5pbmcuICovXG5cdFx0XHRcdGlzVGlja2luZzogZmFsc2UsXG5cdFx0XHRcdC8qIENvbnRhaW5lciBmb3IgZXZlcnkgaW4tcHJvZ3Jlc3MgY2FsbCB0byBWZWxvY2l0eS4gKi9cblx0XHRcdFx0Y2FsbHM6IFtdLFxuXHRcdFx0XHRkZWxheWVkRWxlbWVudHM6IHtcblx0XHRcdFx0XHRjb3VudDogMFxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0LyogVmVsb2NpdHkncyBjdXN0b20gQ1NTIHN0YWNrLiBNYWRlIGdsb2JhbCBmb3IgdW5pdCB0ZXN0aW5nLiAqL1xuXHRcdFx0Q1NTOiB7LyogRGVmaW5lZCBiZWxvdy4gKi99LFxuXHRcdFx0LyogQSBzaGltIG9mIHRoZSBqUXVlcnkgdXRpbGl0eSBmdW5jdGlvbnMgdXNlZCBieSBWZWxvY2l0eSAtLSBwcm92aWRlZCBieSBWZWxvY2l0eSdzIG9wdGlvbmFsIGpRdWVyeSBzaGltLiAqL1xuXHRcdFx0VXRpbGl0aWVzOiAkLFxuXHRcdFx0LyogQ29udGFpbmVyIGZvciB0aGUgdXNlcidzIGN1c3RvbSBhbmltYXRpb24gcmVkaXJlY3RzIHRoYXQgYXJlIHJlZmVyZW5jZWQgYnkgbmFtZSBpbiBwbGFjZSBvZiB0aGUgcHJvcGVydGllcyBtYXAgYXJndW1lbnQuICovXG5cdFx0XHRSZWRpcmVjdHM6IHsvKiBNYW51YWxseSByZWdpc3RlcmVkIGJ5IHRoZSB1c2VyLiAqL30sXG5cdFx0XHRFYXNpbmdzOiB7LyogRGVmaW5lZCBiZWxvdy4gKi99LFxuXHRcdFx0LyogQXR0ZW1wdCB0byB1c2UgRVM2IFByb21pc2VzIGJ5IGRlZmF1bHQuIFVzZXJzIGNhbiBvdmVycmlkZSB0aGlzIHdpdGggYSB0aGlyZC1wYXJ0eSBwcm9taXNlcyBsaWJyYXJ5LiAqL1xuXHRcdFx0UHJvbWlzZTogd2luZG93LlByb21pc2UsXG5cdFx0XHQvKiBWZWxvY2l0eSBvcHRpb24gZGVmYXVsdHMsIHdoaWNoIGNhbiBiZSBvdmVycmlkZW4gYnkgdGhlIHVzZXIuICovXG5cdFx0XHRkZWZhdWx0czoge1xuXHRcdFx0XHRxdWV1ZTogXCJcIixcblx0XHRcdFx0ZHVyYXRpb246IERVUkFUSU9OX0RFRkFVTFQsXG5cdFx0XHRcdGVhc2luZzogRUFTSU5HX0RFRkFVTFQsXG5cdFx0XHRcdGJlZ2luOiB1bmRlZmluZWQsXG5cdFx0XHRcdGNvbXBsZXRlOiB1bmRlZmluZWQsXG5cdFx0XHRcdHByb2dyZXNzOiB1bmRlZmluZWQsXG5cdFx0XHRcdGRpc3BsYXk6IHVuZGVmaW5lZCxcblx0XHRcdFx0dmlzaWJpbGl0eTogdW5kZWZpbmVkLFxuXHRcdFx0XHRsb29wOiBmYWxzZSxcblx0XHRcdFx0ZGVsYXk6IGZhbHNlLFxuXHRcdFx0XHRtb2JpbGVIQTogdHJ1ZSxcblx0XHRcdFx0LyogQWR2YW5jZWQ6IFNldCB0byBmYWxzZSB0byBwcmV2ZW50IHByb3BlcnR5IHZhbHVlcyBmcm9tIGJlaW5nIGNhY2hlZCBiZXR3ZWVuIGNvbnNlY3V0aXZlIFZlbG9jaXR5LWluaXRpYXRlZCBjaGFpbiBjYWxscy4gKi9cblx0XHRcdFx0X2NhY2hlVmFsdWVzOiB0cnVlLFxuXHRcdFx0XHQvKiBBZHZhbmNlZDogU2V0IHRvIGZhbHNlIGlmIHRoZSBwcm9taXNlIHNob3VsZCBhbHdheXMgcmVzb2x2ZSBvbiBlbXB0eSBlbGVtZW50IGxpc3RzLiAqL1xuXHRcdFx0XHRwcm9taXNlUmVqZWN0RW1wdHk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHQvKiBBIGRlc2lnbiBnb2FsIG9mIFZlbG9jaXR5IGlzIHRvIGNhY2hlIGRhdGEgd2hlcmV2ZXIgcG9zc2libGUgaW4gb3JkZXIgdG8gYXZvaWQgRE9NIHJlcXVlcnlpbmcuIEFjY29yZGluZ2x5LCBlYWNoIGVsZW1lbnQgaGFzIGEgZGF0YSBjYWNoZS4gKi9cblx0XHRcdGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdFx0JC5kYXRhKGVsZW1lbnQsIFwidmVsb2NpdHlcIiwge1xuXHRcdFx0XHRcdC8qIFN0b3JlIHdoZXRoZXIgdGhpcyBpcyBhbiBTVkcgZWxlbWVudCwgc2luY2UgaXRzIHByb3BlcnRpZXMgYXJlIHJldHJpZXZlZCBhbmQgdXBkYXRlZCBkaWZmZXJlbnRseSB0aGFuIHN0YW5kYXJkIEhUTUwgZWxlbWVudHMuICovXG5cdFx0XHRcdFx0aXNTVkc6IFR5cGUuaXNTVkcoZWxlbWVudCksXG5cdFx0XHRcdFx0LyogS2VlcCB0cmFjayBvZiB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGN1cnJlbnRseSBiZWluZyBhbmltYXRlZCBieSBWZWxvY2l0eS5cblx0XHRcdFx0XHQgVGhpcyBpcyB1c2VkIHRvIGVuc3VyZSB0aGF0IHByb3BlcnR5IHZhbHVlcyBhcmUgbm90IHRyYW5zZmVycmVkIGJldHdlZW4gbm9uLWNvbnNlY3V0aXZlIChzdGFsZSkgY2FsbHMuICovXG5cdFx0XHRcdFx0aXNBbmltYXRpbmc6IGZhbHNlLFxuXHRcdFx0XHRcdC8qIEEgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50J3MgbGl2ZSBjb21wdXRlZFN0eWxlIG9iamVjdC4gTGVhcm4gbW9yZSBoZXJlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvd2luZG93LmdldENvbXB1dGVkU3R5bGUgKi9cblx0XHRcdFx0XHRjb21wdXRlZFN0eWxlOiBudWxsLFxuXHRcdFx0XHRcdC8qIFR3ZWVuIGRhdGEgaXMgY2FjaGVkIGZvciBlYWNoIGFuaW1hdGlvbiBvbiB0aGUgZWxlbWVudCBzbyB0aGF0IGRhdGEgY2FuIGJlIHBhc3NlZCBhY3Jvc3MgY2FsbHMgLS1cblx0XHRcdFx0XHQgaW4gcGFydGljdWxhciwgZW5kIHZhbHVlcyBhcmUgdXNlZCBhcyBzdWJzZXF1ZW50IHN0YXJ0IHZhbHVlcyBpbiBjb25zZWN1dGl2ZSBWZWxvY2l0eSBjYWxscy4gKi9cblx0XHRcdFx0XHR0d2VlbnNDb250YWluZXI6IG51bGwsXG5cdFx0XHRcdFx0LyogVGhlIGZ1bGwgcm9vdCBwcm9wZXJ0eSB2YWx1ZXMgb2YgZWFjaCBDU1MgaG9vayBiZWluZyBhbmltYXRlZCBvbiB0aGlzIGVsZW1lbnQgYXJlIGNhY2hlZCBzbyB0aGF0OlxuXHRcdFx0XHRcdCAxKSBDb25jdXJyZW50bHktYW5pbWF0aW5nIGhvb2tzIHNoYXJpbmcgdGhlIHNhbWUgcm9vdCBjYW4gaGF2ZSB0aGVpciByb290IHZhbHVlcycgbWVyZ2VkIGludG8gb25lIHdoaWxlIHR3ZWVuaW5nLlxuXHRcdFx0XHRcdCAyKSBQb3N0LWhvb2staW5qZWN0aW9uIHJvb3QgdmFsdWVzIGNhbiBiZSB0cmFuc2ZlcnJlZCBvdmVyIHRvIGNvbnNlY3V0aXZlbHkgY2hhaW5lZCBWZWxvY2l0eSBjYWxscyBhcyBzdGFydGluZyByb290IHZhbHVlcy4gKi9cblx0XHRcdFx0XHRyb290UHJvcGVydHlWYWx1ZUNhY2hlOiB7fSxcblx0XHRcdFx0XHQvKiBBIGNhY2hlIGZvciB0cmFuc2Zvcm0gdXBkYXRlcywgd2hpY2ggbXVzdCBiZSBtYW51YWxseSBmbHVzaGVkIHZpYSBDU1MuZmx1c2hUcmFuc2Zvcm1DYWNoZSgpLiAqL1xuXHRcdFx0XHRcdHRyYW5zZm9ybUNhY2hlOiB7fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHQvKiBBIHBhcmFsbGVsIHRvIGpRdWVyeSdzICQuY3NzKCksIHVzZWQgZm9yIGdldHRpbmcvc2V0dGluZyBWZWxvY2l0eSdzIGhvb2tlZCBDU1MgcHJvcGVydGllcy4gKi9cblx0XHRcdGhvb2s6IG51bGwsIC8qIERlZmluZWQgYmVsb3cuICovXG5cdFx0XHQvKiBWZWxvY2l0eS13aWRlIGFuaW1hdGlvbiB0aW1lIHJlbWFwcGluZyBmb3IgdGVzdGluZyBwdXJwb3Nlcy4gKi9cblx0XHRcdG1vY2s6IGZhbHNlLFxuXHRcdFx0dmVyc2lvbjoge21ham9yOiAxLCBtaW5vcjogNSwgcGF0Y2g6IDF9LFxuXHRcdFx0LyogU2V0IHRvIDEgb3IgMiAobW9zdCB2ZXJib3NlKSB0byBvdXRwdXQgZGVidWcgaW5mbyB0byBjb25zb2xlLiAqL1xuXHRcdFx0ZGVidWc6IGZhbHNlLFxuXHRcdFx0LyogVXNlIHJBRiBoaWdoIHJlc29sdXRpb24gdGltZXN0YW1wIHdoZW4gYXZhaWxhYmxlICovXG5cdFx0XHR0aW1lc3RhbXA6IHRydWUsXG5cdFx0XHQvKiBQYXVzZSBhbGwgYW5pbWF0aW9ucyAqL1xuXHRcdFx0cGF1c2VBbGw6IGZ1bmN0aW9uKHF1ZXVlTmFtZSkge1xuXHRcdFx0XHR2YXIgY3VycmVudFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG5cdFx0XHRcdCQuZWFjaChWZWxvY2l0eS5TdGF0ZS5jYWxscywgZnVuY3Rpb24oaSwgYWN0aXZlQ2FsbCkge1xuXG5cdFx0XHRcdFx0aWYgKGFjdGl2ZUNhbGwpIHtcblxuXHRcdFx0XHRcdFx0LyogSWYgd2UgaGF2ZSBhIHF1ZXVlTmFtZSBhbmQgdGhpcyBjYWxsIGlzIG5vdCBvbiB0aGF0IHF1ZXVlLCBza2lwICovXG5cdFx0XHRcdFx0XHRpZiAocXVldWVOYW1lICE9PSB1bmRlZmluZWQgJiYgKChhY3RpdmVDYWxsWzJdLnF1ZXVlICE9PSBxdWV1ZU5hbWUpIHx8IChhY3RpdmVDYWxsWzJdLnF1ZXVlID09PSBmYWxzZSkpKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBTZXQgY2FsbCB0byBwYXVzZWQgKi9cblx0XHRcdFx0XHRcdGFjdGl2ZUNhbGxbNV0gPSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VtZTogZmFsc2Vcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvKiBQYXVzZSB0aW1lcnMgb24gYW55IGN1cnJlbnRseSBkZWxheWVkIGNhbGxzICovXG5cdFx0XHRcdCQuZWFjaChWZWxvY2l0eS5TdGF0ZS5kZWxheWVkRWxlbWVudHMsIGZ1bmN0aW9uKGssIGVsZW1lbnQpIHtcblx0XHRcdFx0XHRpZiAoIWVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGF1c2VEZWxheU9uRWxlbWVudChlbGVtZW50LCBjdXJyZW50VGltZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdC8qIFJlc3VtZSBhbGwgYW5pbWF0aW9ucyAqL1xuXHRcdFx0cmVzdW1lQWxsOiBmdW5jdGlvbihxdWV1ZU5hbWUpIHtcblx0XHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuXHRcdFx0XHQkLmVhY2goVmVsb2NpdHkuU3RhdGUuY2FsbHMsIGZ1bmN0aW9uKGksIGFjdGl2ZUNhbGwpIHtcblxuXHRcdFx0XHRcdGlmIChhY3RpdmVDYWxsKSB7XG5cblx0XHRcdFx0XHRcdC8qIElmIHdlIGhhdmUgYSBxdWV1ZU5hbWUgYW5kIHRoaXMgY2FsbCBpcyBub3Qgb24gdGhhdCBxdWV1ZSwgc2tpcCAqL1xuXHRcdFx0XHRcdFx0aWYgKHF1ZXVlTmFtZSAhPT0gdW5kZWZpbmVkICYmICgoYWN0aXZlQ2FsbFsyXS5xdWV1ZSAhPT0gcXVldWVOYW1lKSB8fCAoYWN0aXZlQ2FsbFsyXS5xdWV1ZSA9PT0gZmFsc2UpKSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyogU2V0IGNhbGwgdG8gcmVzdW1lZCBpZiBpdCB3YXMgcGF1c2VkICovXG5cdFx0XHRcdFx0XHRpZiAoYWN0aXZlQ2FsbFs1XSkge1xuXHRcdFx0XHRcdFx0XHRhY3RpdmVDYWxsWzVdLnJlc3VtZSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0LyogUmVzdW1lIHRpbWVycyBvbiBhbnkgY3VycmVudGx5IGRlbGF5ZWQgY2FsbHMgKi9cblx0XHRcdFx0JC5lYWNoKFZlbG9jaXR5LlN0YXRlLmRlbGF5ZWRFbGVtZW50cywgZnVuY3Rpb24oaywgZWxlbWVudCkge1xuXHRcdFx0XHRcdGlmICghZWxlbWVudCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXN1bWVEZWxheU9uRWxlbWVudChlbGVtZW50LCBjdXJyZW50VGltZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHQvKiBSZXRyaWV2ZSB0aGUgYXBwcm9wcmlhdGUgc2Nyb2xsIGFuY2hvciBhbmQgcHJvcGVydHkgbmFtZSBmb3IgdGhlIGJyb3dzZXI6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cuc2Nyb2xsWSAqL1xuXHRcdGlmICh3aW5kb3cucGFnZVlPZmZzZXQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0VmVsb2NpdHkuU3RhdGUuc2Nyb2xsQW5jaG9yID0gd2luZG93O1xuXHRcdFx0VmVsb2NpdHkuU3RhdGUuc2Nyb2xsUHJvcGVydHlMZWZ0ID0gXCJwYWdlWE9mZnNldFwiO1xuXHRcdFx0VmVsb2NpdHkuU3RhdGUuc2Nyb2xsUHJvcGVydHlUb3AgPSBcInBhZ2VZT2Zmc2V0XCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFZlbG9jaXR5LlN0YXRlLnNjcm9sbEFuY2hvciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUgfHwgZG9jdW1lbnQuYm9keTtcblx0XHRcdFZlbG9jaXR5LlN0YXRlLnNjcm9sbFByb3BlcnR5TGVmdCA9IFwic2Nyb2xsTGVmdFwiO1xuXHRcdFx0VmVsb2NpdHkuU3RhdGUuc2Nyb2xsUHJvcGVydHlUb3AgPSBcInNjcm9sbFRvcFwiO1xuXHRcdH1cblxuXHRcdC8qIFNob3J0aGFuZCBhbGlhcyBmb3IgalF1ZXJ5J3MgJC5kYXRhKCkgdXRpbGl0eS4gKi9cblx0XHRmdW5jdGlvbiBEYXRhKGVsZW1lbnQpIHtcblx0XHRcdC8qIEhhcmRjb2RlIGEgcmVmZXJlbmNlIHRvIHRoZSBwbHVnaW4gbmFtZS4gKi9cblx0XHRcdHZhciByZXNwb25zZSA9ICQuZGF0YShlbGVtZW50LCBcInZlbG9jaXR5XCIpO1xuXG5cdFx0XHQvKiBqUXVlcnkgPD0xLjQuMiByZXR1cm5zIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQgd2hlbiBubyBtYXRjaCBpcyBmb3VuZC4gV2Ugbm9ybWFsaXplIHRoaXMgYmVoYXZpb3IuICovXG5cdFx0XHRyZXR1cm4gcmVzcG9uc2UgPT09IG51bGwgPyB1bmRlZmluZWQgOiByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvKioqKioqKioqKioqKipcblx0XHQgRGVsYXkgVGltZXJcblx0XHQgKioqKioqKioqKioqKiovXG5cblx0XHRmdW5jdGlvbiBwYXVzZURlbGF5T25FbGVtZW50KGVsZW1lbnQsIGN1cnJlbnRUaW1lKSB7XG5cdFx0XHQvKiBDaGVjayBmb3IgYW55IGRlbGF5IHRpbWVycywgYW5kIHBhdXNlIHRoZSBzZXQgdGltZW91dHMgKHdoaWxlIHByZXNlcnZpbmcgdGltZSBkYXRhKVxuXHRcdFx0IHRvIGJlIHJlc3VtZWQgd2hlbiB0aGUgXCJyZXN1bWVcIiBjb21tYW5kIGlzIGlzc3VlZCAqL1xuXHRcdFx0dmFyIGRhdGEgPSBEYXRhKGVsZW1lbnQpO1xuXHRcdFx0aWYgKGRhdGEgJiYgZGF0YS5kZWxheVRpbWVyICYmICFkYXRhLmRlbGF5UGF1c2VkKSB7XG5cdFx0XHRcdGRhdGEuZGVsYXlSZW1haW5pbmcgPSBkYXRhLmRlbGF5IC0gY3VycmVudFRpbWUgKyBkYXRhLmRlbGF5QmVnaW47XG5cdFx0XHRcdGRhdGEuZGVsYXlQYXVzZWQgPSB0cnVlO1xuXHRcdFx0XHRjbGVhclRpbWVvdXQoZGF0YS5kZWxheVRpbWVyLnNldFRpbWVvdXQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlc3VtZURlbGF5T25FbGVtZW50KGVsZW1lbnQsIGN1cnJlbnRUaW1lKSB7XG5cdFx0XHQvKiBDaGVjayBmb3IgYW55IHBhdXNlZCB0aW1lcnMgYW5kIHJlc3VtZSAqL1xuXHRcdFx0dmFyIGRhdGEgPSBEYXRhKGVsZW1lbnQpO1xuXHRcdFx0aWYgKGRhdGEgJiYgZGF0YS5kZWxheVRpbWVyICYmIGRhdGEuZGVsYXlQYXVzZWQpIHtcblx0XHRcdFx0LyogSWYgdGhlIGVsZW1lbnQgd2FzIG1pZC1kZWxheSwgcmUgaW5pdGlhdGUgdGhlIHRpbWVvdXQgd2l0aCB0aGUgcmVtYWluaW5nIGRlbGF5ICovXG5cdFx0XHRcdGRhdGEuZGVsYXlQYXVzZWQgPSBmYWxzZTtcblx0XHRcdFx0ZGF0YS5kZWxheVRpbWVyLnNldFRpbWVvdXQgPSBzZXRUaW1lb3V0KGRhdGEuZGVsYXlUaW1lci5uZXh0LCBkYXRhLmRlbGF5UmVtYWluaW5nKTtcblx0XHRcdH1cblx0XHR9XG5cblxuXG5cdFx0LyoqKioqKioqKioqKioqXG5cdFx0IEVhc2luZ1xuXHRcdCAqKioqKioqKioqKioqKi9cblxuXHRcdC8qIFN0ZXAgZWFzaW5nIGdlbmVyYXRvci4gKi9cblx0XHRmdW5jdGlvbiBnZW5lcmF0ZVN0ZXAoc3RlcHMpIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbihwKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnJvdW5kKHAgKiBzdGVwcykgKiAoMSAvIHN0ZXBzKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0LyogQmV6aWVyIGN1cnZlIGZ1bmN0aW9uIGdlbmVyYXRvci4gQ29weXJpZ2h0IEdhZXRhbiBSZW5hdWRlYXUuIE1JVCBMaWNlbnNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01JVF9MaWNlbnNlICovXG5cdFx0ZnVuY3Rpb24gZ2VuZXJhdGVCZXppZXIobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG5cdFx0XHR2YXIgTkVXVE9OX0lURVJBVElPTlMgPSA0LFxuXHRcdFx0XHRcdE5FV1RPTl9NSU5fU0xPUEUgPSAwLjAwMSxcblx0XHRcdFx0XHRTVUJESVZJU0lPTl9QUkVDSVNJT04gPSAwLjAwMDAwMDEsXG5cdFx0XHRcdFx0U1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMgPSAxMCxcblx0XHRcdFx0XHRrU3BsaW5lVGFibGVTaXplID0gMTEsXG5cdFx0XHRcdFx0a1NhbXBsZVN0ZXBTaXplID0gMS4wIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxLjApLFxuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVN1cHBvcnRlZCA9IFwiRmxvYXQzMkFycmF5XCIgaW4gd2luZG93O1xuXG5cdFx0XHQvKiBNdXN0IGNvbnRhaW4gZm91ciBhcmd1bWVudHMuICovXG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gNCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8qIEFyZ3VtZW50cyBtdXN0IGJlIG51bWJlcnMuICovXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSAhPT0gXCJudW1iZXJcIiB8fCBpc05hTihhcmd1bWVudHNbaV0pIHx8ICFpc0Zpbml0ZShhcmd1bWVudHNbaV0pKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8qIFggdmFsdWVzIG11c3QgYmUgaW4gdGhlIFswLCAxXSByYW5nZS4gKi9cblx0XHRcdG1YMSA9IE1hdGgubWluKG1YMSwgMSk7XG5cdFx0XHRtWDIgPSBNYXRoLm1pbihtWDIsIDEpO1xuXHRcdFx0bVgxID0gTWF0aC5tYXgobVgxLCAwKTtcblx0XHRcdG1YMiA9IE1hdGgubWF4KG1YMiwgMCk7XG5cblx0XHRcdHZhciBtU2FtcGxlVmFsdWVzID0gZmxvYXQzMkFycmF5U3VwcG9ydGVkID8gbmV3IEZsb2F0MzJBcnJheShrU3BsaW5lVGFibGVTaXplKSA6IG5ldyBBcnJheShrU3BsaW5lVGFibGVTaXplKTtcblxuXHRcdFx0ZnVuY3Rpb24gQShhQTEsIGFBMikge1xuXHRcdFx0XHRyZXR1cm4gMS4wIC0gMy4wICogYUEyICsgMy4wICogYUExO1xuXHRcdFx0fVxuXHRcdFx0ZnVuY3Rpb24gQihhQTEsIGFBMikge1xuXHRcdFx0XHRyZXR1cm4gMy4wICogYUEyIC0gNi4wICogYUExO1xuXHRcdFx0fVxuXHRcdFx0ZnVuY3Rpb24gQyhhQTEpIHtcblx0XHRcdFx0cmV0dXJuIDMuMCAqIGFBMTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY2FsY0JlemllcihhVCwgYUExLCBhQTIpIHtcblx0XHRcdFx0cmV0dXJuICgoQShhQTEsIGFBMikgKiBhVCArIEIoYUExLCBhQTIpKSAqIGFUICsgQyhhQTEpKSAqIGFUO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZXRTbG9wZShhVCwgYUExLCBhQTIpIHtcblx0XHRcdFx0cmV0dXJuIDMuMCAqIEEoYUExLCBhQTIpICogYVQgKiBhVCArIDIuMCAqIEIoYUExLCBhQTIpICogYVQgKyBDKGFBMSk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NUKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgTkVXVE9OX0lURVJBVElPTlM7ICsraSkge1xuXHRcdFx0XHRcdHZhciBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG5cblx0XHRcdFx0XHRpZiAoY3VycmVudFNsb3BlID09PSAwLjApIHtcblx0XHRcdFx0XHRcdHJldHVybiBhR3Vlc3NUO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG5cdFx0XHRcdFx0YUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBhR3Vlc3NUO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjYWxjU2FtcGxlVmFsdWVzKCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtTcGxpbmVUYWJsZVNpemU7ICsraSkge1xuXHRcdFx0XHRcdG1TYW1wbGVWYWx1ZXNbaV0gPSBjYWxjQmV6aWVyKGkgKiBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBiaW5hcnlTdWJkaXZpZGUoYVgsIGFBLCBhQikge1xuXHRcdFx0XHR2YXIgY3VycmVudFgsIGN1cnJlbnRULCBpID0gMDtcblxuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0Y3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDIuMDtcblx0XHRcdFx0XHRjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuXHRcdFx0XHRcdGlmIChjdXJyZW50WCA+IDAuMCkge1xuXHRcdFx0XHRcdFx0YUIgPSBjdXJyZW50VDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YUEgPSBjdXJyZW50VDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IFNVQkRJVklTSU9OX1BSRUNJU0lPTiAmJiArK2kgPCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyk7XG5cblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRUO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZXRURm9yWChhWCkge1xuXHRcdFx0XHR2YXIgaW50ZXJ2YWxTdGFydCA9IDAuMCxcblx0XHRcdFx0XHRcdGN1cnJlbnRTYW1wbGUgPSAxLFxuXHRcdFx0XHRcdFx0bGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuXG5cdFx0XHRcdGZvciAoOyBjdXJyZW50U2FtcGxlICE9PSBsYXN0U2FtcGxlICYmIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuXHRcdFx0XHRcdGludGVydmFsU3RhcnQgKz0ga1NhbXBsZVN0ZXBTaXplO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LS1jdXJyZW50U2FtcGxlO1xuXG5cdFx0XHRcdHZhciBkaXN0ID0gKGFYIC0gbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAobVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlICsgMV0gLSBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSxcblx0XHRcdFx0XHRcdGd1ZXNzRm9yVCA9IGludGVydmFsU3RhcnQgKyBkaXN0ICoga1NhbXBsZVN0ZXBTaXplLFxuXHRcdFx0XHRcdFx0aW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG5cblx0XHRcdFx0aWYgKGluaXRpYWxTbG9wZSA+PSBORVdUT05fTUlOX1NMT1BFKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGluaXRpYWxTbG9wZSA9PT0gMC4wKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGd1ZXNzRm9yVDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gYmluYXJ5U3ViZGl2aWRlKGFYLCBpbnRlcnZhbFN0YXJ0LCBpbnRlcnZhbFN0YXJ0ICsga1NhbXBsZVN0ZXBTaXplKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgX3ByZWNvbXB1dGVkID0gZmFsc2U7XG5cblx0XHRcdGZ1bmN0aW9uIHByZWNvbXB1dGUoKSB7XG5cdFx0XHRcdF9wcmVjb21wdXRlZCA9IHRydWU7XG5cdFx0XHRcdGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMikge1xuXHRcdFx0XHRcdGNhbGNTYW1wbGVWYWx1ZXMoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZiA9IGZ1bmN0aW9uKGFYKSB7XG5cdFx0XHRcdGlmICghX3ByZWNvbXB1dGVkKSB7XG5cdFx0XHRcdFx0cHJlY29tcHV0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMikge1xuXHRcdFx0XHRcdHJldHVybiBhWDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYVggPT09IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYVggPT09IDEpIHtcblx0XHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBjYWxjQmV6aWVyKGdldFRGb3JYKGFYKSwgbVkxLCBtWTIpO1xuXHRcdFx0fTtcblxuXHRcdFx0Zi5nZXRDb250cm9sUG9pbnRzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBbe3g6IG1YMSwgeTogbVkxfSwge3g6IG1YMiwgeTogbVkyfV07XG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgc3RyID0gXCJnZW5lcmF0ZUJlemllcihcIiArIFttWDEsIG1ZMSwgbVgyLCBtWTJdICsgXCIpXCI7XG5cdFx0XHRmLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBzdHI7XG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gZjtcblx0XHR9XG5cblx0XHQvKiBSdW5nZS1LdXR0YSBzcHJpbmcgcGh5c2ljcyBmdW5jdGlvbiBnZW5lcmF0b3IuIEFkYXB0ZWQgZnJvbSBGcmFtZXIuanMsIGNvcHlyaWdodCBLb2VuIEJvay4gTUlUIExpY2Vuc2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2UgKi9cblx0XHQvKiBHaXZlbiBhIHRlbnNpb24sIGZyaWN0aW9uLCBhbmQgZHVyYXRpb24sIGEgc2ltdWxhdGlvbiBhdCA2MEZQUyB3aWxsIGZpcnN0IHJ1biB3aXRob3V0IGEgZGVmaW5lZCBkdXJhdGlvbiBpbiBvcmRlciB0byBjYWxjdWxhdGUgdGhlIGZ1bGwgcGF0aC4gQSBzZWNvbmQgcGFzc1xuXHRcdCB0aGVuIGFkanVzdHMgdGhlIHRpbWUgZGVsdGEgLS0gdXNpbmcgdGhlIHJlbGF0aW9uIGJldHdlZW4gYWN0dWFsIHRpbWUgYW5kIGR1cmF0aW9uIC0tIHRvIGNhbGN1bGF0ZSB0aGUgcGF0aCBmb3IgdGhlIGR1cmF0aW9uLWNvbnN0cmFpbmVkIGFuaW1hdGlvbi4gKi9cblx0XHR2YXIgZ2VuZXJhdGVTcHJpbmdSSzQgPSAoZnVuY3Rpb24oKSB7XG5cdFx0XHRmdW5jdGlvbiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZShzdGF0ZSkge1xuXHRcdFx0XHRyZXR1cm4gKC1zdGF0ZS50ZW5zaW9uICogc3RhdGUueCkgLSAoc3RhdGUuZnJpY3Rpb24gKiBzdGF0ZS52KTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKGluaXRpYWxTdGF0ZSwgZHQsIGRlcml2YXRpdmUpIHtcblx0XHRcdFx0dmFyIHN0YXRlID0ge1xuXHRcdFx0XHRcdHg6IGluaXRpYWxTdGF0ZS54ICsgZGVyaXZhdGl2ZS5keCAqIGR0LFxuXHRcdFx0XHRcdHY6IGluaXRpYWxTdGF0ZS52ICsgZGVyaXZhdGl2ZS5kdiAqIGR0LFxuXHRcdFx0XHRcdHRlbnNpb246IGluaXRpYWxTdGF0ZS50ZW5zaW9uLFxuXHRcdFx0XHRcdGZyaWN0aW9uOiBpbml0aWFsU3RhdGUuZnJpY3Rpb25cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRyZXR1cm4ge2R4OiBzdGF0ZS52LCBkdjogc3ByaW5nQWNjZWxlcmF0aW9uRm9yU3RhdGUoc3RhdGUpfTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gc3ByaW5nSW50ZWdyYXRlU3RhdGUoc3RhdGUsIGR0KSB7XG5cdFx0XHRcdHZhciBhID0ge1xuXHRcdFx0XHRcdGR4OiBzdGF0ZS52LFxuXHRcdFx0XHRcdGR2OiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZShzdGF0ZSlcblx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdGIgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoc3RhdGUsIGR0ICogMC41LCBhKSxcblx0XHRcdFx0XHRcdGMgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoc3RhdGUsIGR0ICogMC41LCBiKSxcblx0XHRcdFx0XHRcdGQgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoc3RhdGUsIGR0LCBjKSxcblx0XHRcdFx0XHRcdGR4ZHQgPSAxLjAgLyA2LjAgKiAoYS5keCArIDIuMCAqIChiLmR4ICsgYy5keCkgKyBkLmR4KSxcblx0XHRcdFx0XHRcdGR2ZHQgPSAxLjAgLyA2LjAgKiAoYS5kdiArIDIuMCAqIChiLmR2ICsgYy5kdikgKyBkLmR2KTtcblxuXHRcdFx0XHRzdGF0ZS54ID0gc3RhdGUueCArIGR4ZHQgKiBkdDtcblx0XHRcdFx0c3RhdGUudiA9IHN0YXRlLnYgKyBkdmR0ICogZHQ7XG5cblx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gc3ByaW5nUks0RmFjdG9yeSh0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24pIHtcblxuXHRcdFx0XHR2YXIgaW5pdFN0YXRlID0ge1xuXHRcdFx0XHRcdHg6IC0xLFxuXHRcdFx0XHRcdHY6IDAsXG5cdFx0XHRcdFx0dGVuc2lvbjogbnVsbCxcblx0XHRcdFx0XHRmcmljdGlvbjogbnVsbFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0cGF0aCA9IFswXSxcblx0XHRcdFx0XHRcdHRpbWVfbGFwc2VkID0gMCxcblx0XHRcdFx0XHRcdHRvbGVyYW5jZSA9IDEgLyAxMDAwMCxcblx0XHRcdFx0XHRcdERUID0gMTYgLyAxMDAwLFxuXHRcdFx0XHRcdFx0aGF2ZV9kdXJhdGlvbiwgZHQsIGxhc3Rfc3RhdGU7XG5cblx0XHRcdFx0dGVuc2lvbiA9IHBhcnNlRmxvYXQodGVuc2lvbikgfHwgNTAwO1xuXHRcdFx0XHRmcmljdGlvbiA9IHBhcnNlRmxvYXQoZnJpY3Rpb24pIHx8IDIwO1xuXHRcdFx0XHRkdXJhdGlvbiA9IGR1cmF0aW9uIHx8IG51bGw7XG5cblx0XHRcdFx0aW5pdFN0YXRlLnRlbnNpb24gPSB0ZW5zaW9uO1xuXHRcdFx0XHRpbml0U3RhdGUuZnJpY3Rpb24gPSBmcmljdGlvbjtcblxuXHRcdFx0XHRoYXZlX2R1cmF0aW9uID0gZHVyYXRpb24gIT09IG51bGw7XG5cblx0XHRcdFx0LyogQ2FsY3VsYXRlIHRoZSBhY3R1YWwgdGltZSBpdCB0YWtlcyBmb3IgdGhpcyBhbmltYXRpb24gdG8gY29tcGxldGUgd2l0aCB0aGUgcHJvdmlkZWQgY29uZGl0aW9ucy4gKi9cblx0XHRcdFx0aWYgKGhhdmVfZHVyYXRpb24pIHtcblx0XHRcdFx0XHQvKiBSdW4gdGhlIHNpbXVsYXRpb24gd2l0aG91dCBhIGR1cmF0aW9uLiAqL1xuXHRcdFx0XHRcdHRpbWVfbGFwc2VkID0gc3ByaW5nUks0RmFjdG9yeSh0ZW5zaW9uLCBmcmljdGlvbik7XG5cdFx0XHRcdFx0LyogQ29tcHV0ZSB0aGUgYWRqdXN0ZWQgdGltZSBkZWx0YS4gKi9cblx0XHRcdFx0XHRkdCA9IHRpbWVfbGFwc2VkIC8gZHVyYXRpb24gKiBEVDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkdCA9IERUO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdFx0XHQvKiBOZXh0L3N0ZXAgZnVuY3Rpb24gLiovXG5cdFx0XHRcdFx0bGFzdF9zdGF0ZSA9IHNwcmluZ0ludGVncmF0ZVN0YXRlKGxhc3Rfc3RhdGUgfHwgaW5pdFN0YXRlLCBkdCk7XG5cdFx0XHRcdFx0LyogU3RvcmUgdGhlIHBvc2l0aW9uLiAqL1xuXHRcdFx0XHRcdHBhdGgucHVzaCgxICsgbGFzdF9zdGF0ZS54KTtcblx0XHRcdFx0XHR0aW1lX2xhcHNlZCArPSAxNjtcblx0XHRcdFx0XHQvKiBJZiB0aGUgY2hhbmdlIHRocmVzaG9sZCBpcyByZWFjaGVkLCBicmVhay4gKi9cblx0XHRcdFx0XHRpZiAoIShNYXRoLmFicyhsYXN0X3N0YXRlLngpID4gdG9sZXJhbmNlICYmIE1hdGguYWJzKGxhc3Rfc3RhdGUudikgPiB0b2xlcmFuY2UpKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBJZiBkdXJhdGlvbiBpcyBub3QgZGVmaW5lZCwgcmV0dXJuIHRoZSBhY3R1YWwgdGltZSByZXF1aXJlZCBmb3IgY29tcGxldGluZyB0aGlzIGFuaW1hdGlvbi4gT3RoZXJ3aXNlLCByZXR1cm4gYSBjbG9zdXJlIHRoYXQgaG9sZHMgdGhlXG5cdFx0XHRcdCBjb21wdXRlZCBwYXRoIGFuZCByZXR1cm5zIGEgc25hcHNob3Qgb2YgdGhlIHBvc2l0aW9uIGFjY29yZGluZyB0byBhIGdpdmVuIHBlcmNlbnRDb21wbGV0ZS4gKi9cblx0XHRcdFx0cmV0dXJuICFoYXZlX2R1cmF0aW9uID8gdGltZV9sYXBzZWQgOiBmdW5jdGlvbihwZXJjZW50Q29tcGxldGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0aFsgKHBlcmNlbnRDb21wbGV0ZSAqIChwYXRoLmxlbmd0aCAtIDEpKSB8IDAgXTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0fSgpKTtcblxuXHRcdC8qIGpRdWVyeSBlYXNpbmdzLiAqL1xuXHRcdFZlbG9jaXR5LkVhc2luZ3MgPSB7XG5cdFx0XHRsaW5lYXI6IGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIHA7XG5cdFx0XHR9LFxuXHRcdFx0c3dpbmc6IGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKHAgKiBNYXRoLlBJKSAvIDI7XG5cdFx0XHR9LFxuXHRcdFx0LyogQm9udXMgXCJzcHJpbmdcIiBlYXNpbmcsIHdoaWNoIGlzIGEgbGVzcyBleGFnZ2VyYXRlZCB2ZXJzaW9uIG9mIGVhc2VJbk91dEVsYXN0aWMuICovXG5cdFx0XHRzcHJpbmc6IGZ1bmN0aW9uKHApIHtcblx0XHRcdFx0cmV0dXJuIDEgLSAoTWF0aC5jb3MocCAqIDQuNSAqIE1hdGguUEkpICogTWF0aC5leHAoLXAgKiA2KSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qIENTUzMgYW5kIFJvYmVydCBQZW5uZXIgZWFzaW5ncy4gKi9cblx0XHQkLmVhY2goXG5cdFx0XHRcdFtcblx0XHRcdFx0XHRbXCJlYXNlXCIsIFswLjI1LCAwLjEsIDAuMjUsIDEuMF1dLFxuXHRcdFx0XHRcdFtcImVhc2UtaW5cIiwgWzAuNDIsIDAuMCwgMS4wMCwgMS4wXV0sXG5cdFx0XHRcdFx0W1wiZWFzZS1vdXRcIiwgWzAuMDAsIDAuMCwgMC41OCwgMS4wXV0sXG5cdFx0XHRcdFx0W1wiZWFzZS1pbi1vdXRcIiwgWzAuNDIsIDAuMCwgMC41OCwgMS4wXV0sXG5cdFx0XHRcdFx0W1wiZWFzZUluU2luZVwiLCBbMC40NywgMCwgMC43NDUsIDAuNzE1XV0sXG5cdFx0XHRcdFx0W1wiZWFzZU91dFNpbmVcIiwgWzAuMzksIDAuNTc1LCAwLjU2NSwgMV1dLFxuXHRcdFx0XHRcdFtcImVhc2VJbk91dFNpbmVcIiwgWzAuNDQ1LCAwLjA1LCAwLjU1LCAwLjk1XV0sXG5cdFx0XHRcdFx0W1wiZWFzZUluUXVhZFwiLCBbMC41NSwgMC4wODUsIDAuNjgsIDAuNTNdXSxcblx0XHRcdFx0XHRbXCJlYXNlT3V0UXVhZFwiLCBbMC4yNSwgMC40NiwgMC40NSwgMC45NF1dLFxuXHRcdFx0XHRcdFtcImVhc2VJbk91dFF1YWRcIiwgWzAuNDU1LCAwLjAzLCAwLjUxNSwgMC45NTVdXSxcblx0XHRcdFx0XHRbXCJlYXNlSW5DdWJpY1wiLCBbMC41NSwgMC4wNTUsIDAuNjc1LCAwLjE5XV0sXG5cdFx0XHRcdFx0W1wiZWFzZU91dEN1YmljXCIsIFswLjIxNSwgMC42MSwgMC4zNTUsIDFdXSxcblx0XHRcdFx0XHRbXCJlYXNlSW5PdXRDdWJpY1wiLCBbMC42NDUsIDAuMDQ1LCAwLjM1NSwgMV1dLFxuXHRcdFx0XHRcdFtcImVhc2VJblF1YXJ0XCIsIFswLjg5NSwgMC4wMywgMC42ODUsIDAuMjJdXSxcblx0XHRcdFx0XHRbXCJlYXNlT3V0UXVhcnRcIiwgWzAuMTY1LCAwLjg0LCAwLjQ0LCAxXV0sXG5cdFx0XHRcdFx0W1wiZWFzZUluT3V0UXVhcnRcIiwgWzAuNzcsIDAsIDAuMTc1LCAxXV0sXG5cdFx0XHRcdFx0W1wiZWFzZUluUXVpbnRcIiwgWzAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNl1dLFxuXHRcdFx0XHRcdFtcImVhc2VPdXRRdWludFwiLCBbMC4yMywgMSwgMC4zMiwgMV1dLFxuXHRcdFx0XHRcdFtcImVhc2VJbk91dFF1aW50XCIsIFswLjg2LCAwLCAwLjA3LCAxXV0sXG5cdFx0XHRcdFx0W1wiZWFzZUluRXhwb1wiLCBbMC45NSwgMC4wNSwgMC43OTUsIDAuMDM1XV0sXG5cdFx0XHRcdFx0W1wiZWFzZU91dEV4cG9cIiwgWzAuMTksIDEsIDAuMjIsIDFdXSxcblx0XHRcdFx0XHRbXCJlYXNlSW5PdXRFeHBvXCIsIFsxLCAwLCAwLCAxXV0sXG5cdFx0XHRcdFx0W1wiZWFzZUluQ2lyY1wiLCBbMC42LCAwLjA0LCAwLjk4LCAwLjMzNV1dLFxuXHRcdFx0XHRcdFtcImVhc2VPdXRDaXJjXCIsIFswLjA3NSwgMC44MiwgMC4xNjUsIDFdXSxcblx0XHRcdFx0XHRbXCJlYXNlSW5PdXRDaXJjXCIsIFswLjc4NSwgMC4xMzUsIDAuMTUsIDAuODZdXVxuXHRcdFx0XHRdLCBmdW5jdGlvbihpLCBlYXNpbmdBcnJheSkge1xuXHRcdFx0VmVsb2NpdHkuRWFzaW5nc1tlYXNpbmdBcnJheVswXV0gPSBnZW5lcmF0ZUJlemllci5hcHBseShudWxsLCBlYXNpbmdBcnJheVsxXSk7XG5cdFx0fSk7XG5cblx0XHQvKiBEZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGVhc2luZyB0eXBlIGdpdmVuIGFuIGVhc2luZyBpbnB1dC4gKi9cblx0XHRmdW5jdGlvbiBnZXRFYXNpbmcodmFsdWUsIGR1cmF0aW9uKSB7XG5cdFx0XHR2YXIgZWFzaW5nID0gdmFsdWU7XG5cblx0XHRcdC8qIFRoZSBlYXNpbmcgb3B0aW9uIGNhbiBlaXRoZXIgYmUgYSBzdHJpbmcgdGhhdCByZWZlcmVuY2VzIGEgcHJlLXJlZ2lzdGVyZWQgZWFzaW5nLFxuXHRcdFx0IG9yIGl0IGNhbiBiZSBhIHR3by0vZm91ci1pdGVtIGFycmF5IG9mIGludGVnZXJzIHRvIGJlIGNvbnZlcnRlZCBpbnRvIGEgYmV6aWVyL3NwcmluZyBmdW5jdGlvbi4gKi9cblx0XHRcdGlmIChUeXBlLmlzU3RyaW5nKHZhbHVlKSkge1xuXHRcdFx0XHQvKiBFbnN1cmUgdGhhdCB0aGUgZWFzaW5nIGhhcyBiZWVuIGFzc2lnbmVkIHRvIGpRdWVyeSdzIFZlbG9jaXR5LkVhc2luZ3Mgb2JqZWN0LiAqL1xuXHRcdFx0XHRpZiAoIVZlbG9jaXR5LkVhc2luZ3NbdmFsdWVdKSB7XG5cdFx0XHRcdFx0ZWFzaW5nID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoVHlwZS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0ZWFzaW5nID0gZ2VuZXJhdGVTdGVwLmFwcGx5KG51bGwsIHZhbHVlKTtcblx0XHRcdH0gZWxzZSBpZiAoVHlwZS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIpIHtcblx0XHRcdFx0Lyogc3ByaW5nUks0IG11c3QgYmUgcGFzc2VkIHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbi4gKi9cblx0XHRcdFx0LyogTm90ZTogSWYgdGhlIHNwcmluZ1JLNCBhcnJheSBjb250YWlucyBub24tbnVtYmVycywgZ2VuZXJhdGVTcHJpbmdSSzQoKSByZXR1cm5zIGFuIGVhc2luZ1xuXHRcdFx0XHQgZnVuY3Rpb24gZ2VuZXJhdGVkIHdpdGggZGVmYXVsdCB0ZW5zaW9uIGFuZCBmcmljdGlvbiB2YWx1ZXMuICovXG5cdFx0XHRcdGVhc2luZyA9IGdlbmVyYXRlU3ByaW5nUks0LmFwcGx5KG51bGwsIHZhbHVlLmNvbmNhdChbZHVyYXRpb25dKSk7XG5cdFx0XHR9IGVsc2UgaWYgKFR5cGUuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSA0KSB7XG5cdFx0XHRcdC8qIE5vdGU6IElmIHRoZSBiZXppZXIgYXJyYXkgY29udGFpbnMgbm9uLW51bWJlcnMsIGdlbmVyYXRlQmV6aWVyKCkgcmV0dXJucyBmYWxzZS4gKi9cblx0XHRcdFx0ZWFzaW5nID0gZ2VuZXJhdGVCZXppZXIuYXBwbHkobnVsbCwgdmFsdWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWFzaW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8qIFJldmVydCB0byB0aGUgVmVsb2NpdHktd2lkZSBkZWZhdWx0IGVhc2luZyB0eXBlLCBvciBmYWxsIGJhY2sgdG8gXCJzd2luZ1wiICh3aGljaCBpcyBhbHNvIGpRdWVyeSdzIGRlZmF1bHQpXG5cdFx0XHQgaWYgdGhlIFZlbG9jaXR5LXdpZGUgZGVmYXVsdCBoYXMgYmVlbiBpbmNvcnJlY3RseSBtb2RpZmllZC4gKi9cblx0XHRcdGlmIChlYXNpbmcgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGlmIChWZWxvY2l0eS5FYXNpbmdzW1ZlbG9jaXR5LmRlZmF1bHRzLmVhc2luZ10pIHtcblx0XHRcdFx0XHRlYXNpbmcgPSBWZWxvY2l0eS5kZWZhdWx0cy5lYXNpbmc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWFzaW5nID0gRUFTSU5HX0RFRkFVTFQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVhc2luZztcblx0XHR9XG5cblx0XHQvKioqKioqKioqKioqKioqKipcblx0XHQgQ1NTIFN0YWNrXG5cdFx0ICoqKioqKioqKioqKioqKioqL1xuXG5cdFx0LyogVGhlIENTUyBvYmplY3QgaXMgYSBoaWdobHkgY29uZGVuc2VkIGFuZCBwZXJmb3JtYW50IENTUyBzdGFjayB0aGF0IGZ1bGx5IHJlcGxhY2VzIGpRdWVyeSdzLlxuXHRcdCBJdCBoYW5kbGVzIHRoZSB2YWxpZGF0aW9uLCBnZXR0aW5nLCBhbmQgc2V0dGluZyBvZiBib3RoIHN0YW5kYXJkIENTUyBwcm9wZXJ0aWVzIGFuZCBDU1MgcHJvcGVydHkgaG9va3MuICovXG5cdFx0LyogTm90ZTogQSBcIkNTU1wiIHNob3J0aGFuZCBpcyBhbGlhc2VkIHNvIHRoYXQgb3VyIGNvZGUgaXMgZWFzaWVyIHRvIHJlYWQuICovXG5cdFx0dmFyIENTUyA9IFZlbG9jaXR5LkNTUyA9IHtcblx0XHRcdC8qKioqKioqKioqKioqXG5cdFx0XHQgUmVnRXhcblx0XHRcdCAqKioqKioqKioqKioqL1xuXG5cdFx0XHRSZWdFeDoge1xuXHRcdFx0XHRpc0hleDogL14jKFtBLWZcXGRdezN9KXsxLDJ9JC9pLFxuXHRcdFx0XHQvKiBVbndyYXAgYSBwcm9wZXJ0eSB2YWx1ZSdzIHN1cnJvdW5kaW5nIHRleHQsIGUuZy4gXCJyZ2JhKDQsIDMsIDIsIDEpXCIgPT0+IFwiNCwgMywgMiwgMVwiIGFuZCBcInJlY3QoNHB4IDNweCAycHggMXB4KVwiID09PiBcIjRweCAzcHggMnB4IDFweFwiLiAqL1xuXHRcdFx0XHR2YWx1ZVVud3JhcDogL15bQS16XStcXCgoLiopXFwpJC9pLFxuXHRcdFx0XHR3cmFwcGVkVmFsdWVBbHJlYWR5RXh0cmFjdGVkOiAvWzAtOS5dKyBbMC05Ll0rIFswLTkuXSsoIFswLTkuXSspPy8sXG5cdFx0XHRcdC8qIFNwbGl0IGEgbXVsdGktdmFsdWUgcHJvcGVydHkgaW50byBhbiBhcnJheSBvZiBzdWJ2YWx1ZXMsIGUuZy4gXCJyZ2JhKDQsIDMsIDIsIDEpIDRweCAzcHggMnB4IDFweFwiID09PiBbIFwicmdiYSg0LCAzLCAyLCAxKVwiLCBcIjRweFwiLCBcIjNweFwiLCBcIjJweFwiLCBcIjFweFwiIF0uICovXG5cdFx0XHRcdHZhbHVlU3BsaXQ6IC8oW0Etel0rXFwoLitcXCkpfCgoW0EtejAtOSMtLl0rPykoPz1cXHN8JCkpL2lnXG5cdFx0XHR9LFxuXHRcdFx0LyoqKioqKioqKioqKlxuXHRcdFx0IExpc3RzXG5cdFx0XHQgKioqKioqKioqKioqL1xuXG5cdFx0XHRMaXN0czoge1xuXHRcdFx0XHRjb2xvcnM6IFtcImZpbGxcIiwgXCJzdHJva2VcIiwgXCJzdG9wQ29sb3JcIiwgXCJjb2xvclwiLCBcImJhY2tncm91bmRDb2xvclwiLCBcImJvcmRlckNvbG9yXCIsIFwiYm9yZGVyVG9wQ29sb3JcIiwgXCJib3JkZXJSaWdodENvbG9yXCIsIFwiYm9yZGVyQm90dG9tQ29sb3JcIiwgXCJib3JkZXJMZWZ0Q29sb3JcIiwgXCJvdXRsaW5lQ29sb3JcIl0sXG5cdFx0XHRcdHRyYW5zZm9ybXNCYXNlOiBbXCJ0cmFuc2xhdGVYXCIsIFwidHJhbnNsYXRlWVwiLCBcInNjYWxlXCIsIFwic2NhbGVYXCIsIFwic2NhbGVZXCIsIFwic2tld1hcIiwgXCJza2V3WVwiLCBcInJvdGF0ZVpcIl0sXG5cdFx0XHRcdHRyYW5zZm9ybXMzRDogW1widHJhbnNmb3JtUGVyc3BlY3RpdmVcIiwgXCJ0cmFuc2xhdGVaXCIsIFwic2NhbGVaXCIsIFwicm90YXRlWFwiLCBcInJvdGF0ZVlcIl0sXG5cdFx0XHRcdHVuaXRzOiBbXG5cdFx0XHRcdFx0XCIlXCIsIC8vIHJlbGF0aXZlXG5cdFx0XHRcdFx0XCJlbVwiLCBcImV4XCIsIFwiY2hcIiwgXCJyZW1cIiwgLy8gZm9udCByZWxhdGl2ZVxuXHRcdFx0XHRcdFwidndcIiwgXCJ2aFwiLCBcInZtaW5cIiwgXCJ2bWF4XCIsIC8vIHZpZXdwb3J0IHJlbGF0aXZlXG5cdFx0XHRcdFx0XCJjbVwiLCBcIm1tXCIsIFwiUVwiLCBcImluXCIsIFwicGNcIiwgXCJwdFwiLCBcInB4XCIsIC8vIGFic29sdXRlIGxlbmd0aHNcblx0XHRcdFx0XHRcImRlZ1wiLCBcImdyYWRcIiwgXCJyYWRcIiwgXCJ0dXJuXCIsIC8vIGFuZ2xlc1xuXHRcdFx0XHRcdFwic1wiLCBcIm1zXCIgLy8gdGltZVxuXHRcdFx0XHRdLFxuXHRcdFx0XHRjb2xvck5hbWVzOiB7XG5cdFx0XHRcdFx0XCJhbGljZWJsdWVcIjogXCIyNDAsMjQ4LDI1NVwiLFxuXHRcdFx0XHRcdFwiYW50aXF1ZXdoaXRlXCI6IFwiMjUwLDIzNSwyMTVcIixcblx0XHRcdFx0XHRcImFxdWFtYXJpbmVcIjogXCIxMjcsMjU1LDIxMlwiLFxuXHRcdFx0XHRcdFwiYXF1YVwiOiBcIjAsMjU1LDI1NVwiLFxuXHRcdFx0XHRcdFwiYXp1cmVcIjogXCIyNDAsMjU1LDI1NVwiLFxuXHRcdFx0XHRcdFwiYmVpZ2VcIjogXCIyNDUsMjQ1LDIyMFwiLFxuXHRcdFx0XHRcdFwiYmlzcXVlXCI6IFwiMjU1LDIyOCwxOTZcIixcblx0XHRcdFx0XHRcImJsYWNrXCI6IFwiMCwwLDBcIixcblx0XHRcdFx0XHRcImJsYW5jaGVkYWxtb25kXCI6IFwiMjU1LDIzNSwyMDVcIixcblx0XHRcdFx0XHRcImJsdWV2aW9sZXRcIjogXCIxMzgsNDMsMjI2XCIsXG5cdFx0XHRcdFx0XCJibHVlXCI6IFwiMCwwLDI1NVwiLFxuXHRcdFx0XHRcdFwiYnJvd25cIjogXCIxNjUsNDIsNDJcIixcblx0XHRcdFx0XHRcImJ1cmx5d29vZFwiOiBcIjIyMiwxODQsMTM1XCIsXG5cdFx0XHRcdFx0XCJjYWRldGJsdWVcIjogXCI5NSwxNTgsMTYwXCIsXG5cdFx0XHRcdFx0XCJjaGFydHJldXNlXCI6IFwiMTI3LDI1NSwwXCIsXG5cdFx0XHRcdFx0XCJjaG9jb2xhdGVcIjogXCIyMTAsMTA1LDMwXCIsXG5cdFx0XHRcdFx0XCJjb3JhbFwiOiBcIjI1NSwxMjcsODBcIixcblx0XHRcdFx0XHRcImNvcm5mbG93ZXJibHVlXCI6IFwiMTAwLDE0OSwyMzdcIixcblx0XHRcdFx0XHRcImNvcm5zaWxrXCI6IFwiMjU1LDI0OCwyMjBcIixcblx0XHRcdFx0XHRcImNyaW1zb25cIjogXCIyMjAsMjAsNjBcIixcblx0XHRcdFx0XHRcImN5YW5cIjogXCIwLDI1NSwyNTVcIixcblx0XHRcdFx0XHRcImRhcmtibHVlXCI6IFwiMCwwLDEzOVwiLFxuXHRcdFx0XHRcdFwiZGFya2N5YW5cIjogXCIwLDEzOSwxMzlcIixcblx0XHRcdFx0XHRcImRhcmtnb2xkZW5yb2RcIjogXCIxODQsMTM0LDExXCIsXG5cdFx0XHRcdFx0XCJkYXJrZ3JheVwiOiBcIjE2OSwxNjksMTY5XCIsXG5cdFx0XHRcdFx0XCJkYXJrZ3JleVwiOiBcIjE2OSwxNjksMTY5XCIsXG5cdFx0XHRcdFx0XCJkYXJrZ3JlZW5cIjogXCIwLDEwMCwwXCIsXG5cdFx0XHRcdFx0XCJkYXJra2hha2lcIjogXCIxODksMTgzLDEwN1wiLFxuXHRcdFx0XHRcdFwiZGFya21hZ2VudGFcIjogXCIxMzksMCwxMzlcIixcblx0XHRcdFx0XHRcImRhcmtvbGl2ZWdyZWVuXCI6IFwiODUsMTA3LDQ3XCIsXG5cdFx0XHRcdFx0XCJkYXJrb3JhbmdlXCI6IFwiMjU1LDE0MCwwXCIsXG5cdFx0XHRcdFx0XCJkYXJrb3JjaGlkXCI6IFwiMTUzLDUwLDIwNFwiLFxuXHRcdFx0XHRcdFwiZGFya3JlZFwiOiBcIjEzOSwwLDBcIixcblx0XHRcdFx0XHRcImRhcmtzYWxtb25cIjogXCIyMzMsMTUwLDEyMlwiLFxuXHRcdFx0XHRcdFwiZGFya3NlYWdyZWVuXCI6IFwiMTQzLDE4OCwxNDNcIixcblx0XHRcdFx0XHRcImRhcmtzbGF0ZWJsdWVcIjogXCI3Miw2MSwxMzlcIixcblx0XHRcdFx0XHRcImRhcmtzbGF0ZWdyYXlcIjogXCI0Nyw3OSw3OVwiLFxuXHRcdFx0XHRcdFwiZGFya3R1cnF1b2lzZVwiOiBcIjAsMjA2LDIwOVwiLFxuXHRcdFx0XHRcdFwiZGFya3Zpb2xldFwiOiBcIjE0OCwwLDIxMVwiLFxuXHRcdFx0XHRcdFwiZGVlcHBpbmtcIjogXCIyNTUsMjAsMTQ3XCIsXG5cdFx0XHRcdFx0XCJkZWVwc2t5Ymx1ZVwiOiBcIjAsMTkxLDI1NVwiLFxuXHRcdFx0XHRcdFwiZGltZ3JheVwiOiBcIjEwNSwxMDUsMTA1XCIsXG5cdFx0XHRcdFx0XCJkaW1ncmV5XCI6IFwiMTA1LDEwNSwxMDVcIixcblx0XHRcdFx0XHRcImRvZGdlcmJsdWVcIjogXCIzMCwxNDQsMjU1XCIsXG5cdFx0XHRcdFx0XCJmaXJlYnJpY2tcIjogXCIxNzgsMzQsMzRcIixcblx0XHRcdFx0XHRcImZsb3JhbHdoaXRlXCI6IFwiMjU1LDI1MCwyNDBcIixcblx0XHRcdFx0XHRcImZvcmVzdGdyZWVuXCI6IFwiMzQsMTM5LDM0XCIsXG5cdFx0XHRcdFx0XCJmdWNoc2lhXCI6IFwiMjU1LDAsMjU1XCIsXG5cdFx0XHRcdFx0XCJnYWluc2Jvcm9cIjogXCIyMjAsMjIwLDIyMFwiLFxuXHRcdFx0XHRcdFwiZ2hvc3R3aGl0ZVwiOiBcIjI0OCwyNDgsMjU1XCIsXG5cdFx0XHRcdFx0XCJnb2xkXCI6IFwiMjU1LDIxNSwwXCIsXG5cdFx0XHRcdFx0XCJnb2xkZW5yb2RcIjogXCIyMTgsMTY1LDMyXCIsXG5cdFx0XHRcdFx0XCJncmF5XCI6IFwiMTI4LDEyOCwxMjhcIixcblx0XHRcdFx0XHRcImdyZXlcIjogXCIxMjgsMTI4LDEyOFwiLFxuXHRcdFx0XHRcdFwiZ3JlZW55ZWxsb3dcIjogXCIxNzMsMjU1LDQ3XCIsXG5cdFx0XHRcdFx0XCJncmVlblwiOiBcIjAsMTI4LDBcIixcblx0XHRcdFx0XHRcImhvbmV5ZGV3XCI6IFwiMjQwLDI1NSwyNDBcIixcblx0XHRcdFx0XHRcImhvdHBpbmtcIjogXCIyNTUsMTA1LDE4MFwiLFxuXHRcdFx0XHRcdFwiaW5kaWFucmVkXCI6IFwiMjA1LDkyLDkyXCIsXG5cdFx0XHRcdFx0XCJpbmRpZ29cIjogXCI3NSwwLDEzMFwiLFxuXHRcdFx0XHRcdFwiaXZvcnlcIjogXCIyNTUsMjU1LDI0MFwiLFxuXHRcdFx0XHRcdFwia2hha2lcIjogXCIyNDAsMjMwLDE0MFwiLFxuXHRcdFx0XHRcdFwibGF2ZW5kZXJibHVzaFwiOiBcIjI1NSwyNDAsMjQ1XCIsXG5cdFx0XHRcdFx0XCJsYXZlbmRlclwiOiBcIjIzMCwyMzAsMjUwXCIsXG5cdFx0XHRcdFx0XCJsYXduZ3JlZW5cIjogXCIxMjQsMjUyLDBcIixcblx0XHRcdFx0XHRcImxlbW9uY2hpZmZvblwiOiBcIjI1NSwyNTAsMjA1XCIsXG5cdFx0XHRcdFx0XCJsaWdodGJsdWVcIjogXCIxNzMsMjE2LDIzMFwiLFxuXHRcdFx0XHRcdFwibGlnaHRjb3JhbFwiOiBcIjI0MCwxMjgsMTI4XCIsXG5cdFx0XHRcdFx0XCJsaWdodGN5YW5cIjogXCIyMjQsMjU1LDI1NVwiLFxuXHRcdFx0XHRcdFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogXCIyNTAsMjUwLDIxMFwiLFxuXHRcdFx0XHRcdFwibGlnaHRncmF5XCI6IFwiMjExLDIxMSwyMTFcIixcblx0XHRcdFx0XHRcImxpZ2h0Z3JleVwiOiBcIjIxMSwyMTEsMjExXCIsXG5cdFx0XHRcdFx0XCJsaWdodGdyZWVuXCI6IFwiMTQ0LDIzOCwxNDRcIixcblx0XHRcdFx0XHRcImxpZ2h0cGlua1wiOiBcIjI1NSwxODIsMTkzXCIsXG5cdFx0XHRcdFx0XCJsaWdodHNhbG1vblwiOiBcIjI1NSwxNjAsMTIyXCIsXG5cdFx0XHRcdFx0XCJsaWdodHNlYWdyZWVuXCI6IFwiMzIsMTc4LDE3MFwiLFxuXHRcdFx0XHRcdFwibGlnaHRza3libHVlXCI6IFwiMTM1LDIwNiwyNTBcIixcblx0XHRcdFx0XHRcImxpZ2h0c2xhdGVncmF5XCI6IFwiMTE5LDEzNiwxNTNcIixcblx0XHRcdFx0XHRcImxpZ2h0c3RlZWxibHVlXCI6IFwiMTc2LDE5NiwyMjJcIixcblx0XHRcdFx0XHRcImxpZ2h0eWVsbG93XCI6IFwiMjU1LDI1NSwyMjRcIixcblx0XHRcdFx0XHRcImxpbWVncmVlblwiOiBcIjUwLDIwNSw1MFwiLFxuXHRcdFx0XHRcdFwibGltZVwiOiBcIjAsMjU1LDBcIixcblx0XHRcdFx0XHRcImxpbmVuXCI6IFwiMjUwLDI0MCwyMzBcIixcblx0XHRcdFx0XHRcIm1hZ2VudGFcIjogXCIyNTUsMCwyNTVcIixcblx0XHRcdFx0XHRcIm1hcm9vblwiOiBcIjEyOCwwLDBcIixcblx0XHRcdFx0XHRcIm1lZGl1bWFxdWFtYXJpbmVcIjogXCIxMDIsMjA1LDE3MFwiLFxuXHRcdFx0XHRcdFwibWVkaXVtYmx1ZVwiOiBcIjAsMCwyMDVcIixcblx0XHRcdFx0XHRcIm1lZGl1bW9yY2hpZFwiOiBcIjE4Niw4NSwyMTFcIixcblx0XHRcdFx0XHRcIm1lZGl1bXB1cnBsZVwiOiBcIjE0NywxMTIsMjE5XCIsXG5cdFx0XHRcdFx0XCJtZWRpdW1zZWFncmVlblwiOiBcIjYwLDE3OSwxMTNcIixcblx0XHRcdFx0XHRcIm1lZGl1bXNsYXRlYmx1ZVwiOiBcIjEyMywxMDQsMjM4XCIsXG5cdFx0XHRcdFx0XCJtZWRpdW1zcHJpbmdncmVlblwiOiBcIjAsMjUwLDE1NFwiLFxuXHRcdFx0XHRcdFwibWVkaXVtdHVycXVvaXNlXCI6IFwiNzIsMjA5LDIwNFwiLFxuXHRcdFx0XHRcdFwibWVkaXVtdmlvbGV0cmVkXCI6IFwiMTk5LDIxLDEzM1wiLFxuXHRcdFx0XHRcdFwibWlkbmlnaHRibHVlXCI6IFwiMjUsMjUsMTEyXCIsXG5cdFx0XHRcdFx0XCJtaW50Y3JlYW1cIjogXCIyNDUsMjU1LDI1MFwiLFxuXHRcdFx0XHRcdFwibWlzdHlyb3NlXCI6IFwiMjU1LDIyOCwyMjVcIixcblx0XHRcdFx0XHRcIm1vY2Nhc2luXCI6IFwiMjU1LDIyOCwxODFcIixcblx0XHRcdFx0XHRcIm5hdmFqb3doaXRlXCI6IFwiMjU1LDIyMiwxNzNcIixcblx0XHRcdFx0XHRcIm5hdnlcIjogXCIwLDAsMTI4XCIsXG5cdFx0XHRcdFx0XCJvbGRsYWNlXCI6IFwiMjUzLDI0NSwyMzBcIixcblx0XHRcdFx0XHRcIm9saXZlZHJhYlwiOiBcIjEwNywxNDIsMzVcIixcblx0XHRcdFx0XHRcIm9saXZlXCI6IFwiMTI4LDEyOCwwXCIsXG5cdFx0XHRcdFx0XCJvcmFuZ2VyZWRcIjogXCIyNTUsNjksMFwiLFxuXHRcdFx0XHRcdFwib3JhbmdlXCI6IFwiMjU1LDE2NSwwXCIsXG5cdFx0XHRcdFx0XCJvcmNoaWRcIjogXCIyMTgsMTEyLDIxNFwiLFxuXHRcdFx0XHRcdFwicGFsZWdvbGRlbnJvZFwiOiBcIjIzOCwyMzIsMTcwXCIsXG5cdFx0XHRcdFx0XCJwYWxlZ3JlZW5cIjogXCIxNTIsMjUxLDE1MlwiLFxuXHRcdFx0XHRcdFwicGFsZXR1cnF1b2lzZVwiOiBcIjE3NSwyMzgsMjM4XCIsXG5cdFx0XHRcdFx0XCJwYWxldmlvbGV0cmVkXCI6IFwiMjE5LDExMiwxNDdcIixcblx0XHRcdFx0XHRcInBhcGF5YXdoaXBcIjogXCIyNTUsMjM5LDIxM1wiLFxuXHRcdFx0XHRcdFwicGVhY2hwdWZmXCI6IFwiMjU1LDIxOCwxODVcIixcblx0XHRcdFx0XHRcInBlcnVcIjogXCIyMDUsMTMzLDYzXCIsXG5cdFx0XHRcdFx0XCJwaW5rXCI6IFwiMjU1LDE5MiwyMDNcIixcblx0XHRcdFx0XHRcInBsdW1cIjogXCIyMjEsMTYwLDIyMVwiLFxuXHRcdFx0XHRcdFwicG93ZGVyYmx1ZVwiOiBcIjE3NiwyMjQsMjMwXCIsXG5cdFx0XHRcdFx0XCJwdXJwbGVcIjogXCIxMjgsMCwxMjhcIixcblx0XHRcdFx0XHRcInJlZFwiOiBcIjI1NSwwLDBcIixcblx0XHRcdFx0XHRcInJvc3licm93blwiOiBcIjE4OCwxNDMsMTQzXCIsXG5cdFx0XHRcdFx0XCJyb3lhbGJsdWVcIjogXCI2NSwxMDUsMjI1XCIsXG5cdFx0XHRcdFx0XCJzYWRkbGVicm93blwiOiBcIjEzOSw2OSwxOVwiLFxuXHRcdFx0XHRcdFwic2FsbW9uXCI6IFwiMjUwLDEyOCwxMTRcIixcblx0XHRcdFx0XHRcInNhbmR5YnJvd25cIjogXCIyNDQsMTY0LDk2XCIsXG5cdFx0XHRcdFx0XCJzZWFncmVlblwiOiBcIjQ2LDEzOSw4N1wiLFxuXHRcdFx0XHRcdFwic2Vhc2hlbGxcIjogXCIyNTUsMjQ1LDIzOFwiLFxuXHRcdFx0XHRcdFwic2llbm5hXCI6IFwiMTYwLDgyLDQ1XCIsXG5cdFx0XHRcdFx0XCJzaWx2ZXJcIjogXCIxOTIsMTkyLDE5MlwiLFxuXHRcdFx0XHRcdFwic2t5Ymx1ZVwiOiBcIjEzNSwyMDYsMjM1XCIsXG5cdFx0XHRcdFx0XCJzbGF0ZWJsdWVcIjogXCIxMDYsOTAsMjA1XCIsXG5cdFx0XHRcdFx0XCJzbGF0ZWdyYXlcIjogXCIxMTIsMTI4LDE0NFwiLFxuXHRcdFx0XHRcdFwic25vd1wiOiBcIjI1NSwyNTAsMjUwXCIsXG5cdFx0XHRcdFx0XCJzcHJpbmdncmVlblwiOiBcIjAsMjU1LDEyN1wiLFxuXHRcdFx0XHRcdFwic3RlZWxibHVlXCI6IFwiNzAsMTMwLDE4MFwiLFxuXHRcdFx0XHRcdFwidGFuXCI6IFwiMjEwLDE4MCwxNDBcIixcblx0XHRcdFx0XHRcInRlYWxcIjogXCIwLDEyOCwxMjhcIixcblx0XHRcdFx0XHRcInRoaXN0bGVcIjogXCIyMTYsMTkxLDIxNlwiLFxuXHRcdFx0XHRcdFwidG9tYXRvXCI6IFwiMjU1LDk5LDcxXCIsXG5cdFx0XHRcdFx0XCJ0dXJxdW9pc2VcIjogXCI2NCwyMjQsMjA4XCIsXG5cdFx0XHRcdFx0XCJ2aW9sZXRcIjogXCIyMzgsMTMwLDIzOFwiLFxuXHRcdFx0XHRcdFwid2hlYXRcIjogXCIyNDUsMjIyLDE3OVwiLFxuXHRcdFx0XHRcdFwid2hpdGVzbW9rZVwiOiBcIjI0NSwyNDUsMjQ1XCIsXG5cdFx0XHRcdFx0XCJ3aGl0ZVwiOiBcIjI1NSwyNTUsMjU1XCIsXG5cdFx0XHRcdFx0XCJ5ZWxsb3dncmVlblwiOiBcIjE1NCwyMDUsNTBcIixcblx0XHRcdFx0XHRcInllbGxvd1wiOiBcIjI1NSwyNTUsMFwiXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvKioqKioqKioqKioqXG5cdFx0XHQgSG9va3Ncblx0XHRcdCAqKioqKioqKioqKiovXG5cblx0XHRcdC8qIEhvb2tzIGFsbG93IGEgc3VicHJvcGVydHkgKGUuZy4gXCJib3hTaGFkb3dCbHVyXCIpIG9mIGEgY29tcG91bmQtdmFsdWUgQ1NTIHByb3BlcnR5XG5cdFx0XHQgKGUuZy4gXCJib3hTaGFkb3c6IFggWSBCbHVyIFNwcmVhZCBDb2xvclwiKSB0byBiZSBhbmltYXRlZCBhcyBpZiBpdCB3ZXJlIGEgZGlzY3JldGUgcHJvcGVydHkuICovXG5cdFx0XHQvKiBOb3RlOiBCZXlvbmQgZW5hYmxpbmcgZmluZS1ncmFpbmVkIHByb3BlcnR5IGFuaW1hdGlvbiwgaG9va2luZyBpcyBuZWNlc3Nhcnkgc2luY2UgVmVsb2NpdHkgb25seVxuXHRcdFx0IHR3ZWVucyBwcm9wZXJ0aWVzIHdpdGggc2luZ2xlIG51bWVyaWMgdmFsdWVzOyB1bmxpa2UgQ1NTIHRyYW5zaXRpb25zLCBWZWxvY2l0eSBkb2VzIG5vdCBpbnRlcnBvbGF0ZSBjb21wb3VuZC12YWx1ZXMuICovXG5cdFx0XHRIb29rczoge1xuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IFJlZ2lzdHJhdGlvblxuXHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0LyogVGVtcGxhdGVzIGFyZSBhIGNvbmNpc2Ugd2F5IG9mIGluZGljYXRpbmcgd2hpY2ggc3VicHJvcGVydGllcyBtdXN0IGJlIGluZGl2aWR1YWxseSByZWdpc3RlcmVkIGZvciBlYWNoIGNvbXBvdW5kLXZhbHVlIENTUyBwcm9wZXJ0eS4gKi9cblx0XHRcdFx0LyogRWFjaCB0ZW1wbGF0ZSBjb25zaXN0cyBvZiB0aGUgY29tcG91bmQtdmFsdWUncyBiYXNlIG5hbWUsIGl0cyBjb25zdGl0dWVudCBzdWJwcm9wZXJ0eSBuYW1lcywgYW5kIHRob3NlIHN1YnByb3BlcnRpZXMnIGRlZmF1bHQgdmFsdWVzLiAqL1xuXHRcdFx0XHR0ZW1wbGF0ZXM6IHtcblx0XHRcdFx0XHRcInRleHRTaGFkb3dcIjogW1wiQ29sb3IgWCBZIEJsdXJcIiwgXCJibGFjayAwcHggMHB4IDBweFwiXSxcblx0XHRcdFx0XHRcImJveFNoYWRvd1wiOiBbXCJDb2xvciBYIFkgQmx1ciBTcHJlYWRcIiwgXCJibGFjayAwcHggMHB4IDBweCAwcHhcIl0sXG5cdFx0XHRcdFx0XCJjbGlwXCI6IFtcIlRvcCBSaWdodCBCb3R0b20gTGVmdFwiLCBcIjBweCAwcHggMHB4IDBweFwiXSxcblx0XHRcdFx0XHRcImJhY2tncm91bmRQb3NpdGlvblwiOiBbXCJYIFlcIiwgXCIwJSAwJVwiXSxcblx0XHRcdFx0XHRcInRyYW5zZm9ybU9yaWdpblwiOiBbXCJYIFkgWlwiLCBcIjUwJSA1MCUgMHB4XCJdLFxuXHRcdFx0XHRcdFwicGVyc3BlY3RpdmVPcmlnaW5cIjogW1wiWCBZXCIsIFwiNTAlIDUwJVwiXVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKiBBIFwicmVnaXN0ZXJlZFwiIGhvb2sgaXMgb25lIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIGZyb20gaXRzIHRlbXBsYXRlIGZvcm0gaW50byBhIGxpdmUsXG5cdFx0XHRcdCB0d2VlbmFibGUgcHJvcGVydHkuIEl0IGNvbnRhaW5zIGRhdGEgdG8gYXNzb2NpYXRlIGl0IHdpdGggaXRzIHJvb3QgcHJvcGVydHkuICovXG5cdFx0XHRcdHJlZ2lzdGVyZWQ6IHtcblx0XHRcdFx0XHQvKiBOb3RlOiBBIHJlZ2lzdGVyZWQgaG9vayBsb29rcyBsaWtlIHRoaXMgPT0+IHRleHRTaGFkb3dCbHVyOiBbIFwidGV4dFNoYWRvd1wiLCAzIF0sXG5cdFx0XHRcdFx0IHdoaWNoIGNvbnNpc3RzIG9mIHRoZSBzdWJwcm9wZXJ0eSdzIG5hbWUsIHRoZSBhc3NvY2lhdGVkIHJvb3QgcHJvcGVydHkncyBuYW1lLFxuXHRcdFx0XHRcdCBhbmQgdGhlIHN1YnByb3BlcnR5J3MgcG9zaXRpb24gaW4gdGhlIHJvb3QncyB2YWx1ZS4gKi9cblx0XHRcdFx0fSxcblx0XHRcdFx0LyogQ29udmVydCB0aGUgdGVtcGxhdGVzIGludG8gaW5kaXZpZHVhbCBob29rcyB0aGVuIGFwcGVuZCB0aGVtIHRvIHRoZSByZWdpc3RlcmVkIG9iamVjdCBhYm92ZS4gKi9cblx0XHRcdFx0cmVnaXN0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdC8qIENvbG9yIGhvb2tzIHJlZ2lzdHJhdGlvbjogQ29sb3JzIGFyZSBkZWZhdWx0ZWQgdG8gd2hpdGUgLS0gYXMgb3Bwb3NlZCB0byBibGFjayAtLSBzaW5jZSBjb2xvcnMgdGhhdCBhcmVcblx0XHRcdFx0XHQgY3VycmVudGx5IHNldCB0byBcInRyYW5zcGFyZW50XCIgZGVmYXVsdCB0byB0aGVpciByZXNwZWN0aXZlIHRlbXBsYXRlIGJlbG93IHdoZW4gY29sb3ItYW5pbWF0ZWQsXG5cdFx0XHRcdFx0IGFuZCB3aGl0ZSBpcyB0eXBpY2FsbHkgYSBjbG9zZXIgbWF0Y2ggdG8gdHJhbnNwYXJlbnQgdGhhbiBibGFjayBpcy4gQW4gZXhjZXB0aW9uIGlzIG1hZGUgZm9yIHRleHQgKFwiY29sb3JcIiksXG5cdFx0XHRcdFx0IHdoaWNoIGlzIGFsbW9zdCBhbHdheXMgc2V0IGNsb3NlciB0byBibGFjayB0aGFuIHdoaXRlLiAqL1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgQ1NTLkxpc3RzLmNvbG9ycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0dmFyIHJnYkNvbXBvbmVudHMgPSAoQ1NTLkxpc3RzLmNvbG9yc1tpXSA9PT0gXCJjb2xvclwiKSA/IFwiMCAwIDAgMVwiIDogXCIyNTUgMjU1IDI1NSAxXCI7XG5cdFx0XHRcdFx0XHRDU1MuSG9va3MudGVtcGxhdGVzW0NTUy5MaXN0cy5jb2xvcnNbaV1dID0gW1wiUmVkIEdyZWVuIEJsdWUgQWxwaGFcIiwgcmdiQ29tcG9uZW50c107XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHJvb3RQcm9wZXJ0eSxcblx0XHRcdFx0XHRcdFx0aG9va1RlbXBsYXRlLFxuXHRcdFx0XHRcdFx0XHRob29rTmFtZXM7XG5cblx0XHRcdFx0XHQvKiBJbiBJRSwgY29sb3IgdmFsdWVzIGluc2lkZSBjb21wb3VuZC12YWx1ZSBwcm9wZXJ0aWVzIGFyZSBwb3NpdGlvbmVkIGF0IHRoZSBlbmQgdGhlIHZhbHVlIGluc3RlYWQgb2YgYXQgdGhlIGJlZ2lubmluZy5cblx0XHRcdFx0XHQgVGh1cywgd2UgcmUtYXJyYW5nZSB0aGUgdGVtcGxhdGVzIGFjY29yZGluZ2x5LiAqL1xuXHRcdFx0XHRcdGlmIChJRSkge1xuXHRcdFx0XHRcdFx0Zm9yIChyb290UHJvcGVydHkgaW4gQ1NTLkhvb2tzLnRlbXBsYXRlcykge1xuXHRcdFx0XHRcdFx0XHRpZiAoIUNTUy5Ib29rcy50ZW1wbGF0ZXMuaGFzT3duUHJvcGVydHkocm9vdFByb3BlcnR5KSkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGhvb2tUZW1wbGF0ZSA9IENTUy5Ib29rcy50ZW1wbGF0ZXNbcm9vdFByb3BlcnR5XTtcblx0XHRcdFx0XHRcdFx0aG9va05hbWVzID0gaG9va1RlbXBsYXRlWzBdLnNwbGl0KFwiIFwiKTtcblxuXHRcdFx0XHRcdFx0XHR2YXIgZGVmYXVsdFZhbHVlcyA9IGhvb2tUZW1wbGF0ZVsxXS5tYXRjaChDU1MuUmVnRXgudmFsdWVTcGxpdCk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKGhvb2tOYW1lc1swXSA9PT0gXCJDb2xvclwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0LyogUmVwb3NpdGlvbiBib3RoIHRoZSBob29rJ3MgbmFtZSBhbmQgaXRzIGRlZmF1bHQgdmFsdWUgdG8gdGhlIGVuZCBvZiB0aGVpciByZXNwZWN0aXZlIHN0cmluZ3MuICovXG5cdFx0XHRcdFx0XHRcdFx0aG9va05hbWVzLnB1c2goaG9va05hbWVzLnNoaWZ0KCkpO1xuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHRWYWx1ZXMucHVzaChkZWZhdWx0VmFsdWVzLnNoaWZ0KCkpO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogUmVwbGFjZSB0aGUgZXhpc3RpbmcgdGVtcGxhdGUgZm9yIHRoZSBob29rJ3Mgcm9vdCBwcm9wZXJ0eS4gKi9cblx0XHRcdFx0XHRcdFx0XHRDU1MuSG9va3MudGVtcGxhdGVzW3Jvb3RQcm9wZXJ0eV0gPSBbaG9va05hbWVzLmpvaW4oXCIgXCIpLCBkZWZhdWx0VmFsdWVzLmpvaW4oXCIgXCIpXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIEhvb2sgcmVnaXN0cmF0aW9uLiAqL1xuXHRcdFx0XHRcdGZvciAocm9vdFByb3BlcnR5IGluIENTUy5Ib29rcy50ZW1wbGF0ZXMpIHtcblx0XHRcdFx0XHRcdGlmICghQ1NTLkhvb2tzLnRlbXBsYXRlcy5oYXNPd25Qcm9wZXJ0eShyb290UHJvcGVydHkpKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aG9va1RlbXBsYXRlID0gQ1NTLkhvb2tzLnRlbXBsYXRlc1tyb290UHJvcGVydHldO1xuXHRcdFx0XHRcdFx0aG9va05hbWVzID0gaG9va1RlbXBsYXRlWzBdLnNwbGl0KFwiIFwiKTtcblxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaiBpbiBob29rTmFtZXMpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFob29rTmFtZXMuaGFzT3duUHJvcGVydHkoaikpIHtcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR2YXIgZnVsbEhvb2tOYW1lID0gcm9vdFByb3BlcnR5ICsgaG9va05hbWVzW2pdLFxuXHRcdFx0XHRcdFx0XHRcdFx0aG9va1Bvc2l0aW9uID0gajtcblxuXHRcdFx0XHRcdFx0XHQvKiBGb3IgZWFjaCBob29rLCByZWdpc3RlciBpdHMgZnVsbCBuYW1lIChlLmcuIHRleHRTaGFkb3dCbHVyKSB3aXRoIGl0cyByb290IHByb3BlcnR5IChlLmcuIHRleHRTaGFkb3cpXG5cdFx0XHRcdFx0XHRcdCBhbmQgdGhlIGhvb2sncyBwb3NpdGlvbiBpbiBpdHMgdGVtcGxhdGUncyBkZWZhdWx0IHZhbHVlIHN0cmluZy4gKi9cblx0XHRcdFx0XHRcdFx0Q1NTLkhvb2tzLnJlZ2lzdGVyZWRbZnVsbEhvb2tOYW1lXSA9IFtyb290UHJvcGVydHksIGhvb2tQb3NpdGlvbl07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IEluamVjdGlvbiBhbmQgRXh0cmFjdGlvblxuXHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0LyogTG9vayB1cCB0aGUgcm9vdCBwcm9wZXJ0eSBhc3NvY2lhdGVkIHdpdGggdGhlIGhvb2sgKGUuZy4gcmV0dXJuIFwidGV4dFNoYWRvd1wiIGZvciBcInRleHRTaGFkb3dCbHVyXCIpLiAqL1xuXHRcdFx0XHQvKiBTaW5jZSBhIGhvb2sgY2Fubm90IGJlIHNldCBkaXJlY3RseSAodGhlIGJyb3dzZXIgd29uJ3QgcmVjb2duaXplIGl0KSwgc3R5bGUgdXBkYXRpbmcgZm9yIGhvb2tzIGlzIHJvdXRlZCB0aHJvdWdoIHRoZSBob29rJ3Mgcm9vdCBwcm9wZXJ0eS4gKi9cblx0XHRcdFx0Z2V0Um9vdDogZnVuY3Rpb24ocHJvcGVydHkpIHtcblx0XHRcdFx0XHR2YXIgaG9va0RhdGEgPSBDU1MuSG9va3MucmVnaXN0ZXJlZFtwcm9wZXJ0eV07XG5cblx0XHRcdFx0XHRpZiAoaG9va0RhdGEpIHtcblx0XHRcdFx0XHRcdHJldHVybiBob29rRGF0YVswXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0LyogSWYgdGhlcmUgd2FzIG5vIGhvb2sgbWF0Y2gsIHJldHVybiB0aGUgcHJvcGVydHkgbmFtZSB1bnRvdWNoZWQuICovXG5cdFx0XHRcdFx0XHRyZXR1cm4gcHJvcGVydHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRnZXRVbml0OiBmdW5jdGlvbihzdHIsIHN0YXJ0KSB7XG5cdFx0XHRcdFx0dmFyIHVuaXQgPSAoc3RyLnN1YnN0cihzdGFydCB8fCAwLCA1KS5tYXRjaCgvXlthLXolXSsvKSB8fCBbXSlbMF0gfHwgXCJcIjtcblxuXHRcdFx0XHRcdGlmICh1bml0ICYmIF9pbkFycmF5KENTUy5MaXN0cy51bml0cywgdW5pdCkpIHtcblx0XHRcdFx0XHRcdHJldHVybiB1bml0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gXCJcIjtcblx0XHRcdFx0fSxcblx0XHRcdFx0Zml4Q29sb3JzOiBmdW5jdGlvbihzdHIpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoLyhyZ2JhP1xcKFxccyopPyhcXGJbYS16XStcXGIpL2csIGZ1bmN0aW9uKCQwLCAkMSwgJDIpIHtcblx0XHRcdFx0XHRcdGlmIChDU1MuTGlzdHMuY29sb3JOYW1lcy5oYXNPd25Qcm9wZXJ0eSgkMikpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuICgkMSA/ICQxIDogXCJyZ2JhKFwiKSArIENTUy5MaXN0cy5jb2xvck5hbWVzWyQyXSArICgkMSA/IFwiXCIgOiBcIiwxKVwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiAkMSArICQyO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKiBDb252ZXJ0IGFueSByb290UHJvcGVydHlWYWx1ZSwgbnVsbCBvciBvdGhlcndpc2UsIGludG8gYSBzcGFjZS1kZWxpbWl0ZWQgbGlzdCBvZiBob29rIHZhbHVlcyBzbyB0aGF0XG5cdFx0XHRcdCB0aGUgdGFyZ2V0ZWQgaG9vayBjYW4gYmUgaW5qZWN0ZWQgb3IgZXh0cmFjdGVkIGF0IGl0cyBzdGFuZGFyZCBwb3NpdGlvbi4gKi9cblx0XHRcdFx0Y2xlYW5Sb290UHJvcGVydHlWYWx1ZTogZnVuY3Rpb24ocm9vdFByb3BlcnR5LCByb290UHJvcGVydHlWYWx1ZSkge1xuXHRcdFx0XHRcdC8qIElmIHRoZSByb290UHJvcGVydHlWYWx1ZSBpcyB3cmFwcGVkIHdpdGggXCJyZ2IoKVwiLCBcImNsaXAoKVwiLCBldGMuLCByZW1vdmUgdGhlIHdyYXBwaW5nIHRvIG5vcm1hbGl6ZSB0aGUgdmFsdWUgYmVmb3JlIG1hbmlwdWxhdGlvbi4gKi9cblx0XHRcdFx0XHRpZiAoQ1NTLlJlZ0V4LnZhbHVlVW53cmFwLnRlc3Qocm9vdFByb3BlcnR5VmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRyb290UHJvcGVydHlWYWx1ZSA9IHJvb3RQcm9wZXJ0eVZhbHVlLm1hdGNoKENTUy5SZWdFeC52YWx1ZVVud3JhcClbMV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogSWYgcm9vdFByb3BlcnR5VmFsdWUgaXMgYSBDU1MgbnVsbC12YWx1ZSAoZnJvbSB3aGljaCB0aGVyZSdzIGluaGVyZW50bHkgbm8gaG9vayB2YWx1ZSB0byBleHRyYWN0KSxcblx0XHRcdFx0XHQgZGVmYXVsdCB0byB0aGUgcm9vdCdzIGRlZmF1bHQgdmFsdWUgYXMgZGVmaW5lZCBpbiBDU1MuSG9va3MudGVtcGxhdGVzLiAqL1xuXHRcdFx0XHRcdC8qIE5vdGU6IENTUyBudWxsLXZhbHVlcyBpbmNsdWRlIFwibm9uZVwiLCBcImF1dG9cIiwgYW5kIFwidHJhbnNwYXJlbnRcIi4gVGhleSBtdXN0IGJlIGNvbnZlcnRlZCBpbnRvIHRoZWlyXG5cdFx0XHRcdFx0IHplcm8tdmFsdWVzIChlLmcuIHRleHRTaGFkb3c6IFwibm9uZVwiID09PiB0ZXh0U2hhZG93OiBcIjBweCAwcHggMHB4IGJsYWNrXCIpIGZvciBob29rIG1hbmlwdWxhdGlvbiB0byBwcm9jZWVkLiAqL1xuXHRcdFx0XHRcdGlmIChDU1MuVmFsdWVzLmlzQ1NTTnVsbFZhbHVlKHJvb3RQcm9wZXJ0eVZhbHVlKSkge1xuXHRcdFx0XHRcdFx0cm9vdFByb3BlcnR5VmFsdWUgPSBDU1MuSG9va3MudGVtcGxhdGVzW3Jvb3RQcm9wZXJ0eV1bMV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHJvb3RQcm9wZXJ0eVZhbHVlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKiBFeHRyYWN0ZWQgdGhlIGhvb2sncyB2YWx1ZSBmcm9tIGl0cyByb290IHByb3BlcnR5J3MgdmFsdWUuIFRoaXMgaXMgdXNlZCB0byBnZXQgdGhlIHN0YXJ0aW5nIHZhbHVlIG9mIGFuIGFuaW1hdGluZyBob29rLiAqL1xuXHRcdFx0XHRleHRyYWN0VmFsdWU6IGZ1bmN0aW9uKGZ1bGxIb29rTmFtZSwgcm9vdFByb3BlcnR5VmFsdWUpIHtcblx0XHRcdFx0XHR2YXIgaG9va0RhdGEgPSBDU1MuSG9va3MucmVnaXN0ZXJlZFtmdWxsSG9va05hbWVdO1xuXG5cdFx0XHRcdFx0aWYgKGhvb2tEYXRhKSB7XG5cdFx0XHRcdFx0XHR2YXIgaG9va1Jvb3QgPSBob29rRGF0YVswXSxcblx0XHRcdFx0XHRcdFx0XHRob29rUG9zaXRpb24gPSBob29rRGF0YVsxXTtcblxuXHRcdFx0XHRcdFx0cm9vdFByb3BlcnR5VmFsdWUgPSBDU1MuSG9va3MuY2xlYW5Sb290UHJvcGVydHlWYWx1ZShob29rUm9vdCwgcm9vdFByb3BlcnR5VmFsdWUpO1xuXG5cdFx0XHRcdFx0XHQvKiBTcGxpdCByb290UHJvcGVydHlWYWx1ZSBpbnRvIGl0cyBjb25zdGl0dWVudCBob29rIHZhbHVlcyB0aGVuIGdyYWIgdGhlIGRlc2lyZWQgaG9vayBhdCBpdHMgc3RhbmRhcmQgcG9zaXRpb24uICovXG5cdFx0XHRcdFx0XHRyZXR1cm4gcm9vdFByb3BlcnR5VmFsdWUudG9TdHJpbmcoKS5tYXRjaChDU1MuUmVnRXgudmFsdWVTcGxpdClbaG9va1Bvc2l0aW9uXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0LyogSWYgdGhlIHByb3ZpZGVkIGZ1bGxIb29rTmFtZSBpc24ndCBhIHJlZ2lzdGVyZWQgaG9vaywgcmV0dXJuIHRoZSByb290UHJvcGVydHlWYWx1ZSB0aGF0IHdhcyBwYXNzZWQgaW4uICovXG5cdFx0XHRcdFx0XHRyZXR1cm4gcm9vdFByb3BlcnR5VmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKiBJbmplY3QgdGhlIGhvb2sncyB2YWx1ZSBpbnRvIGl0cyByb290IHByb3BlcnR5J3MgdmFsdWUuIFRoaXMgaXMgdXNlZCB0byBwaWVjZSBiYWNrIHRvZ2V0aGVyIHRoZSByb290IHByb3BlcnR5XG5cdFx0XHRcdCBvbmNlIFZlbG9jaXR5IGhhcyB1cGRhdGVkIG9uZSBvZiBpdHMgaW5kaXZpZHVhbGx5IGhvb2tlZCB2YWx1ZXMgdGhyb3VnaCB0d2VlbmluZy4gKi9cblx0XHRcdFx0aW5qZWN0VmFsdWU6IGZ1bmN0aW9uKGZ1bGxIb29rTmFtZSwgaG9va1ZhbHVlLCByb290UHJvcGVydHlWYWx1ZSkge1xuXHRcdFx0XHRcdHZhciBob29rRGF0YSA9IENTUy5Ib29rcy5yZWdpc3RlcmVkW2Z1bGxIb29rTmFtZV07XG5cblx0XHRcdFx0XHRpZiAoaG9va0RhdGEpIHtcblx0XHRcdFx0XHRcdHZhciBob29rUm9vdCA9IGhvb2tEYXRhWzBdLFxuXHRcdFx0XHRcdFx0XHRcdGhvb2tQb3NpdGlvbiA9IGhvb2tEYXRhWzFdLFxuXHRcdFx0XHRcdFx0XHRcdHJvb3RQcm9wZXJ0eVZhbHVlUGFydHMsXG5cdFx0XHRcdFx0XHRcdFx0cm9vdFByb3BlcnR5VmFsdWVVcGRhdGVkO1xuXG5cdFx0XHRcdFx0XHRyb290UHJvcGVydHlWYWx1ZSA9IENTUy5Ib29rcy5jbGVhblJvb3RQcm9wZXJ0eVZhbHVlKGhvb2tSb290LCByb290UHJvcGVydHlWYWx1ZSk7XG5cblx0XHRcdFx0XHRcdC8qIFNwbGl0IHJvb3RQcm9wZXJ0eVZhbHVlIGludG8gaXRzIGluZGl2aWR1YWwgaG9vayB2YWx1ZXMsIHJlcGxhY2UgdGhlIHRhcmdldGVkIHZhbHVlIHdpdGggaG9va1ZhbHVlLFxuXHRcdFx0XHRcdFx0IHRoZW4gcmVjb25zdHJ1Y3QgdGhlIHJvb3RQcm9wZXJ0eVZhbHVlIHN0cmluZy4gKi9cblx0XHRcdFx0XHRcdHJvb3RQcm9wZXJ0eVZhbHVlUGFydHMgPSByb290UHJvcGVydHlWYWx1ZS50b1N0cmluZygpLm1hdGNoKENTUy5SZWdFeC52YWx1ZVNwbGl0KTtcblx0XHRcdFx0XHRcdHJvb3RQcm9wZXJ0eVZhbHVlUGFydHNbaG9va1Bvc2l0aW9uXSA9IGhvb2tWYWx1ZTtcblx0XHRcdFx0XHRcdHJvb3RQcm9wZXJ0eVZhbHVlVXBkYXRlZCA9IHJvb3RQcm9wZXJ0eVZhbHVlUGFydHMuam9pbihcIiBcIik7XG5cblx0XHRcdFx0XHRcdHJldHVybiByb290UHJvcGVydHlWYWx1ZVVwZGF0ZWQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8qIElmIHRoZSBwcm92aWRlZCBmdWxsSG9va05hbWUgaXNuJ3QgYSByZWdpc3RlcmVkIGhvb2ssIHJldHVybiB0aGUgcm9vdFByb3BlcnR5VmFsdWUgdGhhdCB3YXMgcGFzc2VkIGluLiAqL1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJvb3RQcm9wZXJ0eVZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8qKioqKioqKioqKioqKioqKioqXG5cdFx0XHQgTm9ybWFsaXphdGlvbnNcblx0XHRcdCAqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHQvKiBOb3JtYWxpemF0aW9ucyBzdGFuZGFyZGl6ZSBDU1MgcHJvcGVydHkgbWFuaXB1bGF0aW9uIGJ5IHBvbGx5ZmlsbGluZyBicm93c2VyLXNwZWNpZmljIGltcGxlbWVudGF0aW9ucyAoZS5nLiBvcGFjaXR5KVxuXHRcdFx0IGFuZCByZWZvcm1hdHRpbmcgc3BlY2lhbCBwcm9wZXJ0aWVzIChlLmcuIGNsaXAsIHJnYmEpIHRvIGxvb2sgbGlrZSBzdGFuZGFyZCBvbmVzLiAqL1xuXHRcdFx0Tm9ybWFsaXphdGlvbnM6IHtcblx0XHRcdFx0LyogTm9ybWFsaXphdGlvbnMgYXJlIHBhc3NlZCBhIG5vcm1hbGl6YXRpb24gdGFyZ2V0IChlaXRoZXIgdGhlIHByb3BlcnR5J3MgbmFtZSwgaXRzIGV4dHJhY3RlZCB2YWx1ZSwgb3IgaXRzIGluamVjdGVkIHZhbHVlKSxcblx0XHRcdFx0IHRoZSB0YXJnZXRlZCBlbGVtZW50ICh3aGljaCBtYXkgbmVlZCB0byBiZSBxdWVyaWVkKSwgYW5kIHRoZSB0YXJnZXRlZCBwcm9wZXJ0eSB2YWx1ZS4gKi9cblx0XHRcdFx0cmVnaXN0ZXJlZDoge1xuXHRcdFx0XHRcdGNsaXA6IGZ1bmN0aW9uKHR5cGUsIGVsZW1lbnQsIHByb3BlcnR5VmFsdWUpIHtcblx0XHRcdFx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRcdFx0XHRjYXNlIFwibmFtZVwiOlxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBcImNsaXBcIjtcblx0XHRcdFx0XHRcdFx0XHQvKiBDbGlwIG5lZWRzIHRvIGJlIHVud3JhcHBlZCBhbmQgc3RyaXBwZWQgb2YgaXRzIGNvbW1hcyBkdXJpbmcgZXh0cmFjdGlvbi4gKi9cblx0XHRcdFx0XHRcdFx0Y2FzZSBcImV4dHJhY3RcIjpcblx0XHRcdFx0XHRcdFx0XHR2YXIgZXh0cmFjdGVkO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogSWYgVmVsb2NpdHkgYWxzbyBleHRyYWN0ZWQgdGhpcyB2YWx1ZSwgc2tpcCBleHRyYWN0aW9uLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmIChDU1MuUmVnRXgud3JhcHBlZFZhbHVlQWxyZWFkeUV4dHJhY3RlZC50ZXN0KHByb3BlcnR5VmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRleHRyYWN0ZWQgPSBwcm9wZXJ0eVZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBSZW1vdmUgdGhlIFwicmVjdCgpXCIgd3JhcHBlci4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdGV4dHJhY3RlZCA9IHByb3BlcnR5VmFsdWUudG9TdHJpbmcoKS5tYXRjaChDU1MuUmVnRXgudmFsdWVVbndyYXApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBTdHJpcCBvZmYgY29tbWFzLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXh0cmFjdGVkID0gZXh0cmFjdGVkID8gZXh0cmFjdGVkWzFdLnJlcGxhY2UoLywoXFxzKyk/L2csIFwiIFwiKSA6IHByb3BlcnR5VmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGV4dHJhY3RlZDtcblx0XHRcdFx0XHRcdFx0XHQvKiBDbGlwIG5lZWRzIHRvIGJlIHJlLXdyYXBwZWQgZHVyaW5nIGluamVjdGlvbi4gKi9cblx0XHRcdFx0XHRcdFx0Y2FzZSBcImluamVjdFwiOlxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBcInJlY3QoXCIgKyBwcm9wZXJ0eVZhbHVlICsgXCIpXCI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRibHVyOiBmdW5jdGlvbih0eXBlLCBlbGVtZW50LCBwcm9wZXJ0eVZhbHVlKSB7XG5cdFx0XHRcdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0XHRcdFx0Y2FzZSBcIm5hbWVcIjpcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gVmVsb2NpdHkuU3RhdGUuaXNGaXJlZm94ID8gXCJmaWx0ZXJcIiA6IFwiLXdlYmtpdC1maWx0ZXJcIjtcblx0XHRcdFx0XHRcdFx0Y2FzZSBcImV4dHJhY3RcIjpcblx0XHRcdFx0XHRcdFx0XHR2YXIgZXh0cmFjdGVkID0gcGFyc2VGbG9hdChwcm9wZXJ0eVZhbHVlKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8qIElmIGV4dHJhY3RlZCBpcyBOYU4sIG1lYW5pbmcgdGhlIHZhbHVlIGlzbid0IGFscmVhZHkgZXh0cmFjdGVkLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmICghKGV4dHJhY3RlZCB8fCBleHRyYWN0ZWQgPT09IDApKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgYmx1ckNvbXBvbmVudCA9IHByb3BlcnR5VmFsdWUudG9TdHJpbmcoKS5tYXRjaCgvYmx1clxcKChbMC05XStbQS16XSspXFwpL2kpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBJZiB0aGUgZmlsdGVyIHN0cmluZyBoYWQgYSBibHVyIGNvbXBvbmVudCwgcmV0dXJuIGp1c3QgdGhlIGJsdXIgdmFsdWUgYW5kIHVuaXQgdHlwZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChibHVyQ29tcG9uZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGV4dHJhY3RlZCA9IGJsdXJDb21wb25lbnRbMV07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIElmIHRoZSBjb21wb25lbnQgZG9lc24ndCBleGlzdCwgZGVmYXVsdCBibHVyIHRvIDAuICovXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRleHRyYWN0ZWQgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBleHRyYWN0ZWQ7XG5cdFx0XHRcdFx0XHRcdFx0LyogQmx1ciBuZWVkcyB0byBiZSByZS13cmFwcGVkIGR1cmluZyBpbmplY3Rpb24uICovXG5cdFx0XHRcdFx0XHRcdGNhc2UgXCJpbmplY3RcIjpcblx0XHRcdFx0XHRcdFx0XHQvKiBGb3IgdGhlIGJsdXIgZWZmZWN0IHRvIGJlIGZ1bGx5IGRlLWFwcGxpZWQsIGl0IG5lZWRzIHRvIGJlIHNldCB0byBcIm5vbmVcIiBpbnN0ZWFkIG9mIDAuICovXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFwYXJzZUZsb2F0KHByb3BlcnR5VmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJub25lXCI7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBcImJsdXIoXCIgKyBwcm9wZXJ0eVZhbHVlICsgXCIpXCI7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0LyogPD1JRTggZG8gbm90IHN1cHBvcnQgdGhlIHN0YW5kYXJkIG9wYWNpdHkgcHJvcGVydHkuIFRoZXkgdXNlIGZpbHRlcjphbHBoYShvcGFjaXR5PUlOVCkgaW5zdGVhZC4gKi9cblx0XHRcdFx0XHRvcGFjaXR5OiBmdW5jdGlvbih0eXBlLCBlbGVtZW50LCBwcm9wZXJ0eVZhbHVlKSB7XG5cdFx0XHRcdFx0XHRpZiAoSUUgPD0gOCkge1xuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHRjYXNlIFwibmFtZVwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIFwiZmlsdGVyXCI7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBcImV4dHJhY3RcIjpcblx0XHRcdFx0XHRcdFx0XHRcdC8qIDw9SUU4IHJldHVybiBhIFwiZmlsdGVyXCIgdmFsdWUgb2YgXCJhbHBoYShvcGFjaXR5PVxcZHsxLDN9KVwiLlxuXHRcdFx0XHRcdFx0XHRcdFx0IEV4dHJhY3QgdGhlIHZhbHVlIGFuZCBjb252ZXJ0IGl0IHRvIGEgZGVjaW1hbCB2YWx1ZSB0byBtYXRjaCB0aGUgc3RhbmRhcmQgQ1NTIG9wYWNpdHkgcHJvcGVydHkncyBmb3JtYXR0aW5nLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGV4dHJhY3RlZCA9IHByb3BlcnR5VmFsdWUudG9TdHJpbmcoKS5tYXRjaCgvYWxwaGFcXChvcGFjaXR5PSguKilcXCkvaSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChleHRyYWN0ZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogQ29udmVydCB0byBkZWNpbWFsIHZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eVZhbHVlID0gZXh0cmFjdGVkWzFdIC8gMTAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogV2hlbiBleHRyYWN0aW5nIG9wYWNpdHksIGRlZmF1bHQgdG8gMSBzaW5jZSBhIG51bGwgdmFsdWUgbWVhbnMgb3BhY2l0eSBoYXNuJ3QgYmVlbiBzZXQuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5VmFsdWUgPSAxO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcHJvcGVydHlWYWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRjYXNlIFwiaW5qZWN0XCI6XG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBPcGFjaWZpZWQgZWxlbWVudHMgYXJlIHJlcXVpcmVkIHRvIGhhdmUgdGhlaXIgem9vbSBwcm9wZXJ0eSBzZXQgdG8gYSBub24temVybyB2YWx1ZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdGVsZW1lbnQuc3R5bGUuem9vbSA9IDE7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8qIFNldHRpbmcgdGhlIGZpbHRlciBwcm9wZXJ0eSBvbiBlbGVtZW50cyB3aXRoIGNlcnRhaW4gZm9udCBwcm9wZXJ0eSBjb21iaW5hdGlvbnMgY2FuIHJlc3VsdCBpbiBhXG5cdFx0XHRcdFx0XHRcdFx0XHQgaGlnaGx5IHVuYXBwZWFsaW5nIHVsdHJhLWJvbGRpbmcgZWZmZWN0LiBUaGVyZSdzIG5vIHdheSB0byByZW1lZHkgdGhpcyB0aHJvdWdob3V0IGEgdHdlZW4sIGJ1dCBkcm9wcGluZyB0aGVcblx0XHRcdFx0XHRcdFx0XHRcdCB2YWx1ZSBhbHRvZ2V0aGVyICh3aGVuIG9wYWNpdHkgaGl0cyAxKSBhdCBsZWFzdHMgZW5zdXJlcyB0aGF0IHRoZSBnbGl0Y2ggaXMgZ29uZSBwb3N0LXR3ZWVuaW5nLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHBhcnNlRmxvYXQocHJvcGVydHlWYWx1ZSkgPj0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJcIjtcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIEFzIHBlciB0aGUgZmlsdGVyIHByb3BlcnR5J3Mgc3BlYywgY29udmVydCB0aGUgZGVjaW1hbCB2YWx1ZSB0byBhIHdob2xlIG51bWJlciBhbmQgd3JhcCB0aGUgdmFsdWUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBcImFscGhhKG9wYWNpdHk9XCIgKyBwYXJzZUludChwYXJzZUZsb2F0KHByb3BlcnR5VmFsdWUpICogMTAwLCAxMCkgKyBcIilcIjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQvKiBXaXRoIGFsbCBvdGhlciBicm93c2Vycywgbm9ybWFsaXphdGlvbiBpcyBub3QgcmVxdWlyZWQ7IHJldHVybiB0aGUgc2FtZSB2YWx1ZXMgdGhhdCB3ZXJlIHBhc3NlZCBpbi4gKi9cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJuYW1lXCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJvcGFjaXR5XCI7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBcImV4dHJhY3RcIjpcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBwcm9wZXJ0eVZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJpbmplY3RcIjpcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBwcm9wZXJ0eVZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IEJhdGNoZWQgUmVnaXN0cmF0aW9uc1xuXHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0LyogTm90ZTogQmF0Y2hlZCBub3JtYWxpemF0aW9ucyBleHRlbmQgdGhlIENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkIG9iamVjdC4gKi9cblx0XHRcdFx0cmVnaXN0ZXI6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0IFRyYW5zZm9ybXNcblx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHQvKiBUcmFuc2Zvcm1zIGFyZSB0aGUgc3VicHJvcGVydGllcyBjb250YWluZWQgYnkgdGhlIENTUyBcInRyYW5zZm9ybVwiIHByb3BlcnR5LiBUcmFuc2Zvcm1zIG11c3QgdW5kZXJnbyBub3JtYWxpemF0aW9uXG5cdFx0XHRcdFx0IHNvIHRoYXQgdGhleSBjYW4gYmUgcmVmZXJlbmNlZCBpbiBhIHByb3BlcnRpZXMgbWFwIGJ5IHRoZWlyIGluZGl2aWR1YWwgbmFtZXMuICovXG5cdFx0XHRcdFx0LyogTm90ZTogV2hlbiB0cmFuc2Zvcm1zIGFyZSBcInNldFwiLCB0aGV5IGFyZSBhY3R1YWxseSBhc3NpZ25lZCB0byBhIHBlci1lbGVtZW50IHRyYW5zZm9ybUNhY2hlLiBXaGVuIGFsbCB0cmFuc2Zvcm1cblx0XHRcdFx0XHQgc2V0dGluZyBpcyBjb21wbGV0ZSBjb21wbGV0ZSwgQ1NTLmZsdXNoVHJhbnNmb3JtQ2FjaGUoKSBtdXN0IGJlIG1hbnVhbGx5IGNhbGxlZCB0byBmbHVzaCB0aGUgdmFsdWVzIHRvIHRoZSBET00uXG5cdFx0XHRcdFx0IFRyYW5zZm9ybSBzZXR0aW5nIGlzIGJhdGNoZWQgaW4gdGhpcyB3YXkgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZTogdGhlIHRyYW5zZm9ybSBzdHlsZSBvbmx5IG5lZWRzIHRvIGJlIHVwZGF0ZWRcblx0XHRcdFx0XHQgb25jZSB3aGVuIG11bHRpcGxlIHRyYW5zZm9ybSBzdWJwcm9wZXJ0aWVzIGFyZSBiZWluZyBhbmltYXRlZCBzaW11bHRhbmVvdXNseS4gKi9cblx0XHRcdFx0XHQvKiBOb3RlOiBJRTkgYW5kIEFuZHJvaWQgR2luZ2VyYnJlYWQgaGF2ZSBzdXBwb3J0IGZvciAyRCAtLSBidXQgbm90IDNEIC0tIHRyYW5zZm9ybXMuIFNpbmNlIGFuaW1hdGluZyB1bnN1cHBvcnRlZFxuXHRcdFx0XHRcdCB0cmFuc2Zvcm0gcHJvcGVydGllcyByZXN1bHRzIGluIHRoZSBicm93c2VyIGlnbm9yaW5nIHRoZSAqZW50aXJlKiB0cmFuc2Zvcm0gc3RyaW5nLCB3ZSBwcmV2ZW50IHRoZXNlIDNEIHZhbHVlc1xuXHRcdFx0XHRcdCBmcm9tIGJlaW5nIG5vcm1hbGl6ZWQgZm9yIHRoZXNlIGJyb3dzZXJzIHNvIHRoYXQgdHdlZW5pbmcgc2tpcHMgdGhlc2UgcHJvcGVydGllcyBhbHRvZ2V0aGVyXG5cdFx0XHRcdFx0IChzaW5jZSBpdCB3aWxsIGlnbm9yZSB0aGVtIGFzIGJlaW5nIHVuc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyLikgKi9cblx0XHRcdFx0XHRpZiAoKCFJRSB8fCBJRSA+IDkpICYmICFWZWxvY2l0eS5TdGF0ZS5pc0dpbmdlcmJyZWFkKSB7XG5cdFx0XHRcdFx0XHQvKiBOb3RlOiBTaW5jZSB0aGUgc3RhbmRhbG9uZSBDU1MgXCJwZXJzcGVjdGl2ZVwiIHByb3BlcnR5IGFuZCB0aGUgQ1NTIHRyYW5zZm9ybSBcInBlcnNwZWN0aXZlXCIgc3VicHJvcGVydHlcblx0XHRcdFx0XHRcdCBzaGFyZSB0aGUgc2FtZSBuYW1lLCB0aGUgbGF0dGVyIGlzIGdpdmVuIGEgdW5pcXVlIHRva2VuIHdpdGhpbiBWZWxvY2l0eTogXCJ0cmFuc2Zvcm1QZXJzcGVjdGl2ZVwiLiAqL1xuXHRcdFx0XHRcdFx0Q1NTLkxpc3RzLnRyYW5zZm9ybXNCYXNlID0gQ1NTLkxpc3RzLnRyYW5zZm9ybXNCYXNlLmNvbmNhdChDU1MuTGlzdHMudHJhbnNmb3JtczNEKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IENTUy5MaXN0cy50cmFuc2Zvcm1zQmFzZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0LyogV3JhcCB0aGUgZHluYW1pY2FsbHkgZ2VuZXJhdGVkIG5vcm1hbGl6YXRpb24gZnVuY3Rpb24gaW4gYSBuZXcgc2NvcGUgc28gdGhhdCB0cmFuc2Zvcm1OYW1lJ3MgdmFsdWUgaXNcblx0XHRcdFx0XHRcdCBwYWlyZWQgd2l0aCBpdHMgcmVzcGVjdGl2ZSBmdW5jdGlvbi4gKE90aGVyd2lzZSwgYWxsIGZ1bmN0aW9ucyB3b3VsZCB0YWtlIHRoZSBmaW5hbCBmb3IgbG9vcCdzIHRyYW5zZm9ybU5hbWUuKSAqL1xuXHRcdFx0XHRcdFx0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdHJhbnNmb3JtTmFtZSA9IENTUy5MaXN0cy50cmFuc2Zvcm1zQmFzZVtpXTtcblxuXHRcdFx0XHRcdFx0XHRDU1MuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFt0cmFuc2Zvcm1OYW1lXSA9IGZ1bmN0aW9uKHR5cGUsIGVsZW1lbnQsIHByb3BlcnR5VmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8qIFRoZSBub3JtYWxpemVkIHByb3BlcnR5IG5hbWUgaXMgdGhlIHBhcmVudCBcInRyYW5zZm9ybVwiIHByb3BlcnR5IC0tIHRoZSBwcm9wZXJ0eSB0aGF0IGlzIGFjdHVhbGx5IHNldCBpbiBDU1MuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFwibmFtZVwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJ0cmFuc2Zvcm1cIjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogVHJhbnNmb3JtIHZhbHVlcyBhcmUgY2FjaGVkIG9udG8gYSBwZXItZWxlbWVudCB0cmFuc2Zvcm1DYWNoZSBvYmplY3QuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFwiZXh0cmFjdFwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBJZiB0aGlzIHRyYW5zZm9ybSBoYXMgeWV0IHRvIGJlIGFzc2lnbmVkIGEgdmFsdWUsIHJldHVybiBpdHMgbnVsbCB2YWx1ZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKERhdGEoZWxlbWVudCkgPT09IHVuZGVmaW5lZCB8fCBEYXRhKGVsZW1lbnQpLnRyYW5zZm9ybUNhY2hlW3RyYW5zZm9ybU5hbWVdID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBTY2FsZSBDU1MuTGlzdHMudHJhbnNmb3Jtc0Jhc2UgZGVmYXVsdCB0byAxIHdoZXJlYXMgYWxsIG90aGVyIHRyYW5zZm9ybSBwcm9wZXJ0aWVzIGRlZmF1bHQgdG8gMC4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gL15zY2FsZS9pLnRlc3QodHJhbnNmb3JtTmFtZSkgPyAxIDogMDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBXaGVuIHRyYW5zZm9ybSB2YWx1ZXMgYXJlIHNldCwgdGhleSBhcmUgd3JhcHBlZCBpbiBwYXJlbnRoZXNlcyBhcyBwZXIgdGhlIENTUyBzcGVjLlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCBUaHVzLCB3aGVuIGV4dHJhY3RpbmcgdGhlaXIgdmFsdWVzIChmb3IgdHdlZW4gY2FsY3VsYXRpb25zKSwgd2Ugc3RyaXAgb2ZmIHRoZSBwYXJlbnRoZXNlcy4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gRGF0YShlbGVtZW50KS50cmFuc2Zvcm1DYWNoZVt0cmFuc2Zvcm1OYW1lXS5yZXBsYWNlKC9bKCldL2csIFwiXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBcImluamVjdFwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgaW52YWxpZCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIElmIGFuIGluZGl2aWR1YWwgdHJhbnNmb3JtIHByb3BlcnR5IGNvbnRhaW5zIGFuIHVuc3VwcG9ydGVkIHVuaXQgdHlwZSwgdGhlIGJyb3dzZXIgaWdub3JlcyB0aGUgKmVudGlyZSogdHJhbnNmb3JtIHByb3BlcnR5LlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgVGh1cywgcHJvdGVjdCB1c2VycyBmcm9tIHRoZW1zZWx2ZXMgYnkgc2tpcHBpbmcgc2V0dGluZyBmb3IgdHJhbnNmb3JtIHZhbHVlcyBzdXBwbGllZCB3aXRoIGludmFsaWQgdW5pdCB0eXBlcy4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogU3dpdGNoIG9uIHRoZSBiYXNlIHRyYW5zZm9ybSB0eXBlOyBpZ25vcmUgdGhlIGF4aXMgYnkgcmVtb3ZpbmcgdGhlIGxhc3QgbGV0dGVyIGZyb20gdGhlIHRyYW5zZm9ybSdzIG5hbWUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN3aXRjaCAodHJhbnNmb3JtTmFtZS5zdWJzdHIoMCwgdHJhbnNmb3JtTmFtZS5sZW5ndGggLSAxKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIFdoaXRlbGlzdCB1bml0IHR5cGVzIGZvciBlYWNoIHRyYW5zZm9ybS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFwidHJhbnNsYXRlXCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpbnZhbGlkID0gIS8oJXxweHxlbXxyZW18dnd8dmh8XFxkKSQvaS50ZXN0KHByb3BlcnR5VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBTaW5jZSBhbiBheGlzLWZyZWUgXCJzY2FsZVwiIHByb3BlcnR5IGlzIHN1cHBvcnRlZCBhcyB3ZWxsLCBhIGxpdHRsZSBoYWNrIGlzIHVzZWQgaGVyZSB0byBkZXRlY3QgaXQgYnkgY2hvcHBpbmcgb2ZmIGl0cyBsYXN0IGxldHRlci4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFwic2NhbFwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJzY2FsZVwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyogQ2hyb21lIG9uIEFuZHJvaWQgaGFzIGEgYnVnIGluIHdoaWNoIHNjYWxlZCBlbGVtZW50cyBibHVyIGlmIHRoZWlyIGluaXRpYWwgc2NhbGVcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCB2YWx1ZSBpcyBiZWxvdyAxICh3aGljaCBjYW4gaGFwcGVuIHdpdGggZm9yY2VmZWVkaW5nKS4gVGh1cywgd2UgZGV0ZWN0IGEgeWV0LXVuc2V0IHNjYWxlIHByb3BlcnR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgYW5kIGVuc3VyZSB0aGF0IGl0cyBmaXJzdCB2YWx1ZSBpcyBhbHdheXMgMS4gTW9yZSBpbmZvOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNDE3ODkwL2NzczMtYW5pbWF0aW9ucy13aXRoLXRyYW5zZm9ybS1jYXVzZXMtYmx1cnJlZC1lbGVtZW50cy1vbi13ZWJraXQvMTA0MTc5NjIjMTA0MTc5NjIgKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChWZWxvY2l0eS5TdGF0ZS5pc0FuZHJvaWQgJiYgRGF0YShlbGVtZW50KS50cmFuc2Zvcm1DYWNoZVt0cmFuc2Zvcm1OYW1lXSA9PT0gdW5kZWZpbmVkICYmIHByb3BlcnR5VmFsdWUgPCAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5VmFsdWUgPSAxO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpbnZhbGlkID0gIS8oXFxkKSQvaS50ZXN0KHByb3BlcnR5VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBcInNrZXdcIjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGludmFsaWQgPSAhLyhkZWd8XFxkKSQvaS50ZXN0KHByb3BlcnR5VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBcInJvdGF0ZVwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aW52YWxpZCA9ICEvKGRlZ3xcXGQpJC9pLnRlc3QocHJvcGVydHlWYWx1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICghaW52YWxpZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIEFzIHBlciB0aGUgQ1NTIHNwZWMsIHdyYXAgdGhlIHZhbHVlIGluIHBhcmVudGhlc2VzLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdERhdGEoZWxlbWVudCkudHJhbnNmb3JtQ2FjaGVbdHJhbnNmb3JtTmFtZV0gPSBcIihcIiArIHByb3BlcnR5VmFsdWUgKyBcIilcIjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIEFsdGhvdWdoIHRoZSB2YWx1ZSBpcyBzZXQgb24gdGhlIHRyYW5zZm9ybUNhY2hlIG9iamVjdCwgcmV0dXJuIHRoZSBuZXdseS11cGRhdGVkIHZhbHVlIGZvciB0aGUgY2FsbGluZyBjb2RlIHRvIHByb2Nlc3MgYXMgbm9ybWFsLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gRGF0YShlbGVtZW50KS50cmFuc2Zvcm1DYWNoZVt0cmFuc2Zvcm1OYW1lXTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9KSgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qKioqKioqKioqKioqXG5cdFx0XHRcdFx0IENvbG9yc1xuXHRcdFx0XHRcdCAqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0LyogU2luY2UgVmVsb2NpdHkgb25seSBhbmltYXRlcyBhIHNpbmdsZSBudW1lcmljIHZhbHVlIHBlciBwcm9wZXJ0eSwgY29sb3IgYW5pbWF0aW9uIGlzIGFjaGlldmVkIGJ5IGhvb2tpbmcgdGhlIGluZGl2aWR1YWwgUkdCQSBjb21wb25lbnRzIG9mIENTUyBjb2xvciBwcm9wZXJ0aWVzLlxuXHRcdFx0XHRcdCBBY2NvcmRpbmdseSwgY29sb3IgdmFsdWVzIG11c3QgYmUgbm9ybWFsaXplZCAoZS5nLiBcIiNmZjAwMDBcIiwgXCJyZWRcIiwgYW5kIFwicmdiKDI1NSwgMCwgMClcIiA9PT4gXCIyNTUgMCAwIDFcIikgc28gdGhhdCB0aGVpciBjb21wb25lbnRzIGNhbiBiZSBpbmplY3RlZC9leHRyYWN0ZWQgYnkgQ1NTLkhvb2tzIGxvZ2ljLiAqL1xuXHRcdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgQ1NTLkxpc3RzLmNvbG9ycy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0LyogV3JhcCB0aGUgZHluYW1pY2FsbHkgZ2VuZXJhdGVkIG5vcm1hbGl6YXRpb24gZnVuY3Rpb24gaW4gYSBuZXcgc2NvcGUgc28gdGhhdCBjb2xvck5hbWUncyB2YWx1ZSBpcyBwYWlyZWQgd2l0aCBpdHMgcmVzcGVjdGl2ZSBmdW5jdGlvbi5cblx0XHRcdFx0XHRcdCAoT3RoZXJ3aXNlLCBhbGwgZnVuY3Rpb25zIHdvdWxkIHRha2UgdGhlIGZpbmFsIGZvciBsb29wJ3MgY29sb3JOYW1lLikgKi9cblx0XHRcdFx0XHRcdChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGNvbG9yTmFtZSA9IENTUy5MaXN0cy5jb2xvcnNbal07XG5cblx0XHRcdFx0XHRcdFx0LyogTm90ZTogSW4gSUU8PTgsIHdoaWNoIHN1cHBvcnQgcmdiIGJ1dCBub3QgcmdiYSwgY29sb3IgcHJvcGVydGllcyBhcmUgcmV2ZXJ0ZWQgdG8gcmdiIGJ5IHN0cmlwcGluZyBvZmYgdGhlIGFscGhhIGNvbXBvbmVudC4gKi9cblx0XHRcdFx0XHRcdFx0Q1NTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbY29sb3JOYW1lXSA9IGZ1bmN0aW9uKHR5cGUsIGVsZW1lbnQsIHByb3BlcnR5VmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJuYW1lXCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBjb2xvck5hbWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIENvbnZlcnQgYWxsIGNvbG9yIHZhbHVlcyBpbnRvIHRoZSByZ2IgZm9ybWF0LiAoT2xkIElFIGNhbiByZXR1cm4gaGV4IHZhbHVlcyBhbmQgY29sb3IgbmFtZXMgaW5zdGVhZCBvZiByZ2IvcmdiYS4pICovXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFwiZXh0cmFjdFwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgZXh0cmFjdGVkO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIElmIHRoZSBjb2xvciBpcyBhbHJlYWR5IGluIGl0cyBob29rYWJsZSBmb3JtIChlLmcuIFwiMjU1IDI1NSAyNTUgMVwiKSBkdWUgdG8gaGF2aW5nIGJlZW4gcHJldmlvdXNseSBleHRyYWN0ZWQsIHNraXAgZXh0cmFjdGlvbi4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKENTUy5SZWdFeC53cmFwcGVkVmFsdWVBbHJlYWR5RXh0cmFjdGVkLnRlc3QocHJvcGVydHlWYWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRleHRyYWN0ZWQgPSBwcm9wZXJ0eVZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBjb252ZXJ0ZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGNvbG9yTmFtZXMgPSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YmxhY2s6IFwicmdiKDAsIDAsIDApXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ymx1ZTogXCJyZ2IoMCwgMCwgMjU1KVwiLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGdyYXk6IFwicmdiKDEyOCwgMTI4LCAxMjgpXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Z3JlZW46IFwicmdiKDAsIDEyOCwgMClcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZWQ6IFwicmdiKDI1NSwgMCwgMClcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR3aGl0ZTogXCJyZ2IoMjU1LCAyNTUsIDI1NSlcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyogQ29udmVydCBjb2xvciBuYW1lcyB0byByZ2IuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKC9eW0Etel0rJC9pLnRlc3QocHJvcGVydHlWYWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChjb2xvck5hbWVzW3Byb3BlcnR5VmFsdWVdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29udmVydGVkID0gY29sb3JOYW1lc1twcm9wZXJ0eVZhbHVlXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIElmIGFuIHVubWF0Y2hlZCBjb2xvciBuYW1lIGlzIHByb3ZpZGVkLCBkZWZhdWx0IHRvIGJsYWNrLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZWQgPSBjb2xvck5hbWVzLmJsYWNrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyogQ29udmVydCBoZXggdmFsdWVzIHRvIHJnYi4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKENTUy5SZWdFeC5pc0hleC50ZXN0KHByb3BlcnR5VmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZWQgPSBcInJnYihcIiArIENTUy5WYWx1ZXMuaGV4VG9SZ2IocHJvcGVydHlWYWx1ZSkuam9pbihcIiBcIikgKyBcIilcIjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIElmIHRoZSBwcm92aWRlZCBjb2xvciBkb2Vzbid0IG1hdGNoIGFueSBvZiB0aGUgYWNjZXB0ZWQgY29sb3IgZm9ybWF0cywgZGVmYXVsdCB0byBibGFjay4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCEoL15yZ2JhP1xcKC9pLnRlc3QocHJvcGVydHlWYWx1ZSkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZWQgPSBjb2xvck5hbWVzLmJsYWNrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIFJlbW92ZSB0aGUgc3Vycm91bmRpbmcgXCJyZ2IvcmdiYSgpXCIgc3RyaW5nIHRoZW4gcmVwbGFjZSBjb21tYXMgd2l0aCBzcGFjZXMgYW5kIHN0cmlwXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0IHJlcGVhdGVkIHNwYWNlcyAoaW4gY2FzZSB0aGUgdmFsdWUgaW5jbHVkZWQgc3BhY2VzIHRvIGJlZ2luIHdpdGgpLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGV4dHJhY3RlZCA9IChjb252ZXJ0ZWQgfHwgcHJvcGVydHlWYWx1ZSkudG9TdHJpbmcoKS5tYXRjaChDU1MuUmVnRXgudmFsdWVVbndyYXApWzFdLnJlcGxhY2UoLywoXFxzKyk/L2csIFwiIFwiKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIFNvIGxvbmcgYXMgdGhpcyBpc24ndCA8PUlFOCwgYWRkIGEgZm91cnRoIChhbHBoYSkgY29tcG9uZW50IGlmIGl0J3MgbWlzc2luZyBhbmQgZGVmYXVsdCBpdCB0byAxICh2aXNpYmxlKS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCghSUUgfHwgSUUgPiA4KSAmJiBleHRyYWN0ZWQuc3BsaXQoXCIgXCIpLmxlbmd0aCA9PT0gMykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGV4dHJhY3RlZCArPSBcIiAxXCI7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZXh0cmFjdGVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBcImluamVjdFwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBJZiB3ZSBoYXZlIGEgcGF0dGVybiB0aGVuIGl0IG1pZ2h0IGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgdmFsdWVzICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICgvXnJnYi8udGVzdChwcm9wZXJ0eVZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBwcm9wZXJ0eVZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogSWYgdGhpcyBpcyBJRTw9OCBhbmQgYW4gYWxwaGEgY29tcG9uZW50IGV4aXN0cywgc3RyaXAgaXQgb2ZmLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoSUUgPD0gOCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChwcm9wZXJ0eVZhbHVlLnNwbGl0KFwiIFwiKS5sZW5ndGggPT09IDQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5VmFsdWUgPSBwcm9wZXJ0eVZhbHVlLnNwbGl0KC9cXHMrLykuc2xpY2UoMCwgMykuam9pbihcIiBcIik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIE90aGVyd2lzZSwgYWRkIGEgZm91cnRoIChhbHBoYSkgY29tcG9uZW50IGlmIGl0J3MgbWlzc2luZyBhbmQgZGVmYXVsdCBpdCB0byAxICh2aXNpYmxlKS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwcm9wZXJ0eVZhbHVlLnNwbGl0KFwiIFwiKS5sZW5ndGggPT09IDMpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eVZhbHVlICs9IFwiIDFcIjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIFJlLWluc2VydCB0aGUgYnJvd3Nlci1hcHByb3ByaWF0ZSB3cmFwcGVyKFwicmdiL3JnYmEoKVwiKSwgaW5zZXJ0IGNvbW1hcywgYW5kIHN0cmlwIG9mZiBkZWNpbWFsIHVuaXRzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCBvbiBhbGwgdmFsdWVzIGJ1dCB0aGUgZm91cnRoIChSLCBHLCBhbmQgQiBvbmx5IGFjY2VwdCB3aG9sZSBudW1iZXJzKS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIChJRSA8PSA4ID8gXCJyZ2JcIiA6IFwicmdiYVwiKSArIFwiKFwiICsgcHJvcGVydHlWYWx1ZS5yZXBsYWNlKC9cXHMrL2csIFwiLFwiKS5yZXBsYWNlKC9cXC4oXFxkKSsoPz0sKS9nLCBcIlwiKSArIFwiKVwiO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH0pKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyoqKioqKioqKioqKioqXG5cdFx0XHRcdFx0IERpbWVuc2lvbnNcblx0XHRcdFx0XHQgKioqKioqKioqKioqKiovXG5cdFx0XHRcdFx0ZnVuY3Rpb24gYXVnbWVudERpbWVuc2lvbihuYW1lLCBlbGVtZW50LCB3YW50SW5uZXIpIHtcblx0XHRcdFx0XHRcdHZhciBpc0JvcmRlckJveCA9IENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwiYm94U2l6aW5nXCIpLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0XHRcdFx0XHRcdGlmIChpc0JvcmRlckJveCA9PT0gKHdhbnRJbm5lciB8fCBmYWxzZSkpIHtcblx0XHRcdFx0XHRcdFx0LyogaW4gYm94LXNpemluZyBtb2RlLCB0aGUgQ1NTIHdpZHRoIC8gaGVpZ2h0IGFjY2Vzc29ycyBhbHJlYWR5IGdpdmUgdGhlIG91dGVyV2lkdGggLyBvdXRlckhlaWdodC4gKi9cblx0XHRcdFx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdGF1Z21lbnQgPSAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0c2lkZXMgPSBuYW1lID09PSBcIndpZHRoXCIgPyBbXCJMZWZ0XCIsIFwiUmlnaHRcIl0gOiBbXCJUb3BcIiwgXCJCb3R0b21cIl0sXG5cdFx0XHRcdFx0XHRcdFx0XHRmaWVsZHMgPSBbXCJwYWRkaW5nXCIgKyBzaWRlc1swXSwgXCJwYWRkaW5nXCIgKyBzaWRlc1sxXSwgXCJib3JkZXJcIiArIHNpZGVzWzBdICsgXCJXaWR0aFwiLCBcImJvcmRlclwiICsgc2lkZXNbMV0gKyBcIldpZHRoXCJdO1xuXG5cdFx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHBhcnNlRmxvYXQoQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgZmllbGRzW2ldKSk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFpc05hTih2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGF1Z21lbnQgKz0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB3YW50SW5uZXIgPyAtYXVnbWVudCA6IGF1Z21lbnQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZnVuY3Rpb24gZ2V0RGltZW5zaW9uKG5hbWUsIHdhbnRJbm5lcikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHR5cGUsIGVsZW1lbnQsIHByb3BlcnR5VmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBcIm5hbWVcIjpcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBuYW1lO1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJleHRyYWN0XCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcGFyc2VGbG9hdChwcm9wZXJ0eVZhbHVlKSArIGF1Z21lbnREaW1lbnNpb24obmFtZSwgZWxlbWVudCwgd2FudElubmVyKTtcblx0XHRcdFx0XHRcdFx0XHRjYXNlIFwiaW5qZWN0XCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gKHBhcnNlRmxvYXQocHJvcGVydHlWYWx1ZSkgLSBhdWdtZW50RGltZW5zaW9uKG5hbWUsIGVsZW1lbnQsIHdhbnRJbm5lcikpICsgXCJweFwiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRDU1MuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZC5pbm5lcldpZHRoID0gZ2V0RGltZW5zaW9uKFwid2lkdGhcIiwgdHJ1ZSk7XG5cdFx0XHRcdFx0Q1NTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWQuaW5uZXJIZWlnaHQgPSBnZXREaW1lbnNpb24oXCJoZWlnaHRcIiwgdHJ1ZSk7XG5cdFx0XHRcdFx0Q1NTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWQub3V0ZXJXaWR0aCA9IGdldERpbWVuc2lvbihcIndpZHRoXCIpO1xuXHRcdFx0XHRcdENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkLm91dGVySGVpZ2h0ID0gZ2V0RGltZW5zaW9uKFwiaGVpZ2h0XCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0IENTUyBQcm9wZXJ0eSBOYW1lc1xuXHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0TmFtZXM6IHtcblx0XHRcdFx0LyogQ2FtZWxjYXNlIGEgcHJvcGVydHkgbmFtZSBpbnRvIGl0cyBKYXZhU2NyaXB0IG5vdGF0aW9uIChlLmcuIFwiYmFja2dyb3VuZC1jb2xvclwiID09PiBcImJhY2tncm91bmRDb2xvclwiKS5cblx0XHRcdFx0IENhbWVsY2FzaW5nIGlzIHVzZWQgdG8gbm9ybWFsaXplIHByb3BlcnR5IG5hbWVzIGJldHdlZW4gYW5kIGFjcm9zcyBjYWxscy4gKi9cblx0XHRcdFx0Y2FtZWxDYXNlOiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuXHRcdFx0XHRcdHJldHVybiBwcm9wZXJ0eS5yZXBsYWNlKC8tKFxcdykvZywgZnVuY3Rpb24obWF0Y2gsIHN1Yk1hdGNoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gc3ViTWF0Y2gudG9VcHBlckNhc2UoKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0LyogRm9yIFNWRyBlbGVtZW50cywgc29tZSBwcm9wZXJ0aWVzIChuYW1lbHksIGRpbWVuc2lvbmFsIG9uZXMpIGFyZSBHRVQvU0VUIHZpYSB0aGUgZWxlbWVudCdzIEhUTUwgYXR0cmlidXRlcyAoaW5zdGVhZCBvZiB2aWEgQ1NTIHN0eWxlcykuICovXG5cdFx0XHRcdFNWR0F0dHJpYnV0ZTogZnVuY3Rpb24ocHJvcGVydHkpIHtcblx0XHRcdFx0XHR2YXIgU1ZHQXR0cmlidXRlcyA9IFwid2lkdGh8aGVpZ2h0fHh8eXxjeHxjeXxyfHJ4fHJ5fHgxfHgyfHkxfHkyXCI7XG5cblx0XHRcdFx0XHQvKiBDZXJ0YWluIGJyb3dzZXJzIHJlcXVpcmUgYW4gU1ZHIHRyYW5zZm9ybSB0byBiZSBhcHBsaWVkIGFzIGFuIGF0dHJpYnV0ZS4gKE90aGVyd2lzZSwgYXBwbGljYXRpb24gdmlhIENTUyBpcyBwcmVmZXJhYmxlIGR1ZSB0byAzRCBzdXBwb3J0LikgKi9cblx0XHRcdFx0XHRpZiAoSUUgfHwgKFZlbG9jaXR5LlN0YXRlLmlzQW5kcm9pZCAmJiAhVmVsb2NpdHkuU3RhdGUuaXNDaHJvbWUpKSB7XG5cdFx0XHRcdFx0XHRTVkdBdHRyaWJ1dGVzICs9IFwifHRyYW5zZm9ybVwiO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBuZXcgUmVnRXhwKFwiXihcIiArIFNWR0F0dHJpYnV0ZXMgKyBcIikkXCIsIFwiaVwiKS50ZXN0KHByb3BlcnR5KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0LyogRGV0ZXJtaW5lIHdoZXRoZXIgYSBwcm9wZXJ0eSBzaG91bGQgYmUgc2V0IHdpdGggYSB2ZW5kb3IgcHJlZml4LiAqL1xuXHRcdFx0XHQvKiBJZiBhIHByZWZpeGVkIHZlcnNpb24gb2YgdGhlIHByb3BlcnR5IGV4aXN0cywgcmV0dXJuIGl0LiBPdGhlcndpc2UsIHJldHVybiB0aGUgb3JpZ2luYWwgcHJvcGVydHkgbmFtZS5cblx0XHRcdFx0IElmIHRoZSBwcm9wZXJ0eSBpcyBub3QgYXQgYWxsIHN1cHBvcnRlZCBieSB0aGUgYnJvd3NlciwgcmV0dXJuIGEgZmFsc2UgZmxhZy4gKi9cblx0XHRcdFx0cHJlZml4Q2hlY2s6IGZ1bmN0aW9uKHByb3BlcnR5KSB7XG5cdFx0XHRcdFx0LyogSWYgdGhpcyBwcm9wZXJ0eSBoYXMgYWxyZWFkeSBiZWVuIGNoZWNrZWQsIHJldHVybiB0aGUgY2FjaGVkIHZhbHVlLiAqL1xuXHRcdFx0XHRcdGlmIChWZWxvY2l0eS5TdGF0ZS5wcmVmaXhNYXRjaGVzW3Byb3BlcnR5XSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFtWZWxvY2l0eS5TdGF0ZS5wcmVmaXhNYXRjaGVzW3Byb3BlcnR5XSwgdHJ1ZV07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciB2ZW5kb3JzID0gW1wiXCIsIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiwgXCJPXCJdO1xuXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgdmVuZG9yc0xlbmd0aCA9IHZlbmRvcnMubGVuZ3RoOyBpIDwgdmVuZG9yc0xlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBwcm9wZXJ0eVByZWZpeGVkO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydHlQcmVmaXhlZCA9IHByb3BlcnR5O1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdC8qIENhcGl0YWxpemUgdGhlIGZpcnN0IGxldHRlciBvZiB0aGUgcHJvcGVydHkgdG8gY29uZm9ybSB0byBKYXZhU2NyaXB0IHZlbmRvciBwcmVmaXggbm90YXRpb24gKGUuZy4gd2Via2l0RmlsdGVyKS4gKi9cblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eVByZWZpeGVkID0gdmVuZG9yc1tpXSArIHByb3BlcnR5LnJlcGxhY2UoL15cXHcvLCBmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIG1hdGNoLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvKiBDaGVjayBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGlzIHByb3BlcnR5IGFzIHByZWZpeGVkLiAqL1xuXHRcdFx0XHRcdFx0XHRpZiAoVHlwZS5pc1N0cmluZyhWZWxvY2l0eS5TdGF0ZS5wcmVmaXhFbGVtZW50LnN0eWxlW3Byb3BlcnR5UHJlZml4ZWRdKSkge1xuXHRcdFx0XHRcdFx0XHRcdC8qIENhY2hlIHRoZSBtYXRjaC4gKi9cblx0XHRcdFx0XHRcdFx0XHRWZWxvY2l0eS5TdGF0ZS5wcmVmaXhNYXRjaGVzW3Byb3BlcnR5XSA9IHByb3BlcnR5UHJlZml4ZWQ7XG5cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gW3Byb3BlcnR5UHJlZml4ZWQsIHRydWVdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIElmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGlzIHByb3BlcnR5IGluIGFueSBmb3JtLCBpbmNsdWRlIGEgZmFsc2UgZmxhZyBzbyB0aGF0IHRoZSBjYWxsZXIgY2FuIGRlY2lkZSBob3cgdG8gcHJvY2VlZC4gKi9cblx0XHRcdFx0XHRcdHJldHVybiBbcHJvcGVydHksIGZhbHNlXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHQgQ1NTIFByb3BlcnR5IFZhbHVlc1xuXHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0VmFsdWVzOiB7XG5cdFx0XHRcdC8qIEhleCB0byBSR0IgY29udmVyc2lvbi4gQ29weXJpZ2h0IFRpbSBEb3duOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU2MjM4MzgvcmdiLXRvLWhleC1hbmQtaGV4LXRvLXJnYiAqL1xuXHRcdFx0XHRoZXhUb1JnYjogZnVuY3Rpb24oaGV4KSB7XG5cdFx0XHRcdFx0dmFyIHNob3J0Zm9ybVJlZ2V4ID0gL14jPyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaSxcblx0XHRcdFx0XHRcdFx0bG9uZ2Zvcm1SZWdleCA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2ksXG5cdFx0XHRcdFx0XHRcdHJnYlBhcnRzO1xuXG5cdFx0XHRcdFx0aGV4ID0gaGV4LnJlcGxhY2Uoc2hvcnRmb3JtUmVnZXgsIGZ1bmN0aW9uKG0sIHIsIGcsIGIpIHtcblx0XHRcdFx0XHRcdHJldHVybiByICsgciArIGcgKyBnICsgYiArIGI7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRyZ2JQYXJ0cyA9IGxvbmdmb3JtUmVnZXguZXhlYyhoZXgpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHJnYlBhcnRzID8gW3BhcnNlSW50KHJnYlBhcnRzWzFdLCAxNiksIHBhcnNlSW50KHJnYlBhcnRzWzJdLCAxNiksIHBhcnNlSW50KHJnYlBhcnRzWzNdLCAxNildIDogWzAsIDAsIDBdO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRpc0NTU051bGxWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0XHQvKiBUaGUgYnJvd3NlciBkZWZhdWx0cyBDU1MgdmFsdWVzIHRoYXQgaGF2ZSBub3QgYmVlbiBzZXQgdG8gZWl0aGVyIDAgb3Igb25lIG9mIHNldmVyYWwgcG9zc2libGUgbnVsbC12YWx1ZSBzdHJpbmdzLlxuXHRcdFx0XHRcdCBUaHVzLCB3ZSBjaGVjayBmb3IgYm90aCBmYWxzaW5lc3MgYW5kIHRoZXNlIHNwZWNpYWwgc3RyaW5ncy4gKi9cblx0XHRcdFx0XHQvKiBOdWxsLXZhbHVlIGNoZWNraW5nIGlzIHBlcmZvcm1lZCB0byBkZWZhdWx0IHRoZSBzcGVjaWFsIHN0cmluZ3MgdG8gMCAoZm9yIHRoZSBzYWtlIG9mIHR3ZWVuaW5nKSBvciB0aGVpciBob29rXG5cdFx0XHRcdFx0IHRlbXBsYXRlcyBhcyBkZWZpbmVkIGFzIENTUy5Ib29rcyAoZm9yIHRoZSBzYWtlIG9mIGhvb2sgaW5qZWN0aW9uL2V4dHJhY3Rpb24pLiAqL1xuXHRcdFx0XHRcdC8qIE5vdGU6IENocm9tZSByZXR1cm5zIFwicmdiYSgwLCAwLCAwLCAwKVwiIGZvciBhbiB1bmRlZmluZWQgY29sb3Igd2hlcmVhcyBJRSByZXR1cm5zIFwidHJhbnNwYXJlbnRcIi4gKi9cblx0XHRcdFx0XHRyZXR1cm4gKCF2YWx1ZSB8fCAvXihub25lfGF1dG98dHJhbnNwYXJlbnR8KHJnYmFcXCgwLCA/MCwgPzAsID8wXFwpKSkkL2kudGVzdCh2YWx1ZSkpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQvKiBSZXRyaWV2ZSBhIHByb3BlcnR5J3MgZGVmYXVsdCB1bml0IHR5cGUuIFVzZWQgZm9yIGFzc2lnbmluZyBhIHVuaXQgdHlwZSB3aGVuIG9uZSBpcyBub3Qgc3VwcGxpZWQgYnkgdGhlIHVzZXIuICovXG5cdFx0XHRcdGdldFVuaXRUeXBlOiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuXHRcdFx0XHRcdGlmICgvXihyb3RhdGV8c2tldykvaS50ZXN0KHByb3BlcnR5KSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFwiZGVnXCI7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICgvKF4oc2NhbGV8c2NhbGVYfHNjYWxlWXxzY2FsZVp8YWxwaGF8ZmxleEdyb3d8ZmxleEhlaWdodHx6SW5kZXh8Zm9udFdlaWdodCkkKXwoKG9wYWNpdHl8cmVkfGdyZWVufGJsdWV8YWxwaGEpJCkvaS50ZXN0KHByb3BlcnR5KSkge1xuXHRcdFx0XHRcdFx0LyogVGhlIGFib3ZlIHByb3BlcnRpZXMgYXJlIHVuaXRsZXNzLiAqL1xuXHRcdFx0XHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8qIERlZmF1bHQgdG8gcHggZm9yIGFsbCBvdGhlciBwcm9wZXJ0aWVzLiAqL1xuXHRcdFx0XHRcdFx0cmV0dXJuIFwicHhcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8qIEhUTUwgZWxlbWVudHMgZGVmYXVsdCB0byBhbiBhc3NvY2lhdGVkIGRpc3BsYXkgdHlwZSB3aGVuIHRoZXkncmUgbm90IHNldCB0byBkaXNwbGF5Om5vbmUuICovXG5cdFx0XHRcdC8qIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBmb3IgY29ycmVjdGx5IHNldHRpbmcgdGhlIG5vbi1cIm5vbmVcIiBkaXNwbGF5IHZhbHVlIGluIGNlcnRhaW4gVmVsb2NpdHkgcmVkaXJlY3RzLCBzdWNoIGFzIGZhZGVJbi9PdXQuICovXG5cdFx0XHRcdGdldERpc3BsYXlUeXBlOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRcdFx0dmFyIHRhZ05hbWUgPSBlbGVtZW50ICYmIGVsZW1lbnQudGFnTmFtZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdFx0XHRpZiAoL14oYnxiaWd8aXxzbWFsbHx0dHxhYmJyfGFjcm9ueW18Y2l0ZXxjb2RlfGRmbnxlbXxrYmR8c3Ryb25nfHNhbXB8dmFyfGF8YmRvfGJyfGltZ3xtYXB8b2JqZWN0fHF8c2NyaXB0fHNwYW58c3VifHN1cHxidXR0b258aW5wdXR8bGFiZWx8c2VsZWN0fHRleHRhcmVhKSQvaS50ZXN0KHRhZ05hbWUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gXCJpbmxpbmVcIjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKC9eKGxpKSQvaS50ZXN0KHRhZ05hbWUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gXCJsaXN0LWl0ZW1cIjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKC9eKHRyKSQvaS50ZXN0KHRhZ05hbWUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gXCJ0YWJsZS1yb3dcIjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKC9eKHRhYmxlKSQvaS50ZXN0KHRhZ05hbWUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gXCJ0YWJsZVwiO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoL14odGJvZHkpJC9pLnRlc3QodGFnTmFtZSkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBcInRhYmxlLXJvdy1ncm91cFwiO1xuXHRcdFx0XHRcdFx0LyogRGVmYXVsdCB0byBcImJsb2NrXCIgd2hlbiBubyBtYXRjaCBpcyBmb3VuZC4gKi9cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFwiYmxvY2tcIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8qIFRoZSBjbGFzcyBhZGQvcmVtb3ZlIGZ1bmN0aW9ucyBhcmUgdXNlZCB0byB0ZW1wb3JhcmlseSBhcHBseSBhIFwidmVsb2NpdHktYW5pbWF0aW5nXCIgY2xhc3MgdG8gZWxlbWVudHMgd2hpbGUgdGhleSdyZSBhbmltYXRpbmcuICovXG5cdFx0XHRcdGFkZENsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUpIHtcblx0XHRcdFx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0XHRcdFx0aWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChUeXBlLmlzU3RyaW5nKGVsZW1lbnQuY2xhc3NOYW1lKSkge1xuXHRcdFx0XHRcdFx0XHQvLyBFbGVtZW50LmNsYXNzTmFtZSBpcyBhcm91bmQgMTUlIGZhc3RlciB0aGVuIHNldC9nZXRBdHRyaWJ1dGVcblx0XHRcdFx0XHRcdFx0ZWxlbWVudC5jbGFzc05hbWUgKz0gKGVsZW1lbnQuY2xhc3NOYW1lLmxlbmd0aCA/IFwiIFwiIDogXCJcIikgKyBjbGFzc05hbWU7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBXb3JrIGFyb3VuZCBmb3IgSUUgc3RyaWN0IG1vZGUgYW5pbWF0aW5nIFNWRyAtIGFuZCBhbnl0aGluZyBlbHNlIHRoYXQgZG9lc24ndCBiZWhhdmUgY29ycmVjdGx5IC0gdGhlIHNhbWUgd2F5IGpRdWVyeSBkb2VzIGl0XG5cdFx0XHRcdFx0XHRcdHZhciBjdXJyZW50Q2xhc3MgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShJRSA8PSA3ID8gXCJjbGFzc05hbWVcIiA6IFwiY2xhc3NcIikgfHwgXCJcIjtcblxuXHRcdFx0XHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGN1cnJlbnRDbGFzcyArIChjdXJyZW50Q2xhc3MgPyBcIiBcIiA6IFwiXCIpICsgY2xhc3NOYW1lKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlbW92ZUNsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUpIHtcblx0XHRcdFx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0XHRcdFx0aWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChUeXBlLmlzU3RyaW5nKGVsZW1lbnQuY2xhc3NOYW1lKSkge1xuXHRcdFx0XHRcdFx0XHQvLyBFbGVtZW50LmNsYXNzTmFtZSBpcyBhcm91bmQgMTUlIGZhc3RlciB0aGVuIHNldC9nZXRBdHRyaWJ1dGVcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogTmVlZCBzb21lIGpzcGVyZiB0ZXN0cyBvbiBwZXJmb3JtYW5jZSAtIGNhbiB3ZSBnZXQgcmlkIG9mIHRoZSByZWdleCBhbmQgbWF5YmUgdXNlIHNwbGl0IC8gYXJyYXkgbWFuaXB1bGF0aW9uP1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnRvU3RyaW5nKCkucmVwbGFjZShuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIgKyBjbGFzc05hbWUuc3BsaXQoXCIgXCIpLmpvaW4oXCJ8XCIpICsgXCIoXFxcXHN8JClcIiwgXCJnaVwiKSwgXCIgXCIpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gV29yayBhcm91bmQgZm9yIElFIHN0cmljdCBtb2RlIGFuaW1hdGluZyBTVkcgLSBhbmQgYW55dGhpbmcgZWxzZSB0aGF0IGRvZXNuJ3QgYmVoYXZlIGNvcnJlY3RseSAtIHRoZSBzYW1lIHdheSBqUXVlcnkgZG9lcyBpdFxuXHRcdFx0XHRcdFx0XHR2YXIgY3VycmVudENsYXNzID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoSUUgPD0gNyA/IFwiY2xhc3NOYW1lXCIgOiBcImNsYXNzXCIpIHx8IFwiXCI7XG5cblx0XHRcdFx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBjdXJyZW50Q2xhc3MucmVwbGFjZShuZXcgUmVnRXhwKFwiKF58XFxzKVwiICsgY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5qb2luKFwifFwiKSArIFwiKFxcc3wkKVwiLCBcImdpXCIpLCBcIiBcIikpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHQgU3R5bGUgR2V0dGluZyAmIFNldHRpbmdcblx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHQvKiBUaGUgc2luZ3VsYXIgZ2V0UHJvcGVydHlWYWx1ZSwgd2hpY2ggcm91dGVzIHRoZSBsb2dpYyBmb3IgYWxsIG5vcm1hbGl6YXRpb25zLCBob29rcywgYW5kIHN0YW5kYXJkIENTUyBwcm9wZXJ0aWVzLiAqL1xuXHRcdFx0Z2V0UHJvcGVydHlWYWx1ZTogZnVuY3Rpb24oZWxlbWVudCwgcHJvcGVydHksIHJvb3RQcm9wZXJ0eVZhbHVlLCBmb3JjZVN0eWxlTG9va3VwKSB7XG5cdFx0XHRcdC8qIEdldCBhbiBlbGVtZW50J3MgY29tcHV0ZWQgcHJvcGVydHkgdmFsdWUuICovXG5cdFx0XHRcdC8qIE5vdGU6IFJldHJpZXZpbmcgdGhlIHZhbHVlIG9mIGEgQ1NTIHByb3BlcnR5IGNhbm5vdCBzaW1wbHkgYmUgcGVyZm9ybWVkIGJ5IGNoZWNraW5nIGFuIGVsZW1lbnQnc1xuXHRcdFx0XHQgc3R5bGUgYXR0cmlidXRlICh3aGljaCBvbmx5IHJlZmxlY3RzIHVzZXItZGVmaW5lZCB2YWx1ZXMpLiBJbnN0ZWFkLCB0aGUgYnJvd3NlciBtdXN0IGJlIHF1ZXJpZWQgZm9yIGEgcHJvcGVydHknc1xuXHRcdFx0XHQgKmNvbXB1dGVkKiB2YWx1ZS4gWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgZ2V0Q29tcHV0ZWRTdHlsZSBoZXJlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvd2luZG93LmdldENvbXB1dGVkU3R5bGUgKi9cblx0XHRcdFx0ZnVuY3Rpb24gY29tcHV0ZVByb3BlcnR5VmFsdWUoZWxlbWVudCwgcHJvcGVydHkpIHtcblx0XHRcdFx0XHQvKiBXaGVuIGJveC1zaXppbmcgaXNuJ3Qgc2V0IHRvIGJvcmRlci1ib3gsIGhlaWdodCBhbmQgd2lkdGggc3R5bGUgdmFsdWVzIGFyZSBpbmNvcnJlY3RseSBjb21wdXRlZCB3aGVuIGFuXG5cdFx0XHRcdFx0IGVsZW1lbnQncyBzY3JvbGxiYXJzIGFyZSB2aXNpYmxlICh3aGljaCBleHBhbmRzIHRoZSBlbGVtZW50J3MgZGltZW5zaW9ucykuIFRodXMsIHdlIGRlZmVyIHRvIHRoZSBtb3JlIGFjY3VyYXRlXG5cdFx0XHRcdFx0IG9mZnNldEhlaWdodC9XaWR0aCBwcm9wZXJ0eSwgd2hpY2ggaW5jbHVkZXMgdGhlIHRvdGFsIGRpbWVuc2lvbnMgZm9yIGludGVyaW9yLCBib3JkZXIsIHBhZGRpbmcsIGFuZCBzY3JvbGxiYXIuXG5cdFx0XHRcdFx0IFdlIHN1YnRyYWN0IGJvcmRlciBhbmQgcGFkZGluZyB0byBnZXQgdGhlIHN1bSBvZiBpbnRlcmlvciArIHNjcm9sbGJhci4gKi9cblx0XHRcdFx0XHR2YXIgY29tcHV0ZWRWYWx1ZSA9IDA7XG5cblx0XHRcdFx0XHQvKiBJRTw9OCBkb2Vzbid0IHN1cHBvcnQgd2luZG93LmdldENvbXB1dGVkU3R5bGUsIHRodXMgd2UgZGVmZXIgdG8galF1ZXJ5LCB3aGljaCBoYXMgYW4gZXh0ZW5zaXZlIGFycmF5XG5cdFx0XHRcdFx0IG9mIGhhY2tzIHRvIGFjY3VyYXRlbHkgcmV0cmlldmUgSUU4IHByb3BlcnR5IHZhbHVlcy4gUmUtaW1wbGVtZW50aW5nIHRoYXQgbG9naWMgaGVyZSBpcyBub3Qgd29ydGggYmxvYXRpbmcgdGhlXG5cdFx0XHRcdFx0IGNvZGViYXNlIGZvciBhIGR5aW5nIGJyb3dzZXIuIFRoZSBwZXJmb3JtYW5jZSByZXBlcmN1c3Npb25zIG9mIHVzaW5nIGpRdWVyeSBoZXJlIGFyZSBtaW5pbWFsIHNpbmNlXG5cdFx0XHRcdFx0IFZlbG9jaXR5IGlzIG9wdGltaXplZCB0byByYXJlbHkgKGFuZCBzb21ldGltZXMgbmV2ZXIpIHF1ZXJ5IHRoZSBET00uIEZ1cnRoZXIsIHRoZSAkLmNzcygpIGNvZGVwYXRoIGlzbid0IHRoYXQgc2xvdy4gKi9cblx0XHRcdFx0XHRpZiAoSUUgPD0gOCkge1xuXHRcdFx0XHRcdFx0Y29tcHV0ZWRWYWx1ZSA9ICQuY3NzKGVsZW1lbnQsIHByb3BlcnR5KTsgLyogR0VUICovXG5cdFx0XHRcdFx0XHQvKiBBbGwgb3RoZXIgYnJvd3NlcnMgc3VwcG9ydCBnZXRDb21wdXRlZFN0eWxlLiBUaGUgcmV0dXJuZWQgbGl2ZSBvYmplY3QgcmVmZXJlbmNlIGlzIGNhY2hlZCBvbnRvIGl0c1xuXHRcdFx0XHRcdFx0IGFzc29jaWF0ZWQgZWxlbWVudCBzbyB0aGF0IGl0IGRvZXMgbm90IG5lZWQgdG8gYmUgcmVmZXRjaGVkIHVwb24gZXZlcnkgR0VULiAqL1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvKiBCcm93c2VycyBkbyBub3QgcmV0dXJuIGhlaWdodCBhbmQgd2lkdGggdmFsdWVzIGZvciBlbGVtZW50cyB0aGF0IGFyZSBzZXQgdG8gZGlzcGxheTpcIm5vbmVcIi4gVGh1cywgd2UgdGVtcG9yYXJpbHlcblx0XHRcdFx0XHRcdCB0b2dnbGUgZGlzcGxheSB0byB0aGUgZWxlbWVudCB0eXBlJ3MgZGVmYXVsdCB2YWx1ZS4gKi9cblx0XHRcdFx0XHRcdHZhciB0b2dnbGVEaXNwbGF5ID0gZmFsc2U7XG5cblx0XHRcdFx0XHRcdGlmICgvXih3aWR0aHxoZWlnaHQpJC8udGVzdChwcm9wZXJ0eSkgJiYgQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJkaXNwbGF5XCIpID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdHRvZ2dsZURpc3BsYXkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRDU1Muc2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcImRpc3BsYXlcIiwgQ1NTLlZhbHVlcy5nZXREaXNwbGF5VHlwZShlbGVtZW50KSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhciByZXZlcnREaXNwbGF5ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh0b2dnbGVEaXNwbGF5KSB7XG5cdFx0XHRcdFx0XHRcdFx0Q1NTLnNldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0aWYgKCFmb3JjZVN0eWxlTG9va3VwKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChwcm9wZXJ0eSA9PT0gXCJoZWlnaHRcIiAmJiBDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcImJveFNpemluZ1wiKS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgIT09IFwiYm9yZGVyLWJveFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGNvbnRlbnRCb3hIZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodCAtIChwYXJzZUZsb2F0KENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwiYm9yZGVyVG9wV2lkdGhcIikpIHx8IDApIC0gKHBhcnNlRmxvYXQoQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJib3JkZXJCb3R0b21XaWR0aFwiKSkgfHwgMCkgLSAocGFyc2VGbG9hdChDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcInBhZGRpbmdUb3BcIikpIHx8IDApIC0gKHBhcnNlRmxvYXQoQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJwYWRkaW5nQm90dG9tXCIpKSB8fCAwKTtcblx0XHRcdFx0XHRcdFx0XHRyZXZlcnREaXNwbGF5KCk7XG5cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gY29udGVudEJveEhlaWdodDtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gXCJ3aWR0aFwiICYmIENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwiYm94U2l6aW5nXCIpLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSAhPT0gXCJib3JkZXItYm94XCIpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgY29udGVudEJveFdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aCAtIChwYXJzZUZsb2F0KENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwiYm9yZGVyTGVmdFdpZHRoXCIpKSB8fCAwKSAtIChwYXJzZUZsb2F0KENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwiYm9yZGVyUmlnaHRXaWR0aFwiKSkgfHwgMCkgLSAocGFyc2VGbG9hdChDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcInBhZGRpbmdMZWZ0XCIpKSB8fCAwKSAtIChwYXJzZUZsb2F0KENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwicGFkZGluZ1JpZ2h0XCIpKSB8fCAwKTtcblx0XHRcdFx0XHRcdFx0XHRyZXZlcnREaXNwbGF5KCk7XG5cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gY29udGVudEJveFdpZHRoO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhciBjb21wdXRlZFN0eWxlO1xuXG5cdFx0XHRcdFx0XHQvKiBGb3IgZWxlbWVudHMgdGhhdCBWZWxvY2l0eSBoYXNuJ3QgYmVlbiBjYWxsZWQgb24gZGlyZWN0bHkgKGUuZy4gd2hlbiBWZWxvY2l0eSBxdWVyaWVzIHRoZSBET00gb24gYmVoYWxmXG5cdFx0XHRcdFx0XHQgb2YgYSBwYXJlbnQgb2YgYW4gZWxlbWVudCBpdHMgYW5pbWF0aW5nKSwgcGVyZm9ybSBhIGRpcmVjdCBnZXRDb21wdXRlZFN0eWxlIGxvb2t1cCBzaW5jZSB0aGUgb2JqZWN0IGlzbid0IGNhY2hlZC4gKi9cblx0XHRcdFx0XHRcdGlmIChEYXRhKGVsZW1lbnQpID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0Y29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpOyAvKiBHRVQgKi9cblx0XHRcdFx0XHRcdFx0LyogSWYgdGhlIGNvbXB1dGVkU3R5bGUgb2JqZWN0IGhhcyB5ZXQgdG8gYmUgY2FjaGVkLCBkbyBzbyBub3cuICovXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCFEYXRhKGVsZW1lbnQpLmNvbXB1dGVkU3R5bGUpIHtcblx0XHRcdFx0XHRcdFx0Y29tcHV0ZWRTdHlsZSA9IERhdGEoZWxlbWVudCkuY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpOyAvKiBHRVQgKi9cblx0XHRcdFx0XHRcdFx0LyogSWYgY29tcHV0ZWRTdHlsZSBpcyBjYWNoZWQsIHVzZSBpdC4gKi9cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbXB1dGVkU3R5bGUgPSBEYXRhKGVsZW1lbnQpLmNvbXB1dGVkU3R5bGU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIElFIGFuZCBGaXJlZm94IGRvIG5vdCByZXR1cm4gYSB2YWx1ZSBmb3IgdGhlIGdlbmVyaWMgYm9yZGVyQ29sb3IgLS0gdGhleSBvbmx5IHJldHVybiBpbmRpdmlkdWFsIHZhbHVlcyBmb3IgZWFjaCBib3JkZXIgc2lkZSdzIGNvbG9yLlxuXHRcdFx0XHRcdFx0IEFsc28sIGluIGFsbCBicm93c2Vycywgd2hlbiBib3JkZXIgY29sb3JzIGFyZW4ndCBhbGwgdGhlIHNhbWUsIGEgY29tcG91bmQgdmFsdWUgaXMgcmV0dXJuZWQgdGhhdCBWZWxvY2l0eSBpc24ndCBzZXR1cCB0byBwYXJzZS5cblx0XHRcdFx0XHRcdCBTbywgYXMgYSBwb2x5ZmlsbCBmb3IgcXVlcnlpbmcgaW5kaXZpZHVhbCBib3JkZXIgc2lkZSBjb2xvcnMsIHdlIGp1c3QgcmV0dXJuIHRoZSB0b3AgYm9yZGVyJ3MgY29sb3IgYW5kIGFuaW1hdGUgYWxsIGJvcmRlcnMgZnJvbSB0aGF0IHZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0aWYgKHByb3BlcnR5ID09PSBcImJvcmRlckNvbG9yXCIpIHtcblx0XHRcdFx0XHRcdFx0cHJvcGVydHkgPSBcImJvcmRlclRvcENvbG9yXCI7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIElFOSBoYXMgYSBidWcgaW4gd2hpY2ggdGhlIFwiZmlsdGVyXCIgcHJvcGVydHkgbXVzdCBiZSBhY2Nlc3NlZCBmcm9tIGNvbXB1dGVkU3R5bGUgdXNpbmcgdGhlIGdldFByb3BlcnR5VmFsdWUgbWV0aG9kXG5cdFx0XHRcdFx0XHQgaW5zdGVhZCBvZiBhIGRpcmVjdCBwcm9wZXJ0eSBsb29rdXAuIFRoZSBnZXRQcm9wZXJ0eVZhbHVlIG1ldGhvZCBpcyBzbG93ZXIgdGhhbiBhIGRpcmVjdCBsb29rdXAsIHdoaWNoIGlzIHdoeSB3ZSBhdm9pZCBpdCBieSBkZWZhdWx0LiAqL1xuXHRcdFx0XHRcdFx0aWYgKElFID09PSA5ICYmIHByb3BlcnR5ID09PSBcImZpbHRlclwiKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXB1dGVkVmFsdWUgPSBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpOyAvKiBHRVQgKi9cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbXB1dGVkVmFsdWUgPSBjb21wdXRlZFN0eWxlW3Byb3BlcnR5XTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyogRmFsbCBiYWNrIHRvIHRoZSBwcm9wZXJ0eSdzIHN0eWxlIHZhbHVlIChpZiBkZWZpbmVkKSB3aGVuIGNvbXB1dGVkVmFsdWUgcmV0dXJucyBub3RoaW5nLFxuXHRcdFx0XHRcdFx0IHdoaWNoIGNhbiBoYXBwZW4gd2hlbiB0aGUgZWxlbWVudCBoYXNuJ3QgYmVlbiBwYWludGVkLiAqL1xuXHRcdFx0XHRcdFx0aWYgKGNvbXB1dGVkVmFsdWUgPT09IFwiXCIgfHwgY29tcHV0ZWRWYWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRjb21wdXRlZFZhbHVlID0gZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV07XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldmVydERpc3BsYXkoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBGb3IgdG9wLCByaWdodCwgYm90dG9tLCBhbmQgbGVmdCAoVFJCTCkgdmFsdWVzIHRoYXQgYXJlIHNldCB0byBcImF1dG9cIiBvbiBlbGVtZW50cyBvZiBcImZpeGVkXCIgb3IgXCJhYnNvbHV0ZVwiIHBvc2l0aW9uLFxuXHRcdFx0XHRcdCBkZWZlciB0byBqUXVlcnkgZm9yIGNvbnZlcnRpbmcgXCJhdXRvXCIgdG8gYSBudW1lcmljIHZhbHVlLiAoRm9yIGVsZW1lbnRzIHdpdGggYSBcInN0YXRpY1wiIG9yIFwicmVsYXRpdmVcIiBwb3NpdGlvbiwgXCJhdXRvXCIgaGFzIHRoZSBzYW1lXG5cdFx0XHRcdFx0IGVmZmVjdCBhcyBiZWluZyBzZXQgdG8gMCwgc28gbm8gY29udmVyc2lvbiBpcyBuZWNlc3NhcnkuKSAqL1xuXHRcdFx0XHRcdC8qIEFuIGV4YW1wbGUgb2Ygd2h5IG51bWVyaWMgY29udmVyc2lvbiBpcyBuZWNlc3Nhcnk6IFdoZW4gYW4gZWxlbWVudCB3aXRoIFwicG9zaXRpb246YWJzb2x1dGVcIiBoYXMgYW4gdW50b3VjaGVkIFwibGVmdFwiXG5cdFx0XHRcdFx0IHByb3BlcnR5LCB3aGljaCByZXZlcnRzIHRvIFwiYXV0b1wiLCBsZWZ0J3MgdmFsdWUgaXMgMCByZWxhdGl2ZSB0byBpdHMgcGFyZW50IGVsZW1lbnQsIGJ1dCBpcyBvZnRlbiBub24temVybyByZWxhdGl2ZVxuXHRcdFx0XHRcdCB0byBpdHMgKmNvbnRhaW5pbmcqIChub3QgcGFyZW50KSBlbGVtZW50LCB3aGljaCBpcyB0aGUgbmVhcmVzdCBcInBvc2l0aW9uOnJlbGF0aXZlXCIgYW5jZXN0b3Igb3IgdGhlIHZpZXdwb3J0IChhbmQgYWx3YXlzIHRoZSB2aWV3cG9ydCBpbiB0aGUgY2FzZSBvZiBcInBvc2l0aW9uOmZpeGVkXCIpLiAqL1xuXHRcdFx0XHRcdGlmIChjb21wdXRlZFZhbHVlID09PSBcImF1dG9cIiAmJiAvXih0b3B8cmlnaHR8Ym90dG9tfGxlZnQpJC9pLnRlc3QocHJvcGVydHkpKSB7XG5cdFx0XHRcdFx0XHR2YXIgcG9zaXRpb24gPSBjb21wdXRlUHJvcGVydHlWYWx1ZShlbGVtZW50LCBcInBvc2l0aW9uXCIpOyAvKiBHRVQgKi9cblxuXHRcdFx0XHRcdFx0LyogRm9yIGFic29sdXRlIHBvc2l0aW9uaW5nLCBqUXVlcnkncyAkLnBvc2l0aW9uKCkgb25seSByZXR1cm5zIHZhbHVlcyBmb3IgdG9wIGFuZCBsZWZ0O1xuXHRcdFx0XHRcdFx0IHJpZ2h0IGFuZCBib3R0b20gd2lsbCBoYXZlIHRoZWlyIFwiYXV0b1wiIHZhbHVlIHJldmVydGVkIHRvIDAuICovXG5cdFx0XHRcdFx0XHQvKiBOb3RlOiBBIGpRdWVyeSBvYmplY3QgbXVzdCBiZSBjcmVhdGVkIGhlcmUgc2luY2UgalF1ZXJ5IGRvZXNuJ3QgaGF2ZSBhIGxvdy1sZXZlbCBhbGlhcyBmb3IgJC5wb3NpdGlvbigpLlxuXHRcdFx0XHRcdFx0IE5vdCBhIGJpZyBkZWFsIHNpbmNlIHdlJ3JlIGN1cnJlbnRseSBpbiBhIEdFVCBiYXRjaCBhbnl3YXkuICovXG5cdFx0XHRcdFx0XHRpZiAocG9zaXRpb24gPT09IFwiZml4ZWRcIiB8fCAocG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiAmJiAvdG9wfGxlZnQvaS50ZXN0KHByb3BlcnR5KSkpIHtcblx0XHRcdFx0XHRcdFx0LyogTm90ZTogalF1ZXJ5IHN0cmlwcyB0aGUgcGl4ZWwgdW5pdCBmcm9tIGl0cyByZXR1cm5lZCB2YWx1ZXM7IHdlIHJlLWFkZCBpdCBoZXJlIHRvIGNvbmZvcm0gd2l0aCBjb21wdXRlUHJvcGVydHlWYWx1ZSdzIGJlaGF2aW9yLiAqL1xuXHRcdFx0XHRcdFx0XHRjb21wdXRlZFZhbHVlID0gJChlbGVtZW50KS5wb3NpdGlvbigpW3Byb3BlcnR5XSArIFwicHhcIjsgLyogR0VUICovXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGNvbXB1dGVkVmFsdWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcHJvcGVydHlWYWx1ZTtcblxuXHRcdFx0XHQvKiBJZiB0aGlzIGlzIGEgaG9va2VkIHByb3BlcnR5IChlLmcuIFwiY2xpcExlZnRcIiBpbnN0ZWFkIG9mIHRoZSByb290IHByb3BlcnR5IG9mIFwiY2xpcFwiKSxcblx0XHRcdFx0IGV4dHJhY3QgdGhlIGhvb2sncyB2YWx1ZSBmcm9tIGEgbm9ybWFsaXplZCByb290UHJvcGVydHlWYWx1ZSB1c2luZyBDU1MuSG9va3MuZXh0cmFjdFZhbHVlKCkuICovXG5cdFx0XHRcdGlmIChDU1MuSG9va3MucmVnaXN0ZXJlZFtwcm9wZXJ0eV0pIHtcblx0XHRcdFx0XHR2YXIgaG9vayA9IHByb3BlcnR5LFxuXHRcdFx0XHRcdFx0XHRob29rUm9vdCA9IENTUy5Ib29rcy5nZXRSb290KGhvb2spO1xuXG5cdFx0XHRcdFx0LyogSWYgYSBjYWNoZWQgcm9vdFByb3BlcnR5VmFsdWUgd2Fzbid0IHBhc3NlZCBpbiAod2hpY2ggVmVsb2NpdHkgYWx3YXlzIGF0dGVtcHRzIHRvIGRvIGluIG9yZGVyIHRvIGF2b2lkIHJlcXVlcnlpbmcgdGhlIERPTSksXG5cdFx0XHRcdFx0IHF1ZXJ5IHRoZSBET00gZm9yIHRoZSByb290IHByb3BlcnR5J3MgdmFsdWUuICovXG5cdFx0XHRcdFx0aWYgKHJvb3RQcm9wZXJ0eVZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdC8qIFNpbmNlIHRoZSBicm93c2VyIGlzIG5vdyBiZWluZyBkaXJlY3RseSBxdWVyaWVkLCB1c2UgdGhlIG9mZmljaWFsIHBvc3QtcHJlZml4aW5nIHByb3BlcnR5IG5hbWUgZm9yIHRoaXMgbG9va3VwLiAqL1xuXHRcdFx0XHRcdFx0cm9vdFByb3BlcnR5VmFsdWUgPSBDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBDU1MuTmFtZXMucHJlZml4Q2hlY2soaG9va1Jvb3QpWzBdKTsgLyogR0VUICovXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogSWYgdGhpcyByb290IGhhcyBhIG5vcm1hbGl6YXRpb24gcmVnaXN0ZXJlZCwgcGVmb3JtIHRoZSBhc3NvY2lhdGVkIG5vcm1hbGl6YXRpb24gZXh0cmFjdGlvbi4gKi9cblx0XHRcdFx0XHRpZiAoQ1NTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbaG9va1Jvb3RdKSB7XG5cdFx0XHRcdFx0XHRyb290UHJvcGVydHlWYWx1ZSA9IENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW2hvb2tSb290XShcImV4dHJhY3RcIiwgZWxlbWVudCwgcm9vdFByb3BlcnR5VmFsdWUpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIEV4dHJhY3QgdGhlIGhvb2sncyB2YWx1ZS4gKi9cblx0XHRcdFx0XHRwcm9wZXJ0eVZhbHVlID0gQ1NTLkhvb2tzLmV4dHJhY3RWYWx1ZShob29rLCByb290UHJvcGVydHlWYWx1ZSk7XG5cblx0XHRcdFx0XHQvKiBJZiB0aGlzIGlzIGEgbm9ybWFsaXplZCBwcm9wZXJ0eSAoZS5nLiBcIm9wYWNpdHlcIiBiZWNvbWVzIFwiZmlsdGVyXCIgaW4gPD1JRTgpIG9yIFwidHJhbnNsYXRlWFwiIGJlY29tZXMgXCJ0cmFuc2Zvcm1cIiksXG5cdFx0XHRcdFx0IG5vcm1hbGl6ZSB0aGUgcHJvcGVydHkncyBuYW1lIGFuZCB2YWx1ZSwgYW5kIGhhbmRsZSB0aGUgc3BlY2lhbCBjYXNlIG9mIHRyYW5zZm9ybXMuICovXG5cdFx0XHRcdFx0LyogTm90ZTogTm9ybWFsaXppbmcgYSBwcm9wZXJ0eSBpcyBtdXR1YWxseSBleGNsdXNpdmUgZnJvbSBob29raW5nIGEgcHJvcGVydHkgc2luY2UgaG9vay1leHRyYWN0ZWQgdmFsdWVzIGFyZSBzdHJpY3RseVxuXHRcdFx0XHRcdCBudW1lcmljYWwgYW5kIHRoZXJlZm9yZSBkbyBub3QgcmVxdWlyZSBub3JtYWxpemF0aW9uIGV4dHJhY3Rpb24uICovXG5cdFx0XHRcdH0gZWxzZSBpZiAoQ1NTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbcHJvcGVydHldKSB7XG5cdFx0XHRcdFx0dmFyIG5vcm1hbGl6ZWRQcm9wZXJ0eU5hbWUsXG5cdFx0XHRcdFx0XHRcdG5vcm1hbGl6ZWRQcm9wZXJ0eVZhbHVlO1xuXG5cdFx0XHRcdFx0bm9ybWFsaXplZFByb3BlcnR5TmFtZSA9IENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW3Byb3BlcnR5XShcIm5hbWVcIiwgZWxlbWVudCk7XG5cblx0XHRcdFx0XHQvKiBUcmFuc2Zvcm0gdmFsdWVzIGFyZSBjYWxjdWxhdGVkIHZpYSBub3JtYWxpemF0aW9uIGV4dHJhY3Rpb24gKHNlZSBiZWxvdyksIHdoaWNoIGNoZWNrcyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgdHJhbnNmb3JtQ2FjaGUuXG5cdFx0XHRcdFx0IEF0IG5vIHBvaW50IGRvIHRyYW5zZm9ybSBHRVRzIGV2ZXIgYWN0dWFsbHkgcXVlcnkgdGhlIERPTTsgaW5pdGlhbCBzdHlsZXNoZWV0IHZhbHVlcyBhcmUgbmV2ZXIgcHJvY2Vzc2VkLlxuXHRcdFx0XHRcdCBUaGlzIGlzIGJlY2F1c2UgcGFyc2luZyAzRCB0cmFuc2Zvcm0gbWF0cmljZXMgaXMgbm90IGFsd2F5cyBhY2N1cmF0ZSBhbmQgd291bGQgYmxvYXQgb3VyIGNvZGViYXNlO1xuXHRcdFx0XHRcdCB0aHVzLCBub3JtYWxpemF0aW9uIGV4dHJhY3Rpb24gZGVmYXVsdHMgaW5pdGlhbCB0cmFuc2Zvcm0gdmFsdWVzIHRvIHRoZWlyIHplcm8tdmFsdWVzIChlLmcuIDEgZm9yIHNjYWxlWCBhbmQgMCBmb3IgdHJhbnNsYXRlWCkuICovXG5cdFx0XHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wZXJ0eU5hbWUgIT09IFwidHJhbnNmb3JtXCIpIHtcblx0XHRcdFx0XHRcdG5vcm1hbGl6ZWRQcm9wZXJ0eVZhbHVlID0gY29tcHV0ZVByb3BlcnR5VmFsdWUoZWxlbWVudCwgQ1NTLk5hbWVzLnByZWZpeENoZWNrKG5vcm1hbGl6ZWRQcm9wZXJ0eU5hbWUpWzBdKTsgLyogR0VUICovXG5cblx0XHRcdFx0XHRcdC8qIElmIHRoZSB2YWx1ZSBpcyBhIENTUyBudWxsLXZhbHVlIGFuZCB0aGlzIHByb3BlcnR5IGhhcyBhIGhvb2sgdGVtcGxhdGUsIHVzZSB0aGF0IHplcm8tdmFsdWUgdGVtcGxhdGUgc28gdGhhdCBob29rcyBjYW4gYmUgZXh0cmFjdGVkIGZyb20gaXQuICovXG5cdFx0XHRcdFx0XHRpZiAoQ1NTLlZhbHVlcy5pc0NTU051bGxWYWx1ZShub3JtYWxpemVkUHJvcGVydHlWYWx1ZSkgJiYgQ1NTLkhvb2tzLnRlbXBsYXRlc1twcm9wZXJ0eV0pIHtcblx0XHRcdFx0XHRcdFx0bm9ybWFsaXplZFByb3BlcnR5VmFsdWUgPSBDU1MuSG9va3MudGVtcGxhdGVzW3Byb3BlcnR5XVsxXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRwcm9wZXJ0eVZhbHVlID0gQ1NTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbcHJvcGVydHldKFwiZXh0cmFjdFwiLCBlbGVtZW50LCBub3JtYWxpemVkUHJvcGVydHlWYWx1ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBJZiBhIChudW1lcmljKSB2YWx1ZSB3YXNuJ3QgcHJvZHVjZWQgdmlhIGhvb2sgZXh0cmFjdGlvbiBvciBub3JtYWxpemF0aW9uLCBxdWVyeSB0aGUgRE9NLiAqL1xuXHRcdFx0XHRpZiAoIS9eW1xcZC1dLy50ZXN0KHByb3BlcnR5VmFsdWUpKSB7XG5cdFx0XHRcdFx0LyogRm9yIFNWRyBlbGVtZW50cywgZGltZW5zaW9uYWwgcHJvcGVydGllcyAod2hpY2ggU1ZHQXR0cmlidXRlKCkgZGV0ZWN0cykgYXJlIHR3ZWVuZWQgdmlhXG5cdFx0XHRcdFx0IHRoZWlyIEhUTUwgYXR0cmlidXRlIHZhbHVlcyBpbnN0ZWFkIG9mIHRoZWlyIENTUyBzdHlsZSB2YWx1ZXMuICovXG5cdFx0XHRcdFx0dmFyIGRhdGEgPSBEYXRhKGVsZW1lbnQpO1xuXG5cdFx0XHRcdFx0aWYgKGRhdGEgJiYgZGF0YS5pc1NWRyAmJiBDU1MuTmFtZXMuU1ZHQXR0cmlidXRlKHByb3BlcnR5KSkge1xuXHRcdFx0XHRcdFx0LyogU2luY2UgdGhlIGhlaWdodC93aWR0aCBhdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgc2V0IG1hbnVhbGx5LCB0aGV5IGRvbid0IHJlZmxlY3QgY29tcHV0ZWQgdmFsdWVzLlxuXHRcdFx0XHRcdFx0IFRodXMsIHdlIHVzZSB1c2UgZ2V0QkJveCgpIHRvIGVuc3VyZSB3ZSBhbHdheXMgZ2V0IHZhbHVlcyBmb3IgZWxlbWVudHMgd2l0aCB1bmRlZmluZWQgaGVpZ2h0L3dpZHRoIGF0dHJpYnV0ZXMuICovXG5cdFx0XHRcdFx0XHRpZiAoL14oaGVpZ2h0fHdpZHRoKSQvaS50ZXN0KHByb3BlcnR5KSkge1xuXHRcdFx0XHRcdFx0XHQvKiBGaXJlZm94IHRocm93cyBhbiBlcnJvciBpZiAuZ2V0QkJveCgpIGlzIGNhbGxlZCBvbiBhbiBTVkcgdGhhdCBpc24ndCBhdHRhY2hlZCB0byB0aGUgRE9NLiAqL1xuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdHByb3BlcnR5VmFsdWUgPSBlbGVtZW50LmdldEJCb3goKVtwcm9wZXJ0eV07XG5cdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydHlWYWx1ZSA9IDA7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0LyogT3RoZXJ3aXNlLCBhY2Nlc3MgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBkaXJlY3RseS4gKi9cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5VmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShwcm9wZXJ0eSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHByb3BlcnR5VmFsdWUgPSBjb21wdXRlUHJvcGVydHlWYWx1ZShlbGVtZW50LCBDU1MuTmFtZXMucHJlZml4Q2hlY2socHJvcGVydHkpWzBdKTsgLyogR0VUICovXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyogU2luY2UgcHJvcGVydHkgbG9va3VwcyBhcmUgZm9yIGFuaW1hdGlvbiBwdXJwb3NlcyAod2hpY2ggZW50YWlscyBjb21wdXRpbmcgdGhlIG51bWVyaWMgZGVsdGEgYmV0d2VlbiBzdGFydCBhbmQgZW5kIHZhbHVlcyksXG5cdFx0XHRcdCBjb252ZXJ0IENTUyBudWxsLXZhbHVlcyB0byBhbiBpbnRlZ2VyIG9mIHZhbHVlIDAuICovXG5cdFx0XHRcdGlmIChDU1MuVmFsdWVzLmlzQ1NTTnVsbFZhbHVlKHByb3BlcnR5VmFsdWUpKSB7XG5cdFx0XHRcdFx0cHJvcGVydHlWYWx1ZSA9IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoVmVsb2NpdHkuZGVidWcgPj0gMikge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiR2V0IFwiICsgcHJvcGVydHkgKyBcIjogXCIgKyBwcm9wZXJ0eVZhbHVlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBwcm9wZXJ0eVZhbHVlO1xuXHRcdFx0fSxcblx0XHRcdC8qIFRoZSBzaW5ndWxhciBzZXRQcm9wZXJ0eVZhbHVlLCB3aGljaCByb3V0ZXMgdGhlIGxvZ2ljIGZvciBhbGwgbm9ybWFsaXphdGlvbnMsIGhvb2tzLCBhbmQgc3RhbmRhcmQgQ1NTIHByb3BlcnRpZXMuICovXG5cdFx0XHRzZXRQcm9wZXJ0eVZhbHVlOiBmdW5jdGlvbihlbGVtZW50LCBwcm9wZXJ0eSwgcHJvcGVydHlWYWx1ZSwgcm9vdFByb3BlcnR5VmFsdWUsIHNjcm9sbERhdGEpIHtcblx0XHRcdFx0dmFyIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5O1xuXG5cdFx0XHRcdC8qIEluIG9yZGVyIHRvIGJlIHN1YmplY3RlZCB0byBjYWxsIG9wdGlvbnMgYW5kIGVsZW1lbnQgcXVldWVpbmcsIHNjcm9sbCBhbmltYXRpb24gaXMgcm91dGVkIHRocm91Z2ggVmVsb2NpdHkgYXMgaWYgaXQgd2VyZSBhIHN0YW5kYXJkIENTUyBwcm9wZXJ0eS4gKi9cblx0XHRcdFx0aWYgKHByb3BlcnR5ID09PSBcInNjcm9sbFwiKSB7XG5cdFx0XHRcdFx0LyogSWYgYSBjb250YWluZXIgb3B0aW9uIGlzIHByZXNlbnQsIHNjcm9sbCB0aGUgY29udGFpbmVyIGluc3RlYWQgb2YgdGhlIGJyb3dzZXIgd2luZG93LiAqL1xuXHRcdFx0XHRcdGlmIChzY3JvbGxEYXRhLmNvbnRhaW5lcikge1xuXHRcdFx0XHRcdFx0c2Nyb2xsRGF0YS5jb250YWluZXJbXCJzY3JvbGxcIiArIHNjcm9sbERhdGEuZGlyZWN0aW9uXSA9IHByb3BlcnR5VmFsdWU7XG5cdFx0XHRcdFx0XHQvKiBPdGhlcndpc2UsIFZlbG9jaXR5IGRlZmF1bHRzIHRvIHNjcm9sbGluZyB0aGUgYnJvd3NlciB3aW5kb3cuICovXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChzY3JvbGxEYXRhLmRpcmVjdGlvbiA9PT0gXCJMZWZ0XCIpIHtcblx0XHRcdFx0XHRcdFx0d2luZG93LnNjcm9sbFRvKHByb3BlcnR5VmFsdWUsIHNjcm9sbERhdGEuYWx0ZXJuYXRlVmFsdWUpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0d2luZG93LnNjcm9sbFRvKHNjcm9sbERhdGEuYWx0ZXJuYXRlVmFsdWUsIHByb3BlcnR5VmFsdWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvKiBUcmFuc2Zvcm1zICh0cmFuc2xhdGVYLCByb3RhdGVaLCBldGMuKSBhcmUgYXBwbGllZCB0byBhIHBlci1lbGVtZW50IHRyYW5zZm9ybUNhY2hlIG9iamVjdCwgd2hpY2ggaXMgbWFudWFsbHkgZmx1c2hlZCB2aWEgZmx1c2hUcmFuc2Zvcm1DYWNoZSgpLlxuXHRcdFx0XHRcdCBUaHVzLCBmb3Igbm93LCB3ZSBtZXJlbHkgY2FjaGUgdHJhbnNmb3JtcyBiZWluZyBTRVQuICovXG5cdFx0XHRcdFx0aWYgKENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW3Byb3BlcnR5XSAmJiBDU1MuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtwcm9wZXJ0eV0oXCJuYW1lXCIsIGVsZW1lbnQpID09PSBcInRyYW5zZm9ybVwiKSB7XG5cdFx0XHRcdFx0XHQvKiBQZXJmb3JtIGEgbm9ybWFsaXphdGlvbiBpbmplY3Rpb24uICovXG5cdFx0XHRcdFx0XHQvKiBOb3RlOiBUaGUgbm9ybWFsaXphdGlvbiBsb2dpYyBoYW5kbGVzIHRoZSB0cmFuc2Zvcm1DYWNoZSB1cGRhdGluZy4gKi9cblx0XHRcdFx0XHRcdENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW3Byb3BlcnR5XShcImluamVjdFwiLCBlbGVtZW50LCBwcm9wZXJ0eVZhbHVlKTtcblxuXHRcdFx0XHRcdFx0cHJvcGVydHlOYW1lID0gXCJ0cmFuc2Zvcm1cIjtcblx0XHRcdFx0XHRcdHByb3BlcnR5VmFsdWUgPSBEYXRhKGVsZW1lbnQpLnRyYW5zZm9ybUNhY2hlW3Byb3BlcnR5XTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0LyogSW5qZWN0IGhvb2tzLiAqL1xuXHRcdFx0XHRcdFx0aWYgKENTUy5Ib29rcy5yZWdpc3RlcmVkW3Byb3BlcnR5XSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgaG9va05hbWUgPSBwcm9wZXJ0eSxcblx0XHRcdFx0XHRcdFx0XHRcdGhvb2tSb290ID0gQ1NTLkhvb2tzLmdldFJvb3QocHJvcGVydHkpO1xuXG5cdFx0XHRcdFx0XHRcdC8qIElmIGEgY2FjaGVkIHJvb3RQcm9wZXJ0eVZhbHVlIHdhcyBub3QgcHJvdmlkZWQsIHF1ZXJ5IHRoZSBET00gZm9yIHRoZSBob29rUm9vdCdzIGN1cnJlbnQgdmFsdWUuICovXG5cdFx0XHRcdFx0XHRcdHJvb3RQcm9wZXJ0eVZhbHVlID0gcm9vdFByb3BlcnR5VmFsdWUgfHwgQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgaG9va1Jvb3QpOyAvKiBHRVQgKi9cblxuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eVZhbHVlID0gQ1NTLkhvb2tzLmluamVjdFZhbHVlKGhvb2tOYW1lLCBwcm9wZXJ0eVZhbHVlLCByb290UHJvcGVydHlWYWx1ZSk7XG5cdFx0XHRcdFx0XHRcdHByb3BlcnR5ID0gaG9va1Jvb3Q7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIE5vcm1hbGl6ZSBuYW1lcyBhbmQgdmFsdWVzLiAqL1xuXHRcdFx0XHRcdFx0aWYgKENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW3Byb3BlcnR5XSkge1xuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eVZhbHVlID0gQ1NTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbcHJvcGVydHldKFwiaW5qZWN0XCIsIGVsZW1lbnQsIHByb3BlcnR5VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eSA9IENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcmVkW3Byb3BlcnR5XShcIm5hbWVcIiwgZWxlbWVudCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIEFzc2lnbiB0aGUgYXBwcm9wcmlhdGUgdmVuZG9yIHByZWZpeCBiZWZvcmUgcGVyZm9ybWluZyBhbiBvZmZpY2lhbCBzdHlsZSB1cGRhdGUuICovXG5cdFx0XHRcdFx0XHRwcm9wZXJ0eU5hbWUgPSBDU1MuTmFtZXMucHJlZml4Q2hlY2socHJvcGVydHkpWzBdO1xuXG5cdFx0XHRcdFx0XHQvKiBBIHRyeS9jYXRjaCBpcyB1c2VkIGZvciBJRTw9OCwgd2hpY2ggdGhyb3dzIGFuIGVycm9yIHdoZW4gXCJpbnZhbGlkXCIgQ1NTIHZhbHVlcyBhcmUgc2V0LCBlLmcuIGEgbmVnYXRpdmUgd2lkdGguXG5cdFx0XHRcdFx0XHQgVHJ5L2NhdGNoIGlzIGF2b2lkZWQgZm9yIG90aGVyIGJyb3dzZXJzIHNpbmNlIGl0IGluY3VycyBhIHBlcmZvcm1hbmNlIG92ZXJoZWFkLiAqL1xuXHRcdFx0XHRcdFx0aWYgKElFIDw9IDgpIHtcblx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRlbGVtZW50LnN0eWxlW3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0eVZhbHVlO1xuXHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChWZWxvY2l0eS5kZWJ1Zykge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgW1wiICsgcHJvcGVydHlWYWx1ZSArIFwiXSBmb3IgW1wiICsgcHJvcGVydHlOYW1lICsgXCJdXCIpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQvKiBTVkcgZWxlbWVudHMgaGF2ZSB0aGVpciBkaW1lbnNpb25hbCBwcm9wZXJ0aWVzICh3aWR0aCwgaGVpZ2h0LCB4LCB5LCBjeCwgZXRjLikgYXBwbGllZCBkaXJlY3RseSBhcyBhdHRyaWJ1dGVzIGluc3RlYWQgb2YgYXMgc3R5bGVzLiAqL1xuXHRcdFx0XHRcdFx0XHQvKiBOb3RlOiBJRTggZG9lcyBub3Qgc3VwcG9ydCBTVkcgZWxlbWVudHMsIHNvIGl0J3Mgb2theSB0aGF0IHdlIHNraXAgaXQgZm9yIFNWRyBhbmltYXRpb24uICovXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgZGF0YSA9IERhdGEoZWxlbWVudCk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKGRhdGEgJiYgZGF0YS5pc1NWRyAmJiBDU1MuTmFtZXMuU1ZHQXR0cmlidXRlKHByb3BlcnR5KSkge1xuXHRcdFx0XHRcdFx0XHRcdC8qIE5vdGU6IEZvciBTVkcgYXR0cmlidXRlcywgdmVuZG9yLXByZWZpeGVkIHByb3BlcnR5IG5hbWVzIGFyZSBuZXZlciB1c2VkLiAqL1xuXHRcdFx0XHRcdFx0XHRcdC8qIE5vdGU6IE5vdCBhbGwgQ1NTIHByb3BlcnRpZXMgY2FuIGJlIGFuaW1hdGVkIHZpYSBhdHRyaWJ1dGVzLCBidXQgdGhlIGJyb3dzZXIgd29uJ3QgdGhyb3cgYW4gZXJyb3IgZm9yIHVuc3VwcG9ydGVkIHByb3BlcnRpZXMuICovXG5cdFx0XHRcdFx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUocHJvcGVydHksIHByb3BlcnR5VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGVsZW1lbnQuc3R5bGVbcHJvcGVydHlOYW1lXSA9IHByb3BlcnR5VmFsdWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKFZlbG9jaXR5LmRlYnVnID49IDIpIHtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJTZXQgXCIgKyBwcm9wZXJ0eSArIFwiIChcIiArIHByb3BlcnR5TmFtZSArIFwiKTogXCIgKyBwcm9wZXJ0eVZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBSZXR1cm4gdGhlIG5vcm1hbGl6ZWQgcHJvcGVydHkgbmFtZSBhbmQgdmFsdWUgaW4gY2FzZSB0aGUgY2FsbGVyIHdhbnRzIHRvIGtub3cgaG93IHRoZXNlIHZhbHVlcyB3ZXJlIG1vZGlmaWVkIGJlZm9yZSBiZWluZyBhcHBsaWVkIHRvIHRoZSBET00uICovXG5cdFx0XHRcdHJldHVybiBbcHJvcGVydHlOYW1lLCBwcm9wZXJ0eVZhbHVlXTtcblx0XHRcdH0sXG5cdFx0XHQvKiBUbyBpbmNyZWFzZSBwZXJmb3JtYW5jZSBieSBiYXRjaGluZyB0cmFuc2Zvcm0gdXBkYXRlcyBpbnRvIGEgc2luZ2xlIFNFVCwgdHJhbnNmb3JtcyBhcmUgbm90IGRpcmVjdGx5IGFwcGxpZWQgdG8gYW4gZWxlbWVudCB1bnRpbCBmbHVzaFRyYW5zZm9ybUNhY2hlKCkgaXMgY2FsbGVkLiAqL1xuXHRcdFx0LyogTm90ZTogVmVsb2NpdHkgYXBwbGllcyB0cmFuc2Zvcm0gcHJvcGVydGllcyBpbiB0aGUgc2FtZSBvcmRlciB0aGF0IHRoZXkgYXJlIGNocm9ub2dpY2FsbHkgaW50cm9kdWNlZCB0byB0aGUgZWxlbWVudCdzIENTUyBzdHlsZXMuICovXG5cdFx0XHRmbHVzaFRyYW5zZm9ybUNhY2hlOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRcdHZhciB0cmFuc2Zvcm1TdHJpbmcgPSBcIlwiLFxuXHRcdFx0XHRcdFx0ZGF0YSA9IERhdGEoZWxlbWVudCk7XG5cblx0XHRcdFx0LyogQ2VydGFpbiBicm93c2VycyByZXF1aXJlIHRoYXQgU1ZHIHRyYW5zZm9ybXMgYmUgYXBwbGllZCBhcyBhbiBhdHRyaWJ1dGUuIEhvd2V2ZXIsIHRoZSBTVkcgdHJhbnNmb3JtIGF0dHJpYnV0ZSB0YWtlcyBhIG1vZGlmaWVkIHZlcnNpb24gb2YgQ1NTJ3MgdHJhbnNmb3JtIHN0cmluZ1xuXHRcdFx0XHQgKHVuaXRzIGFyZSBkcm9wcGVkIGFuZCwgZXhjZXB0IGZvciBza2V3WC9ZLCBzdWJwcm9wZXJ0aWVzIGFyZSBtZXJnZWQgaW50byB0aGVpciBtYXN0ZXIgcHJvcGVydHkgLS0gZS5nLiBzY2FsZVggYW5kIHNjYWxlWSBhcmUgbWVyZ2VkIGludG8gc2NhbGUoWCBZKS4gKi9cblx0XHRcdFx0aWYgKChJRSB8fCAoVmVsb2NpdHkuU3RhdGUuaXNBbmRyb2lkICYmICFWZWxvY2l0eS5TdGF0ZS5pc0Nocm9tZSkpICYmIGRhdGEgJiYgZGF0YS5pc1NWRykge1xuXHRcdFx0XHRcdC8qIFNpbmNlIHRyYW5zZm9ybSB2YWx1ZXMgYXJlIHN0b3JlZCBpbiB0aGVpciBwYXJlbnRoZXNlcy13cmFwcGVkIGZvcm0sIHdlIHVzZSBhIGhlbHBlciBmdW5jdGlvbiB0byBzdHJpcCBvdXQgdGhlaXIgbnVtZXJpYyB2YWx1ZXMuXG5cdFx0XHRcdFx0IEZ1cnRoZXIsIFNWRyB0cmFuc2Zvcm0gcHJvcGVydGllcyBvbmx5IHRha2UgdW5pdGxlc3MgKHJlcHJlc2VudGluZyBwaXhlbHMpIHZhbHVlcywgc28gaXQncyBva2F5IHRoYXQgcGFyc2VGbG9hdCgpIHN0cmlwcyB0aGUgdW5pdCBzdWZmaXhlZCB0byB0aGUgZmxvYXQgdmFsdWUuICovXG5cdFx0XHRcdFx0dmFyIGdldFRyYW5zZm9ybUZsb2F0ID0gZnVuY3Rpb24odHJhbnNmb3JtUHJvcGVydHkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBwYXJzZUZsb2F0KENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIHRyYW5zZm9ybVByb3BlcnR5KSk7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdC8qIENyZWF0ZSBhbiBvYmplY3QgdG8gb3JnYW5pemUgYWxsIHRoZSB0cmFuc2Zvcm1zIHRoYXQgd2UnbGwgYXBwbHkgdG8gdGhlIFNWRyBlbGVtZW50LiBUbyBrZWVwIHRoZSBsb2dpYyBzaW1wbGUsXG5cdFx0XHRcdFx0IHdlIHByb2Nlc3MgKmFsbCogdHJhbnNmb3JtIHByb3BlcnRpZXMgLS0gZXZlbiB0aG9zZSB0aGF0IG1heSBub3QgYmUgZXhwbGljaXRseSBhcHBsaWVkIChzaW5jZSB0aGV5IGRlZmF1bHQgdG8gdGhlaXIgemVyby12YWx1ZXMgYW55d2F5KS4gKi9cblx0XHRcdFx0XHR2YXIgU1ZHVHJhbnNmb3JtcyA9IHtcblx0XHRcdFx0XHRcdHRyYW5zbGF0ZTogW2dldFRyYW5zZm9ybUZsb2F0KFwidHJhbnNsYXRlWFwiKSwgZ2V0VHJhbnNmb3JtRmxvYXQoXCJ0cmFuc2xhdGVZXCIpXSxcblx0XHRcdFx0XHRcdHNrZXdYOiBbZ2V0VHJhbnNmb3JtRmxvYXQoXCJza2V3WFwiKV0sIHNrZXdZOiBbZ2V0VHJhbnNmb3JtRmxvYXQoXCJza2V3WVwiKV0sXG5cdFx0XHRcdFx0XHQvKiBJZiB0aGUgc2NhbGUgcHJvcGVydHkgaXMgc2V0IChub24tMSksIHVzZSB0aGF0IHZhbHVlIGZvciB0aGUgc2NhbGVYIGFuZCBzY2FsZVkgdmFsdWVzXG5cdFx0XHRcdFx0XHQgKHRoaXMgYmVoYXZpb3IgbWltaWNzIHRoZSByZXN1bHQgb2YgYW5pbWF0aW5nIGFsbCB0aGVzZSBwcm9wZXJ0aWVzIGF0IG9uY2Ugb24gSFRNTCBlbGVtZW50cykuICovXG5cdFx0XHRcdFx0XHRzY2FsZTogZ2V0VHJhbnNmb3JtRmxvYXQoXCJzY2FsZVwiKSAhPT0gMSA/IFtnZXRUcmFuc2Zvcm1GbG9hdChcInNjYWxlXCIpLCBnZXRUcmFuc2Zvcm1GbG9hdChcInNjYWxlXCIpXSA6IFtnZXRUcmFuc2Zvcm1GbG9hdChcInNjYWxlWFwiKSwgZ2V0VHJhbnNmb3JtRmxvYXQoXCJzY2FsZVlcIildLFxuXHRcdFx0XHRcdFx0LyogTm90ZTogU1ZHJ3Mgcm90YXRlIHRyYW5zZm9ybSB0YWtlcyB0aHJlZSB2YWx1ZXM6IHJvdGF0aW9uIGRlZ3JlZXMgZm9sbG93ZWQgYnkgdGhlIFggYW5kIFkgdmFsdWVzXG5cdFx0XHRcdFx0XHQgZGVmaW5pbmcgdGhlIHJvdGF0aW9uJ3Mgb3JpZ2luIHBvaW50LiBXZSBpZ25vcmUgdGhlIG9yaWdpbiB2YWx1ZXMgKGRlZmF1bHQgdGhlbSB0byAwKS4gKi9cblx0XHRcdFx0XHRcdHJvdGF0ZTogW2dldFRyYW5zZm9ybUZsb2F0KFwicm90YXRlWlwiKSwgMCwgMF1cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0LyogSXRlcmF0ZSB0aHJvdWdoIHRoZSB0cmFuc2Zvcm0gcHJvcGVydGllcyBpbiB0aGUgdXNlci1kZWZpbmVkIHByb3BlcnR5IG1hcCBvcmRlci5cblx0XHRcdFx0XHQgKFRoaXMgbWltaWNzIHRoZSBiZWhhdmlvciBvZiBub24tU1ZHIHRyYW5zZm9ybSBhbmltYXRpb24uKSAqL1xuXHRcdFx0XHRcdCQuZWFjaChEYXRhKGVsZW1lbnQpLnRyYW5zZm9ybUNhY2hlLCBmdW5jdGlvbih0cmFuc2Zvcm1OYW1lKSB7XG5cdFx0XHRcdFx0XHQvKiBFeGNlcHQgZm9yIHdpdGggc2tld1gvWSwgcmV2ZXJ0IHRoZSBheGlzLXNwZWNpZmljIHRyYW5zZm9ybSBzdWJwcm9wZXJ0aWVzIHRvIHRoZWlyIGF4aXMtZnJlZSBtYXN0ZXJcblx0XHRcdFx0XHRcdCBwcm9wZXJ0aWVzIHNvIHRoYXQgdGhleSBtYXRjaCB1cCB3aXRoIFNWRydzIGFjY2VwdGVkIHRyYW5zZm9ybSBwcm9wZXJ0aWVzLiAqL1xuXHRcdFx0XHRcdFx0aWYgKC9edHJhbnNsYXRlL2kudGVzdCh0cmFuc2Zvcm1OYW1lKSkge1xuXHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm1OYW1lID0gXCJ0cmFuc2xhdGVcIjtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoL15zY2FsZS9pLnRlc3QodHJhbnNmb3JtTmFtZSkpIHtcblx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtTmFtZSA9IFwic2NhbGVcIjtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoL15yb3RhdGUvaS50ZXN0KHRyYW5zZm9ybU5hbWUpKSB7XG5cdFx0XHRcdFx0XHRcdHRyYW5zZm9ybU5hbWUgPSBcInJvdGF0ZVwiO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBDaGVjayB0aGF0IHdlIGhhdmVuJ3QgeWV0IGRlbGV0ZWQgdGhlIHByb3BlcnR5IGZyb20gdGhlIFNWR1RyYW5zZm9ybXMgY29udGFpbmVyLiAqL1xuXHRcdFx0XHRcdFx0aWYgKFNWR1RyYW5zZm9ybXNbdHJhbnNmb3JtTmFtZV0pIHtcblx0XHRcdFx0XHRcdFx0LyogQXBwZW5kIHRoZSB0cmFuc2Zvcm0gcHJvcGVydHkgaW4gdGhlIFNWRy1zdXBwb3J0ZWQgdHJhbnNmb3JtIGZvcm1hdC4gQXMgcGVyIHRoZSBzcGVjLCBzdXJyb3VuZCB0aGUgc3BhY2UtZGVsaW1pdGVkIHZhbHVlcyBpbiBwYXJlbnRoZXNlcy4gKi9cblx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtU3RyaW5nICs9IHRyYW5zZm9ybU5hbWUgKyBcIihcIiArIFNWR1RyYW5zZm9ybXNbdHJhbnNmb3JtTmFtZV0uam9pbihcIiBcIikgKyBcIilcIiArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRcdC8qIEFmdGVyIHByb2Nlc3NpbmcgYW4gU1ZHIHRyYW5zZm9ybSBwcm9wZXJ0eSwgZGVsZXRlIGl0IGZyb20gdGhlIFNWR1RyYW5zZm9ybXMgY29udGFpbmVyIHNvIHdlIGRvbid0XG5cdFx0XHRcdFx0XHRcdCByZS1pbnNlcnQgdGhlIHNhbWUgbWFzdGVyIHByb3BlcnR5IGlmIHdlIGVuY291bnRlciBhbm90aGVyIG9uZSBvZiBpdHMgYXhpcy1zcGVjaWZpYyBwcm9wZXJ0aWVzLiAqL1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgU1ZHVHJhbnNmb3Jtc1t0cmFuc2Zvcm1OYW1lXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgdHJhbnNmb3JtVmFsdWUsXG5cdFx0XHRcdFx0XHRcdHBlcnNwZWN0aXZlO1xuXG5cdFx0XHRcdFx0LyogVHJhbnNmb3JtIHByb3BlcnRpZXMgYXJlIHN0b3JlZCBhcyBtZW1iZXJzIG9mIHRoZSB0cmFuc2Zvcm1DYWNoZSBvYmplY3QuIENvbmNhdGVuYXRlIGFsbCB0aGUgbWVtYmVycyBpbnRvIGEgc3RyaW5nLiAqL1xuXHRcdFx0XHRcdCQuZWFjaChEYXRhKGVsZW1lbnQpLnRyYW5zZm9ybUNhY2hlLCBmdW5jdGlvbih0cmFuc2Zvcm1OYW1lKSB7XG5cdFx0XHRcdFx0XHR0cmFuc2Zvcm1WYWx1ZSA9IERhdGEoZWxlbWVudCkudHJhbnNmb3JtQ2FjaGVbdHJhbnNmb3JtTmFtZV07XG5cblx0XHRcdFx0XHRcdC8qIFRyYW5zZm9ybSdzIHBlcnNwZWN0aXZlIHN1YnByb3BlcnR5IG11c3QgYmUgc2V0IGZpcnN0IGluIG9yZGVyIHRvIHRha2UgZWZmZWN0LiBTdG9yZSBpdCB0ZW1wb3JhcmlseS4gKi9cblx0XHRcdFx0XHRcdGlmICh0cmFuc2Zvcm1OYW1lID09PSBcInRyYW5zZm9ybVBlcnNwZWN0aXZlXCIpIHtcblx0XHRcdFx0XHRcdFx0cGVyc3BlY3RpdmUgPSB0cmFuc2Zvcm1WYWx1ZTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIElFOSBvbmx5IHN1cHBvcnRzIG9uZSByb3RhdGlvbiB0eXBlLCByb3RhdGVaLCB3aGljaCBpdCByZWZlcnMgdG8gYXMgXCJyb3RhdGVcIi4gKi9cblx0XHRcdFx0XHRcdGlmIChJRSA9PT0gOSAmJiB0cmFuc2Zvcm1OYW1lID09PSBcInJvdGF0ZVpcIikge1xuXHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm1OYW1lID0gXCJyb3RhdGVcIjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dHJhbnNmb3JtU3RyaW5nICs9IHRyYW5zZm9ybU5hbWUgKyB0cmFuc2Zvcm1WYWx1ZSArIFwiIFwiO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0LyogSWYgcHJlc2VudCwgc2V0IHRoZSBwZXJzcGVjdGl2ZSBzdWJwcm9wZXJ0eSBmaXJzdC4gKi9cblx0XHRcdFx0XHRpZiAocGVyc3BlY3RpdmUpIHtcblx0XHRcdFx0XHRcdHRyYW5zZm9ybVN0cmluZyA9IFwicGVyc3BlY3RpdmVcIiArIHBlcnNwZWN0aXZlICsgXCIgXCIgKyB0cmFuc2Zvcm1TdHJpbmc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Q1NTLnNldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtU3RyaW5nKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0LyogUmVnaXN0ZXIgaG9va3MgYW5kIG5vcm1hbGl6YXRpb25zLiAqL1xuXHRcdENTUy5Ib29rcy5yZWdpc3RlcigpO1xuXHRcdENTUy5Ob3JtYWxpemF0aW9ucy5yZWdpc3RlcigpO1xuXG5cdFx0LyogQWxsb3cgaG9vayBzZXR0aW5nIGluIHRoZSBzYW1lIGZhc2hpb24gYXMgalF1ZXJ5J3MgJC5jc3MoKS4gKi9cblx0XHRWZWxvY2l0eS5ob29rID0gZnVuY3Rpb24oZWxlbWVudHMsIGFyZzIsIGFyZzMpIHtcblx0XHRcdHZhciB2YWx1ZTtcblxuXHRcdFx0ZWxlbWVudHMgPSBzYW5pdGl6ZUVsZW1lbnRzKGVsZW1lbnRzKTtcblxuXHRcdFx0JC5lYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihpLCBlbGVtZW50KSB7XG5cdFx0XHRcdC8qIEluaXRpYWxpemUgVmVsb2NpdHkncyBwZXItZWxlbWVudCBkYXRhIGNhY2hlIGlmIHRoaXMgZWxlbWVudCBoYXNuJ3QgcHJldmlvdXNseSBiZWVuIGFuaW1hdGVkLiAqL1xuXHRcdFx0XHRpZiAoRGF0YShlbGVtZW50KSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0VmVsb2NpdHkuaW5pdChlbGVtZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qIEdldCBwcm9wZXJ0eSB2YWx1ZS4gSWYgYW4gZWxlbWVudCBzZXQgd2FzIHBhc3NlZCBpbiwgb25seSByZXR1cm4gdGhlIHZhbHVlIGZvciB0aGUgZmlyc3QgZWxlbWVudC4gKi9cblx0XHRcdFx0aWYgKGFyZzMgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIGFyZzIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvKiBTZXQgcHJvcGVydHkgdmFsdWUuICovXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Lyogc1BWIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIG5vcm1hbGl6ZWQgcHJvcGVydHlOYW1lL3Byb3BlcnR5VmFsdWUgcGFpciB1c2VkIHRvIHVwZGF0ZSB0aGUgRE9NLiAqL1xuXHRcdFx0XHRcdHZhciBhZGp1c3RlZFNldCA9IENTUy5zZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIGFyZzIsIGFyZzMpO1xuXG5cdFx0XHRcdFx0LyogVHJhbnNmb3JtIHByb3BlcnRpZXMgZG9uJ3QgYXV0b21hdGljYWxseSBzZXQuIFRoZXkgaGF2ZSB0byBiZSBmbHVzaGVkIHRvIHRoZSBET00uICovXG5cdFx0XHRcdFx0aWYgKGFkanVzdGVkU2V0WzBdID09PSBcInRyYW5zZm9ybVwiKSB7XG5cdFx0XHRcdFx0XHRWZWxvY2l0eS5DU1MuZmx1c2hUcmFuc2Zvcm1DYWNoZShlbGVtZW50KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YWx1ZSA9IGFkanVzdGVkU2V0O1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH07XG5cblx0XHQvKioqKioqKioqKioqKioqKipcblx0XHQgQW5pbWF0aW9uXG5cdFx0ICoqKioqKioqKioqKioqKioqL1xuXG5cdFx0dmFyIGFuaW1hdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBvcHRzO1xuXG5cdFx0XHQvKioqKioqKioqKioqKioqKioqXG5cdFx0XHQgQ2FsbCBDaGFpblxuXHRcdFx0ICoqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0LyogTG9naWMgZm9yIGRldGVybWluaW5nIHdoYXQgdG8gcmV0dXJuIHRvIHRoZSBjYWxsIHN0YWNrIHdoZW4gZXhpdGluZyBvdXQgb2YgVmVsb2NpdHkuICovXG5cdFx0XHRmdW5jdGlvbiBnZXRDaGFpbigpIHtcblx0XHRcdFx0LyogSWYgd2UgYXJlIHVzaW5nIHRoZSB1dGlsaXR5IGZ1bmN0aW9uLCBhdHRlbXB0IHRvIHJldHVybiB0aGlzIGNhbGwncyBwcm9taXNlLiBJZiBubyBwcm9taXNlIGxpYnJhcnkgd2FzIGRldGVjdGVkLFxuXHRcdFx0XHQgZGVmYXVsdCB0byBudWxsIGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZSB0YXJnZXRlZCBlbGVtZW50cyBzbyB0aGF0IHV0aWxpdHkgZnVuY3Rpb24ncyByZXR1cm4gdmFsdWUgaXMgc3RhbmRhcmRpemVkLiAqL1xuXHRcdFx0XHRpZiAoaXNVdGlsaXR5KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2VEYXRhLnByb21pc2UgfHwgbnVsbDtcblx0XHRcdFx0XHQvKiBPdGhlcndpc2UsIGlmIHdlJ3JlIHVzaW5nICQuZm4sIHJldHVybiB0aGUgalF1ZXJ5LS9aZXB0by13cmFwcGVkIGVsZW1lbnQgc2V0LiAqL1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtZW50c1dyYXBwZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdCBBcmd1bWVudHMgQXNzaWdubWVudFxuXHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdC8qIFRvIGFsbG93IGZvciBleHByZXNzaXZlIENvZmZlZVNjcmlwdCBjb2RlLCBWZWxvY2l0eSBzdXBwb3J0cyBhbiBhbHRlcm5hdGl2ZSBzeW50YXggaW4gd2hpY2ggXCJlbGVtZW50c1wiIChvciBcImVcIiksIFwicHJvcGVydGllc1wiIChvciBcInBcIiksIGFuZCBcIm9wdGlvbnNcIiAob3IgXCJvXCIpXG5cdFx0XHQgb2JqZWN0cyBhcmUgZGVmaW5lZCBvbiBhIGNvbnRhaW5lciBvYmplY3QgdGhhdCdzIHBhc3NlZCBpbiBhcyBWZWxvY2l0eSdzIHNvbGUgYXJndW1lbnQuICovXG5cdFx0XHQvKiBOb3RlOiBTb21lIGJyb3dzZXJzIGF1dG9tYXRpY2FsbHkgcG9wdWxhdGUgYXJndW1lbnRzIHdpdGggYSBcInByb3BlcnRpZXNcIiBvYmplY3QuIFdlIGRldGVjdCBpdCBieSBjaGVja2luZyBmb3IgaXRzIGRlZmF1bHQgXCJuYW1lc1wiIHByb3BlcnR5LiAqL1xuXHRcdFx0dmFyIHN5bnRhY3RpY1N1Z2FyID0gKGFyZ3VtZW50c1swXSAmJiAoYXJndW1lbnRzWzBdLnAgfHwgKCgkLmlzUGxhaW5PYmplY3QoYXJndW1lbnRzWzBdLnByb3BlcnRpZXMpICYmICFhcmd1bWVudHNbMF0ucHJvcGVydGllcy5uYW1lcykgfHwgVHlwZS5pc1N0cmluZyhhcmd1bWVudHNbMF0ucHJvcGVydGllcykpKSksXG5cdFx0XHRcdFx0LyogV2hldGhlciBWZWxvY2l0eSB3YXMgY2FsbGVkIHZpYSB0aGUgdXRpbGl0eSBmdW5jdGlvbiAoYXMgb3Bwb3NlZCB0byBvbiBhIGpRdWVyeS9aZXB0byBvYmplY3QpLiAqL1xuXHRcdFx0XHRcdGlzVXRpbGl0eSxcblx0XHRcdFx0XHQvKiBXaGVuIFZlbG9jaXR5IGlzIGNhbGxlZCB2aWEgdGhlIHV0aWxpdHkgZnVuY3Rpb24gKCQuVmVsb2NpdHkoKS9WZWxvY2l0eSgpKSwgZWxlbWVudHMgYXJlIGV4cGxpY2l0bHlcblx0XHRcdFx0XHQgcGFzc2VkIGluIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIuIFRodXMsIGFyZ3VtZW50IHBvc2l0aW9uaW5nIHZhcmllcy4gV2Ugbm9ybWFsaXplIHRoZW0gaGVyZS4gKi9cblx0XHRcdFx0XHRlbGVtZW50c1dyYXBwZWQsXG5cdFx0XHRcdFx0YXJndW1lbnRJbmRleDtcblxuXHRcdFx0dmFyIGVsZW1lbnRzLFxuXHRcdFx0XHRcdHByb3BlcnRpZXNNYXAsXG5cdFx0XHRcdFx0b3B0aW9ucztcblxuXHRcdFx0LyogRGV0ZWN0IGpRdWVyeS9aZXB0byBlbGVtZW50cyBiZWluZyBhbmltYXRlZCB2aWEgdGhlICQuZm4gbWV0aG9kLiAqL1xuXHRcdFx0aWYgKFR5cGUuaXNXcmFwcGVkKHRoaXMpKSB7XG5cdFx0XHRcdGlzVXRpbGl0eSA9IGZhbHNlO1xuXG5cdFx0XHRcdGFyZ3VtZW50SW5kZXggPSAwO1xuXHRcdFx0XHRlbGVtZW50cyA9IHRoaXM7XG5cdFx0XHRcdGVsZW1lbnRzV3JhcHBlZCA9IHRoaXM7XG5cdFx0XHRcdC8qIE90aGVyd2lzZSwgcmF3IGVsZW1lbnRzIGFyZSBiZWluZyBhbmltYXRlZCB2aWEgdGhlIHV0aWxpdHkgZnVuY3Rpb24uICovXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpc1V0aWxpdHkgPSB0cnVlO1xuXG5cdFx0XHRcdGFyZ3VtZW50SW5kZXggPSAxO1xuXHRcdFx0XHRlbGVtZW50cyA9IHN5bnRhY3RpY1N1Z2FyID8gKGFyZ3VtZW50c1swXS5lbGVtZW50cyB8fCBhcmd1bWVudHNbMF0uZSkgOiBhcmd1bWVudHNbMF07XG5cdFx0XHR9XG5cblx0XHRcdC8qKioqKioqKioqKioqKipcblx0XHRcdCBQcm9taXNlc1xuXHRcdFx0ICoqKioqKioqKioqKioqKi9cblxuXHRcdFx0dmFyIHByb21pc2VEYXRhID0ge1xuXHRcdFx0XHRwcm9taXNlOiBudWxsLFxuXHRcdFx0XHRyZXNvbHZlcjogbnVsbCxcblx0XHRcdFx0cmVqZWN0ZXI6IG51bGxcblx0XHRcdH07XG5cblx0XHRcdC8qIElmIHRoaXMgY2FsbCB3YXMgbWFkZSB2aWEgdGhlIHV0aWxpdHkgZnVuY3Rpb24gKHdoaWNoIGlzIHRoZSBkZWZhdWx0IG1ldGhvZCBvZiBpbnZvY2F0aW9uIHdoZW4galF1ZXJ5L1plcHRvIGFyZSBub3QgYmVpbmcgdXNlZCksIGFuZCBpZlxuXHRcdFx0IHByb21pc2Ugc3VwcG9ydCB3YXMgZGV0ZWN0ZWQsIGNyZWF0ZSBhIHByb21pc2Ugb2JqZWN0IGZvciB0aGlzIGNhbGwgYW5kIHN0b3JlIHJlZmVyZW5jZXMgdG8gaXRzIHJlc29sdmVyIGFuZCByZWplY3RlciBtZXRob2RzLiBUaGUgcmVzb2x2ZVxuXHRcdFx0IG1ldGhvZCBpcyB1c2VkIHdoZW4gYSBjYWxsIGNvbXBsZXRlcyBuYXR1cmFsbHkgb3IgaXMgcHJlbWF0dXJlbHkgc3RvcHBlZCBieSB0aGUgdXNlci4gSW4gYm90aCBjYXNlcywgY29tcGxldGVDYWxsKCkgaGFuZGxlcyB0aGUgYXNzb2NpYXRlZFxuXHRcdFx0IGNhbGwgY2xlYW51cCBhbmQgcHJvbWlzZSByZXNvbHZpbmcgbG9naWMuIFRoZSByZWplY3QgbWV0aG9kIGlzIHVzZWQgd2hlbiBhbiBpbnZhbGlkIHNldCBvZiBhcmd1bWVudHMgaXMgcGFzc2VkIGludG8gYSBWZWxvY2l0eSBjYWxsLiAqL1xuXHRcdFx0LyogTm90ZTogVmVsb2NpdHkgZW1wbG95cyBhIGNhbGwtYmFzZWQgcXVldWVpbmcgYXJjaGl0ZWN0dXJlLCB3aGljaCBtZWFucyB0aGF0IHN0b3BwaW5nIGFuIGFuaW1hdGluZyBlbGVtZW50IGFjdHVhbGx5IHN0b3BzIHRoZSBmdWxsIGNhbGwgdGhhdFxuXHRcdFx0IHRyaWdnZXJlZCBpdCAtLSBub3QgdGhhdCBvbmUgZWxlbWVudCBleGNsdXNpdmVseS4gU2ltaWxhcmx5LCB0aGVyZSBpcyBvbmUgcHJvbWlzZSBwZXIgY2FsbCwgYW5kIGFsbCBlbGVtZW50cyB0YXJnZXRlZCBieSBhIFZlbG9jaXR5IGNhbGwgYXJlXG5cdFx0XHQgZ3JvdXBlZCB0b2dldGhlciBmb3IgdGhlIHB1cnBvc2VzIG9mIHJlc29sdmluZyBhbmQgcmVqZWN0aW5nIGEgcHJvbWlzZS4gKi9cblx0XHRcdGlmIChpc1V0aWxpdHkgJiYgVmVsb2NpdHkuUHJvbWlzZSkge1xuXHRcdFx0XHRwcm9taXNlRGF0YS5wcm9taXNlID0gbmV3IFZlbG9jaXR5LlByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRcdFx0cHJvbWlzZURhdGEucmVzb2x2ZXIgPSByZXNvbHZlO1xuXHRcdFx0XHRcdHByb21pc2VEYXRhLnJlamVjdGVyID0gcmVqZWN0O1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHN5bnRhY3RpY1N1Z2FyKSB7XG5cdFx0XHRcdHByb3BlcnRpZXNNYXAgPSBhcmd1bWVudHNbMF0ucHJvcGVydGllcyB8fCBhcmd1bWVudHNbMF0ucDtcblx0XHRcdFx0b3B0aW9ucyA9IGFyZ3VtZW50c1swXS5vcHRpb25zIHx8IGFyZ3VtZW50c1swXS5vO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHJvcGVydGllc01hcCA9IGFyZ3VtZW50c1thcmd1bWVudEluZGV4XTtcblx0XHRcdFx0b3B0aW9ucyA9IGFyZ3VtZW50c1thcmd1bWVudEluZGV4ICsgMV07XG5cdFx0XHR9XG5cblx0XHRcdGVsZW1lbnRzID0gc2FuaXRpemVFbGVtZW50cyhlbGVtZW50cyk7XG5cblx0XHRcdGlmICghZWxlbWVudHMpIHtcblx0XHRcdFx0aWYgKHByb21pc2VEYXRhLnByb21pc2UpIHtcblx0XHRcdFx0XHRpZiAoIXByb3BlcnRpZXNNYXAgfHwgIW9wdGlvbnMgfHwgb3B0aW9ucy5wcm9taXNlUmVqZWN0RW1wdHkgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRwcm9taXNlRGF0YS5yZWplY3RlcigpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwcm9taXNlRGF0YS5yZXNvbHZlcigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8qIFRoZSBsZW5ndGggb2YgdGhlIGVsZW1lbnQgc2V0IChpbiB0aGUgZm9ybSBvZiBhIG5vZGVMaXN0IG9yIGFuIGFycmF5IG9mIGVsZW1lbnRzKSBpcyBkZWZhdWx0ZWQgdG8gMSBpbiBjYXNlIGFcblx0XHRcdCBzaW5nbGUgcmF3IERPTSBlbGVtZW50IGlzIHBhc3NlZCBpbiAod2hpY2ggZG9lc24ndCBjb250YWluIGEgbGVuZ3RoIHByb3BlcnR5KS4gKi9cblx0XHRcdHZhciBlbGVtZW50c0xlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aCxcblx0XHRcdFx0XHRlbGVtZW50c0luZGV4ID0gMDtcblxuXHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0IEFyZ3VtZW50IE92ZXJsb2FkaW5nXG5cdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHQvKiBTdXBwb3J0IGlzIGluY2x1ZGVkIGZvciBqUXVlcnkncyBhcmd1bWVudCBvdmVybG9hZGluZzogJC5hbmltYXRlKHByb3BlcnR5TWFwIFssIGR1cmF0aW9uXSBbLCBlYXNpbmddIFssIGNvbXBsZXRlXSkuXG5cdFx0XHQgT3ZlcmxvYWRpbmcgaXMgZGV0ZWN0ZWQgYnkgY2hlY2tpbmcgZm9yIHRoZSBhYnNlbmNlIG9mIGFuIG9iamVjdCBiZWluZyBwYXNzZWQgaW50byBvcHRpb25zLiAqL1xuXHRcdFx0LyogTm90ZTogVGhlIHN0b3AvZmluaXNoL3BhdXNlL3Jlc3VtZSBhY3Rpb25zIGRvIG5vdCBhY2NlcHQgYW5pbWF0aW9uIG9wdGlvbnMsIGFuZCBhcmUgdGhlcmVmb3JlIGV4Y2x1ZGVkIGZyb20gdGhpcyBjaGVjay4gKi9cblx0XHRcdGlmICghL14oc3RvcHxmaW5pc2h8ZmluaXNoQWxsfHBhdXNlfHJlc3VtZSkkL2kudGVzdChwcm9wZXJ0aWVzTWFwKSAmJiAhJC5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG5cdFx0XHRcdC8qIFRoZSB1dGlsaXR5IGZ1bmN0aW9uIHNoaWZ0cyBhbGwgYXJndW1lbnRzIG9uZSBwb3NpdGlvbiB0byB0aGUgcmlnaHQsIHNvIHdlIGFkanVzdCBmb3IgdGhhdCBvZmZzZXQuICovXG5cdFx0XHRcdHZhciBzdGFydGluZ0FyZ3VtZW50UG9zaXRpb24gPSBhcmd1bWVudEluZGV4ICsgMTtcblxuXHRcdFx0XHRvcHRpb25zID0ge307XG5cblx0XHRcdFx0LyogSXRlcmF0ZSB0aHJvdWdoIGFsbCBvcHRpb25zIGFyZ3VtZW50cyAqL1xuXHRcdFx0XHRmb3IgKHZhciBpID0gc3RhcnRpbmdBcmd1bWVudFBvc2l0aW9uOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0LyogVHJlYXQgYSBudW1iZXIgYXMgYSBkdXJhdGlvbi4gUGFyc2UgaXQgb3V0LiAqL1xuXHRcdFx0XHRcdC8qIE5vdGU6IFRoZSBmb2xsb3dpbmcgUmVnRXggd2lsbCByZXR1cm4gdHJ1ZSBpZiBwYXNzZWQgYW4gYXJyYXkgd2l0aCBhIG51bWJlciBhcyBpdHMgZmlyc3QgaXRlbS5cblx0XHRcdFx0XHQgVGh1cywgYXJyYXlzIGFyZSBza2lwcGVkIGZyb20gdGhpcyBjaGVjay4gKi9cblx0XHRcdFx0XHRpZiAoIVR5cGUuaXNBcnJheShhcmd1bWVudHNbaV0pICYmICgvXihmYXN0fG5vcm1hbHxzbG93KSQvaS50ZXN0KGFyZ3VtZW50c1tpXSkgfHwgL15cXGQvLnRlc3QoYXJndW1lbnRzW2ldKSkpIHtcblx0XHRcdFx0XHRcdG9wdGlvbnMuZHVyYXRpb24gPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdFx0XHQvKiBUcmVhdCBzdHJpbmdzIGFuZCBhcnJheXMgYXMgZWFzaW5ncy4gKi9cblx0XHRcdFx0XHR9IGVsc2UgaWYgKFR5cGUuaXNTdHJpbmcoYXJndW1lbnRzW2ldKSB8fCBUeXBlLmlzQXJyYXkoYXJndW1lbnRzW2ldKSkge1xuXHRcdFx0XHRcdFx0b3B0aW9ucy5lYXNpbmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdFx0XHQvKiBUcmVhdCBhIGZ1bmN0aW9uIGFzIGEgY29tcGxldGUgY2FsbGJhY2suICovXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChUeXBlLmlzRnVuY3Rpb24oYXJndW1lbnRzW2ldKSkge1xuXHRcdFx0XHRcdFx0b3B0aW9ucy5jb21wbGV0ZSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0IEFjdGlvbiBEZXRlY3Rpb25cblx0XHRcdCAqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdC8qIFZlbG9jaXR5J3MgYmVoYXZpb3IgaXMgY2F0ZWdvcml6ZWQgaW50byBcImFjdGlvbnNcIjogRWxlbWVudHMgY2FuIGVpdGhlciBiZSBzcGVjaWFsbHkgc2Nyb2xsZWQgaW50byB2aWV3LFxuXHRcdFx0IG9yIHRoZXkgY2FuIGJlIHN0YXJ0ZWQsIHN0b3BwZWQsIHBhdXNlZCwgcmVzdW1lZCwgb3IgcmV2ZXJzZWQgLiBJZiBhIGxpdGVyYWwgb3IgcmVmZXJlbmNlZCBwcm9wZXJ0aWVzIG1hcCBpcyBwYXNzZWQgaW4gYXMgVmVsb2NpdHknc1xuXHRcdFx0IGZpcnN0IGFyZ3VtZW50LCB0aGUgYXNzb2NpYXRlZCBhY3Rpb24gaXMgXCJzdGFydFwiLiBBbHRlcm5hdGl2ZWx5LCBcInNjcm9sbFwiLCBcInJldmVyc2VcIiwgXCJwYXVzZVwiLCBcInJlc3VtZVwiIG9yIFwic3RvcFwiIGNhbiBiZSBwYXNzZWQgaW4gXG5cdFx0XHQgaW5zdGVhZCBvZiBhIHByb3BlcnRpZXMgbWFwLiAqL1xuXHRcdFx0dmFyIGFjdGlvbjtcblxuXHRcdFx0c3dpdGNoIChwcm9wZXJ0aWVzTWFwKSB7XG5cdFx0XHRcdGNhc2UgXCJzY3JvbGxcIjpcblx0XHRcdFx0XHRhY3Rpb24gPSBcInNjcm9sbFwiO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgXCJyZXZlcnNlXCI6XG5cdFx0XHRcdFx0YWN0aW9uID0gXCJyZXZlcnNlXCI7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBcInBhdXNlXCI6XG5cblx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdCBBY3Rpb246IFBhdXNlXG5cdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHR2YXIgY3VycmVudFRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG5cdFx0XHRcdFx0LyogSGFuZGxlIGRlbGF5IHRpbWVycyAqL1xuXHRcdFx0XHRcdCQuZWFjaChlbGVtZW50cywgZnVuY3Rpb24oaSwgZWxlbWVudCkge1xuXHRcdFx0XHRcdFx0cGF1c2VEZWxheU9uRWxlbWVudChlbGVtZW50LCBjdXJyZW50VGltZSk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHQvKiBQYXVzZSBhbmQgUmVzdW1lIGFyZSBjYWxsLXdpZGUgKG5vdCBvbiBhIHBlciBlbGVtZW50IGJhc2lzKS4gVGh1cywgY2FsbGluZyBwYXVzZSBvciByZXN1bWUgb24gYSBcblx0XHRcdFx0XHQgc2luZ2xlIGVsZW1lbnQgd2lsbCBjYXVzZSBhbnkgY2FsbHMgdGhhdCBjb250YWludCB0d2VlbnMgZm9yIHRoYXQgZWxlbWVudCB0byBiZSBwYXVzZWQvcmVzdW1lZFxuXHRcdFx0XHRcdCBhcyB3ZWxsLiAqL1xuXG5cdFx0XHRcdFx0LyogSXRlcmF0ZSB0aHJvdWdoIGFsbCBjYWxscyBhbmQgcGF1c2UgYW55IHRoYXQgY29udGFpbiBhbnkgb2Ygb3VyIGVsZW1lbnRzICovXG5cdFx0XHRcdFx0JC5lYWNoKFZlbG9jaXR5LlN0YXRlLmNhbGxzLCBmdW5jdGlvbihpLCBhY3RpdmVDYWxsKSB7XG5cblx0XHRcdFx0XHRcdHZhciBmb3VuZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0LyogSW5hY3RpdmUgY2FsbHMgYXJlIHNldCB0byBmYWxzZSBieSB0aGUgbG9naWMgaW5zaWRlIGNvbXBsZXRlQ2FsbCgpLiBTa2lwIHRoZW0uICovXG5cdFx0XHRcdFx0XHRpZiAoYWN0aXZlQ2FsbCkge1xuXHRcdFx0XHRcdFx0XHQvKiBJdGVyYXRlIHRocm91Z2ggdGhlIGFjdGl2ZSBjYWxsJ3MgdGFyZ2V0ZWQgZWxlbWVudHMuICovXG5cdFx0XHRcdFx0XHRcdCQuZWFjaChhY3RpdmVDYWxsWzFdLCBmdW5jdGlvbihrLCBhY3RpdmVFbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHF1ZXVlTmFtZSA9IChvcHRpb25zID09PSB1bmRlZmluZWQpID8gXCJcIiA6IG9wdGlvbnM7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAocXVldWVOYW1lICE9PSB0cnVlICYmIChhY3RpdmVDYWxsWzJdLnF1ZXVlICE9PSBxdWV1ZU5hbWUpICYmICEob3B0aW9ucyA9PT0gdW5kZWZpbmVkICYmIGFjdGl2ZUNhbGxbMl0ucXVldWUgPT09IGZhbHNlKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0LyogSXRlcmF0ZSB0aHJvdWdoIHRoZSBjYWxscyB0YXJnZXRlZCBieSB0aGUgc3RvcCBjb21tYW5kLiAqL1xuXHRcdFx0XHRcdFx0XHRcdCQuZWFjaChlbGVtZW50cywgZnVuY3Rpb24obCwgZWxlbWVudCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0LyogQ2hlY2sgdGhhdCB0aGlzIGNhbGwgd2FzIGFwcGxpZWQgdG8gdGhlIHRhcmdldCBlbGVtZW50LiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGVsZW1lbnQgPT09IGFjdGl2ZUVsZW1lbnQpIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBTZXQgY2FsbCB0byBwYXVzZWQgKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWN0aXZlQ2FsbFs1XSA9IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXN1bWU6IGZhbHNlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogT25jZSB3ZSBtYXRjaCBhbiBlbGVtZW50LCB3ZSBjYW4gYm91bmNlIG91dCB0byB0aGUgbmV4dCBjYWxsIGVudGlyZWx5ICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZvdW5kID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogUHJvY2VlZCB0byBjaGVjayBuZXh0IGNhbGwgaWYgd2UgaGF2ZSBhbHJlYWR5IG1hdGNoZWQgKi9cblx0XHRcdFx0XHRcdFx0XHRpZiAoZm91bmQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHQvKiBTaW5jZSBwYXVzZSBjcmVhdGVzIG5vIG5ldyB0d2VlbnMsIGV4aXQgb3V0IG9mIFZlbG9jaXR5LiAqL1xuXHRcdFx0XHRcdHJldHVybiBnZXRDaGFpbigpO1xuXG5cdFx0XHRcdGNhc2UgXCJyZXN1bWVcIjpcblxuXHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0IEFjdGlvbjogUmVzdW1lXG5cdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHQvKiBIYW5kbGUgZGVsYXkgdGltZXJzICovXG5cdFx0XHRcdFx0JC5lYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihpLCBlbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRyZXN1bWVEZWxheU9uRWxlbWVudChlbGVtZW50LCBjdXJyZW50VGltZSk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHQvKiBQYXVzZSBhbmQgUmVzdW1lIGFyZSBjYWxsLXdpZGUgKG5vdCBvbiBhIHBlciBlbGVtbnQgYmFzaXMpLiBUaHVzLCBjYWxsaW5nIHBhdXNlIG9yIHJlc3VtZSBvbiBhIFxuXHRcdFx0XHRcdCBzaW5nbGUgZWxlbWVudCB3aWxsIGNhdXNlIGFueSBjYWxscyB0aGF0IGNvbnRhaW50IHR3ZWVucyBmb3IgdGhhdCBlbGVtZW50IHRvIGJlIHBhdXNlZC9yZXN1bWVkXG5cdFx0XHRcdFx0IGFzIHdlbGwuICovXG5cblx0XHRcdFx0XHQvKiBJdGVyYXRlIHRocm91Z2ggYWxsIGNhbGxzIGFuZCBwYXVzZSBhbnkgdGhhdCBjb250YWluIGFueSBvZiBvdXIgZWxlbWVudHMgKi9cblx0XHRcdFx0XHQkLmVhY2goVmVsb2NpdHkuU3RhdGUuY2FsbHMsIGZ1bmN0aW9uKGksIGFjdGl2ZUNhbGwpIHtcblx0XHRcdFx0XHRcdHZhciBmb3VuZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0LyogSW5hY3RpdmUgY2FsbHMgYXJlIHNldCB0byBmYWxzZSBieSB0aGUgbG9naWMgaW5zaWRlIGNvbXBsZXRlQ2FsbCgpLiBTa2lwIHRoZW0uICovXG5cdFx0XHRcdFx0XHRpZiAoYWN0aXZlQ2FsbCkge1xuXHRcdFx0XHRcdFx0XHQvKiBJdGVyYXRlIHRocm91Z2ggdGhlIGFjdGl2ZSBjYWxsJ3MgdGFyZ2V0ZWQgZWxlbWVudHMuICovXG5cdFx0XHRcdFx0XHRcdCQuZWFjaChhY3RpdmVDYWxsWzFdLCBmdW5jdGlvbihrLCBhY3RpdmVFbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHF1ZXVlTmFtZSA9IChvcHRpb25zID09PSB1bmRlZmluZWQpID8gXCJcIiA6IG9wdGlvbnM7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAocXVldWVOYW1lICE9PSB0cnVlICYmIChhY3RpdmVDYWxsWzJdLnF1ZXVlICE9PSBxdWV1ZU5hbWUpICYmICEob3B0aW9ucyA9PT0gdW5kZWZpbmVkICYmIGFjdGl2ZUNhbGxbMl0ucXVldWUgPT09IGZhbHNlKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0LyogU2tpcCBhbnkgY2FsbHMgdGhhdCBoYXZlIG5ldmVyIGJlZW4gcGF1c2VkICovXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFhY3RpdmVDYWxsWzVdKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvKiBJdGVyYXRlIHRocm91Z2ggdGhlIGNhbGxzIHRhcmdldGVkIGJ5IHRoZSBzdG9wIGNvbW1hbmQuICovXG5cdFx0XHRcdFx0XHRcdFx0JC5lYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihsLCBlbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBDaGVjayB0aGF0IHRoaXMgY2FsbCB3YXMgYXBwbGllZCB0byB0aGUgdGFyZ2V0IGVsZW1lbnQuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoZWxlbWVudCA9PT0gYWN0aXZlRWxlbWVudCkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIEZsYWcgYSBwYXVzZSBvYmplY3QgdG8gYmUgcmVzdW1lZCwgd2hpY2ggd2lsbCBvY2N1ciBkdXJpbmcgdGhlIG5leHQgdGljay4gSW5cblx0XHRcdFx0XHRcdFx0XHRcdFx0IGFkZGl0aW9uLCB0aGUgcGF1c2Ugb2JqZWN0IHdpbGwgYXQgdGhhdCB0aW1lIGJlIGRlbGV0ZWQgKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0YWN0aXZlQ2FsbFs1XS5yZXN1bWUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIE9uY2Ugd2UgbWF0Y2ggYW4gZWxlbWVudCwgd2UgY2FuIGJvdW5jZSBvdXQgdG8gdGhlIG5leHQgY2FsbCBlbnRpcmVseSAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0XHRcdC8qIFByb2NlZWQgdG8gY2hlY2sgbmV4dCBjYWxsIGlmIHdlIGhhdmUgYWxyZWFkeSBtYXRjaGVkICovXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGZvdW5kKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0LyogU2luY2UgcmVzdW1lIGNyZWF0ZXMgbm8gbmV3IHR3ZWVucywgZXhpdCBvdXQgb2YgVmVsb2NpdHkuICovXG5cdFx0XHRcdFx0cmV0dXJuIGdldENoYWluKCk7XG5cblx0XHRcdFx0Y2FzZSBcImZpbmlzaFwiOlxuXHRcdFx0XHRjYXNlIFwiZmluaXNoQWxsXCI6XG5cdFx0XHRcdGNhc2UgXCJzdG9wXCI6XG5cdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHQgQWN0aW9uOiBTdG9wXG5cdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHQvKiBDbGVhciB0aGUgY3VycmVudGx5LWFjdGl2ZSBkZWxheSBvbiBlYWNoIHRhcmdldGVkIGVsZW1lbnQuICovXG5cdFx0XHRcdFx0JC5lYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihpLCBlbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRpZiAoRGF0YShlbGVtZW50KSAmJiBEYXRhKGVsZW1lbnQpLmRlbGF5VGltZXIpIHtcblx0XHRcdFx0XHRcdFx0LyogU3RvcCB0aGUgdGltZXIgZnJvbSB0cmlnZ2VyaW5nIGl0cyBjYWNoZWQgbmV4dCgpIGZ1bmN0aW9uLiAqL1xuXHRcdFx0XHRcdFx0XHRjbGVhclRpbWVvdXQoRGF0YShlbGVtZW50KS5kZWxheVRpbWVyLnNldFRpbWVvdXQpO1xuXG5cdFx0XHRcdFx0XHRcdC8qIE1hbnVhbGx5IGNhbGwgdGhlIG5leHQoKSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBzdWJzZXF1ZW50IHF1ZXVlIGl0ZW1zIGNhbiBwcm9ncmVzcy4gKi9cblx0XHRcdFx0XHRcdFx0aWYgKERhdGEoZWxlbWVudCkuZGVsYXlUaW1lci5uZXh0KSB7XG5cdFx0XHRcdFx0XHRcdFx0RGF0YShlbGVtZW50KS5kZWxheVRpbWVyLm5leHQoKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBEYXRhKGVsZW1lbnQpLmRlbGF5VGltZXI7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIElmIHdlIHdhbnQgdG8gZmluaXNoIGV2ZXJ5dGhpbmcgaW4gdGhlIHF1ZXVlLCB3ZSBoYXZlIHRvIGl0ZXJhdGUgdGhyb3VnaCBpdFxuXHRcdFx0XHRcdFx0IGFuZCBjYWxsIGVhY2ggZnVuY3Rpb24uIFRoaXMgd2lsbCBtYWtlIHRoZW0gYWN0aXZlIGNhbGxzIGJlbG93LCB3aGljaCB3aWxsXG5cdFx0XHRcdFx0XHQgY2F1c2UgdGhlbSB0byBiZSBhcHBsaWVkIHZpYSB0aGUgZHVyYXRpb24gc2V0dGluZy4gKi9cblx0XHRcdFx0XHRcdGlmIChwcm9wZXJ0aWVzTWFwID09PSBcImZpbmlzaEFsbFwiICYmIChvcHRpb25zID09PSB0cnVlIHx8IFR5cGUuaXNTdHJpbmcob3B0aW9ucykpKSB7XG5cdFx0XHRcdFx0XHRcdC8qIEl0ZXJhdGUgdGhyb3VnaCB0aGUgaXRlbXMgaW4gdGhlIGVsZW1lbnQncyBxdWV1ZS4gKi9cblx0XHRcdFx0XHRcdFx0JC5lYWNoKCQucXVldWUoZWxlbWVudCwgVHlwZS5pc1N0cmluZyhvcHRpb25zKSA/IG9wdGlvbnMgOiBcIlwiKSwgZnVuY3Rpb24oXywgaXRlbSkge1xuXHRcdFx0XHRcdFx0XHRcdC8qIFRoZSBxdWV1ZSBhcnJheSBjYW4gY29udGFpbiBhbiBcImlucHJvZ3Jlc3NcIiBzdHJpbmcsIHdoaWNoIHdlIHNraXAuICovXG5cdFx0XHRcdFx0XHRcdFx0aWYgKFR5cGUuaXNGdW5jdGlvbihpdGVtKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aXRlbSgpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdFx0LyogQ2xlYXJpbmcgdGhlICQucXVldWUoKSBhcnJheSBpcyBhY2hpZXZlZCBieSByZXNldHRpbmcgaXQgdG8gW10uICovXG5cdFx0XHRcdFx0XHRcdCQucXVldWUoZWxlbWVudCwgVHlwZS5pc1N0cmluZyhvcHRpb25zKSA/IG9wdGlvbnMgOiBcIlwiLCBbXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHR2YXIgY2FsbHNUb1N0b3AgPSBbXTtcblxuXHRcdFx0XHRcdC8qIFdoZW4gdGhlIHN0b3AgYWN0aW9uIGlzIHRyaWdnZXJlZCwgdGhlIGVsZW1lbnRzJyBjdXJyZW50bHkgYWN0aXZlIGNhbGwgaXMgaW1tZWRpYXRlbHkgc3RvcHBlZC4gVGhlIGFjdGl2ZSBjYWxsIG1pZ2h0IGhhdmVcblx0XHRcdFx0XHQgYmVlbiBhcHBsaWVkIHRvIG11bHRpcGxlIGVsZW1lbnRzLCBpbiB3aGljaCBjYXNlIGFsbCBvZiB0aGUgY2FsbCdzIGVsZW1lbnRzIHdpbGwgYmUgc3RvcHBlZC4gV2hlbiBhbiBlbGVtZW50XG5cdFx0XHRcdFx0IGlzIHN0b3BwZWQsIHRoZSBuZXh0IGl0ZW0gaW4gaXRzIGFuaW1hdGlvbiBxdWV1ZSBpcyBpbW1lZGlhdGVseSB0cmlnZ2VyZWQuICovXG5cdFx0XHRcdFx0LyogQW4gYWRkaXRpb25hbCBhcmd1bWVudCBtYXkgYmUgcGFzc2VkIGluIHRvIGNsZWFyIGFuIGVsZW1lbnQncyByZW1haW5pbmcgcXVldWVkIGNhbGxzLiBFaXRoZXIgdHJ1ZSAod2hpY2ggZGVmYXVsdHMgdG8gdGhlIFwiZnhcIiBxdWV1ZSlcblx0XHRcdFx0XHQgb3IgYSBjdXN0b20gcXVldWUgc3RyaW5nIGNhbiBiZSBwYXNzZWQgaW4uICovXG5cdFx0XHRcdFx0LyogTm90ZTogVGhlIHN0b3AgY29tbWFuZCBydW5zIHByaW9yIHRvIFZlbG9jaXR5J3MgUXVldWVpbmcgcGhhc2Ugc2luY2UgaXRzIGJlaGF2aW9yIGlzIGludGVuZGVkIHRvIHRha2UgZWZmZWN0ICppbW1lZGlhdGVseSosXG5cdFx0XHRcdFx0IHJlZ2FyZGxlc3Mgb2YgdGhlIGVsZW1lbnQncyBjdXJyZW50IHF1ZXVlIHN0YXRlLiAqL1xuXG5cdFx0XHRcdFx0LyogSXRlcmF0ZSB0aHJvdWdoIGV2ZXJ5IGFjdGl2ZSBjYWxsLiAqL1xuXHRcdFx0XHRcdCQuZWFjaChWZWxvY2l0eS5TdGF0ZS5jYWxscywgZnVuY3Rpb24oaSwgYWN0aXZlQ2FsbCkge1xuXHRcdFx0XHRcdFx0LyogSW5hY3RpdmUgY2FsbHMgYXJlIHNldCB0byBmYWxzZSBieSB0aGUgbG9naWMgaW5zaWRlIGNvbXBsZXRlQ2FsbCgpLiBTa2lwIHRoZW0uICovXG5cdFx0XHRcdFx0XHRpZiAoYWN0aXZlQ2FsbCkge1xuXHRcdFx0XHRcdFx0XHQvKiBJdGVyYXRlIHRocm91Z2ggdGhlIGFjdGl2ZSBjYWxsJ3MgdGFyZ2V0ZWQgZWxlbWVudHMuICovXG5cdFx0XHRcdFx0XHRcdCQuZWFjaChhY3RpdmVDYWxsWzFdLCBmdW5jdGlvbihrLCBhY3RpdmVFbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0LyogSWYgdHJ1ZSB3YXMgcGFzc2VkIGluIGFzIGEgc2Vjb25kYXJ5IGFyZ3VtZW50LCBjbGVhciBhYnNvbHV0ZWx5IGFsbCBjYWxscyBvbiB0aGlzIGVsZW1lbnQuIE90aGVyd2lzZSwgb25seVxuXHRcdFx0XHRcdFx0XHRcdCBjbGVhciBjYWxscyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlbGV2YW50IHF1ZXVlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdC8qIENhbGwgc3RvcHBpbmcgbG9naWMgd29ya3MgYXMgZm9sbG93czpcblx0XHRcdFx0XHRcdFx0XHQgLSBvcHRpb25zID09PSB0cnVlIC0tPiBzdG9wIGN1cnJlbnQgZGVmYXVsdCBxdWV1ZSBjYWxscyAoYW5kIHF1ZXVlOmZhbHNlIGNhbGxzKSwgaW5jbHVkaW5nIHJlbWFpbmluZyBxdWV1ZWQgb25lcy5cblx0XHRcdFx0XHRcdFx0XHQgLSBvcHRpb25zID09PSB1bmRlZmluZWQgLS0+IHN0b3AgY3VycmVudCBxdWV1ZTpcIlwiIGNhbGwgYW5kIGFsbCBxdWV1ZTpmYWxzZSBjYWxscy5cblx0XHRcdFx0XHRcdFx0XHQgLSBvcHRpb25zID09PSBmYWxzZSAtLT4gc3RvcCBvbmx5IHF1ZXVlOmZhbHNlIGNhbGxzLlxuXHRcdFx0XHRcdFx0XHRcdCAtIG9wdGlvbnMgPT09IFwiY3VzdG9tXCIgLS0+IHN0b3AgY3VycmVudCBxdWV1ZTpcImN1c3RvbVwiIGNhbGwsIGluY2x1ZGluZyByZW1haW5pbmcgcXVldWVkIG9uZXMgKHRoZXJlIGlzIG5vIGZ1bmN0aW9uYWxpdHkgdG8gb25seSBjbGVhciB0aGUgY3VycmVudGx5LXJ1bm5pbmcgcXVldWU6XCJjdXN0b21cIiBjYWxsKS4gKi9cblx0XHRcdFx0XHRcdFx0XHR2YXIgcXVldWVOYW1lID0gKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgPyBcIlwiIDogb3B0aW9ucztcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChxdWV1ZU5hbWUgIT09IHRydWUgJiYgKGFjdGl2ZUNhbGxbMl0ucXVldWUgIT09IHF1ZXVlTmFtZSkgJiYgIShvcHRpb25zID09PSB1bmRlZmluZWQgJiYgYWN0aXZlQ2FsbFsyXS5xdWV1ZSA9PT0gZmFsc2UpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvKiBJdGVyYXRlIHRocm91Z2ggdGhlIGNhbGxzIHRhcmdldGVkIGJ5IHRoZSBzdG9wIGNvbW1hbmQuICovXG5cdFx0XHRcdFx0XHRcdFx0JC5lYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihsLCBlbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBDaGVjayB0aGF0IHRoaXMgY2FsbCB3YXMgYXBwbGllZCB0byB0aGUgdGFyZ2V0IGVsZW1lbnQuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoZWxlbWVudCA9PT0gYWN0aXZlRWxlbWVudCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBPcHRpb25hbGx5IGNsZWFyIHRoZSByZW1haW5pbmcgcXVldWVkIGNhbGxzLiBJZiB3ZSdyZSBkb2luZyBcImZpbmlzaEFsbFwiIHRoaXMgd29uJ3QgZmluZCBhbnl0aGluZyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0IGR1ZSB0byB0aGUgcXVldWUtY2xlYXJpbmcgYWJvdmUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChvcHRpb25zID09PSB0cnVlIHx8IFR5cGUuaXNTdHJpbmcob3B0aW9ucykpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBJdGVyYXRlIHRocm91Z2ggdGhlIGl0ZW1zIGluIHRoZSBlbGVtZW50J3MgcXVldWUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0JC5lYWNoKCQucXVldWUoZWxlbWVudCwgVHlwZS5pc1N0cmluZyhvcHRpb25zKSA/IG9wdGlvbnMgOiBcIlwiKSwgZnVuY3Rpb24oXywgaXRlbSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyogVGhlIHF1ZXVlIGFycmF5IGNhbiBjb250YWluIGFuIFwiaW5wcm9ncmVzc1wiIHN0cmluZywgd2hpY2ggd2Ugc2tpcC4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChUeXBlLmlzRnVuY3Rpb24oaXRlbSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyogUGFzcyB0aGUgaXRlbSdzIGNhbGxiYWNrIGEgZmxhZyBpbmRpY2F0aW5nIHRoYXQgd2Ugd2FudCB0byBhYm9ydCBmcm9tIHRoZSBxdWV1ZSBjYWxsLlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgKFNwZWNpZmljYWxseSwgdGhlIHF1ZXVlIHdpbGwgcmVzb2x2ZSB0aGUgY2FsbCdzIGFzc29jaWF0ZWQgcHJvbWlzZSB0aGVuIGFib3J0LikgICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGl0ZW0obnVsbCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBDbGVhcmluZyB0aGUgJC5xdWV1ZSgpIGFycmF5IGlzIGFjaGlldmVkIGJ5IHJlc2V0dGluZyBpdCB0byBbXS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQkLnF1ZXVlKGVsZW1lbnQsIFR5cGUuaXNTdHJpbmcob3B0aW9ucykgPyBvcHRpb25zIDogXCJcIiwgW10pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKHByb3BlcnRpZXNNYXAgPT09IFwic3RvcFwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyogU2luY2UgXCJyZXZlcnNlXCIgdXNlcyBjYWNoZWQgc3RhcnQgdmFsdWVzICh0aGUgcHJldmlvdXMgY2FsbCdzIGVuZFZhbHVlcyksIHRoZXNlIHZhbHVlcyBtdXN0IGJlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0IGNoYW5nZWQgdG8gcmVmbGVjdCB0aGUgZmluYWwgdmFsdWUgdGhhdCB0aGUgZWxlbWVudHMgd2VyZSBhY3R1YWxseSB0d2VlbmVkIHRvLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIE5vdGU6IElmIG9ubHkgcXVldWU6ZmFsc2UgYW5pbWF0aW9ucyBhcmUgY3VycmVudGx5IHJ1bm5pbmcgb24gYW4gZWxlbWVudCwgaXQgd29uJ3QgaGF2ZSBhIHR3ZWVuc0NvbnRhaW5lclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCBvYmplY3QuIEFsc28sIHF1ZXVlOmZhbHNlIGFuaW1hdGlvbnMgY2FuJ3QgYmUgcmV2ZXJzZWQuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIGRhdGEgPSBEYXRhKGVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChkYXRhICYmIGRhdGEudHdlZW5zQ29udGFpbmVyICYmIHF1ZXVlTmFtZSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCQuZWFjaChkYXRhLnR3ZWVuc0NvbnRhaW5lciwgZnVuY3Rpb24obSwgYWN0aXZlVHdlZW4pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YWN0aXZlVHdlZW4uZW5kVmFsdWUgPSBhY3RpdmVUd2Vlbi5jdXJyZW50VmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjYWxsc1RvU3RvcC5wdXNoKGkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHByb3BlcnRpZXNNYXAgPT09IFwiZmluaXNoXCIgfHwgcHJvcGVydGllc01hcCA9PT0gXCJmaW5pc2hBbGxcIikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIFRvIGdldCBhY3RpdmUgdHdlZW5zIHRvIGZpbmlzaCBpbW1lZGlhdGVseSwgd2UgZm9yY2VmdWxseSBzaG9ydGVuIHRoZWlyIGR1cmF0aW9ucyB0byAxbXMgc28gdGhhdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCB0aGV5IGZpbmlzaCB1cG9uIHRoZSBuZXh0IHJBZiB0aWNrIHRoZW4gcHJvY2VlZCB3aXRoIG5vcm1hbCBjYWxsIGNvbXBsZXRpb24gbG9naWMuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YWN0aXZlQ2FsbFsyXS5kdXJhdGlvbiA9IDE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHQvKiBQcmVtYXR1cmVseSBjYWxsIGNvbXBsZXRlQ2FsbCgpIG9uIGVhY2ggbWF0Y2hlZCBhY3RpdmUgY2FsbC4gUGFzcyBhbiBhZGRpdGlvbmFsIGZsYWcgZm9yIFwic3RvcFwiIHRvIGluZGljYXRlXG5cdFx0XHRcdFx0IHRoYXQgdGhlIGNvbXBsZXRlIGNhbGxiYWNrIGFuZCBkaXNwbGF5Om5vbmUgc2V0dGluZyBzaG91bGQgYmUgc2tpcHBlZCBzaW5jZSB3ZSdyZSBjb21wbGV0aW5nIHByZW1hdHVyZWx5LiAqL1xuXHRcdFx0XHRcdGlmIChwcm9wZXJ0aWVzTWFwID09PSBcInN0b3BcIikge1xuXHRcdFx0XHRcdFx0JC5lYWNoKGNhbGxzVG9TdG9wLCBmdW5jdGlvbihpLCBqKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlQ2FsbChqLCB0cnVlKTtcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRpZiAocHJvbWlzZURhdGEucHJvbWlzZSkge1xuXHRcdFx0XHRcdFx0XHQvKiBJbW1lZGlhdGVseSByZXNvbHZlIHRoZSBwcm9taXNlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHN0b3AgY2FsbCBzaW5jZSBzdG9wIHJ1bnMgc3luY2hyb25vdXNseS4gKi9cblx0XHRcdFx0XHRcdFx0cHJvbWlzZURhdGEucmVzb2x2ZXIoZWxlbWVudHMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIFNpbmNlIHdlJ3JlIHN0b3BwaW5nLCBhbmQgbm90IHByb2NlZWRpbmcgd2l0aCBxdWV1ZWluZywgZXhpdCBvdXQgb2YgVmVsb2NpdHkuICovXG5cdFx0XHRcdFx0cmV0dXJuIGdldENoYWluKCk7XG5cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHQvKiBUcmVhdCBhIG5vbi1lbXB0eSBwbGFpbiBvYmplY3QgYXMgYSBsaXRlcmFsIHByb3BlcnRpZXMgbWFwLiAqL1xuXHRcdFx0XHRcdGlmICgkLmlzUGxhaW5PYmplY3QocHJvcGVydGllc01hcCkgJiYgIVR5cGUuaXNFbXB0eU9iamVjdChwcm9wZXJ0aWVzTWFwKSkge1xuXHRcdFx0XHRcdFx0YWN0aW9uID0gXCJzdGFydFwiO1xuXG5cdFx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0IFJlZGlyZWN0c1xuXHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHRcdC8qIENoZWNrIGlmIGEgc3RyaW5nIG1hdGNoZXMgYSByZWdpc3RlcmVkIHJlZGlyZWN0IChzZWUgUmVkaXJlY3RzIGFib3ZlKS4gKi9cblx0XHRcdFx0XHR9IGVsc2UgaWYgKFR5cGUuaXNTdHJpbmcocHJvcGVydGllc01hcCkgJiYgVmVsb2NpdHkuUmVkaXJlY3RzW3Byb3BlcnRpZXNNYXBdKSB7XG5cdFx0XHRcdFx0XHRvcHRzID0gJC5leHRlbmQoe30sIG9wdGlvbnMpO1xuXG5cdFx0XHRcdFx0XHR2YXIgZHVyYXRpb25PcmlnaW5hbCA9IG9wdHMuZHVyYXRpb24sXG5cdFx0XHRcdFx0XHRcdFx0ZGVsYXlPcmlnaW5hbCA9IG9wdHMuZGVsYXkgfHwgMDtcblxuXHRcdFx0XHRcdFx0LyogSWYgdGhlIGJhY2t3YXJkcyBvcHRpb24gd2FzIHBhc3NlZCBpbiwgcmV2ZXJzZSB0aGUgZWxlbWVudCBzZXQgc28gdGhhdCBlbGVtZW50cyBhbmltYXRlIGZyb20gdGhlIGxhc3QgdG8gdGhlIGZpcnN0LiAqL1xuXHRcdFx0XHRcdFx0aWYgKG9wdHMuYmFja3dhcmRzID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnRzID0gJC5leHRlbmQodHJ1ZSwgW10sIGVsZW1lbnRzKS5yZXZlcnNlKCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIEluZGl2aWR1YWxseSB0cmlnZ2VyIHRoZSByZWRpcmVjdCBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBzZXQgdG8gcHJldmVudCB1c2VycyBmcm9tIGhhdmluZyB0byBoYW5kbGUgaXRlcmF0aW9uIGxvZ2ljIGluIHRoZWlyIHJlZGlyZWN0LiAqL1xuXHRcdFx0XHRcdFx0JC5lYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50SW5kZXgsIGVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0LyogSWYgdGhlIHN0YWdnZXIgb3B0aW9uIHdhcyBwYXNzZWQgaW4sIHN1Y2Nlc3NpdmVseSBkZWxheSBlYWNoIGVsZW1lbnQgYnkgdGhlIHN0YWdnZXIgdmFsdWUgKGluIG1zKS4gUmV0YWluIHRoZSBvcmlnaW5hbCBkZWxheSB2YWx1ZS4gKi9cblx0XHRcdFx0XHRcdFx0aWYgKHBhcnNlRmxvYXQob3B0cy5zdGFnZ2VyKSkge1xuXHRcdFx0XHRcdFx0XHRcdG9wdHMuZGVsYXkgPSBkZWxheU9yaWdpbmFsICsgKHBhcnNlRmxvYXQob3B0cy5zdGFnZ2VyKSAqIGVsZW1lbnRJbmRleCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoVHlwZS5pc0Z1bmN0aW9uKG9wdHMuc3RhZ2dlcikpIHtcblx0XHRcdFx0XHRcdFx0XHRvcHRzLmRlbGF5ID0gZGVsYXlPcmlnaW5hbCArIG9wdHMuc3RhZ2dlci5jYWxsKGVsZW1lbnQsIGVsZW1lbnRJbmRleCwgZWxlbWVudHNMZW5ndGgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0LyogSWYgdGhlIGRyYWcgb3B0aW9uIHdhcyBwYXNzZWQgaW4sIHN1Y2Nlc3NpdmVseSBpbmNyZWFzZS9kZWNyZWFzZSAoZGVwZW5kaW5nIG9uIHRoZSBwcmVzZW5zZSBvZiBvcHRzLmJhY2t3YXJkcylcblx0XHRcdFx0XHRcdFx0IHRoZSBkdXJhdGlvbiBvZiBlYWNoIGVsZW1lbnQncyBhbmltYXRpb24sIHVzaW5nIGZsb29ycyB0byBwcmV2ZW50IHByb2R1Y2luZyB2ZXJ5IHNob3J0IGR1cmF0aW9ucy4gKi9cblx0XHRcdFx0XHRcdFx0aWYgKG9wdHMuZHJhZykge1xuXHRcdFx0XHRcdFx0XHRcdC8qIERlZmF1bHQgdGhlIGR1cmF0aW9uIG9mIFVJIHBhY2sgZWZmZWN0cyAoY2FsbG91dHMgYW5kIHRyYW5zaXRpb25zKSB0byAxMDAwbXMgaW5zdGVhZCBvZiB0aGUgdXN1YWwgZGVmYXVsdCBkdXJhdGlvbiBvZiA0MDBtcy4gKi9cblx0XHRcdFx0XHRcdFx0XHRvcHRzLmR1cmF0aW9uID0gcGFyc2VGbG9hdChkdXJhdGlvbk9yaWdpbmFsKSB8fCAoL14oY2FsbG91dHx0cmFuc2l0aW9uKS8udGVzdChwcm9wZXJ0aWVzTWFwKSA/IDEwMDAgOiBEVVJBVElPTl9ERUZBVUxUKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8qIEZvciBlYWNoIGVsZW1lbnQsIHRha2UgdGhlIGdyZWF0ZXIgZHVyYXRpb24gb2Y6IEEpIGFuaW1hdGlvbiBjb21wbGV0aW9uIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIG9yaWdpbmFsIGR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0XHRcdCBCKSA3NSUgb2YgdGhlIG9yaWdpbmFsIGR1cmF0aW9uLCBvciBDKSBhIDIwMG1zIGZhbGxiYWNrIChpbiBjYXNlIGR1cmF0aW9uIGlzIGFscmVhZHkgc2V0IHRvIGEgbG93IHZhbHVlKS5cblx0XHRcdFx0XHRcdFx0XHQgVGhlIGVuZCByZXN1bHQgaXMgYSBiYXNlbGluZSBvZiA3NSUgb2YgdGhlIHJlZGlyZWN0J3MgZHVyYXRpb24gdGhhdCBpbmNyZWFzZXMvZGVjcmVhc2VzIGFzIHRoZSBlbmQgb2YgdGhlIGVsZW1lbnQgc2V0IGlzIGFwcHJvYWNoZWQuICovXG5cdFx0XHRcdFx0XHRcdFx0b3B0cy5kdXJhdGlvbiA9IE1hdGgubWF4KG9wdHMuZHVyYXRpb24gKiAob3B0cy5iYWNrd2FyZHMgPyAxIC0gZWxlbWVudEluZGV4IC8gZWxlbWVudHNMZW5ndGggOiAoZWxlbWVudEluZGV4ICsgMSkgLyBlbGVtZW50c0xlbmd0aCksIG9wdHMuZHVyYXRpb24gKiAwLjc1LCAyMDApO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0LyogUGFzcyBpbiB0aGUgY2FsbCdzIG9wdHMgb2JqZWN0IHNvIHRoYXQgdGhlIHJlZGlyZWN0IGNhbiBvcHRpb25hbGx5IGV4dGVuZCBpdC4gSXQgZGVmYXVsdHMgdG8gYW4gZW1wdHkgb2JqZWN0IGluc3RlYWQgb2YgbnVsbCB0b1xuXHRcdFx0XHRcdFx0XHQgcmVkdWNlIHRoZSBvcHRzIGNoZWNraW5nIGxvZ2ljIHJlcXVpcmVkIGluc2lkZSB0aGUgcmVkaXJlY3QuICovXG5cdFx0XHRcdFx0XHRcdFZlbG9jaXR5LlJlZGlyZWN0c1twcm9wZXJ0aWVzTWFwXS5jYWxsKGVsZW1lbnQsIGVsZW1lbnQsIG9wdHMgfHwge30sIGVsZW1lbnRJbmRleCwgZWxlbWVudHNMZW5ndGgsIGVsZW1lbnRzLCBwcm9taXNlRGF0YS5wcm9taXNlID8gcHJvbWlzZURhdGEgOiB1bmRlZmluZWQpO1xuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdC8qIFNpbmNlIHRoZSBhbmltYXRpb24gbG9naWMgcmVzaWRlcyB3aXRoaW4gdGhlIHJlZGlyZWN0J3Mgb3duIGNvZGUsIGFib3J0IHRoZSByZW1haW5kZXIgb2YgdGhpcyBjYWxsLlxuXHRcdFx0XHRcdFx0IChUaGUgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQgdXAgdG8gdGhpcyBwb2ludCBpcyB2aXJ0dWFsbHkgbm9uLWV4aXN0YW50LikgKi9cblx0XHRcdFx0XHRcdC8qIE5vdGU6IFRoZSBqUXVlcnkgY2FsbCBjaGFpbiBpcyBrZXB0IGludGFjdCBieSByZXR1cm5pbmcgdGhlIGNvbXBsZXRlIGVsZW1lbnQgc2V0LiAqL1xuXHRcdFx0XHRcdFx0cmV0dXJuIGdldENoYWluKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBhYm9ydEVycm9yID0gXCJWZWxvY2l0eTogRmlyc3QgYXJndW1lbnQgKFwiICsgcHJvcGVydGllc01hcCArIFwiKSB3YXMgbm90IGEgcHJvcGVydHkgbWFwLCBhIGtub3duIGFjdGlvbiwgb3IgYSByZWdpc3RlcmVkIHJlZGlyZWN0LiBBYm9ydGluZy5cIjtcblxuXHRcdFx0XHRcdFx0aWYgKHByb21pc2VEYXRhLnByb21pc2UpIHtcblx0XHRcdFx0XHRcdFx0cHJvbWlzZURhdGEucmVqZWN0ZXIobmV3IEVycm9yKGFib3J0RXJyb3IpKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAod2luZG93LmNvbnNvbGUpIHtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coYWJvcnRFcnJvcik7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBnZXRDaGFpbigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHQgQ2FsbC1XaWRlIFZhcmlhYmxlc1xuXHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHQvKiBBIGNvbnRhaW5lciBmb3IgQ1NTIHVuaXQgY29udmVyc2lvbiByYXRpb3MgKGUuZy4gJSwgcmVtLCBhbmQgZW0gPT0+IHB4KSB0aGF0IGlzIHVzZWQgdG8gY2FjaGUgcmF0aW9zIGFjcm9zcyBhbGwgZWxlbWVudHNcblx0XHRcdCBiZWluZyBhbmltYXRlZCBpbiBhIHNpbmdsZSBWZWxvY2l0eSBjYWxsLiBDYWxjdWxhdGluZyB1bml0IHJhdGlvcyBuZWNlc3NpdGF0ZXMgRE9NIHF1ZXJ5aW5nIGFuZCB1cGRhdGluZywgYW5kIGlzIHRoZXJlZm9yZVxuXHRcdFx0IGF2b2lkZWQgKHZpYSBjYWNoaW5nKSB3aGVyZXZlciBwb3NzaWJsZS4gVGhpcyBjb250YWluZXIgaXMgY2FsbC13aWRlIGluc3RlYWQgb2YgcGFnZS13aWRlIHRvIGF2b2lkIHRoZSByaXNrIG9mIHVzaW5nIHN0YWxlXG5cdFx0XHQgY29udmVyc2lvbiBtZXRyaWNzIGFjcm9zcyBWZWxvY2l0eSBhbmltYXRpb25zIHRoYXQgYXJlIG5vdCBpbW1lZGlhdGVseSBjb25zZWN1dGl2ZWx5IGNoYWluZWQuICovXG5cdFx0XHR2YXIgY2FsbFVuaXRDb252ZXJzaW9uRGF0YSA9IHtcblx0XHRcdFx0bGFzdFBhcmVudDogbnVsbCxcblx0XHRcdFx0bGFzdFBvc2l0aW9uOiBudWxsLFxuXHRcdFx0XHRsYXN0Rm9udFNpemU6IG51bGwsXG5cdFx0XHRcdGxhc3RQZXJjZW50VG9QeFdpZHRoOiBudWxsLFxuXHRcdFx0XHRsYXN0UGVyY2VudFRvUHhIZWlnaHQ6IG51bGwsXG5cdFx0XHRcdGxhc3RFbVRvUHg6IG51bGwsXG5cdFx0XHRcdHJlbVRvUHg6IG51bGwsXG5cdFx0XHRcdHZ3VG9QeDogbnVsbCxcblx0XHRcdFx0dmhUb1B4OiBudWxsXG5cdFx0XHR9O1xuXG5cdFx0XHQvKiBBIGNvbnRhaW5lciBmb3IgYWxsIHRoZSBlbnN1aW5nIHR3ZWVuIGRhdGEgYW5kIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNhbGwuIFRoaXMgY29udGFpbmVyIGdldHMgcHVzaGVkIHRvIHRoZSBwYWdlLXdpZGVcblx0XHRcdCBWZWxvY2l0eS5TdGF0ZS5jYWxscyBhcnJheSB0aGF0IGlzIHByb2Nlc3NlZCBkdXJpbmcgYW5pbWF0aW9uIHRpY2tpbmcuICovXG5cdFx0XHR2YXIgY2FsbCA9IFtdO1xuXG5cdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHQgRWxlbWVudCBQcm9jZXNzaW5nXG5cdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHQvKiBFbGVtZW50IHByb2Nlc3NpbmcgY29uc2lzdHMgb2YgdGhyZWUgcGFydHMgLS0gZGF0YSBwcm9jZXNzaW5nIHRoYXQgY2Fubm90IGdvIHN0YWxlIGFuZCBkYXRhIHByb2Nlc3NpbmcgdGhhdCAqY2FuKiBnbyBzdGFsZSAoaS5lLiB0aGlyZC1wYXJ0eSBzdHlsZSBtb2RpZmljYXRpb25zKTpcblx0XHRcdCAxKSBQcmUtUXVldWVpbmc6IEVsZW1lbnQtd2lkZSB2YXJpYWJsZXMsIGluY2x1ZGluZyB0aGUgZWxlbWVudCdzIGRhdGEgc3RvcmFnZSwgYXJlIGluc3RhbnRpYXRlZC4gQ2FsbCBvcHRpb25zIGFyZSBwcmVwYXJlZC4gSWYgdHJpZ2dlcmVkLCB0aGUgU3RvcCBhY3Rpb24gaXMgZXhlY3V0ZWQuXG5cdFx0XHQgMikgUXVldWVpbmc6IFRoZSBsb2dpYyB0aGF0IHJ1bnMgb25jZSB0aGlzIGNhbGwgaGFzIHJlYWNoZWQgaXRzIHBvaW50IG9mIGV4ZWN1dGlvbiBpbiB0aGUgZWxlbWVudCdzICQucXVldWUoKSBzdGFjay4gTW9zdCBsb2dpYyBpcyBwbGFjZWQgaGVyZSB0byBhdm9pZCByaXNraW5nIGl0IGJlY29taW5nIHN0YWxlLlxuXHRcdFx0IDMpIFB1c2hpbmc6IENvbnNvbGlkYXRpb24gb2YgdGhlIHR3ZWVuIGRhdGEgZm9sbG93ZWQgYnkgaXRzIHB1c2ggb250byB0aGUgZ2xvYmFsIGluLXByb2dyZXNzIGNhbGxzIGNvbnRhaW5lci5cblx0XHRcdCBgZWxlbWVudEFycmF5SW5kZXhgIGFsbG93cyBwYXNzaW5nIGluZGV4IG9mIHRoZSBlbGVtZW50IGluIHRoZSBvcmlnaW5hbCBhcnJheSB0byB2YWx1ZSBmdW5jdGlvbnMuXG5cdFx0XHQgSWYgYGVsZW1lbnRzSW5kZXhgIHdlcmUgdXNlZCBpbnN0ZWFkIHRoZSBpbmRleCB3b3VsZCBiZSBkZXRlcm1pbmVkIGJ5IHRoZSBlbGVtZW50cycgcGVyLWVsZW1lbnQgcXVldWUuXG5cdFx0XHQgKi9cblx0XHRcdGZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50KGVsZW1lbnQsIGVsZW1lbnRBcnJheUluZGV4KSB7XG5cblx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IFBhcnQgSTogUHJlLVF1ZXVlaW5nXG5cdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IEVsZW1lbnQtV2lkZSBWYXJpYWJsZXNcblx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHR2YXIgLyogVGhlIHJ1bnRpbWUgb3B0cyBvYmplY3QgaXMgdGhlIGV4dGVuc2lvbiBvZiB0aGUgY3VycmVudCBjYWxsJ3Mgb3B0aW9ucyBhbmQgVmVsb2NpdHkncyBwYWdlLXdpZGUgb3B0aW9uIGRlZmF1bHRzLiAqL1xuXHRcdFx0XHRcdFx0b3B0cyA9ICQuZXh0ZW5kKHt9LCBWZWxvY2l0eS5kZWZhdWx0cywgb3B0aW9ucyksXG5cdFx0XHRcdFx0XHQvKiBBIGNvbnRhaW5lciBmb3IgdGhlIHByb2Nlc3NlZCBkYXRhIGFzc29jaWF0ZWQgd2l0aCBlYWNoIHByb3BlcnR5IGluIHRoZSBwcm9wZXJ0eU1hcC5cblx0XHRcdFx0XHRcdCAoRWFjaCBwcm9wZXJ0eSBpbiB0aGUgbWFwIHByb2R1Y2VzIGl0cyBvd24gXCJ0d2VlblwiLikgKi9cblx0XHRcdFx0XHRcdHR3ZWVuc0NvbnRhaW5lciA9IHt9LFxuXHRcdFx0XHRcdFx0ZWxlbWVudFVuaXRDb252ZXJzaW9uRGF0YTtcblxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdCBFbGVtZW50IEluaXRcblx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRpZiAoRGF0YShlbGVtZW50KSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0VmVsb2NpdHkuaW5pdChlbGVtZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IE9wdGlvbjogRGVsYXlcblx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHQvKiBTaW5jZSBxdWV1ZTpmYWxzZSBkb2Vzbid0IHJlc3BlY3QgdGhlIGl0ZW0ncyBleGlzdGluZyBxdWV1ZSwgd2UgYXZvaWQgaW5qZWN0aW5nIGl0cyBkZWxheSBoZXJlIChpdCdzIHNldCBsYXRlciBvbikuICovXG5cdFx0XHRcdC8qIE5vdGU6IFZlbG9jaXR5IHJvbGxzIGl0cyBvd24gZGVsYXkgZnVuY3Rpb24gc2luY2UgalF1ZXJ5IGRvZXNuJ3QgaGF2ZSBhIHV0aWxpdHkgYWxpYXMgZm9yICQuZm4uZGVsYXkoKVxuXHRcdFx0XHQgKGFuZCB0aHVzIHJlcXVpcmVzIGpRdWVyeSBlbGVtZW50IGNyZWF0aW9uLCB3aGljaCB3ZSBhdm9pZCBzaW5jZSBpdHMgb3ZlcmhlYWQgaW5jbHVkZXMgRE9NIHF1ZXJ5aW5nKS4gKi9cblx0XHRcdFx0aWYgKHBhcnNlRmxvYXQob3B0cy5kZWxheSkgJiYgb3B0cy5xdWV1ZSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHQkLnF1ZXVlKGVsZW1lbnQsIG9wdHMucXVldWUsIGZ1bmN0aW9uKG5leHQsIGNsZWFyUXVldWUpIHtcblx0XHRcdFx0XHRcdGlmIChjbGVhclF1ZXVlID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdC8qIERvIG5vdCBjb250aW51ZSB3aXRoIGFuaW1hdGlvbiBxdWV1ZWluZy4gKi9cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIFRoaXMgaXMgYSBmbGFnIHVzZWQgdG8gaW5kaWNhdGUgdG8gdGhlIHVwY29taW5nIGNvbXBsZXRlQ2FsbCgpIGZ1bmN0aW9uIHRoYXQgdGhpcyBxdWV1ZSBlbnRyeSB3YXMgaW5pdGlhdGVkIGJ5IFZlbG9jaXR5LiBTZWUgY29tcGxldGVDYWxsKCkgZm9yIGZ1cnRoZXIgZGV0YWlscy4gKi9cblx0XHRcdFx0XHRcdFZlbG9jaXR5LnZlbG9jaXR5UXVldWVFbnRyeUZsYWcgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHQvKiBUaGUgZW5zdWluZyBxdWV1ZSBpdGVtICh3aGljaCBpcyBhc3NpZ25lZCB0byB0aGUgXCJuZXh0XCIgYXJndW1lbnQgdGhhdCAkLnF1ZXVlKCkgYXV0b21hdGljYWxseSBwYXNzZXMgaW4pIHdpbGwgYmUgdHJpZ2dlcmVkIGFmdGVyIGEgc2V0VGltZW91dCBkZWxheS5cblx0XHRcdFx0XHRcdCBUaGUgc2V0VGltZW91dCBpcyBzdG9yZWQgc28gdGhhdCBpdCBjYW4gYmUgc3ViamVjdGVkIHRvIGNsZWFyVGltZW91dCgpIGlmIHRoaXMgYW5pbWF0aW9uIGlzIHByZW1hdHVyZWx5IHN0b3BwZWQgdmlhIFZlbG9jaXR5J3MgXCJzdG9wXCIgY29tbWFuZCwgYW5kXG5cdFx0XHRcdFx0XHQgZGVsYXlCZWdpbi9kZWxheVRpbWUgaXMgdXNlZCB0byBlbnN1cmUgd2UgY2FuIFwicGF1c2VcIiBhbmQgXCJyZXN1bWVcIiBhIHR3ZWVuIHRoYXQgaXMgc3RpbGwgbWlkLWRlbGF5LiAqL1xuXG5cdFx0XHRcdFx0XHQvKiBUZW1wb3JhcmlseSBzdG9yZSBkZWxheWVkIGVsZW1lbnRzIHRvIGZhY2lsaXRlIGFjY2VzcyBmb3IgZ2xvYmFsIHBhdXNlL3Jlc3VtZSAqL1xuXHRcdFx0XHRcdFx0dmFyIGNhbGxJbmRleCA9IFZlbG9jaXR5LlN0YXRlLmRlbGF5ZWRFbGVtZW50cy5jb3VudCsrO1xuXHRcdFx0XHRcdFx0VmVsb2NpdHkuU3RhdGUuZGVsYXllZEVsZW1lbnRzW2NhbGxJbmRleF0gPSBlbGVtZW50O1xuXG5cdFx0XHRcdFx0XHR2YXIgZGVsYXlDb21wbGV0ZSA9IChmdW5jdGlvbihpbmRleCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0LyogQ2xlYXIgdGhlIHRlbXBvcmFyeSBlbGVtZW50ICovXG5cdFx0XHRcdFx0XHRcdFx0VmVsb2NpdHkuU3RhdGUuZGVsYXllZEVsZW1lbnRzW2luZGV4XSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogRmluYWxseSwgaXNzdWUgdGhlIGNhbGwgKi9cblx0XHRcdFx0XHRcdFx0XHRuZXh0KCk7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9KShjYWxsSW5kZXgpO1xuXG5cblx0XHRcdFx0XHRcdERhdGEoZWxlbWVudCkuZGVsYXlCZWdpbiA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cdFx0XHRcdFx0XHREYXRhKGVsZW1lbnQpLmRlbGF5ID0gcGFyc2VGbG9hdChvcHRzLmRlbGF5KTtcblx0XHRcdFx0XHRcdERhdGEoZWxlbWVudCkuZGVsYXlUaW1lciA9IHtcblx0XHRcdFx0XHRcdFx0c2V0VGltZW91dDogc2V0VGltZW91dChuZXh0LCBwYXJzZUZsb2F0KG9wdHMuZGVsYXkpKSxcblx0XHRcdFx0XHRcdFx0bmV4dDogZGVsYXlDb21wbGV0ZVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IE9wdGlvbjogRHVyYXRpb25cblx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHQvKiBTdXBwb3J0IGZvciBqUXVlcnkncyBuYW1lZCBkdXJhdGlvbnMuICovXG5cdFx0XHRcdHN3aXRjaCAob3B0cy5kdXJhdGlvbi50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRcdFx0XHRjYXNlIFwiZmFzdFwiOlxuXHRcdFx0XHRcdFx0b3B0cy5kdXJhdGlvbiA9IDIwMDtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSBcIm5vcm1hbFwiOlxuXHRcdFx0XHRcdFx0b3B0cy5kdXJhdGlvbiA9IERVUkFUSU9OX0RFRkFVTFQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGNhc2UgXCJzbG93XCI6XG5cdFx0XHRcdFx0XHRvcHRzLmR1cmF0aW9uID0gNjAwO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0LyogUmVtb3ZlIHRoZSBwb3RlbnRpYWwgXCJtc1wiIHN1ZmZpeCBhbmQgZGVmYXVsdCB0byAxIGlmIHRoZSB1c2VyIGlzIGF0dGVtcHRpbmcgdG8gc2V0IGEgZHVyYXRpb24gb2YgMCAoaW4gb3JkZXIgdG8gcHJvZHVjZSBhbiBpbW1lZGlhdGUgc3R5bGUgY2hhbmdlKS4gKi9cblx0XHRcdFx0XHRcdG9wdHMuZHVyYXRpb24gPSBwYXJzZUZsb2F0KG9wdHMuZHVyYXRpb24pIHx8IDE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdCBHbG9iYWwgT3B0aW9uOiBNb2NrXG5cdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0aWYgKFZlbG9jaXR5Lm1vY2sgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0LyogSW4gbW9jayBtb2RlLCBhbGwgYW5pbWF0aW9ucyBhcmUgZm9yY2VkIHRvIDFtcyBzbyB0aGF0IHRoZXkgb2NjdXIgaW1tZWRpYXRlbHkgdXBvbiB0aGUgbmV4dCByQUYgdGljay5cblx0XHRcdFx0XHQgQWx0ZXJuYXRpdmVseSwgYSBtdWx0aXBsaWVyIGNhbiBiZSBwYXNzZWQgaW4gdG8gdGltZSByZW1hcCBhbGwgZGVsYXlzIGFuZCBkdXJhdGlvbnMuICovXG5cdFx0XHRcdFx0aWYgKFZlbG9jaXR5Lm1vY2sgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdG9wdHMuZHVyYXRpb24gPSBvcHRzLmRlbGF5ID0gMTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0b3B0cy5kdXJhdGlvbiAqPSBwYXJzZUZsb2F0KFZlbG9jaXR5Lm1vY2spIHx8IDE7XG5cdFx0XHRcdFx0XHRvcHRzLmRlbGF5ICo9IHBhcnNlRmxvYXQoVmVsb2NpdHkubW9jaykgfHwgMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHQgT3B0aW9uOiBFYXNpbmdcblx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0b3B0cy5lYXNpbmcgPSBnZXRFYXNpbmcob3B0cy5lYXNpbmcsIG9wdHMuZHVyYXRpb24pO1xuXG5cdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdCBPcHRpb246IENhbGxiYWNrc1xuXHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHQvKiBDYWxsYmFja3MgbXVzdCBmdW5jdGlvbnMuIE90aGVyd2lzZSwgZGVmYXVsdCB0byBudWxsLiAqL1xuXHRcdFx0XHRpZiAob3B0cy5iZWdpbiAmJiAhVHlwZS5pc0Z1bmN0aW9uKG9wdHMuYmVnaW4pKSB7XG5cdFx0XHRcdFx0b3B0cy5iZWdpbiA9IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAob3B0cy5wcm9ncmVzcyAmJiAhVHlwZS5pc0Z1bmN0aW9uKG9wdHMucHJvZ3Jlc3MpKSB7XG5cdFx0XHRcdFx0b3B0cy5wcm9ncmVzcyA9IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAob3B0cy5jb21wbGV0ZSAmJiAhVHlwZS5pc0Z1bmN0aW9uKG9wdHMuY29tcGxldGUpKSB7XG5cdFx0XHRcdFx0b3B0cy5jb21wbGV0ZSA9IG51bGw7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdCBPcHRpb246IERpc3BsYXkgJiBWaXNpYmlsaXR5XG5cdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0LyogUmVmZXIgdG8gVmVsb2NpdHkncyBkb2N1bWVudGF0aW9uIChWZWxvY2l0eUpTLm9yZy8jZGlzcGxheUFuZFZpc2liaWxpdHkpIGZvciBhIGRlc2NyaXB0aW9uIG9mIHRoZSBkaXNwbGF5IGFuZCB2aXNpYmlsaXR5IG9wdGlvbnMnIGJlaGF2aW9yLiAqL1xuXHRcdFx0XHQvKiBOb3RlOiBXZSBzdHJpY3RseSBjaGVjayBmb3IgdW5kZWZpbmVkIGluc3RlYWQgb2YgZmFsc2luZXNzIGJlY2F1c2UgZGlzcGxheSBhY2NlcHRzIGFuIGVtcHR5IHN0cmluZyB2YWx1ZS4gKi9cblx0XHRcdFx0aWYgKG9wdHMuZGlzcGxheSAhPT0gdW5kZWZpbmVkICYmIG9wdHMuZGlzcGxheSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdG9wdHMuZGlzcGxheSA9IG9wdHMuZGlzcGxheS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdFx0XHQvKiBVc2VycyBjYW4gcGFzcyBpbiBhIHNwZWNpYWwgXCJhdXRvXCIgdmFsdWUgdG8gaW5zdHJ1Y3QgVmVsb2NpdHkgdG8gc2V0IHRoZSBlbGVtZW50IHRvIGl0cyBkZWZhdWx0IGRpc3BsYXkgdmFsdWUuICovXG5cdFx0XHRcdFx0aWYgKG9wdHMuZGlzcGxheSA9PT0gXCJhdXRvXCIpIHtcblx0XHRcdFx0XHRcdG9wdHMuZGlzcGxheSA9IFZlbG9jaXR5LkNTUy5WYWx1ZXMuZ2V0RGlzcGxheVR5cGUoZWxlbWVudCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKG9wdHMudmlzaWJpbGl0eSAhPT0gdW5kZWZpbmVkICYmIG9wdHMudmlzaWJpbGl0eSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdG9wdHMudmlzaWJpbGl0eSA9IG9wdHMudmlzaWJpbGl0eS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHQgT3B0aW9uOiBtb2JpbGVIQVxuXHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHQvKiBXaGVuIHNldCB0byB0cnVlLCBhbmQgaWYgdGhpcyBpcyBhIG1vYmlsZSBkZXZpY2UsIG1vYmlsZUhBIGF1dG9tYXRpY2FsbHkgZW5hYmxlcyBoYXJkd2FyZSBhY2NlbGVyYXRpb24gKHZpYSBhIG51bGwgdHJhbnNmb3JtIGhhY2spXG5cdFx0XHRcdCBvbiBhbmltYXRpbmcgZWxlbWVudHMuIEhBIGlzIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudCBhdCB0aGUgY29tcGxldGlvbiBvZiBpdHMgYW5pbWF0aW9uLiAqL1xuXHRcdFx0XHQvKiBOb3RlOiBBbmRyb2lkIEdpbmdlcmJyZWFkIGRvZXNuJ3Qgc3VwcG9ydCBIQS4gSWYgYSBudWxsIHRyYW5zZm9ybSBoYWNrIChtb2JpbGVIQSkgaXMgaW4gZmFjdCBzZXQsIGl0IHdpbGwgcHJldmVudCBvdGhlciB0cmFuZm9ybSBzdWJwcm9wZXJ0aWVzIGZyb20gdGFraW5nIGVmZmVjdC4gKi9cblx0XHRcdFx0LyogTm90ZTogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgdGhlIHVzZSBvZiBtb2JpbGVIQSBpbiBWZWxvY2l0eSdzIGRvY3VtZW50YXRpb246IFZlbG9jaXR5SlMub3JnLyNtb2JpbGVIQS4gKi9cblx0XHRcdFx0b3B0cy5tb2JpbGVIQSA9IChvcHRzLm1vYmlsZUhBICYmIFZlbG9jaXR5LlN0YXRlLmlzTW9iaWxlICYmICFWZWxvY2l0eS5TdGF0ZS5pc0dpbmdlcmJyZWFkKTtcblxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IFBhcnQgSUk6IFF1ZXVlaW5nXG5cdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHQvKiBXaGVuIGEgc2V0IG9mIGVsZW1lbnRzIGlzIHRhcmdldGVkIGJ5IGEgVmVsb2NpdHkgY2FsbCwgdGhlIHNldCBpcyBicm9rZW4gdXAgYW5kIGVhY2ggZWxlbWVudCBoYXMgdGhlIGN1cnJlbnQgVmVsb2NpdHkgY2FsbCBpbmRpdmlkdWFsbHkgcXVldWVkIG9udG8gaXQuXG5cdFx0XHRcdCBJbiB0aGlzIHdheSwgZWFjaCBlbGVtZW50J3MgZXhpc3RpbmcgcXVldWUgaXMgcmVzcGVjdGVkOyBzb21lIGVsZW1lbnRzIG1heSBhbHJlYWR5IGJlIGFuaW1hdGluZyBhbmQgYWNjb3JkaW5nbHkgc2hvdWxkIG5vdCBoYXZlIHRoaXMgY3VycmVudCBWZWxvY2l0eSBjYWxsIHRyaWdnZXJlZCBpbW1lZGlhdGVseS4gKi9cblx0XHRcdFx0LyogSW4gZWFjaCBxdWV1ZSwgdHdlZW4gZGF0YSBpcyBwcm9jZXNzZWQgZm9yIGVhY2ggYW5pbWF0aW5nIHByb3BlcnR5IHRoZW4gcHVzaGVkIG9udG8gdGhlIGNhbGwtd2lkZSBjYWxscyBhcnJheS4gV2hlbiB0aGUgbGFzdCBlbGVtZW50IGluIHRoZSBzZXQgaGFzIGhhZCBpdHMgdHdlZW5zIHByb2Nlc3NlZCxcblx0XHRcdFx0IHRoZSBjYWxsIGFycmF5IGlzIHB1c2hlZCB0byBWZWxvY2l0eS5TdGF0ZS5jYWxscyBmb3IgbGl2ZSBwcm9jZXNzaW5nIGJ5IHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdGljay4gKi9cblx0XHRcdFx0ZnVuY3Rpb24gYnVpbGRRdWV1ZShuZXh0KSB7XG5cdFx0XHRcdFx0dmFyIGRhdGEsIGxhc3RUd2VlbnNDb250YWluZXI7XG5cblx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdCBPcHRpb246IEJlZ2luXG5cdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHQvKiBUaGUgYmVnaW4gY2FsbGJhY2sgaXMgZmlyZWQgb25jZSBwZXIgY2FsbCAtLSBub3Qgb25jZSBwZXIgZWxlbWVuZXQgLS0gYW5kIGlzIHBhc3NlZCB0aGUgZnVsbCByYXcgRE9NIGVsZW1lbnQgc2V0IGFzIGJvdGggaXRzIGNvbnRleHQgYW5kIGl0cyBmaXJzdCBhcmd1bWVudC4gKi9cblx0XHRcdFx0XHRpZiAob3B0cy5iZWdpbiAmJiBlbGVtZW50c0luZGV4ID09PSAwKSB7XG5cdFx0XHRcdFx0XHQvKiBXZSB0aHJvdyBjYWxsYmFja3MgaW4gYSBzZXRUaW1lb3V0IHNvIHRoYXQgdGhyb3duIGVycm9ycyBkb24ndCBoYWx0IHRoZSBleGVjdXRpb24gb2YgVmVsb2NpdHkgaXRzZWxmLiAqL1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0b3B0cy5iZWdpbi5jYWxsKGVsZW1lbnRzLCBlbGVtZW50cyk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0XHRcdFx0XHR9LCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHQgVHdlZW4gRGF0YSBDb25zdHJ1Y3Rpb24gKGZvciBTY3JvbGwpXG5cdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0LyogTm90ZTogSW4gb3JkZXIgdG8gYmUgc3ViamVjdGVkIHRvIGNoYWluaW5nIGFuZCBhbmltYXRpb24gb3B0aW9ucywgc2Nyb2xsJ3MgdHdlZW5pbmcgaXMgcm91dGVkIHRocm91Z2ggVmVsb2NpdHkgYXMgaWYgaXQgd2VyZSBhIHN0YW5kYXJkIENTUyBwcm9wZXJ0eSBhbmltYXRpb24uICovXG5cdFx0XHRcdFx0aWYgKGFjdGlvbiA9PT0gXCJzY3JvbGxcIikge1xuXHRcdFx0XHRcdFx0LyogVGhlIHNjcm9sbCBhY3Rpb24gdW5pcXVlbHkgdGFrZXMgYW4gb3B0aW9uYWwgXCJvZmZzZXRcIiBvcHRpb24gLS0gc3BlY2lmaWVkIGluIHBpeGVscyAtLSB0aGF0IG9mZnNldHMgdGhlIHRhcmdldGVkIHNjcm9sbCBwb3NpdGlvbi4gKi9cblx0XHRcdFx0XHRcdHZhciBzY3JvbGxEaXJlY3Rpb24gPSAoL154JC9pLnRlc3Qob3B0cy5heGlzKSA/IFwiTGVmdFwiIDogXCJUb3BcIiksXG5cdFx0XHRcdFx0XHRcdFx0c2Nyb2xsT2Zmc2V0ID0gcGFyc2VGbG9hdChvcHRzLm9mZnNldCkgfHwgMCxcblx0XHRcdFx0XHRcdFx0XHRzY3JvbGxQb3NpdGlvbkN1cnJlbnQsXG5cdFx0XHRcdFx0XHRcdFx0c2Nyb2xsUG9zaXRpb25DdXJyZW50QWx0ZXJuYXRlLFxuXHRcdFx0XHRcdFx0XHRcdHNjcm9sbFBvc2l0aW9uRW5kO1xuXG5cdFx0XHRcdFx0XHQvKiBTY3JvbGwgYWxzbyB1bmlxdWVseSB0YWtlcyBhbiBvcHRpb25hbCBcImNvbnRhaW5lclwiIG9wdGlvbiwgd2hpY2ggaW5kaWNhdGVzIHRoZSBwYXJlbnQgZWxlbWVudCB0aGF0IHNob3VsZCBiZSBzY3JvbGxlZCAtLVxuXHRcdFx0XHRcdFx0IGFzIG9wcG9zZWQgdG8gdGhlIGJyb3dzZXIgd2luZG93IGl0c2VsZi4gVGhpcyBpcyB1c2VmdWwgZm9yIHNjcm9sbGluZyB0b3dhcmQgYW4gZWxlbWVudCB0aGF0J3MgaW5zaWRlIGFuIG92ZXJmbG93aW5nIHBhcmVudCBlbGVtZW50LiAqL1xuXHRcdFx0XHRcdFx0aWYgKG9wdHMuY29udGFpbmVyKSB7XG5cdFx0XHRcdFx0XHRcdC8qIEVuc3VyZSB0aGF0IGVpdGhlciBhIGpRdWVyeSBvYmplY3Qgb3IgYSByYXcgRE9NIGVsZW1lbnQgd2FzIHBhc3NlZCBpbi4gKi9cblx0XHRcdFx0XHRcdFx0aWYgKFR5cGUuaXNXcmFwcGVkKG9wdHMuY29udGFpbmVyKSB8fCBUeXBlLmlzTm9kZShvcHRzLmNvbnRhaW5lcikpIHtcblx0XHRcdFx0XHRcdFx0XHQvKiBFeHRyYWN0IHRoZSByYXcgRE9NIGVsZW1lbnQgZnJvbSB0aGUgalF1ZXJ5IHdyYXBwZXIuICovXG5cdFx0XHRcdFx0XHRcdFx0b3B0cy5jb250YWluZXIgPSBvcHRzLmNvbnRhaW5lclswXSB8fCBvcHRzLmNvbnRhaW5lcjtcblx0XHRcdFx0XHRcdFx0XHQvKiBOb3RlOiBVbmxpa2Ugb3RoZXIgcHJvcGVydGllcyBpbiBWZWxvY2l0eSwgdGhlIGJyb3dzZXIncyBzY3JvbGwgcG9zaXRpb24gaXMgbmV2ZXIgY2FjaGVkIHNpbmNlIGl0IHNvIGZyZXF1ZW50bHkgY2hhbmdlc1xuXHRcdFx0XHRcdFx0XHRcdCAoZHVlIHRvIHRoZSB1c2VyJ3MgbmF0dXJhbCBpbnRlcmFjdGlvbiB3aXRoIHRoZSBwYWdlKS4gKi9cblx0XHRcdFx0XHRcdFx0XHRzY3JvbGxQb3NpdGlvbkN1cnJlbnQgPSBvcHRzLmNvbnRhaW5lcltcInNjcm9sbFwiICsgc2Nyb2xsRGlyZWN0aW9uXTsgLyogR0VUICovXG5cblx0XHRcdFx0XHRcdFx0XHQvKiAkLnBvc2l0aW9uKCkgdmFsdWVzIGFyZSByZWxhdGl2ZSB0byB0aGUgY29udGFpbmVyJ3MgY3VycmVudGx5IHZpZXdhYmxlIGFyZWEgKHdpdGhvdXQgdGFraW5nIGludG8gYWNjb3VudCB0aGUgY29udGFpbmVyJ3MgdHJ1ZSBkaW1lbnNpb25zXG5cdFx0XHRcdFx0XHRcdFx0IC0tIHNheSwgZm9yIGV4YW1wbGUsIGlmIHRoZSBjb250YWluZXIgd2FzIG5vdCBvdmVyZmxvd2luZykuIFRodXMsIHRoZSBzY3JvbGwgZW5kIHZhbHVlIGlzIHRoZSBzdW0gb2YgdGhlIGNoaWxkIGVsZW1lbnQncyBwb3NpdGlvbiAqYW5kKlxuXHRcdFx0XHRcdFx0XHRcdCB0aGUgc2Nyb2xsIGNvbnRhaW5lcidzIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uLiAqL1xuXHRcdFx0XHRcdFx0XHRcdHNjcm9sbFBvc2l0aW9uRW5kID0gKHNjcm9sbFBvc2l0aW9uQ3VycmVudCArICQoZWxlbWVudCkucG9zaXRpb24oKVtzY3JvbGxEaXJlY3Rpb24udG9Mb3dlckNhc2UoKV0pICsgc2Nyb2xsT2Zmc2V0OyAvKiBHRVQgKi9cblx0XHRcdFx0XHRcdFx0XHQvKiBJZiBhIHZhbHVlIG90aGVyIHRoYW4gYSBqUXVlcnkgb2JqZWN0IG9yIGEgcmF3IERPTSBlbGVtZW50IHdhcyBwYXNzZWQgaW4sIGRlZmF1bHQgdG8gbnVsbCBzbyB0aGF0IHRoaXMgb3B0aW9uIGlzIGlnbm9yZWQuICovXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0b3B0cy5jb250YWluZXIgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvKiBJZiB0aGUgd2luZG93IGl0c2VsZiBpcyBiZWluZyBzY3JvbGxlZCAtLSBub3QgYSBjb250YWluaW5nIGVsZW1lbnQgLS0gcGVyZm9ybSBhIGxpdmUgc2Nyb2xsIHBvc2l0aW9uIGxvb2t1cCB1c2luZ1xuXHRcdFx0XHRcdFx0XHQgdGhlIGFwcHJvcHJpYXRlIGNhY2hlZCBwcm9wZXJ0eSBuYW1lcyAod2hpY2ggZGlmZmVyIGJhc2VkIG9uIGJyb3dzZXIgdHlwZSkuICovXG5cdFx0XHRcdFx0XHRcdHNjcm9sbFBvc2l0aW9uQ3VycmVudCA9IFZlbG9jaXR5LlN0YXRlLnNjcm9sbEFuY2hvcltWZWxvY2l0eS5TdGF0ZVtcInNjcm9sbFByb3BlcnR5XCIgKyBzY3JvbGxEaXJlY3Rpb25dXTsgLyogR0VUICovXG5cdFx0XHRcdFx0XHRcdC8qIFdoZW4gc2Nyb2xsaW5nIHRoZSBicm93c2VyIHdpbmRvdywgY2FjaGUgdGhlIGFsdGVybmF0ZSBheGlzJ3MgY3VycmVudCB2YWx1ZSBzaW5jZSB3aW5kb3cuc2Nyb2xsVG8oKSBkb2Vzbid0IGxldCB1cyBjaGFuZ2Ugb25seSBvbmUgdmFsdWUgYXQgYSB0aW1lLiAqL1xuXHRcdFx0XHRcdFx0XHRzY3JvbGxQb3NpdGlvbkN1cnJlbnRBbHRlcm5hdGUgPSBWZWxvY2l0eS5TdGF0ZS5zY3JvbGxBbmNob3JbVmVsb2NpdHkuU3RhdGVbXCJzY3JvbGxQcm9wZXJ0eVwiICsgKHNjcm9sbERpcmVjdGlvbiA9PT0gXCJMZWZ0XCIgPyBcIlRvcFwiIDogXCJMZWZ0XCIpXV07IC8qIEdFVCAqL1xuXG5cdFx0XHRcdFx0XHRcdC8qIFVubGlrZSAkLnBvc2l0aW9uKCksICQub2Zmc2V0KCkgdmFsdWVzIGFyZSByZWxhdGl2ZSB0byB0aGUgYnJvd3NlciB3aW5kb3cncyB0cnVlIGRpbWVuc2lvbnMgLS0gbm90IG1lcmVseSBpdHMgY3VycmVudGx5IHZpZXdhYmxlIGFyZWEgLS1cblx0XHRcdFx0XHRcdFx0IGFuZCB0aGVyZWZvcmUgZW5kIHZhbHVlcyBkbyBub3QgbmVlZCB0byBiZSBjb21wb3VuZGVkIG9udG8gY3VycmVudCB2YWx1ZXMuICovXG5cdFx0XHRcdFx0XHRcdHNjcm9sbFBvc2l0aW9uRW5kID0gJChlbGVtZW50KS5vZmZzZXQoKVtzY3JvbGxEaXJlY3Rpb24udG9Mb3dlckNhc2UoKV0gKyBzY3JvbGxPZmZzZXQ7IC8qIEdFVCAqL1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBTaW5jZSB0aGVyZSdzIG9ubHkgb25lIGZvcm1hdCB0aGF0IHNjcm9sbCdzIGFzc29jaWF0ZWQgdHdlZW5zQ29udGFpbmVyIGNhbiB0YWtlLCB3ZSBjcmVhdGUgaXQgbWFudWFsbHkuICovXG5cdFx0XHRcdFx0XHR0d2VlbnNDb250YWluZXIgPSB7XG5cdFx0XHRcdFx0XHRcdHNjcm9sbDoge1xuXHRcdFx0XHRcdFx0XHRcdHJvb3RQcm9wZXJ0eVZhbHVlOiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlOiBzY3JvbGxQb3NpdGlvbkN1cnJlbnQsXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudFZhbHVlOiBzY3JvbGxQb3NpdGlvbkN1cnJlbnQsXG5cdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWU6IHNjcm9sbFBvc2l0aW9uRW5kLFxuXHRcdFx0XHRcdFx0XHRcdHVuaXRUeXBlOiBcIlwiLFxuXHRcdFx0XHRcdFx0XHRcdGVhc2luZzogb3B0cy5lYXNpbmcsXG5cdFx0XHRcdFx0XHRcdFx0c2Nyb2xsRGF0YToge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udGFpbmVyOiBvcHRzLmNvbnRhaW5lcixcblx0XHRcdFx0XHRcdFx0XHRcdGRpcmVjdGlvbjogc2Nyb2xsRGlyZWN0aW9uLFxuXHRcdFx0XHRcdFx0XHRcdFx0YWx0ZXJuYXRlVmFsdWU6IHNjcm9sbFBvc2l0aW9uQ3VycmVudEFsdGVybmF0ZVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZWxlbWVudDogZWxlbWVudFxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0aWYgKFZlbG9jaXR5LmRlYnVnKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwidHdlZW5zQ29udGFpbmVyIChzY3JvbGwpOiBcIiwgdHdlZW5zQ29udGFpbmVyLnNjcm9sbCwgZWxlbWVudCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdCBUd2VlbiBEYXRhIENvbnN0cnVjdGlvbiAoZm9yIFJldmVyc2UpXG5cdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHQvKiBSZXZlcnNlIGFjdHMgbGlrZSBhIFwic3RhcnRcIiBhY3Rpb24gaW4gdGhhdCBhIHByb3BlcnR5IG1hcCBpcyBhbmltYXRlZCB0b3dhcmQuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXNcblx0XHRcdFx0XHRcdCB0aGF0IHRoZSBwcm9wZXJ0eSBtYXAgdXNlZCBmb3IgcmV2ZXJzZSBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgbWFwIHVzZWQgaW4gdGhlIHByZXZpb3VzIGNhbGwuIFRodXMsIHdlIG1hbmlwdWxhdGVcblx0XHRcdFx0XHRcdCB0aGUgcHJldmlvdXMgY2FsbCB0byBjb25zdHJ1Y3Qgb3VyIG5ldyBtYXA6IHVzZSB0aGUgcHJldmlvdXMgbWFwJ3MgZW5kIHZhbHVlcyBhcyBvdXIgbmV3IG1hcCdzIHN0YXJ0IHZhbHVlcy4gQ29weSBvdmVyIGFsbCBvdGhlciBkYXRhLiAqL1xuXHRcdFx0XHRcdFx0LyogTm90ZTogUmV2ZXJzZSBjYW4gYmUgZGlyZWN0bHkgY2FsbGVkIHZpYSB0aGUgXCJyZXZlcnNlXCIgcGFyYW1ldGVyLCBvciBpdCBjYW4gYmUgaW5kaXJlY3RseSB0cmlnZ2VyZWQgdmlhIHRoZSBsb29wIG9wdGlvbi4gKExvb3BzIGFyZSBjb21wb3NlZCBvZiBtdWx0aXBsZSByZXZlcnNlcy4pICovXG5cdFx0XHRcdFx0XHQvKiBOb3RlOiBSZXZlcnNlIGNhbGxzIGRvIG5vdCBuZWVkIHRvIGJlIGNvbnNlY3V0aXZlbHkgY2hhaW5lZCBvbnRvIGEgY3VycmVudGx5LWFuaW1hdGluZyBlbGVtZW50IGluIG9yZGVyIHRvIG9wZXJhdGUgb24gY2FjaGVkIHZhbHVlcztcblx0XHRcdFx0XHRcdCB0aGVyZSBpcyBubyBoYXJtIHRvIHJldmVyc2UgYmVpbmcgY2FsbGVkIG9uIGEgcG90ZW50aWFsbHkgc3RhbGUgZGF0YSBjYWNoZSBzaW5jZSByZXZlcnNlJ3MgYmVoYXZpb3IgaXMgc2ltcGx5IGRlZmluZWRcblx0XHRcdFx0XHRcdCBhcyByZXZlcnRpbmcgdG8gdGhlIGVsZW1lbnQncyB2YWx1ZXMgYXMgdGhleSB3ZXJlIHByaW9yIHRvIHRoZSBwcmV2aW91cyAqVmVsb2NpdHkqIGNhbGwuICovXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChhY3Rpb24gPT09IFwicmV2ZXJzZVwiKSB7XG5cdFx0XHRcdFx0XHRkYXRhID0gRGF0YShlbGVtZW50KTtcblxuXHRcdFx0XHRcdFx0LyogQWJvcnQgaWYgdGhlcmUgaXMgbm8gcHJpb3IgYW5pbWF0aW9uIGRhdGEgdG8gcmV2ZXJzZSB0by4gKi9cblx0XHRcdFx0XHRcdGlmICghZGF0YSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICghZGF0YS50d2VlbnNDb250YWluZXIpIHtcblx0XHRcdFx0XHRcdFx0LyogRGVxdWV1ZSB0aGUgZWxlbWVudCBzbyB0aGF0IHRoaXMgcXVldWUgZW50cnkgcmVsZWFzZXMgaXRzZWxmIGltbWVkaWF0ZWx5LCBhbGxvd2luZyBzdWJzZXF1ZW50IHF1ZXVlIGVudHJpZXMgdG8gcnVuLiAqL1xuXHRcdFx0XHRcdFx0XHQkLmRlcXVldWUoZWxlbWVudCwgb3B0cy5xdWV1ZSk7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHQgT3B0aW9ucyBQYXJzaW5nXG5cdFx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHRcdFx0LyogSWYgdGhlIGVsZW1lbnQgd2FzIGhpZGRlbiB2aWEgdGhlIGRpc3BsYXkgb3B0aW9uIGluIHRoZSBwcmV2aW91cyBjYWxsLFxuXHRcdFx0XHRcdFx0XHQgcmV2ZXJ0IGRpc3BsYXkgdG8gXCJhdXRvXCIgcHJpb3IgdG8gcmV2ZXJzYWwgc28gdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGFnYWluLiAqL1xuXHRcdFx0XHRcdFx0XHRpZiAoZGF0YS5vcHRzLmRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5vcHRzLmRpc3BsYXkgPSBcImF1dG9cIjtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdGlmIChkYXRhLm9wdHMudmlzaWJpbGl0eSA9PT0gXCJoaWRkZW5cIikge1xuXHRcdFx0XHRcdFx0XHRcdGRhdGEub3B0cy52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvKiBJZiB0aGUgbG9vcCBvcHRpb24gd2FzIHNldCBpbiB0aGUgcHJldmlvdXMgY2FsbCwgZGlzYWJsZSBpdCBzbyB0aGF0IFwicmV2ZXJzZVwiIGNhbGxzIGFyZW4ndCByZWN1cnNpdmVseSBnZW5lcmF0ZWQuXG5cdFx0XHRcdFx0XHRcdCBGdXJ0aGVyLCByZW1vdmUgdGhlIHByZXZpb3VzIGNhbGwncyBjYWxsYmFjayBvcHRpb25zOyB0eXBpY2FsbHksIHVzZXJzIGRvIG5vdCB3YW50IHRoZXNlIHRvIGJlIHJlZmlyZWQuICovXG5cdFx0XHRcdFx0XHRcdGRhdGEub3B0cy5sb29wID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdGRhdGEub3B0cy5iZWdpbiA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdGRhdGEub3B0cy5jb21wbGV0ZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0LyogU2luY2Ugd2UncmUgZXh0ZW5kaW5nIGFuIG9wdHMgb2JqZWN0IHRoYXQgaGFzIGFscmVhZHkgYmVlbiBleHRlbmRlZCB3aXRoIHRoZSBkZWZhdWx0cyBvcHRpb25zIG9iamVjdCxcblx0XHRcdFx0XHRcdFx0IHdlIHJlbW92ZSBub24tZXhwbGljaXRseS1kZWZpbmVkIHByb3BlcnRpZXMgdGhhdCBhcmUgYXV0by1hc3NpZ25lZCB2YWx1ZXMuICovXG5cdFx0XHRcdFx0XHRcdGlmICghb3B0aW9ucy5lYXNpbmcpIHtcblx0XHRcdFx0XHRcdFx0XHRkZWxldGUgb3B0cy5lYXNpbmc7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuZHVyYXRpb24pIHtcblx0XHRcdFx0XHRcdFx0XHRkZWxldGUgb3B0cy5kdXJhdGlvbjtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8qIFRoZSBvcHRzIG9iamVjdCB1c2VkIGZvciByZXZlcnNhbCBpcyBhbiBleHRlbnNpb24gb2YgdGhlIG9wdGlvbnMgb2JqZWN0IG9wdGlvbmFsbHkgcGFzc2VkIGludG8gdGhpc1xuXHRcdFx0XHRcdFx0XHQgcmV2ZXJzZSBjYWxsIHBsdXMgdGhlIG9wdGlvbnMgdXNlZCBpbiB0aGUgcHJldmlvdXMgVmVsb2NpdHkgY2FsbC4gKi9cblx0XHRcdFx0XHRcdFx0b3B0cyA9ICQuZXh0ZW5kKHt9LCBkYXRhLm9wdHMsIG9wdHMpO1xuXG5cdFx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0XHRcdCBUd2VlbnMgQ29udGFpbmVyIFJlY29uc3RydWN0aW9uXG5cdFx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdC8qIENyZWF0ZSBhIGRlZXB5IGNvcHkgKGluZGljYXRlZCB2aWEgdGhlIHRydWUgZmxhZykgb2YgdGhlIHByZXZpb3VzIGNhbGwncyB0d2VlbnNDb250YWluZXIuICovXG5cdFx0XHRcdFx0XHRcdGxhc3RUd2VlbnNDb250YWluZXIgPSAkLmV4dGVuZCh0cnVlLCB7fSwgZGF0YSA/IGRhdGEudHdlZW5zQ29udGFpbmVyIDogbnVsbCk7XG5cblx0XHRcdFx0XHRcdFx0LyogTWFuaXB1bGF0ZSB0aGUgcHJldmlvdXMgdHdlZW5zQ29udGFpbmVyIGJ5IHJlcGxhY2luZyBpdHMgZW5kIHZhbHVlcyBhbmQgY3VycmVudFZhbHVlcyB3aXRoIGl0cyBzdGFydCB2YWx1ZXMuICovXG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGxhc3RUd2VlbiBpbiBsYXN0VHdlZW5zQ29udGFpbmVyKSB7XG5cdFx0XHRcdFx0XHRcdFx0LyogSW4gYWRkaXRpb24gdG8gdHdlZW4gZGF0YSwgdHdlZW5zQ29udGFpbmVycyBjb250YWluIGFuIGVsZW1lbnQgcHJvcGVydHkgdGhhdCB3ZSBpZ25vcmUgaGVyZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRpZiAobGFzdFR3ZWVuc0NvbnRhaW5lci5oYXNPd25Qcm9wZXJ0eShsYXN0VHdlZW4pICYmIGxhc3RUd2VlbiAhPT0gXCJlbGVtZW50XCIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBsYXN0U3RhcnRWYWx1ZSA9IGxhc3RUd2VlbnNDb250YWluZXJbbGFzdFR3ZWVuXS5zdGFydFZhbHVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRsYXN0VHdlZW5zQ29udGFpbmVyW2xhc3RUd2Vlbl0uc3RhcnRWYWx1ZSA9IGxhc3RUd2VlbnNDb250YWluZXJbbGFzdFR3ZWVuXS5jdXJyZW50VmFsdWUgPSBsYXN0VHdlZW5zQ29udGFpbmVyW2xhc3RUd2Vlbl0uZW5kVmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRsYXN0VHdlZW5zQ29udGFpbmVyW2xhc3RUd2Vlbl0uZW5kVmFsdWUgPSBsYXN0U3RhcnRWYWx1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0LyogRWFzaW5nIGlzIHRoZSBvbmx5IG9wdGlvbiB0aGF0IGVtYmVkcyBpbnRvIHRoZSBpbmRpdmlkdWFsIHR3ZWVuIGRhdGEgKHNpbmNlIGl0IGNhbiBiZSBkZWZpbmVkIG9uIGEgcGVyLXByb3BlcnR5IGJhc2lzKS5cblx0XHRcdFx0XHRcdFx0XHRcdCBBY2NvcmRpbmdseSwgZXZlcnkgcHJvcGVydHkncyBlYXNpbmcgdmFsdWUgbXVzdCBiZSB1cGRhdGVkIHdoZW4gYW4gb3B0aW9ucyBvYmplY3QgaXMgcGFzc2VkIGluIHdpdGggYSByZXZlcnNlIGNhbGwuXG5cdFx0XHRcdFx0XHRcdFx0XHQgVGhlIHNpZGUgZWZmZWN0IG9mIHRoaXMgZXh0ZW5zaWJpbGl0eSBpcyB0aGF0IGFsbCBwZXItcHJvcGVydHkgZWFzaW5nIHZhbHVlcyBhcmUgZm9yY2VmdWxseSByZXNldCB0byB0aGUgbmV3IHZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCFUeXBlLmlzRW1wdHlPYmplY3Qob3B0aW9ucykpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bGFzdFR3ZWVuc0NvbnRhaW5lcltsYXN0VHdlZW5dLmVhc2luZyA9IG9wdHMuZWFzaW5nO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoVmVsb2NpdHkuZGVidWcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJyZXZlcnNlIHR3ZWVuc0NvbnRhaW5lciAoXCIgKyBsYXN0VHdlZW4gKyBcIik6IFwiICsgSlNPTi5zdHJpbmdpZnkobGFzdFR3ZWVuc0NvbnRhaW5lcltsYXN0VHdlZW5dKSwgZWxlbWVudCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0dHdlZW5zQ29udGFpbmVyID0gbGFzdFR3ZWVuc0NvbnRhaW5lcjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0XHQgVHdlZW4gRGF0YSBDb25zdHJ1Y3Rpb24gKGZvciBTdGFydClcblx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYWN0aW9uID09PSBcInN0YXJ0XCIpIHtcblxuXHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdCBWYWx1ZSBUcmFuc2ZlcnJpbmdcblx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHQvKiBJZiB0aGlzIHF1ZXVlIGVudHJ5IGZvbGxvd3MgYSBwcmV2aW91cyBWZWxvY2l0eS1pbml0aWF0ZWQgcXVldWUgZW50cnkgKmFuZCogaWYgdGhpcyBlbnRyeSB3YXMgY3JlYXRlZFxuXHRcdFx0XHRcdFx0IHdoaWxlIHRoZSBlbGVtZW50IHdhcyBpbiB0aGUgcHJvY2VzcyBvZiBiZWluZyBhbmltYXRlZCBieSBWZWxvY2l0eSwgdGhlbiB0aGlzIGN1cnJlbnQgY2FsbCBpcyBzYWZlIHRvIHVzZVxuXHRcdFx0XHRcdFx0IHRoZSBlbmQgdmFsdWVzIGZyb20gdGhlIHByaW9yIGNhbGwgYXMgaXRzIHN0YXJ0IHZhbHVlcy4gVmVsb2NpdHkgYXR0ZW1wdHMgdG8gcGVyZm9ybSB0aGlzIHZhbHVlIHRyYW5zZmVyXG5cdFx0XHRcdFx0XHQgcHJvY2VzcyB3aGVuZXZlciBwb3NzaWJsZSBpbiBvcmRlciB0byBhdm9pZCByZXF1ZXJ5aW5nIHRoZSBET00uICovXG5cdFx0XHRcdFx0XHQvKiBJZiB2YWx1ZXMgYXJlbid0IHRyYW5zZmVycmVkIGZyb20gYSBwcmlvciBjYWxsIGFuZCBzdGFydCB2YWx1ZXMgd2VyZSBub3QgZm9yY2VmZWQgYnkgdGhlIHVzZXIgKG1vcmUgb24gdGhpcyBiZWxvdyksXG5cdFx0XHRcdFx0XHQgdGhlbiB0aGUgRE9NIGlzIHF1ZXJpZWQgZm9yIHRoZSBlbGVtZW50J3MgY3VycmVudCB2YWx1ZXMgYXMgYSBsYXN0IHJlc29ydC4gKi9cblx0XHRcdFx0XHRcdC8qIE5vdGU6IENvbnZlcnNlbHksIGFuaW1hdGlvbiByZXZlcnNhbCAoYW5kIGxvb3BpbmcpICphbHdheXMqIHBlcmZvcm0gaW50ZXItY2FsbCB2YWx1ZSB0cmFuc2ZlcnM7IHRoZXkgbmV2ZXIgcmVxdWVyeSB0aGUgRE9NLiAqL1xuXG5cdFx0XHRcdFx0XHRkYXRhID0gRGF0YShlbGVtZW50KTtcblxuXHRcdFx0XHRcdFx0LyogVGhlIHBlci1lbGVtZW50IGlzQW5pbWF0aW5nIGZsYWcgaXMgdXNlZCB0byBpbmRpY2F0ZSB3aGV0aGVyIGl0J3Mgc2FmZSAoaS5lLiB0aGUgZGF0YSBpc24ndCBzdGFsZSlcblx0XHRcdFx0XHRcdCB0byB0cmFuc2ZlciBvdmVyIGVuZCB2YWx1ZXMgdG8gdXNlIGFzIHN0YXJ0IHZhbHVlcy4gSWYgaXQncyBzZXQgdG8gdHJ1ZSBhbmQgdGhlcmUgaXMgYSBwcmV2aW91c1xuXHRcdFx0XHRcdFx0IFZlbG9jaXR5IGNhbGwgdG8gcHVsbCB2YWx1ZXMgZnJvbSwgZG8gc28uICovXG5cdFx0XHRcdFx0XHRpZiAoZGF0YSAmJiBkYXRhLnR3ZWVuc0NvbnRhaW5lciAmJiBkYXRhLmlzQW5pbWF0aW5nID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdGxhc3RUd2VlbnNDb250YWluZXIgPSBkYXRhLnR3ZWVuc0NvbnRhaW5lcjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0IFR3ZWVuIERhdGEgQ2FsY3VsYXRpb25cblx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHRcdC8qIFRoaXMgZnVuY3Rpb24gcGFyc2VzIHByb3BlcnR5IGRhdGEgYW5kIGRlZmF1bHRzIGVuZFZhbHVlLCBlYXNpbmcsIGFuZCBzdGFydFZhbHVlIGFzIGFwcHJvcHJpYXRlLiAqL1xuXHRcdFx0XHRcdFx0LyogUHJvcGVydHkgbWFwIHZhbHVlcyBjYW4gZWl0aGVyIHRha2UgdGhlIGZvcm0gb2YgMSkgYSBzaW5nbGUgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBlbmQgdmFsdWUsXG5cdFx0XHRcdFx0XHQgb3IgMikgYW4gYXJyYXkgaW4gdGhlIGZvcm0gb2YgWyBlbmRWYWx1ZSwgWywgZWFzaW5nXSBbLCBzdGFydFZhbHVlXSBdLlxuXHRcdFx0XHRcdFx0IFRoZSBvcHRpb25hbCB0aGlyZCBwYXJhbWV0ZXIgaXMgYSBmb3JjZWZlZCBzdGFydFZhbHVlIHRvIGJlIHVzZWQgaW5zdGVhZCBvZiBxdWVyeWluZyB0aGUgRE9NIGZvclxuXHRcdFx0XHRcdFx0IHRoZSBlbGVtZW50J3MgY3VycmVudCB2YWx1ZS4gUmVhZCBWZWxvY2l0eSdzIGRvY21lbnRhdGlvbiB0byBsZWFybiBtb3JlIGFib3V0IGZvcmNlZmVlZGluZzogVmVsb2NpdHlKUy5vcmcvI2ZvcmNlZmVlZGluZyAqL1xuXHRcdFx0XHRcdFx0dmFyIHBhcnNlUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlRGF0YSwgc2tpcFJlc29sdmluZ0Vhc2luZykge1xuXHRcdFx0XHRcdFx0XHR2YXIgZW5kVmFsdWUsIGVhc2luZywgc3RhcnRWYWx1ZTtcblxuXHRcdFx0XHRcdFx0XHQvKiBJZiB3ZSBoYXZlIGEgZnVuY3Rpb24gYXMgdGhlIG1haW4gYXJndW1lbnQgdGhlbiByZXNvbHZlIGl0IGZpcnN0LCBpbiBjYXNlIGl0IHJldHVybnMgYW4gYXJyYXkgdGhhdCBuZWVkcyB0byBiZSBzcGxpdCAqL1xuXHRcdFx0XHRcdFx0XHRpZiAoVHlwZS5pc0Z1bmN0aW9uKHZhbHVlRGF0YSkpIHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZURhdGEgPSB2YWx1ZURhdGEuY2FsbChlbGVtZW50LCBlbGVtZW50QXJyYXlJbmRleCwgZWxlbWVudHNMZW5ndGgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0LyogSGFuZGxlIHRoZSBhcnJheSBmb3JtYXQsIHdoaWNoIGNhbiBiZSBzdHJ1Y3R1cmVkIGFzIG9uZSBvZiB0aHJlZSBwb3RlbnRpYWwgb3ZlcmxvYWRzOlxuXHRcdFx0XHRcdFx0XHQgQSkgWyBlbmRWYWx1ZSwgZWFzaW5nLCBzdGFydFZhbHVlIF0sIEIpIFsgZW5kVmFsdWUsIGVhc2luZyBdLCBvciBDKSBbIGVuZFZhbHVlLCBzdGFydFZhbHVlIF0gKi9cblx0XHRcdFx0XHRcdFx0aWYgKFR5cGUuaXNBcnJheSh2YWx1ZURhdGEpKSB7XG5cdFx0XHRcdFx0XHRcdFx0LyogZW5kVmFsdWUgaXMgYWx3YXlzIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBhcnJheS4gRG9uJ3QgYm90aGVyIHZhbGlkYXRpbmcgZW5kVmFsdWUncyB2YWx1ZSBub3dcblx0XHRcdFx0XHRcdFx0XHQgc2luY2UgdGhlIGVuc3VpbmcgcHJvcGVydHkgY3ljbGluZyBsb2dpYyBkb2VzIHRoYXQuICovXG5cdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSB2YWx1ZURhdGFbMF07XG5cblx0XHRcdFx0XHRcdFx0XHQvKiBUd28taXRlbSBhcnJheSBmb3JtYXQ6IElmIHRoZSBzZWNvbmQgaXRlbSBpcyBhIG51bWJlciwgZnVuY3Rpb24sIG9yIGhleCBzdHJpbmcsIHRyZWF0IGl0IGFzIGFcblx0XHRcdFx0XHRcdFx0XHQgc3RhcnQgdmFsdWUgc2luY2UgZWFzaW5ncyBjYW4gb25seSBiZSBub24taGV4IHN0cmluZ3Mgb3IgYXJyYXlzLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmICgoIVR5cGUuaXNBcnJheSh2YWx1ZURhdGFbMV0pICYmIC9eW1xcZC1dLy50ZXN0KHZhbHVlRGF0YVsxXSkpIHx8IFR5cGUuaXNGdW5jdGlvbih2YWx1ZURhdGFbMV0pIHx8IENTUy5SZWdFeC5pc0hleC50ZXN0KHZhbHVlRGF0YVsxXSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0VmFsdWUgPSB2YWx1ZURhdGFbMV07XG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBUd28gb3IgdGhyZWUtaXRlbSBhcnJheTogSWYgdGhlIHNlY29uZCBpdGVtIGlzIGEgbm9uLWhleCBzdHJpbmcgZWFzaW5nIG5hbWUgb3IgYW4gYXJyYXksIHRyZWF0IGl0IGFzIGFuIGVhc2luZy4gKi9cblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKChUeXBlLmlzU3RyaW5nKHZhbHVlRGF0YVsxXSkgJiYgIUNTUy5SZWdFeC5pc0hleC50ZXN0KHZhbHVlRGF0YVsxXSkgJiYgVmVsb2NpdHkuRWFzaW5nc1t2YWx1ZURhdGFbMV1dKSB8fCBUeXBlLmlzQXJyYXkodmFsdWVEYXRhWzFdKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZWFzaW5nID0gc2tpcFJlc29sdmluZ0Vhc2luZyA/IHZhbHVlRGF0YVsxXSA6IGdldEVhc2luZyh2YWx1ZURhdGFbMV0sIG9wdHMuZHVyYXRpb24pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBEb24ndCBib3RoZXIgdmFsaWRhdGluZyBzdGFydFZhbHVlJ3MgdmFsdWUgbm93IHNpbmNlIHRoZSBlbnN1aW5nIHByb3BlcnR5IGN5Y2xpbmcgbG9naWMgaW5oZXJlbnRseSBkb2VzIHRoYXQuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlID0gdmFsdWVEYXRhWzJdO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlID0gdmFsdWVEYXRhWzFdIHx8IHZhbHVlRGF0YVsyXTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0LyogSGFuZGxlIHRoZSBzaW5nbGUtdmFsdWUgZm9ybWF0LiAqL1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlID0gdmFsdWVEYXRhO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0LyogRGVmYXVsdCB0byB0aGUgY2FsbCdzIGVhc2luZyBpZiBhIHBlci1wcm9wZXJ0eSBlYXNpbmcgdHlwZSB3YXMgbm90IGRlZmluZWQuICovXG5cdFx0XHRcdFx0XHRcdGlmICghc2tpcFJlc29sdmluZ0Vhc2luZykge1xuXHRcdFx0XHRcdFx0XHRcdGVhc2luZyA9IGVhc2luZyB8fCBvcHRzLmVhc2luZztcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8qIElmIGZ1bmN0aW9ucyB3ZXJlIHBhc3NlZCBpbiBhcyB2YWx1ZXMsIHBhc3MgdGhlIGZ1bmN0aW9uIHRoZSBjdXJyZW50IGVsZW1lbnQgYXMgaXRzIGNvbnRleHQsXG5cdFx0XHRcdFx0XHRcdCBwbHVzIHRoZSBlbGVtZW50J3MgaW5kZXggYW5kIHRoZSBlbGVtZW50IHNldCdzIHNpemUgYXMgYXJndW1lbnRzLiBUaGVuLCBhc3NpZ24gdGhlIHJldHVybmVkIHZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHRpZiAoVHlwZS5pc0Z1bmN0aW9uKGVuZFZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlID0gZW5kVmFsdWUuY2FsbChlbGVtZW50LCBlbGVtZW50QXJyYXlJbmRleCwgZWxlbWVudHNMZW5ndGgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKFR5cGUuaXNGdW5jdGlvbihzdGFydFZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0VmFsdWUgPSBzdGFydFZhbHVlLmNhbGwoZWxlbWVudCwgZWxlbWVudEFycmF5SW5kZXgsIGVsZW1lbnRzTGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8qIEFsbG93IHN0YXJ0VmFsdWUgdG8gYmUgbGVmdCBhcyB1bmRlZmluZWQgdG8gaW5kaWNhdGUgdG8gdGhlIGVuc3VpbmcgY29kZSB0aGF0IGl0cyB2YWx1ZSB3YXMgbm90IGZvcmNlZmVkLiAqL1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gW2VuZFZhbHVlIHx8IDAsIGVhc2luZywgc3RhcnRWYWx1ZV07XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHR2YXIgZml4UHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHByb3BlcnR5LCB2YWx1ZURhdGEpIHtcblx0XHRcdFx0XHRcdFx0LyogSW4gY2FzZSB0aGlzIHByb3BlcnR5IGlzIGEgaG9vaywgdGhlcmUgYXJlIGNpcmN1bXN0YW5jZXMgd2hlcmUgd2Ugd2lsbCBpbnRlbmQgdG8gd29yayBvbiB0aGUgaG9vaydzIHJvb3QgcHJvcGVydHkgYW5kIG5vdCB0aGUgaG9va2VkIHN1YnByb3BlcnR5LiAqL1xuXHRcdFx0XHRcdFx0XHR2YXIgcm9vdFByb3BlcnR5ID0gQ1NTLkhvb2tzLmdldFJvb3QocHJvcGVydHkpLFxuXHRcdFx0XHRcdFx0XHRcdFx0cm9vdFByb3BlcnR5VmFsdWUgPSBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XHRcdC8qIFBhcnNlIG91dCBlbmRWYWx1ZSwgZWFzaW5nLCBhbmQgc3RhcnRWYWx1ZSBmcm9tIHRoZSBwcm9wZXJ0eSdzIGRhdGEuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRlbmRWYWx1ZSA9IHZhbHVlRGF0YVswXSxcblx0XHRcdFx0XHRcdFx0XHRcdGVhc2luZyA9IHZhbHVlRGF0YVsxXSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0VmFsdWUgPSB2YWx1ZURhdGFbMl0sXG5cdFx0XHRcdFx0XHRcdFx0XHRwYXR0ZXJuO1xuXG5cdFx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHQgU3RhcnQgVmFsdWUgU291cmNpbmdcblx0XHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdC8qIE90aGVyIHRoYW4gZm9yIHRoZSBkdW1teSB0d2VlbiBwcm9wZXJ0eSwgcHJvcGVydGllcyB0aGF0IGFyZSBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBicm93c2VyIChhbmQgZG8gbm90IGhhdmUgYW4gYXNzb2NpYXRlZCBub3JtYWxpemF0aW9uKSB3aWxsXG5cdFx0XHRcdFx0XHRcdCBpbmhlcmVudGx5IHByb2R1Y2Ugbm8gc3R5bGUgY2hhbmdlcyB3aGVuIHNldCwgc28gdGhleSBhcmUgc2tpcHBlZCBpbiBvcmRlciB0byBkZWNyZWFzZSBhbmltYXRpb24gdGljayBvdmVyaGVhZC5cblx0XHRcdFx0XHRcdFx0IFByb3BlcnR5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZCB2aWEgcHJlZml4Q2hlY2soKSwgd2hpY2ggcmV0dXJucyBhIGZhbHNlIGZsYWcgd2hlbiBubyBzdXBwb3J0ZWQgaXMgZGV0ZWN0ZWQuICovXG5cdFx0XHRcdFx0XHRcdC8qIE5vdGU6IFNpbmNlIFNWRyBlbGVtZW50cyBoYXZlIHNvbWUgb2YgdGhlaXIgcHJvcGVydGllcyBkaXJlY3RseSBhcHBsaWVkIGFzIEhUTUwgYXR0cmlidXRlcyxcblx0XHRcdFx0XHRcdFx0IHRoZXJlIGlzIG5vIHdheSB0byBjaGVjayBmb3IgdGhlaXIgZXhwbGljaXQgYnJvd3NlciBzdXBwb3J0LCBhbmQgc28gd2Ugc2tpcCBza2lwIHRoaXMgY2hlY2sgZm9yIHRoZW0uICovXG5cdFx0XHRcdFx0XHRcdGlmICgoIWRhdGEgfHwgIWRhdGEuaXNTVkcpICYmIHJvb3RQcm9wZXJ0eSAhPT0gXCJ0d2VlblwiICYmIENTUy5OYW1lcy5wcmVmaXhDaGVjayhyb290UHJvcGVydHkpWzFdID09PSBmYWxzZSAmJiBDU1MuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtyb290UHJvcGVydHldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoVmVsb2NpdHkuZGVidWcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiU2tpcHBpbmcgW1wiICsgcm9vdFByb3BlcnR5ICsgXCJdIGR1ZSB0byBhIGxhY2sgb2YgYnJvd3NlciBzdXBwb3J0LlwiKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0LyogSWYgdGhlIGRpc3BsYXkgb3B0aW9uIGlzIGJlaW5nIHNldCB0byBhIG5vbi1cIm5vbmVcIiAoZS5nLiBcImJsb2NrXCIpIGFuZCBvcGFjaXR5IChmaWx0ZXIgb24gSUU8PTgpIGlzIGJlaW5nXG5cdFx0XHRcdFx0XHRcdCBhbmltYXRlZCB0byBhbiBlbmRWYWx1ZSBvZiBub24temVybywgdGhlIHVzZXIncyBpbnRlbnRpb24gaXMgdG8gZmFkZSBpbiBmcm9tIGludmlzaWJsZSwgdGh1cyB3ZSBmb3JjZWZlZWQgb3BhY2l0eVxuXHRcdFx0XHRcdFx0XHQgYSBzdGFydFZhbHVlIG9mIDAgaWYgaXRzIHN0YXJ0VmFsdWUgaGFzbid0IGFscmVhZHkgYmVlbiBzb3VyY2VkIGJ5IHZhbHVlIHRyYW5zZmVycmluZyBvciBwcmlvciBmb3JjZWZlZWRpbmcuICovXG5cdFx0XHRcdFx0XHRcdGlmICgoKG9wdHMuZGlzcGxheSAhPT0gdW5kZWZpbmVkICYmIG9wdHMuZGlzcGxheSAhPT0gbnVsbCAmJiBvcHRzLmRpc3BsYXkgIT09IFwibm9uZVwiKSB8fCAob3B0cy52aXNpYmlsaXR5ICE9PSB1bmRlZmluZWQgJiYgb3B0cy52aXNpYmlsaXR5ICE9PSBcImhpZGRlblwiKSkgJiYgL29wYWNpdHl8ZmlsdGVyLy50ZXN0KHByb3BlcnR5KSAmJiAhc3RhcnRWYWx1ZSAmJiBlbmRWYWx1ZSAhPT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0VmFsdWUgPSAwO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0LyogSWYgdmFsdWVzIGhhdmUgYmVlbiB0cmFuc2ZlcnJlZCBmcm9tIHRoZSBwcmV2aW91cyBWZWxvY2l0eSBjYWxsLCBleHRyYWN0IHRoZSBlbmRWYWx1ZSBhbmQgcm9vdFByb3BlcnR5VmFsdWVcblx0XHRcdFx0XHRcdFx0IGZvciBhbGwgb2YgdGhlIGN1cnJlbnQgY2FsbCdzIHByb3BlcnRpZXMgdGhhdCB3ZXJlICphbHNvKiBhbmltYXRlZCBpbiB0aGUgcHJldmlvdXMgY2FsbC4gKi9cblx0XHRcdFx0XHRcdFx0LyogTm90ZTogVmFsdWUgdHJhbnNmZXJyaW5nIGNhbiBvcHRpb25hbGx5IGJlIGRpc2FibGVkIGJ5IHRoZSB1c2VyIHZpYSB0aGUgX2NhY2hlVmFsdWVzIG9wdGlvbi4gKi9cblx0XHRcdFx0XHRcdFx0aWYgKG9wdHMuX2NhY2hlVmFsdWVzICYmIGxhc3RUd2VlbnNDb250YWluZXIgJiYgbGFzdFR3ZWVuc0NvbnRhaW5lcltwcm9wZXJ0eV0pIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoc3RhcnRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlID0gbGFzdFR3ZWVuc0NvbnRhaW5lcltwcm9wZXJ0eV0uZW5kVmFsdWUgKyBsYXN0VHdlZW5zQ29udGFpbmVyW3Byb3BlcnR5XS51bml0VHlwZTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvKiBUaGUgcHJldmlvdXMgY2FsbCdzIHJvb3RQcm9wZXJ0eVZhbHVlIGlzIGV4dHJhY3RlZCBmcm9tIHRoZSBlbGVtZW50J3MgZGF0YSBjYWNoZSBzaW5jZSB0aGF0J3MgdGhlXG5cdFx0XHRcdFx0XHRcdFx0IGluc3RhbmNlIG9mIHJvb3RQcm9wZXJ0eVZhbHVlIHRoYXQgZ2V0cyBmcmVzaGx5IHVwZGF0ZWQgYnkgdGhlIHR3ZWVuaW5nIHByb2Nlc3MsIHdoZXJlYXMgdGhlIHJvb3RQcm9wZXJ0eVZhbHVlXG5cdFx0XHRcdFx0XHRcdFx0IGF0dGFjaGVkIHRvIHRoZSBpbmNvbWluZyBsYXN0VHdlZW5zQ29udGFpbmVyIGlzIGVxdWFsIHRvIHRoZSByb290IHByb3BlcnR5J3MgdmFsdWUgcHJpb3IgdG8gYW55IHR3ZWVuaW5nLiAqL1xuXHRcdFx0XHRcdFx0XHRcdHJvb3RQcm9wZXJ0eVZhbHVlID0gZGF0YS5yb290UHJvcGVydHlWYWx1ZUNhY2hlW3Jvb3RQcm9wZXJ0eV07XG5cdFx0XHRcdFx0XHRcdFx0LyogSWYgdmFsdWVzIHdlcmUgbm90IHRyYW5zZmVycmVkIGZyb20gYSBwcmV2aW91cyBWZWxvY2l0eSBjYWxsLCBxdWVyeSB0aGUgRE9NIGFzIG5lZWRlZC4gKi9cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHQvKiBIYW5kbGUgaG9va2VkIHByb3BlcnRpZXMuICovXG5cdFx0XHRcdFx0XHRcdFx0aWYgKENTUy5Ib29rcy5yZWdpc3RlcmVkW3Byb3BlcnR5XSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHN0YXJ0VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyb290UHJvcGVydHlWYWx1ZSA9IENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIHJvb3RQcm9wZXJ0eSk7IC8qIEdFVCAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBOb3RlOiBUaGUgZm9sbG93aW5nIGdldFByb3BlcnR5VmFsdWUoKSBjYWxsIGRvZXMgbm90IGFjdHVhbGx5IHRyaWdnZXIgYSBET00gcXVlcnk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCBnZXRQcm9wZXJ0eVZhbHVlKCkgd2lsbCBleHRyYWN0IHRoZSBob29rIGZyb20gcm9vdFByb3BlcnR5VmFsdWUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0VmFsdWUgPSBDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBwcm9wZXJ0eSwgcm9vdFByb3BlcnR5VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBJZiBzdGFydFZhbHVlIGlzIGFscmVhZHkgZGVmaW5lZCB2aWEgZm9yY2VmZWVkaW5nLCBkbyBub3QgcXVlcnkgdGhlIERPTSBmb3IgdGhlIHJvb3QgcHJvcGVydHkncyB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0IGp1c3QgZ3JhYiByb290UHJvcGVydHkncyB6ZXJvLXZhbHVlIHRlbXBsYXRlIGZyb20gQ1NTLkhvb2tzLiBUaGlzIG92ZXJ3cml0ZXMgdGhlIGVsZW1lbnQncyBhY3R1YWxcblx0XHRcdFx0XHRcdFx0XHRcdFx0IHJvb3QgcHJvcGVydHkgdmFsdWUgKGlmIG9uZSBpcyBzZXQpLCBidXQgdGhpcyBpcyBhY2NlcHRhYmxlIHNpbmNlIHRoZSBwcmltYXJ5IHJlYXNvbiB1c2VycyBmb3JjZWZlZWQgaXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0IHRvIGF2b2lkIERPTSBxdWVyaWVzLCBhbmQgdGh1cyB3ZSBsaWtld2lzZSBhdm9pZCBxdWVyeWluZyB0aGUgRE9NIGZvciB0aGUgcm9vdCBwcm9wZXJ0eSdzIHZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogR3JhYiB0aGlzIGhvb2sncyB6ZXJvLXZhbHVlIHRlbXBsYXRlLCBlLmcuIFwiMHB4IDBweCAwcHggYmxhY2tcIi4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0cm9vdFByb3BlcnR5VmFsdWUgPSBDU1MuSG9va3MudGVtcGxhdGVzW3Jvb3RQcm9wZXJ0eV1bMV07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBIYW5kbGUgbm9uLWhvb2tlZCBwcm9wZXJ0aWVzIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gZGVmaW5lZCB2aWEgZm9yY2VmZWVkaW5nLiAqL1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoc3RhcnRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlID0gQ1NTLmdldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgcHJvcGVydHkpOyAvKiBHRVQgKi9cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdFx0IFZhbHVlIERhdGEgRXh0cmFjdGlvblxuXHRcdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHRcdFx0dmFyIHNlcGFyYXRlZFZhbHVlLFxuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWVVbml0VHlwZSxcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0VmFsdWVVbml0VHlwZSxcblx0XHRcdFx0XHRcdFx0XHRcdG9wZXJhdG9yID0gZmFsc2U7XG5cblx0XHRcdFx0XHRcdFx0LyogU2VwYXJhdGVzIGEgcHJvcGVydHkgdmFsdWUgaW50byBpdHMgbnVtZXJpYyB2YWx1ZSBhbmQgaXRzIHVuaXQgdHlwZS4gKi9cblx0XHRcdFx0XHRcdFx0dmFyIHNlcGFyYXRlVmFsdWUgPSBmdW5jdGlvbihwcm9wZXJ0eSwgdmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgdW5pdFR5cGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG51bWVyaWNWYWx1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdG51bWVyaWNWYWx1ZSA9ICh2YWx1ZSB8fCBcIjBcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnRvU3RyaW5nKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnRvTG93ZXJDYXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogTWF0Y2ggdGhlIHVuaXQgdHlwZSBhdCB0aGUgZW5kIG9mIHRoZSB2YWx1ZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1slQS16XSskLywgZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBHcmFiIHRoZSB1bml0IHR5cGUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pdFR5cGUgPSBtYXRjaDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIFN0cmlwIHRoZSB1bml0IHR5cGUgb2ZmIG9mIHZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBcIlwiO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0XHRcdC8qIElmIG5vIHVuaXQgdHlwZSB3YXMgc3VwcGxpZWQsIGFzc2lnbiBvbmUgdGhhdCBpcyBhcHByb3ByaWF0ZSBmb3IgdGhpcyBwcm9wZXJ0eSAoZS5nLiBcImRlZ1wiIGZvciByb3RhdGVaIG9yIFwicHhcIiBmb3Igd2lkdGgpLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmICghdW5pdFR5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXRUeXBlID0gQ1NTLlZhbHVlcy5nZXRVbml0VHlwZShwcm9wZXJ0eSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIFtudW1lcmljVmFsdWUsIHVuaXRUeXBlXTtcblx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoc3RhcnRWYWx1ZSAhPT0gZW5kVmFsdWUgJiYgVHlwZS5pc1N0cmluZyhzdGFydFZhbHVlKSAmJiBUeXBlLmlzU3RyaW5nKGVuZFZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdHBhdHRlcm4gPSBcIlwiO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBpU3RhcnQgPSAwLCAvLyBpbmRleCBpbiBzdGFydFZhbHVlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlFbmQgPSAwLCAvLyBpbmRleCBpbiBlbmRWYWx1ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhU3RhcnQgPSBbXSwgLy8gYXJyYXkgb2Ygc3RhcnRWYWx1ZSBudW1iZXJzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFFbmQgPSBbXSwgLy8gYXJyYXkgb2YgZW5kVmFsdWUgbnVtYmVyc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpbkNhbGMgPSAwLCAvLyBLZWVwIHRyYWNrIG9mIGJlaW5nIGluc2lkZSBhIFwiY2FsYygpXCIgc28gd2UgZG9uJ3QgZHVwbGljYXRlIGl0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGluUkdCID0gMCwgLy8gS2VlcCB0cmFjayBvZiBiZWluZyBpbnNpZGUgYW4gUkdCIGFzIHdlIGNhbid0IHVzZSBmcmFjdGlvbmFsIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpblJHQkEgPSAwOyAvLyBLZWVwIHRyYWNrIG9mIGJlaW5nIGluc2lkZSBhbiBSR0JBIGFzIHdlIG11c3QgcGFzcyBmcmFjdGlvbmFsIGZvciB0aGUgYWxwaGEgY2hhbm5lbFxuXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnRWYWx1ZSA9IENTUy5Ib29rcy5maXhDb2xvcnMoc3RhcnRWYWx1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSBDU1MuSG9va3MuZml4Q29sb3JzKGVuZFZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoaVN0YXJ0IDwgc3RhcnRWYWx1ZS5sZW5ndGggJiYgaUVuZCA8IGVuZFZhbHVlLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGNTdGFydCA9IHN0YXJ0VmFsdWVbaVN0YXJ0XSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjRW5kID0gZW5kVmFsdWVbaUVuZF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICgvW1xcZFxcLi1dLy50ZXN0KGNTdGFydCkgJiYgL1tcXGRcXC4tXS8udGVzdChjRW5kKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgdFN0YXJ0ID0gY1N0YXJ0LCAvLyB0ZW1wb3JhcnkgY2hhcmFjdGVyIGJ1ZmZlclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dEVuZCA9IGNFbmQsIC8vIHRlbXBvcmFyeSBjaGFyYWN0ZXIgYnVmZmVyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkb3RTdGFydCA9IFwiLlwiLCAvLyBNYWtlIHN1cmUgd2UgY2FuIG9ubHkgZXZlciBtYXRjaCBhIHNpbmdsZSBkb3QgaW4gYSBkZWNpbWFsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkb3RFbmQgPSBcIi5cIjsgLy8gTWFrZSBzdXJlIHdlIGNhbiBvbmx5IGV2ZXIgbWF0Y2ggYSBzaW5nbGUgZG90IGluIGEgZGVjaW1hbFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHdoaWxlICgrK2lTdGFydCA8IHN0YXJ0VmFsdWUubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y1N0YXJ0ID0gc3RhcnRWYWx1ZVtpU3RhcnRdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChjU3RhcnQgPT09IGRvdFN0YXJ0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkb3RTdGFydCA9IFwiLi5cIjsgLy8gQ2FuIG5ldmVyIG1hdGNoIHR3byBjaGFyYWN0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICghL1xcZC8udGVzdChjU3RhcnQpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dFN0YXJ0ICs9IGNTdGFydDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoKytpRW5kIDwgZW5kVmFsdWUubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y0VuZCA9IGVuZFZhbHVlW2lFbmRdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChjRW5kID09PSBkb3RFbmQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRvdEVuZCA9IFwiLi5cIjsgLy8gQ2FuIG5ldmVyIG1hdGNoIHR3byBjaGFyYWN0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICghL1xcZC8udGVzdChjRW5kKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRFbmQgKz0gY0VuZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgdVN0YXJ0ID0gQ1NTLkhvb2tzLmdldFVuaXQoc3RhcnRWYWx1ZSwgaVN0YXJ0KSwgLy8gdGVtcG9yYXJ5IHVuaXQgdHlwZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dUVuZCA9IENTUy5Ib29rcy5nZXRVbml0KGVuZFZhbHVlLCBpRW5kKTsgLy8gdGVtcG9yYXJ5IHVuaXQgdHlwZVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlTdGFydCArPSB1U3RhcnQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpRW5kICs9IHVFbmQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAodVN0YXJ0ID09PSB1RW5kKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU2FtZSB1bml0c1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICh0U3RhcnQgPT09IHRFbmQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNhbWUgbnVtYmVycywgc28ganVzdCBjb3B5IG92ZXJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBhdHRlcm4gKz0gdFN0YXJ0ICsgdVN0YXJ0O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEaWZmZXJlbnQgbnVtYmVycywgc28gc3RvcmUgdGhlbVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cGF0dGVybiArPSBcIntcIiArIGFTdGFydC5sZW5ndGggKyAoaW5SR0IgPyBcIiFcIiA6IFwiXCIpICsgXCJ9XCIgKyB1U3RhcnQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhU3RhcnQucHVzaChwYXJzZUZsb2F0KHRTdGFydCkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YUVuZC5wdXNoKHBhcnNlRmxvYXQodEVuZCkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEaWZmZXJlbnQgdW5pdHMsIHNvIHB1dCBpbnRvIGEgXCJjYWxjKGZyb20gKyB0bylcIiBhbmQgYW5pbWF0ZSBlYWNoIHNpZGUgdG8vZnJvbSB6ZXJvXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIG5TdGFydCA9IHBhcnNlRmxvYXQodFN0YXJ0KSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bkVuZCA9IHBhcnNlRmxvYXQodEVuZCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwYXR0ZXJuICs9IChpbkNhbGMgPCA1ID8gXCJjYWxjXCIgOiBcIlwiKSArIFwiKFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCsgKG5TdGFydCA/IFwie1wiICsgYVN0YXJ0Lmxlbmd0aCArIChpblJHQiA/IFwiIVwiIDogXCJcIikgKyBcIn1cIiA6IFwiMFwiKSArIHVTdGFydFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQrIFwiICsgXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KyAobkVuZCA/IFwie1wiICsgKGFTdGFydC5sZW5ndGggKyAoblN0YXJ0ID8gMSA6IDApKSArIChpblJHQiA/IFwiIVwiIDogXCJcIikgKyBcIn1cIiA6IFwiMFwiKSArIHVFbmRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KyBcIilcIjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoblN0YXJ0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhU3RhcnQucHVzaChuU3RhcnQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YUVuZC5wdXNoKDApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAobkVuZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YVN0YXJ0LnB1c2goMCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhRW5kLnB1c2gobkVuZCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGNTdGFydCA9PT0gY0VuZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXR0ZXJuICs9IGNTdGFydDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aVN0YXJ0Kys7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlFbmQrKztcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gS2VlcCB0cmFjayBvZiBiZWluZyBpbnNpZGUgYSBjYWxjKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGluQ2FsYyA9PT0gMCAmJiBjU3RhcnQgPT09IFwiY1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR8fCBpbkNhbGMgPT09IDEgJiYgY1N0YXJ0ID09PSBcImFcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fHwgaW5DYWxjID09PSAyICYmIGNTdGFydCA9PT0gXCJsXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHx8IGluQ2FsYyA9PT0gMyAmJiBjU3RhcnQgPT09IFwiY1wiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR8fCBpbkNhbGMgPj0gNCAmJiBjU3RhcnQgPT09IFwiKFwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpbkNhbGMrKztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICgoaW5DYWxjICYmIGluQ2FsYyA8IDUpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR8fCBpbkNhbGMgPj0gNCAmJiBjU3RhcnQgPT09IFwiKVwiICYmIC0taW5DYWxjIDwgNSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGluQ2FsYyA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gS2VlcCB0cmFjayBvZiBiZWluZyBpbnNpZGUgYW4gcmdiKCkgLyByZ2JhKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGluUkdCID09PSAwICYmIGNTdGFydCA9PT0gXCJyXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHx8IGluUkdCID09PSAxICYmIGNTdGFydCA9PT0gXCJnXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHx8IGluUkdCID09PSAyICYmIGNTdGFydCA9PT0gXCJiXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHx8IGluUkdCID09PSAzICYmIGNTdGFydCA9PT0gXCJhXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHx8IGluUkdCID49IDMgJiYgY1N0YXJ0ID09PSBcIihcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGluUkdCID09PSAzICYmIGNTdGFydCA9PT0gXCJhXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGluUkdCQSA9IDE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGluUkdCKys7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoaW5SR0JBICYmIGNTdGFydCA9PT0gXCIsXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoKytpblJHQkEgPiAzKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpblJHQiA9IGluUkdCQSA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKChpblJHQkEgJiYgaW5SR0IgPCAoaW5SR0JBID8gNSA6IDQpKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fHwgaW5SR0IgPj0gKGluUkdCQSA/IDQgOiAzKSAmJiBjU3RhcnQgPT09IFwiKVwiICYmIC0taW5SR0IgPCAoaW5SR0JBID8gNSA6IDQpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aW5SR0IgPSBpblJHQkEgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpbkNhbGMgPSAwO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBjaGFuZ2luZyB1bml0cywgZml4aW5nIGNvbG91cnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChpU3RhcnQgIT09IHN0YXJ0VmFsdWUubGVuZ3RoIHx8IGlFbmQgIT09IGVuZFZhbHVlLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKFZlbG9jaXR5LmRlYnVnKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJUcnlpbmcgdG8gcGF0dGVybiBtYXRjaCBtaXMtbWF0Y2hlZCBzdHJpbmdzIFtcXFwiXCIgKyBlbmRWYWx1ZSArIFwiXFxcIiwgXFxcIlwiICsgc3RhcnRWYWx1ZSArIFwiXFxcIl1cIik7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRwYXR0ZXJuID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAocGF0dGVybikge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGFTdGFydC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKFZlbG9jaXR5LmRlYnVnKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJQYXR0ZXJuIGZvdW5kIFxcXCJcIiArIHBhdHRlcm4gKyBcIlxcXCIgLT4gXCIsIGFTdGFydCwgYUVuZCwgXCJbXCIgKyBzdGFydFZhbHVlICsgXCIsXCIgKyBlbmRWYWx1ZSArIFwiXVwiKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlID0gYVN0YXJ0O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRlbmRWYWx1ZSA9IGFFbmQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlVW5pdFR5cGUgPSBzdGFydFZhbHVlVW5pdFR5cGUgPSBcIlwiO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGF0dGVybiA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoIXBhdHRlcm4pIHtcblx0XHRcdFx0XHRcdFx0XHQvKiBTZXBhcmF0ZSBzdGFydFZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdHNlcGFyYXRlZFZhbHVlID0gc2VwYXJhdGVWYWx1ZShwcm9wZXJ0eSwgc3RhcnRWYWx1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0c3RhcnRWYWx1ZSA9IHNlcGFyYXRlZFZhbHVlWzBdO1xuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0VmFsdWVVbml0VHlwZSA9IHNlcGFyYXRlZFZhbHVlWzFdO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogU2VwYXJhdGUgZW5kVmFsdWUsIGFuZCBleHRyYWN0IGEgdmFsdWUgb3BlcmF0b3IgKGUuZy4gXCIrPVwiLCBcIi09XCIpIGlmIG9uZSBleGlzdHMuICovXG5cdFx0XHRcdFx0XHRcdFx0c2VwYXJhdGVkVmFsdWUgPSBzZXBhcmF0ZVZhbHVlKHByb3BlcnR5LCBlbmRWYWx1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSBzZXBhcmF0ZWRWYWx1ZVswXS5yZXBsYWNlKC9eKFsrLVxcLypdKT0vLCBmdW5jdGlvbihtYXRjaCwgc3ViTWF0Y2gpIHtcblx0XHRcdFx0XHRcdFx0XHRcdG9wZXJhdG9yID0gc3ViTWF0Y2g7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8qIFN0cmlwIHRoZSBvcGVyYXRvciBvZmYgb2YgdGhlIHZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWVVbml0VHlwZSA9IHNlcGFyYXRlZFZhbHVlWzFdO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogUGFyc2UgZmxvYXQgdmFsdWVzIGZyb20gZW5kVmFsdWUgYW5kIHN0YXJ0VmFsdWUuIERlZmF1bHQgdG8gMCBpZiBOYU4gaXMgcmV0dXJuZWQuICovXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnRWYWx1ZSA9IHBhcnNlRmxvYXQoc3RhcnRWYWx1ZSkgfHwgMDtcblx0XHRcdFx0XHRcdFx0XHRlbmRWYWx1ZSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpIHx8IDA7XG5cblx0XHRcdFx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0XHRcdFx0IFByb3BlcnR5LVNwZWNpZmljIFZhbHVlIENvbnZlcnNpb25cblx0XHRcdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogQ3VzdG9tIHN1cHBvcnQgZm9yIHByb3BlcnRpZXMgdGhhdCBkb24ndCBhY3R1YWxseSBhY2NlcHQgdGhlICUgdW5pdCB0eXBlLCBidXQgd2hlcmUgcG9sbHlmaWxsaW5nIGlzIHRyaXZpYWwgYW5kIHJlbGF0aXZlbHkgZm9vbHByb29mLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmIChlbmRWYWx1ZVVuaXRUeXBlID09PSBcIiVcIikge1xuXHRcdFx0XHRcdFx0XHRcdFx0LyogQSAlLXZhbHVlIGZvbnRTaXplL2xpbmVIZWlnaHQgaXMgcmVsYXRpdmUgdG8gdGhlIHBhcmVudCdzIGZvbnRTaXplIChhcyBvcHBvc2VkIHRvIHRoZSBwYXJlbnQncyBkaW1lbnNpb25zKSxcblx0XHRcdFx0XHRcdFx0XHRcdCB3aGljaCBpcyBpZGVudGljYWwgdG8gdGhlIGVtIHVuaXQncyBiZWhhdmlvciwgc28gd2UgcGlnZ3liYWNrIG9mZiBvZiB0aGF0LiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKC9eKGZvbnRTaXplfGxpbmVIZWlnaHQpJC8udGVzdChwcm9wZXJ0eSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogQ29udmVydCAlIGludG8gYW4gZW0gZGVjaW1hbCB2YWx1ZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSBlbmRWYWx1ZSAvIDEwMDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWVVbml0VHlwZSA9IFwiZW1cIjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogRm9yIHNjYWxlWCBhbmQgc2NhbGVZLCBjb252ZXJ0IHRoZSB2YWx1ZSBpbnRvIGl0cyBkZWNpbWFsIGZvcm1hdCBhbmQgc3RyaXAgb2ZmIHRoZSB1bml0IHR5cGUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKC9ec2NhbGUvLnRlc3QocHJvcGVydHkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlID0gZW5kVmFsdWUgLyAxMDA7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlVW5pdFR5cGUgPSBcIlwiO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBGb3IgUkdCIGNvbXBvbmVudHMsIHRha2UgdGhlIGRlZmluZWQgcGVyY2VudGFnZSBvZiAyNTUgYW5kIHN0cmlwIG9mZiB0aGUgdW5pdCB0eXBlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICgvKFJlZHxHcmVlbnxCbHVlKSQvaS50ZXN0KHByb3BlcnR5KSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRlbmRWYWx1ZSA9IChlbmRWYWx1ZSAvIDEwMCkgKiAyNTU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlVW5pdFR5cGUgPSBcIlwiO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdFx0IFVuaXQgUmF0aW8gQ2FsY3VsYXRpb25cblx0XHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdFx0XHQvKiBXaGVuIHF1ZXJpZWQsIHRoZSBicm93c2VyIHJldHVybnMgKG1vc3QpIENTUyBwcm9wZXJ0eSB2YWx1ZXMgaW4gcGl4ZWxzLiBUaGVyZWZvcmUsIGlmIGFuIGVuZFZhbHVlIHdpdGggYSB1bml0IHR5cGUgb2Zcblx0XHRcdFx0XHRcdFx0ICUsIGVtLCBvciByZW0gaXMgYW5pbWF0ZWQgdG93YXJkLCBzdGFydFZhbHVlIG11c3QgYmUgY29udmVydGVkIGZyb20gcGl4ZWxzIGludG8gdGhlIHNhbWUgdW5pdCB0eXBlIGFzIGVuZFZhbHVlIGluIG9yZGVyXG5cdFx0XHRcdFx0XHRcdCBmb3IgdmFsdWUgbWFuaXB1bGF0aW9uIGxvZ2ljIChpbmNyZW1lbnQvZGVjcmVtZW50KSB0byBwcm9jZWVkLiBGdXJ0aGVyLCBpZiB0aGUgc3RhcnRWYWx1ZSB3YXMgZm9yY2VmZWQgb3IgdHJhbnNmZXJyZWRcblx0XHRcdFx0XHRcdFx0IGZyb20gYSBwcmV2aW91cyBjYWxsLCBzdGFydFZhbHVlIG1heSBhbHNvIG5vdCBiZSBpbiBwaXhlbHMuIFVuaXQgY29udmVyc2lvbiBsb2dpYyB0aGVyZWZvcmUgY29uc2lzdHMgb2YgdHdvIHN0ZXBzOlxuXHRcdFx0XHRcdFx0XHQgMSkgQ2FsY3VsYXRpbmcgdGhlIHJhdGlvIG9mICUvZW0vcmVtL3ZoL3Z3IHJlbGF0aXZlIHRvIHBpeGVsc1xuXHRcdFx0XHRcdFx0XHQgMikgQ29udmVydGluZyBzdGFydFZhbHVlIGludG8gdGhlIHNhbWUgdW5pdCBvZiBtZWFzdXJlbWVudCBhcyBlbmRWYWx1ZSBiYXNlZCBvbiB0aGVzZSByYXRpb3MuICovXG5cdFx0XHRcdFx0XHRcdC8qIFVuaXQgY29udmVyc2lvbiByYXRpb3MgYXJlIGNhbGN1bGF0ZWQgYnkgaW5zZXJ0aW5nIGEgc2libGluZyBub2RlIG5leHQgdG8gdGhlIHRhcmdldCBub2RlLCBjb3B5aW5nIG92ZXIgaXRzIHBvc2l0aW9uIHByb3BlcnR5LFxuXHRcdFx0XHRcdFx0XHQgc2V0dGluZyB2YWx1ZXMgd2l0aCB0aGUgdGFyZ2V0IHVuaXQgdHlwZSB0aGVuIGNvbXBhcmluZyB0aGUgcmV0dXJuZWQgcGl4ZWwgdmFsdWUuICovXG5cdFx0XHRcdFx0XHRcdC8qIE5vdGU6IEV2ZW4gaWYgb25seSBvbmUgb2YgdGhlc2UgdW5pdCB0eXBlcyBpcyBiZWluZyBhbmltYXRlZCwgYWxsIHVuaXQgcmF0aW9zIGFyZSBjYWxjdWxhdGVkIGF0IG9uY2Ugc2luY2UgdGhlIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdCBvZiBiYXRjaGluZyB0aGUgU0VUcyBhbmQgR0VUcyB0b2dldGhlciB1cGZyb250IG91dHdlaWdodHMgdGhlIHBvdGVudGlhbCBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHQgb2YgbGF5b3V0IHRocmFzaGluZyBjYXVzZWQgYnkgcmUtcXVlcnlpbmcgZm9yIHVuY2FsY3VsYXRlZCByYXRpb3MgZm9yIHN1YnNlcXVlbnRseS1wcm9jZXNzZWQgcHJvcGVydGllcy4gKi9cblx0XHRcdFx0XHRcdFx0LyogVG9kbzogU2hpZnQgdGhpcyBsb2dpYyBpbnRvIHRoZSBjYWxscycgZmlyc3QgdGljayBpbnN0YW5jZSBzbyB0aGF0IGl0J3Mgc3luY2VkIHdpdGggUkFGLiAqL1xuXHRcdFx0XHRcdFx0XHR2YXIgY2FsY3VsYXRlVW5pdFJhdGlvcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHRcdCBTYW1lIFJhdGlvIENoZWNrc1xuXHRcdFx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHRcdFx0XHQvKiBUaGUgcHJvcGVydGllcyBiZWxvdyBhcmUgdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgZWxlbWVudCBkaWZmZXJzIHN1ZmZpY2llbnRseSBmcm9tIHRoaXMgY2FsbCdzXG5cdFx0XHRcdFx0XHRcdFx0IHByZXZpb3VzbHkgaXRlcmF0ZWQgZWxlbWVudCB0byBhbHNvIGRpZmZlciBpbiBpdHMgdW5pdCBjb252ZXJzaW9uIHJhdGlvcy4gSWYgdGhlIHByb3BlcnRpZXMgbWF0Y2ggdXAgd2l0aCB0aG9zZVxuXHRcdFx0XHRcdFx0XHRcdCBvZiB0aGUgcHJpb3IgZWxlbWVudCwgdGhlIHByaW9yIGVsZW1lbnQncyBjb252ZXJzaW9uIHJhdGlvcyBhcmUgdXNlZC4gTGlrZSBtb3N0IG9wdGltaXphdGlvbnMgaW4gVmVsb2NpdHksXG5cdFx0XHRcdFx0XHRcdFx0IHRoaXMgaXMgZG9uZSB0byBtaW5pbWl6ZSBET00gcXVlcnlpbmcuICovXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHNhbWVSYXRpb0luZGljYXRvcnMgPSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRteVBhcmVudDogZWxlbWVudC5wYXJlbnROb2RlIHx8IGRvY3VtZW50LmJvZHksIC8qIEdFVCAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0cG9zaXRpb246IENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwicG9zaXRpb25cIiksIC8qIEdFVCAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm9udFNpemU6IENTUy5nZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwiZm9udFNpemVcIikgLyogR0VUICovXG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogRGV0ZXJtaW5lIGlmIHRoZSBzYW1lICUgcmF0aW8gY2FuIGJlIHVzZWQuICUgaXMgYmFzZWQgb24gdGhlIGVsZW1lbnQncyBwb3NpdGlvbiB2YWx1ZSBhbmQgaXRzIHBhcmVudCdzIHdpZHRoIGFuZCBoZWlnaHQgZGltZW5zaW9ucy4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0c2FtZVBlcmNlbnRSYXRpbyA9ICgoc2FtZVJhdGlvSW5kaWNhdG9ycy5wb3NpdGlvbiA9PT0gY2FsbFVuaXRDb252ZXJzaW9uRGF0YS5sYXN0UG9zaXRpb24pICYmIChzYW1lUmF0aW9JbmRpY2F0b3JzLm15UGFyZW50ID09PSBjYWxsVW5pdENvbnZlcnNpb25EYXRhLmxhc3RQYXJlbnQpKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogRGV0ZXJtaW5lIGlmIHRoZSBzYW1lIGVtIHJhdGlvIGNhbiBiZSB1c2VkLiBlbSBpcyByZWxhdGl2ZSB0byB0aGUgZWxlbWVudCdzIGZvbnRTaXplLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzYW1lRW1SYXRpbyA9IChzYW1lUmF0aW9JbmRpY2F0b3JzLmZvbnRTaXplID09PSBjYWxsVW5pdENvbnZlcnNpb25EYXRhLmxhc3RGb250U2l6ZSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvKiBTdG9yZSB0aGVzZSByYXRpbyBpbmRpY2F0b3JzIGNhbGwtd2lkZSBmb3IgdGhlIG5leHQgZWxlbWVudCB0byBjb21wYXJlIGFnYWluc3QuICovXG5cdFx0XHRcdFx0XHRcdFx0Y2FsbFVuaXRDb252ZXJzaW9uRGF0YS5sYXN0UGFyZW50ID0gc2FtZVJhdGlvSW5kaWNhdG9ycy5teVBhcmVudDtcblx0XHRcdFx0XHRcdFx0XHRjYWxsVW5pdENvbnZlcnNpb25EYXRhLmxhc3RQb3NpdGlvbiA9IHNhbWVSYXRpb0luZGljYXRvcnMucG9zaXRpb247XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbFVuaXRDb252ZXJzaW9uRGF0YS5sYXN0Rm9udFNpemUgPSBzYW1lUmF0aW9JbmRpY2F0b3JzLmZvbnRTaXplO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHRcdCBFbGVtZW50LVNwZWNpZmljIFVuaXRzXG5cdFx0XHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdFx0XHRcdC8qIE5vdGU6IElFOCByb3VuZHMgdG8gdGhlIG5lYXJlc3QgcGl4ZWwgd2hlbiByZXR1cm5pbmcgQ1NTIHZhbHVlcywgdGh1cyB3ZSBwZXJmb3JtIGNvbnZlcnNpb25zIHVzaW5nIGEgbWVhc3VyZW1lbnRcblx0XHRcdFx0XHRcdFx0XHQgb2YgMTAwIChpbnN0ZWFkIG9mIDEpIHRvIGdpdmUgb3VyIHJhdGlvcyBhIHByZWNpc2lvbiBvZiBhdCBsZWFzdCAyIGRlY2ltYWwgdmFsdWVzLiAqL1xuXHRcdFx0XHRcdFx0XHRcdHZhciBtZWFzdXJlbWVudCA9IDEwMCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pdFJhdGlvcyA9IHt9O1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFzYW1lRW1SYXRpbyB8fCAhc2FtZVBlcmNlbnRSYXRpbykge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGR1bW15ID0gZGF0YSAmJiBkYXRhLmlzU1ZHID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJyZWN0XCIpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0VmVsb2NpdHkuaW5pdChkdW1teSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRzYW1lUmF0aW9JbmRpY2F0b3JzLm15UGFyZW50LmFwcGVuZENoaWxkKGR1bW15KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0LyogVG8gYWNjdXJhdGVseSBhbmQgY29uc2lzdGVudGx5IGNhbGN1bGF0ZSBjb252ZXJzaW9uIHJhdGlvcywgdGhlIGVsZW1lbnQncyBjYXNjYWRlZCBvdmVyZmxvdyBhbmQgYm94LXNpemluZyBhcmUgc3RyaXBwZWQuXG5cdFx0XHRcdFx0XHRcdFx0XHQgU2ltaWxhcmx5LCBzaW5jZSB3aWR0aC9oZWlnaHQgY2FuIGJlIGFydGlmaWNpYWxseSBjb25zdHJhaW5lZCBieSB0aGVpciBtaW4tL21heC0gZXF1aXZhbGVudHMsIHRoZXNlIGFyZSBjb250cm9sbGVkIGZvciBhcyB3ZWxsLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0LyogTm90ZTogT3ZlcmZsb3cgbXVzdCBiZSBhbHNvIGJlIGNvbnRyb2xsZWQgZm9yIHBlci1heGlzIHNpbmNlIHRoZSBvdmVyZmxvdyBwcm9wZXJ0eSBvdmVyd3JpdGVzIGl0cyBwZXItYXhpcyB2YWx1ZXMuICovXG5cdFx0XHRcdFx0XHRcdFx0XHQkLmVhY2goW1wib3ZlcmZsb3dcIiwgXCJvdmVyZmxvd1hcIiwgXCJvdmVyZmxvd1lcIl0sIGZ1bmN0aW9uKGksIHByb3BlcnR5KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFZlbG9jaXR5LkNTUy5zZXRQcm9wZXJ0eVZhbHVlKGR1bW15LCBwcm9wZXJ0eSwgXCJoaWRkZW5cIik7XG5cdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRcdFZlbG9jaXR5LkNTUy5zZXRQcm9wZXJ0eVZhbHVlKGR1bW15LCBcInBvc2l0aW9uXCIsIHNhbWVSYXRpb0luZGljYXRvcnMucG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0XHRcdFx0VmVsb2NpdHkuQ1NTLnNldFByb3BlcnR5VmFsdWUoZHVtbXksIFwiZm9udFNpemVcIiwgc2FtZVJhdGlvSW5kaWNhdG9ycy5mb250U2l6ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRWZWxvY2l0eS5DU1Muc2V0UHJvcGVydHlWYWx1ZShkdW1teSwgXCJib3hTaXppbmdcIiwgXCJjb250ZW50LWJveFwiKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Lyogd2lkdGggYW5kIGhlaWdodCBhY3QgYXMgb3VyIHByb3h5IHByb3BlcnRpZXMgZm9yIG1lYXN1cmluZyB0aGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgJSByYXRpb3MuICovXG5cdFx0XHRcdFx0XHRcdFx0XHQkLmVhY2goW1wibWluV2lkdGhcIiwgXCJtYXhXaWR0aFwiLCBcIndpZHRoXCIsIFwibWluSGVpZ2h0XCIsIFwibWF4SGVpZ2h0XCIsIFwiaGVpZ2h0XCJdLCBmdW5jdGlvbihpLCBwcm9wZXJ0eSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRWZWxvY2l0eS5DU1Muc2V0UHJvcGVydHlWYWx1ZShkdW1teSwgcHJvcGVydHksIG1lYXN1cmVtZW50ICsgXCIlXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBwYWRkaW5nTGVmdCBhcmJpdHJhcmlseSBhY3RzIGFzIG91ciBwcm94eSBwcm9wZXJ0eSBmb3IgdGhlIGVtIHJhdGlvLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0VmVsb2NpdHkuQ1NTLnNldFByb3BlcnR5VmFsdWUoZHVtbXksIFwicGFkZGluZ0xlZnRcIiwgbWVhc3VyZW1lbnQgKyBcImVtXCIpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBEaXZpZGUgdGhlIHJldHVybmVkIHZhbHVlIGJ5IHRoZSBtZWFzdXJlbWVudCB0byBnZXQgdGhlIHJhdGlvIGJldHdlZW4gMSUgYW5kIDFweC4gRGVmYXVsdCB0byAxIHNpbmNlIHdvcmtpbmcgd2l0aCAwIGNhbiBwcm9kdWNlIEluZmluaXRlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pdFJhdGlvcy5wZXJjZW50VG9QeFdpZHRoID0gY2FsbFVuaXRDb252ZXJzaW9uRGF0YS5sYXN0UGVyY2VudFRvUHhXaWR0aCA9IChwYXJzZUZsb2F0KENTUy5nZXRQcm9wZXJ0eVZhbHVlKGR1bW15LCBcIndpZHRoXCIsIG51bGwsIHRydWUpKSB8fCAxKSAvIG1lYXN1cmVtZW50OyAvKiBHRVQgKi9cblx0XHRcdFx0XHRcdFx0XHRcdHVuaXRSYXRpb3MucGVyY2VudFRvUHhIZWlnaHQgPSBjYWxsVW5pdENvbnZlcnNpb25EYXRhLmxhc3RQZXJjZW50VG9QeEhlaWdodCA9IChwYXJzZUZsb2F0KENTUy5nZXRQcm9wZXJ0eVZhbHVlKGR1bW15LCBcImhlaWdodFwiLCBudWxsLCB0cnVlKSkgfHwgMSkgLyBtZWFzdXJlbWVudDsgLyogR0VUICovXG5cdFx0XHRcdFx0XHRcdFx0XHR1bml0UmF0aW9zLmVtVG9QeCA9IGNhbGxVbml0Q29udmVyc2lvbkRhdGEubGFzdEVtVG9QeCA9IChwYXJzZUZsb2F0KENTUy5nZXRQcm9wZXJ0eVZhbHVlKGR1bW15LCBcInBhZGRpbmdMZWZ0XCIpKSB8fCAxKSAvIG1lYXN1cmVtZW50OyAvKiBHRVQgKi9cblxuXHRcdFx0XHRcdFx0XHRcdFx0c2FtZVJhdGlvSW5kaWNhdG9ycy5teVBhcmVudC5yZW1vdmVDaGlsZChkdW1teSk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXRSYXRpb3MuZW1Ub1B4ID0gY2FsbFVuaXRDb252ZXJzaW9uRGF0YS5sYXN0RW1Ub1B4O1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pdFJhdGlvcy5wZXJjZW50VG9QeFdpZHRoID0gY2FsbFVuaXRDb252ZXJzaW9uRGF0YS5sYXN0UGVyY2VudFRvUHhXaWR0aDtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXRSYXRpb3MucGVyY2VudFRvUHhIZWlnaHQgPSBjYWxsVW5pdENvbnZlcnNpb25EYXRhLmxhc3RQZXJjZW50VG9QeEhlaWdodDtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0XHRcdFx0IEVsZW1lbnQtQWdub3N0aWMgVW5pdHNcblx0XHRcdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogV2hlcmVhcyAlIGFuZCBlbSByYXRpb3MgYXJlIGRldGVybWluZWQgb24gYSBwZXItZWxlbWVudCBiYXNpcywgdGhlIHJlbSB1bml0IG9ubHkgbmVlZHMgdG8gYmUgY2hlY2tlZFxuXHRcdFx0XHRcdFx0XHRcdCBvbmNlIHBlciBjYWxsIHNpbmNlIGl0J3MgZXhjbHVzaXZlbHkgZGVwZW5kYW50IHVwb24gZG9jdW1lbnQuYm9keSdzIGZvbnRTaXplLiBJZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lXG5cdFx0XHRcdFx0XHRcdFx0IHRoYXQgY2FsY3VsYXRlVW5pdFJhdGlvcygpIGlzIGJlaW5nIHJ1biBkdXJpbmcgdGhpcyBjYWxsLCByZW1Ub1B4IHdpbGwgc3RpbGwgYmUgc2V0IHRvIGl0cyBkZWZhdWx0IHZhbHVlIG9mIG51bGwsXG5cdFx0XHRcdFx0XHRcdFx0IHNvIHdlIGNhbGN1bGF0ZSBpdCBub3cuICovXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGNhbGxVbml0Q29udmVyc2lvbkRhdGEucmVtVG9QeCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0LyogRGVmYXVsdCB0byBicm93c2VycycgZGVmYXVsdCBmb250U2l6ZSBvZiAxNnB4IGluIHRoZSBjYXNlIG9mIDAuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRjYWxsVW5pdENvbnZlcnNpb25EYXRhLnJlbVRvUHggPSBwYXJzZUZsb2F0KENTUy5nZXRQcm9wZXJ0eVZhbHVlKGRvY3VtZW50LmJvZHksIFwiZm9udFNpemVcIikpIHx8IDE2OyAvKiBHRVQgKi9cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHQvKiBTaW1pbGFybHksIHZpZXdwb3J0IHVuaXRzIGFyZSAlLXJlbGF0aXZlIHRvIHRoZSB3aW5kb3cncyBpbm5lciBkaW1lbnNpb25zLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmIChjYWxsVW5pdENvbnZlcnNpb25EYXRhLnZ3VG9QeCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2FsbFVuaXRDb252ZXJzaW9uRGF0YS52d1RvUHggPSBwYXJzZUZsb2F0KHdpbmRvdy5pbm5lcldpZHRoKSAvIDEwMDsgLyogR0VUICovXG5cdFx0XHRcdFx0XHRcdFx0XHRjYWxsVW5pdENvbnZlcnNpb25EYXRhLnZoVG9QeCA9IHBhcnNlRmxvYXQod2luZG93LmlubmVySGVpZ2h0KSAvIDEwMDsgLyogR0VUICovXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0dW5pdFJhdGlvcy5yZW1Ub1B4ID0gY2FsbFVuaXRDb252ZXJzaW9uRGF0YS5yZW1Ub1B4O1xuXHRcdFx0XHRcdFx0XHRcdHVuaXRSYXRpb3MudndUb1B4ID0gY2FsbFVuaXRDb252ZXJzaW9uRGF0YS52d1RvUHg7XG5cdFx0XHRcdFx0XHRcdFx0dW5pdFJhdGlvcy52aFRvUHggPSBjYWxsVW5pdENvbnZlcnNpb25EYXRhLnZoVG9QeDtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChWZWxvY2l0eS5kZWJ1ZyA+PSAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcIlVuaXQgcmF0aW9zOiBcIiArIEpTT04uc3RyaW5naWZ5KHVuaXRSYXRpb3MpLCBlbGVtZW50KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHVuaXRSYXRpb3M7XG5cdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0XHRcdCBVbml0IENvbnZlcnNpb25cblx0XHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdC8qIFRoZSAqIGFuZCAvIG9wZXJhdG9ycywgd2hpY2ggYXJlIG5vdCBwYXNzZWQgaW4gd2l0aCBhbiBhc3NvY2lhdGVkIHVuaXQsIGluaGVyZW50bHkgdXNlIHN0YXJ0VmFsdWUncyB1bml0LiBTa2lwIHZhbHVlIGFuZCB1bml0IGNvbnZlcnNpb24uICovXG5cdFx0XHRcdFx0XHRcdGlmICgvW1xcLypdLy50ZXN0KG9wZXJhdG9yKSkge1xuXHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlVW5pdFR5cGUgPSBzdGFydFZhbHVlVW5pdFR5cGU7XG5cdFx0XHRcdFx0XHRcdFx0LyogSWYgc3RhcnRWYWx1ZSBhbmQgZW5kVmFsdWUgZGlmZmVyIGluIHVuaXQgdHlwZSwgY29udmVydCBzdGFydFZhbHVlIGludG8gdGhlIHNhbWUgdW5pdCB0eXBlIGFzIGVuZFZhbHVlIHNvIHRoYXQgaWYgZW5kVmFsdWVVbml0VHlwZVxuXHRcdFx0XHRcdFx0XHRcdCBpcyBhIHJlbGF0aXZlIHVuaXQgKCUsIGVtLCByZW0pLCB0aGUgdmFsdWVzIHNldCBkdXJpbmcgdHdlZW5pbmcgd2lsbCBjb250aW51ZSB0byBiZSBhY2N1cmF0ZWx5IHJlbGF0aXZlIGV2ZW4gaWYgdGhlIG1ldHJpY3MgdGhleSBkZXBlbmRcblx0XHRcdFx0XHRcdFx0XHQgb24gYXJlIGR5bmFtaWNhbGx5IGNoYW5naW5nIGR1cmluZyB0aGUgY291cnNlIG9mIHRoZSBhbmltYXRpb24uIENvbnZlcnNlbHksIGlmIHdlIGFsd2F5cyBub3JtYWxpemVkIGludG8gcHggYW5kIHVzZWQgcHggZm9yIHNldHRpbmcgdmFsdWVzLCB0aGUgcHggcmF0aW9cblx0XHRcdFx0XHRcdFx0XHQgd291bGQgYmVjb21lIHN0YWxlIGlmIHRoZSBvcmlnaW5hbCB1bml0IGJlaW5nIGFuaW1hdGVkIHRvd2FyZCB3YXMgcmVsYXRpdmUgYW5kIHRoZSB1bmRlcmx5aW5nIG1ldHJpY3MgY2hhbmdlIGR1cmluZyB0aGUgYW5pbWF0aW9uLiAqL1xuXHRcdFx0XHRcdFx0XHRcdC8qIFNpbmNlIDAgaXMgMCBpbiBhbnkgdW5pdCB0eXBlLCBubyBjb252ZXJzaW9uIGlzIG5lY2Vzc2FyeSB3aGVuIHN0YXJ0VmFsdWUgaXMgMCAtLSB3ZSBqdXN0IHN0YXJ0IGF0IDAgd2l0aCBlbmRWYWx1ZVVuaXRUeXBlLiAqL1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKChzdGFydFZhbHVlVW5pdFR5cGUgIT09IGVuZFZhbHVlVW5pdFR5cGUpICYmIHN0YXJ0VmFsdWUgIT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHQvKiBVbml0IGNvbnZlcnNpb24gaXMgYWxzbyBza2lwcGVkIHdoZW4gZW5kVmFsdWUgaXMgMCwgYnV0ICpzdGFydFZhbHVlVW5pdFR5cGUqIG11c3QgYmUgdXNlZCBmb3IgdHdlZW4gdmFsdWVzIHRvIHJlbWFpbiBhY2N1cmF0ZS4gKi9cblx0XHRcdFx0XHRcdFx0XHQvKiBOb3RlOiBTa2lwcGluZyB1bml0IGNvbnZlcnNpb24gaGVyZSBtZWFucyB0aGF0IGlmIGVuZFZhbHVlVW5pdFR5cGUgd2FzIG9yaWdpbmFsbHkgYSByZWxhdGl2ZSB1bml0LCB0aGUgYW5pbWF0aW9uIHdvbid0IHJlbGF0aXZlbHlcblx0XHRcdFx0XHRcdFx0XHQgbWF0Y2ggdGhlIHVuZGVybHlpbmcgbWV0cmljcyBpZiB0aGV5IGNoYW5nZSwgYnV0IHRoaXMgaXMgYWNjZXB0YWJsZSBzaW5jZSB3ZSdyZSBhbmltYXRpbmcgdG93YXJkIGludmlzaWJpbGl0eSBpbnN0ZWFkIG9mIHRvd2FyZCB2aXNpYmlsaXR5LFxuXHRcdFx0XHRcdFx0XHRcdCB3aGljaCByZW1haW5zIHBhc3QgdGhlIHBvaW50IG9mIHRoZSBhbmltYXRpb24ncyBjb21wbGV0aW9uLiAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmIChlbmRWYWx1ZSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWVVbml0VHlwZSA9IHN0YXJ0VmFsdWVVbml0VHlwZTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0LyogQnkgdGhpcyBwb2ludCwgd2UgY2Fubm90IGF2b2lkIHVuaXQgY29udmVyc2lvbiAoaXQncyB1bmRlc2lyYWJsZSBzaW5jZSBpdCBjYXVzZXMgbGF5b3V0IHRocmFzaGluZykuXG5cdFx0XHRcdFx0XHRcdFx0XHQgSWYgd2UgaGF2ZW4ndCBhbHJlYWR5LCB3ZSB0cmlnZ2VyIGNhbGN1bGF0ZVVuaXRSYXRpb3MoKSwgd2hpY2ggcnVucyBvbmNlIHBlciBlbGVtZW50IHBlciBjYWxsLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0ZWxlbWVudFVuaXRDb252ZXJzaW9uRGF0YSA9IGVsZW1lbnRVbml0Q29udmVyc2lvbkRhdGEgfHwgY2FsY3VsYXRlVW5pdFJhdGlvcygpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBUaGUgZm9sbG93aW5nIFJlZ0V4IG1hdGNoZXMgQ1NTIHByb3BlcnRpZXMgdGhhdCBoYXZlIHRoZWlyICUgdmFsdWVzIG1lYXN1cmVkIHJlbGF0aXZlIHRvIHRoZSB4LWF4aXMuICovXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBOb3RlOiBXM0Mgc3BlYyBtYW5kYXRlcyB0aGF0IGFsbCBvZiBtYXJnaW4gYW5kIHBhZGRpbmcncyBwcm9wZXJ0aWVzIChldmVuIHRvcCBhbmQgYm90dG9tKSBhcmUgJS1yZWxhdGl2ZSB0byB0aGUgKndpZHRoKiBvZiB0aGUgcGFyZW50IGVsZW1lbnQuICovXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgYXhpcyA9ICgvbWFyZ2lufHBhZGRpbmd8bGVmdHxyaWdodHx3aWR0aHx0ZXh0fHdvcmR8bGV0dGVyL2kudGVzdChwcm9wZXJ0eSkgfHwgL1gkLy50ZXN0KHByb3BlcnR5KSB8fCBwcm9wZXJ0eSA9PT0gXCJ4XCIpID8gXCJ4XCIgOiBcInlcIjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0LyogSW4gb3JkZXIgdG8gYXZvaWQgZ2VuZXJhdGluZyBuXjIgYmVzcG9rZSBjb252ZXJzaW9uIGZ1bmN0aW9ucywgdW5pdCBjb252ZXJzaW9uIGlzIGEgdHdvLXN0ZXAgcHJvY2Vzczpcblx0XHRcdFx0XHRcdFx0XHRcdCAxKSBDb252ZXJ0IHN0YXJ0VmFsdWUgaW50byBwaXhlbHMuIDIpIENvbnZlcnQgdGhpcyBuZXcgcGl4ZWwgdmFsdWUgaW50byBlbmRWYWx1ZSdzIHVuaXQgdHlwZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdHN3aXRjaCAoc3RhcnRWYWx1ZVVuaXRUeXBlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgXCIlXCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyogTm90ZTogdHJhbnNsYXRlWCBhbmQgdHJhbnNsYXRlWSBhcmUgdGhlIG9ubHkgcHJvcGVydGllcyB0aGF0IGFyZSAlLXJlbGF0aXZlIHRvIGFuIGVsZW1lbnQncyBvd24gZGltZW5zaW9ucyAtLSBub3QgaXRzIHBhcmVudCdzIGRpbWVuc2lvbnMuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0IFZlbG9jaXR5IGRvZXMgbm90IGluY2x1ZGUgYSBzcGVjaWFsIGNvbnZlcnNpb24gcHJvY2VzcyB0byBhY2NvdW50IGZvciB0aGlzIGJlaGF2aW9yLiBUaGVyZWZvcmUsIGFuaW1hdGluZyB0cmFuc2xhdGVYL1kgZnJvbSBhICUgdmFsdWVcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgdG8gYSBub24tJSB2YWx1ZSB3aWxsIHByb2R1Y2UgYW4gaW5jb3JyZWN0IHN0YXJ0IHZhbHVlLiBGb3J0dW5hdGVseSwgdGhpcyBzb3J0IG9mIGNyb3NzLXVuaXQgY29udmVyc2lvbiBpcyByYXJlbHkgZG9uZSBieSB1c2VycyBpbiBwcmFjdGljZS4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlICo9IChheGlzID09PSBcInhcIiA/IGVsZW1lbnRVbml0Q29udmVyc2lvbkRhdGEucGVyY2VudFRvUHhXaWR0aCA6IGVsZW1lbnRVbml0Q29udmVyc2lvbkRhdGEucGVyY2VudFRvUHhIZWlnaHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJweFwiOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qIHB4IGFjdHMgYXMgb3VyIG1pZHBvaW50IGluIHRoZSB1bml0IGNvbnZlcnNpb24gcHJvY2VzczsgZG8gbm90aGluZy4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHN0YXJ0VmFsdWUgKj0gZWxlbWVudFVuaXRDb252ZXJzaW9uRGF0YVtzdGFydFZhbHVlVW5pdFR5cGUgKyBcIlRvUHhcIl07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8qIEludmVydCB0aGUgcHggcmF0aW9zIHRvIGNvbnZlcnQgaW50byB0byB0aGUgdGFyZ2V0IHVuaXQuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRzd2l0Y2ggKGVuZFZhbHVlVW5pdFR5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSBcIiVcIjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlICo9IDEgLyAoYXhpcyA9PT0gXCJ4XCIgPyBlbGVtZW50VW5pdENvbnZlcnNpb25EYXRhLnBlcmNlbnRUb1B4V2lkdGggOiBlbGVtZW50VW5pdENvbnZlcnNpb25EYXRhLnBlcmNlbnRUb1B4SGVpZ2h0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYXNlIFwicHhcIjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvKiBzdGFydFZhbHVlIGlzIGFscmVhZHkgaW4gcHgsIGRvIG5vdGhpbmc7IHdlJ3JlIGRvbmUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlICo9IDEgLyBlbGVtZW50VW5pdENvbnZlcnNpb25EYXRhW2VuZFZhbHVlVW5pdFR5cGUgKyBcIlRvUHhcIl07XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHQgUmVsYXRpdmUgVmFsdWVzXG5cdFx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHRcdFx0LyogT3BlcmF0b3IgbG9naWMgbXVzdCBiZSBwZXJmb3JtZWQgbGFzdCBzaW5jZSBpdCByZXF1aXJlcyB1bml0LW5vcm1hbGl6ZWQgc3RhcnQgYW5kIGVuZCB2YWx1ZXMuICovXG5cdFx0XHRcdFx0XHRcdC8qIE5vdGU6IFJlbGF0aXZlICpwZXJjZW50IHZhbHVlcyogZG8gbm90IGJlaGF2ZSBob3cgbW9zdCBwZW9wbGUgdGhpbms7IHdoaWxlIG9uZSB3b3VsZCBleHBlY3QgXCIrPTUwJVwiXG5cdFx0XHRcdFx0XHRcdCB0byBpbmNyZWFzZSB0aGUgcHJvcGVydHkgMS41eCBpdHMgY3VycmVudCB2YWx1ZSwgaXQgaW4gZmFjdCBpbmNyZWFzZXMgdGhlIHBlcmNlbnQgdW5pdHMgaW4gYWJzb2x1dGUgdGVybXM6XG5cdFx0XHRcdFx0XHRcdCA1MCBwb2ludHMgaXMgYWRkZWQgb24gdG9wIG9mIHRoZSBjdXJyZW50ICUgdmFsdWUuICovXG5cdFx0XHRcdFx0XHRcdHN3aXRjaCAob3BlcmF0b3IpIHtcblx0XHRcdFx0XHRcdFx0XHRjYXNlIFwiK1wiOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSBzdGFydFZhbHVlICsgZW5kVmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgXCItXCI6XG5cdFx0XHRcdFx0XHRcdFx0XHRlbmRWYWx1ZSA9IHN0YXJ0VmFsdWUgLSBlbmRWYWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBcIipcIjpcblx0XHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlID0gc3RhcnRWYWx1ZSAqIGVuZFZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRcdFx0XHRjYXNlIFwiL1wiOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWUgPSBzdGFydFZhbHVlIC8gZW5kVmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHQgdHdlZW5zQ29udGFpbmVyIFB1c2hcblx0XHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdC8qIENvbnN0cnVjdCB0aGUgcGVyLXByb3BlcnR5IHR3ZWVuIG9iamVjdCwgYW5kIHB1c2ggaXQgdG8gdGhlIGVsZW1lbnQncyB0d2VlbnNDb250YWluZXIuICovXG5cdFx0XHRcdFx0XHRcdHR3ZWVuc0NvbnRhaW5lcltwcm9wZXJ0eV0gPSB7XG5cdFx0XHRcdFx0XHRcdFx0cm9vdFByb3BlcnR5VmFsdWU6IHJvb3RQcm9wZXJ0eVZhbHVlLFxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0VmFsdWU6IHN0YXJ0VmFsdWUsXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudFZhbHVlOiBzdGFydFZhbHVlLFxuXHRcdFx0XHRcdFx0XHRcdGVuZFZhbHVlOiBlbmRWYWx1ZSxcblx0XHRcdFx0XHRcdFx0XHR1bml0VHlwZTogZW5kVmFsdWVVbml0VHlwZSxcblx0XHRcdFx0XHRcdFx0XHRlYXNpbmc6IGVhc2luZ1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRpZiAocGF0dGVybikge1xuXHRcdFx0XHRcdFx0XHRcdHR3ZWVuc0NvbnRhaW5lcltwcm9wZXJ0eV0ucGF0dGVybiA9IHBhdHRlcm47XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRpZiAoVmVsb2NpdHkuZGVidWcpIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcInR3ZWVuc0NvbnRhaW5lciAoXCIgKyBwcm9wZXJ0eSArIFwiKTogXCIgKyBKU09OLnN0cmluZ2lmeSh0d2VlbnNDb250YWluZXJbcHJvcGVydHldKSwgZWxlbWVudCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdC8qIENyZWF0ZSBhIHR3ZWVuIG91dCBvZiBlYWNoIHByb3BlcnR5LCBhbmQgYXBwZW5kIGl0cyBhc3NvY2lhdGVkIGRhdGEgdG8gdHdlZW5zQ29udGFpbmVyLiAqL1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgcHJvcGVydHkgaW4gcHJvcGVydGllc01hcCkge1xuXG5cdFx0XHRcdFx0XHRcdGlmICghcHJvcGVydGllc01hcC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQvKiBUaGUgb3JpZ2luYWwgcHJvcGVydHkgbmFtZSdzIGZvcm1hdCBtdXN0IGJlIHVzZWQgZm9yIHRoZSBwYXJzZVByb3BlcnR5VmFsdWUoKSBsb29rdXAsXG5cdFx0XHRcdFx0XHRcdCBidXQgd2UgdGhlbiB1c2UgaXRzIGNhbWVsQ2FzZSBzdHlsaW5nIHRvIG5vcm1hbGl6ZSBpdCBmb3IgbWFuaXB1bGF0aW9uLiAqL1xuXHRcdFx0XHRcdFx0XHR2YXIgcHJvcGVydHlOYW1lID0gQ1NTLk5hbWVzLmNhbWVsQ2FzZShwcm9wZXJ0eSksXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZURhdGEgPSBwYXJzZVByb3BlcnR5VmFsdWUocHJvcGVydGllc01hcFtwcm9wZXJ0eV0pO1xuXG5cdFx0XHRcdFx0XHRcdC8qIEZpbmQgc2hvcnRoYW5kIGNvbG9yIHByb3BlcnRpZXMgdGhhdCBoYXZlIGJlZW4gcGFzc2VkIGEgaGV4IHN0cmluZy4gKi9cblx0XHRcdFx0XHRcdFx0LyogV291bGQgYmUgcXVpY2tlciB0byB1c2UgQ1NTLkxpc3RzLmNvbG9ycy5pbmNsdWRlcygpIGlmIHBvc3NpYmxlICovXG5cdFx0XHRcdFx0XHRcdGlmIChfaW5BcnJheShDU1MuTGlzdHMuY29sb3JzLCBwcm9wZXJ0eU5hbWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0LyogUGFyc2UgdGhlIHZhbHVlIGRhdGEgZm9yIGVhY2ggc2hvcnRoYW5kLiAqL1xuXHRcdFx0XHRcdFx0XHRcdHZhciBlbmRWYWx1ZSA9IHZhbHVlRGF0YVswXSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZWFzaW5nID0gdmFsdWVEYXRhWzFdLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlID0gdmFsdWVEYXRhWzJdO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKENTUy5SZWdFeC5pc0hleC50ZXN0KGVuZFZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0LyogQ29udmVydCB0aGUgaGV4IHN0cmluZ3MgaW50byB0aGVpciBSR0IgY29tcG9uZW50IGFycmF5cy4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdHZhciBjb2xvckNvbXBvbmVudHMgPSBbXCJSZWRcIiwgXCJHcmVlblwiLCBcIkJsdWVcIl0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZW5kVmFsdWVSR0IgPSBDU1MuVmFsdWVzLmhleFRvUmdiKGVuZFZhbHVlKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRzdGFydFZhbHVlUkdCID0gc3RhcnRWYWx1ZSA/IENTUy5WYWx1ZXMuaGV4VG9SZ2Ioc3RhcnRWYWx1ZSkgOiB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8qIEluamVjdCB0aGUgUkdCIGNvbXBvbmVudCB0d2VlbnMgaW50byBwcm9wZXJ0aWVzTWFwLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvckNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIGRhdGFBcnJheSA9IFtlbmRWYWx1ZVJHQltpXV07XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKGVhc2luZykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRhdGFBcnJheS5wdXNoKGVhc2luZyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoc3RhcnRWYWx1ZVJHQiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YUFycmF5LnB1c2goc3RhcnRWYWx1ZVJHQltpXSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmaXhQcm9wZXJ0eVZhbHVlKHByb3BlcnR5TmFtZSArIGNvbG9yQ29tcG9uZW50c1tpXSwgZGF0YUFycmF5KTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdC8qIElmIHdlIGhhdmUgcmVwbGFjZWQgYSBzaG9ydGN1dCBjb2xvciB2YWx1ZSB0aGVuIGRvbid0IHVwZGF0ZSB0aGUgc3RhbmRhcmQgcHJvcGVydHkgbmFtZSAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGZpeFByb3BlcnR5VmFsdWUocHJvcGVydHlOYW1lLCB2YWx1ZURhdGEpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBBbG9uZyB3aXRoIGl0cyBwcm9wZXJ0eSBkYXRhLCBzdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgZWxlbWVudCBpdHNlbGYgb250byB0d2VlbnNDb250YWluZXIuICovXG5cdFx0XHRcdFx0XHR0d2VlbnNDb250YWluZXIuZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0IENhbGwgUHVzaFxuXHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdC8qIE5vdGU6IHR3ZWVuc0NvbnRhaW5lciBjYW4gYmUgZW1wdHkgaWYgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIGluIHRoaXMgY2FsbCdzIHByb3BlcnR5IG1hcCB3ZXJlIHNraXBwZWQgZHVlIHRvIG5vdFxuXHRcdFx0XHRcdCBiZWluZyBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuIFRoZSBlbGVtZW50IHByb3BlcnR5IGlzIHVzZWQgZm9yIGNoZWNraW5nIHRoYXQgdGhlIHR3ZWVuc0NvbnRhaW5lciBoYXMgYmVlbiBhcHBlbmRlZCB0by4gKi9cblx0XHRcdFx0XHRpZiAodHdlZW5zQ29udGFpbmVyLmVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdC8qIEFwcGx5IHRoZSBcInZlbG9jaXR5LWFuaW1hdGluZ1wiIGluZGljYXRvciBjbGFzcy4gKi9cblx0XHRcdFx0XHRcdENTUy5WYWx1ZXMuYWRkQ2xhc3MoZWxlbWVudCwgXCJ2ZWxvY2l0eS1hbmltYXRpbmdcIik7XG5cblx0XHRcdFx0XHRcdC8qIFRoZSBjYWxsIGFycmF5IGhvdXNlcyB0aGUgdHdlZW5zQ29udGFpbmVycyBmb3IgZWFjaCBlbGVtZW50IGJlaW5nIGFuaW1hdGVkIGluIHRoZSBjdXJyZW50IGNhbGwuICovXG5cdFx0XHRcdFx0XHRjYWxsLnB1c2godHdlZW5zQ29udGFpbmVyKTtcblxuXHRcdFx0XHRcdFx0ZGF0YSA9IERhdGEoZWxlbWVudCk7XG5cblx0XHRcdFx0XHRcdGlmIChkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdC8qIFN0b3JlIHRoZSB0d2VlbnNDb250YWluZXIgYW5kIG9wdGlvbnMgaWYgd2UncmUgd29ya2luZyBvbiB0aGUgZGVmYXVsdCBlZmZlY3RzIHF1ZXVlLCBzbyB0aGF0IHRoZXkgY2FuIGJlIHVzZWQgYnkgdGhlIHJldmVyc2UgY29tbWFuZC4gKi9cblx0XHRcdFx0XHRcdFx0aWYgKG9wdHMucXVldWUgPT09IFwiXCIpIHtcblxuXHRcdFx0XHRcdFx0XHRcdGRhdGEudHdlZW5zQ29udGFpbmVyID0gdHdlZW5zQ29udGFpbmVyO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGEub3B0cyA9IG9wdHM7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvKiBTd2l0Y2ggb24gdGhlIGVsZW1lbnQncyBhbmltYXRpbmcgZmxhZy4gKi9cblx0XHRcdFx0XHRcdFx0ZGF0YS5pc0FuaW1hdGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIE9uY2UgdGhlIGZpbmFsIGVsZW1lbnQgaW4gdGhpcyBjYWxsJ3MgZWxlbWVudCBzZXQgaGFzIGJlZW4gcHJvY2Vzc2VkLCBwdXNoIHRoZSBjYWxsIGFycmF5IG9udG9cblx0XHRcdFx0XHRcdCBWZWxvY2l0eS5TdGF0ZS5jYWxscyBmb3IgdGhlIGFuaW1hdGlvbiB0aWNrIHRvIGltbWVkaWF0ZWx5IGJlZ2luIHByb2Nlc3NpbmcuICovXG5cdFx0XHRcdFx0XHRpZiAoZWxlbWVudHNJbmRleCA9PT0gZWxlbWVudHNMZW5ndGggLSAxKSB7XG5cdFx0XHRcdFx0XHRcdC8qIEFkZCB0aGUgY3VycmVudCBjYWxsIHBsdXMgaXRzIGFzc29jaWF0ZWQgbWV0YWRhdGEgKHRoZSBlbGVtZW50IHNldCBhbmQgdGhlIGNhbGwncyBvcHRpb25zKSBvbnRvIHRoZSBnbG9iYWwgY2FsbCBjb250YWluZXIuXG5cdFx0XHRcdFx0XHRcdCBBbnl0aGluZyBvbiB0aGlzIGNhbGwgY29udGFpbmVyIGlzIHN1YmplY3RlZCB0byB0aWNrKCkgcHJvY2Vzc2luZy4gKi9cblx0XHRcdFx0XHRcdFx0VmVsb2NpdHkuU3RhdGUuY2FsbHMucHVzaChbY2FsbCwgZWxlbWVudHMsIG9wdHMsIG51bGwsIHByb21pc2VEYXRhLnJlc29sdmVyLCBudWxsLCAwXSk7XG5cblx0XHRcdFx0XHRcdFx0LyogSWYgdGhlIGFuaW1hdGlvbiB0aWNrIGlzbid0IHJ1bm5pbmcsIHN0YXJ0IGl0LiAoVmVsb2NpdHkgc2h1dHMgaXQgb2ZmIHdoZW4gdGhlcmUgYXJlIG5vIGFjdGl2ZSBjYWxscyB0byBwcm9jZXNzLikgKi9cblx0XHRcdFx0XHRcdFx0aWYgKFZlbG9jaXR5LlN0YXRlLmlzVGlja2luZyA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdFx0XHRWZWxvY2l0eS5TdGF0ZS5pc1RpY2tpbmcgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogU3RhcnQgdGhlIHRpY2sgbG9vcC4gKi9cblx0XHRcdFx0XHRcdFx0XHR0aWNrKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGVsZW1lbnRzSW5kZXgrKztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBXaGVuIHRoZSBxdWV1ZSBvcHRpb24gaXMgc2V0IHRvIGZhbHNlLCB0aGUgY2FsbCBza2lwcyB0aGUgZWxlbWVudCdzIHF1ZXVlIGFuZCBmaXJlcyBpbW1lZGlhdGVseS4gKi9cblx0XHRcdFx0aWYgKG9wdHMucXVldWUgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0LyogU2luY2UgdGhpcyBidWlsZFF1ZXVlIGNhbGwgZG9lc24ndCByZXNwZWN0IHRoZSBlbGVtZW50J3MgZXhpc3RpbmcgcXVldWUgKHdoaWNoIGlzIHdoZXJlIGEgZGVsYXkgb3B0aW9uIHdvdWxkIGhhdmUgYmVlbiBhcHBlbmRlZCksXG5cdFx0XHRcdFx0IHdlIG1hbnVhbGx5IGluamVjdCB0aGUgZGVsYXkgcHJvcGVydHkgaGVyZSB3aXRoIGFuIGV4cGxpY2l0IHNldFRpbWVvdXQuICovXG5cdFx0XHRcdFx0aWYgKG9wdHMuZGVsYXkpIHtcblxuXHRcdFx0XHRcdFx0LyogVGVtcG9yYXJpbHkgc3RvcmUgZGVsYXllZCBlbGVtZW50cyB0byBmYWNpbGl0YXRlIGFjY2VzcyBmb3IgZ2xvYmFsIHBhdXNlL3Jlc3VtZSAqL1xuXHRcdFx0XHRcdFx0dmFyIGNhbGxJbmRleCA9IFZlbG9jaXR5LlN0YXRlLmRlbGF5ZWRFbGVtZW50cy5jb3VudCsrO1xuXHRcdFx0XHRcdFx0VmVsb2NpdHkuU3RhdGUuZGVsYXllZEVsZW1lbnRzW2NhbGxJbmRleF0gPSBlbGVtZW50O1xuXG5cdFx0XHRcdFx0XHR2YXIgZGVsYXlDb21wbGV0ZSA9IChmdW5jdGlvbihpbmRleCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0LyogQ2xlYXIgdGhlIHRlbXBvcmFyeSBlbGVtZW50ICovXG5cdFx0XHRcdFx0XHRcdFx0VmVsb2NpdHkuU3RhdGUuZGVsYXllZEVsZW1lbnRzW2luZGV4XSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogRmluYWxseSwgaXNzdWUgdGhlIGNhbGwgKi9cblx0XHRcdFx0XHRcdFx0XHRidWlsZFF1ZXVlKCk7XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9KShjYWxsSW5kZXgpO1xuXG5cdFx0XHRcdFx0XHREYXRhKGVsZW1lbnQpLmRlbGF5QmVnaW4gPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXHRcdFx0XHRcdFx0RGF0YShlbGVtZW50KS5kZWxheSA9IHBhcnNlRmxvYXQob3B0cy5kZWxheSk7XG5cdFx0XHRcdFx0XHREYXRhKGVsZW1lbnQpLmRlbGF5VGltZXIgPSB7XG5cdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQ6IHNldFRpbWVvdXQoYnVpbGRRdWV1ZSwgcGFyc2VGbG9hdChvcHRzLmRlbGF5KSksXG5cdFx0XHRcdFx0XHRcdG5leHQ6IGRlbGF5Q29tcGxldGVcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJ1aWxkUXVldWUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0LyogT3RoZXJ3aXNlLCB0aGUgY2FsbCB1bmRlcmdvZXMgZWxlbWVudCBxdWV1ZWluZyBhcyBub3JtYWwuICovXG5cdFx0XHRcdFx0LyogTm90ZTogVG8gaW50ZXJvcGVyYXRlIHdpdGggalF1ZXJ5LCBWZWxvY2l0eSB1c2VzIGpRdWVyeSdzIG93biAkLnF1ZXVlKCkgc3RhY2sgZm9yIHF1ZXVpbmcgbG9naWMuICovXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0JC5xdWV1ZShlbGVtZW50LCBvcHRzLnF1ZXVlLCBmdW5jdGlvbihuZXh0LCBjbGVhclF1ZXVlKSB7XG5cdFx0XHRcdFx0XHQvKiBJZiB0aGUgY2xlYXJRdWV1ZSBmbGFnIHdhcyBwYXNzZWQgaW4gYnkgdGhlIHN0b3AgY29tbWFuZCwgcmVzb2x2ZSB0aGlzIGNhbGwncyBwcm9taXNlLiAoUHJvbWlzZXMgY2FuIG9ubHkgYmUgcmVzb2x2ZWQgb25jZSxcblx0XHRcdFx0XHRcdCBzbyBpdCdzIGZpbmUgaWYgdGhpcyBpcyByZXBlYXRlZGx5IHRyaWdnZXJlZCBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBhc3NvY2lhdGVkIGNhbGwuKSAqL1xuXHRcdFx0XHRcdFx0aWYgKGNsZWFyUXVldWUgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHByb21pc2VEYXRhLnByb21pc2UpIHtcblx0XHRcdFx0XHRcdFx0XHRwcm9taXNlRGF0YS5yZXNvbHZlcihlbGVtZW50cyk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvKiBEbyBub3QgY29udGludWUgd2l0aCBhbmltYXRpb24gcXVldWVpbmcuICovXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBUaGlzIGZsYWcgaW5kaWNhdGVzIHRvIHRoZSB1cGNvbWluZyBjb21wbGV0ZUNhbGwoKSBmdW5jdGlvbiB0aGF0IHRoaXMgcXVldWUgZW50cnkgd2FzIGluaXRpYXRlZCBieSBWZWxvY2l0eS5cblx0XHRcdFx0XHRcdCBTZWUgY29tcGxldGVDYWxsKCkgZm9yIGZ1cnRoZXIgZGV0YWlscy4gKi9cblx0XHRcdFx0XHRcdFZlbG9jaXR5LnZlbG9jaXR5UXVldWVFbnRyeUZsYWcgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRidWlsZFF1ZXVlKG5leHQpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHQgQXV0by1EZXF1ZXVpbmdcblx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHQvKiBBcyBwZXIgalF1ZXJ5J3MgJC5xdWV1ZSgpIGJlaGF2aW9yLCB0byBmaXJlIHRoZSBmaXJzdCBub24tY3VzdG9tLXF1ZXVlIGVudHJ5IG9uIGFuIGVsZW1lbnQsIHRoZSBlbGVtZW50XG5cdFx0XHRcdCBtdXN0IGJlIGRlcXVldWVkIGlmIGl0cyBxdWV1ZSBzdGFjayBjb25zaXN0cyAqc29sZWx5KiBvZiB0aGUgY3VycmVudCBjYWxsLiAoVGhpcyBjYW4gYmUgZGV0ZXJtaW5lZCBieSBjaGVja2luZ1xuXHRcdFx0XHQgZm9yIHRoZSBcImlucHJvZ3Jlc3NcIiBpdGVtIHRoYXQgalF1ZXJ5IHByZXBlbmRzIHRvIGFjdGl2ZSBxdWV1ZSBzdGFjayBhcnJheXMuKSBSZWdhcmRsZXNzLCB3aGVuZXZlciB0aGUgZWxlbWVudCdzXG5cdFx0XHRcdCBxdWV1ZSBpcyBmdXJ0aGVyIGFwcGVuZGVkIHdpdGggYWRkaXRpb25hbCBpdGVtcyAtLSBpbmNsdWRpbmcgJC5kZWxheSgpJ3Mgb3IgZXZlbiAkLmFuaW1hdGUoKSBjYWxscywgdGhlIHF1ZXVlJ3Ncblx0XHRcdFx0IGZpcnN0IGVudHJ5IGlzIGF1dG9tYXRpY2FsbHkgZmlyZWQuIFRoaXMgYmVoYXZpb3IgY29udHJhc3RzIHRoYXQgb2YgY3VzdG9tIHF1ZXVlcywgd2hpY2ggbmV2ZXIgYXV0by1maXJlLiAqL1xuXHRcdFx0XHQvKiBOb3RlOiBXaGVuIGFuIGVsZW1lbnQgc2V0IGlzIGJlaW5nIHN1YmplY3RlZCB0byBhIG5vbi1wYXJhbGxlbCBWZWxvY2l0eSBjYWxsLCB0aGUgYW5pbWF0aW9uIHdpbGwgbm90IGJlZ2luIHVudGlsXG5cdFx0XHRcdCBlYWNoIG9uZSBvZiB0aGUgZWxlbWVudHMgaW4gdGhlIHNldCBoYXMgcmVhY2hlZCB0aGUgZW5kIG9mIGl0cyBpbmRpdmlkdWFsbHkgcHJlLWV4aXN0aW5nIHF1ZXVlIGNoYWluLiAqL1xuXHRcdFx0XHQvKiBOb3RlOiBVbmZvcnR1bmF0ZWx5LCBtb3N0IHBlb3BsZSBkb24ndCBmdWxseSBncmFzcCBqUXVlcnkncyBwb3dlcmZ1bCwgeWV0IHF1aXJreSwgJC5xdWV1ZSgpIGZ1bmN0aW9uLlxuXHRcdFx0XHQgTGVhbiBtb3JlIGhlcmU6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1ODE1OC9jYW4tc29tZWJvZHktZXhwbGFpbi1qcXVlcnktcXVldWUtdG8tbWUgKi9cblx0XHRcdFx0aWYgKChvcHRzLnF1ZXVlID09PSBcIlwiIHx8IG9wdHMucXVldWUgPT09IFwiZnhcIikgJiYgJC5xdWV1ZShlbGVtZW50KVswXSAhPT0gXCJpbnByb2dyZXNzXCIpIHtcblx0XHRcdFx0XHQkLmRlcXVldWUoZWxlbWVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHQgRWxlbWVudCBTZXQgSXRlcmF0aW9uXG5cdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdC8qIElmIHRoZSBcIm5vZGVUeXBlXCIgcHJvcGVydHkgZXhpc3RzIG9uIHRoZSBlbGVtZW50cyB2YXJpYWJsZSwgd2UncmUgYW5pbWF0aW5nIGEgc2luZ2xlIGVsZW1lbnQuXG5cdFx0XHQgUGxhY2UgaXQgaW4gYW4gYXJyYXkgc28gdGhhdCAkLmVhY2goKSBjYW4gaXRlcmF0ZSBvdmVyIGl0LiAqL1xuXHRcdFx0JC5lYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihpLCBlbGVtZW50KSB7XG5cdFx0XHRcdC8qIEVuc3VyZSBlYWNoIGVsZW1lbnQgaW4gYSBzZXQgaGFzIGEgbm9kZVR5cGUgKGlzIGEgcmVhbCBlbGVtZW50KSB0byBhdm9pZCB0aHJvd2luZyBlcnJvcnMuICovXG5cdFx0XHRcdGlmIChUeXBlLmlzTm9kZShlbGVtZW50KSkge1xuXHRcdFx0XHRcdHByb2Nlc3NFbGVtZW50KGVsZW1lbnQsIGkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0LyoqKioqKioqKioqKioqKioqKlxuXHRcdFx0IE9wdGlvbjogTG9vcFxuXHRcdFx0ICoqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0LyogVGhlIGxvb3Agb3B0aW9uIGFjY2VwdHMgYW4gaW50ZWdlciBpbmRpY2F0aW5nIGhvdyBtYW55IHRpbWVzIHRoZSBlbGVtZW50IHNob3VsZCBsb29wIGJldHdlZW4gdGhlIHZhbHVlcyBpbiB0aGVcblx0XHRcdCBjdXJyZW50IGNhbGwncyBwcm9wZXJ0aWVzIG1hcCBhbmQgdGhlIGVsZW1lbnQncyBwcm9wZXJ0eSB2YWx1ZXMgcHJpb3IgdG8gdGhpcyBjYWxsLiAqL1xuXHRcdFx0LyogTm90ZTogVGhlIGxvb3Agb3B0aW9uJ3MgbG9naWMgaXMgcGVyZm9ybWVkIGhlcmUgLS0gYWZ0ZXIgZWxlbWVudCBwcm9jZXNzaW5nIC0tIGJlY2F1c2UgdGhlIGN1cnJlbnQgY2FsbCBuZWVkc1xuXHRcdFx0IHRvIHVuZGVyZ28gaXRzIHF1ZXVlIGluc2VydGlvbiBwcmlvciB0byB0aGUgbG9vcCBvcHRpb24gZ2VuZXJhdGluZyBpdHMgc2VyaWVzIG9mIGNvbnN0aXR1ZW50IFwicmV2ZXJzZVwiIGNhbGxzLFxuXHRcdFx0IHdoaWNoIGNoYWluIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwuIFR3byByZXZlcnNlIGNhbGxzICh0d28gXCJhbHRlcm5hdGlvbnNcIikgY29uc3RpdHV0ZSBvbmUgbG9vcC4gKi9cblx0XHRcdG9wdHMgPSAkLmV4dGVuZCh7fSwgVmVsb2NpdHkuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXHRcdFx0b3B0cy5sb29wID0gcGFyc2VJbnQob3B0cy5sb29wLCAxMCk7XG5cdFx0XHR2YXIgcmV2ZXJzZUNhbGxzQ291bnQgPSAob3B0cy5sb29wICogMikgLSAxO1xuXG5cdFx0XHRpZiAob3B0cy5sb29wKSB7XG5cdFx0XHRcdC8qIERvdWJsZSB0aGUgbG9vcCBjb3VudCB0byBjb252ZXJ0IGl0IGludG8gaXRzIGFwcHJvcHJpYXRlIG51bWJlciBvZiBcInJldmVyc2VcIiBjYWxscy5cblx0XHRcdFx0IFN1YnRyYWN0IDEgZnJvbSB0aGUgcmVzdWx0aW5nIHZhbHVlIHNpbmNlIHRoZSBjdXJyZW50IGNhbGwgaXMgaW5jbHVkZWQgaW4gdGhlIHRvdGFsIGFsdGVybmF0aW9uIGNvdW50LiAqL1xuXHRcdFx0XHRmb3IgKHZhciB4ID0gMDsgeCA8IHJldmVyc2VDYWxsc0NvdW50OyB4KyspIHtcblx0XHRcdFx0XHQvKiBTaW5jZSB0aGUgbG9naWMgZm9yIHRoZSByZXZlcnNlIGFjdGlvbiBvY2N1cnMgaW5zaWRlIFF1ZXVlaW5nIGFuZCB0aGVyZWZvcmUgdGhpcyBjYWxsJ3Mgb3B0aW9ucyBvYmplY3Rcblx0XHRcdFx0XHQgaXNuJ3QgcGFyc2VkIHVudGlsIHRoZW4gYXMgd2VsbCwgdGhlIGN1cnJlbnQgY2FsbCdzIGRlbGF5IG9wdGlvbiBtdXN0IGJlIGV4cGxpY2l0bHkgcGFzc2VkIGludG8gdGhlIHJldmVyc2Vcblx0XHRcdFx0XHQgY2FsbCBzbyB0aGF0IHRoZSBkZWxheSBsb2dpYyB0aGF0IG9jY3VycyBpbnNpZGUgKlByZS1RdWV1ZWluZyogY2FuIHByb2Nlc3MgaXQuICovXG5cdFx0XHRcdFx0dmFyIHJldmVyc2VPcHRpb25zID0ge1xuXHRcdFx0XHRcdFx0ZGVsYXk6IG9wdHMuZGVsYXksXG5cdFx0XHRcdFx0XHRwcm9ncmVzczogb3B0cy5wcm9ncmVzc1xuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHQvKiBJZiBhIGNvbXBsZXRlIGNhbGxiYWNrIHdhcyBwYXNzZWQgaW50byB0aGlzIGNhbGwsIHRyYW5zZmVyIGl0IHRvIHRoZSBsb29wIHJlZGlyZWN0J3MgZmluYWwgXCJyZXZlcnNlXCIgY2FsbFxuXHRcdFx0XHRcdCBzbyB0aGF0IGl0J3MgdHJpZ2dlcmVkIHdoZW4gdGhlIGVudGlyZSByZWRpcmVjdCBpcyBjb21wbGV0ZSAoYW5kIG5vdCB3aGVuIHRoZSB2ZXJ5IGZpcnN0IGFuaW1hdGlvbiBpcyBjb21wbGV0ZSkuICovXG5cdFx0XHRcdFx0aWYgKHggPT09IHJldmVyc2VDYWxsc0NvdW50IC0gMSkge1xuXHRcdFx0XHRcdFx0cmV2ZXJzZU9wdGlvbnMuZGlzcGxheSA9IG9wdHMuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJldmVyc2VPcHRpb25zLnZpc2liaWxpdHkgPSBvcHRzLnZpc2liaWxpdHk7XG5cdFx0XHRcdFx0XHRyZXZlcnNlT3B0aW9ucy5jb21wbGV0ZSA9IG9wdHMuY29tcGxldGU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YW5pbWF0ZShlbGVtZW50cywgXCJyZXZlcnNlXCIsIHJldmVyc2VPcHRpb25zKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvKioqKioqKioqKioqKioqXG5cdFx0XHQgQ2hhaW5pbmdcblx0XHRcdCAqKioqKioqKioqKioqKiovXG5cblx0XHRcdC8qIFJldHVybiB0aGUgZWxlbWVudHMgYmFjayB0byB0aGUgY2FsbCBjaGFpbiwgd2l0aCB3cmFwcGVkIGVsZW1lbnRzIHRha2luZyBwcmVjZWRlbmNlIGluIGNhc2UgVmVsb2NpdHkgd2FzIGNhbGxlZCB2aWEgdGhlICQuZm4uIGV4dGVuc2lvbi4gKi9cblx0XHRcdHJldHVybiBnZXRDaGFpbigpO1xuXHRcdH07XG5cblx0XHQvKiBUdXJuIFZlbG9jaXR5IGludG8gdGhlIGFuaW1hdGlvbiBmdW5jdGlvbiwgZXh0ZW5kZWQgd2l0aCB0aGUgcHJlLWV4aXN0aW5nIFZlbG9jaXR5IG9iamVjdC4gKi9cblx0XHRWZWxvY2l0eSA9ICQuZXh0ZW5kKGFuaW1hdGUsIFZlbG9jaXR5KTtcblx0XHQvKiBGb3IgbGVnYWN5IHN1cHBvcnQsIGFsc28gZXhwb3NlIHRoZSBsaXRlcmFsIGFuaW1hdGUgbWV0aG9kLiAqL1xuXHRcdFZlbG9jaXR5LmFuaW1hdGUgPSBhbmltYXRlO1xuXG5cdFx0LyoqKioqKioqKioqKioqXG5cdFx0IFRpbWluZ1xuXHRcdCAqKioqKioqKioqKioqKi9cblxuXHRcdC8qIFRpY2tlciBmdW5jdGlvbi4gKi9cblx0XHR2YXIgdGlja2VyID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCByQUZTaGltO1xuXG5cdFx0LyogSW5hY3RpdmUgYnJvd3NlciB0YWJzIHBhdXNlIHJBRiwgd2hpY2ggcmVzdWx0cyBpbiBhbGwgYWN0aXZlIGFuaW1hdGlvbnMgaW1tZWRpYXRlbHkgc3ByaW50aW5nIHRvIHRoZWlyIGNvbXBsZXRpb24gc3RhdGVzIHdoZW4gdGhlIHRhYiByZWZvY3VzZXMuXG5cdFx0IFRvIGdldCBhcm91bmQgdGhpcywgd2UgZHluYW1pY2FsbHkgc3dpdGNoIHJBRiB0byBzZXRUaW1lb3V0ICh3aGljaCB0aGUgYnJvd3NlciAqZG9lc24ndCogcGF1c2UpIHdoZW4gdGhlIHRhYiBsb3NlcyBmb2N1cy4gV2Ugc2tpcCB0aGlzIGZvciBtb2JpbGVcblx0XHQgZGV2aWNlcyB0byBhdm9pZCB3YXN0aW5nIGJhdHRlcnkgcG93ZXIgb24gaW5hY3RpdmUgdGFicy4gKi9cblx0XHQvKiBOb3RlOiBUYWIgZm9jdXMgZGV0ZWN0aW9uIGRvZXNuJ3Qgd29yayBvbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgYnV0IHRoYXQncyBva2F5IHNpbmNlIHRoZXkgZG9uJ3Qgc3VwcG9ydCByQUYgdG8gYmVnaW4gd2l0aC4gKi9cblx0XHRpZiAoIVZlbG9jaXR5LlN0YXRlLmlzTW9iaWxlICYmIGRvY3VtZW50LmhpZGRlbiAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR2YXIgdXBkYXRlVGlja2VyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8qIFJlYXNzaWduIHRoZSByQUYgZnVuY3Rpb24gKHdoaWNoIHRoZSBnbG9iYWwgdGljaygpIGZ1bmN0aW9uIHVzZXMpIGJhc2VkIG9uIHRoZSB0YWIncyBmb2N1cyBzdGF0ZS4gKi9cblx0XHRcdFx0aWYgKGRvY3VtZW50LmhpZGRlbikge1xuXHRcdFx0XHRcdHRpY2tlciA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0XHQvKiBUaGUgdGljayBmdW5jdGlvbiBuZWVkcyBhIHRydXRoeSBmaXJzdCBhcmd1bWVudCBpbiBvcmRlciB0byBwYXNzIGl0cyBpbnRlcm5hbCB0aW1lc3RhbXAgY2hlY2suICovXG5cdFx0XHRcdFx0XHRyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sodHJ1ZSk7XG5cdFx0XHRcdFx0XHR9LCAxNik7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdC8qIFRoZSByQUYgbG9vcCBoYXMgYmVlbiBwYXVzZWQgYnkgdGhlIGJyb3dzZXIsIHNvIHdlIG1hbnVhbGx5IHJlc3RhcnQgdGhlIHRpY2suICovXG5cdFx0XHRcdFx0dGljaygpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRpY2tlciA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgckFGU2hpbTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0LyogUGFnZSBjb3VsZCBiZSBzaXR0aW5nIGluIHRoZSBiYWNrZ3JvdW5kIGF0IHRoaXMgdGltZSAoaS5lLiBvcGVuZWQgYXMgbmV3IHRhYikgc28gbWFraW5nIHN1cmUgd2UgdXNlIGNvcnJlY3QgdGlja2VyIGZyb20gdGhlIHN0YXJ0ICovXG5cdFx0XHR1cGRhdGVUaWNrZXIoKTtcblxuXHRcdFx0LyogQW5kIHRoZW4gcnVuIGNoZWNrIGFnYWluIGV2ZXJ5IHRpbWUgdmlzaWJpbGl0eSBjaGFuZ2VzICovXG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCB1cGRhdGVUaWNrZXIpO1xuXHRcdH1cblxuXHRcdC8qKioqKioqKioqKipcblx0XHQgVGlja1xuXHRcdCAqKioqKioqKioqKiovXG5cblx0XHQvKiBOb3RlOiBBbGwgY2FsbHMgdG8gVmVsb2NpdHkgYXJlIHB1c2hlZCB0byB0aGUgVmVsb2NpdHkuU3RhdGUuY2FsbHMgYXJyYXksIHdoaWNoIGlzIGZ1bGx5IGl0ZXJhdGVkIHRocm91Z2ggdXBvbiBlYWNoIHRpY2suICovXG5cdFx0ZnVuY3Rpb24gdGljayh0aW1lc3RhbXApIHtcblx0XHRcdC8qIEFuIGVtcHR5IHRpbWVzdGFtcCBhcmd1bWVudCBpbmRpY2F0ZXMgdGhhdCB0aGlzIGlzIHRoZSBmaXJzdCB0aWNrIG9jY3VyZW5jZSBzaW5jZSB0aWNraW5nIHdhcyB0dXJuZWQgb24uXG5cdFx0XHQgV2UgbGV2ZXJhZ2UgdGhpcyBtZXRhZGF0YSB0byBmdWxseSBpZ25vcmUgdGhlIGZpcnN0IHRpY2sgcGFzcyBzaW5jZSBSQUYncyBpbml0aWFsIHBhc3MgaXMgZmlyZWQgd2hlbmV2ZXJcblx0XHRcdCB0aGUgYnJvd3NlcidzIG5leHQgdGljayBzeW5jIHRpbWUgb2NjdXJzLCB3aGljaCByZXN1bHRzIGluIHRoZSBmaXJzdCBlbGVtZW50cyBzdWJqZWN0ZWQgdG8gVmVsb2NpdHlcblx0XHRcdCBjYWxscyBiZWluZyBhbmltYXRlZCBvdXQgb2Ygc3luYyB3aXRoIGFueSBlbGVtZW50cyBhbmltYXRlZCBpbW1lZGlhdGVseSB0aGVyZWFmdGVyLiBJbiBzaG9ydCwgd2UgaWdub3JlXG5cdFx0XHQgdGhlIGZpcnN0IFJBRiB0aWNrIHBhc3Mgc28gdGhhdCBlbGVtZW50cyBiZWluZyBpbW1lZGlhdGVseSBjb25zZWN1dGl2ZWx5IGFuaW1hdGVkIC0tIGluc3RlYWQgb2Ygc2ltdWx0YW5lb3VzbHkgYW5pbWF0ZWRcblx0XHRcdCBieSB0aGUgc2FtZSBWZWxvY2l0eSBjYWxsIC0tIGFyZSBwcm9wZXJseSBiYXRjaGVkIGludG8gdGhlIHNhbWUgaW5pdGlhbCBSQUYgdGljayBhbmQgY29uc2VxdWVudGx5IHJlbWFpbiBpbiBzeW5jIHRoZXJlYWZ0ZXIuICovXG5cdFx0XHRpZiAodGltZXN0YW1wKSB7XG5cdFx0XHRcdC8qIFdlIG5vcm1hbGx5IHVzZSBSQUYncyBoaWdoIHJlc29sdXRpb24gdGltZXN0YW1wIGJ1dCBhcyBpdCBjYW4gYmUgc2lnbmlmaWNhbnRseSBvZmZzZXQgd2hlbiB0aGUgYnJvd3NlciBpc1xuXHRcdFx0XHQgdW5kZXIgaGlnaCBzdHJlc3Mgd2UgZ2l2ZSB0aGUgb3B0aW9uIGZvciBjaG9wcGluZXNzIG92ZXIgYWxsb3dpbmcgdGhlIGJyb3dzZXIgdG8gZHJvcCBodWdlIGNodW5rcyBvZiBmcmFtZXMuXG5cdFx0XHRcdCBXZSB1c2UgcGVyZm9ybWFuY2Uubm93KCkgYW5kIHNoaW0gaXQgaWYgaXQgZG9lc24ndCBleGlzdCBmb3Igd2hlbiB0aGUgdGFiIGlzIGhpZGRlbi4gKi9cblx0XHRcdFx0dmFyIHRpbWVDdXJyZW50ID0gVmVsb2NpdHkudGltZXN0YW1wICYmIHRpbWVzdGFtcCAhPT0gdHJ1ZSA/IHRpbWVzdGFtcCA6IHBlcmZvcm1hbmNlLm5vdygpO1xuXG5cdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHQgQ2FsbCBJdGVyYXRpb25cblx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdHZhciBjYWxsc0xlbmd0aCA9IFZlbG9jaXR5LlN0YXRlLmNhbGxzLmxlbmd0aDtcblxuXHRcdFx0XHQvKiBUbyBzcGVlZCB1cCBpdGVyYXRpbmcgb3ZlciB0aGlzIGFycmF5LCBpdCBpcyBjb21wYWN0ZWQgKGZhbHNleSBpdGVtcyAtLSBjYWxscyB0aGF0IGhhdmUgY29tcGxldGVkIC0tIGFyZSByZW1vdmVkKVxuXHRcdFx0XHQgd2hlbiBpdHMgbGVuZ3RoIGhhcyBiYWxsb29uZWQgdG8gYSBwb2ludCB0aGF0IGNhbiBpbXBhY3QgdGljayBwZXJmb3JtYW5jZS4gVGhpcyBvbmx5IGJlY29tZXMgbmVjZXNzYXJ5IHdoZW4gYW5pbWF0aW9uXG5cdFx0XHRcdCBoYXMgYmVlbiBjb250aW51b3VzIHdpdGggbWFueSBlbGVtZW50cyBvdmVyIGEgbG9uZyBwZXJpb2Qgb2YgdGltZTsgd2hlbmV2ZXIgYWxsIGFjdGl2ZSBjYWxscyBhcmUgY29tcGxldGVkLCBjb21wbGV0ZUNhbGwoKSBjbGVhcnMgVmVsb2NpdHkuU3RhdGUuY2FsbHMuICovXG5cdFx0XHRcdGlmIChjYWxsc0xlbmd0aCA+IDEwMDAwKSB7XG5cdFx0XHRcdFx0VmVsb2NpdHkuU3RhdGUuY2FsbHMgPSBjb21wYWN0U3BhcnNlQXJyYXkoVmVsb2NpdHkuU3RhdGUuY2FsbHMpO1xuXHRcdFx0XHRcdGNhbGxzTGVuZ3RoID0gVmVsb2NpdHkuU3RhdGUuY2FsbHMubGVuZ3RoO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyogSXRlcmF0ZSB0aHJvdWdoIGVhY2ggYWN0aXZlIGNhbGwuICovXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbHNMZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdC8qIFdoZW4gYSBWZWxvY2l0eSBjYWxsIGlzIGNvbXBsZXRlZCwgaXRzIFZlbG9jaXR5LlN0YXRlLmNhbGxzIGVudHJ5IGlzIHNldCB0byBmYWxzZS4gQ29udGludWUgb24gdG8gdGhlIG5leHQgY2FsbC4gKi9cblx0XHRcdFx0XHRpZiAoIVZlbG9jaXR5LlN0YXRlLmNhbGxzW2ldKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0IENhbGwtV2lkZSBWYXJpYWJsZXNcblx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0dmFyIGNhbGxDb250YWluZXIgPSBWZWxvY2l0eS5TdGF0ZS5jYWxsc1tpXSxcblx0XHRcdFx0XHRcdFx0Y2FsbCA9IGNhbGxDb250YWluZXJbMF0sXG5cdFx0XHRcdFx0XHRcdG9wdHMgPSBjYWxsQ29udGFpbmVyWzJdLFxuXHRcdFx0XHRcdFx0XHR0aW1lU3RhcnQgPSBjYWxsQ29udGFpbmVyWzNdLFxuXHRcdFx0XHRcdFx0XHRmaXJzdFRpY2sgPSAhdGltZVN0YXJ0LFxuXHRcdFx0XHRcdFx0XHR0d2VlbkR1bW15VmFsdWUgPSBudWxsLFxuXHRcdFx0XHRcdFx0XHRwYXVzZU9iamVjdCA9IGNhbGxDb250YWluZXJbNV0sXG5cdFx0XHRcdFx0XHRcdG1pbGxpc2Vjb25kc0VsbGFwc2VkID0gY2FsbENvbnRhaW5lcls2XTtcblxuXG5cblx0XHRcdFx0XHQvKiBJZiB0aW1lU3RhcnQgaXMgdW5kZWZpbmVkLCB0aGVuIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgdGhhdCB0aGlzIGNhbGwgaGFzIGJlZW4gcHJvY2Vzc2VkIGJ5IHRpY2soKS5cblx0XHRcdFx0XHQgV2UgYXNzaWduIHRpbWVTdGFydCBub3cgc28gdGhhdCBpdHMgdmFsdWUgaXMgYXMgY2xvc2UgdG8gdGhlIHJlYWwgYW5pbWF0aW9uIHN0YXJ0IHRpbWUgYXMgcG9zc2libGUuXG5cdFx0XHRcdFx0IChDb252ZXJzZWx5LCBoYWQgdGltZVN0YXJ0IGJlZW4gZGVmaW5lZCB3aGVuIHRoaXMgY2FsbCB3YXMgYWRkZWQgdG8gVmVsb2NpdHkuU3RhdGUuY2FsbHMsIHRoZSBkZWxheVxuXHRcdFx0XHRcdCBiZXR3ZWVuIHRoYXQgdGltZSBhbmQgbm93IHdvdWxkIGNhdXNlIHRoZSBmaXJzdCBmZXcgZnJhbWVzIG9mIHRoZSB0d2VlbiB0byBiZSBza2lwcGVkIHNpbmNlXG5cdFx0XHRcdFx0IHBlcmNlbnRDb21wbGV0ZSBpcyBjYWxjdWxhdGVkIHJlbGF0aXZlIHRvIHRpbWVTdGFydC4pICovXG5cdFx0XHRcdFx0LyogRnVydGhlciwgc3VidHJhY3QgMTZtcyAodGhlIGFwcHJveGltYXRlIHJlc29sdXRpb24gb2YgUkFGKSBmcm9tIHRoZSBjdXJyZW50IHRpbWUgdmFsdWUgc28gdGhhdCB0aGVcblx0XHRcdFx0XHQgZmlyc3QgdGljayBpdGVyYXRpb24gaXNuJ3Qgd2FzdGVkIGJ5IGFuaW1hdGluZyBhdCAwJSB0d2VlbiBjb21wbGV0aW9uLCB3aGljaCB3b3VsZCBwcm9kdWNlIHRoZVxuXHRcdFx0XHRcdCBzYW1lIHN0eWxlIHZhbHVlIGFzIHRoZSBlbGVtZW50J3MgY3VycmVudCB2YWx1ZS4gKi9cblx0XHRcdFx0XHRpZiAoIXRpbWVTdGFydCkge1xuXHRcdFx0XHRcdFx0dGltZVN0YXJ0ID0gVmVsb2NpdHkuU3RhdGUuY2FsbHNbaV1bM10gPSB0aW1lQ3VycmVudCAtIDE2O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8qIElmIGEgcGF1c2Ugb2JqZWN0IGlzIHByZXNlbnQsIHNraXAgcHJvY2Vzc2luZyB1bmxlc3MgaXQgaGFzIGJlZW4gc2V0IHRvIHJlc3VtZSAqL1xuXHRcdFx0XHRcdGlmIChwYXVzZU9iamVjdCkge1xuXHRcdFx0XHRcdFx0aWYgKHBhdXNlT2JqZWN0LnJlc3VtZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0XHQvKiBVcGRhdGUgdGhlIHRpbWUgc3RhcnQgdG8gYWNjb21vZGF0ZSB0aGUgcGF1c2VkIGNvbXBsZXRpb24gYW1vdW50ICovXG5cdFx0XHRcdFx0XHRcdHRpbWVTdGFydCA9IGNhbGxDb250YWluZXJbM10gPSBNYXRoLnJvdW5kKHRpbWVDdXJyZW50IC0gbWlsbGlzZWNvbmRzRWxsYXBzZWQgLSAxNik7XG5cblx0XHRcdFx0XHRcdFx0LyogUmVtb3ZlIHBhdXNlIG9iamVjdCBhZnRlciBwcm9jZXNzaW5nICovXG5cdFx0XHRcdFx0XHRcdGNhbGxDb250YWluZXJbNV0gPSBudWxsO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bWlsbGlzZWNvbmRzRWxsYXBzZWQgPSBjYWxsQ29udGFpbmVyWzZdID0gdGltZUN1cnJlbnQgLSB0aW1lU3RhcnQ7XG5cblx0XHRcdFx0XHQvKiBUaGUgdHdlZW4ncyBjb21wbGV0aW9uIHBlcmNlbnRhZ2UgaXMgcmVsYXRpdmUgdG8gdGhlIHR3ZWVuJ3Mgc3RhcnQgdGltZSwgbm90IHRoZSB0d2VlbidzIHN0YXJ0IHZhbHVlXG5cdFx0XHRcdFx0ICh3aGljaCB3b3VsZCByZXN1bHQgaW4gdW5wcmVkaWN0YWJsZSB0d2VlbiBkdXJhdGlvbnMgc2luY2UgSmF2YVNjcmlwdCdzIHRpbWVycyBhcmUgbm90IHBhcnRpY3VsYXJseSBhY2N1cmF0ZSkuXG5cdFx0XHRcdFx0IEFjY29yZGluZ2x5LCB3ZSBlbnN1cmUgdGhhdCBwZXJjZW50Q29tcGxldGUgZG9lcyBub3QgZXhjZWVkIDEuICovXG5cdFx0XHRcdFx0dmFyIHBlcmNlbnRDb21wbGV0ZSA9IE1hdGgubWluKChtaWxsaXNlY29uZHNFbGxhcHNlZCkgLyBvcHRzLmR1cmF0aW9uLCAxKTtcblxuXHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0IEVsZW1lbnQgSXRlcmF0aW9uXG5cdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHQvKiBGb3IgZXZlcnkgY2FsbCwgaXRlcmF0ZSB0aHJvdWdoIGVhY2ggb2YgdGhlIGVsZW1lbnRzIGluIGl0cyBzZXQuICovXG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDAsIGNhbGxMZW5ndGggPSBjYWxsLmxlbmd0aDsgaiA8IGNhbGxMZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0dmFyIHR3ZWVuc0NvbnRhaW5lciA9IGNhbGxbal0sXG5cdFx0XHRcdFx0XHRcdFx0ZWxlbWVudCA9IHR3ZWVuc0NvbnRhaW5lci5lbGVtZW50O1xuXG5cdFx0XHRcdFx0XHQvKiBDaGVjayB0byBzZWUgaWYgdGhpcyBlbGVtZW50IGhhcyBiZWVuIGRlbGV0ZWQgbWlkd2F5IHRocm91Z2ggdGhlIGFuaW1hdGlvbiBieSBjaGVja2luZyBmb3IgdGhlXG5cdFx0XHRcdFx0XHQgY29udGludWVkIGV4aXN0ZW5jZSBvZiBpdHMgZGF0YSBjYWNoZS4gSWYgaXQncyBnb25lLCBvciB0aGUgZWxlbWVudCBpcyBjdXJyZW50bHkgcGF1c2VkLCBza2lwIGFuaW1hdGluZyB0aGlzIGVsZW1lbnQuICovXG5cdFx0XHRcdFx0XHRpZiAoIURhdGEoZWxlbWVudCkpIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhciB0cmFuc2Zvcm1Qcm9wZXJ0eUV4aXN0cyA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0IERpc3BsYXkgJiBWaXNpYmlsaXR5IFRvZ2dsaW5nXG5cdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdFx0LyogSWYgdGhlIGRpc3BsYXkgb3B0aW9uIGlzIHNldCB0byBub24tXCJub25lXCIsIHNldCBpdCB1cGZyb250IHNvIHRoYXQgdGhlIGVsZW1lbnQgY2FuIGJlY29tZSB2aXNpYmxlIGJlZm9yZSB0d2VlbmluZyBiZWdpbnMuXG5cdFx0XHRcdFx0XHQgKE90aGVyd2lzZSwgZGlzcGxheSdzIFwibm9uZVwiIHZhbHVlIGlzIHNldCBpbiBjb21wbGV0ZUNhbGwoKSBvbmNlIHRoZSBhbmltYXRpb24gaGFzIGNvbXBsZXRlZC4pICovXG5cdFx0XHRcdFx0XHRpZiAob3B0cy5kaXNwbGF5ICE9PSB1bmRlZmluZWQgJiYgb3B0cy5kaXNwbGF5ICE9PSBudWxsICYmIG9wdHMuZGlzcGxheSAhPT0gXCJub25lXCIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKG9wdHMuZGlzcGxheSA9PT0gXCJmbGV4XCIpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgZmxleFZhbHVlcyA9IFtcIi13ZWJraXQtYm94XCIsIFwiLW1vei1ib3hcIiwgXCItbXMtZmxleGJveFwiLCBcIi13ZWJraXQtZmxleFwiXTtcblxuXHRcdFx0XHRcdFx0XHRcdCQuZWFjaChmbGV4VmFsdWVzLCBmdW5jdGlvbihpLCBmbGV4VmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdENTUy5zZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwiZGlzcGxheVwiLCBmbGV4VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Q1NTLnNldFByb3BlcnR5VmFsdWUoZWxlbWVudCwgXCJkaXNwbGF5XCIsIG9wdHMuZGlzcGxheSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8qIFNhbWUgZ29lcyB3aXRoIHRoZSB2aXNpYmlsaXR5IG9wdGlvbiwgYnV0IGl0cyBcIm5vbmVcIiBlcXVpdmFsZW50IGlzIFwiaGlkZGVuXCIuICovXG5cdFx0XHRcdFx0XHRpZiAob3B0cy52aXNpYmlsaXR5ICE9PSB1bmRlZmluZWQgJiYgb3B0cy52aXNpYmlsaXR5ICE9PSBcImhpZGRlblwiKSB7XG5cdFx0XHRcdFx0XHRcdENTUy5zZXRQcm9wZXJ0eVZhbHVlKGVsZW1lbnQsIFwidmlzaWJpbGl0eVwiLCBvcHRzLnZpc2liaWxpdHkpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0XHQgUHJvcGVydHkgSXRlcmF0aW9uXG5cdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHQvKiBGb3IgZXZlcnkgZWxlbWVudCwgaXRlcmF0ZSB0aHJvdWdoIGVhY2ggcHJvcGVydHkuICovXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBwcm9wZXJ0eSBpbiB0d2VlbnNDb250YWluZXIpIHtcblx0XHRcdFx0XHRcdFx0LyogTm90ZTogSW4gYWRkaXRpb24gdG8gcHJvcGVydHkgdHdlZW4gZGF0YSwgdHdlZW5zQ29udGFpbmVyIGNvbnRhaW5zIGEgcmVmZXJlbmNlIHRvIGl0cyBhc3NvY2lhdGVkIGVsZW1lbnQuICovXG5cdFx0XHRcdFx0XHRcdGlmICh0d2VlbnNDb250YWluZXIuaGFzT3duUHJvcGVydHkocHJvcGVydHkpICYmIHByb3BlcnR5ICE9PSBcImVsZW1lbnRcIikge1xuXHRcdFx0XHRcdFx0XHRcdHZhciB0d2VlbiA9IHR3ZWVuc0NvbnRhaW5lcltwcm9wZXJ0eV0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRWYWx1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0LyogRWFzaW5nIGNhbiBlaXRoZXIgYmUgYSBwcmUtZ2VuZXJlYXRlZCBmdW5jdGlvbiBvciBhIHN0cmluZyB0aGF0IHJlZmVyZW5jZXMgYSBwcmUtcmVnaXN0ZXJlZCBlYXNpbmdcblx0XHRcdFx0XHRcdFx0XHRcdFx0IG9uIHRoZSBWZWxvY2l0eS5FYXNpbmdzIG9iamVjdC4gSW4gZWl0aGVyIGNhc2UsIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgZWFzaW5nICpmdW5jdGlvbiouICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVhc2luZyA9IFR5cGUuaXNTdHJpbmcodHdlZW4uZWFzaW5nKSA/IFZlbG9jaXR5LkVhc2luZ3NbdHdlZW4uZWFzaW5nXSA6IHR3ZWVuLmVhc2luZztcblxuXHRcdFx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0XHRcdFx0XHQgQ3VycmVudCBWYWx1ZSBDYWxjdWxhdGlvblxuXHRcdFx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoVHlwZS5pc1N0cmluZyh0d2Vlbi5wYXR0ZXJuKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHBhdHRlcm5SZXBsYWNlID0gcGVyY2VudENvbXBsZXRlID09PSAxID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigkMCwgaW5kZXgsIHJvdW5kKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gdHdlZW4uZW5kVmFsdWVbaW5kZXhdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcm91bmQgPyBNYXRoLnJvdW5kKHJlc3VsdCkgOiByZXN1bHQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oJDAsIGluZGV4LCByb3VuZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHN0YXJ0VmFsdWUgPSB0d2Vlbi5zdGFydFZhbHVlW2luZGV4XSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0d2VlbkRlbHRhID0gdHdlZW4uZW5kVmFsdWVbaW5kZXhdIC0gc3RhcnRWYWx1ZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQgPSBzdGFydFZhbHVlICsgKHR3ZWVuRGVsdGEgKiBlYXNpbmcocGVyY2VudENvbXBsZXRlLCBvcHRzLCB0d2VlbkRlbHRhKSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiByb3VuZCA/IE1hdGgucm91bmQocmVzdWx0KSA6IHJlc3VsdDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50VmFsdWUgPSB0d2Vlbi5wYXR0ZXJuLnJlcGxhY2UoL3soXFxkKykoISk/fS9nLCBwYXR0ZXJuUmVwbGFjZSk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwZXJjZW50Q29tcGxldGUgPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8qIElmIHRoaXMgaXMgdGhlIGxhc3QgdGljayBwYXNzIChpZiB3ZSd2ZSByZWFjaGVkIDEwMCUgY29tcGxldGlvbiBmb3IgdGhpcyB0d2VlbiksXG5cdFx0XHRcdFx0XHRcdFx0XHQgZW5zdXJlIHRoYXQgY3VycmVudFZhbHVlIGlzIGV4cGxpY2l0bHkgc2V0IHRvIGl0cyB0YXJnZXQgZW5kVmFsdWUgc28gdGhhdCBpdCdzIG5vdCBzdWJqZWN0ZWQgdG8gYW55IHJvdW5kaW5nLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFZhbHVlID0gdHdlZW4uZW5kVmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8qIE90aGVyd2lzZSwgY2FsY3VsYXRlIGN1cnJlbnRWYWx1ZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkZWx0YSBmcm9tIHN0YXJ0VmFsdWUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgdHdlZW5EZWx0YSA9IHR3ZWVuLmVuZFZhbHVlIC0gdHdlZW4uc3RhcnRWYWx1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFZhbHVlID0gdHdlZW4uc3RhcnRWYWx1ZSArICh0d2VlbkRlbHRhICogZWFzaW5nKHBlcmNlbnRDb21wbGV0ZSwgb3B0cywgdHdlZW5EZWx0YSkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0LyogSWYgbm8gdmFsdWUgY2hhbmdlIGlzIG9jY3VycmluZywgZG9uJ3QgcHJvY2VlZCB3aXRoIERPTSB1cGRhdGluZy4gKi9cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFmaXJzdFRpY2sgJiYgKGN1cnJlbnRWYWx1ZSA9PT0gdHdlZW4uY3VycmVudFZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0dHdlZW4uY3VycmVudFZhbHVlID0gY3VycmVudFZhbHVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0LyogSWYgd2UncmUgdHdlZW5pbmcgYSBmYWtlICd0d2VlbicgcHJvcGVydHkgaW4gb3JkZXIgdG8gbG9nIHRyYW5zaXRpb24gdmFsdWVzLCB1cGRhdGUgdGhlIG9uZS1wZXItY2FsbCB2YXJpYWJsZSBzbyB0aGF0XG5cdFx0XHRcdFx0XHRcdFx0IGl0IGNhbiBiZSBwYXNzZWQgaW50byB0aGUgcHJvZ3Jlc3MgY2FsbGJhY2suICovXG5cdFx0XHRcdFx0XHRcdFx0aWYgKHByb3BlcnR5ID09PSBcInR3ZWVuXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHR3ZWVuRHVtbXlWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHRcdFx0IEhvb2tzOiBQYXJ0IElcblx0XHRcdFx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKiovXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgaG9va1Jvb3Q7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8qIEZvciBob29rZWQgcHJvcGVydGllcywgdGhlIG5ld2x5LXVwZGF0ZWQgcm9vdFByb3BlcnR5VmFsdWVDYWNoZSBpcyBjYWNoZWQgb250byB0aGUgZWxlbWVudCBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkXG5cdFx0XHRcdFx0XHRcdFx0XHQgZm9yIHN1YnNlcXVlbnQgaG9va3MgaW4gdGhpcyBjYWxsIHRoYXQgYXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgc2FtZSByb290IHByb3BlcnR5LiBJZiB3ZSBkaWRuJ3QgY2FjaGUgdGhlIHVwZGF0ZWRcblx0XHRcdFx0XHRcdFx0XHRcdCByb290UHJvcGVydHlWYWx1ZSwgZWFjaCBzdWJzZXF1ZW50IHVwZGF0ZSB0byB0aGUgcm9vdCBwcm9wZXJ0eSBpbiB0aGlzIHRpY2sgcGFzcyB3b3VsZCByZXNldCB0aGUgcHJldmlvdXMgaG9vaydzXG5cdFx0XHRcdFx0XHRcdFx0XHQgdXBkYXRlcyB0byByb290UHJvcGVydHlWYWx1ZSBwcmlvciB0byBpbmplY3Rpb24uIEEgbmljZSBwZXJmb3JtYW5jZSBieXByb2R1Y3Qgb2Ygcm9vdFByb3BlcnR5VmFsdWUgY2FjaGluZyBpcyB0aGF0XG5cdFx0XHRcdFx0XHRcdFx0XHQgc3Vic2VxdWVudGx5IGNoYWluZWQgYW5pbWF0aW9ucyB1c2luZyB0aGUgc2FtZSBob29rUm9vdCBidXQgYSBkaWZmZXJlbnQgaG9vayBjYW4gdXNlIHRoaXMgY2FjaGVkIHJvb3RQcm9wZXJ0eVZhbHVlLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKENTUy5Ib29rcy5yZWdpc3RlcmVkW3Byb3BlcnR5XSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRob29rUm9vdCA9IENTUy5Ib29rcy5nZXRSb290KHByb3BlcnR5KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgcm9vdFByb3BlcnR5VmFsdWVDYWNoZSA9IERhdGEoZWxlbWVudCkucm9vdFByb3BlcnR5VmFsdWVDYWNoZVtob29rUm9vdF07XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKHJvb3RQcm9wZXJ0eVZhbHVlQ2FjaGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0d2Vlbi5yb290UHJvcGVydHlWYWx1ZSA9IHJvb3RQcm9wZXJ0eVZhbHVlQ2FjaGU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0XHRcdFx0XHQgRE9NIFVwZGF0ZVxuXHRcdFx0XHRcdFx0XHRcdFx0ICoqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBzZXRQcm9wZXJ0eVZhbHVlKCkgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcHJvcGVydHkgbmFtZSBhbmQgcHJvcGVydHkgdmFsdWUgcG9zdCBhbnkgbm9ybWFsaXphdGlvbiB0aGF0IG1heSBoYXZlIGJlZW4gcGVyZm9ybWVkLiAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0LyogTm90ZTogVG8gc29sdmUgYW4gSUU8PTggcG9zaXRpb25pbmcgYnVnLCB0aGUgdW5pdCB0eXBlIGlzIGRyb3BwZWQgd2hlbiBzZXR0aW5nIGEgcHJvcGVydHkgdmFsdWUgb2YgMC4gKi9cblx0XHRcdFx0XHRcdFx0XHRcdHZhciBhZGp1c3RlZFNldERhdGEgPSBDU1Muc2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCAvKiBTRVQgKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0d2Vlbi5jdXJyZW50VmFsdWUgKyAoSUUgPCA5ICYmIHBhcnNlRmxvYXQoY3VycmVudFZhbHVlKSA9PT0gMCA/IFwiXCIgOiB0d2Vlbi51bml0VHlwZSksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHdlZW4ucm9vdFByb3BlcnR5VmFsdWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHdlZW4uc2Nyb2xsRGF0YSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8qKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdFx0XHRcdFx0XHQgSG9va3M6IFBhcnQgSUlcblx0XHRcdFx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvKiBOb3cgdGhhdCB3ZSBoYXZlIHRoZSBob29rJ3MgdXBkYXRlZCByb290UHJvcGVydHlWYWx1ZSAodGhlIHBvc3QtcHJvY2Vzc2VkIHZhbHVlIHByb3ZpZGVkIGJ5IGFkanVzdGVkU2V0RGF0YSksIGNhY2hlIGl0IG9udG8gdGhlIGVsZW1lbnQuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoQ1NTLkhvb2tzLnJlZ2lzdGVyZWRbcHJvcGVydHldKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qIFNpbmNlIGFkanVzdGVkU2V0RGF0YSBjb250YWlucyBub3JtYWxpemVkIGRhdGEgcmVhZHkgZm9yIERPTSB1cGRhdGluZywgdGhlIHJvb3RQcm9wZXJ0eVZhbHVlIG5lZWRzIHRvIGJlIHJlLWV4dHJhY3RlZCBmcm9tIGl0cyBub3JtYWxpemVkIGZvcm0uID8/ICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChDU1MuTm9ybWFsaXphdGlvbnMucmVnaXN0ZXJlZFtob29rUm9vdF0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHREYXRhKGVsZW1lbnQpLnJvb3RQcm9wZXJ0eVZhbHVlQ2FjaGVbaG9va1Jvb3RdID0gQ1NTLk5vcm1hbGl6YXRpb25zLnJlZ2lzdGVyZWRbaG9va1Jvb3RdKFwiZXh0cmFjdFwiLCBudWxsLCBhZGp1c3RlZFNldERhdGFbMV0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdERhdGEoZWxlbWVudCkucm9vdFByb3BlcnR5VmFsdWVDYWNoZVtob29rUm9vdF0gPSBhZGp1c3RlZFNldERhdGFbMV07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0LyoqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0XHRcdFx0IFRyYW5zZm9ybXNcblx0XHRcdFx0XHRcdFx0XHRcdCAqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8qIEZsYWcgd2hldGhlciBhIHRyYW5zZm9ybSBwcm9wZXJ0eSBpcyBiZWluZyBhbmltYXRlZCBzbyB0aGF0IGZsdXNoVHJhbnNmb3JtQ2FjaGUoKSBjYW4gYmUgdHJpZ2dlcmVkIG9uY2UgdGhpcyB0aWNrIHBhc3MgaXMgY29tcGxldGUuICovXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoYWRqdXN0ZWRTZXREYXRhWzBdID09PSBcInRyYW5zZm9ybVwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyYW5zZm9ybVByb3BlcnR5RXhpc3RzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKioqKioqKioqKioqKioqKlxuXHRcdFx0XHRcdFx0IG1vYmlsZUhBXG5cdFx0XHRcdFx0XHQgKioqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHRcdFx0LyogSWYgbW9iaWxlSEEgaXMgZW5hYmxlZCwgc2V0IHRoZSB0cmFuc2xhdGUzZCB0cmFuc2Zvcm0gdG8gbnVsbCB0byBmb3JjZSBoYXJkd2FyZSBhY2NlbGVyYXRpb24uXG5cdFx0XHRcdFx0XHQgSXQncyBzYWZlIHRvIG92ZXJyaWRlIHRoaXMgcHJvcGVydHkgc2luY2UgVmVsb2NpdHkgZG9lc24ndCBhY3R1YWxseSBzdXBwb3J0IGl0cyBhbmltYXRpb24gKGhvb2tzIGFyZSB1c2VkIGluIGl0cyBwbGFjZSkuICovXG5cdFx0XHRcdFx0XHRpZiAob3B0cy5tb2JpbGVIQSkge1xuXHRcdFx0XHRcdFx0XHQvKiBEb24ndCBzZXQgdGhlIG51bGwgdHJhbnNmb3JtIGhhY2sgaWYgd2UndmUgYWxyZWFkeSBkb25lIHNvLiAqL1xuXHRcdFx0XHRcdFx0XHRpZiAoRGF0YShlbGVtZW50KS50cmFuc2Zvcm1DYWNoZS50cmFuc2xhdGUzZCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0LyogQWxsIGVudHJpZXMgb24gdGhlIHRyYW5zZm9ybUNhY2hlIG9iamVjdCBhcmUgbGF0ZXIgY29uY2F0ZW5hdGVkIGludG8gYSBzaW5nbGUgdHJhbnNmb3JtIHN0cmluZyB2aWEgZmx1c2hUcmFuc2Zvcm1DYWNoZSgpLiAqL1xuXHRcdFx0XHRcdFx0XHRcdERhdGEoZWxlbWVudCkudHJhbnNmb3JtQ2FjaGUudHJhbnNsYXRlM2QgPSBcIigwcHgsIDBweCwgMHB4KVwiO1xuXG5cdFx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtUHJvcGVydHlFeGlzdHMgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICh0cmFuc2Zvcm1Qcm9wZXJ0eUV4aXN0cykge1xuXHRcdFx0XHRcdFx0XHRDU1MuZmx1c2hUcmFuc2Zvcm1DYWNoZShlbGVtZW50KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBUaGUgbm9uLVwibm9uZVwiIGRpc3BsYXkgdmFsdWUgaXMgb25seSBhcHBsaWVkIHRvIGFuIGVsZW1lbnQgb25jZSAtLSB3aGVuIGl0cyBhc3NvY2lhdGVkIGNhbGwgaXMgZmlyc3QgdGlja2VkIHRocm91Z2guXG5cdFx0XHRcdFx0IEFjY29yZGluZ2x5LCBpdCdzIHNldCB0byBmYWxzZSBzbyB0aGF0IGl0IGlzbid0IHJlLXByb2Nlc3NlZCBieSB0aGlzIGNhbGwgaW4gdGhlIG5leHQgdGljay4gKi9cblx0XHRcdFx0XHRpZiAob3B0cy5kaXNwbGF5ICE9PSB1bmRlZmluZWQgJiYgb3B0cy5kaXNwbGF5ICE9PSBcIm5vbmVcIikge1xuXHRcdFx0XHRcdFx0VmVsb2NpdHkuU3RhdGUuY2FsbHNbaV1bMl0uZGlzcGxheSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAob3B0cy52aXNpYmlsaXR5ICE9PSB1bmRlZmluZWQgJiYgb3B0cy52aXNpYmlsaXR5ICE9PSBcImhpZGRlblwiKSB7XG5cdFx0XHRcdFx0XHRWZWxvY2l0eS5TdGF0ZS5jYWxsc1tpXVsyXS52aXNpYmlsaXR5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogUGFzcyB0aGUgZWxlbWVudHMgYW5kIHRoZSB0aW1pbmcgZGF0YSAocGVyY2VudENvbXBsZXRlLCBtc1JlbWFpbmluZywgdGltZVN0YXJ0LCB0d2VlbkR1bW15VmFsdWUpIGludG8gdGhlIHByb2dyZXNzIGNhbGxiYWNrLiAqL1xuXHRcdFx0XHRcdGlmIChvcHRzLnByb2dyZXNzKSB7XG5cdFx0XHRcdFx0XHRvcHRzLnByb2dyZXNzLmNhbGwoY2FsbENvbnRhaW5lclsxXSxcblx0XHRcdFx0XHRcdFx0XHRjYWxsQ29udGFpbmVyWzFdLFxuXHRcdFx0XHRcdFx0XHRcdHBlcmNlbnRDb21wbGV0ZSxcblx0XHRcdFx0XHRcdFx0XHRNYXRoLm1heCgwLCAodGltZVN0YXJ0ICsgb3B0cy5kdXJhdGlvbikgLSB0aW1lQ3VycmVudCksXG5cdFx0XHRcdFx0XHRcdFx0dGltZVN0YXJ0LFxuXHRcdFx0XHRcdFx0XHRcdHR3ZWVuRHVtbXlWYWx1ZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogSWYgdGhpcyBjYWxsIGhhcyBmaW5pc2hlZCB0d2VlbmluZywgcGFzcyBpdHMgaW5kZXggdG8gY29tcGxldGVDYWxsKCkgdG8gaGFuZGxlIGNhbGwgY2xlYW51cC4gKi9cblx0XHRcdFx0XHRpZiAocGVyY2VudENvbXBsZXRlID09PSAxKSB7XG5cdFx0XHRcdFx0XHRjb21wbGV0ZUNhbGwoaSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8qIE5vdGU6IGNvbXBsZXRlQ2FsbCgpIHNldHMgdGhlIGlzVGlja2luZyBmbGFnIHRvIGZhbHNlIHdoZW4gdGhlIGxhc3QgY2FsbCBvbiBWZWxvY2l0eS5TdGF0ZS5jYWxscyBoYXMgY29tcGxldGVkLiAqL1xuXHRcdFx0aWYgKFZlbG9jaXR5LlN0YXRlLmlzVGlja2luZykge1xuXHRcdFx0XHR0aWNrZXIodGljayk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqKioqKioqKioqKioqKioqKioqKipcblx0XHQgQ2FsbCBDb21wbGV0aW9uXG5cdFx0ICoqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHQvKiBOb3RlOiBVbmxpa2UgdGljaygpLCB3aGljaCBwcm9jZXNzZXMgYWxsIGFjdGl2ZSBjYWxscyBhdCBvbmNlLCBjYWxsIGNvbXBsZXRpb24gaXMgaGFuZGxlZCBvbiBhIHBlci1jYWxsIGJhc2lzLiAqL1xuXHRcdGZ1bmN0aW9uIGNvbXBsZXRlQ2FsbChjYWxsSW5kZXgsIGlzU3RvcHBlZCkge1xuXHRcdFx0LyogRW5zdXJlIHRoZSBjYWxsIGV4aXN0cy4gKi9cblx0XHRcdGlmICghVmVsb2NpdHkuU3RhdGUuY2FsbHNbY2FsbEluZGV4XSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8qIFB1bGwgdGhlIG1ldGFkYXRhIGZyb20gdGhlIGNhbGwuICovXG5cdFx0XHR2YXIgY2FsbCA9IFZlbG9jaXR5LlN0YXRlLmNhbGxzW2NhbGxJbmRleF1bMF0sXG5cdFx0XHRcdFx0ZWxlbWVudHMgPSBWZWxvY2l0eS5TdGF0ZS5jYWxsc1tjYWxsSW5kZXhdWzFdLFxuXHRcdFx0XHRcdG9wdHMgPSBWZWxvY2l0eS5TdGF0ZS5jYWxsc1tjYWxsSW5kZXhdWzJdLFxuXHRcdFx0XHRcdHJlc29sdmVyID0gVmVsb2NpdHkuU3RhdGUuY2FsbHNbY2FsbEluZGV4XVs0XTtcblxuXHRcdFx0dmFyIHJlbWFpbmluZ0NhbGxzRXhpc3QgPSBmYWxzZTtcblxuXHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdCBFbGVtZW50IEZpbmFsaXphdGlvblxuXHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdGZvciAodmFyIGkgPSAwLCBjYWxsTGVuZ3RoID0gY2FsbC5sZW5ndGg7IGkgPCBjYWxsTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGVsZW1lbnQgPSBjYWxsW2ldLmVsZW1lbnQ7XG5cblx0XHRcdFx0LyogSWYgdGhlIHVzZXIgc2V0IGRpc3BsYXkgdG8gXCJub25lXCIgKGludGVuZGluZyB0byBoaWRlIHRoZSBlbGVtZW50KSwgc2V0IGl0IG5vdyB0aGF0IHRoZSBhbmltYXRpb24gaGFzIGNvbXBsZXRlZC4gKi9cblx0XHRcdFx0LyogTm90ZTogZGlzcGxheTpub25lIGlzbid0IHNldCB3aGVuIGNhbGxzIGFyZSBtYW51YWxseSBzdG9wcGVkICh2aWEgVmVsb2NpdHkoXCJzdG9wXCIpLiAqL1xuXHRcdFx0XHQvKiBOb3RlOiBEaXNwbGF5IGdldHMgaWdub3JlZCB3aXRoIFwicmV2ZXJzZVwiIGNhbGxzIGFuZCBpbmZpbml0ZSBsb29wcywgc2luY2UgdGhpcyBiZWhhdmlvciB3b3VsZCBiZSB1bmRlc2lyYWJsZS4gKi9cblx0XHRcdFx0aWYgKCFpc1N0b3BwZWQgJiYgIW9wdHMubG9vcCkge1xuXHRcdFx0XHRcdGlmIChvcHRzLmRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG5cdFx0XHRcdFx0XHRDU1Muc2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcImRpc3BsYXlcIiwgb3B0cy5kaXNwbGF5KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAob3B0cy52aXNpYmlsaXR5ID09PSBcImhpZGRlblwiKSB7XG5cdFx0XHRcdFx0XHRDU1Muc2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBcInZpc2liaWxpdHlcIiwgb3B0cy52aXNpYmlsaXR5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBJZiB0aGUgZWxlbWVudCdzIHF1ZXVlIGlzIGVtcHR5IChpZiBvbmx5IHRoZSBcImlucHJvZ3Jlc3NcIiBpdGVtIGlzIGxlZnQgYXQgcG9zaXRpb24gMCkgb3IgaWYgaXRzIHF1ZXVlIGlzIGFib3V0IHRvIHJ1blxuXHRcdFx0XHQgYSBub24tVmVsb2NpdHktaW5pdGlhdGVkIGVudHJ5LCB0dXJuIG9mZiB0aGUgaXNBbmltYXRpbmcgZmxhZy4gQSBub24tVmVsb2NpdHktaW5pdGlhdGllZCBxdWV1ZSBlbnRyeSdzIGxvZ2ljIG1pZ2h0IGFsdGVyXG5cdFx0XHRcdCBhbiBlbGVtZW50J3MgQ1NTIHZhbHVlcyBhbmQgdGhlcmVieSBjYXVzZSBWZWxvY2l0eSdzIGNhY2hlZCB2YWx1ZSBkYXRhIHRvIGdvIHN0YWxlLiBUbyBkZXRlY3QgaWYgYSBxdWV1ZSBlbnRyeSB3YXMgaW5pdGlhdGVkIGJ5IFZlbG9jaXR5LFxuXHRcdFx0XHQgd2UgY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2Ygb3VyIHNwZWNpYWwgVmVsb2NpdHkucXVldWVFbnRyeUZsYWcgZGVjbGFyYXRpb24sIHdoaWNoIG1pbmlmaWVycyB3b24ndCByZW5hbWUgc2luY2UgdGhlIGZsYWdcblx0XHRcdFx0IGlzIGFzc2lnbmVkIHRvIGpRdWVyeSdzIGdsb2JhbCAkIG9iamVjdCBhbmQgdGh1cyBleGlzdHMgb3V0IG9mIFZlbG9jaXR5J3Mgb3duIHNjb3BlLiAqL1xuXHRcdFx0XHR2YXIgZGF0YSA9IERhdGEoZWxlbWVudCk7XG5cblx0XHRcdFx0aWYgKG9wdHMubG9vcCAhPT0gdHJ1ZSAmJiAoJC5xdWV1ZShlbGVtZW50KVsxXSA9PT0gdW5kZWZpbmVkIHx8ICEvXFwudmVsb2NpdHlRdWV1ZUVudHJ5RmxhZy9pLnRlc3QoJC5xdWV1ZShlbGVtZW50KVsxXSkpKSB7XG5cdFx0XHRcdFx0LyogVGhlIGVsZW1lbnQgbWF5IGhhdmUgYmVlbiBkZWxldGVkLiBFbnN1cmUgdGhhdCBpdHMgZGF0YSBjYWNoZSBzdGlsbCBleGlzdHMgYmVmb3JlIGFjdGluZyBvbiBpdC4gKi9cblx0XHRcdFx0XHRpZiAoZGF0YSkge1xuXHRcdFx0XHRcdFx0ZGF0YS5pc0FuaW1hdGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0LyogQ2xlYXIgdGhlIGVsZW1lbnQncyByb290UHJvcGVydHlWYWx1ZUNhY2hlLCB3aGljaCB3aWxsIGJlY29tZSBzdGFsZS4gKi9cblx0XHRcdFx0XHRcdGRhdGEucm9vdFByb3BlcnR5VmFsdWVDYWNoZSA9IHt9O1xuXG5cdFx0XHRcdFx0XHR2YXIgdHJhbnNmb3JtSEFQcm9wZXJ0eUV4aXN0cyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0LyogSWYgYW55IDNEIHRyYW5zZm9ybSBzdWJwcm9wZXJ0eSBpcyBhdCBpdHMgZGVmYXVsdCB2YWx1ZSAocmVnYXJkbGVzcyBvZiB1bml0IHR5cGUpLCByZW1vdmUgaXQuICovXG5cdFx0XHRcdFx0XHQkLmVhY2goQ1NTLkxpc3RzLnRyYW5zZm9ybXMzRCwgZnVuY3Rpb24oaSwgdHJhbnNmb3JtTmFtZSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgZGVmYXVsdFZhbHVlID0gL15zY2FsZS8udGVzdCh0cmFuc2Zvcm1OYW1lKSA/IDEgOiAwLFxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudFZhbHVlID0gZGF0YS50cmFuc2Zvcm1DYWNoZVt0cmFuc2Zvcm1OYW1lXTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoZGF0YS50cmFuc2Zvcm1DYWNoZVt0cmFuc2Zvcm1OYW1lXSAhPT0gdW5kZWZpbmVkICYmIG5ldyBSZWdFeHAoXCJeXFxcXChcIiArIGRlZmF1bHRWYWx1ZSArIFwiW14uXVwiKS50ZXN0KGN1cnJlbnRWYWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm1IQVByb3BlcnR5RXhpc3RzID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRcdGRlbGV0ZSBkYXRhLnRyYW5zZm9ybUNhY2hlW3RyYW5zZm9ybU5hbWVdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0LyogTW9iaWxlIGRldmljZXMgaGF2ZSBoYXJkd2FyZSBhY2NlbGVyYXRpb24gcmVtb3ZlZCBhdCB0aGUgZW5kIG9mIHRoZSBhbmltYXRpb24gaW4gb3JkZXIgdG8gYXZvaWQgaG9nZ2luZyB0aGUgR1BVJ3MgbWVtb3J5LiAqL1xuXHRcdFx0XHRcdFx0aWYgKG9wdHMubW9iaWxlSEEpIHtcblx0XHRcdFx0XHRcdFx0dHJhbnNmb3JtSEFQcm9wZXJ0eUV4aXN0cyA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBkYXRhLnRyYW5zZm9ybUNhY2hlLnRyYW5zbGF0ZTNkO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBGbHVzaCB0aGUgc3VicHJvcGVydHkgcmVtb3ZhbHMgdG8gdGhlIERPTS4gKi9cblx0XHRcdFx0XHRcdGlmICh0cmFuc2Zvcm1IQVByb3BlcnR5RXhpc3RzKSB7XG5cdFx0XHRcdFx0XHRcdENTUy5mbHVzaFRyYW5zZm9ybUNhY2hlKGVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvKiBSZW1vdmUgdGhlIFwidmVsb2NpdHktYW5pbWF0aW5nXCIgaW5kaWNhdG9yIGNsYXNzLiAqL1xuXHRcdFx0XHRcdFx0Q1NTLlZhbHVlcy5yZW1vdmVDbGFzcyhlbGVtZW50LCBcInZlbG9jaXR5LWFuaW1hdGluZ1wiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqXG5cdFx0XHRcdCBPcHRpb246IENvbXBsZXRlXG5cdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0LyogQ29tcGxldGUgaXMgZmlyZWQgb25jZSBwZXIgY2FsbCAobm90IG9uY2UgcGVyIGVsZW1lbnQpIGFuZCBpcyBwYXNzZWQgdGhlIGZ1bGwgcmF3IERPTSBlbGVtZW50IHNldCBhcyBib3RoIGl0cyBjb250ZXh0IGFuZCBpdHMgZmlyc3QgYXJndW1lbnQuICovXG5cdFx0XHRcdC8qIE5vdGU6IENhbGxiYWNrcyBhcmVuJ3QgZmlyZWQgd2hlbiBjYWxscyBhcmUgbWFudWFsbHkgc3RvcHBlZCAodmlhIFZlbG9jaXR5KFwic3RvcFwiKS4gKi9cblx0XHRcdFx0aWYgKCFpc1N0b3BwZWQgJiYgb3B0cy5jb21wbGV0ZSAmJiAhb3B0cy5sb29wICYmIChpID09PSBjYWxsTGVuZ3RoIC0gMSkpIHtcblx0XHRcdFx0XHQvKiBXZSB0aHJvdyBjYWxsYmFja3MgaW4gYSBzZXRUaW1lb3V0IHNvIHRoYXQgdGhyb3duIGVycm9ycyBkb24ndCBoYWx0IHRoZSBleGVjdXRpb24gb2YgVmVsb2NpdHkgaXRzZWxmLiAqL1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRvcHRzLmNvbXBsZXRlLmNhbGwoZWxlbWVudHMsIGVsZW1lbnRzKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0XHRcdFx0XHR9LCAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0XHQgUHJvbWlzZSBSZXNvbHZpbmdcblx0XHRcdFx0ICoqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdFx0LyogTm90ZTogSW5maW5pdGUgbG9vcHMgZG9uJ3QgcmV0dXJuIHByb21pc2VzLiAqL1xuXHRcdFx0XHRpZiAocmVzb2x2ZXIgJiYgb3B0cy5sb29wICE9PSB0cnVlKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZXIoZWxlbWVudHMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKipcblx0XHRcdFx0IE9wdGlvbjogTG9vcCAoSW5maW5pdGUpXG5cdFx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0XHRcdGlmIChkYXRhICYmIG9wdHMubG9vcCA9PT0gdHJ1ZSAmJiAhaXNTdG9wcGVkKSB7XG5cdFx0XHRcdFx0LyogSWYgYSByb3RhdGVYL1kvWiBwcm9wZXJ0eSBpcyBiZWluZyBhbmltYXRlZCBieSAzNjAgZGVnIHdpdGggbG9vcDp0cnVlLCBzd2FwIHR3ZWVuIHN0YXJ0L2VuZCB2YWx1ZXMgdG8gZW5hYmxlXG5cdFx0XHRcdFx0IGNvbnRpbnVvdXMgaXRlcmF0aXZlIHJvdGF0aW9uIGxvb3BpbmcuIChPdGhlcmlzZSwgdGhlIGVsZW1lbnQgd291bGQganVzdCByb3RhdGUgYmFjayBhbmQgZm9ydGguKSAqL1xuXHRcdFx0XHRcdCQuZWFjaChkYXRhLnR3ZWVuc0NvbnRhaW5lciwgZnVuY3Rpb24ocHJvcGVydHlOYW1lLCB0d2VlbkNvbnRhaW5lcikge1xuXHRcdFx0XHRcdFx0aWYgKC9ecm90YXRlLy50ZXN0KHByb3BlcnR5TmFtZSkgJiYgKChwYXJzZUZsb2F0KHR3ZWVuQ29udGFpbmVyLnN0YXJ0VmFsdWUpIC0gcGFyc2VGbG9hdCh0d2VlbkNvbnRhaW5lci5lbmRWYWx1ZSkpICUgMzYwID09PSAwKSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgb2xkU3RhcnRWYWx1ZSA9IHR3ZWVuQ29udGFpbmVyLnN0YXJ0VmFsdWU7XG5cblx0XHRcdFx0XHRcdFx0dHdlZW5Db250YWluZXIuc3RhcnRWYWx1ZSA9IHR3ZWVuQ29udGFpbmVyLmVuZFZhbHVlO1xuXHRcdFx0XHRcdFx0XHR0d2VlbkNvbnRhaW5lci5lbmRWYWx1ZSA9IG9sZFN0YXJ0VmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmICgvXmJhY2tncm91bmRQb3NpdGlvbi8udGVzdChwcm9wZXJ0eU5hbWUpICYmIHBhcnNlRmxvYXQodHdlZW5Db250YWluZXIuZW5kVmFsdWUpID09PSAxMDAgJiYgdHdlZW5Db250YWluZXIudW5pdFR5cGUgPT09IFwiJVwiKSB7XG5cdFx0XHRcdFx0XHRcdHR3ZWVuQ29udGFpbmVyLmVuZFZhbHVlID0gMDtcblx0XHRcdFx0XHRcdFx0dHdlZW5Db250YWluZXIuc3RhcnRWYWx1ZSA9IDEwMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFZlbG9jaXR5KGVsZW1lbnQsIFwicmV2ZXJzZVwiLCB7bG9vcDogdHJ1ZSwgZGVsYXk6IG9wdHMuZGVsYXl9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qKioqKioqKioqKioqKipcblx0XHRcdFx0IERlcXVldWVpbmdcblx0XHRcdFx0ICoqKioqKioqKioqKioqKi9cblxuXHRcdFx0XHQvKiBGaXJlIHRoZSBuZXh0IGNhbGwgaW4gdGhlIHF1ZXVlIHNvIGxvbmcgYXMgdGhpcyBjYWxsJ3MgcXVldWUgd2Fzbid0IHNldCB0byBmYWxzZSAodG8gdHJpZ2dlciBhIHBhcmFsbGVsIGFuaW1hdGlvbiksXG5cdFx0XHRcdCB3aGljaCB3b3VsZCBoYXZlIGFscmVhZHkgY2F1c2VkIHRoZSBuZXh0IGNhbGwgdG8gZmlyZS4gTm90ZTogRXZlbiBpZiB0aGUgZW5kIG9mIHRoZSBhbmltYXRpb24gcXVldWUgaGFzIGJlZW4gcmVhY2hlZCxcblx0XHRcdFx0ICQuZGVxdWV1ZSgpIG11c3Qgc3RpbGwgYmUgY2FsbGVkIGluIG9yZGVyIHRvIGNvbXBsZXRlbHkgY2xlYXIgalF1ZXJ5J3MgYW5pbWF0aW9uIHF1ZXVlLiAqL1xuXHRcdFx0XHRpZiAob3B0cy5xdWV1ZSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHQkLmRlcXVldWUoZWxlbWVudCwgb3B0cy5xdWV1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0LyoqKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdFx0IENhbGxzIEFycmF5IENsZWFudXBcblx0XHRcdCAqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHRcdC8qIFNpbmNlIHRoaXMgY2FsbCBpcyBjb21wbGV0ZSwgc2V0IGl0IHRvIGZhbHNlIHNvIHRoYXQgdGhlIHJBRiB0aWNrIHNraXBzIGl0LiBUaGlzIGFycmF5IGlzIGxhdGVyIGNvbXBhY3RlZCB2aWEgY29tcGFjdFNwYXJzZUFycmF5KCkuXG5cdFx0XHQgKEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB0aGUgY2FsbCBpcyBzZXQgdG8gZmFsc2UgaW5zdGVhZCBvZiBiZWluZyBkZWxldGVkIGZyb20gdGhlIGFycmF5OiBodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9zcGVlZC92OC8pICovXG5cdFx0XHRWZWxvY2l0eS5TdGF0ZS5jYWxsc1tjYWxsSW5kZXhdID0gZmFsc2U7XG5cblx0XHRcdC8qIEl0ZXJhdGUgdGhyb3VnaCB0aGUgY2FsbHMgYXJyYXkgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgd2FzIHRoZSBmaW5hbCBpbi1wcm9ncmVzcyBhbmltYXRpb24uXG5cdFx0XHQgSWYgc28sIHNldCBhIGZsYWcgdG8gZW5kIHRpY2tpbmcgYW5kIGNsZWFyIHRoZSBjYWxscyBhcnJheS4gKi9cblx0XHRcdGZvciAodmFyIGogPSAwLCBjYWxsc0xlbmd0aCA9IFZlbG9jaXR5LlN0YXRlLmNhbGxzLmxlbmd0aDsgaiA8IGNhbGxzTGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0aWYgKFZlbG9jaXR5LlN0YXRlLmNhbGxzW2pdICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdHJlbWFpbmluZ0NhbGxzRXhpc3QgPSB0cnVlO1xuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHJlbWFpbmluZ0NhbGxzRXhpc3QgPT09IGZhbHNlKSB7XG5cdFx0XHRcdC8qIHRpY2soKSB3aWxsIGRldGVjdCB0aGlzIGZsYWcgdXBvbiBpdHMgbmV4dCBpdGVyYXRpb24gYW5kIHN1YnNlcXVlbnRseSB0dXJuIGl0c2VsZiBvZmYuICovXG5cdFx0XHRcdFZlbG9jaXR5LlN0YXRlLmlzVGlja2luZyA9IGZhbHNlO1xuXG5cdFx0XHRcdC8qIENsZWFyIHRoZSBjYWxscyBhcnJheSBzbyB0aGF0IGl0cyBsZW5ndGggaXMgcmVzZXQuICovXG5cdFx0XHRcdGRlbGV0ZSBWZWxvY2l0eS5TdGF0ZS5jYWxscztcblx0XHRcdFx0VmVsb2NpdHkuU3RhdGUuY2FsbHMgPSBbXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKioqKioqKioqKioqKioqKioqXG5cdFx0IEZyYW1ld29ya3Ncblx0XHQgKioqKioqKioqKioqKioqKioqL1xuXG5cdFx0LyogQm90aCBqUXVlcnkgYW5kIFplcHRvIGFsbG93IHRoZWlyICQuZm4gb2JqZWN0IHRvIGJlIGV4dGVuZGVkIHRvIGFsbG93IHdyYXBwZWQgZWxlbWVudHMgdG8gYmUgc3ViamVjdGVkIHRvIHBsdWdpbiBjYWxscy5cblx0XHQgSWYgZWl0aGVyIGZyYW1ld29yayBpcyBsb2FkZWQsIHJlZ2lzdGVyIGEgXCJ2ZWxvY2l0eVwiIGV4dGVuc2lvbiBwb2ludGluZyB0byBWZWxvY2l0eSdzIGNvcmUgYW5pbWF0ZSgpIG1ldGhvZC4gIFZlbG9jaXR5XG5cdFx0IGFsc28gcmVnaXN0ZXJzIGl0c2VsZiBvbnRvIGEgZ2xvYmFsIGNvbnRhaW5lciAod2luZG93LmpRdWVyeSB8fCB3aW5kb3cuWmVwdG8gfHwgd2luZG93KSBzbyB0aGF0IGNlcnRhaW4gZmVhdHVyZXMgYXJlXG5cdFx0IGFjY2Vzc2libGUgYmV5b25kIGp1c3QgYSBwZXItZWxlbWVudCBzY29wZS4gVGhpcyBtYXN0ZXIgb2JqZWN0IGNvbnRhaW5zIGFuIC5hbmltYXRlKCkgbWV0aG9kLCB3aGljaCBpcyBsYXRlciBhc3NpZ25lZCB0byAkLmZuXG5cdFx0IChpZiBqUXVlcnkgb3IgWmVwdG8gYXJlIHByZXNlbnQpLiBBY2NvcmRpbmdseSwgVmVsb2NpdHkgY2FuIGJvdGggYWN0IG9uIHdyYXBwZWQgRE9NIGVsZW1lbnRzIGFuZCBzdGFuZCBhbG9uZSBmb3IgdGFyZ2V0aW5nIHJhdyBET00gZWxlbWVudHMuICovXG5cdFx0Z2xvYmFsLlZlbG9jaXR5ID0gVmVsb2NpdHk7XG5cblx0XHRpZiAoZ2xvYmFsICE9PSB3aW5kb3cpIHtcblx0XHRcdC8qIEFzc2lnbiB0aGUgZWxlbWVudCBmdW5jdGlvbiB0byBWZWxvY2l0eSdzIGNvcmUgYW5pbWF0ZSgpIG1ldGhvZC4gKi9cblx0XHRcdGdsb2JhbC5mbi52ZWxvY2l0eSA9IGFuaW1hdGU7XG5cdFx0XHQvKiBBc3NpZ24gdGhlIG9iamVjdCBmdW5jdGlvbidzIGRlZmF1bHRzIHRvIFZlbG9jaXR5J3MgZ2xvYmFsIGRlZmF1bHRzIG9iamVjdC4gKi9cblx0XHRcdGdsb2JhbC5mbi52ZWxvY2l0eS5kZWZhdWx0cyA9IFZlbG9jaXR5LmRlZmF1bHRzO1xuXHRcdH1cblxuXHRcdC8qKioqKioqKioqKioqKioqKioqKioqKlxuXHRcdCBQYWNrYWdlZCBSZWRpcmVjdHNcblx0XHQgKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0XHQvKiBzbGlkZVVwLCBzbGlkZURvd24gKi9cblx0XHQkLmVhY2goW1wiRG93blwiLCBcIlVwXCJdLCBmdW5jdGlvbihpLCBkaXJlY3Rpb24pIHtcblx0XHRcdFZlbG9jaXR5LlJlZGlyZWN0c1tcInNsaWRlXCIgKyBkaXJlY3Rpb25dID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucywgZWxlbWVudHNJbmRleCwgZWxlbWVudHNTaXplLCBlbGVtZW50cywgcHJvbWlzZURhdGEpIHtcblx0XHRcdFx0dmFyIG9wdHMgPSAkLmV4dGVuZCh7fSwgb3B0aW9ucyksXG5cdFx0XHRcdFx0XHRiZWdpbiA9IG9wdHMuYmVnaW4sXG5cdFx0XHRcdFx0XHRjb21wbGV0ZSA9IG9wdHMuY29tcGxldGUsXG5cdFx0XHRcdFx0XHRpbmxpbmVWYWx1ZXMgPSB7fSxcblx0XHRcdFx0XHRcdGNvbXB1dGVkVmFsdWVzID0ge2hlaWdodDogXCJcIiwgbWFyZ2luVG9wOiBcIlwiLCBtYXJnaW5Cb3R0b206IFwiXCIsIHBhZGRpbmdUb3A6IFwiXCIsIHBhZGRpbmdCb3R0b206IFwiXCJ9O1xuXG5cdFx0XHRcdGlmIChvcHRzLmRpc3BsYXkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdC8qIFNob3cgdGhlIGVsZW1lbnQgYmVmb3JlIHNsaWRlRG93biBiZWdpbnMgYW5kIGhpZGUgdGhlIGVsZW1lbnQgYWZ0ZXIgc2xpZGVVcCBjb21wbGV0ZXMuICovXG5cdFx0XHRcdFx0LyogTm90ZTogSW5saW5lIGVsZW1lbnRzIGNhbm5vdCBoYXZlIGRpbWVuc2lvbnMgYW5pbWF0ZWQsIHNvIHRoZXkncmUgcmV2ZXJ0ZWQgdG8gaW5saW5lLWJsb2NrLiAqL1xuXHRcdFx0XHRcdG9wdHMuZGlzcGxheSA9IChkaXJlY3Rpb24gPT09IFwiRG93blwiID8gKFZlbG9jaXR5LkNTUy5WYWx1ZXMuZ2V0RGlzcGxheVR5cGUoZWxlbWVudCkgPT09IFwiaW5saW5lXCIgPyBcImlubGluZS1ibG9ja1wiIDogXCJibG9ja1wiKSA6IFwibm9uZVwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG9wdHMuYmVnaW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvKiBJZiB0aGUgdXNlciBwYXNzZWQgaW4gYSBiZWdpbiBjYWxsYmFjaywgZmlyZSBpdCBub3cuICovXG5cdFx0XHRcdFx0aWYgKGVsZW1lbnRzSW5kZXggPT09IDAgJiYgYmVnaW4pIHtcblx0XHRcdFx0XHRcdGJlZ2luLmNhbGwoZWxlbWVudHMsIGVsZW1lbnRzKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBDYWNoZSB0aGUgZWxlbWVudHMnIG9yaWdpbmFsIHZlcnRpY2FsIGRpbWVuc2lvbmFsIHByb3BlcnR5IHZhbHVlcyBzbyB0aGF0IHdlIGNhbiBhbmltYXRlIGJhY2sgdG8gdGhlbS4gKi9cblx0XHRcdFx0XHRmb3IgKHZhciBwcm9wZXJ0eSBpbiBjb21wdXRlZFZhbHVlcykge1xuXHRcdFx0XHRcdFx0aWYgKCFjb21wdXRlZFZhbHVlcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpbmxpbmVWYWx1ZXNbcHJvcGVydHldID0gZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV07XG5cblx0XHRcdFx0XHRcdC8qIEZvciBzbGlkZURvd24sIHVzZSBmb3JjZWZlZWRpbmcgdG8gYW5pbWF0ZSBhbGwgdmVydGljYWwgcHJvcGVydGllcyBmcm9tIDAuIEZvciBzbGlkZVVwLFxuXHRcdFx0XHRcdFx0IHVzZSBmb3JjZWZlZWRpbmcgdG8gc3RhcnQgZnJvbSBjb21wdXRlZCB2YWx1ZXMgYW5kIGFuaW1hdGUgZG93biB0byAwLiAqL1xuXHRcdFx0XHRcdFx0dmFyIHByb3BlcnR5VmFsdWUgPSBDU1MuZ2V0UHJvcGVydHlWYWx1ZShlbGVtZW50LCBwcm9wZXJ0eSk7XG5cdFx0XHRcdFx0XHRjb21wdXRlZFZhbHVlc1twcm9wZXJ0eV0gPSAoZGlyZWN0aW9uID09PSBcIkRvd25cIikgPyBbcHJvcGVydHlWYWx1ZSwgMF0gOiBbMCwgcHJvcGVydHlWYWx1ZV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogRm9yY2UgdmVydGljYWwgb3ZlcmZsb3cgY29udGVudCB0byBjbGlwIHNvIHRoYXQgc2xpZGluZyB3b3JrcyBhcyBleHBlY3RlZC4gKi9cblx0XHRcdFx0XHRpbmxpbmVWYWx1ZXMub3ZlcmZsb3cgPSBlbGVtZW50LnN0eWxlLm92ZXJmbG93O1xuXHRcdFx0XHRcdGVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdG9wdHMuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQvKiBSZXNldCBlbGVtZW50IHRvIGl0cyBwcmUtc2xpZGUgaW5saW5lIHZhbHVlcyBvbmNlIGl0cyBzbGlkZSBhbmltYXRpb24gaXMgY29tcGxldGUuICovXG5cdFx0XHRcdFx0Zm9yICh2YXIgcHJvcGVydHkgaW4gaW5saW5lVmFsdWVzKSB7XG5cdFx0XHRcdFx0XHRpZiAoaW5saW5lVmFsdWVzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuXHRcdFx0XHRcdFx0XHRlbGVtZW50LnN0eWxlW3Byb3BlcnR5XSA9IGlubGluZVZhbHVlc1twcm9wZXJ0eV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogSWYgdGhlIHVzZXIgcGFzc2VkIGluIGEgY29tcGxldGUgY2FsbGJhY2ssIGZpcmUgaXQgbm93LiAqL1xuXHRcdFx0XHRcdGlmIChlbGVtZW50c0luZGV4ID09PSBlbGVtZW50c1NpemUgLSAxKSB7XG5cdFx0XHRcdFx0XHRpZiAoY29tcGxldGUpIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUuY2FsbChlbGVtZW50cywgZWxlbWVudHMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHByb21pc2VEYXRhKSB7XG5cdFx0XHRcdFx0XHRcdHByb21pc2VEYXRhLnJlc29sdmVyKGVsZW1lbnRzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0VmVsb2NpdHkoZWxlbWVudCwgY29tcHV0ZWRWYWx1ZXMsIG9wdHMpO1xuXHRcdFx0fTtcblx0XHR9KTtcblxuXHRcdC8qIGZhZGVJbiwgZmFkZU91dCAqL1xuXHRcdCQuZWFjaChbXCJJblwiLCBcIk91dFwiXSwgZnVuY3Rpb24oaSwgZGlyZWN0aW9uKSB7XG5cdFx0XHRWZWxvY2l0eS5SZWRpcmVjdHNbXCJmYWRlXCIgKyBkaXJlY3Rpb25dID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucywgZWxlbWVudHNJbmRleCwgZWxlbWVudHNTaXplLCBlbGVtZW50cywgcHJvbWlzZURhdGEpIHtcblx0XHRcdFx0dmFyIG9wdHMgPSAkLmV4dGVuZCh7fSwgb3B0aW9ucyksXG5cdFx0XHRcdFx0XHRjb21wbGV0ZSA9IG9wdHMuY29tcGxldGUsXG5cdFx0XHRcdFx0XHRwcm9wZXJ0aWVzTWFwID0ge29wYWNpdHk6IChkaXJlY3Rpb24gPT09IFwiSW5cIikgPyAxIDogMH07XG5cblx0XHRcdFx0LyogU2luY2UgcmVkaXJlY3RzIGFyZSB0cmlnZ2VyZWQgaW5kaXZpZHVhbGx5IGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIGFuaW1hdGVkIHNldCwgYXZvaWQgcmVwZWF0ZWRseSB0cmlnZ2VyaW5nXG5cdFx0XHRcdCBjYWxsYmFja3MgYnkgZmlyaW5nIHRoZW0gb25seSB3aGVuIHRoZSBmaW5hbCBlbGVtZW50IGhhcyBiZWVuIHJlYWNoZWQuICovXG5cdFx0XHRcdGlmIChlbGVtZW50c0luZGV4ICE9PSAwKSB7XG5cdFx0XHRcdFx0b3B0cy5iZWdpbiA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVsZW1lbnRzSW5kZXggIT09IGVsZW1lbnRzU2l6ZSAtIDEpIHtcblx0XHRcdFx0XHRvcHRzLmNvbXBsZXRlID0gbnVsbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvcHRzLmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoY29tcGxldGUpIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUuY2FsbChlbGVtZW50cywgZWxlbWVudHMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHByb21pc2VEYXRhKSB7XG5cdFx0XHRcdFx0XHRcdHByb21pc2VEYXRhLnJlc29sdmVyKGVsZW1lbnRzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyogSWYgYSBkaXNwbGF5IHdhcyBwYXNzZWQgaW4sIHVzZSBpdC4gT3RoZXJ3aXNlLCBkZWZhdWx0IHRvIFwibm9uZVwiIGZvciBmYWRlT3V0IG9yIHRoZSBlbGVtZW50LXNwZWNpZmljIGRlZmF1bHQgZm9yIGZhZGVJbi4gKi9cblx0XHRcdFx0LyogTm90ZTogV2UgYWxsb3cgdXNlcnMgdG8gcGFzcyBpbiBcIm51bGxcIiB0byBza2lwIGRpc3BsYXkgc2V0dGluZyBhbHRvZ2V0aGVyLiAqL1xuXHRcdFx0XHRpZiAob3B0cy5kaXNwbGF5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRvcHRzLmRpc3BsYXkgPSAoZGlyZWN0aW9uID09PSBcIkluXCIgPyBcImF1dG9cIiA6IFwibm9uZVwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdFZlbG9jaXR5KHRoaXMsIHByb3BlcnRpZXNNYXAsIG9wdHMpO1xuXHRcdFx0fTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBWZWxvY2l0eTtcblx0fSgod2luZG93LmpRdWVyeSB8fCB3aW5kb3cuWmVwdG8gfHwgd2luZG93KSwgd2luZG93LCAod2luZG93ID8gd2luZG93LmRvY3VtZW50IDogdW5kZWZpbmVkKSk7XG59KSk7XG5cbi8qKioqKioqKioqKioqKioqKipcbiBLbm93biBJc3N1ZXNcbiAqKioqKioqKioqKioqKioqKiovXG5cbi8qIFRoZSBDU1Mgc3BlYyBtYW5kYXRlcyB0aGF0IHRoZSB0cmFuc2xhdGVYL1kvWiB0cmFuc2Zvcm1zIGFyZSAlLXJlbGF0aXZlIHRvIHRoZSBlbGVtZW50IGl0c2VsZiAtLSBub3QgaXRzIHBhcmVudC5cbiBWZWxvY2l0eSwgaG93ZXZlciwgZG9lc24ndCBtYWtlIHRoaXMgZGlzdGluY3Rpb24uIFRodXMsIGNvbnZlcnRpbmcgdG8gb3IgZnJvbSB0aGUgJSB1bml0IHdpdGggdGhlc2Ugc3VicHJvcGVydGllc1xuIHdpbGwgcHJvZHVjZSBhbiBpbmFjY3VyYXRlIGNvbnZlcnNpb24gdmFsdWUuIFRoZSBzYW1lIGlzc3VlIGV4aXN0cyB3aXRoIHRoZSBjeC9jeSBhdHRyaWJ1dGVzIG9mIFNWRyBjaXJjbGVzIGFuZCBlbGxpcHNlcy4gKi9cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3ZlbG9jaXR5LWFuaW1hdGUvdmVsb2NpdHkuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9qc3gudHNcIiAvPlxyXG5cInVzZSBzdHJpY3RcIjtcclxuaW1wb3J0IHsgVk5vZGUsIFZOb2RlUHJvcGVydGllcyB9IGZyb20gXCJtYXF1ZXR0ZVwiO1xyXG5kZWNsYXJlIHZhciByZXF1aXJlOiBhbnk7XHJcbmltcG9ydCAqIGFzIG1hcXVldHRlIGZyb20gXCJtYXF1ZXR0ZVwiO1xyXG5jb25zdCBoID0gbWFxdWV0dGUuaDtcclxuaW1wb3J0IHsgQ2FsaWZvcm5pYUFwcCwgREVGQVVMVF9FWENFUFRJT04gfSBmcm9tIFwiLi9DYWxpZm9ybmlhQXBwXCI7XHJcbmltcG9ydCB7IENhbGlmb3JuaWFDbGllbnRWaWV3TW9kZWwsIENhbGlmb3JuaWFFdmVudCwgQ2FsaWZvcm5pYVZpZXcsIFN0eWxlTW9sZWN1bGUsIFJlc3BvbnNpdmVEZXZpY2UsIExheW91dFJvdywgQ2FsaWZvcm5pYVByb2plY3QsIExheW91dEF0b20sIExheW91dEJveCwgTGF5b3V0VHlwZSwgQ29udGVudEF0b20sIFN0eWxlTW9sZWN1bGVBdG9tTWFwcGluZyB9IGZyb20gXCIuL0NhbGlmb3JuaWFHZW5lcmF0ZWRcIjtcclxuaW1wb3J0IHsgU1RBVElDX01BUkdJTl9QWCwgRWRpdFZpZXdNb2RlIH0gZnJvbSBcIi4vQ2xpZW50U3RhdGVcIjtcclxuaW1wb3J0IHsgTGF5b3V0U3R5bGVJbnRlcmFjdGlvbiB9IGZyb20gXCIuLi9UeXBld3JpdGVyL0xheW91dFN0eWxlSW50ZXJhY3Rpb25cIjtcclxuaW1wb3J0IHsgUHJvcGVydHlCYXIgfSBmcm9tIFwiLi9Qcm9wZXJ0eUJhclwiO1xyXG5pbXBvcnQgeyBQcm9wZXJ0eUJhck1vZGUgfSBmcm9tIFwiLi4vVmlld01vZGVscy9Qcm9wZXJ0eUJhclZNXCI7XHJcblxyXG5sZXQgY3VycmVudEFwcDogQ2FsaWZvcm5pYUFwcDtcclxubGV0IGN1cnJlbnRSb3V0ZXI6IENhbGlmb3JuaWFSb3V0ZXI7XHJcblxyXG5leHBvcnQgY2xhc3MgQ2FsaWZvcm5pYVJvdXRlciB7XHJcbiAgICBwcml2YXRlIGRlZXBlc3RMZXZlbEN1cnJlbnRSb3c6IG51bWJlciA9IDA7IC8vIFRPRE8gb3B0aW1pemUgLyB0cmFuc2ZlciBzZXJ2ZXIgPT4gY29uY2VwdD9cclxuICAgIGNvbnN0cnVjdG9yKGNhbGlmb3JuaWFBcHBBcmc6IENhbGlmb3JuaWFBcHApIHtcclxuICAgICAgICBjdXJyZW50Um91dGVyID0gdGhpcztcclxuICAgICAgICBjdXJyZW50QXBwID0gY2FsaWZvcm5pYUFwcEFyZztcclxuICAgIH07XHJcblxyXG4gICAgLypwdWJsaWMgdXBkYXRlRGF0YSA9IChyZXNwb25zZTogQ2FsaWZvcm5pYUNsaWVudFZpZXdNb2RlbCwgcHJldmVudFJlbmRlckNoYWluZWRDYWxsczogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCA9PiB7IFRPRE8ga2VwdCBhcyByZWZlcmVuY2UsIHVudXNlZFxyXG4gICAgICAgIENhbGlmb3JuaWFBcHAuQ2FsaWZvcm5pYUFwcEluc3RhbmNlLnByb2plY3Rvci5zY2hlZHVsZVJlbmRlcigpO1xyXG4gICAgICAgIC8vIGluY3JlbWVudGFsIHVwZGF0ZSwgdXNlIGRhdGEgZnJvbSByZXNwb25zZSB0byB1cGRhdGUgbmF0aXZlIGNsaWVudCBkYXRhIHN0b3JlIChjb252ZXJzaW9ucyBmb3IgZGF0ZXMsIG9iamVjdCByZWZlcmVuY2VzIGV0Yy4pXHJcbiAgICAgICAgbGV0IGlzVmFsaWRSZXNwb25zZTogYm9vbGVhbiA9IGN1cnJlbnRSb3V0ZXIudmFsaWRhdGVSZXNwb25zZShyZXNwb25zZSk7XHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPIGNhbiByZXR1cm4gNDA0IG5vdCBmb3VuZCB3aGVuIGRlbGV0aW5nIGFscmVhZHkgZGVsZXRlZCBvYmplY3RzID0+IHBhZ2UgcmVsb2FkXHJcbiAgICAgICAgLy8gVE9ETyBzZWxlY3RlZCBwcm9qZWN0IGNoYW5nZSBtdXN0IGJlIHRlc3RlZCBwcm9wZXJseSAoYnJlYWtwb2ludCBpbiBjb250cm9sbGVyIGFjdGlvbnMgYW5kIGV4ZWN1dGUgMm5kIHVpIGFjdGlvbilcclxuICAgICAgICAvLyBUT0RPIG90aGVyIGNvbnN0cmFpbnRzIGxpa2UgXCJzZWxlY3RlZCBwcm9qZWN0IG1heSBub3QgY2hhbmdlXCI/XHJcbiAgICAgICAgLy8gVE9ETyByZWZhY3RvciBjbGllbnQgdmlldyBtb2RlbCB0byBub3QgY29udGFpbiBtdWx0aXBsZSByZWZlcmVuY2VzIHRvIHNhbWUgb2JqZWN0ID0+IHNlbGVjdGVkIHByb2plY3Qgc2hvdWxkIGJlIGNhbGlmb3JuaWFQcm9qZWN0c1tpbmRleF1cclxuICAgICAgICAvLyBUT0RPIHRlc3QgZXZlcnkgY2xpZW50IGludGVyYWN0aW9uIHdpdGggYSBkZWxheSBhbmQgc2VsZWN0IHByb2plY3QgaW4gYmV0d2VlblxyXG4gICAgICAgIC8vIHRlbXBvcmFyeSBzb2x1dGlvbjogcmVzZXQgb2JqZWN0IHJlZmVyZW5jZXMgPT4gbGVhZHMgdG8gZGlmZmVyZW50IGJ1Z3NcclxuICAgICAgICBsZXQgaXNVcGRhdGVTdWNjZXNzID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIHVudXNlZCwgYWx3YXlzIGZ1bGwgcGFnZSB1cGRhdGVcclxuICAgICAgICBzd2l0Y2ggKHJlc3BvbnNlLkNhbGlmb3JuaWFFdmVudCkge1xyXG4gICAgICAgICAgICBjYXNlIENhbGlmb3JuaWFFdmVudC5EdXBsaWNhdGVTdHlsZVF1YW50dW06XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuU3R5bGVRdWFudHVtICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgICAgICAmJiBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICYmIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZVF1YW50dW1zICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVRdWFudHVtcy5wdXNoKHJlc3BvbnNlLlN0eWxlUXVhbnR1bSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5wcm9wZXJ0eUJhclZNLnN0eWxlUXVhbnR1bU1hcHBpbmcubWFwKGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZVF1YW50dW1zKTtcclxuICAgICAgICAgICAgICAgICAgICBpc1VwZGF0ZVN1Y2Nlc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgaW5jcmVtZW50YWwgdXBkYXRlIG5vdCBpbXBsZW1lbnRlZCBmb3IgJHtDYWxpZm9ybmlhRXZlbnRbcmVzcG9uc2UuQ2FsaWZvcm5pYUV2ZW50XX1gKTsgLy8gVE9ET1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc1VwZGF0ZVN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJpbnZhbGlkIGNsaWVudCBzdGF0ZVwiKTtcclxuICAgICAgICAgICAgbG9jYXRpb24ucmVsb2FkKCk7IC8vIFRPRE8gYXVkaXQgc2VjdXJpdHkuLi5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghcHJldmVudFJlbmRlckNoYWluZWRDYWxscykge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnByb2plY3Rvci5zY2hlZHVsZVJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH07Ki9cclxuXHJcbiAgICBwdWJsaWMgdXBkYXRlRGF0YSA9IChyZXNwb25zZTogQ2FsaWZvcm5pYUNsaWVudFZpZXdNb2RlbCwgaXNJbml0aWFsID0gZmFsc2UsIHByZXZlbnRSZW5kZXJDaGFpbmVkQ2FsbHM6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQgPT4ge1xyXG4gICAgICAgIC8vIGNvcHkgZGF0YSBmcm9tIHJlc3BvbnNlIHRvIG5hdGl2ZSBjbGllbnQgZGF0YSBzdG9yZSAoY29udmVyc2lvbnMgZm9yIGRhdGVzLCBvYmplY3QgcmVmZXJlbmNlcyBldGMuKVxyXG4gICAgICAgIGxldCBpc1ZhbGlkUmVzcG9uc2U6IGJvb2xlYW4gPSBjdXJyZW50Um91dGVyLnZhbGlkYXRlUmVzcG9uc2UocmVzcG9uc2UpO1xyXG4gICAgICAgIGlmICghaXNWYWxpZFJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETyBtb3JlIGluaXRpYWwgY2xpZW50IGNoZWNrIGlmIHJlcXVpcmVkIGRhdGEsIGNlcnRpZmljYXRlcywgLi4uIGlzIGxvYWRlZCBldGMuIHRlc3QgYmFzaWMgc2V0dXAgYW5kIGNsZWFyIHZpZXcgYWdhaW5cclxuICAgICAgICBsZXQgaXNGdWxsRGF0YVVwZGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBpc1VwZGF0ZVN1Y2Nlc3M6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgICAgICBzd2l0Y2ggKHJlc3BvbnNlLkNhbGlmb3JuaWFFdmVudCkge1xyXG4gICAgICAgICAgICBjYXNlIENhbGlmb3JuaWFFdmVudC5VcGRhdGVDb250ZW50QXRvbTpcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5QYXJ0aWFsVXBkYXRlLkNvbnRlbnRBdG9tICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudENvbnRlbnRBdG9tSW5kZXg6IG51bWJlciA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5Db250ZW50QXRvbXMuZmluZEluZGV4KGMgPT4gYy5Db250ZW50QXRvbUlkID09IHJlc3BvbnNlLlBhcnRpYWxVcGRhdGUuQ29udGVudEF0b20uQ29udGVudEF0b21JZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyB0ZXN0OiBkb2VzIHVwZGF0ZSByb3V0aW5lcyBvZiByZW5kZXJlZCBsYXlvdXQgYXRvbXMgaGF2ZSB0byBiZSBjYWxsZWQgdG8gcmVmcmVzaCBcImxvY2FsXCIgY29weSBvZiBjb250ZW50L3JlbmRlcmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5Db250ZW50QXRvbXMuc3BsaWNlKGN1cnJlbnRDb250ZW50QXRvbUluZGV4LCAxLCAuLi5bcmVzcG9uc2UuUGFydGlhbFVwZGF0ZS5Db250ZW50QXRvbV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuTGF5b3V0TW9sZWN1bGVzLmZpbmQobCA9PiBsLkxheW91dEJhc2VJZCA9PSByZXNwb25zZS5QYXJ0aWFsVXBkYXRlLkNvbnRlbnRBdG9tLkluc3RhbmNlZE9uTGF5b3V0SWQpIGFzIExheW91dEF0b20pLkhvc3RlZENvbnRlbnRBdG9tID0gcmVzcG9uc2UuUGFydGlhbFVwZGF0ZS5Db250ZW50QXRvbTtcclxuICAgICAgICAgICAgICAgICAgICBpc1VwZGF0ZVN1Y2Nlc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgaXNGdWxsRGF0YVVwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzRnVsbERhdGFVcGRhdGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLkNhbGlmb3JuaWFQcm9qZWN0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdCA9IHJlc3BvbnNlLkNhbGlmb3JuaWFQcm9qZWN0O1xyXG5cclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5VcmxUb1JlYWRPbmx5ID0gcmVzcG9uc2UuVXJsVG9SZWFkT25seTsgLy8gVE9ETyBvbmx5IGluaXRpYWxcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5VcmxUb1JlYWRBbmRFZGl0ID0gcmVzcG9uc2UuVXJsVG9SZWFkQW5kRWRpdDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzb3J0IHJlc3BvbnNpdmUgZGV2aWNlczogLTEsIDAsIC4uLj4wXHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuQ2FsaWZvcm5pYVByb2plY3QuUmVzcG9uc2l2ZURldmljZXMubGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgcmVzcG9uc2UuQ2FsaWZvcm5pYVByb2plY3QuUmVzcG9uc2l2ZURldmljZXMubGVuZ3RoID4gMCkgeyAvLyBjaGVjayBpZiByZXNwb25zaXZlIGRldmljZXMgYXJlIGFscmVhZHkgc2VlZGVkXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzLnNvcnQoKHIxLCByMikgPT4gKHIxLldpZHRoVGhyZXNob2xkICE9PSB1bmRlZmluZWQgJiYgcjIuV2lkdGhUaHJlc2hvbGQgIT09IHVuZGVmaW5lZCkgPyAocjEuV2lkdGhUaHJlc2hvbGQgPCByMi5XaWR0aFRocmVzaG9sZCA/IC0xIDogcjEuV2lkdGhUaHJlc2hvbGQgPT0gcjIuV2lkdGhUaHJlc2hvbGQgPyAwIDogMSkgOiAwKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmxvd2VzdFdpZHRoVGhyZXNob2xkUmVzcG9uc2l2ZURldmljZUlkID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzWzFdLlJlc3BvbnNpdmVEZXZpY2VJZDtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnN0YXRlLmhpZ2hlc3RXaWR0aFRocmVzaG9sZFJlc3BvbnNpdmVEZXZpY2VJZCA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5SZXNwb25zaXZlRGV2aWNlc1tjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuUmVzcG9uc2l2ZURldmljZXMubGVuZ3RoIC0gMV0uUmVzcG9uc2l2ZURldmljZUlkO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUubm9uZVJlc3BvbnNpdmVEZXZpY2VJZCA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5SZXNwb25zaXZlRGV2aWNlc1swXS5SZXNwb25zaXZlRGV2aWNlSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5pdGlhbCkgeyAvLyBUT0RPIHdoYXQgaWYgaW5pdGlhbCBkYXRhIGlzIGVycm9uZW91c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRBcHAucHJvcGVydHlCYXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJvcGVydHlCYXI6IFByb3BlcnR5QmFyID0gY3VycmVudEFwcC5wcm9wZXJ0eUJhcnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUJhci52aWV3TW9kZWwuc2V0U2VsZWN0ZWRSZXNwb25zaXZlRGV2aWNlSWQoY3VycmVudEFwcC5zdGF0ZS5ub25lUmVzcG9uc2l2ZURldmljZUlkLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBcHAucGFnZVByZXZpZXcudmlydHVhbFN0eWxlSW5kZXgubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5wYWdlUHJldmlldy52aXJ0dWFsU3R5bGVJbmRleCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnBhZ2VQcmV2aWV3LnZpcnR1YWxQc2V1ZG9TdHlsZUluZGV4ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHJlc3BvbnNpdmVEZXZpY2Ugb2YgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlJlc3BvbnNpdmVEZXZpY2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnBhZ2VQcmV2aWV3LnZpcnR1YWxTdHlsZUluZGV4LnB1c2goW10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5wYWdlUHJldmlldy52aXJ0dWFsUHNldWRvU3R5bGVJbmRleC5wdXNoKHt9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0luaXRpYWwgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLmNsaWVudERhdGEuQWxsQ3NzUHJvcGVydGllcyA9IHJlc3BvbnNlLkFsbENzc1Byb3BlcnRpZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5jbGllbnREYXRhLlN0eWxlQXRvbUNzc1Byb3BlcnR5TWFwcGluZyA9IHJlc3BvbnNlLlN0eWxlQXRvbUNzc1Byb3BlcnR5TWFwcGluZztcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLmNsaWVudERhdGEuVGhpcmRQYXJ0eUZvbnRzID0gcmVzcG9uc2UuVGhpcmRQYXJ0eUZvbnRzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVRdWFudHVtcyAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlQXRvbXMgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcyAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkxheW91dE1vbGVjdWxlcyAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFWaWV3cyAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFWaWV3cy5sZW5ndGggPiAwKSB7IC8vIFRPRE8gZHVwbGljYXRlIG51bWJlcmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gb25seSBtYXAgd2hlbiBwcm9wZXJ0eSBiYXIgd2FzIHVzZWQgYXQgbGVhc3Qgb25jZSAvLyBUT0RPIHNvcnQgYW5kIHJlb3JkZXJpbmcgaXMgaGFwcGVuaW5nIGF0IGRpZmZlcmVudCBwbGFjZWRcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Um91dGVyLnJlc3RvcmVMYXlvdXRNb2xlY3VsZUFuZFN0eWxlUmVmZXJlbmNlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuc3BlY2lhbFN0eWxlSG9sZGVyID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LkNhbGlmb3JuaWFWaWV3cy5maW5kKHYgPT4gdi5Jc0ludGVybmFsID09PSB0cnVlICYmIHYuTmFtZSA9PT0gXCJbSW50ZXJuYWxdIFNwZWNpYWwgU3R5bGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLnNwZWNpYWxTdHlsZUhvbGRlciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTsgIC8vIFRPRE8gd2lsbCBicmVhayB3aGVuIGRhdGEgY2hhbmdlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5DYWxpZm9ybmlhVmlld3MuZmlsdGVyKHYgPT4gIXYuSXNJbnRlcm5hbCkubWFwKHYgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEFwcC5zdGF0ZS5zcGVjaWFsU3R5bGVIb2xkZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNhbGlmb3JuaWFWaWV3U3R5bGVIb2xkZXJSb3c6IExheW91dFJvdyA9IGN1cnJlbnRBcHAuc3RhdGUuc3BlY2lhbFN0eWxlSG9sZGVyLlBsYWNlZExheW91dFJvd3MuZmluZChsYXlvdXRSb3cgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdHlsZU1vbGVjdWxlOiBTdHlsZU1vbGVjdWxlID0gY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlTW9sZWN1bGVzLmZpbmQobSA9PiBtLlN0eWxlRm9yTGF5b3V0SWQgPT0gbGF5b3V0Um93LkxheW91dEJhc2VJZCkgYXMgU3R5bGVNb2xlY3VsZTsgLy8gVE9ETyBleHBlbnNpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGVNb2xlY3VsZS5OYW1lID09PSBgW0ludGVybmFsXSAke3YuTmFtZX0gVmlldyBTdHlsZWApIHsgLy8gVE9ETyB3aWxsIGJyZWFrIHdoZW4gZGF0YSBjaGFuZ2VzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuU3BlY2lhbFN0eWxlVmlld1N0eWxlTW9sZWN1bGVJZCA9IHN0eWxlTW9sZWN1bGUuU3R5bGVNb2xlY3VsZUlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgYXMgTGF5b3V0Um93O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNhbGlmb3JuaWFWaWV3Qm9keVN0eWxlSG9sZGVyUm93OiBMYXlvdXRSb3cgPSBjdXJyZW50QXBwLnN0YXRlLnNwZWNpYWxTdHlsZUhvbGRlci5QbGFjZWRMYXlvdXRSb3dzLmZpbmQobGF5b3V0Um93ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3R5bGVNb2xlY3VsZTogU3R5bGVNb2xlY3VsZSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcy5maW5kKG0gPT4gbS5TdHlsZUZvckxheW91dElkID09IGxheW91dFJvdy5MYXlvdXRCYXNlSWQpIGFzIFN0eWxlTW9sZWN1bGU7IC8vIFRPRE8gZXhwZW5zaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0eWxlTW9sZWN1bGUuTmFtZSA9PT0gYFtJbnRlcm5hbF0gJHt2Lk5hbWV9IEJvZHkgU3R5bGVgKSB7IC8vIFRPRE8gd2lsbCBicmVhayB3aGVuIGRhdGEgY2hhbmdlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LlNwZWNpYWxTdHlsZUJvZHlTdHlsZU1vbGVjdWxlSWQgPSBzdHlsZU1vbGVjdWxlLlN0eWxlTW9sZWN1bGVJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIGFzIExheW91dFJvdztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjYWxpZm9ybmlhVmlld0h0bWxTdHlsZUhvbGRlclJvdzogTGF5b3V0Um93ID0gY3VycmVudEFwcC5zdGF0ZS5zcGVjaWFsU3R5bGVIb2xkZXIuUGxhY2VkTGF5b3V0Um93cy5maW5kKGxheW91dFJvdyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0eWxlTW9sZWN1bGU6IFN0eWxlTW9sZWN1bGUgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVNb2xlY3VsZXMuZmluZChtID0+IG0uU3R5bGVGb3JMYXlvdXRJZCA9PSBsYXlvdXRSb3cuTGF5b3V0QmFzZUlkKSBhcyBTdHlsZU1vbGVjdWxlOyAvLyBUT0RPIGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdHlsZU1vbGVjdWxlLk5hbWUgPT09IGBbSW50ZXJuYWxdICR7di5OYW1lfSBIdG1sIFN0eWxlYCkgeyAvLyBUT0RPIHdpbGwgYnJlYWsgd2hlbiBkYXRhIGNoYW5nZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5TcGVjaWFsU3R5bGVIdG1sU3R5bGVNb2xlY3VsZUlkID0gc3R5bGVNb2xlY3VsZS5TdHlsZU1vbGVjdWxlSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSBhcyBMYXlvdXRSb3c7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LlNwZWNpYWxTdHlsZVZpZXdTdHlsZU1vbGVjdWxlSWRTdHJpbmcgPSB2LlNwZWNpYWxTdHlsZVZpZXdTdHlsZU1vbGVjdWxlSWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuU3BlY2lhbFN0eWxlVmlld1N0eWxlU3RyaW5nID0gYHMke3YuU3BlY2lhbFN0eWxlVmlld1N0eWxlTW9sZWN1bGVJZFN0cmluZ31gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5TcGVjaWFsU3R5bGVCb2R5U3R5bGVNb2xlY3VsZUlkU3RyaW5nID0gdi5TcGVjaWFsU3R5bGVCb2R5U3R5bGVNb2xlY3VsZUlkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LlNwZWNpYWxTdHlsZUJvZHlTdHlsZVN0cmluZyA9IGBzJHt2LlNwZWNpYWxTdHlsZUJvZHlTdHlsZU1vbGVjdWxlSWRTdHJpbmd9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYuU3BlY2lhbFN0eWxlSHRtbFN0eWxlTW9sZWN1bGVJZFN0cmluZyA9IHYuU3BlY2lhbFN0eWxlSHRtbFN0eWxlTW9sZWN1bGVJZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdi5TcGVjaWFsU3R5bGVIdG1sU3R5bGVTdHJpbmcgPSBgcyR7di5TcGVjaWFsU3R5bGVIdG1sU3R5bGVNb2xlY3VsZUlkU3RyaW5nfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LlNwZWNpYWxTdHlsZVZpZXdTdHlsZVN0cmluZyA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LlNwZWNpYWxTdHlsZUJvZHlTdHlsZVN0cmluZyA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LlNwZWNpYWxTdHlsZUh0bWxTdHlsZVN0cmluZyA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluc3RhbmNlYWJsZUF0b21zVmlldzogQ2FsaWZvcm5pYVZpZXcgPSBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ2FsaWZvcm5pYVZpZXdzLmZpbmQodmlldyA9PiB2aWV3LklzSW50ZXJuYWwgJiYgdmlldy5OYW1lID09PSBcIltJbnRlcm5hbF0gSW5zdGFuY2VhYmxlIExheW91dCBBdG9tc1wiKSBhcyBDYWxpZm9ybmlhVmlldzsgLy8gVE9ETyBtYWdpYyBzdHJpbmcgPT4gY29uc3QgZXhwb3J0XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluc3RhbmNlYWJsZVJvd3NWaWV3OiBDYWxpZm9ybmlhVmlldyA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5DYWxpZm9ybmlhVmlld3MuZmluZCh2aWV3ID0+IHZpZXcuSXNJbnRlcm5hbCAmJiB2aWV3Lk5hbWUgPT09IFwiW0ludGVybmFsXSBJbnN0YW5jZWFibGUgTGF5b3V0IFJvd3NcIikgYXMgQ2FsaWZvcm5pYVZpZXc7IC8vIFRPRE8gbWFnaWMgc3RyaW5nID0+IGNvbnN0IGV4cG9ydFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSb3V0ZXIuc2V0QWN0aXZlQ2FsaWZvcm5pYVZpZXdJZChjdXJyZW50QXBwLnBhZ2VQcmV2aWV3Vk0uYWN0aXZlQ2FsaWZvcm5pYVZpZXdJZCAhPSAwID8gY3VycmVudEFwcC5wYWdlUHJldmlld1ZNLmFjdGl2ZUNhbGlmb3JuaWFWaWV3SWQgOiAwLCB0cnVlLCBpc0luaXRpYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudEFwcC5wcm9wZXJ0eUJhcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5wcm9wZXJ0eUJhcnNbaV0udmlld01vZGVsLnVwZGF0ZURhdGEoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlUXVhbnR1bXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuU3R5bGVBdG9tcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5TdHlsZU1vbGVjdWxlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5MYXlvdXRNb2xlY3VsZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLmNsaWVudERhdGEuQ2FsaWZvcm5pYVByb2plY3QuQ2FsaWZvcm5pYVZpZXdzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VhYmxlQXRvbXNWaWV3LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VhYmxlUm93c1ZpZXcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmlyc3RSb3c6IExheW91dFJvdyA9IGluc3RhbmNlYWJsZVJvd3NWaWV3LlBsYWNlZExheW91dFJvd3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5uZXdCb3hTdHlsZU1vbGVjdWxlSWQgPSAoY3VycmVudEFwcC5jbGllbnREYXRhLkNhbGlmb3JuaWFQcm9qZWN0LlN0eWxlTW9sZWN1bGVzLmZpbmQocyA9PiBzLlN0eWxlRm9yTGF5b3V0SWQgPT0gZmlyc3RSb3cuQWxsQm94ZXNCZWxvd1Jvd1swXS5MYXlvdXRCYXNlSWQpIGFzIFN0eWxlTW9sZWN1bGUpLlN0eWxlTW9sZWN1bGVJZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuc3BlY2lhbFN0eWxlSG9sZGVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5pdGlhbCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpOiBudW1iZXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgY3VycmVudEFwcC5wcm9wZXJ0eUJhckNvdW50KSB7IC8vIFRPRE8gZXhhbXBsZSBzbmlwcGV0IGZvciBjb2RlIGd1aWRlbGluZXMgPT4gbGF5b3V0IGhlbHBzIHRvIHdyaXRlIGNvcnJlY3QgY29kZSAvIG5vdCBmb3JnZXQgc3R1ZmZcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5wcm9wZXJ0eUJhclZNc1tpKytdLmN1cnJlbnRQcm9wZXJ0eUJhck1vZGUgPSBQcm9wZXJ0eUJhck1vZGUuQ2FsaWZvcm5pYVZpZXc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpIDwgY3VycmVudEFwcC5wcm9wZXJ0eUJhckNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnByb3BlcnR5QmFyVk1zW2krK10uY3VycmVudFByb3BlcnR5QmFyTW9kZSA9IFByb3BlcnR5QmFyTW9kZS5BbGxDYWxpZm9ybmlhVmlld3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IGN1cnJlbnRBcHAucHJvcGVydHlCYXJDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucHJvcGVydHlCYXJWTXNbaSsrXS5jdXJyZW50UHJvcGVydHlCYXJNb2RlID0gUHJvcGVydHlCYXJNb2RlLlN0eWxlTW9sZWN1bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBjdXJyZW50QXBwLnByb3BlcnR5QmFyQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5wcm9wZXJ0eUJhclZNc1tpKytdLmN1cnJlbnRQcm9wZXJ0eUJhck1vZGUgPSBQcm9wZXJ0eUJhck1vZGUuQWxsU3R5bGVRdWFudHVtcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY3VycmVudFJvdXRlci5zZXR1cFVpRm9yRGV2aWNlKCk7IC8vIFRPRE8gd2hhdCBpZiBmaXJzdCByZW5kZXIgaGFwcGVucyBhZnRlciBpbml0aWFsIGNsaWVudCBkYXRhIHVwZGF0ZT8gaXMgdGhpcyBwb3NzaWJsZSBhdCBhbGxcclxuXHJcbiAgICAgICAgICAgICAgICBpc1VwZGF0ZVN1Y2Nlc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNVcGRhdGVTdWNjZXNzID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIm1pc3NpbmcgY2xpZW50IGRhdGFcIik7XHJcbiAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpOyAvLyBUT0RPIGF1ZGl0IHNlY3VyaXR5Li4uIFRFU1RcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudEFwcC5zdGF0ZS5pc0RhdGFMb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmICghcHJldmVudFJlbmRlckNoYWluZWRDYWxscykge1xyXG4gICAgICAgICAgICBjdXJyZW50QXBwLnByb2plY3Rvci5zY2hlZHVsZVJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGNsZWFyQ2FsaWZvcm5pYVByb3BlcnR5QmFycyhpc0NsZWFyV2hlbk5vbkVxdWFsOiBib29sZWFuLCBjbGVhcldoZW5FcXVhbHNDYWxpZm9ybmlhVmlld0lkOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICAvLyB2aWV3IG1vZGVscyBjYW4gaGF2ZSBubyBzZWxlY3Rpb25cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnRBcHAucHJvcGVydHlCYXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAucHJvcGVydHlCYXJzW2ldLnZpZXdNb2RlbC5jbGVhclNlbGVjdGVkQ2FsaWZvcm5pYVZpZXcoaXNDbGVhcldoZW5Ob25FcXVhbCwgY2xlYXJXaGVuRXF1YWxzQ2FsaWZvcm5pYVZpZXdJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcHVibGljIHNldEFjdGl2ZUNhbGlmb3JuaWFWaWV3SWQoY2FsaWZvcm5pYVZpZXdJZDogbnVtYmVyLCBpc0RlZmF1bHRUb0hvbWU6IGJvb2xlYW4sIGlzU2V0QWxsUHJvcGVydHlCYXJzOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgbGV0IHVzZXJQYWdlczogQ2FsaWZvcm5pYVZpZXdbXSA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5DYWxpZm9ybmlhVmlld3MuZmlsdGVyKHZpZXcgPT4gIXZpZXcuSXNJbnRlcm5hbCk7XHJcbiAgICAgICAgbGV0IGFjdGl2ZVZpZXc6IENhbGlmb3JuaWFWaWV3IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGxldCBhY3RpdmVQYWdlSW5kZXg6IG51bWJlciA9IC0xO1xyXG4gICAgICAgIGlmIChjYWxpZm9ybmlhVmlld0lkICE9IDApIHtcclxuICAgICAgICAgICAgYWN0aXZlUGFnZUluZGV4ID0gdXNlclBhZ2VzLmZpbmRJbmRleCh2ID0+IHYuQ2FsaWZvcm5pYVZpZXdJZCA9PSBjYWxpZm9ybmlhVmlld0lkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFjdGl2ZVBhZ2VJbmRleCA9PSAtMSAmJiBpc0RlZmF1bHRUb0hvbWUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgYWN0aXZlUGFnZUluZGV4ID0gdXNlclBhZ2VzLmZpbmRJbmRleCh2ID0+IHYuTmFtZSA9PT0gXCJIb21lXCIpOyAvLyBUT0RPIHdpbGwgYnJlYWsgaWYgZGF0YSBpcyBub3Qgc3VwcGxpZWRcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFjdGl2ZVBhZ2VJbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgIGFjdGl2ZVZpZXcgPSB1c2VyUGFnZXNbYWN0aXZlUGFnZUluZGV4XTtcclxuICAgICAgICAgICAgY3VycmVudFJvdXRlci5zZXRBY3RpdmVDYWxpZm9ybmlhVmlldyhhY3RpdmVWaWV3KTtcclxuICAgICAgICAgICAgaWYgKGlzU2V0QWxsUHJvcGVydHlCYXJzID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgY3VycmVudEFwcC5wcm9wZXJ0eUJhcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnByb3BlcnR5QmFyc1tpXS52aWV3TW9kZWwuc2V0U2VsZWN0ZWRDYWxpZm9ybmlhVmlldyhhY3RpdmVWaWV3LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gY29tcGxleCB1cGRhdGUgdmlldyBtb2RlbHNcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRBcHAucHJvcGVydHlCYXJzWzBdLnZpZXdNb2RlbC5zZXRTZWxlY3RlZENhbGlmb3JuaWFWaWV3KGFjdGl2ZVZpZXcsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaTogbnVtYmVyID0gMTsgaSA8IGN1cnJlbnRBcHAucHJvcGVydHlCYXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByb3BlcnR5QmFyVmlld0lkOiBudW1iZXIgPSBjdXJyZW50QXBwLnByb3BlcnR5QmFyc1tpXS52aWV3TW9kZWwuc2VsZWN0ZWRDYWxpZm9ybmlhVmlld0lkO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eUJhclZpZXdJZCAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwcm9wZXJ0eUJhclZpZXc6IENhbGlmb3JuaWFWaWV3ID0gdXNlclBhZ2VzLmZpbmQodiA9PiB2LkNhbGlmb3JuaWFWaWV3SWQgPT09IHByb3BlcnR5QmFyVmlld0lkKSBhcyBDYWxpZm9ybmlhVmlldztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFwcC5wcm9wZXJ0eUJhcnNbaV0udmlld01vZGVsLnNldFNlbGVjdGVkQ2FsaWZvcm5pYVZpZXcocHJvcGVydHlCYXJWaWV3LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKERFRkFVTFRfRVhDRVBUSU9OKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzZXRBY3RpdmVDYWxpZm9ybmlhVmlldyhjYWxpZm9ybmlhVmlldzogQ2FsaWZvcm5pYVZpZXcpOiB2b2lkIHsgLy8gVE9ETyBzaG91bGQgYmUgc2V0dGVyIG1ldGhvZCBmb3IgYWN0aXZlQ2FsaWZvcm5pYVZpZXdcclxuICAgICAgICBjdXJyZW50QXBwLnBhZ2VQcmV2aWV3LnZpZXdNb2RlbC5hY3RpdmVDYWxpZm9ybmlhVmlld0lkID0gY2FsaWZvcm5pYVZpZXcuQ2FsaWZvcm5pYVZpZXdJZDtcclxuICAgICAgICBjdXJyZW50QXBwLnBhZ2VQcmV2aWV3Vk0uY2FsaWZvcm5pYVZpZXdQcm9qZWN0b3IubWFwKFtjYWxpZm9ybmlhVmlld10pO1xyXG4gICAgICAgIGN1cnJlbnRBcHAucGFnZVByZXZpZXdWTS5maXhlZExheW91dFJvd3NQcm9qZWN0b3IubWFwKGNhbGlmb3JuaWFWaWV3LlBsYWNlZExheW91dFJvd3MpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIHJlc3RvcmVMYXlvdXRNb2xlY3VsZUFuZFN0eWxlUmVmZXJlbmNlcyA9ICgpOiB2b2lkID0+IHtcclxuICAgICAgICAvLyByZXN0b3JlIGxheW91dCBtb2xlY3VsZSBvYmplY3QgcmVmZXJlbmNlczogdmlldyA9PiByb3cgPT4gYm94ZXMgPT4gYm94ZXMvYXRvbXMgPT4gYXRvbXMgPT4gY29udGVudFxyXG4gICAgICAgIGxldCBwcm9qZWN0OiBDYWxpZm9ybmlhUHJvamVjdCA9IGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdDtcclxuICAgICAgICBsZXQgYWxsUm93czogTGF5b3V0Um93W10gPSBbXTtcclxuICAgICAgICBsZXQgYWxsQm94ZXM6IExheW91dEJveFtdID0gW107XHJcbiAgICAgICAgbGV0IGFsbEF0b21zOiBMYXlvdXRBdG9tW10gPSBbXTtcclxuICAgICAgICBwcm9qZWN0LkxheW91dE1vbGVjdWxlcy5tYXAobW9sID0+IHtcclxuICAgICAgICAgICAgc3dpdGNoIChtb2wuTGF5b3V0VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBMYXlvdXRUeXBlLlJvdzpcclxuICAgICAgICAgICAgICAgICAgICBhbGxSb3dzLnB1c2gobW9sIGFzIExheW91dFJvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIExheW91dFR5cGUuQm94OlxyXG4gICAgICAgICAgICAgICAgICAgIGFsbEJveGVzLnB1c2gobW9sIGFzIExheW91dEJveCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIExheW91dFR5cGUuQXRvbTpcclxuICAgICAgICAgICAgICAgICAgICBhbGxBdG9tcy5wdXNoKG1vbCBhcyBMYXlvdXRBdG9tKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IGFsbENvbnRlbnRBdG9tczogQ29udGVudEF0b21bXSA9IHByb2plY3QuQ29udGVudEF0b21zO1xyXG4gICAgICAgIGxldCBhbGxJbnRlcmFjdGlvbnM6IExheW91dFN0eWxlSW50ZXJhY3Rpb25bXSA9IHByb2plY3QuTGF5b3V0U3R5bGVJbnRlcmFjdGlvbnM7XHJcbiAgICAgICAgLy8gbGF5b3V0IHJlZmVyZW5jZXNcclxuICAgICAgICAvLyBUT0RPIHNvcnQgcm93cyBoZXJlPyBzdHJhbmdlIGRhdGEgbW9kZWwgLy8gVE9ETyBzb3J0ZWQgbm90IG9ubHkgd2hlbiB1cGRhdGluZyBkYXRhIC8vIFRPRE8gaXMgc29ydCBvcmRlciBndWFyYW50ZWVkIHRvIGJlIGdlbmVyYXRlZCBsYXlvdXQgaWQgaW4gZ2VuZXJhdGUgcHJvamVjdCAocHJvYmFibHkgeWVzKVxyXG4gICAgICAgIHByb2plY3QuQ2FsaWZvcm5pYVZpZXdzLm1hcCh2aWV3ID0+IHtcclxuICAgICAgICAgICAgdmlldy5QbGFjZWRMYXlvdXRSb3dzID0gYWxsUm93cy5maWx0ZXIocm93ID0+IHJvdy5QbGFjZWRPblZpZXdJZCA9PSB2aWV3LkNhbGlmb3JuaWFWaWV3SWQpLnNvcnQoKHJvd0E6IExheW91dFJvdywgcm93QjogTGF5b3V0Um93KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocm93QS5MYXlvdXRTb3J0T3JkZXJLZXkgPCByb3dCLkxheW91dFNvcnRPcmRlcktleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJvd0EuTGF5b3V0U29ydE9yZGVyS2V5ID09IHJvd0IuTGF5b3V0U29ydE9yZGVyS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHsgLy8gcm93QS5MYXlvdXRTb3J0T3JkZXJLZXkgPiByb3dCLkxheW91dFNvcnRPcmRlcktleVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgZGVlcGVzdExldmVsQ3VycmVudFZpZXc6IG51bWJlciA9IDA7XHJcbiAgICAgICAgcHJvamVjdC5DYWxpZm9ybmlhVmlld3MubWFwKHZpZXcgPT4ge1xyXG4gICAgICAgICAgICBkZWVwZXN0TGV2ZWxDdXJyZW50VmlldyA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGlSb3c6IG51bWJlciA9IDA7IGlSb3cgPCB2aWV3LlBsYWNlZExheW91dFJvd3MubGVuZ3RoOyBpUm93KyspIHsgLy8gVE9ETyBhcmUgYXJyYXkgbGltaXRzIHJlY29nbml6ZWQgYXMgaW1tdXRhYmxlIGJ5IGphdmFzY3JpcHQgcnVudGltZXM/IGlmIG5vdCwgZGVjbGFyZSBsaW1pdCBiZWZvcmUgbG9vcCBldmVyeXdoZXJlXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Um91dGVyLmRlZXBlc3RMZXZlbEN1cnJlbnRSb3cgPSAwO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJvdzogTGF5b3V0Um93ID0gdmlldy5QbGFjZWRMYXlvdXRSb3dzW2lSb3ddO1xyXG4gICAgICAgICAgICAgICAgcm93LkFsbEJveGVzQmVsb3dSb3cgPSBhbGxCb3hlcy5maWx0ZXIoYm94ID0+IGJveC5Cb3hPd25lclJvd0lkID09IHJvdy5MYXlvdXRCYXNlSWQgJiYgYm94LlBsYWNlZEJveEluQm94SWQgPT0gdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgICAgIHJvdy5BbGxCb3hlc0JlbG93Um93Lm1hcChib3ggPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSb3V0ZXIucmVzdG9yZUxheW91dEJveFJlZmVyZW5jZXNSZWN1cnNpdmUoMCwgYm94LCByb3csIGFsbEJveGVzLCBhbGxBdG9tcywgYWxsQ29udGVudEF0b21zLCBhbGxJbnRlcmFjdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJveC5Cb3hPd25lclJvdyA9IHJvdztcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcm93LkRlZXBlc3RMZXZlbCA9IGN1cnJlbnRSb3V0ZXIuZGVlcGVzdExldmVsQ3VycmVudFJvdztcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Um91dGVyLmRlZXBlc3RMZXZlbEN1cnJlbnRSb3cgPiBkZWVwZXN0TGV2ZWxDdXJyZW50Vmlldykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZXBlc3RMZXZlbEN1cnJlbnRWaWV3ID0gY3VycmVudFJvdXRlci5kZWVwZXN0TGV2ZWxDdXJyZW50Um93O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZpZXcuRGVlcGVzdExldmVsID0gZGVlcGVzdExldmVsQ3VycmVudFZpZXc7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gc3R5bGUgcmVmZXJlbmNlc1xyXG4gICAgICAgIC8qcHJvamVjdC5TdHlsZUF0b21zLm1hcChhdG9tID0+IHtcclxuICAgICAgICAgICAgYXRvbS5BcHBsaWVkVmFsdWVzID0gcHJvamVjdC5TdHlsZVZhbHVlcy5maWx0ZXIodmFsID0+IHZhbC5TdHlsZUF0b21JZCA9PSBhdG9tLlN0eWxlQXRvbUlkKTtcclxuICAgICAgICB9KTsqL1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJhZnRlciByZXN0b3JlOlwiKTtjb25zb2xlLmxvZyhjdXJyZW50QXBwLmNsaWVudERhdGEpO1xyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIHJlc3RvcmVMYXlvdXRCb3hSZWZlcmVuY2VzUmVjdXJzaXZlID0gKGJveExldmVsOiBudW1iZXIsIGJveDogTGF5b3V0Qm94LCBib3hPd25lclJvdzogTGF5b3V0Um93LCBhbGxCb3hlczogTGF5b3V0Qm94W10sIGFsbEF0b21zOiBMYXlvdXRBdG9tW10sIGFsbENvbnRlbnRBdG9tczogQ29udGVudEF0b21bXSwgYWxsSW50ZXJhY3Rpb25zOiBMYXlvdXRTdHlsZUludGVyYWN0aW9uW10pOiB2b2lkID0+IHtcclxuICAgICAgICBib3guTGV2ZWwgPSBib3hMZXZlbDtcclxuICAgICAgICBib3guUGxhY2VkSW5Cb3hCb3hlcyA9IGFsbEJveGVzLmZpbHRlcihzdWJCb3ggPT4gc3ViQm94LlBsYWNlZEJveEluQm94SWQgIT09IHVuZGVmaW5lZCAmJiBzdWJCb3guUGxhY2VkQm94SW5Cb3hJZCA9PSBib3guTGF5b3V0QmFzZUlkKTtcclxuICAgICAgICBib3guUGxhY2VkSW5Cb3hCb3hlcy5tYXAoc3ViQm94ID0+IHtcclxuICAgICAgICAgICAgY3VycmVudFJvdXRlci5yZXN0b3JlTGF5b3V0Qm94UmVmZXJlbmNlc1JlY3Vyc2l2ZShib3hMZXZlbCArIDEsIHN1YkJveCwgYm94T3duZXJSb3csIGFsbEJveGVzLCBhbGxBdG9tcywgYWxsQ29udGVudEF0b21zLCBhbGxJbnRlcmFjdGlvbnMpO1xyXG4gICAgICAgICAgICBzdWJCb3guQm94T3duZXJSb3cgPSBib3hPd25lclJvdztcclxuICAgICAgICAgICAgc3ViQm94LlBsYWNlZEJveEluQm94ID0gYm94O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGJveE93bmVyUm93LkFsbEJveGVzQmVsb3dSb3cucHVzaCguLi5ib3guUGxhY2VkSW5Cb3hCb3hlcyk7XHJcbiAgICAgICAgYm94LlBsYWNlZEluQm94QXRvbXMgPSBhbGxBdG9tcy5maWx0ZXIoc3ViQXRvbSA9PiBzdWJBdG9tLlBsYWNlZEF0b21JbkJveElkICE9PSB1bmRlZmluZWQgJiYgc3ViQXRvbS5QbGFjZWRBdG9tSW5Cb3hJZCA9PSBib3guTGF5b3V0QmFzZUlkKTtcclxuICAgICAgICBib3guUGxhY2VkSW5Cb3hBdG9tcy5tYXAoc3ViQXRvbSA9PiB7XHJcbiAgICAgICAgICAgIHN1YkF0b20uSG9zdGVkQ29udGVudEF0b20gPSBhbGxDb250ZW50QXRvbXMuZmluZChjb250ZW50QXRvbSA9PiBjb250ZW50QXRvbS5JbnN0YW5jZWRPbkxheW91dElkID09IHN1YkF0b20uTGF5b3V0QmFzZUlkKSBhcyBDb250ZW50QXRvbTtcclxuICAgICAgICAgICAgc3ViQXRvbS5QbGFjZWRBdG9tSW5Cb3ggPSBib3g7XHJcbiAgICAgICAgICAgIHN1YkF0b20uTGF5b3V0U3R5bGVJbnRlcmFjdGlvbnMgPSBhbGxJbnRlcmFjdGlvbnMuZmlsdGVyKG1hcCA9PiBtYXAuTGF5b3V0QXRvbUlkID09IHN1YkF0b20uTGF5b3V0QmFzZUlkKTtcclxuICAgICAgICAgICAgc3ViQXRvbS5MZXZlbCA9IGJveExldmVsICsgMTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoYm94LlBsYWNlZEluQm94QXRvbXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBpZiAoKGJveExldmVsICsgMSkgPiBjdXJyZW50Um91dGVyLmRlZXBlc3RMZXZlbEN1cnJlbnRSb3cpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSb3V0ZXIuZGVlcGVzdExldmVsQ3VycmVudFJvdyA9IGJveExldmVsICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChib3hMZXZlbCA+IGN1cnJlbnRSb3V0ZXIuZGVlcGVzdExldmVsQ3VycmVudFJvdykge1xyXG4gICAgICAgICAgICBjdXJyZW50Um91dGVyLmRlZXBlc3RMZXZlbEN1cnJlbnRSb3cgPSBib3hMZXZlbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzZXR1cFVpRm9yRGV2aWNlID0gKCk6IHZvaWQgPT4ge1xyXG4gICAgICAgIC8vIFRPRE8gdXNlIHdpbmRvdy5pbm5lcldpZHRoIHRvIGFkanVzdCBVSSBzdGF0ZSwgY2FsbGVkIG9uIHBhZ2UgbG9hZCBhbmQgd2luZG93IHJlc2l6ZSBUT0RPIGlwaG9uZSBzZWVtcyB0byBoYXZlIHZpZXdwb3J0IGxhcmdlciB0aGFuIGF2YWlsYWJsZSBzcGFjZS4uLlxyXG4gICAgICAgIGxldCBjYWxpZm9ybmlhQXBwSGVpZ2h0OiBudW1iZXIgfCB1bmRlZmluZWQgPSAkKHdpbmRvdykuaGVpZ2h0KCk7IC8vIFRPRE8gdXNlIGlubmVyIG9yIG91dGVyIGhlaWdodFxyXG4gICAgICAgIGlmIChjYWxpZm9ybmlhQXBwSGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coREVGQVVMVF9FWENFUFRJT04pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUuaGVpZ2h0ID0gYCR7Y2FsaWZvcm5pYUFwcEhlaWdodH1weGA7IC8vIDEwMCUgaGVpZ2h0IG9uIGlQYWQsIHdpdGggYW5kIHdpdGhvdXQgcmVuZGVyZWQgYnJvd3NlciBjb250cm9sc1xyXG4gICAgICAgIC8vIGNsaWVudFdpZHRoIGluY2x1ZGVzIG1hcmdpblxyXG4gICAgICAgIGlmIChjdXJyZW50QXBwLnN0YXRlLmlzSGlkZVVzZXJJbnRlcmZhY2UgPT09IHRydWUgfHwgY3VycmVudEFwcC5zdGF0ZS5lZGl0Vmlld01vZGUgPT09IEVkaXRWaWV3TW9kZS5QYWdlUHJldmlld09ubHkpIHtcclxuICAgICAgICAgICAgLy8gVE9ETyB2ZXJpZnkgdGhpcyB3b3JrcyBldmVyeXdoZXJlXHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuYXZhaWxhYmxlU3BhY2VQYWdlUHJldmlld1B4ID0gY3VycmVudEFwcC5wYWdlUHJldmlld0hvbGRlciAhPT0gdW5kZWZpbmVkID8gd2luZG93LmlubmVyV2lkdGggKyAyICogY3VycmVudEFwcC5zdGF0ZS50YXJnZXRQYWdlUHJldmlld0hvbGRlck1hcmdpblB4IDogMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRBcHAuc3RhdGUuYXZhaWxhYmxlU3BhY2VQYWdlUHJldmlld1B4ID0gY3VycmVudEFwcC5wYWdlUHJldmlld0hvbGRlciAhPT0gdW5kZWZpbmVkID8gY3VycmVudEFwcC5wYWdlUHJldmlld0hvbGRlci5jbGllbnRXaWR0aCArICgyICogY3VycmVudEFwcC5zdGF0ZS50YXJnZXRQYWdlUHJldmlld0hvbGRlck1hcmdpblB4KSA6IDA7IC8vIFRPRE8gdGVzdCByZXN1bHRpbmcgdmFsdWUgY2hhbmdlcyBkZXBlbmRpbmcgb24gY2xpZW50IGJyb3dzZXIvc3lzdGVtIGFyY2hpdGVjdHVyZT9cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdCAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5SZXNwb25zaXZlRGV2aWNlcyAhPT0gdW5kZWZpbmVkICYmIGN1cnJlbnRBcHAuY2xpZW50RGF0YS5DYWxpZm9ybmlhUHJvamVjdC5SZXNwb25zaXZlRGV2aWNlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50QXBwLnBhZ2VQcmV2aWV3Vk0uZWRpdGVkTGF5b3V0QXRvbUlkID09IDApIHsgLy8gVE9ET1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBkaXNhYmxlIHJlc2l6ZSB3aGVuIGVkaXRpbmcgdGV4dCBhcmVhcyBpbiBvdGhlciBjb250cm9scyAoZS5nLiB2YWx1ZSBpbiBwcm9wZXJ0eSBiYXIpXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50QXBwLnBhZ2VQcmV2aWV3LnVwZGF0ZVBhZ2VQcmV2aWV3RGltZW5zaW9ucygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwcml2YXRlIHZhbGlkYXRlUmVzcG9uc2UgPSAocmVzcG9uc2U6IENhbGlmb3JuaWFDbGllbnRWaWV3TW9kZWwpOiBib29sZWFuID0+IHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKHJlc3BvbnNlKTsgLy8gVE9ETyBleGNlcHRpb24gbWFuYWdlbWVudDogd2hlbiBhcHAgdGhyb3dzLCBoYW5ncywgZXRjLiBwcmludCBjdXJyZW50IGRhdGEgc3RhdGUgKG9yIHNhdmUgb24gc2VuZCghISkpXHJcbiAgICAgICAgaWYgKHJlc3BvbnNlID09IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJpbnZhbGlkIGNsaWVudCBkYXRhXCIpOyAvLyBUT0RPXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLlN0YXR1c1RleHQgIT09IG51bGwgJiYgcmVzcG9uc2UuU3RhdHVzVGV4dCAhPT0gXCJcIikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwb25zZS5TdGF0dXNUZXh0KTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjaGVjayByZXZpc2lvblxyXG4gICAgICAgIGlmICgoY3VycmVudEFwcC5jbGllbnREYXRhICE9PSB1bmRlZmluZWQpICYmIChyZXNwb25zZS5DdXJyZW50UmV2aXNpb24gPCBjdXJyZW50QXBwLmNsaWVudERhdGEuQ3VycmVudFJldmlzaW9uKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIklnbm9yaW5nIGNsaWVudCBkYXRhOiByZXZpc2lvbiBpcyBsb3dlclwiKTtcclxuICAgICAgICAgICAgLy8gVE9ETyBtYWtlIHN1cmUgYWxsIG90aGVyIHN0dWZmIHRoYXQgY2FsbHMgdGhpcyBmdW5jdGlvbiBoYW5kbGVzIGNhc2UgY29ycmVjdGx5XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vTW9kZWxzL0NhbGlmb3JuaWFSb3V0ZXIudHN4IiwiXHJcblxyXG5pbXBvcnQge0NvbnRlbnRBdG9tfSBmcm9tIFwiLi9Db250ZW50QXRvbVwiOyBcclxuZXhwb3J0IGNsYXNzIENhbGlmb3JuaWFDbGllbnRQYXJ0aWFsRGF0YSB7IFxyXG4gICAgQ29udGVudEF0b206IENvbnRlbnRBdG9tO1xyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vVHlwZXdyaXRlci9DYWxpZm9ybmlhQ2xpZW50UGFydGlhbERhdGEudHMiXSwic291cmNlUm9vdCI6IiJ9